var VueCompilerCore = (function (exports) {
  "use strict";

  /**
   * Make a map and return a function for checking if a key
   * is in that map.
   * IMPORTANT: all calls of this function must be prefixed with
   * \/\*#\_\_PURE\_\_\*\/
   * So that rollup can tree-shake them if necessary.
   */
  function makeMap(str, expectsLowerCase) {
    const map = Object.create(null);
    const list = str.split(",");
    for (let i = 0; i < list.length; i++) {
      map[list[i]] = true;
    }
    return expectsLowerCase
      ? (val) => !!map[val.toLowerCase()]
      : (val) => !!map[val];
  }

  // Patch flags are optimization hints generated by the compiler.
  // when a block with dynamicChildren is encountered during diff, the algorithm
  // enters "optimized mode". In this mode, we know that the vdom is produced by
  // a render function generated by the compiler, so the algorithm only needs to
  // handle updates explicitly marked by these patch flags.
  // dev only flag -> name mapping
  const PatchFlagNames = {
    [1 /* TEXT */]: `TEXT`,
    [2 /* CLASS */]: `CLASS`,
    [4 /* STYLE */]: `STYLE`,
    [8 /* PROPS */]: `PROPS`,
    [16 /* FULL_PROPS */]: `FULL_PROPS`,
    [32 /* HYDRATE_EVENTS */]: `HYDRATE_EVENTS`,
    [64 /* STABLE_FRAGMENT */]: `STABLE_FRAGMENT`,
    [128 /* KEYED_FRAGMENT */]: `KEYED_FRAGMENT`,
    [256 /* UNKEYED_FRAGMENT */]: `UNKEYED_FRAGMENT`,
    [1024 /* DYNAMIC_SLOTS */]: `DYNAMIC_SLOTS`,
    [512 /* NEED_PATCH */]: `NEED_PATCH`,
    [-1 /* HOISTED */]: `HOISTED`,
    [-2 /* BAIL */]: `BAIL`,
  };

  const range = 2;
  function generateCodeFrame(source, start = 0, end = source.length) {
    const lines = source.split(/\r?\n/);
    let count = 0;
    const res = [];
    for (let i = 0; i < lines.length; i++) {
      count += lines[i].length + 1;
      if (count >= start) {
        for (let j = i - range; j <= i + range || end > count; j++) {
          if (j < 0 || j >= lines.length) continue;
          const line = j + 1;
          res.push(
            `${line}${" ".repeat(Math.max(3 - String(line).length, 0))}|  ${
              lines[j]
            }`
          );
          const lineLength = lines[j].length;
          if (j === i) {
            // push underline
            const pad = start - (count - lineLength) + 1;
            const length = Math.max(
              1,
              end > count ? lineLength - pad : end - start
            );
            res.push(`   |  ` + " ".repeat(pad) + "^".repeat(length));
          } else if (j > i) {
            if (end > count) {
              const length = Math.max(Math.min(end - count, lineLength), 1);
              res.push(`   |  ` + "^".repeat(length));
            }
            count += lineLength + 1;
          }
        }
        break;
      }
    }
    return res.join("\n");
  }

  const EMPTY_OBJ = Object.freeze({});
  const EMPTY_ARR = Object.freeze([]);
  const NOOP = () => {};
  /**
   * Always return false.
   */
  const NO = () => false;
  const extend = Object.assign;
  const isArray = Array.isArray;
  const isString = (val) => typeof val === "string";
  const isSymbol = (val) => typeof val === "symbol";
  const cacheStringFunction = (fn) => {
    const cache = Object.create(null);
    return (str) => {
      const hit = cache[str];
      return hit || (cache[str] = fn(str));
    };
  };
  const hyphenateRE = /\B([A-Z])/g;
  /**
   * @private
   */
  const hyphenate = cacheStringFunction((str) =>
    str.replace(hyphenateRE, "-$1").toLowerCase()
  );

  const FRAGMENT = Symbol(`Fragment`);
  const TELEPORT = Symbol(`Teleport`);
  const SUSPENSE = Symbol(`Suspense`);
  const KEEP_ALIVE = Symbol(`KeepAlive`);
  const BASE_TRANSITION = Symbol(`BaseTransition`);
  const OPEN_BLOCK = Symbol(`openBlock`);
  const CREATE_BLOCK = Symbol(`createBlock`);
  const CREATE_VNODE = Symbol(`createVNode`);
  const CREATE_COMMENT = Symbol(`createCommentVNode`);
  const CREATE_TEXT = Symbol(`createTextVNode`);
  const CREATE_STATIC = Symbol(`createStaticVNode`);
  const RESOLVE_COMPONENT = Symbol(`resolveComponent`);
  const RESOLVE_DYNAMIC_COMPONENT = Symbol(`resolveDynamicComponent`);
  const RESOLVE_DIRECTIVE = Symbol(`resolveDirective`);
  const WITH_DIRECTIVES = Symbol(`withDirectives`);
  const RENDER_LIST = Symbol(`renderList`);
  const RENDER_SLOT = Symbol(`renderSlot`);
  const CREATE_SLOTS = Symbol(`createSlots`);
  const TO_DISPLAY_STRING = Symbol(`toDisplayString`);
  const MERGE_PROPS = Symbol(`mergeProps`);
  const TO_HANDLERS = Symbol(`toHandlers`);
  const CAMELIZE = Symbol(`camelize`);
  const CAPITALIZE = Symbol(`capitalize`);
  const TO_HANDLER_KEY = Symbol(`toHandlerKey`);
  const SET_BLOCK_TRACKING = Symbol(`setBlockTracking`);
  const PUSH_SCOPE_ID = Symbol(`pushScopeId`);
  const POP_SCOPE_ID = Symbol(`popScopeId`);
  const WITH_SCOPE_ID = Symbol(`withScopeId`);
  const WITH_CTX = Symbol(`withCtx`);
  // Name mapping for runtime helpers that need to be imported from 'vue' in
  // generated code. Make sure these are correctly exported in the runtime!
  // Using `any` here because TS doesn't allow symbols as index type.
  const helperNameMap = {
    [FRAGMENT]: `Fragment`,
    [TELEPORT]: `Teleport`,
    [SUSPENSE]: `Suspense`,
    [KEEP_ALIVE]: `KeepAlive`,
    [BASE_TRANSITION]: `BaseTransition`,
    [OPEN_BLOCK]: `openBlock`,
    [CREATE_BLOCK]: `createBlock`,
    [CREATE_VNODE]: `createVNode`,
    [CREATE_COMMENT]: `createCommentVNode`,
    [CREATE_TEXT]: `createTextVNode`,
    [CREATE_STATIC]: `createStaticVNode`,
    [RESOLVE_COMPONENT]: `resolveComponent`,
    [RESOLVE_DYNAMIC_COMPONENT]: `resolveDynamicComponent`,
    [RESOLVE_DIRECTIVE]: `resolveDirective`,
    [WITH_DIRECTIVES]: `withDirectives`,
    [RENDER_LIST]: `renderList`,
    [RENDER_SLOT]: `renderSlot`,
    [CREATE_SLOTS]: `createSlots`,
    [TO_DISPLAY_STRING]: `toDisplayString`,
    [MERGE_PROPS]: `mergeProps`,
    [TO_HANDLERS]: `toHandlers`,
    [CAMELIZE]: `camelize`,
    [CAPITALIZE]: `capitalize`,
    [TO_HANDLER_KEY]: `toHandlerKey`,
    [SET_BLOCK_TRACKING]: `setBlockTracking`,
    [PUSH_SCOPE_ID]: `pushScopeId`,
    [POP_SCOPE_ID]: `popScopeId`,
    [WITH_SCOPE_ID]: `withScopeId`,
    [WITH_CTX]: `withCtx`,
  };
  function registerRuntimeHelpers(helpers) {
    Object.getOwnPropertySymbols(helpers).forEach((s) => {
      helperNameMap[s] = helpers[s];
    });
  }

  function createCodegenContext(
    ast,
    {
      mode = "function",
      prefixIdentifiers = mode === "module",
      sourceMap = false,
      filename = `template.vue.html`,
      scopeId = null,
      optimizeImports = false,
      runtimeGlobalName = `Vue`,
      runtimeModuleName = `vue`,
      ssr = false,
    }
  ) {
    const context = {
      mode,
      prefixIdentifiers,
      sourceMap,
      filename,
      scopeId,
      optimizeImports,
      runtimeGlobalName,
      runtimeModuleName,
      ssr,
      source: ast.loc.source,
      code: ``,
      column: 1,
      line: 1,
      offset: 0,
      indentLevel: 0,
      pure: false,
      map: undefined,
      helper(key) {
        return `_${helperNameMap[key]}`;
      },
      push(code, node) {
        context.code += code;
      },
      indent() {
        newline(++context.indentLevel);
      },
      deindent(withoutNewLine = false) {
        if (withoutNewLine) {
          --context.indentLevel;
        } else {
          newline(--context.indentLevel);
        }
      },
      newline() {
        newline(context.indentLevel);
      },
    };
    function newline(n) {
      context.push("\n" + `  `.repeat(n));
    }
    return context;
  }
  function generate(ast, options = {}) {
    const context = createCodegenContext(ast, options);
    // 上下文创建结束的钩子函数
    if (options.onContextCreated) {
      options.onContextCreated(context);
    }
    const {
      prefixIdentifiers,
      scopeId,
      push,
      ssr,
      mode,
      indent,
      deindent,
      newline,
    } = context;
    const hasHelpers = ast.helpers.length > 0;
    const useWithBlock = !prefixIdentifiers && mode !== "module";
    {
      // -> `function ...`
      genFunctionPreamble(ast, context);
    }
    const optimizeSources = options.bindingMetadata
      ? `, $props, $setup, $data, $options`
      : ``;
    if (!ssr) {
      push(`function render(_ctx, _cache${optimizeSources}) {`);
    }
    indent();
    if (useWithBlock) {
      push(`with (_ctx) {`);
      indent();
      // function mode const declarations should be inside with block
      // also they should be renamed to avoid collision with user properties
      // 重命名引入的函数避免冲突
      if (hasHelpers) {
        push(
          `const { ${ast.helpers
            .map((s) => `${helperNameMap[s]} : _${helperNameMap[s]}`)
            .join(", ")} } = _Vue`
        );
        push(`\n`);
        newline();
      }
    }
    // TODO ast.components, generate asset resolution statements
    // TODO generate directives, ast.directives
    // TODO 临时变量 ast.temps
    // 生成 VNode 树表达式
    if (!ssr) {
      // 这里是真正 render 函数核心，上面都是为了引入变量，函数，imports 等做的处理
      push(`return `);
    }
    if (ast.codegenNode) {
      // genNode 为 codegen 阶段最最最核心函数
      genNode(ast.codegenNode, context);
    } else {
      push(`null`);
    }
    if (useWithBlock) {
      deindent();
      push(`}`);
    }
    deindent();
    push(`}`);
    return {
      ast,
      code: context.code,
      map: context.map ? context.map.toJSON() : undefined,
    };
  }
  function genFunctionPreamble(ast, context) {
    const { push, newline } = context;
    // Generate const declaration for helpers
    // In prefix mode, we place the const declaration at top so it's done
    // only once; But if we not prefixing, we place the declaration inside the
    // with block so it doesn't incur the `in` check cost for every helper access.
    if (ast.helpers.length > 0);
    // TODO gen hoists 静态提升
    newline();
    push(`return `);
  }
  function genNode(node, context) {
    if (isString(node)) {
      // 节点是字符串，直接 code += node
      context.push(node);
      return;
    }
    if (isSymbol(node)) {
      context.push(context.helper(node));
      return;
    }
    switch (node.type) {
      case 2 /* TEXT */:
        genText(node, context);
        break;
    }
  }
  function genText(node, context) {
    context.push(JSON.stringify(node.content), node);
  }

  // AST Utilities ---------------------------------------------------------------
  // Some expressions, e.g. sequence and conditional expressions, are never
  // associated with template nodes, so their source locations are just a stub.
  // Container types like CompoundExpression also don't need a real location.
  const locStub = {
    source: "",
    start: { line: 1, column: 1, offset: 0 },
    end: { line: 1, column: 1, offset: 0 },
  };
  function createRoot(children, loc = locStub) {
    return {
      type: 0 /* ROOT */,
      children,
      helpers: [],
      components: [],
      directives: [],
      hoists: [],
      imports: [],
      cached: 0,
      temps: 0,
      codegenNode: undefined,
      loc,
    };
  }
  function createCallExpression(callee, args = [], loc = locStub) {
    return {
      type: 14 /* JS_CALL_EXPRESSION */,
      loc,
      callee,
      arguments: args,
    };
  }

  function defaultOnError(error) {
    throw error;
  }
  function createCompilerError(code, loc, messages, additionalMessage) {
    const msg = (messages || errorMessages)[code] + (additionalMessage || ``);
    const error = new SyntaxError(String(msg));
    error.code = code;
    error.loc = loc;
    return error;
  }
  const errorMessages = {
    // parse errors
    [0 /* ABRUPT_CLOSING_OF_EMPTY_COMMENT */]: "Illegal comment.",
    [1 /* CDATA_IN_HTML_CONTENT */]: "CDATA section is allowed only in XML context.",
    [2 /* DUPLICATE_ATTRIBUTE */]: "Duplicate attribute.",
    [3 /* END_TAG_WITH_ATTRIBUTES */]: "End tag cannot have attributes.",
    [4 /* END_TAG_WITH_TRAILING_SOLIDUS */]: "Illegal '/' in tags.",
    [5 /* EOF_BEFORE_TAG_NAME */]: "Unexpected EOF in tag.",
    [6 /* EOF_IN_CDATA */]: "Unexpected EOF in CDATA section.",
    [7 /* EOF_IN_COMMENT */]: "Unexpected EOF in comment.",
    [8 /* EOF_IN_SCRIPT_HTML_COMMENT_LIKE_TEXT */]: "Unexpected EOF in script.",
    [9 /* EOF_IN_TAG */]: "Unexpected EOF in tag.",
    [10 /* INCORRECTLY_CLOSED_COMMENT */]: "Incorrectly closed comment.",
    [11 /* INCORRECTLY_OPENED_COMMENT */]: "Incorrectly opened comment.",
    [12 /* INVALID_FIRST_CHARACTER_OF_TAG_NAME */]: "Illegal tag name. Use '&lt;' to print '<'.",
    [13 /* MISSING_ATTRIBUTE_VALUE */]: "Attribute value was expected.",
    [14 /* MISSING_END_TAG_NAME */]: "End tag name was expected.",
    [15 /* MISSING_WHITESPACE_BETWEEN_ATTRIBUTES */]: "Whitespace was expected.",
    [16 /* NESTED_COMMENT */]: "Unexpected '<!--' in comment.",
    [17 /* UNEXPECTED_CHARACTER_IN_ATTRIBUTE_NAME */]: "Attribute name cannot contain U+0022 (\"), U+0027 ('), and U+003C (<).",
    [18 /* UNEXPECTED_CHARACTER_IN_UNQUOTED_ATTRIBUTE_VALUE */]: "Unquoted attribute value cannot contain U+0022 (\"), U+0027 ('), U+003C (<), U+003D (=), and U+0060 (`).",
    [19 /* UNEXPECTED_EQUALS_SIGN_BEFORE_ATTRIBUTE_NAME */]: "Attribute name cannot start with '='.",
    [21 /* UNEXPECTED_QUESTION_MARK_INSTEAD_OF_TAG_NAME */]: "'<?' is allowed only in XML context.",
    [22 /* UNEXPECTED_SOLIDUS_IN_TAG */]: "Illegal '/' in tags.",
    // Vue-specific parse errors
    [23 /* X_INVALID_END_TAG */]: "Invalid end tag.",
    [24 /* X_MISSING_END_TAG */]: "Element is missing end tag.",
    [25 /* X_MISSING_INTERPOLATION_END */]: "Interpolation end sign was not found.",
    [26 /* X_MISSING_DYNAMIC_DIRECTIVE_ARGUMENT_END */]:
      "End bracket for dynamic directive argument was not found. " +
      "Note that dynamic directive argument cannot contain spaces.",
    // transform errors
    [27 /* X_V_IF_NO_EXPRESSION */]: `v-if/v-else-if is missing expression.`,
    [28 /* X_V_IF_SAME_KEY */]: `v-if/else branches must use unique keys.`,
    [29 /* X_V_ELSE_NO_ADJACENT_IF */]: `v-else/v-else-if has no adjacent v-if.`,
    [30 /* X_V_FOR_NO_EXPRESSION */]: `v-for is missing expression.`,
    [31 /* X_V_FOR_MALFORMED_EXPRESSION */]: `v-for has invalid expression.`,
    [32 /* X_V_FOR_TEMPLATE_KEY_PLACEMENT */]: `<template v-for> key should be placed on the <template> tag.`,
    [33 /* X_V_BIND_NO_EXPRESSION */]: `v-bind is missing expression.`,
    [34 /* X_V_ON_NO_EXPRESSION */]: `v-on is missing expression.`,
    [35 /* X_V_SLOT_UNEXPECTED_DIRECTIVE_ON_SLOT_OUTLET */]: `Unexpected custom directive on <slot> outlet.`,
    [36 /* X_V_SLOT_MIXED_SLOT_USAGE */]:
      `Mixed v-slot usage on both the component and nested <template>.` +
      `When there are multiple named slots, all slots should use <template> ` +
      `syntax to avoid scope ambiguity.`,
    [37 /* X_V_SLOT_DUPLICATE_SLOT_NAMES */]: `Duplicate slot names found. `,
    [38 /* X_V_SLOT_EXTRANEOUS_DEFAULT_SLOT_CHILDREN */]:
      `Extraneous children found when component already has explicitly named ` +
      `default slot. These children will be ignored.`,
    [39 /* X_V_SLOT_MISPLACED */]: `v-slot can only be used on components or <template> tags.`,
    [40 /* X_V_MODEL_NO_EXPRESSION */]: `v-model is missing expression.`,
    [41 /* X_V_MODEL_MALFORMED_EXPRESSION */]: `v-model value must be a valid JavaScript member expression.`,
    [42 /* X_V_MODEL_ON_SCOPE_VARIABLE */]: `v-model cannot be used on v-for or v-slot scope variables because they are not writable.`,
    [43 /* X_INVALID_EXPRESSION */]: `Error parsing JavaScript expression: `,
    [44 /* X_KEEP_ALIVE_INVALID_CHILDREN */]: `<KeepAlive> expects exactly one child component.`,
    // generic errors
    [45 /* X_PREFIX_ID_NOT_SUPPORTED */]: `"prefixIdentifiers" option is not supported in this build of compiler.`,
    [46 /* X_MODULE_MODE_NOT_SUPPORTED */]: `ES module mode is not supported in this build of compiler.`,
    [47 /* X_CACHE_HANDLER_NOT_SUPPORTED */]: `"cacheHandlers" option is only supported when the "prefixIdentifiers" option is enabled.`,
    [48 /* X_SCOPE_ID_NOT_SUPPORTED */]: `"scopeId" option is only supported in module mode.`,
  };

  const isBuiltInType = (tag, expected) =>
    tag === expected || tag === hyphenate(expected);
  function isCoreComponent(tag) {
    if (isBuiltInType(tag, "Teleport")) {
      return TELEPORT;
    } else if (isBuiltInType(tag, "Suspense")) {
      return SUSPENSE;
    } else if (isBuiltInType(tag, "KeepAlive")) {
      return KEEP_ALIVE;
    } else if (isBuiltInType(tag, "BaseTransition")) {
      return BASE_TRANSITION;
    }
  }
  const nonIdentifierRE = /^\d|[^\$\w]/;
  const isSimpleIdentifier = (name) => !nonIdentifierRE.test(name);
  function advancePositionWithClone(
    pos,
    source,
    numberOfCharacters = source.length
  ) {
    return advancePositionWithMutation(
      extend({}, pos),
      source,
      numberOfCharacters
    );
  }
  // advance by mutation without cloning (for performance reasons), since this
  // gets called a lot in the parser
  function advancePositionWithMutation(
    pos,
    source,
    numberOfCharacters = source.length
  ) {
    let linesCount = 0;
    let lastNewLinePos = -1;
    for (let i = 0; i < numberOfCharacters; i++) {
      if (source.charCodeAt(i) === 10 /* newline char code */) {
        linesCount++;
        lastNewLinePos = i;
      }
    }
    pos.offset += numberOfCharacters;
    pos.line += linesCount;
    pos.column =
      lastNewLinePos === -1
        ? pos.column + numberOfCharacters
        : numberOfCharacters - lastNewLinePos;
    return pos;
  }
  function assert(condition, msg) {
    /* istanbul ignore if */
    if (!condition) {
      throw new Error(msg || `unexpected compiler condition`);
    }
  }
  function isText(node) {
    return node.type === 5 /* INTERPOLATION */ || node.type === 2 /* TEXT */;
  }
  function isSlotOutlet(node) {
    return node.type === 1 /* ELEMENT */ && node.tagType === 2 /* SLOT */;
  }

  // The default decoder only provides escapes for characters reserved as part of
  // the template syntax, and is only used if the custom renderer did not provide
  // a platform-specific decoder.
  const decodeRE = /&(gt|lt|amp|apos|quot);/g;
  const decodeMap = {
    gt: ">",
    lt: "<",
    amp: "&",
    apos: "'",
    quot: '"',
  };
  const defaultParserOptions = {
    delimiters: [`{{`, `}}`],
    getNamespace: () => 0 /* HTML */,
    getTextMode: () => 0 /* DATA */,
    isVoidTag: NO,
    isPreTag: NO,
    isCustomElement: NO,
    decodeEntities: (rawText) =>
      rawText.replace(decodeRE, (_, p1) => decodeMap[p1]),
    onError: defaultOnError,
    comments: false,
  };
  function baseParse(content, options) {
    const context = createParserContext(content, options);
    const start = getCursor(context);
    return createRoot(
      parseChildren(context, 0 /* DATA */, []),
      getSelection(context, start)
    );
  }
  function createParserContext(content, rawOptions) {
    const options = extend({}, defaultParserOptions);
    for (const key in rawOptions) {
      // @ts-ignore
      options[key] = rawOptions[key] || defaultParserOptions[key];
    }
    return {
      options,
      column: 1,
      line: 1,
      offset: 0,
      originalSource: content,
      source: content,
      inPre: false,
      inVPre: false,
    };
  }
  function parseChildren(context, mode, ancestors) {
    const parent = last(ancestors);
    const ns = parent ? parent.ns : 0; /* HTML */
    const nodes = [];
    while (!isEnd(context, mode, ancestors)) {
      const s = context.source;
      let node = undefined;
      if (mode === 0 /* DATA */ || mode === 1 /* RCDATA */) {
        if (!context.inVPre && startsWith(s, context.options.delimiters[0])) {
          // '{{'
          node = parseInterpolation(context, mode);
        } else if (mode === 0 /* DATA */ && s[0] === "<") {
          // https://html.spec.whatwg.org/multipage/parsing.html#tag-open-state
          if (s.length === 1) {
            emitError(context, 5 /* EOF_BEFORE_TAG_NAME */, 1);
          } else if (s[1] === "!") {
            // <!
            if (startsWith(s, "<!--")) {
              // 注释
              node = parseComment(context);
            } else if (startsWith(s, "<!DOCTYPE")) {
              node = parseBogusComment(context);
            } else if (startsWith(s, "<![CDATA[")) {
              if (ns !== 0 /* HTML */) {
                node = parseCDATA(context, ancestors);
              } else {
                emitError(context, 1 /* CDATA_IN_HTML_CONTENT */);
                node = parseBogusComment(context);
              }
            } else {
              emitError(context, 11 /* INCORRECTLY_OPENED_COMMENT */);
              node = parseBogusComment(context);
            }
          } else if (s[1] === "/") {
            // end tag, </
            if (s.length === 2) {
              emitError(context, 5 /* EOF_BEFORE_TAG_NAME */, 2);
            } else if (s[2] === ">") {
              // </>
              emitError(context, 14 /* MISSING_END_TAG_NAME */, 2);
              advanceBy(context, 3);
              continue;
            } else if (/[a-z]/i.test(s[2])) {
              // 非法结束标签，因为结束标签会直接在 parseElement 解析完成
              emitError(context, 23 /* X_INVALID_END_TAG */);
              parseTag(context, 1 /* End */, parent);
              continue;
            } else {
              // 无效的标签名称
              emitError(
                context,
                12 /* INVALID_FIRST_CHARACTER_OF_TAG_NAME */,
                2
              );
              node = parseBogusComment(context);
            }
          } else if (/[a-z]/i.test(s[1])) {
            // 开始标签
            node = parseElement(context, ancestors);
          } else if (s[1] === "?") {
            emitError(
              context,
              21 /* UNEXPECTED_QUESTION_MARK_INSTEAD_OF_TAG_NAME */,
              1
            );
            node = parseBogusComment(context);
          } else {
            emitError(context, 12 /* INVALID_FIRST_CHARACTER_OF_TAG_NAME */, 1);
          }
        }
      }
      // 纯文本节点
      if (!node) {
        node = parseText(context, mode);
      }
      if (isArray(node)) {
        for (let i = 0; i < node.length; i++) {
          pushNode(nodes, node[i]);
        }
      } else {
        pushNode(nodes, node);
      }
    }
    let removedWhitespace = false;
    // 空格和空字符串节点合并
    if (mode !== 2 /* RAWTEXT */) {
      for (let i = 0; i < nodes.length; i++) {
        const node = nodes[i];
        if (!context.inPre && node.type === 2 /* TEXT */) {
          if (!/[^\t\r\n\f ]/.test(node.content)) {
            const prev = nodes[i - 1];
            const next = nodes[i + 1];
            // If:
            // - the whitespace is the first or last node, or:
            // - the whitespace is adjacent to a comment, or:
            // - the whitespace is between two elements AND contains newline
            // Then the whitespace is ignored.
            if (
              !prev ||
              !next ||
              prev.type === 3 /* COMMENT */ ||
              next.type === 3 /* COMMENT */ ||
              (prev.type === 1 /* ELEMENT */ &&
                next.type === 1 /* ELEMENT */ &&
                /[\r\n]/.test(node.content))
            ) {
              removedWhitespace = true;
              nodes[i] = null;
            } else {
              // Otherwise, condensed consecutive whitespace inside the text
              // down to a single space
              node.content = " ";
            }
          } else {
            // 空格合并从一个
            node.content = node.content.replace(/[\t\r\n\f ]+/g, " ");
          }
        }
      }
      if (context.inPre && parent && context.options.isPreTag(parent.tag)) {
        // 删除首行空行
        // remove leading newline per html spec
        // https://html.spec.whatwg.org/multipage/grouping-content.html#the-pre-element
        const first = nodes[0];
        if (first && first.type === 2 /* TEXT */) {
          first.content = first.content.replace(/^\r?\n/, "");
        }
      }
    }
    return removedWhitespace ? nodes.filter(Boolean) : nodes;
  }
  function pushNode(nodes, node) {
    if (node.type === 2 /* TEXT */) {
      // 合并两个相邻的文本内容
      const prev = last(nodes);
      // Merge if both this and the previous node are text and those are
      // consecutive. This happens for cases like "a < b".
      if (
        prev &&
        prev.type === 2 /* TEXT */ &&
        prev.loc.end.offset === node.loc.start.offset
      ) {
        prev.content += node.content;
        prev.loc.end = node.loc.end;
        prev.loc.source += node.loc.source;
        return;
      }
    }
    nodes.push(node);
  }
  function parseCDATA(context, ancestors) {
    advanceBy(context, 9);
    const nodes = parseChildren(context, 3 /* CDATA */, ancestors);
    if (context.source.length === 0) {
      emitError(context, 6 /* EOF_IN_CDATA */);
    } else {
      advanceBy(context, 3);
    }
    return nodes;
  }
  function parseComment(context) {
    const start = getCursor(context);
    let content;
    const match = /--(\!)?>/.exec(context.source);
    if (!match) {
      // 非法注释
      content = context.source.slice(4);
      advanceBy(context, context.source.length);
      emitError(context, 7 /* EOF_IN_COMMENT */);
    } else {
      if (match.index <= 3) {
        // 不满足 <!-- -->
        emitError(context, 0 /* ABRUPT_CLOSING_OF_EMPTY_COMMENT */);
      }
      if (match[1]) {
        // 非法结束 <!-- --!>
        emitError(context, 10 /* INCORRECTLY_CLOSED_COMMENT */);
      }
      // 注释内容
      content = context.source.slice(4, match.index);
      // 嵌套注释
      const s = context.source.slice(0, match.index);
      let prevIndex = 1,
        nestedIndex = 0;
      while ((nestedIndex = s.indexOf("<!--", prevIndex)) !== -1) {
        advanceBy(context, nestedIndex - prevIndex + 1);
        if (nestedIndex + 4 < s.length) {
          emitError(context, 16 /* NESTED_COMMENT */);
        }
        prevIndex = nestedIndex + 1;
      }
      advanceBy(context, match.index + match[0].length - prevIndex + 1);
    }
    return {
      type: 3 /* COMMENT */,
      content,
      loc: getSelection(context, start),
    };
  }
  function parseBogusComment(context) {
    const start = getCursor(context);
    const contentStart = context.source[1] === "?" ? 1 : 2;
    let content;
    // 结束
    const closeIndex = context.source.indexOf(">");
    if (closeIndex === -1) {
      content = context.source.slice(contentStart);
      advanceBy(context, context.source.length);
    } else {
      content = context.source.slice(contentStart, closeIndex);
      advanceBy(context, closeIndex + 1);
    }
    return {
      type: 3 /* COMMENT */,
      content,
      loc: getSelection(context, start),
    };
  }
  function parseElement(context, ancestors) {
    const wasInPre = context.inPre;
    const wasInVPre = context.inVPre;
    const parent = last(ancestors);
    // 解析出开始标签
    const element = parseTag(context, 0 /* Start */, parent);
    const isPreBoundray = context.inPre && !wasInPre;
    const isVPreBoundray = context.inVPre && !wasInVPre;
    if (element.isSelfClosing || context.options.isVoidTag(element.tag)) {
      return element;
    }
    ancestors.push(element);
    const mode = context.options.getTextMode(element, parent);
    const children = parseChildren(context, mode, ancestors);
    // 要将孩子节点解析完成的 parent element pop 掉，待处理下一个 parent 的 children
    ancestors.pop();
    element.children = children;
    if (startsWithEndTagOpen(context.source, element.tag)) {
      // 结束标签
      parseTag(context, 1 /* End */, parent);
    } else {
      emitError(context, 24 /* X_MISSING_END_TAG */, 0, element.loc.start);
      if (
        context.source.length === 0 &&
        element.tag.toLowerCase() === "script"
      ) {
        const first = children[0];
        if (first && startsWith(first.loc.source, "<!--")) {
          emitError(context, 8 /* EOF_IN_SCRIPT_HTML_COMMENT_LIKE_TEXT */);
        }
      }
    }
    element.loc = getSelection(context, element.loc.start);
    if (isPreBoundray) {
      context.inPre = false;
    }
    if (isVPreBoundray) {
      context.inVPre = false;
    }
    return element;
  }
  const isSpecialTemplateDirective = /*#__PURE__*/ makeMap(
    `if,else,else-if,for,slot`
  );
  function parseTag(context, type, parent) {
    // 开始标签
    const start = getCursor(context);
    const match = /^<\/?([a-z][^\t\r\n\f />]*)/i.exec(context.source);
    const tag = match[1];
    const ns = context.options.getNamespace(tag, parent);
    advanceBy(context, match[0].length);
    advanceSpaces(context);
    // 保存当前状态，待会需要回过头来解析属性
    const cursor = getCursor(context);
    const currentSource = context.source;
    // 解析属性
    let props = parseAttributes(context, type);
    if (context.options.isPreTag(tag)) {
      context.inPre = true;
    }
    // v-pre 指令, 需要有上面的属性解析步骤
    if (
      !context.inVPre &&
      props.some((p) => p.type === 7 /* DIRECTIVE */ && p.name === "pre")
    ) {
      context.inVPre = true;
      extend(context, cursor);
      context.source = currentSource;
      // 重新解析属性并且将 v-pre 过滤出来
      props = parseAttributes(context, type).filter((p) => p.name !== "v-pre");
    }
    // 结束标签
    let isSelfClosing = false;
    if (context.source.length === 0) {
      emitError(context, 9 /* EOF_IN_TAG */);
    } else {
      // <div ... />
      isSelfClosing = startsWith(context.source, "/>");
      // 到这里不应该是 End 标签
      if (type === 1 /* End */ && isSelfClosing) {
        emitError(context, 4 /* END_TAG_WITH_TRAILING_SOLIDUS */);
      }
      advanceBy(context, isSelfClosing ? 2 : 1);
    }
    let tagType = 0; /* ELEMENT */
    const options = context.options;
    // 标签类型解析，非 v-pre 元素且不是自定义类型
    if (!context.inVPre && !options.isCustomElement(tag)) {
      // v-is
      const hasVIs = props.some(
        (p) => p.type === 7 /* DIRECTIVE */ && p.name === "is"
      );
      if (options.isNativeTag && !hasVIs) {
        if (!options.isNativeTag(tag)) {
          tagType = 1 /* COMPONENT */;
        }
      } else if (
        hasVIs ||
        isCoreComponent(tag) ||
        (options.isBuiltInComponent && options.isBuiltInComponent(tag)) ||
        /^[A-Z]/.test(tag) ||
        tag === "component"
      ) {
        tagType = 1 /* COMPONENT */;
      }
      if (tag === "slot") {
        tagType = 2 /* SLOT */;
      } else if (
        tag === "template" &&
        props.some((p) => {
          return (
            p.type === 7 /* DIRECTIVE */ && isSpecialTemplateDirective(p.name)
          );
        })
      ) {
        tagType = 3 /* TEMPLATE */;
      }
    }
    return {
      type: 1 /* ELEMENT */,
      ns,
      tag,
      tagType,
      props,
      isSelfClosing,
      children: [],
      loc: getSelection(context, start),
      codegenNode: undefined,
    };
  }
  function parseAttributes(context, type) {
    const props = [];
    const attributeNames = new Set();
    while (
      context.source.length > 0 &&
      !startsWith(context.source, ">") &&
      !startsWith(context.source, "/>")
    ) {
      if (startsWith(context.source, "/")) {
        emitError(context, 22 /* UNEXPECTED_SOLIDUS_IN_TAG */);
        advanceBy(context, 1);
        advanceSpaces(context);
        continue;
      }
      if (type === 1 /* End */) {
        emitError(context, 3 /* END_TAG_WITH_ATTRIBUTES */);
      }
      const attr = parseAttribute(context, attributeNames);
      if (type === 0 /* Start */) {
        props.push(attr);
      }
      // 必须有空格分割属性
      if (/^[^\t\r\n\f />]/.test(context.source)) {
        emitError(context, 15 /* MISSING_WHITESPACE_BETWEEN_ATTRIBUTES */);
      }
      advanceSpaces(context);
    }
    return props;
  }
  function parseAttribute(context, nameSet) {
    // 属性名
    const start = getCursor(context);
    // 匹配等号前的内容，属性名
    const match = /^[^\t\r\n\f />][^\t\r\n\f />=]*/.exec(context.source);
    const name = match[0];
    if (nameSet.has(name)) {
      emitError(context, 2 /* DUPLICATE_ATTRIBUTE */);
    }
    nameSet.add(name);
    if (name[0] === "=") {
      // 不能用 `=` 做属性名
      emitError(context, 19 /* UNEXPECTED_EQUALS_SIGN_BEFORE_ATTRIBUTE_NAME */);
    }
    {
      const pattern = /["'<]/g;
      let m;
      // 属性名中不能有 ", ', <
      while ((m = pattern.exec(name))) {
        emitError(
          context,
          17 /* UNEXPECTED_CHARACTER_IN_ATTRIBUTE_NAME */,
          m.index
        );
      }
    }
    advanceBy(context, name.length);
    let value = undefined;
    if (/^[\t\r\n\f ]*=/.test(context.source)) {
      advanceSpaces(context);
      advanceBy(context, 1); // =
      advanceSpaces(context); // = 后面的空格
      // 解析出属性值
      value = parseAttributeValue(context);
      if (!value) {
        emitError(context, 13 /* MISSING_ATTRIBUTE_VALUE */);
      }
    }
    const loc = getSelection(context, start);
    if (!context.inVPre && /^(v-|:|@|#)/.test(name)) {
      // 指令匹配，四个捕获组含义
      // 1. v-bind,v-for,v-if
      // 2. :, @, # 指令缩写
      // 3. [name] 动态属性名
      // 4. name.modifier 修饰符
      const match = /(?:^v-([a-z0-9]+))?(?:(?::|^@|^#)(\[[^\]]+\]|[^\.]+))?(.+)?$/i.exec(
        name
      );
      // 缩写指令替换成指令单词
      const dirName =
        match[1] ||
        (startsWith(name, ":")
          ? "bind"
          : startsWith(name, "@")
          ? "on"
          : "slot");
      let arg;
      if (match[2]) {
        const isSlot = dirName === "slot";
        const startOffset = name.indexOf(match[2]);
        const loc = getSelection(
          context,
          getNewPosition(context, start, startOffset),
          getNewPosition(
            context,
            start,
            startOffset + match[2].length + ((isSlot && match[3]) || "").length
          )
        );
        let content = match[2];
        let isStatic = true;
        if (content.startsWith("[")) {
          isStatic = false;
          if (!content.endsWith("]")) {
            emitError(
              context,
              26 /* X_MISSING_DYNAMIC_DIRECTIVE_ARGUMENT_END */
            );
          }
          content = content.substr(1, content.length - 2);
        } else if (isSlot) {
          // #1241 special case for v-slot: vuetify relies extensively on slot
          // names containing dots. v-slot doesn't have any modifiers and Vue 2.x
          // supports such usage so we are keeping it consistent with 2.x.
          content += match[3] || "";
        }
        arg = {
          type: 4 /* SIMPLE_EXPRESSION */,
          content,
          isStatic,
          isConstant: isStatic,
          loc,
        };
      }
      if (value && value.isQuoted) {
        const valueLoc = value.loc;
        valueLoc.start.offset++;
        valueLoc.start.column++;
        valueLoc.end = advancePositionWithClone(valueLoc.start, value.content);
        valueLoc.source = valueLoc.source.slice(1, -1);
      }
      return {
        type: 7 /* DIRECTIVE */,
        name: dirName,
        exp: value && {
          type: 4 /* SIMPLE_EXPRESSION */,
          content: value.content,
          isStatic: false,
          // Treat as non-constant by default. This can be potentially set to
          // true by `transformExpression` to make it eligible for hoisting.
          isConstant: false,
          loc: value.loc,
        },
        arg,
        modifiers: match[3] ? match[3].substr(1).split(".") : [],
        loc,
      };
    }
    return {
      type: 6 /* ATTRIBUTE */,
      name,
      value: value && {
        type: 2 /* TEXT */,
        content: value.content,
        loc: value.loc,
      },
      loc,
    };
  }
  function parseAttributeValue(context) {
    const start = getCursor(context);
    let content;
    const quote = context.source[0];
    const isQuoted = quote === `"` || quote === `'`;
    if (isQuoted) {
      // Quoted value.
      advanceBy(context, 1);
      const endIndex = context.source.indexOf(quote);
      if (endIndex === -1) {
        content = parseTextData(
          context,
          context.source.length,
          4 /* ATTRIBUTE_VALUE */
        );
      } else {
        content = parseTextData(context, endIndex, 4 /* ATTRIBUTE_VALUE */);
        advanceBy(context, 1);
      }
    } else {
      // Unquoted
      const match = /^[^\t\r\n\f >]+/.exec(context.source);
      if (!match) {
        return undefined;
      }
      const unexpectedChars = /["'<=`]/g;
      let m;
      while ((m = unexpectedChars.exec(match[0]))) {
        emitError(
          context,
          18 /* UNEXPECTED_CHARACTER_IN_UNQUOTED_ATTRIBUTE_VALUE */,
          m.index
        );
      }
      content = parseTextData(
        context,
        match[0].length,
        4 /* ATTRIBUTE_VALUE */
      );
    }
    return { content, isQuoted, loc: getSelection(context, start) };
  }
  function parseInterpolation(context, mode) {
    const [open, close] = context.options.delimiters;
    const closeIndex = context.source.indexOf(close, open.length);
    if (closeIndex === -1) {
      emitError(context, 25 /* X_MISSING_INTERPOLATION_END */);
      return undefined;
    }
    const start = getCursor(context);
    advanceBy(context, open.length);
    const innerStart = getCursor(context);
    const innerEnd = getCursor(context);
    // 插值内容长度
    const rawContentLength = closeIndex - open.length;
    const rawContent = context.source.slice(0, rawContentLength);
    // html 语义化符号替换
    const preTrimContent = parseTextData(context, rawContentLength, mode);
    // 去掉前后空格
    const content = preTrimContent.trim();
    // 去掉空格后的内容所在的索引位置
    const startOffset = preTrimContent.indexOf(content);
    if (startOffset > 0) {
      advancePositionWithMutation(innerStart, rawContent, startOffset);
    }
    const endOffset =
      rawContentLength - (preTrimContent.length - content.length - startOffset);
    advancePositionWithMutation(innerEnd, rawContent, endOffset);
    advanceBy(context, close.length);
    return {
      type: 5 /* INTERPOLATION */,
      content: {
        type: 4 /* SIMPLE_EXPRESSION */,
        isStatic: false,
        isConstant: false,
        content,
        loc: getSelection(context, innerStart, innerEnd),
      },
      loc: getSelection(context, start),
    };
  }
  function parseText(context, mode) {
    const endTokens = ["<", context.options.delimiters[0]];
    if (mode === 3 /* CDATA */) {
      endTokens.push("]]>");
    }
    let endIndex = context.source.length;
    // 找到遇到的第一个结束符 }}, <
    for (let i = 0; i < endTokens.length; i++) {
      const index = context.source.indexOf(endTokens[i], 1);
      if (index !== -1 && endIndex > index) {
        endIndex = index;
      }
    }
    const start = getCursor(context);
    const content = parseTextData(context, endIndex, mode);
    return {
      type: 2 /* TEXT */,
      content,
      loc: getSelection(context, start),
    };
  }
  /**
   * Get text data with a given length from the current location.
   * This translates HTML entities in the text data.
   */
  function parseTextData(context, length, mode) {
    const rawText = context.source.slice(0, length);
    advanceBy(context, length);
    if (
      mode === 2 /* RAWTEXT */ ||
      mode === 3 /* CDATA */ ||
      rawText.indexOf("&") === -1
    ) {
      return rawText;
    } else {
      // DATA or RCDATA containing "&"". Entity decoding required.
      return context.options.decodeEntities(
        rawText,
        mode === 4 /* ATTRIBUTE_VALUE */
      );
    }
  }
  function getCursor(context) {
    const { column, line, offset } = context;
    return { column, line, offset };
  }
  function getSelection(context, start, end) {
    end = end || getCursor(context);
    return {
      start,
      end,
      source: context.originalSource.slice(start.offset, end.offset),
    };
  }
  function last(xs) {
    return xs[xs.length - 1];
  }
  function startsWith(source, searchString) {
    return source.startsWith(searchString);
  }
  function advanceBy(context, numberOfCharacters) {
    const { source } = context;
    advancePositionWithMutation(context, source, numberOfCharacters);
    context.source = source.slice(numberOfCharacters);
  }
  function advanceSpaces(context) {
    const match = /^[\t\r\n\f ]+/.exec(context.source);
    if (match) {
      advanceBy(context, match[0].length);
    }
  }
  function getNewPosition(context, start, numberOfCharacters) {
    return advancePositionWithClone(
      start,
      context.originalSource.slice(start.offset, numberOfCharacters),
      numberOfCharacters
    );
  }
  function emitError(context, code, offset, loc = getCursor(context)) {
    if (offset) {
      loc.offset += offset;
      loc.column += offset;
    }
    context.options.onError(
      createCompilerError(code, {
        start: loc,
        end: loc,
        source: "",
      })
    );
  }
  function isEnd(context, mode, ancestors) {
    const s = context.source;
    switch (mode) {
      case 0 /* DATA */:
        if (startsWith(s, "</")) {
          //TODO: probably bad performance
          for (let i = ancestors.length - 1; i >= 0; --i) {
            if (startsWithEndTagOpen(s, ancestors[i].tag)) {
              return true;
            }
          }
        }
        break;
      case 1 /* RCDATA */:
      case 2 /* RAWTEXT */: {
        const parent = last(ancestors);
        if (parent && startsWithEndTagOpen(s, parent.tag)) {
          return true;
        }
        break;
      }
      case 3 /* CDATA */:
        if (startsWith(s, "]]>")) {
          return true;
        }
        break;
    }
    return !s;
  }
  function startsWithEndTagOpen(source, tag) {
    return (
      startsWith(source, "</") &&
      source.substr(2, tag.length).toLowerCase() === tag.toLowerCase() &&
      /[\t\r\n\f />]/.test(source[2 + tag.length] || ">")
    );
  }

  function isSingleElementRoot(root, child) {
    const { children } = root;
    return (
      children.length === 1 &&
      child.type === 1 /* ELEMENT */ &&
      !isSlotOutlet(child)
    );
  }

  function createTransformContext(
    root,
    {
      prefixIdentifiers = false,
      hoistStatic = false,
      cacheHandlers = false,
      nodeTransforms = [],
      directiveTransforms = {},
      transformHoist = null,
      isBuiltInComponent = NOOP,
      isCustomElement = NOOP,
      expressionPlugins = [],
      scopeId = null,
      ssr = false,
      ssrCssVars = ``,
      bindingMetadata = {},
      onError = defaultOnError,
    }
  ) {
    const context = {
      // options
      prefixIdentifiers,
      hoistStatic,
      cacheHandlers,
      nodeTransforms,
      directiveTransforms,
      transformHoist,
      isBuiltInComponent,
      isCustomElement,
      expressionPlugins,
      scopeId,
      ssr,
      ssrCssVars,
      bindingMetadata,
      onError,
      // state
      root,
      helpers: new Set(),
      components: new Set(),
      directives: new Set(),
      hoists: [],
      imports: new Set(),
      temps: 0,
      cached: 0,
      identifiers: Object.create(null),
      scopes: {
        vFor: 0,
        vSlot: 0,
        vPre: 0,
        vOnce: 0,
      },
      parent: null,
      currentNode: root,
      childIndex: 0,
      // methods
      helper(name) {
        context.helpers.add(name);
        return name;
      },
      helperString(name) {
        return ``;
      },
      replaceNode(node) {},
      removeNode(node) {},
      onNodeRemoved: () => {},
      addIdentifiers(exp) {
        // TODO
      },
      removeIdentifiers(exp) {
        // TODO
      },
      hoist(exp) {
        // TODO
        return {};
      },
      cache(exp, isVNode = false) {
        // TODO
        return {};
      },
    };
    return context;
  }
  function transform(root, options) {
    const context = createTransformContext(root, options);
    traverseNode(root, context);
    if (options.hoistStatic);
    if (!options.ssr) {
      createRootCodegen(root);
    }
    root.helpers = [...context.helpers];
    root.components = [...context.components];
    root.directives = [...context.directives];
    root.imports = [...context.imports];
    root.hoists = context.hoists;
    root.temps = context.temps;
    root.cached = context.cached;
  }
  function createRootCodegen(root, context) {
    // const { helper } = context
    const { children } = root;
    if (children.length === 1) {
      // 只有一个孩子节点，直接取该孩子节点 的 codegenNode
      const child = children[0];
      if (isSingleElementRoot(root, child) && child.codegenNode);
      else {
        // - single <slot/>, IfNode, ForNode: already blocks.
        // - single text node: always patched.
        // root codegen falls through via genNode()
        root.codegenNode = child;
      }
    } else if (children.length > 1);
    else;
  }
  function traverseNode(node, context) {
    // 保存当前被处理的 节点
    context.currentNode = node;
    // 应用 transform 插件
    const { nodeTransforms } = context;
    // 针对每个节点会收集到一个或多个 transformXxx 函数，用来解析它的 ast
    // 得到 codegenNode ，这些函数会在当前的节点树被递归遍历完之后调用
    const exitFns = [];
    for (let i = 0; i < nodeTransforms.length; i++) {
      const onExit = nodeTransforms[i](node, context);
      if (onExit) {
        if (isArray(onExit)) {
          exitFns.push(...onExit);
        } else {
          exitFns.push(onExit);
        }
      }
      if (!context.currentNode) {
        // 节点可能被删除了，比如： v-else-if, v-else 会合并到 v-if 的 branches[] 中
        return;
      } else {
        // 节点可能会替换了，需要更新
        node = context.currentNode;
      }
    }
    switch (
      node.type
      // TODO
    ) {
    }
    context.currentNode = node;
    let i = exitFns.length;
    while (i--) {
      exitFns[i]();
    }
  }
  function createStructuralDirectiveTransform(name, fn) {
    return {};
  }

  // 合并相邻的文本节点(包含插值)
  // Merge adjacent text nodes and expressions into a single expression
  // e.g. <div>abc {{ d }} {{ e }}</div> should have a single expression node as child.
  const transformText = (node, context) => {
    // 只有这四种类型才会收集这个函数
    if (
      node.type === 0 /* ROOT */ ||
      node.type === 1 /* ELEMENT */ ||
      node.type === 11 /* FOR */ ||
      node.type === 10 /* IF_BRANCH */
    ) {
      // perform the transform on node exit so that all expressions have already
      // been processed.
      return () => {
        const children = node.children;
        // let currentContainer: CompoundExpressionNode | undefined = undefined
        let hasText = false;
        // 遍历所有孩子节点，合并文本
        for (let i = 0; i < children.length; i++) {
          const child = children[i];
          if (isText(child)) {
            hasText = true;
            // TODO 合并
          }
        }
        // 不处理的几种情况
        // 1. hasText = false ，压根没有文本节点
        // 2. 只有一个 child 且类型必须是 ROOT 或 type, tagType 都是 ELEMENT的标签
        if (
          !hasText ||
          (children.length === 1 &&
            (node.type === 0 /* ROOT */ ||
              (node.type === 1 /* ELEMENT */ &&
                node.tagType === 0))) /* ELEMENT */
        ) {
          return;
        }
        // 将文本节点转换成用 createTextVNode(text) 创建
        for (let i = 0; i < children.length; i++) {
          const child = children[i];
          if (isText(child) || child.type === 8 /* COMPOUND_EXPRESSION */) {
            const callArgs = [];
            // createTextVNode defaults to single whitespace, so if it is a
            // single space the code could be an empty call to save bytes.
            if (child.type !== 2 /* TEXT */ || child.content !== " ") {
              callArgs.push(child);
            }
            // mark dynamic text with flag so it gets patched inside a block
            if (!context.ssr && child.type !== 2 /* TEXT */) {
              callArgs.push(
                `${1 /* TEXT */} /* ${PatchFlagNames[1 /* TEXT */]} */`
              );
            }
            children[i] = {
              type: 12 /* TEXT_CALL */,
              content: child,
              loc: child.loc,
              codegenNode: createCallExpression(
                context.helper(CREATE_TEXT),
                callArgs
              ),
            };
          }
        }
      };
    }
  };

  // 合并 transform 插件列表
  function getBaseTransformPreset(prefixIdentifiers) {
    return [[transformText], {}];
  }
  function baseCompile(template, options = {}) {
    // const onError = options.onError || defaultOnError
    const isModuleMode = options.mode === "module";
    const prefixIdentifiers = !true;
    // TODO errors
    const ast = isString(template) ? baseParse(template, options) : template;
    const [nodeTransforms, directiveTransforms] = getBaseTransformPreset();
    transform(
      ast,
      extend({}, options, {
        prefixIdentifiers,
        nodeTransforms: [
          ...nodeTransforms,
          ...(options.nodeTransforms || []), // user transforms
        ],
        directiveTransforms: extend(
          {},
          directiveTransforms,
          options.directiveTransforms || {}
        ),
      })
    );
    return generate(
      ast,
      extend({}, options, {
        prefixIdentifiers,
      })
    );
  }

  exports.BASE_TRANSITION = BASE_TRANSITION;
  exports.CAMELIZE = CAMELIZE;
  exports.CAPITALIZE = CAPITALIZE;
  exports.CREATE_BLOCK = CREATE_BLOCK;
  exports.CREATE_COMMENT = CREATE_COMMENT;
  exports.CREATE_SLOTS = CREATE_SLOTS;
  exports.CREATE_STATIC = CREATE_STATIC;
  exports.CREATE_TEXT = CREATE_TEXT;
  exports.CREATE_VNODE = CREATE_VNODE;
  exports.FRAGMENT = FRAGMENT;
  exports.KEEP_ALIVE = KEEP_ALIVE;
  exports.MERGE_PROPS = MERGE_PROPS;
  exports.OPEN_BLOCK = OPEN_BLOCK;
  exports.POP_SCOPE_ID = POP_SCOPE_ID;
  exports.PUSH_SCOPE_ID = PUSH_SCOPE_ID;
  exports.RENDER_LIST = RENDER_LIST;
  exports.RENDER_SLOT = RENDER_SLOT;
  exports.RESOLVE_COMPONENT = RESOLVE_COMPONENT;
  exports.RESOLVE_DIRECTIVE = RESOLVE_DIRECTIVE;
  exports.RESOLVE_DYNAMIC_COMPONENT = RESOLVE_DYNAMIC_COMPONENT;
  exports.SET_BLOCK_TRACKING = SET_BLOCK_TRACKING;
  exports.SUSPENSE = SUSPENSE;
  exports.TELEPORT = TELEPORT;
  exports.TO_DISPLAY_STRING = TO_DISPLAY_STRING;
  exports.TO_HANDLERS = TO_HANDLERS;
  exports.TO_HANDLER_KEY = TO_HANDLER_KEY;
  exports.WITH_CTX = WITH_CTX;
  exports.WITH_DIRECTIVES = WITH_DIRECTIVES;
  exports.WITH_SCOPE_ID = WITH_SCOPE_ID;
  exports.advancePositionWithClone = advancePositionWithClone;
  exports.advancePositionWithMutation = advancePositionWithMutation;
  exports.assert = assert;
  exports.baseCompile = baseCompile;
  exports.baseParse = baseParse;
  exports.createCallExpression = createCallExpression;
  exports.createCompilerError = createCompilerError;
  exports.createRoot = createRoot;
  exports.createStructuralDirectiveTransform = createStructuralDirectiveTransform;
  exports.createTransformContext = createTransformContext;
  exports.generate = generate;
  exports.generateCodeFrame = generateCodeFrame;
  exports.getBaseTransformPreset = getBaseTransformPreset;
  exports.helperNameMap = helperNameMap;
  exports.isBuiltInType = isBuiltInType;
  exports.isCoreComponent = isCoreComponent;
  exports.isSimpleIdentifier = isSimpleIdentifier;
  exports.isSlotOutlet = isSlotOutlet;
  exports.isText = isText;
  exports.locStub = locStub;
  exports.registerRuntimeHelpers = registerRuntimeHelpers;
  exports.transform = transform;
  exports.traverseNode = traverseNode;

  Object.defineProperty(exports, "__esModule", { value: true });

  return exports;
})({});

try {
  if (module) {
    module.exports = VueCompilerCore;
  }
} catch (e) {}
