[{"categories":["vue"],"contents":" 诗号：六道同坠，魔劫万千，引渡如来。  \n  --  insertCssLink(\"https://unpkg.com/element-plus/lib/theme-chalk/index.css\");       本文涉及的源码包： compiler-sfc, runtime-dom，讲述了 style 中 v-deep, v-slotted, 等指令的使用及原理。\n ","permalink":"https://www.cheng92.com/vue/vue-teardown-13-v-deep-in-style/","tags":["vue3,","vue-next"],"title":"Vue3 功能拆解⑬ style v-deep, v-slotted"},{"categories":["web"],"contents":" Marquee 已经废弃的元素。\n 能用 transition 和 anmiation，请尽量不要使用这个。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20  interface HTMLMarqueeElement : HTMLElement { attribute DOMString behavior; attribute DOMString bgColor; attribute DOMString direction; attribute DOMString height; attribute unsigned long hspace; attribute long loop; attribute unsigned long scrollAmount; attribute unsigned long scrollDelay; attribute DOMString trueSpeed; attribute unsigned long vspace; attribute DOMString width; attribute Function onbounce; attribute Function onfinish; attribute Function onstart; void start(); void stop(); };     marquee 可以通过自身的 api 开启/开始( start() )和关闭/暂停( stop() )？\n 如下测试：\n-- start \u0026 stop 控制暂停和开始 marquee test start \u0026 stop start() stop() var m1= document.getElementById('m1') window.m1start = () = { console.log('m1 start'); m1.start()} window.m1stop = () = { console.log('m1 start'); m1.stop() }  -- behavior: scroll, slide, alternate marquee behavior scroll(default) marquee behavior slide marquee behavior alternate  -- direction: left, right, up, down marquee direction left(default) marquee direction right marquee direction up marquee direction down  -- scroll interval(default: 85 ms) scroll interval(default: 85) scroll interval: 200   -- treespeed: 影响 scrolldelay 属性，默认：false -- 1. 当 treespeed = false, scrolldelay -- 2. 当 treespeed = true, scrolldelay 取设置的值，等于是 false 的时候会自动调整 scrolldelay -- 如下现象， 好像没啥用， m1 和 m4 速度是同步的 m1: scroll interval + treespeed(false): 30 m2: scroll interval + treespeed(false): 60 m3: scroll interval + treespeed(false): 120 m4: scroll interval + treespeed(true ): 30 m5: scroll interval + treespeed(true ): 60 m6: scroll interval + treespeed(true ): 120   -- scrollamount: marquee scroll distance, 每次移动的距离，默认：6px/ms scrollamount(default: 6px) scrollamount: 12px   -- loop: marquee loop count, 如果 -- loop index: 完成一次，自动 +1 当 = loop count 时候滚动停止，并触发 onfinish -- 如果 loop index = loop count 时候滚动停止，并触发 onfinish -- 如果 behavior=alternate，loop index = loop count 时触发 onbounce 事件 -- 否则触发 onstart 事件(loop index -- start,bounce,finish 在 chrome 上都触发不了 -- stackover 上说是最新的版不再维护这个标签的原因 -- 但是 Firefox 上测试了下，三个事件都可以正常触发 ml1, loop: -1, behavior: alternate, onbounce 没用？ ml1, loop: -1 info-ml1: \nml2, loop: 0 info-ml2: \nml3, loop: 1 info-ml3: \nml4, loop: 2 info-ml4: \nloop index = 0\n  listenEvents(ml0, info1, 'ml0') listenEvents(ml1, info1, 'ml1') listenEvents(ml2, info2, 'ml2') listenEvents(ml3, info3, 'ml3') listenEvents(ml4, info4, 'ml4') function listenEvents(ml, info, text) { ml.addEventListener('start', function(e) { info.textContent = text + ' start' }) ml.addEventListener('finish', function(e) { info.textContent = text + ' finish' }) ml.addEventListener('bounce', function(e) { info.textContent = text +' bounce' }) }   下表的属性与DOM属性对应关系：\n   marquee attribute DOM attribute     behavior behavior   direction direction   height height   width width   hspace hspace   vspace vspace   bgcolor bgColor   scrollamount scrollAmount   scrolldelay scrollDelay   truespeed trueSpeed    -- vspace: 垂直距离，hspace: 水平距离 vspace: 20px  hspace: 50px   ","permalink":"https://www.cheng92.com/web/html-marquee-tag/","tags":["web,","html"],"title":"HTML Marquee 标签"},{"categories":["vue"],"contents":"  诗号：六道同坠，魔劫万千，引渡如来。  \n  --  insertCssLink(\"https://unpkg.com/element-plus/lib/theme-chalk/index.css\");       vue3 中 expose 的原理及使用。\n  本文涉及的源码包： runtime-core。\nexpose in options   组件中的所有选项处理(methods, data, …)都在这个函数中，其中就包括 expose:\n componentOptions.ts:applyOptions(instance: ComponentInternalInstance)\n options 初始化顺序：\n  props\n  inject\n  methods\n  data, 延迟处理，因为它依赖 this\n  computed\n  watch, 延迟处理，因为它依赖 this\n   \n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32  export function applyOptions(instance: ComponentInternalInstance) { const options = resolveMergedOptions(instance) const publicThis = instance.proxy! as any const ctx = instance.ctx shouldCacheAccess = false const { // ...  // public API  expose, // ...  } = options // ...  if (isArray(expose)) { if (expose.length) { const exposed = instance.exposed || (instance.exposed = {}) expose.forEach(key =\u0026gt; { Object.defineProperty(exposed, key, { get: () =\u0026gt; publicThis[key], set: val =\u0026gt; (publicThis[key] = val) }) }) } else if (!instance.exposed) { instance.exposed = {} } } // ... }     expose 属性的访问路径:\n expose[] -\u0026gt; instance.exposed -\u0026gt; publicThis -\u0026gt; instance.proxy\n  instance.proxy   对组件上下文对象的代理对象。\n instance.proxy 创建自：\n runtime-core/src/component.ts:setupStatefulComponent\n1 2 3  // 1. create public instance / render proxy  // also mark it raw so it\u0026#39;s never observed  instance.proxy = markRaw(new Proxy(instance.ctx, PublicInstanceProxyHandlers))     是对 instance.ctx 的代理，当你在实例中通过 this.xxx 或 ctx.xxx 去访问属性的时候实际走的是下 面这个代理。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80  export const PublicInstanceProxyHandlers: ProxyHandler\u0026lt;any\u0026gt; = { // get proxy  get({ _: instance }: ComponentRenderContext, key: string) { const { ctx, setupState, data, props, accessCache, type, appContext } = instance let normalizedProps if (key[0] !== \u0026#39;$\u0026#39;) { // 1. 非 $xx 的属性访问顺序: setupState -\u0026gt; data -\u0026gt; ctx -\u0026gt; props  // setupState 是 setup() 返回对象时的值，或 \u0026lt;script setup\u0026gt; 标签中的状态  // 并且这个会记录每次访问时的 key 对应在哪个对象上，这样下次就不用再过一篇这  // 里繁琐的逻辑了  // ...  } // 2. 下面是针对 this.$xxx 的访问，顺序是：  // publicPropertiesMap -\u0026gt; cssModule -\u0026gt; ctx -\u0026gt; globalProperties  // 找到对应 key 的 get 方法, 注意点  // 1) this.$attrs 的访问会触发 track  // 2) globalProperties 参过 app.config.globalProperties 注册的全局属性  const publicGetter = publicPropertiesMap[key] let cssModule, globalProperties // public $xxx properties  // ...  }, // set proxy  set( { _: instance }: ComponentRenderContext, key: string, value: any ): boolean { const { data, setupState, ctx } = instance // 设置优先级： setupState -\u0026gt; options data  if (setupState !== EMPTY_OBJ \u0026amp;\u0026amp; hasOwn(setupState, key)) { setupState[key] = value } else if (data !== EMPTY_OBJ \u0026amp;\u0026amp; hasOwn(data, key)) { data[key] = value } else if (hasOwn(instance.props, key)) { // ...不允许直接修改 props  return false } if (key[0] === \u0026#39;$\u0026#39; \u0026amp;\u0026amp; key.slice(1) in instance) { // ...不允许直接修改 $xxx 上的属性  return false } else { // 开发时，可以修改 app.config.globalProperties 上属性的值  if (__DEV__ \u0026amp;\u0026amp; key in instance.appContext.config.globalProperties) { Object.defineProperty(ctx, key, { enumerable: true, configurable: true, value }) } else { ctx[key] = value } } return true }, has( { _: { data, setupState, accessCache, ctx, appContext, propsOptions } }: ComponentRenderContext, key: string ) { let normalizedProps // 检测属性有无时的代理：  // 缓存(取值时缓存的) -\u0026gt; data -\u0026gt; setup state -\u0026gt; props -\u0026gt; ctx -\u0026gt; $xxx -\u0026gt; globalProperties  return ( accessCache![key] !== undefined || (data !== EMPTY_OBJ \u0026amp;\u0026amp; hasOwn(data, key)) || (setupState !== EMPTY_OBJ \u0026amp;\u0026amp; hasOwn(setupState, key)) || ((normalizedProps = propsOptions[0]) \u0026amp;\u0026amp; hasOwn(normalizedProps, key)) || hasOwn(ctx, key) || hasOwn(publicPropertiesMap, key) || hasOwn(appContext.config.globalProperties, key) ) } }    属性代理\n  取值操作可能经过的路径(依优先级从左到右)：\n 非 $xxx 的属性： setup state \u0026gt; data \u0026gt; ctx \u0026gt; props\n $xxx 的属性： publicPropertiesMap -\u0026gt; cssModule -\u0026gt; ctx -\u0026gt; globalProperties\n 实际上 $xxx 的属性只是 ctx.xxx 的别名。\n  设值，只能设置 setup state \u0026gt; options data\n 有一种情况比较特殊：当要设置的 key 在 setup state, options data, props, $xxx, globalProperties 上都没有的时候，最后会直接被添加的 ctx 上去：\n ctx[key] = value\n  has 属性检查的顺序： cache 中 \u0026gt; data \u0026gt; setup state \u0026gt; props \u0026gt; ctx \u0026gt; publicPropertiesMap \u0026gt; globalProperties\n    publicPropertiesMap:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19  export const publicPropertiesMap: PublicPropertiesMap = extend( Object.create(null), { $: i =\u0026gt; i, $el: i =\u0026gt; i.vnode.el, $data: i =\u0026gt; i.data, $props: i =\u0026gt; (__DEV__ ? shallowReadonly(i.props) : i.props), $attrs: i =\u0026gt; (__DEV__ ? shallowReadonly(i.attrs) : i.attrs), $slots: i =\u0026gt; (__DEV__ ? shallowReadonly(i.slots) : i.slots), $refs: i =\u0026gt; (__DEV__ ? shallowReadonly(i.refs) : i.refs), $parent: i =\u0026gt; getPublicInstance(i.parent), $root: i =\u0026gt; getPublicInstance(i.root), $emit: i =\u0026gt; i.emit, $options: i =\u0026gt; (__FEATURE_OPTIONS_API__ ? resolveMergedOptions(i) : i.type), $forceUpdate: i =\u0026gt; () =\u0026gt; queueJob(i.update), $nextTick: i =\u0026gt; nextTick.bind(i.proxy!), $watch: i =\u0026gt; (__FEATURE_OPTIONS_API__ ? instanceWatch.bind(i) : NOOP) } as PublicPropertiesMap )     从上面的 代码流程 来看，好像和 props, data 没什么区别吧❓\n 最终不都是走了 proxy get 那一套❓\n 从这里好像看不出什么…\n  ref \u0026amp; setRef   来看下面官方(runtime-core/__tests__/apiExpose.spec.ts)的例子：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34  const url = process.env.VNEXT_PKG_RC +\u0026#39;/../runtime-test/dist/runtime-test.cjs.js\u0026#39; const value = require(url.replace(\u0026#39;stb-\u0026#39;, \u0026#39;\u0026#39;)) const { nodeOps, render, h, serializeInner: s, ref, defineComponent, toRaw } = value const Child = defineComponent({ render() {}, expose: [\u0026#39;fox\u0026#39;, \u0026#39;foo\u0026#39;], setup(_, { expose }) { expose({ foo: 1, bar: ref(2) }) return { bar: ref(3), baz: ref(4) } } }) const childRef = ref() const Parent = { setup() { return () =\u0026gt; h(Child, { ref: childRef }) } } const root = nodeOps.createElement(\u0026#39;div\u0026#39;) render(h(Parent), root) console.log(\u0026#39;childRef.value = \u0026#39;, childRef.value); console.log(\u0026#39;childRef.value.foo = \u0026#39;, childRef.value.foo); console.log(\u0026#39;childRef.value.bar = \u0026#39;, childRef.value.bar); console.log(\u0026#39;childRef.value.baz = \u0026#39;, childRef.value.baz); console.log(\u0026#39;childRef.value.fox = \u0026#39;, childRef.value.fox);    key = __v_raw key = __v_isReadonly key = __v_raw key = __v_skip childRef.value = { foo: [Getter/Setter], bar: RefImpl { _rawValue: 2, _shallow: false, __v_isRef: true, _value: 2 } } key = foo childRef.value.foo = undefined key = bar childRef.value.bar = 2 key = baz childRef.value.baz = undefined key = fox childRef.value.fox = undefined undefined  \n 从测试用例来看，这个 expose 用途是将组件本身的属性暴露出去，可以在父组件中通过 ref 取到该组件元素的引用 childRef (严格来说当有 expose 时就不再是指向 vnode.el了)， 然后就可以通过这个引用来直接访问 expose 出来的属性。\n 那这个是怎么做到的？\n 既然和 ref 元素本身有关系，那就得从这个 ref 去下手看看了。\n ref 值设置的地方(setRef(...))：在组件渲染完成之后才会有实际的DOM元素，所以这个肯定是发生在 mounted 之后。\n 调用 setRef() 的地方有：\n  patch(n1, n2, …) 函数的最后\n1 2 3 4  // set ref  if (ref != null \u0026amp;\u0026amp; parentComponent) { setRef(ref, n1 \u0026amp;\u0026amp; n1.ref, parentSuspense, n2 || n1, !n2) }      unmount(vnode, …) 的时候取消引用，防止内存泄漏\n1 2 3  if (ref != null) { setRef(ref, null, parentSuspense, vnode, true) }      TIP\n 另外，组件实际的 DOM 元素的引用是在 vnode.el 上，这个值是在 mountElement(vnode) 中创建真实 DOM 元素的时候被赋值的，而 setRef() 是在 patch() 最后执行，所以在这个 时候 vnode.el 上就已经有了该组件真实 DOM 元素的引用，因为所有的组件流程一开始都 是经过的 patch() 函数(组件渲染完整流程图)。\n Vue3 源码头脑风暴之 7 ☞ runtime-core(3) - render component\n  上面只是知道了设置，但实际这里是需要知道是对 childRef.value.foo 的取值会发生些什 么，流程是什么，最终又是怎么和 expose 发生关联的？\n 下面来仔细看下 setRef 里面又发生了什么，设想应该是对 ref 的引用是不是做了代理❓\n runtime-core/src/renderer.ts:setRef\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34  export const setRef = ( rawRef: VNodeNormalizedRef, oldRawRef: VNodeNormalizedRef | null, parentSuspense: SuspenseBoundary | null, vnode: VNode, isUnmount = false ) =\u0026gt; { // ... rawRef 是数组处理  // 异步组件判断，如果是异步的需要等异步组件完成渲染才可以  // isAsyncWrapper:  // export const isAsyncWrapper = (i: ComponentInternalInstance | VNode): boolean =\u0026gt;  // !!(i.type as ComponentOptions).__asyncLoader  // 有状态的组件：对象组件, vnode.ts:createVNode 里面的检测  // isObject(type) ? ShapeFlags.STATEFUL_COMPONENT : ...  // 重点就在这：先取 expose proxy 然后取 component.proxy  const refValue = vnode.shapeFlag \u0026amp; ShapeFlags.STATEFUL_COMPONENT ? getExposeProxy(vnode.component!) || vnode.component!.proxy : vnode.el const value = isUnmount ? null : refValue // ...  // \u0026lt;div ref=\u0026#34;formRef\u0026#34; /\u0026gt; -\u0026gt; this.$refs.formRef  if (isString(ref)) { // refs[ref] = value ...  } else if (isRef(ref)) { // 这个正是这里使用的案例所执行的分支  } // ... }     在 setRef 中检测到如果是有状态的组件，会先执行 getExposeProxy(instance) 去 instance.exposed 中取值，如果没有则再去组件实例的代 理(也就是最开始分析的instance.proxy)中去取 expose proxy:\n \n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17  export function getExposeProxy(instance: ComponentInternalInstance) { if (instance.exposed) { return ( instance.exposeProxy || (instance.exposeProxy = new Proxy(proxyRefs(markRaw(instance.exposed)), { get(target, key: string) { console.log(\u0026#39;key = \u0026#39; + key); if (key in target) { return target[key] } else if (key in publicPropertiesMap) { return publicPropertiesMap[key](instance) } } })) ) } }     上面代码加了打印可以从 🔗上面的例子 中看到 key 的值。\n 以上就是 expose + ref 的使用及原理，下面还会对一些其它细节进行回顾。\n  $root and $parent   在 Child 中可以通过 this.$root 和 this.$parent 去取到 parent 中 expose 出 来的属性，这个又是怎么实现的呢❓❓❓\n 先看下测试用例(runtime-core/__tests__/apiExpose.spec.ts)：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43  const url = process.env.VNEXT_PKG_RC +\u0026#39;/../runtime-test/dist/runtime-test.cjs.js\u0026#39; const value = require(url.replace(\u0026#39;stb-\u0026#39;, \u0026#39;\u0026#39;)) const { nodeOps, render, h, serializeInner: s, defineComponent } = value let Root const Child = defineComponent( { render() { console.log(\u0026#34;this.$parent.foo = \u0026#34; + this.$parent.foo); console.log(\u0026#34;this.$parent.bar = \u0026#34; + this.$parent.bar); console.log(\u0026#34;this.$root.foo = \u0026#34; + this.$root.foo); console.log(\u0026#34;this.$root.bar = \u0026#34; + this.$root.bar); console.log(\u0026#34;$root: \u0026#34;, this.$root); console.log(\u0026#34;Root:\u0026#34;, Root); } } ) const Parent = defineComponent({ expose: [], setup(_, { expose }) { expose({ foo: 1 }) return { bar: 2 } }, render() { return h(Child) } }) // #1 console.log(\u0026#39;\u0026gt; root = parent\u0026#39;); const root1 = nodeOps.createElement(\u0026#39;div\u0026#39;) render(h(Parent), root1) Root = defineComponent({ render () { return h(Parent) } }) // #2 console.log(\u0026#39;\u0026gt; root = parent.$parent\u0026#39;); const root2 = nodeOps.createElement(\u0026#39;div\u0026#39;) render(h(Root), root2) return 0    \u0026gt; root = parent this.$parent.foo = 1 this.$parent.bar = undefined this.$root.foo = 1 this.$root.bar = undefined $root: { foo: 1 } Root: undefined \u0026gt; root = parent.$parent this.$parent.foo = 1 this.$parent.bar = undefined this.$root.foo = undefined this.$root.bar = undefined $root: {} Root: { render: [Function: render] } 0   结果显示， 在 Child 中都可以正确取到 foo ，而取不到 bar。\n 那么为什么呢❓\n 可以从 publicPropertiesMap 中找到 $parent 和 $root 的引用：\n1 2 3 4 5 6 7 8 9 10 11  export const publicPropertiesMap: PublicPropertiesMap = extend( Object.create(null), { // ...  $el: i =\u0026gt; i.vnode.el, // ...  $parent: i =\u0026gt; getPublicInstance(i.parent), $root: i =\u0026gt; getPublicInstance(i.root), // ...  } as PublicPropertiesMap )     两者都是映射到了 getPublicInstance 那什么是 public instance❓\n 代码位于： runtime-core/src/componentPublicInstance.ts:getPublicInstance\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  /** ,* #2437 In Vue 3, functional components do not have a public instance proxy but ,* they exist in the internal parent chain. For code that relies on traversing ,* public $parent chains, skip functional ones and go to the parent instead. ,*/ const getPublicInstance = ( i: ComponentInternalInstance | null ): ComponentPublicInstance | ComponentInternalInstance[\u0026#39;exposed\u0026#39;] | null =\u0026gt; { if (!i) return null // 对象组件，跳过函数组件，如上面的注释，函数组件并没有公共的实例，但是它们  // 依旧在 parent 链上  if (isStatefulComponent(i)) return i.exposed ? i.exposed : i.proxy // 递归取父级组件实例，这个一直会找到 root  return getPublicInstance(i.parent) }     this.$parent.foo 倒是好理解， $parent 被映射到 getPublicInstance(i.parent) 找自 己的父级组件，如果有 exposed 级返回这个对象，所以这里也就等于是 instance.exposed.foo\n 然而对于 this.$root.foo 为什么也能取到 expose 里面的 1 ❓\n因为在 root1 的时候 Parent 就是 root 组件，所以 instance.root == parent\n  每个组件都会持有一份对 root 组件的引用，instance.root，这个引用的设置发生在创建 组件实例的时候:\n1 2  // createComponentInstance(vnode, parent, suspense) -\u0026gt; instance.root = parent ? parent.root : instance     所以 #1 和 #2 的结果不一样(1 和 undefined)。\n  expose()   除了能使用 options api expose 之外，还可以通过在 setup() 中调用 expose({...}) 来 暴露部分属性。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27  const url = process.env.VNEXT_PKG_RC +\u0026#39;/../runtime-test/dist/runtime-test.cjs.js\u0026#39; const value = require(url.replace(\u0026#39;stb-\u0026#39;, \u0026#39;\u0026#39;)) const { nodeOps, render, h, serializeInner: s, defineComponent, ref } = value const Child = { render() { return h(\u0026#39;div\u0026#39;) }, setup(_, { expose }) { expose() return {} } } const childRef = ref() const Parent = { setup() { return () =\u0026gt; h(Child, { ref: childRef }) } } const root = nodeOps.createElement(\u0026#39;div\u0026#39;) render(h(Parent), root) console.log(\u0026#39;childRef.value.$el.tag = \u0026#39; + childRef.value.$el.tag); return 0    key = __v_raw key = __v_isReadonly key = __v_raw key = __v_skip key = $el childRef.value.$el.tag = div 0   expose() 函数又做了什么呢？为什么这个不传参数呢？\nWARNING\n expose() 只能在 setup() 中执行，且只能执行一次(非强制，多次也无意义，会覆盖)。\n  有关 setup ctx 参数的说明见: setup(_, ctx) 的第二个参数？\n expose 函数其实很简单，赋值及初始化，不能重复调用也只是给出了警告：\n1 2 3 4 5 6  const expose: SetupContext[\u0026#39;expose\u0026#39;] = exposed =\u0026gt; { if (__DEV__ \u0026amp;\u0026amp; instance.exposed) { warn(`expose() should be called only once per setup().`) } instance.exposed = exposed || {} }     getExposeProxy(instance)\n 设置了 instance.exposed 的代理，并且如果要访问的属性这个对象本身没有的时候会去 publicPropertiesMap 中去找，所以这个去访问 childRef.value.$el 的时候在 instance.exposed 上面是找不到的，最后找到的是 $el: i =\u0026gt; i.vnode.el 。\n  总结    支持 options api expose: [...]\n  支持 setup context expose({...})\n  同时支持 option api 和 setup context\n  empty expose 等于没有\n  this.$parent 在子组件中使用可以取到父组件 expose 的属性\n  this.$root 取到根节点上 expose 的属性\n  setup() 中调用 expose() 不传参，最后属性访问会被代理到 publicPropertiesMap 上\n    ","permalink":"https://www.cheng92.com/vue/vue-teardown-11-expose/","tags":["vue3,","vue-next,"],"title":"Vue3 功能拆解⑪ expose options\u0026api"},{"categories":["vue"],"contents":"  诗号：六道同坠，魔劫万千，引渡如来。  \n  --  insertCssLink(\"https://unpkg.com/element-plus/lib/theme-chalk/index.css\");       本文主要是分析 applyOptions 函数。\n  本文涉及的源码包： runtime-core/src/componentOptions.ts:applyOptions(instance: ComponentInternalInstance)。\nTODO   ","permalink":"https://www.cheng92.com/vue/vue-teardown-12-options/","tags":["vue3,","vue-next,"],"title":"Vue3 功能拆解⑫ 组件选项处理 options(如：methods, data, ...)"},{"categories":["vue"],"contents":"  诗号：六道同坠，魔劫万千，引渡如来。  \n  --  insertCssLink(\"https://unpkg.com/element-plus/lib/theme-chalk/index.css\");     本系列为 vue-next 源码分析系列的旁系分支，主要目的在于对 vue3 源码中的一些细节进 行分析。本文讲述的是 Transition 组件使用，原理，源码分析。\n TODO   ","permalink":"https://www.cheng92.com/vue/vue-teardown-9-transition/","tags":["vue3,","vue-next,","Transition"],"title":"Vue3 功能拆解⑨ Transition 组件机制"},{"categories":["vue"],"contents":"  诗号：六道同坠，魔劫万千，引渡如来。  \n  --  insertCssLink(\"https://unpkg.com/element-plus/lib/theme-chalk/index.css\");       本系列为 vue-next 源码分析系列的旁系分支，主要目的在于对 vue3 源码中的一些细节进 行分析。本文讲述的是 SFC 中 style 的解析，比如： v-deep 的使用及原理。\n TODO   ","permalink":"https://www.cheng92.com/vue/vue-teardown-10-sfc-style/","tags":["vue3,","vue-next,","Transition"],"title":"Vue3 功能拆解⑩ SFC style"},{"categories":["awesome"],"contents":" APIs   基于 org-verb-mode.\nTODO online-convert 在线转换接口   https://www.api2convert.com/ 这里获取 API Key.\n  TODO 聚合数据\u0026#xa0;\u0026#xa0;\u0026#xa0;verb   gnu.org\u0026#xa0;\u0026#xa0;\u0026#xa0;verb   template https://www.gnu.org\nPDF   get /licenses/quick-guide-gplv3.pdf\n  Images   template /graphics\nPNG image   get /gnu-head.png\n      openlibrary.org\u0026#xa0;\u0026#xa0;\u0026#xa0;verb   template https://openlibrary.org User-Agent: Verb/Emacs Emacs/{{emacs-version}} Accept: application/json\nSeach  template /search.json\n  Sbujects  get /subjects/{{(read-string \u0026#34;Subject: \u0026#34;)}}.json\n  books  :properties: :Verb-Store: book 🔚\nget /api/books?bibkeys=ISBN:{{(verb-var isbn)}}\u0026amp;format=json\n CLOSED: [2020-08-27 Thu 00:07]\n  State \u0026#34;DONE\u0026#34; from [2020-08-27 Thu 00:07]\n  template https://reqres.in\nAccept: application/json\nAuthentication: {{(verb-var token)}}\n    User\u0026#xa0;\u0026#xa0;\u0026#xa0;verb  User management  get Content-Language: de-DE\n  Get users list  get /api/users Content-Language: de-DE\n  create a user   post /api/users Content-Type: application/json; charset=utf-8\n1 2 3 4  { \u0026#34;name\u0026#34;: \u0026#34;John\u0026#34;, \u0026#34;age\u0026#34;: 42 }     post /api/users\n1 2 3 4 5  { \u0026#34;name\u0026#34;: \u0026#34;{{(user-full-name)}}\u0026#34;, \u0026#34;age\u0026#34;: \u0026#34;{{(read-string \u0026#34;Age: \u0026#34;)}}\u0026#34; }    Cloud Servers    三丰云, 三十天的免费，到期直接续费使用，记得设置闹钟哦~~\n 服务器只能用一天，完了之后需要每五天续费一次。。。\n          Development   Awesome Web Development(WEB开发资源)\n  ","permalink":"https://www.cheng92.com/post/awesome/","tags":["awesome"],"title":"My Awesome Everything"},{"categories":["golang"],"contents":" 问题  go get i/o timeout ?  1 2 3 4 5  go env -w GO111MODULE=on go env -w GOPROXY=https://goproxy.io,direct # 设置不走 proxy 的私有仓库，多个用逗号相隔（可选） go env -w GOPRIVATE=*.gitlab.com        ","permalink":"https://www.cheng92.com/post/golang/","tags":["golang"],"title":"Golang Go Go Go..."},{"categories":["web"],"contents":" TODO\n","permalink":"https://www.cheng92.com/web/web-component/","tags":["web,","component"],"title":"Web Component 学习记录"},{"categories":["vue"],"contents":"  诗号：六道同坠，魔劫万千，引渡如来。  \n  --  insertCssLink(\"https://unpkg.com/element-plus/lib/theme-chalk/index.css\");       本文将从源码，编译前后让你明白 \u0026lt;script setup\u0026gt; 标签内如何正确的书写代码，及每个语 法背后的原理又是什么？\n  本文涉及的源码包： compiler-sfc, compiler-core。\n SFC \u0026lt;script setup\u0026gt; 的编译相关代码在 packages/compiler-sfc/src/compileScript.ts\n 使用到的第三方插件 ： @babel/parser-\u0026gt;parse, magic-string, estree-walker\nscript setup   插件使用测试  @babel/parser:  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  const { parse } = require(\u0026#39;/usr/local/lib/node_modules/@babel/parser/lib/index\u0026#39;) const ast = parse(` const foo = 100, bar = 200; function baz() { console.log(foo + bar) } `) const program = ast.program console.log(\u0026#39;\u0026gt;\u0026gt;\u0026gt; foo 变量声明 AST\\n\u0026#39;, program.body[0].declarations[0]); // console.log(\u0026#39;\u0026gt;\u0026gt;\u0026gt; bar 变量声明 AST\\n\u0026#39;, program.body[0].declarations[1]); console.log(\u0026#39;\u0026gt;\u0026gt;\u0026gt; baz 函数声明 AST\\n\u0026#39;, program.body[1]); // console.log(\u0026#39;\u0026gt;\u0026gt;\u0026gt; 代码体 AST\\n\u0026#39;, program.body); // console.log(\u0026#39;\u0026gt;\u0026gt;\u0026gt; 代码 AST\\n\u0026#39;, program); // console.log(\u0026#39;\u0026gt;\u0026gt;\u0026gt; 完整的 AST 结构\\n\u0026#39;, ast); return 0    \u0026gt;\u0026gt;\u0026gt; foo 变量声明 AST Node { type: \u0026#39;VariableDeclarator\u0026#39;, start: 7, end: 16, loc: SourceLocation { start: Position { line: 2, column: 6 }, end: Position { line: 2, column: 15 }, filename: undefined, identifierName: undefined }, range: undefined, leadingComments: undefined, trailingComments: undefined, innerComments: undefined, extra: undefined, id: Node { type: \u0026#39;Identifier\u0026#39;, start: 7, end: 10, loc: SourceLocation { start: [Position], end: [Position], filename: undefined, identifierName: \u0026#39;foo\u0026#39; }, range: undefined, leadingComments: undefined, trailingComments: undefined, innerComments: undefined, extra: undefined, name: \u0026#39;foo\u0026#39; }, init: Node { type: \u0026#39;NumericLiteral\u0026#39;, start: 13, end: 16, loc: SourceLocation { start: [Position], end: [Position], filename: undefined, identifierName: undefined }, range: undefined, leadingComments: undefined, trailingComments: undefined, innerComments: undefined, extra: { rawValue: 100, raw: \u0026#39;100\u0026#39; }, value: 100 } } \u0026gt;\u0026gt;\u0026gt; baz 函数声明 AST Node { type: \u0026#39;FunctionDeclaration\u0026#39;, start: 29, end: 72, loc: SourceLocation { start: Position { line: 3, column: 0 }, end: Position { line: 5, column: 1 }, filename: undefined, identifierName: undefined }, range: undefined, leadingComments: undefined, trailingComments: undefined, innerComments: undefined, extra: undefined, id: Node { type: \u0026#39;Identifier\u0026#39;, start: 38, end: 41, loc: SourceLocation { start: [Position], end: [Position], filename: undefined, identifierName: \u0026#39;baz\u0026#39; }, range: undefined, leadingComments: undefined, trailingComments: undefined, innerComments: undefined, extra: undefined, name: \u0026#39;baz\u0026#39; }, generator: false, async: false, params: [], body: Node { type: \u0026#39;BlockStatement\u0026#39;, start: 44, end: 72, loc: SourceLocation { start: [Position], end: [Position], filename: undefined, identifierName: undefined }, range: undefined, leadingComments: undefined, trailingComments: undefined, innerComments: undefined, extra: undefined, body: [ [Node] ], directives: [] } } 0    magic-string   对字符串进行增删改查的各种操作， vue3 中使用该插件来替换编译之后的 ast code。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  const MagicString = require(\u0026#39;/usr/local/lib/node_modules/magic-string/dist/magic-string.cjs.js\u0026#39;) const log = console.log const s = new MagicString(\u0026#39;problems = 99\u0026#39;) log(\u0026#39;替换变量名 -\u0026gt; \u0026#39;, s.overwrite(0, 8, \u0026#39;answer\u0026#39;).toString()) log(\u0026#39;替换变量值 -\u0026gt; \u0026#39;, s.overwrite(11, 13, \u0026#39;42\u0026#39;).toString()) log(\u0026#39;前后加内容 -\u0026gt; \u0026#39;, s.prepend(\u0026#39;var \u0026#39;).append(\u0026#39;;\u0026#39;).toString()) const map = s.generateMap({ source: \u0026#39;source.js\u0026#39;, file: \u0026#39;converted.js.map\u0026#39;, includeContent: true }) // generates a v3 sourcemap  log(\u0026#39;生产 source map -\u0026gt; \u0026#39;, map.toString())    替换变量名 -\u0026gt; answer = 99 替换变量值 -\u0026gt; answer = 42 前后加内容 -\u0026gt; var answer = 42; 生产 source map -\u0026gt; {\u0026#34;version\u0026#34;:3,\u0026#34;file\u0026#34;:\u0026#34;converted.js.map\u0026#34;,\u0026#34;sources\u0026#34;:[\u0026#34;source.js\u0026#34;],\u0026#34;sourcesContent\u0026#34;:[\u0026#34;problems = 99\u0026#34;],\u0026#34;names\u0026#34;:[],\u0026#34;mappings\u0026#34;:\u0026#34;IAAA,MAAQ,GAAG\u0026#34;} undefined    estree-walker   一个遍历 ast 的插件。\n1 2 3 4 5 6 7 8 9 10 11 12  const walk = require(\u0026#39;/usr/local/lib/node_modules/estree-walker/src/index.js\u0026#39;).walk const acorn = require(\u0026#39;/usr/local/lib/node_modules/acorn/dist/acorn.js\u0026#39;) const ast = acorn.parse(`const foo = 100`) walk(ast, { enter(node, parent, prop, index) { console.log(\u0026#39;enter\u0026gt;\u0026gt;\u0026gt;\u0026#39;, node, parent, prop, index); }, leave(node, parent, prop, index) { console.log(\u0026#39;leave\u0026gt;\u0026gt;\u0026gt;\u0026#39;, node, parent, prop, index); } })    #+RESULTS:\n    ","permalink":"https://www.cheng92.com/vue/vue-teardown-8-script-setup/","tags":["vue3,","vue-next,","script.setup"],"title":"Vue3 功能拆解⑧ script setup 来龙去脉"},{"categories":["vue"],"contents":" 诗号：六道同坠，魔劫万千，引渡如来。  \n  本文纯粹的链接，列出源码学习过程中重要知识点和功能特性有关的分析链接，这些链接主 要链接到本网站内文章，不排除有外链其他网站。\n   h(\u0026#39;div\u0026#39;, { ref: childRef }) ref 属性什么时候不会指向 vnode.el ❓\n  setup(_, ctx) 的第二个参数？ \n runtime-core/src/component.ts:createSetupContext()\n 最后返回的对象：\n1 2 3 4 5 6  { attrs: instance.attrs, slots: instance.slots, emit: instance.emit, expose }     setup() 函数被调用的地方： component.ts:setupStatefulComponent\n 调用流程：\n renderer.ts:mountComponent -\u0026gt; setupComponent()\n component.ts:setupComponent() -\u0026gt; setupStatefulComponent() -\u0026gt; setup(instance.props, setupContenxt)\n expose 函数：\n1 2 3 4 5 6  const expose: SetupContext[\u0026#39;expose\u0026#39;] = exposed =\u0026gt; { if (__DEV__ \u0026amp;\u0026amp; instance.exposed) { warn(`expose() should be called only once per setup().`) } instance.exposed = exposed || {} }     更详细的过程-\u0026gt;\n  trasition 组件原理分析？\n  模板中的资源 URL 是如何识别的，最后又是被编译成啥了？(如： \u0026lt;img src=\u0026#34;@img/vue/test.png\u0026#34; /\u0026gt;)\n  TODO component render 函数在哪里执行？\n  \u0026lt;script setup\u0026gt; 原理和编译过程及结果？\n  setup 函数如何解析？又是如何执行？\n render -\u0026gt; patch -\u0026gt; processComponent -\u0026gt; mountComponent -\u0026gt; createComponentInstance -\u0026gt; 创建组件实例，初始化组件结构 -\u0026gt;\n setupComponent -\u0026gt; 初始化 props 和 slots，有状态组件处理\n setupStatefulComponent -\u0026gt; 给 instance.ctx 增加代理，执行 setup() 函数\n 也就是说在 setup 执行之前 props, emits, slots 都已经可以访问了，并且这个函数 在组 件整个生命周期中只会调用一次，因为后面组件的更新时直接调用 instance.update 来完成，不会进入 mountComponent 。\n  props ? attrs ? 当给子组件传递属性的时候，哪些在 props 中，哪些在 attrs中？\n 比如：\n1  \u0026lt;Child name=\u0026#34;child\u0026#34; foo=1 bar=true/\u0026gt;     name, foo, bar 在 Child 组件中存在哪里了？\n 是 props ? attrs ?\n  vue3 中和 scheduler 任务调度有关的代码！\n 讲述了 runtime-core/src/scheduler.ts 中 api 在哪些地方有用到，这些使用的地方 任务执行顺序又是什么❓\n  vue3 事件绑定是如何实现的(stopImmediatePropagation 又是啥?)？\n 简述：一个元素一个事件名对应的事件只会绑定一个 listener 及 封装之后的 invoker，此时为了实现原生事件的 stopImmediatePropagation 功能，对 invoker.value 即事件句柄列表里面的所有事件句柄(函数)进行了重写。\n  vue3 异步任务调度机制 runtime-core-\u0026gt;scheduler 是如何实现的?\n vue3 中的异步更新任务分为三种： pre cbs/queue jobs/post cbs，他们的执行都有一 定的先后顺序，点击链接了解更多分析内容。\n  vue3 diff 原理？\n   old new 更新原则     [1] [1,2,3] append，新增   [4,5] [1,2,3,4,5] append，新增   [2,3,4] [1,2,3,4,5] 新增+插入   [1,2,3,4] [2,3,1,4] 一次移动   [1,2,3,4] [1,4,2,3] 一次移动   [1,2,3] [2,3,1] 一次移动   [1,2,3,4] [4,2,3,1] 一次移动     诸如上面的实例是如何实现插入，新增，删除和移动的？\n 这里又是如何利用“最长增长序列”来过滤掉不需要移动的节点的？\n 简述： 两个 while + if…else if…else\n while1 检测 patch 头部相同节点\n while2 检测 patch 尾部相同节点\n 经过两个 while 处理之后剩下的只有不规则的两组(new \u0026amp; old)序列。\n if 执行新增\n else if 执行删除\n else 依照『最长增长序列』算法进行分析，决定是删除还是新增或插入。\n 最长增长序列：找到一组序列中路径最长的递增序列，比如：\n 2,3,1,4 最长增长序列就是 2,3,4\n 剩下的元素只可能比这个序列中的元素值小(如： 1)\n 对于不规则的序列对比过程中，会优先查找有 key 的 child, 根据 old child key 去 new children 中找到相同 key 的 new child 来替换这个 old child。\n 如果没找到相同 key 的 new child 那这个 old child 将面临被删除的命运。\n 如果 old child 也是 unkeyed 那会从 new children 中找到第一个 unkeyed 的 new child 来替换。\n 所以总结下来：\n  while1 同化头部\n  while2 同化尾部\n  if 新增\n  else if 删除\n  else 不规则序列\n  keyed old child 找 keyed new child，没有 unmount old\n  unkeyed old child 找 unkeyed new child, 没有 unmount old\n  剩余的 new child 新增\n  最后根据最长递增序列算法进行移动，前提是需要移动\n      keep-alive 组件实现原理？\n activate 和 deactivate 状态切换的实际原理是什么？\n ⁉ 通过创建一个 off-dom div 来承接 deactivate 状态下的 DOM 🌲。\n   ","permalink":"https://www.cheng92.com/vue/vue-core-code-link/","tags":["vue,","vue3"],"title":"Vue3 自问自答系列❓❓❓"},{"categories":["vue"],"contents":" 诗号：六道同坠，魔劫万千，引渡如来。  \n  --  insertCssLink(\"https://unpkg.com/element-plus/lib/theme-chalk/index.css\");       本文从源码角度讲解了 vue3 中是如何对 assets url 进行转换的，比如 \u0026lt;img src=\u0026#34;@img/vue/test.png\u0026#34;\u0026gt; 在编译之后是怎么样？ 这篇文章将详尽的接晓。\n  本文涉及的源码包： compiler-sfc, compiler-core。\n assets url 在模板中的使用方式：\n1 2 3 4 5 6 7 8  const template = ` \u0026lt;img src=\u0026#34;./logo.png\u0026#34;/\u0026gt; \u0026lt;img src=\u0026#34;~fixtures/logo.png\u0026#34;/\u0026gt; \u0026lt;img src=\u0026#34;~/fixtures/logo.png\u0026#34;/\u0026gt; \u0026lt;img src=\u0026#34;http://example.com/fixtures/logo.png\u0026#34;/\u0026gt; \u0026lt;img src=\u0026#34;/fixtures/logo.png\u0026#34;/\u0026gt; \u0026lt;img src=\u0026#34;data:image/png;base64,i\u0026#34;/\u0026gt; `     下面会从源码角度取分析各种情况最后被解析的结果。\n 该解析过成在 SFC 模板解析模块 compiler-sfc 触发中，但是最终解析的是 compiler-core 模块。\n 相关函数： packages/compiler-sfc/src/templateTransofrmAssetUrl.ts 中的 transformAssetUrl，这个函数并非直接在哪里调用，而是做为选项，转换器传递给了 compiler-core ，在 transform 介段处理，具体代码简要流程。\n compiler-sfc:src/compileTemplate.ts\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34  function compileTemplate(options) { // ... 一些预处理  return doCompileTemplate(options) // ... 和错误处理 } function doCompileTemplate({/* SFCTemplateCompileOptions ... */}) { // ...  let nodeTransforms: NodeTransform[] = [] if (isObject(transformAssetUrls)) { const assetOptions = normalizeOptions(transformAssetUrls) // 因为 compiler-core:transform 阶段 traverseNode 中调用  // nodeTransform 的时候只有 (node, context) =\u0026gt; ...  // 所以这里需要进行一次封装，将 options 传递给 transformAssetUrl  nodeTransforms = [ createAssetUrlTransformWithOptions(assetOptions), createSrcsetTransformWithOptions(assetOptions) ] } else if (transformAssetUrls !== false) { nodeTransforms = [transformAssetUrl, transformSrcset] } // ...  let { code, ast, preamble, map } = compiler.compile(source, { // ... 一系列选项  ...compilerOptions, // ⚠ 这是本节关注的重点  nodeTransforms: nodeTransforms.concat(compilerOptions.nodeTransforms || []), // ...  }) // ... }     省略一些无关紧要的代码，这里重点关注 transformAssetUrl 和 transformSrcset 两 个，尤其是前者。\n 上面是 compiler-sfc 阶段的大致逻辑，接下来执行两个 transformXxx 的地方发生在\n compiler-core:src/transform.ts(更详尽的分析在这里 。)\n transform() -\u0026gt; traverseNode() 从 root 节点开始递归处理 ast，来自 ast.ts 解析后的 AST 结构。\n traverseNode() 函数分三个阶段实现\n  收集 node transform 函数，并会提前处理一些节点\n  根据节点类型 NodeTypes，做相应的分支处理，比如： children\n  最后一个 while 反方向执行收集到的 node transform 完成转换\n   这些步骤不展开讲了，更详细的还是这篇文章: Vue3 源码头脑风暴之 3 ☞compiler-core - transform + codegen\n 再回头看 transformAssetUrl 内的条件：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83  export const transformAssetUrl: NodeTransform = ( node, context, options: AssetURLOptions = defaultAssetUrlOptions ) =\u0026gt; { // 条件1:  if (node.type === NodeTypes.ELEMENT) { if (!node.props.length) { return } } // 条件2:  const tags = options.tags || defaultAssetUrlOptions.tags const attrs = tags[node.tag] const wildCardAttrs = tags[\u0026#39;*\u0026#39;] if (!attrs \u0026amp;\u0026amp; !wildCardAttrs) { return } // 开始处理 node.props  node.props.forEach((attr, index) =\u0026gt; { // 1. props 过滤  if ( attr.type !== NodeTypes.ATTRIBUTE || !assetAttrs.includes(attr.name) || !attr.value || isExternalUrl(attr.value.content) || isDataUrl(attr.value.content) || attr.value.content[0] === \u0026#39;#\u0026#39; || (!options.includeAbsolute \u0026amp;\u0026amp; !isRelativeUrl(attr.value.content)) ) { return } // ... 排除了上面的情况  // 2. 相对路径转换，包括新增的 options.base 选项(db786b1)  // https://github.com/vuejs/vue-next/issues/2477  const url = parseUrl(attr.value.content) if (options.base \u0026amp;\u0026amp; attr.value.content[0] === \u0026#39;.\u0026#39;) { // parseUrl 处理结果  // ~assets/images/ =\u0026gt; assets/images  // 或者  // /assets/images/ =\u0026gt; assets/images  // 最后使用 url 将 base 转成 URL 对象(包含： path,hash,host,...)。  const base = parseUrl(options.base) const protocol = base.protocol || \u0026#39;\u0026#39; const host = base.host ? protocol + \u0026#39;//\u0026#39; + base.host : \u0026#39;\u0026#39; const basePath = base.path || \u0026#39;/\u0026#39; // 经过两次 parseUrl 分别对 attr.value 和 base 的处理  // 最终得到下面的组合  // 假设 base = \u0026#34;https://www.cheng92.com/img/vue\u0026#34;  // \u0026lt;img src=\u0026#34;./vue/test.png\u0026#34; /\u0026gt;  // base = { protocol: \u0026#34;https://\u0026#34;, host: \u0026#34;www.cheng92.com\u0026#34;, path: \u0026#34;/img/vue\u0026#34; }  // url = { path: \u0026#34;vue/test.png\u0026#34;, hash: \u0026#39;\u0026#39; }  // 最终组合结果： base.host + base.path + url.path + url.hash  // = https://www.cheng92.com/img/vue/test.png  // 综合上面的分析  // ~vue/test.png =\u0026gt; import ... from \u0026#39;vue/test.png\u0026#39;  // @vue/test.png =\u0026gt; import ... from \u0026#39;@vue/test.png\u0026#39;  // ./test.png =\u0026gt; https://www.cheng92.com/img/vue/test.png  // 因为只有 . 开头的当做相对路径结合 base 来拼接  attr.value.content = host + (path.posix || path).join(basePath, url.path + (url.hash || \u0026#39;\u0026#39;)) return } // 3. 接下来是没有 options.base 的情况处理，对于资源处理是  const exp = getImportsExpressionExp(url.path, url.hash, attr.loc, context) node.props[index] = { type: NodeTypes.DIRECTIVE, name: \u0026#39;bind\u0026#39;, arg: createSimpleExpression(attr.name, true, attr.loc), exp, modifiers: [], loc: attr.loc } }) }     条件1: 首先是 ELEMENT 类型节点且有 props 的情况下这个函数彩绘被收集进当前组件 的 transform 队列中。\n 条件2: 必需是指定类型的标签，这里有默认的标签列表\n1 2 3 4 5 6 7 8 9 10 11 12 13  export const defaultAssetUrlOptions: Required\u0026lt;AssetURLOptions\u0026gt; = { base: null, includeAbsolute: false, tags: { video: [\u0026#39;src\u0026#39;, \u0026#39;poster\u0026#39;], source: [\u0026#39;src\u0026#39;], img: [\u0026#39;src\u0026#39;], image: [\u0026#39;xlink:href\u0026#39;, \u0026#39;href\u0026#39;], use: [\u0026#39;xlink:href\u0026#39;, \u0026#39;href\u0026#39;] } } // 默认情况只有 video, source, img, image, use 标签 // 满足情况      满足条件后会针对每个 prop 进行单独处理:\n  过滤掉不满足处理条件的\n  非 ATTRIBUTE 类型，可能是指令\n  检查标签属性名是否在 options.tags 对应的 tag 的范围值内, 比如： \u0026lt;img\u0026gt; 是 src， \u0026lt;video\u0026gt; 是 src 或 poster 等等…\n  已经是 http(s):// 打头的完整链接\n  data:xxx 开头的 url ，比如： base64 之后的 url\n  #xx 开头的值，比如： \u0026lt;a href=\u0026#34;#\u0026#34;/\u0026gt;\n  最后一个条件就是过滤掉非相对路径的情况(相对路径： .,~,@ 三个字符开头的路径 被视为相对路径, 比如： \u0026#34;./path/to\u0026#34;, \u0026#34;~/path/to\u0026#34;, \u0026#34;@dir/path/to\u0026#34;)\n    相对路径转换，包括新增的 options.base 选项(db786b1, #2477)\n const url = parseUrl(attr.value.content)\n parseUrl 转换，首先将 ~img/vue/test.png 转成 img/vue/test.png 然后交给 url 解析出 URL 对象： {path, hash, href, host, ...} 如： parseUrl 实现\n  接下来是没有 options.base 或者非相对路径的情况处理，如： ~/img/vue/test.png 或 @img/vue/test.png 的处理\n 转变成 import imgUrl from \u0026#39;…./…./x.png\u0026#39; 的引入语法。\n const exp = getImportsExpressionExp(url.path, url.hash, attr.loc, context)\n 这个函数所完成的工作:\n  从 context.imports 中查找是否已经存在\n  创建 import exp 对象最后会径由 codegen 阶段生成 import … from … 代码(SIMPLE_EXPRESSION)\n  缓存到 context.imports.push({ exp, path })\n  hash 和 path 同时存在的情况\n 对 url 值进行提升处理 context.hoist(…) 比如下面测试中的:\n \u0026lt;use href=\u0026#34;~@svg/file.svg#fragment\u0026#34;\u0026gt;\u0026lt;/use\u0026gt;\n 编译后：\n const _hoisted_1 = _imports_2 + \u0026#39;#fragment\u0026#39; const _hoisted_8 = /*#__PURE__*/_createVNode(\u0026#34;use\u0026#34;, { href: _hoisted_1 }, null, -1 /* HOISTED */)\n 首先是 \u0026lt;use\u0026gt; 元素本身进行了提升，因为是普通标签，没有动态属性或指令，也没 有动态的 children 所以是静态节点给提升，同时因为 href 值有 hash 有 path 所以该值也做了提升处理，当做静态来处理。\n    测试：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21  const url = process.env.VNEXT_PKG_SFC +\u0026#39;/dist/compiler-sfc.cjs.js\u0026#39; const sfc = require(url.replace(\u0026#39;stb-\u0026#39;, \u0026#39;\u0026#39;)) const { compileTemplate: compile } = sfc const source = ` \u0026lt;img src=\u0026#34;/vue/logo.png\u0026#34; /\u0026gt; \u0026lt;img src=\u0026#34;./vue/logo.png\u0026#34; /\u0026gt; \u0026lt;img src=\u0026#34;@vue/logo.png\u0026#34; /\u0026gt; \u0026lt;img src=\u0026#34;~vue/logo.png\u0026#34;/\u0026gt; \u0026lt;img src=\u0026#34;https://www.cheng92.com/img/vue/logo.png\u0026#34;/\u0026gt; \u0026lt;img src=\u0026#34;data:image/png;base64,i\u0026#34;/\u0026gt; \u0026lt;use href=\u0026#34;~@svg/file.svg#fragment\u0026#34;\u0026gt;\u0026lt;/use\u0026gt; ` const opt = {} const run = () =\u0026gt; compile({ source, transformAssetUrls: opt }) let result = run() console.log(\u0026#39;\\n\u0026gt;\u0026gt;\u0026gt; 没有 options.base \\n\u0026#39;, result.code); opt.base = \u0026#39;https://www.cheng92.com/img\u0026#39; result = compile({ source, transformAssetUrls: opt }) console.log(\u0026#39;\\n\u0026gt;\u0026gt;\u0026gt; 有 options.base \\n\u0026#39;, result.code); return 0    \u0026gt;\u0026gt;\u0026gt; 没有 options.base import { createVNode as _createVNode, Fragment as _Fragment, openBlock as _openBlock, createBlock as _createBlock } from \u0026#34;vue\u0026#34; import _imports_0 from \u0026#39;./vue/logo.png\u0026#39; import _imports_1 from \u0026#39;@vue/logo.png\u0026#39; import _imports_2 from \u0026#39;vue/logo.png\u0026#39; import _imports_3 from \u0026#39;@svg/file.svg\u0026#39; const _hoisted_1 = _imports_3 + \u0026#39;#fragment\u0026#39; const _hoisted_2 = /*#__PURE__*/_createVNode(\u0026#34;img\u0026#34;, { src: \u0026#34;/vue/logo.png\u0026#34; }, null, -1 /* HOISTED */) const _hoisted_3 = /*#__PURE__*/_createVNode(\u0026#34;img\u0026#34;, { src: _imports_0 }, null, -1 /* HOISTED */) const _hoisted_4 = /*#__PURE__*/_createVNode(\u0026#34;img\u0026#34;, { src: _imports_1 }, null, -1 /* HOISTED */) const _hoisted_5 = /*#__PURE__*/_createVNode(\u0026#34;img\u0026#34;, { src: _imports_2 }, null, -1 /* HOISTED */) const _hoisted_6 = /*#__PURE__*/_createVNode(\u0026#34;img\u0026#34;, { src: \u0026#34;https://www.cheng92.com/img/vue/logo.png\u0026#34; }, null, -1 /* HOISTED */) const _hoisted_7 = /*#__PURE__*/_createVNode(\u0026#34;img\u0026#34;, { src: \u0026#34;data:image/png;base64,i\u0026#34; }, null, -1 /* HOISTED */) const _hoisted_8 = /*#__PURE__*/_createVNode(\u0026#34;use\u0026#34;, { href: _hoisted_1 }, null, -1 /* HOISTED */) export function render(_ctx, _cache) { return (_openBlock(), _createBlock(_Fragment, null, [ _hoisted_2, _hoisted_3, _hoisted_4, _hoisted_5, _hoisted_6, _hoisted_7, _hoisted_8 ], 64 /* STABLE_FRAGMENT */)) } \u0026gt;\u0026gt;\u0026gt; 有 options.base import { createVNode as _createVNode, Fragment as _Fragment, openBlock as _openBlock, createBlock as _createBlock } from \u0026#34;vue\u0026#34; import _imports_0 from \u0026#39;@vue/logo.png\u0026#39; import _imports_1 from \u0026#39;vue/logo.png\u0026#39; import _imports_2 from \u0026#39;@svg/file.svg\u0026#39; const _hoisted_1 = _imports_2 + \u0026#39;#fragment\u0026#39; const _hoisted_2 = /*#__PURE__*/_createVNode(\u0026#34;img\u0026#34;, { src: \u0026#34;/vue/logo.png\u0026#34; }, null, -1 /* HOISTED */) const _hoisted_3 = /*#__PURE__*/_createVNode(\u0026#34;img\u0026#34;, { src: \u0026#34;https://www.cheng92.com/img/vue/logo.png\u0026#34; }, null, -1 /* HOISTED */) const _hoisted_4 = /*#__PURE__*/_createVNode(\u0026#34;img\u0026#34;, { src: _imports_0 }, null, -1 /* HOISTED */) const _hoisted_5 = /*#__PURE__*/_createVNode(\u0026#34;img\u0026#34;, { src: _imports_1 }, null, -1 /* HOISTED */) const _hoisted_6 = /*#__PURE__*/_createVNode(\u0026#34;img\u0026#34;, { src: \u0026#34;https://www.cheng92.com/img/vue/logo.png\u0026#34; }, null, -1 /* HOISTED */) const _hoisted_7 = /*#__PURE__*/_createVNode(\u0026#34;img\u0026#34;, { src: \u0026#34;data:image/png;base64,i\u0026#34; }, null, -1 /* HOISTED */) const _hoisted_8 = /*#__PURE__*/_createVNode(\u0026#34;use\u0026#34;, { href: _hoisted_1 }, null, -1 /* HOISTED */) export function render(_ctx, _cache) { return (_openBlock(), _createBlock(_Fragment, null, [ _hoisted_2, _hoisted_3, _hoisted_4, _hoisted_5, _hoisted_6, _hoisted_7, _hoisted_8 ], 64 /* STABLE_FRAGMENT */)) } 0     小结：\n   base 选项传递给 compileTemplate 是以 { transformAssetUrls: { base: \u0026#39;...\u0026#39; }} 属性\n  没有 base 情况， ./path/to =\u0026gt; import ... from \u0026#39;./path/to\u0026#39; 当做相对路径处 理\n  有 base 情况, ./path/to =\u0026gt; src: \u0026#39;https://www.cheng92.com/path/to 会将 base 解析后与解析后的 src 进行拼接，没有 import\n  ~ 语法情况， ~/path/to =\u0026gt; import ... from \u0026#39;path/to\u0026#39;\n  @ 语法情况， @path/to =\u0026gt; import ... from \u0026#39;@path/to\u0026#39;\n  ~@ 有 path 又有 hash 的情况， url 值会进行提升，如:\n \u0026lt;use href=\u0026#34;~@svg/file.svg#fragment\u0026#34;\u0026gt;\u0026lt;/use\u0026gt;\n   ","permalink":"https://www.cheng92.com/vue/vue-teardown-7-asset-transform/","tags":["vue3,","vue-next,","assets","transform"],"title":"Vue3 功能拆解⑦ assets url 转换规则"},{"categories":["basis"],"contents":" 路线图：\n  MOOC 大学网教程： https://www.icourse163.org/learn/ZJU-93001?tid=1464647442#/learn/announce\n","permalink":"https://www.cheng92.com/post/data-structure-algorithm/","tags":["数据结构,","算法"],"title":"数据结构与算法 - 学习记录"},{"categories":["emacs"],"contents":" 折腾，折腾。。。\n 用的是 2015 版的 macos 在使用外部输入法的时候 emacs 尤其的卡顿，无奈只能折腾内部 输入法。\n 我的 doom emacs 配置： gcclll/.doom.d: private doom-emacs configuration\n 下面是经过一番折腾整的一个安装脚本：\n 配置安装相关链接：\n .doom.d/config.el at main · eggcaker/.doom.d\n maomiui/rime: Rime 鼠须管（Squirrel）朙月拼音｜小鹤双拼｜自然码双拼配置\n rime/plum: 東風破 plum: Rime configuration manager and input schema repository\n 在Mac版的Emacs中使用RIME输入法\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82  #!/usr/bin/env bash set -euo pipefail DOOM=\u0026#34;$HOME/.doom.d\u0026#34; DYLIB=\u0026#34;/Library/Input Methods/Squirrel.app/Contents/Frameworks/librime.1.dylib\u0026#34; if [ ! -d $DOOM ]; then echo \u0026#34;\u0026gt; 没有 doom-emacs 配置\u0026#34; echo \u0026#34;\u0026gt; 执行 git clone git@github.com:gcclll/.doom.d.git ~/.emacs.d\u0026#34; echo \u0026#34;\u0026gt; 执行 ~/.emacs.d/bin/doom sync\u0026#34; exit -1 fi if [[ ! -e ${DYLIB} ]]; then echo \u0026#34;\u0026gt; Rime 没有安装, 准备安装 Rime 输入法 https://rime.im/download/\u0026#34; echo \u0026#34;\u0026gt; 如果下載速度太慢，建議通過網站下載安裝：https://rime.im/download/\u0026#34; echo \u0026#34;\u0026gt; -------- F4 呼出配置，可進行简体和繁体切换 --------\u0026#34; brew install --cask squirrel echo \u0026#34;\u0026gt; rime installed, link lib into /usr/local/lib\u0026#34; sudo cp \u0026#34;${DYLIB}\u0026#34; /usr/local/lib echo \u0026#34;\u0026gt; -------- Rime 安装完成 --------\u0026#34; echo \u0026#34;\u0026#34; else echo \u0026#34;\u0026gt; Rime 已经存在，无需重复安装。\u0026#34; fi echo \u0026#34;\u0026gt; -------- 开始安装 rime-install 命令 --------\u0026#34; PLUM=\u0026#34;$DOOM/extensions/plum\u0026#34; if [ ! -d $PLUM ]; then cd $DOOM git submodule add --depth 1 https://github.com/rime/plum.git extensions/plum fi cd $PLUM bash rime-install :preset echo \u0026#34;\u0026gt; -------- rime-install 安装完成 --------\u0026#34; echo \u0026#34;\u0026#34; echo \u0026#34;\u0026gt; -------- 开始安装 Rime 五笔 --------\u0026#34; bash rime-install wubi pinyin-simp echo \u0026#34;\u0026gt; -------- Rime 五笔安装完成 --------\u0026#34; echo \u0026#34;\u0026#34; echo \u0026#34;\u0026gt; -------- 开始构建 librime.so --------\u0026#34; echo \u0026#34;\u0026gt; 1. installing cmake \u0026amp; git dependencies...\u0026#34; brew install cmake git LIB=\u0026#34;$DOOM/extensions/librime\u0026#34; if [ ! -d $LIB ]; then echo \u0026#34;\u0026gt; clone librime -\u0026gt; $LIB\u0026#34; cd $DOOM # [[https://rime.im/download/][下載及安裝 | RIME | 中州韻輸入法引擎]] git submodule add --depth=1 https://github.com/rime/librime.git extensions/librime fi echo \u0026#39;\u0026gt; export RIME_PATH=\u0026#34;$LIB\u0026#34;\u0026#39; export RIME_PATH=\u0026#34;$LIB\u0026#34; cd $LIB echo \u0026#34;\u0026gt; 2. begin make -\u0026gt; xcode/thirdparty/boost\u0026#34; make xcode/thirdparty/boost echo \u0026#39;\u0026gt; export BOOST_ROOT=\u0026#34;$(pwd)/thirdparty/src/boost_1_75_0\u0026#34;\u0026#39; export BOOST_ROOT=\u0026#34;$(pwd)/thirdparty/src/boost_1_75_0\u0026#34; echo \u0026#34;\u0026gt; 3. building 3rd parth libraries...\u0026#34; git submodule update --init make xcode/thirdparty echo \u0026#34;\u0026gt; 4. building librime ...\u0026#34; make xcode make xcode/debug echo \u0026#34;\u0026gt; done.\u0026#34; echo \u0026#34;\u0026gt; 5. running unit tests...\u0026#34; make xcode/test echo \u0026#34;\u0026gt; 6. try it ...\u0026#34; cd debug/bin echo \u0026#34;congmingdeRime{space}shurufa\u0026#34; | Debug/rime_api_console     其他：\n maomiui/rime: Rime 鼠须管（Squirrel）朙月拼音｜小鹤双拼｜自然码双拼配置\n 安装生字字体： rime/花园明朝字体 at master · maomiui/rime\n 因为中文脚本问题，所以 fork 了一份出来，目录都改成了英文名。\n gcclll/rime: Rime 鼠须管（Squirrel）朙月拼音｜小鹤双拼｜自然码双拼配置\n","permalink":"https://www.cheng92.com/emacs/emacs-rime-pyim/","tags":["emacs,","doomemacs,","rime,","pyim"],"title":"Doom Emacs 上配置Rime + Pyim"},{"categories":["macos"],"contents":" 😀😀😀😀😀😀😀😀😀😀😀😀😀😀😀😀 MacOS 系统相关的东西 😀😀😀😀😀😀😀😀😀😀😀😀😀😀😀😀     insertCssLink(\"https://unpkg.com/element-plus/lib/theme-chalk/index.css\"); insertCssLink(\"/js/vue/css/awesome.css\");    CLI  bcal, 字节计算，转换   bcal 进入或直接使用 $ bcal \u0026lt;expr\u0026gt; ... :\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24  ╭─simon at gcl in ~/.doom.d on native✘✘✘ 21-07-22 - 15:24:39 ╰─⠠⠵ bcal ~/.doom.d q/double Enter -\u0026gt; quit, ? -\u0026gt; help bcal\u0026gt; \u0026#34;(5kb+10mb)\u0026#34; 10005000 B IEC standard (base 2) 9.7705078125e+03 KiB 9.5415115356e+00 MiB 9.3178823590e-03 GiB 9.0994944912e-06 TiB SI standard (base 10) 10005 kB 1.0005000000e+01 MB 1.0005000000e-02 GB 1.0005000000e-05 TB ADDRESS (d) 10005000 (h) 0x98aa08 bcal\u0026gt;     使用方式，采用各种表达式方式：\n  支持数学计算\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28  $ bcal \u0026#34;(5kb+2mb)/3\u0026#34; $ bcal \u0026#34;5 tb / 12\u0026#34; $ bcal \u0026#34;2.5mb*3\u0026#34; ╰─⠠⠵ bcal \u0026#34;2.5mb*3\u0026#34; ~/.doom.d RESULT 7500000 B IEC standard (base 2) 7.3242187500e+03 KiB 7.1525573730e+00 MiB 6.9849193096e-03 GiB 6.8212102633e-06 TiB SI standard (base 10) 7500 kB 7.5000000000e+00 MB 7.5000000000e-03 GB 7.5000000000e-06 TB ADDRESS (d) 7500000 (h) 0x7270e0 $ bcal \u0026#34;(2giB * 2) / (2kib \u0026gt;\u0026gt; 2)\u0026#34; ╰─⠠⠵ bcal \u0026#34;(2giB * 2) / (2kib \u0026gt;\u0026gt; 2)\u0026#34; ~/.doom.d 8388608      转成其它格式，单位大小写敏感\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31  $ bcal 20140115 b $ bcal 0x1335053 B $ bcal 0xaabbcc kb $ bcal 0xdef Gib ╭─simon at gcl in ~/.doom.d on native✔ 21-07-22 - 15:39:04 ╰─⠠⠵ bcal 20140115 b ~/.doom.d UNIT CONVERSION 20140115 B IEC standard (base 2) 1.9668081055e+04 KiB 1.9207110405e+01 MiB 1.8756943755e-02 GiB 1.8317327886e-05 TiB SI standard (base 10) 2.0140115000e+04 kB 2.0140115000e+01 MB 2.0140115000e-02 GB 2.0140115000e-05 TB ADDRESS (d) 20140115 (h) 0x1335053 LBA:OFFSET (sector size: 0x200) (d) 39336:83 (h) 0x99a8:0x53      指定区块大小\n1  $ bcal 0xaabbcc kb -s 4096      LBA 转成 CHS:\n1 2 3 4 5 6 7 8 9 10  $ bcal -f l500 $ bcal -f l0x600-18-0x7e $ bcal -f l0x300-0x12-0x7e # result: ╭─simon at gcl in ~/.doom.d on native✔ 21-07-22 - 15:32:44 ╰─⠠⠵ bcal -f l500 ~/.doom.d LBA2CHS LBA:500 MAX_HEAD:16 MAX_SECTOR:63 CHS: (d) 0 7 60, (h) 0x0 0x7 0x3c      CHS 转成 LBA\n1 2 3 4 5 6 7 8 9 10  $ bcal -f l500 $ bcal -f l0x600-18-0x7e $ bcal -f l0x300-0x12-0x7e # result: ╭─simon at gcl in ~/.doom.d on native✔ 21-07-22 - 15:40:28 ╰─⠠⠵ bcal -f l0x300-0x12-0x7e ~/.doom.d LBA2CHS LBA:768 MAX_HEAD:18 MAX_SECTOR:126 CHS: (d) 0 6 13, (h) 0x0 0x6 0xd      显示一个数据的2进制，10 进制和 16 进制表示形式\n b (2进制), d (十进制), h (16进制)。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21  $ bcal -c 20140115 ╭─simon at gcl in ~/.doom.d on native✔ 21-07-22 - 15:44:32 ╰─⠠⠵ bcal -c 20140115 ~/.doom.d (b) 0b1001100110101000001010011 (d) 20140115 (h) 0x1335053 $ bcal -c 0b1001100110101000001010011 ╭─simon at gcl in ~/.doom.d on native✔ 21-07-22 - 15:44:14 ╰─⠠⠵ bcal -c 0b1001100110101000001010011 ~/.doom.d (b) 0b1001100110101000001010011 (d) 20140115 (h) 0x1335053 $ bcal -c 0x1335053 ╭─simon at gcl in ~/.doom.d on native✔ 21-07-22 - 15:42:10 ╰─⠠⠵ bcal -c 0x1335053 ~/.doom.d (b) 0b1001100110101000001010011 (d) 20140115 (h) 0x1335053     交互模式：\n1 2  q/double Enter -\u0026gt; quit, ? -\u0026gt; help bcal\u0026gt; c 20140115 # 直接使用对应的选项      执行 bc, 在交互模式下输入 b\n1 2 3 4  $ bcal -b \u0026#39;3.5 * 2.1 + 5.7\u0026#39; bcal\u0026gt; b bc vars: scale = 10, ibase = 10, last = r bc\u0026gt; 3.5 * 2.1 + 5.7      管道输入，结果给 bcal 处理\n1 2  $ printf \u0026#39;15 kib + 15 gib \\n r / 5\u0026#39; | bcal -m $ printf \u0026#39;15 + 15 + 2\u0026#39; | bcal -bm      从文件获取输入给 bcal\n1 2 3 4  $ cat expr 15 gib + 15 kib r / 5 $ bcal -m \u0026lt; expr          Nix   install:\n NixOS - NixOS Linux\n Nix on macOS, Made Easy - 知乎\n MacOS Nix Setup (an alternative to Homebrew)\n $ curl -L https://nixos.org/nix/install | sh\n 新系统不能安装问题，无权限创建 /nix\n $ sh \u0026lt;(curl -L https://nixos.org/nix/install) --darwin-use-unencrypted-nix-store-volume\nCreating volume and mountpoint /nix. ------------------------------------------------------------------ | This installer will create a volume for the nix store and | | configure it to mount at /nix. Follow these steps to uninstall. | ------------------------------------------------------------------ 1. Remove the entry from fstab using \u0026#39;sudo vifs\u0026#39; 2. Destroy the data volume using \u0026#39;diskutil apfs deleteVolume\u0026#39; 3. Remove the \u0026#39;nix\u0026#39; line from /etc/synthetic.conf or the file ... Installation finished! To ensure that the necessary environment variables are set, either log in again, or type . /Users/simon/.nix-profile/etc/profile.d/nix.sh in your shell.   完成之后：\n# simon @ gcl in ~ [20:18:32] $ nix Usage: nix \u0026lt;COMMAND\u0026gt; \u0026lt;FLAGS\u0026gt;... \u0026lt;ARGS\u0026gt;... Common flags: --debug enable debug output --help show usage information --help-config show configuration options --no-net disable substituters and consider all previously downloaded files up-to-date --option \u0026lt;NAME\u0026gt; \u0026lt;VALUE\u0026gt; set a Nix configuration option (overriding nix.conf) -L, --print-build-logs print full build logs on stderr --quiet decrease verbosity level -v, --verbose increase verbosity level --version show version information In addition, most configuration settings can be overriden using \u0026#39;--\u0026lt;name\u0026gt; \u0026lt;value\u0026gt;\u0026#39;. Boolean settings can be overriden using \u0026#39;--\u0026lt;name\u0026gt;\u0026#39; or \u0026#39;--no-\u0026lt;name\u0026gt;\u0026#39;. See \u0026#39;nix --help-config\u0026#39; for a list of configuration settings. Available commands: add-to-store add a path to the Nix store build build a derivation or fetch a store path cat-nar print the contents of a file inside a NAR file cat-store print the contents of a store file on stdout copy copy paths between Nix stores copy-sigs copy path signatures from substituters (like binary caches) doctor check your system for potential problems dump-path dump a store path to stdout (in NAR format) edit open the Nix expression of a Nix package in $EDITOR eval evaluate a Nix expression hash-file print cryptographic hash of a regular file hash-path print cryptographic hash of the NAR serialisation of a path log show the build log of the specified packages or paths, if available ls-nar show information about the contents of a NAR file ls-store show information about a store path optimise-store replace identical files in the store by hard links path-info query information about store paths ping-store test whether a store can be opened repl start an interactive environment for evaluating Nix expressions run run a shell in which the specified packages are available search query available packages show-config show the Nix configuration show-derivation show the contents of a store derivation sign-paths sign the specified paths to-base16 convert a hash to base-16 representation to-base32 convert a hash to base-32 representation to-base64 convert a hash to base-64 representation to-sri convert a hash to SRI representation upgrade-nix upgrade Nix to the latest stable version verify verify the integrity of store paths why-depends show why a package has another package in its closure Note: this program is EXPERIMENTAL and subject to change.   安装 nix-darwin:\n1 2  nix-build https://github.com/LnL7/nix-darwin/archive/master.tar.gz -A installer ./result/bin/darwin-installer     配置： /Users/simon/.nixpkgs/darwin-configuration.nix\n{ config, pkgs, ... }: { # List packages installed in system profile. To search by name, run: $ nix-env -qaP | grep wget environment.systemPackages = [ pkgs.vim ]; # Use a custom configuration.nix location. $ darwin-rebuild switch -I # darwin-config=$HOME/.config/nixpkgs/darwin/configuration.nix environment.darwinConfig = # \u0026#34;$HOME/.config/nixpkgs/darwin/configuration.nix\u0026#34;; # Auto upgrade nix package and the daemon service. services.nix-daemon.enable = true; # nix.package = pkgs.nix; # Create /etc/bashrc that loads the nix-darwin environment. programs.zsh.enable = true; # default shell on catalina # programs.fish.enable = true; # Used for backwards compatibility, please read the changelog before changing. $ darwin-rebuild # changelog system.stateVersion = 4; }   配置文件每次修改之后要执行 darwin-rebuild switch 生效。\n 更新包: nix-channel --update\n  awesome tools   https://github.com/jaywcjlove/awesome-mac/blob/master/README-zh.md\n example:\n1 2  \u0026lt;div id=\u0026#34;test\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;script src=\u0026#34;/path/to/test.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt;    Share VPN   Parallel Desktop - Ubuntu share the VPN of host computer.\n Ubuntu -\u0026gt; 设置 -\u0026gt; 网络 -\u0026gt; VPN: Network Proxy, 网络代理：\n http/https, socks proxy:\n IP: 宿主机的 IP，推荐配置成静态IP。\n PORT: 代理工具的端口号，比如： clashX 的 7890/7891\n 完了之后还要在代码工具那允许下局域网连接：\n   窗口管理        ubuntu  修改家目录和主机名   假设当前名字为 parallels (安装虚拟机的时候默认是这个), 将基修改为： simon\n  $ su , 切换 root\n  $ passwd \u0026lt;user\u0026gt;, 修改密码\n  $ reboot, 重启\n  $ su\n  $ vim /etc/passwd, 找到 parallels 那一行， 只修改用户名为 simon，其它不要动\n  $ vim /etc/shadow, 找到 parallels 那一行，同样只修改用户名为 simon\n  $ vim /etc/group, 找到所有的 parallels, 使用 :%s/parallels/simon/g 全局替换\n  $ reboot, 重启\n  $ vim /etc/hostname 修改成想要的主机名\n  $ vim /etc/passwd 找到 simon 那一行(这里用户名已经经过上面的修改成了 simon)， 修改目录名\n  $ cd /home\n  $ mv parallels simon, 修改家目录名字\n  $ reboot, OK.\n   可能的问题（我没遇到）：修改主目录名时候，只修改了 /etc/password 而没有给 /home/parallels 重命名，导致开机后一直登陆蛤面循环。\n 解 ： Ctrl+Alt+[F1~F6] 登陆后直接修改 /home/parallels, 重启。\n Ctrl+Alt+F7 进入图形模式。\n    ","permalink":"https://www.cheng92.com/post/macos/","tags":["macos"],"title":"My MacOS"},{"categories":["vue"],"contents":" 诗号：六道同坠，魔劫万千，引渡如来。  \n  --  insertCssLink(\"https://unpkg.com/element-plus/lib/theme-chalk/index.css\");       本文从源码角度讲解了vue中的事件注册机制(v-on 指令)。\n  该文分析的相关代码在 packages/runtime-dom 包中，主要针对 v-on 的事件注册机制原理 进行分析一篇文章，相关代码并不多，理解起来也不会有什么困难。\n props 属性 patch 入口： runtime-dom/src/patchProp.ts\n 针对 v-on 处理的代码分支：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29  export const patchProp: DOMRendererOptions[\u0026#39;patchProp\u0026#39;] = ( el, key, prevValue, nextValue, isSVG = false, prevChildren, parentComponent, parentSuspense, unmountChildren ) =\u0026gt; { switch (key) { // ... class, style 属性的处理，主要是进行合并操作  default: if (isOn(key)) { // ignore v-model listeners  // v-on 事件属性处理逻辑  if (!isModelListener(key)) { patchEvent(el, key, prevValue, nextValue, parentComponent) } } else if (shouldSetAsProp(el, key, nextValue, isSVG)) { // ... dom 原生属性处理  } else { // ...  } break } }     所以重点代码在\n patchEvent(el, key, prevValue, nextValue, parentComponent)\n 也就是 runtime-dom/src/modules/events.ts 中\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26  export function patchEvent( el: Element \u0026amp; { _vei?: Record\u0026lt;string, Invoker | undefined\u0026gt; }, rawName: string, prevValue: EventValue | null, nextValue: EventValue | null, instance: ComponentInternalInstance | null = null ) { // vei = vue event invokers  const invokers = el._vei || (el._vei = {}) const existingInvoker = invokers[rawName] if (nextValue \u0026amp;\u0026amp; existingInvoker) { // patch  existingInvoker.value = nextValue } else { const [name, options] = parseName(rawName) if (nextValue) { // add  const invoker = (invokers[rawName] = createInvoker(nextValue, instance)) addEventListener(el, name, invoker, options) } else if (existingInvoker) { // remove  removeEventListener(el, name, existingInvoker, options) invokers[rawName] = undefined } } }     可以看到这里实现是一种特殊处理方式，而不是简单的直接调用 addEventListener 和 removeEventListener 直接将所有事件句柄注册到 element 上。\n1 2  const invokers = el._vei || (el._vei = {}) const existingInvoker = invokers[rawName]     el._vei =\u0026gt; vue event invokers\n 参数说明：\n   name desc     el 事件的目标元素   rawName 事件名称   prevValue 绑定在 el 上 rawName 对应事件的老句柄   nextValue 绑定在 el 上 rawName 对应事件的新句柄   instance 当前组件的实例     参数重点在于 prevValue \u0026amp; nextValue 这两个分别对应了事件的处理新旧函数。\n 对于所有的 prevValue \u0026amp; nextValue 对应的事件处理函数都不会是直接被注册，而是会被 封装成一个 Invoker 形式存在。\n 而 Invoker 来自 createInvoker(nextValue):\n 一个二次封装函数：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25  function createInvoker( initialValue: EventValue, instance: ComponentInternalInstance | null ) { const invoker: Invoker = (e: Event) =\u0026gt; { // async edge case #6566: inner click event triggers patch, event handler  // attached to outer element during patch, and triggered again. This  // happens because browsers fire microtask ticks between event propagation.  // the solution is simple: we save the timestamp when a handler is attached,  // and the handler would only fire if the event passed to it was fired  // AFTER it was attached.  const timeStamp = e.timeStamp || _getNow() if (timeStamp \u0026gt;= invoker.attached - 1) { callWithAsyncErrorHandling( patchStopImmediatePropagation(e, invoker.value), instance, ErrorCodes.NATIVE_EVENT_HANDLER, [e] ) } } invoker.value = initialValue invoker.attached = getNow() return invoker }     返回一个\n1 2 3 4  interface Invoker extends EventListener { value: EventValue attached: number }     封装过程重点做了几件事情：\n  invoker 里面 callWithAsyncErrorHandling() 方式执行了事件句柄函数\n 拦截事件处理函数执行过程中差生的错误异常，这些异常可以通过 vue 的全局配置来捕 获：\n1 2 3 4  const instance = createApp(App) instance.config.errorHandler = function(err, vm, info) { // 处理错误异常 }      执行前提是 timeStamp \u0026gt;= invoker.attached - 1\n 注释内容：\n async edge case #6566: inner click event triggers patch, event handler attached to outer element during patch, and triggered again. This happens because browsers fire microtask ticks between event propagation. the solution is simple: we save the timestamp when a handler is attached, and the handler would only fire if the event passed to it was fired AFTER it was attached.\n  个人翻译理解： 事件注册期间会同时注册到 outer element 上，这是因为浏览器会在 事件冒泡期间触发微任务 ticks，从而导致会被重复触发事件。\n 解决方案就是记录事件注册完成时的时间戳，在执行的时候检测是不是过了该时间，只 有过了该时间触发的才会去执行。\n  记录时间戳\n1 2  invoker.value = initialValue invoker.attached = getNow()      TIP\n 注意在 invoker 函数中有个特殊步骤：\n patchStopImmediatePropagation(e, invoker.value) 这是做什么的？？？\n 稍后再讲~~\n  回头在看 patchProp()\n el._vei 上保存了所有的 \u0026lt;eventName, fns\u0026gt; 事件和事件句柄的映射关系。\n 当发现新事件来到时，首先检测的是当前事件名是不是曾经注册过事件句柄，如果注册过就 继续复用并且直接覆盖之前的注册的事件句柄:\n1 2 3 4  if (nextValue \u0026amp;\u0026amp; existingInvoker) { // patch  existingInvoker.value = nextValue }     但是请注意，这里的覆盖并非是直接就将 element 上的 listener 删除了再赋值 (addEventListener)的操作。\nWARNING\n 时刻注意，绑定到 element 上的 event listener 永远都是一个 Invoker，且一旦第一次 注册了之后这个 Invoker 就会一直作为该 element 上 event name 对应的 event listener 存在。之后的所有变更都是发生在封装之后的 Invoker 上的，如上面的赋值操作，改变的 只是 invoker.value 。\n  而对于这个 value 值是个 type EventValue = Function | Function[] 类型，这个值 的处理发生在 compiler-core 和 compiler-dom 阶段的 vOn.ts 中，这里就不多做赘述了， 有兴趣的可以通过链接查看之前相关的分析(compiler-core 重点在于模指令的解析， compiler-dom 阶段重点在于修饰符的处理上)。\n 继续看 patchEvent :\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  if (nextValue \u0026amp;\u0026amp; existingInvoker) { // patch  existingInvoker.value = nextValue } else { const [name, options] = parseName(rawName) if (nextValue) { // add  const invoker = (invokers[rawName] = createInvoker(nextValue, instance)) addEventListener(el, name, invoker, options) } else if (existingInvoker) { // remove  removeEventListener(el, name, existingInvoker, options) invokers[rawName] = undefined } }     两个 if…else，这段代码很容易理解不是！！！\n 需要注意的是最后的一个 else if (existingInvoker) 到这里的时候会将事件句柄给移 除。\n 比如：\n \u0026lt;div @click=\u0026#34;null\u0026#34; /\u0026gt; \u0026lt;div @click=\u0026#34;\u0026#34; /\u0026gt; \u0026lt;div @click=\u0026#34;false\u0026#34; /\u0026gt;\n 等等，事件句柄是一些空值的时候会当作是移除操作。\n 那么到这里基本也完成了事件的『封装-注册-移除』部分代码。\n  封装： Invoker 记录 attach 时间戳防止重复触发，捕获异常\n  注册：一个事件名只会注册一个 Invoker 后续操作都是针对这个 invoker 而言\n  移除：使用 v-on 最后解析得到的值如果是空值时会被视为移除操作\n  那么之前说到的 patchStopImmediatePropagation(e, invoker.value) 又是什么操作？\n 对于原生的事件有个原生的函数 event.stopImmediatePropagation() 这个函数的含义： 它可以在任意一个事件句柄函数中调用，来阻止后面的事件被调用。\n 比如：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24  const a = () =\u0026gt; { // log a } const b = (e) =\u0026gt; { // log b  e.stopImmediatePropagation() } const c = () =\u0026gt; { // log c } const d = () =\u0026gt; { // log d } el.addEventListener(\u0026#39;click\u0026#39;, a) el.addEventListener(\u0026#39;click\u0026#39;, b) el.addEventListener(\u0026#39;click\u0026#39;, c) el.addEventListener(\u0026#39;click\u0026#39;, d) // 完了之后触发 click 会得到结果 // log a // log b  // c/d 不会被执行，这就是 stopImmediatePropagation 的作用。      因此 vue events.ts 中的 patchStopImmediatePropagation(e: Event, value: EventValue) 就是为了模拟这个作用，来让这个原生功能生效，因为 events.ts 中对事件 的绑定上面说过了，针对element上同一事件名的事件只会有一个句柄 Invoker 函数，所以 原生的 stopImmediatePropagation 功能就会失效。\n 功能模拟：只有 invoker.value 是个数组时才会生效。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  function patchStopImmediatePropagation( e: Event, value: EventValue ): EventValue { if (isArray(value)) { const originalStop = e.stopImmediatePropagation e.stopImmediatePropagation = () =\u0026gt; { originalStop.call(e) ;(e as any)._stopped = true } return value.map(fn =\u0026gt; (e: Event) =\u0026gt; !(e as any)._stopped \u0026amp;\u0026amp; fn(e)) } else { return value } }     其实就是重写了 e.stopImmediatePropagation 给事件注册一个 _stopped 属性，然后将 value 中所有的 fn 进一步进行封装返回一个全新的 fn:\n (e: Event) =\u0026gt; !(e as any)._stopped \u0026amp;\u0026amp; fn(e)\n 通过检测 _stoppped 标记来达到阻止后续函数的执行的目的。\n 最后，这里还有个针对三个修饰符的处理(/(?:Once|Passive|Capture)$/)，因为在 compiler-dom 阶段，这三个修饰符会被单独解析，比如：\n \u0026lt;div @click.once=.../\u0026gt;\n 最后被解析成 onClickOnce 依此类推： onClickPassive, onClickCapture 所以这 里要进行拆分一下，等于是拆分出：\n {once: true, passive: true, capture: true} 的结构。\n 源码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17  const optionsModifierRE = /(?:Once|Passive|Capture)$/ function parseName(name: string): [string, EventListenerOptions | undefined] { let options: EventListenerOptions | undefined if (optionsModifierRE.test(name)) { options = {} let m while ((m = name.match(optionsModifierRE))) { name = name.slice(0, name.length - m[0].length) ;(options as any)[m[0].toLowerCase()] = true options } } // return [name.slice(2).toLowerCase(), options]  // #b302cbb, fooBar -\u0026gt; foo-bar  return [hyphenate(name.slice(2)), options] }    WARNING\n *小结*：\n 有点湊篇幅的嫌疑 😪\n 内容其实很简单，四个函数，两次封装。\n  createInvoker 封装事件句柄函数 Invoker\n  patchEvent 检测 el._vei 注册 invoker.value\n  patchStopImmediatePropagation 通过添加 event._stopped 模拟原生功能，拦截后面 的函数执行\n  parseName 三个修饰符的处理工作 once/passive/capture\n   ","permalink":"https://www.cheng92.com/vue/vue-teardown-6-event-listen/","tags":["vue3,","vue-next,","component,","directives"],"title":"Vue3 功能拆解⑥ directives 事件绑定机制"},{"categories":["vue"],"contents":"  诗号：六道同坠，魔劫万千，引渡如来。  \n  --  insertCssLink(\"https://unpkg.com/element-plus/lib/theme-chalk/index.css\");       https://github.com/vuejs/vue-next/blob/master/CHANGELOG.md\n前言  TIP\n 本系列文说明：会不定期的更新本地的 vue-next 仓库，本系列文章则是针对 git pull 后 的更新内容的分析和记录， 。\n 可参过链接跳转到对应的分析文章\n  更新内容：\n 很久没更新了，惨~~~~~~~~~\n 捡点重要的来看下吧，以后还是要保持每周拉一次代码比较好！！！\n 最初分析拉取的代码是： 3.0.4, 现在都 3.1.2 了 尴尬！！!\n  3.0.8 (2021-03-26)  Important    IMP: SFC style 中的 ::v-slotted 和 :slotted 🔗 \n    TODO Bug Fixes [0/44]   compiler: properly bail stringfication for nested slot elements (f74b16c)\n compiler-core: allow unicode to appear in identifiers (#3443) (ebedccc), closes #3440\n compiler-core: avoid generating useless createVNode helper (#2938) (7715c49), closes #2739\n compiler-core: detect v-if branch root with comment as dev fragment (#2785) (4bf7ba1), closes #2780\n compiler-core: fix the detection of forwarded slots with v-if or v-for (#3353) (602b58e), closes #3347\n compiler-core: should not condense whitespace in RCDATA text mode (#3482) (b4b8215), closes #3479\n compiler-dom: stringifyStatic should remove attribute bindings with null value (#3477) (ca6aa01), closes #3475\n compiler-sfc: scope Id should not be attached to @keyframe breakpoint rules (#3308) (6cb9475), closes #3304\n compiler-sfc: should not rewrite scope variable (#3449) (bbc5fe6), closes #3445\n compiler-ssr: keep the order of imports expression for the fallback branch of SSR (#3448) (49f4072), closes #3447\n component: prioritize registered component over implicit self-reference via filename (abd129d), closes #2827\n hydration: handle camel-case tag name when performing match assertion (#3247) (9036f88), closes #3243\n KeepAlive: adapt keepalive for ssr (#3259) (e8e9b00), closes #3255\n reactivity: ensure computed can be wrapped by readonly (41e02f0), closes #3376\n reactivity: ensure that shallow and normal proxies are tracked seperately (close #2843) (#2851) (22cc4a7)\n reactivity: fix shallow readonly behavior for collections (#3003) (68de9f4), closes #3007\n rumtime-core: custom dom props should be cloned when cloning a hoisted DOM (#3080) (5dbe834), closes #3072\n runtime-core: cache props default values to avoid unnecessary watcher trigger (#3474) (44166b4), closes #3471\n runtime-core: ensure only skip unflushed job (#3406) (bf34e33)\n runtime-core: fix async component ref handling (#3191) (7562e72), closes #3188\n runtime-core: fix erraneous emits warnings w/ mixins (60d777d), closes #2651\n runtime-core: fix warning for absent props (#3363) (86ceef4), closes #3362\n runtime-core: handle error in async setup (#2881) (d668d48)\n runtime-core: handle error in async watchEffect (#3129) (eb1fae6)\n runtime-core: should call chained mixins and extends (#3040) (b58bb16), closes #3038\n runtime-core: should not cache property access during data() invocation (#3299) (6e88156), closes #3297\n runtime-core: should not track deps in pre flush watcher callbacks (d5824b9), closes #2728\n runtime-core: the select tag\u0026#39;s multiple prop should be set before the children mounting (#3202) (2451dd8), closes #3199\n runtime-dom: support mounting app to svg container (#2929) (8ffcde2), closes #2926\n ssr: ensure async setup error handling work with suspense during ssr (2e71f07)\n ssr: fix memory leak when vnode component render throws error (da944cb), closes #3100\n ssr: properly update currentRenderingInstance state during ssr (8c3c14a), closes #2863\n ssr: respect render function from extends/mixins in ssr (#3006) (0a583d5), closes #3004\n ssr: watchEffect onInvalidate runner initialization (#3323) (e4b5fcc), closes #3322\n ssr/hydration: handle ending empty text node (#3246) (420c8f4), closes #3245\n teleport: targetAnchor should also be removed when unmounted (#2870) (21d1288)\n Teleport: component with multi roots should be removed when unmounted (#3157) (7769513), closes #3156\n Teleport: fallback to non-optimized mode when HRM performing updates (#3311) (9cb21d0), closes #3302\n transition: toggling branches with in-out mode should be transitioned correctly (#3109) (67a0290), closes #3104\n types: allow style to be an array in JSX (#2947) (13c9d2c)\n types: union function prop (#3119) (3755e60), closes #3357\n types: unwrap refs on public instance data (#3319) (2b588cf), closes #3315\n types/jsx: llow tabindex to be a string (#3476) (e4a5712)\n add display name for suspense component (#3312) (3b3a9a1)\n    DONE Performance Improvements [1/1]  CLOSED: [2021-08-09 Mon 21:23]\n support only attaching slot scope ids when necessary (02cbbb7) \n SFC style 中使用\n :slotted(h1) { color: blue; }\n 或\n ::v-slotted(h1) { color: blue; }\n 可以在当前组件中控制 slot 组件的样式。\n https://codesandbox.io/s/damp-cdn-k9eed?file=/src/main.js\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20  const url = process.env.VNEXT_PKG_RC + \u0026#34;/../compiler-sfc/dist/compiler-sfc.cjs.js\u0026#34;; const value = require(url.replace(\u0026#34;stb-\u0026#34;, \u0026#34;\u0026#34;)); const { compileScript, parse, compileStyle } = value; function compileScoped(source, options) { const res = compileStyle({ source, filename: \u0026#39;test.css\u0026#39;, id: \u0026#39;data-v-test\u0026#39;, scoped: true, ...options }) return res.code } const src = `::v-slotted(h1) { color: red; } :slotted(h1) {font-size:12px;}` const code = compileScoped(src) console.log(code) return 0;    h1[data-v-test-s] { color: red; } h1[data-v-test-s] {font-size:12px;} 0   下面会检查 style 中是不是含 ::v-slotted(...) {...} 或 :slotted(...) {..} 指令\n1 2 3 4  // packages/compiler-sfc/src/parse.ts // check if the SFC uses :slotted const slottedRE = /(?:::v-|:)slotted\\(/ descriptor.slotted = descriptor.styles.some(s =\u0026gt; slottedRE.test(s.content))     根据上面的结果，在 parse SFC template 阶段给组件加上 scope-id-s 属性， 如：\n \u0026lt;div scope-id-s /\u0026gt;\n1 2 3 4 5  // packages/compiler-ssr/src/transforms/ssrTransformSlotOutlet.ts // inject slot scope id if current template uses :slotted if (context.scopeId \u0026amp;\u0026amp; context.slotted !== false) { args.push(`\u0026#34;${context.scopeId}-s\u0026#34;`) }          3.0.7 (2021-08-08)  Important    FIX: \u0026lt;script setup\u0026gt; 中 export default 和 class 语法 🔗\n  FIX: v-show 的优先级比 {style: { display: \u0026#39;block\u0026#39; }} 更高 🔗\n  FIX: scheduler 中 组件更新任务总是保持以 job.id 的增序执行，在插入的时候找到 对应的索引插入 🔗 \n    DONE Bug Fixes [6/6]  CLOSED: [2021-08-09 Mon 15:23]\n ✅ compiler-sfc: handle more edge cases in default rewrite (1dedc19) \n 处理 setup script 中更多语法情况：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18  const url = process.env.VNEXT_PKG_RC + \u0026#34;/../compiler-sfc/dist/compiler-sfc.cjs.js\u0026#34;; const value = require(url.replace(\u0026#34;stb-\u0026#34;, \u0026#34;\u0026#34;)); const { rewriteDefault } = value; const test = (hint, code) =\u0026gt; { console.log(\u0026#39;\u0026gt; \u0026#39; + hint + \u0026#39;\\n\u0026#39;); console.log(rewriteDefault(code, \u0026#39;script\u0026#39;)) } test(\u0026#39;1. comments\u0026#39;, `// export default\\nexport default {}`) test(\u0026#39;2. export default class\u0026#39;, `export default class Foo {}`) test(\u0026#39;3. export default class + commons\u0026#39;, `// export default\\nexport default class Foo {}`) test(\u0026#39;4. export default class + comments 2\u0026#39;, `export default {}\\n` + `// export default class Foo {}`) test(\u0026#39;5. export default class + comments 3\u0026#39;, `/*\\nexport default class Foo {}*/\\n` + `export default class Bar {}`) console.log(\u0026#39;------ end ------ \u0026#39;); return 0;    \u0026gt; 1. comments // export default const script = {} \u0026gt; 2. export default class class Foo {} const script = Foo \u0026gt; 3. export default class + commons // export default class Foo {} const script = Foo \u0026gt; 4. export default class + comments 2 const script = {} // export default class Foo {} \u0026gt; 5. export default class + comments 3 /* export default class Foo {}*/ const script = class Bar {} ------ end ------ 0   ✅ deps: pin Rollup to 2.38 (34f354b), closes #3332\n ✅ runtime-core: properties in methods should be writable and enumerable in DEV (#3301) (e3568ba), closes #3300\n1 2 3 4 5 6 7 8 9 10 11  3 packages/runtime-core/src/componentOptions.ts @@ -610,7 +610,8 @@ export function applyOptions(  Object.defineProperty(ctx, key, { value: methodHandler.bind(publicThis), configurable: true, - enumerable: false + enumerable: true, + writable: true  }) } else { ctx[key] = methodHandler.bind(publicThis)      ✅ scheduler: ensure updates are always inserted in ascending id order (#3184) (45fae9d), closes #2768 #2829 \n View isn\u0026#39;t updated in a weird case (combination of many factors, transition, injection \u0026amp; computed)\n 确保 updates 总是以升序被插入，那么在插入之前就得找到适当的 job 索引:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18  // #2768 // Use binary-search to find a suitable position in the queue, // so that the queue maintains the increasing order of job\u0026#39;s id, // which can prevent the job from being skipped and also can avoid repeated patching. function findInsertionIndex(job: SchedulerJob) { // the start index should be `flushIndex + 1` let start = flushIndex + 1 let end = queue.length const jobId = getId(job) while (start \u0026lt; end) { const middle = (start + end) \u0026gt;\u0026gt;\u0026gt; 1 const middleJobId = getId(queue[middle]) middleJobId \u0026lt; jobId ? (start = middle + 1) : (end = middle) } return start }     在 update 进入任务队列的时候保证所有 jobs 是以升序排列\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17  export function queueJob(job: SchedulerJob) { // the dedupe search uses the startIndex argument of Array.includes() // by default the search index includes the current job that is being run @@ -72,7 +91,12 @@ export function queueJob(job: SchedulerJob) {  )) \u0026amp;\u0026amp; job !== currentPreFlushParentJob ) { - queue.push(job) + const pos = findInsertionIndex(job) + if (pos \u0026gt; -1) { + queue.splice(pos, 0, job) + } else { + queue.push(job) + }  queueFlush() } }      ✅ v-show: v-show takes higher priority than style attribute (#3230) (5ad4036), closes #2757 \nv-show 也是通过 el.style.display 来实现的，这里意思是如果 style 属性中也有 display 的话，在 runtime-dom/src/modules/style.ts 中 patch 的时候应该 v-show 的优先级更高。\n  ✅ init devtools after feature flag checks (d0ea745)\n    DONE Performance Improvements [1/1]  CLOSED: [2021-08-09 Mon 15:22]\n ✅ reactivity: only call Set.add if doesn\u0026#39;t already have value (#3307) (9cd9883)\n 对于 Set key-value 都是值，所以当有这个 value 的时候再添加就没有什么意义了， Set 又是不重复集合。\n1 2 3 4 5 6 7 8 9 10 11  packages/reactivity/src/collectionHandlers.ts @@ -76,8 +76,8 @@ function add(this: SetTypes, value: unknown) { const target = toRaw(this) const proto = getProto(target) const hadKey = proto.has.call(target, value) - target.add(value) if (!hadKey) { + target.add(value)  trigger(target, TriggerOpTypes.ADD, value, value) } return this           3.0.6 (2021-02-24)  Important   此次更新重点内容(值得关注的点)：\n  ADD: BigInt 类型和 SFC 支持 🔗\n  FIX: 修复 class: [\u0026#39;foo\u0026#39;, false, undefined, \u0026#39;bar\u0026#39;] 被解析成 \u0026lt;div class=\u0026#34;foo bar\u0026#34;/\u0026gt; 问题 🔗。\n  FIX: 修复 foo-bar 事件名无法触发问题 🔗 。\n  FIX: this.$watch(fn, callback) 的 fn 第一个参数是 instance.proxy 🔗\n    DONE Bug Fixes [25/25]  CLOSED: [2021-08-05 Thu 23:42]\n ✅ compiler-core: do not mark v-for as stable on const bindings (734c65b), closes vitejs/vite#1956\n ✅ compiler-dom: ensure global build filename matches the one defined in package.json (close #3181) (#3185) (96b6433)\n ✅ compiler-dom: fix cdn entries (fcb6c89), closes #3181 #3185\n ✅ compiler-sfc: compiler blank srcset (#3005) (9dc816d)\n 允许 \u0026lt;img src=\u0026#34;./logo.png\u0026#34; srcset=\u0026#34;\u0026#34;/\u0026gt; 的 srcset 是个空值，编译后：\n1 2 3 4  _createVNode(\\\\\u0026#34;img\\\\\u0026#34;, { src: \\\\\u0026#34;./logo.png\\\\\u0026#34;, srcset: \\\\\u0026#34;\\\\\u0026#34; }),     ✅ compiler-sfc: removeSpecifier issue when removing initial imports (script-setup) (#2729) (6d762a8)\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23  const url = process.env.VNEXT_PKG_RC + \u0026#34;/../compiler-sfc/dist/compiler-sfc.cjs.js\u0026#34;; const value = require(url.replace(\u0026#34;stb-\u0026#34;, \u0026#34;\u0026#34;)); const parser = \u0026#39;/usr/local/lib/node_modules/@babel/parser/lib\u0026#39; const { parse: babelParse } = require(parser) const { compileScript, parse } = value; const src = `\u0026lt;script setup\u0026gt; import { defineProps, defineEmits, ref } from \u0026#39;vue\u0026#39; defineProps([\u0026#39;foo\u0026#39;]) defineEmits([\u0026#39;bar\u0026#39;]) const r = ref(0) \u0026lt;/script\u0026gt;` const { descriptor } = parse(src) const code = compileScript(descriptor, { id: \u0026#39;xxxxx\u0026#39; }).content console.log(\u0026#39;before babel \u0026gt; \\n\u0026#39;, code); babelParse(code, { sourceType: \u0026#39;module\u0026#39;, plugins: [\u0026#39;bigInt\u0026#39;, \u0026#39;optionalChaining\u0026#39;, \u0026#39;nullishCoalescingOperator\u0026#39;, \u0026#39;typescript\u0026#39;] }) console.log(\u0026#39;after babel \u0026gt; \\n\u0026#39;, code); return 0;    before babel \u0026gt; import { ref } from \u0026#39;vue\u0026#39; export default { props: [\u0026#39;foo\u0026#39;], emits: [\u0026#39;bar\u0026#39;], setup(__props, { expose }) { expose() const r = ref(0) return { r, ref, __isScriptSetup: true } } } after babel \u0026gt; import { ref } from \u0026#39;vue\u0026#39; export default { props: [\u0026#39;foo\u0026#39;], emits: [\u0026#39;bar\u0026#39;], setup(__props, { expose }) { expose() const r = ref(0) return { r, ref, __isScriptSetup: true } } } 0   ✅ compiler-sfc: the empty lang attribute should be treated as no lang specified (#3051) (6d5b623)\n ✅ compiler-sfc: transformAssetUrls.base should not affect known module requests (2ea9867)\n ✅ compiler-sfc: treat const reactive() bindings as mutable (03360ce) const obj = reactive({}) 编译成 let 变量。\n ✅ compiler-ssr: avoid duplicated asset imports merged from component slot client branch (c69f4ea), closes vitejs/vite#2034\n root.imports Set 改成了 Array，允许重复了.\n ✅ devtools: init devtools in production (#2906) (4d9bcb7)\n ✅ devtools: send instance to devtools when it\u0026#39;s mounted instead of created (4fecb27)\n ✅ docs: change reference to passed deadline (#2930) (de7f9d1)\n ✅ hmr: deep clone reused hoisted trees during dev (5a7a1b8), closes vitejs/vite#2022\n 开发过程中，对静态提升的组件树进行深拷贝。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25  packages/runtime-core/src/vnode.ts @@ -459,7 +459,7 @@ export function cloneVNode\u0026lt;T, U\u0026gt;( ): VNode\u0026lt;T, U\u0026gt; { // This is intentionally NOT using spread or extend to avoid the runtime // key enumeration cost. - const { props, ref, patchFlag } = vnode + const { props, ref, patchFlag, children } = vnode const mergedProps = extraProps ? mergeProps(props || {}, extraProps) : props return { __v_isVNode: true, @@ -479,7 +479,10 @@ export function cloneVNode\u0026lt;T, U\u0026gt;(  : normalizeRef(extraProps) : ref, scopeId: vnode.scopeId, - children: vnode.children, + children: + __DEV__ \u0026amp;\u0026amp; patchFlag === PatchFlags.HOISTED \u0026amp;\u0026amp; isArray(children) + ? (children as VNode[]).map(deepCloneVNode) + : children,  target: vnode.target, targetAnchor: vnode.targetAnchor, staticCount: vnode.staticCount, @@ -513,6 +516,18 @@ export function cloneVNode\u0026lt;T, U\u0026gt;( } }      deep clone 函数：\n1 2 3 4 5 6 7 8 9 10 11  /** * Dev only, for HMR of hoisted vnodes reused in v-for * https://github.com/vitejs/vite/issues/2022 */ function deepCloneVNode(vnode: VNode): VNode { const cloned = cloneVNode(vnode) if (isArray(vnode.children)) { cloned.children = (vnode.children as VNode[]).map(deepCloneVNode) } return cloned }     ✅ runtime-core: align $parent/$root with the template ref when using expose (#3158) (f43a3b0)\n expose 特性详解：Vue3 功能拆解⑪ expose options\u0026amp;api\n ✅ runtime-core: allow overriding properties other than props (#3105) (73117f6)\n 允许重写非组件 props 的属性，比如：原生 API hasOwnProperty\n1 2 3 4 5 6 7 8 9 10  packages/runtime-core/src/componentPublicInstance.ts @@ -368,7 +368,7 @@ export const PublicInstanceProxyHandlers: ProxyHandler\u0026lt;any\u0026gt; = {  setupState[key] = value } else if (data !== EMPTY_OBJ \u0026amp;\u0026amp; hasOwn(data, key)) { data[key] = value - } else if (key in instance.props) { + } else if (hasOwn(instance.props, key)) {  __DEV__ \u0026amp;\u0026amp; warn( `Attempting to mutate prop \u0026#34;${key}\u0026#34;. Props are readonly.`,      测试：\n1 2 3 4 5 6 7 8 9 10  packages/runtime-core/__tests__/componentProps.spec.ts @@ -295,6 +295,10 @@ describe(\u0026#39;component props\u0026#39;, () =\u0026gt; {  ;(instance!.proxy as any).foo = 2 }).toThrow(TypeError) expect(`Attempting to mutate prop \u0026#34;foo\u0026#34;`).toHaveBeenWarned() // should not throw when overriding properties other than props + expect(() =\u0026gt; { + ;(instance!.proxy as any).hasOwnProperty = () =\u0026gt; {} + }).not.toThrow(TypeError) })      ✅ runtime-core: check the DEV_ROOT_FRAGMENT flag correctly in the dev environment (#2750) (347a879)\n1 2 3 4 5 6 7 8 9 10 11  // to have comments along side the root element which makes it a fragment let root = result let setRoot: ((root: VNode) =\u0026gt; void) | undefined = undefined - if (__DEV__ \u0026amp;\u0026amp; result.patchFlag \u0026amp; PatchFlags.DEV_ROOT_FRAGMENT) { + if ( + __DEV__ \u0026amp;\u0026amp; + result.patchFlag \u0026gt; 0 \u0026amp;\u0026amp; + result.patchFlag \u0026amp; PatchFlags.DEV_ROOT_FRAGMENT + ) {  ;[root, setRoot] = getChildRoot(result) }      ✅ runtime-core: component methods should override global properties in DEV (#3074) (2587f36)\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20  packages/runtime-core/src/componentOptions.ts @@ -604,7 +604,17 @@ export function applyOptions(  for (const key in methods) { const methodHandler = (methods as MethodOptions)[key] if (isFunction(methodHandler)) { - ctx[key] = methodHandler.bind(publicThis) + // In dev mode, we use the `createRenderContext` function to define methods to the proxy target, + // and those are read-only but reconfigurable, so it needs to be redefined here + if (__DEV__) { + Object.defineProperty(ctx, key, { + value: methodHandler.bind(publicThis), + configurable: true, + enumerable: false + }) + } else { + ctx[key] = methodHandler.bind(publicThis) + }  if (__DEV__) { checkDuplicateProperties!(OptionTypes.METHODS, key) }      测试：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23  const url = process.env.VNEXT_PKG_RC +\u0026#39;/../runtime-test/dist/runtime-test.cjs.js\u0026#39; const value = require(url.replace(\u0026#39;stb-\u0026#39;, \u0026#39;\u0026#39;)) const { nodeOps, render, h, serializeInner: s, createApp } = value const Comp = { methods: { foo() { return \u0026#39;foo\u0026#39; } }, render() { return this.foo() } } const app = createApp(Comp) app.config.globalProperties.foo = () =\u0026gt; \u0026#39;bar\u0026#39; const root = nodeOps.createElement(\u0026#39;div\u0026#39;) app.mount(root) console.log(s(root)) return 0    foo 0   ✅ runtime-core: ensure app instance can be garbage collected after unmount (close #2907) (#2909) (60e05ef)\n1 2 3 4 5 6 7 8 9  packages/runtime-core/src/apiCreateApp.ts @@ -272,6 +272,7 @@ export function createAppAPI\u0026lt;HostElement\u0026gt;(  if (__DEV__ || __FEATURE_PROD_DEVTOOLS__) { devtoolsUnmountApp(app) } + delete app._container.__vue_app__  } else if (__DEV__) { warn(`Cannot unmount an app that is not mounted.`) }      取消引用。\n1 2 3 4 5 6 7 8 9 10 11 12  function unmount() { if (isMounted) { render(null, app._container) if (__DEV__ || __FEATURE_PROD_DEVTOOLS__) { app._instance = null devtoolsUnmountApp(app) } delete app._container.__vue_app__ } else if (__DEV__) { warn(`Cannot unmount an app that is not mounted.`) } }     mount 里面保存的 __vue_ap__\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29  function mount( rootContainer: HostElement, isHydrate?: boolean, isSVG?: boolean ): any { if (!isMounted) { // ...  vnode.appContext = context // HMR root reload ...  if (isHydrate \u0026amp;\u0026amp; hydrate) { hydrate(vnode as VNode\u0026lt;Node, Element\u0026gt;, rootContainer as any) } else { render(vnode, rootContainer, isSVG) } isMounted = true app._container = rootContainer // for devtools and telemetry  ;(rootContainer as any).__vue_app__ = app if (__DEV__ || __FEATURE_PROD_DEVTOOLS__) { app._instance = vnode.component devtoolsInitApp(app, version) } return vnode.component!.proxy } // ... }     ✅ runtime-core: instanceWatch should pass this.proxy to source as the first argument (#2753) (ec8fd10) \n 当 watch 一个函数的时候，将 instance.proxy 做为第一个参数传给这个函数。\n 测试：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17  const url = process.env.VNEXT_PKG_RC +\u0026#39;/../runtime-test/dist/runtime-test.cjs.js\u0026#39; const value = require(url.replace(\u0026#39;stb-\u0026#39;, \u0026#39;\u0026#39;)) const { nodeOps, render, h, serializeInner: s, createApp } = value let instance = null const source = (proxy) =\u0026gt; console.log(instance \u0026amp;\u0026amp; ( proxy === instance.proxy )) const Comp = { created() { instance = this this.$watch(source, () =\u0026gt; {}) }, render() {} } const root = nodeOps.createElement(\u0026#39;div\u0026#39;) createApp(Comp).mount(root) return 0    false 0   修复：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23  packages/runtime-core/src/apiWatch.ts @@ -181,7 +181,9 @@ function doWatch(  } else if (isReactive(s)) { return traverse(s) } else if (isFunction(s)) { - return callWithErrorHandling(s, instance, ErrorCodes.WATCH_GETTER) + return callWithErrorHandling(s, instance, ErrorCodes.WATCH_GETTER, [ + instance \u0026amp;\u0026amp; (instance.proxy as any) + ])  } else { __DEV__ \u0026amp;\u0026amp; warnInvalidSource(s) } @@ -190,7 +192,9 @@ function doWatch(  if (cb) { // getter with cb getter = () =\u0026gt; - callWithErrorHandling(source, instance, ErrorCodes.WATCH_GETTER) + callWithErrorHandling(source, instance, ErrorCodes.WATCH_GETTER, [ + instance \u0026amp;\u0026amp; (instance.proxy as any) + ])  } else { // no cb -\u0026gt; simple effect getter = () =\u0026gt; {      ✅ types: extract the correct props type for the DateConstructor (#2676) (48f0d29)\n ✅ ensure all published packages contan a LICENCE file (close #2650) (#2857) (6a48d23)\n ✅ remove superfluous spaces when normalizing class (#3083) (4b55142) \n 问题如下代码，正常应该忽略 undefind, false ：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18  const url = process.env.VNEXT_PKG_RC +\u0026#39;/../runtime-test/dist/runtime-test.cjs.js\u0026#39; const value = require(url.replace(\u0026#39;stb-\u0026#39;, \u0026#39;\u0026#39;)) const { nodeOps, render, h, serializeInner: s } = value const Comp = { props: { foo: BigInt }, render() { return h(\u0026#39;div\u0026#39;, { class: [\u0026#39;foo\u0026#39;, undefined, false, \u0026#39;bar\u0026#39;] }, [this.foo]) } } const root = nodeOps.createElement(\u0026#39;div\u0026#39;) render(h(Comp, { foo: BigInt(BigInt(100000111)) + BigInt(2000000000) * BigInt(30000000) }), root) console.log(s(root)) return 0    \u0026lt;div class=\u0026#34;foo bar\u0026#34;\u0026gt;60000000100000111\u0026lt;/div\u0026gt; 0   修复：\n1 2 3 4 5 6 7 8 9 10 11 12 13  packages/shared/src/normalizeProp.ts @@ -62,7 +62,10 @@ export function normalizeClass(value: unknown): string {  res = value } else if (isArray(value)) { for (let i = 0; i \u0026lt; value.length; i++) { - res += normalizeClass(value[i]) + \u0026#39; \u0026#39; + const normalized = normalizeClass(value[i]) + if (normalized) { + res += normalized + \u0026#39; \u0026#39; + }  } } else if (isObject(value)) { for (const name in value) {      ✅ runtime-dom: enable set form attr to null on form-elements (#2840) (#2849) (f262438)\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24  packages/runtime-dom/src/patchProp.ts @@ -3,7 +3,13 @@ import { patchStyle } from \u0026#39;./modules/style\u0026#39; - // #1787 form as an attribute must be a string, while it accepts an Element as - // a prop - if (key === \u0026#39;form\u0026#39; \u0026amp;\u0026amp; typeof value === \u0026#39;string\u0026#39;) { + // #1787, #2840 the form property is readonly and can only be set as an + // attribute using a string value + if (key === \u0026#39;form\u0026#39; \u0026amp;\u0026amp; isFormTag(el.tagName)) {  return false } packages/shared/src/domTagConfig.ts @@ -30,6 +30,11 @@ const SVG_TAGS = const VOID_TAGS = \u0026#39;area,base,br,col,embed,hr,img,input,link,meta,param,source,track,wbr\u0026#39; + const FORM_TAGS = + \u0026#39;button,datalist,fieldset,input,keygen,label,legend,meter,optgroup,option,\u0026#39; + + \u0026#39;output,progress,select,textarea\u0026#39;  export const isHTMLTag = /*#__PURE__*/ makeMap(HTML_TAGS) export const isSVGTag = /*#__PURE__*/ makeMap(SVG_TAGS) export const isVoidTag = /*#__PURE__*/ makeMap(VOID_TAGS) export const isFormTag = /*#__PURE__*/ makeMap(FORM_TAGS, true)      ✅ toRef: ref created from union typed prop can\u0026#39;t be used in watch (#3048) (4ca4666)\n ✅ should prefix ShadowRoot with window. (#2943) (97d6f1a)\n 通过 window 去使用 ShadowRoot，因为它不是 window 上可枚举的属性。\n1 2 3 4 5 6 7 8 9  packages/runtime-dom/src/index.ts @@ -119,7 +119,7 @@ function normalizeContainer( } if ( __DEV__ \u0026amp;\u0026amp; - container instanceof ShadowRoot \u0026amp;\u0026amp; + container instanceof window.ShadowRoot \u0026amp;\u0026amp;  container.mode === \u0026#39;closed\u0026#39; ) {         DONE Features [5/5]  CLOSED: [2021-08-05 Thu 23:42]\n ✅ remove useless option in KeepAlive (#3170) (bd1240c)\n 删除了 KeepAlive 的 inheritRef: true 选项。\n ✅ compiler-core: support BigInt in template (#2900) (c9f94fa)\n 将 BigInt 标记为全局变量。\n1 2 3 4 5 6 7 8 9  packages/shared/src/globalsWhitelist.ts @@ -3,6 +3,6 @@ import { makeMap } from \u0026#39;./makeMap\u0026#39; const GLOBALS_WHITE_LISTED = \u0026#39;Infinity,undefined,NaN,isFinite,isNaN,parseFloat,parseInt,decodeURI,\u0026#39; + \u0026#39;decodeURIComponent,encodeURI,encodeURIComponent,Math,Number,Date,Array,\u0026#39; + - \u0026#39;Object,Boolean,String,RegExp,Map,Set,JSON,Intl\u0026#39; + \u0026#39;Object,Boolean,String,RegExp,Map,Set,JSON,Intl,BigInt\u0026#39;  export const isGloballyWhitelisted = /*#__PURE__*/ makeMap(GLOBALS_WHITE_LISTED)      测试结果：\n const app = Vue.createApp({ template: ` {{ BigInt(BigInt(100000111)) + BigInt(2000000000n) * 30000000n }} 查看测试源码 {{code}} `, setup() { const showCode = Vue.ref(false) return { showCode, code: Vue.computed(() = document.querySelector('script.ZA4bDx').textContent), click: () = ( showCode.value = !showCode.value ) } } }) const root = document.getElementById('ZA4bDx') app.use(ElementPlus).mount(root)   ✅ compiler-sfc: upgrade to postcss 8 (#2710) (49bc2e4)\n ✅ runtime-core: improve render context warning (#2496) (288ae0a)\n 问题： 组件渲染期间去访问一个不存在的属性时候，报错信息：\nProperty ${JSON.stringify(key)} was accessed during render but is not defined on instance.\n 1 2 3 4 5 6 7 8 9 10  packages/runtime-core/src/componentPublicInstance.ts @@ -349,7 +349,7 @@ export const PublicInstanceProxyHandlers: ProxyHandler\u0026lt;any\u0026gt; = {  )} must be accessed via $data because it starts with a reserved ` + `character (\u0026#34;$\u0026#34; or \u0026#34;_\u0026#34;) and is not proxied on the render context.` ) - } else { + } else if (instance === currentRenderingInstance) {  warn( `Property ${JSON.stringify(key)} was accessed during render ` + `but is not defined on instance.`      ✅ runtime-core: props type support BigInt (#2891) (ffd5288) \n 修改代码：\n1 2 3 4  const isSimpleType = /*#__PURE__*/ makeMap( - \u0026#39;String,Number,Boolean,Function,Symbol\u0026#39; + \u0026#39;String,Number,Boolean,Function,Symbol,BigInt\u0026#39; )      测试\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18  const url = process.env.VNEXT_PKG_RC +\u0026#39;/../runtime-test/dist/runtime-test.cjs.js\u0026#39; const value = require(url.replace(\u0026#39;stb-\u0026#39;, \u0026#39;\u0026#39;)) const { nodeOps, render, h, serializeInner: s } = value const Comp = { props: { foo: BigInt }, render() { return h(\u0026#39;div\u0026#39;, [this.foo]) } } const root = nodeOps.createElement(\u0026#39;div\u0026#39;) render(h(Comp, { foo: BigInt(BigInt(100000111)) + BigInt(2000000000) * BigInt(30000000) }), root) console.log(s(root)) return 0    \u0026lt;div\u0026gt;60000000100000111\u0026lt;/div\u0026gt; 0      DONE Performance Improvements [1/1]  CLOSED: [2021-08-05 Thu 23:42]\n ✅ reactivity: should not track __isVue (#2940) (dd02cf3)\n @@ -93,7 +96,7 @@ function createGetter(isReadonly = false, shallow = false) {\n1 2 3 4 5 6 7 8 9 10 11 12  + const isNonTrackableKeys = /*#__PURE__*/ makeMap(`__proto__,__v_isRef,__isVue`)  if ( isSymbol(key) ? builtInSymbols.has(key as symbol) - : key === `__proto__` || key === `__v_isRef` + : isNonTrackableKeys(key)  ) { return res } // 遇到 __isVue 也直接返回 Reflect.get 的结果，不往下 track 了。           3.0.5 (2020-12-30)   vue-next/CHANGELOG.md at master · vuejs/vue-next\nTIP\n Note: this release contains a type-only change that requires TypeScript 4.0+, which may cause build issues in projects still using TS 3.x.\n  只包含一些类型的变更。\nDONE Bug Fixes [9/9]  CLOSED: [2021-08-05 Thu 23:44]\n ✅ compiler-core: fix missing createVNode import on nested v-for (ad4d391), closes #2718\n ✅ compiler-sfc: should keep template nodes with no content (#2468) (5b9b37f), closes #2463\n1 2 3 4 5 6 7 8 9 10  -\u0026gt; packages/compiler-sfc/src/parse.ts if (node.type !== NodeTypes.ELEMENT) { return } - if (!node.children.length \u0026amp;\u0026amp; !hasSrc(node)) { + if (!node.children.length \u0026amp;\u0026amp; !hasSrc(node) \u0026amp;\u0026amp; node.tag !== \u0026#39;template\u0026#39;) {  return } switch (node.tag) {      ✅ compiler-sfc: support transforming asset urls with full base url. (#2477) (db786b1)\n 针对相对路径而言，当提供了 base 选项的时候，会使用这个值去拼接，如：\n { transformAssetUrls: { base: \u0026#39;https://www.cheng92.com\u0026#39; } }\n \u0026lt;img src=\u0026#34;./vue/img/test.png\u0026#34; /\u0026gt; 会被编译成：\n createVNode(\u0026#39;img\u0026#39;, { src: \u0026#39;https://www.cheng92.com/vue/img/test.png\u0026#39; })\n ✅ runtime-core: component mount anchor memory leak (#2459) (3867bb4), closes #2458\n  ✅ runtime-core: skip patchBlockChildren if n1.dynamicChildren is null (#2717) (c59897c), closes #2715 #2485\n    这个问题原因是，一开始 HelloWorld 的 dynamicChildren 是 null。\n 当点击 ADD 按钮的时候增加了一项数据，会进入 mountChildren -\u0026gt; patchBlockChildren\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  const patchBlockChildren: PatchBlockChildrenFn = ( oldChildren, newChildren, fallbackContainer, parentComponent, parentSuspense, isSVG, slotScopeIds ) =\u0026gt; { for (let i = 0; i \u0026lt; newChildren.length; i++) { const oldVNode = oldChildren[i] // dynamicChildren  const newVNode = newChildren[i] // ...  } }     而 dynamicChildren 在初始化的时候是个 null 值, 一开始就访问了 dynamicChildren[i] 所以导致报错。\n 修复代码(c59897c)，加个判断条件：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19  if ( patchFlag \u0026gt; 0 \u0026amp;\u0026amp; patchFlag \u0026amp; PatchFlags.STABLE_FRAGMENT \u0026amp;\u0026amp; - dynamicChildren \u0026amp;\u0026amp; + dynamicChildren \u0026amp;\u0026amp; + n1.dynamicChildren  ) { // a stable fragment (template root or \u0026lt;template v-for\u0026gt;) doesn\u0026#39;t need to // patch children order, but it may contain dynamicChildren. patchBlockChildren( - n1.dynamicChildren!, + n1.dynamicChildren,  dynamicChildren, container, parentComponent, parentSuspense, isSVG, slotScopeIds )      ❌ runtime-dom: support mounting app on ShadowRoot (#2447) (b2189ba), closes #2399\n \u0026gt;3.2 中已经没有 __isShadowRoot 相关的代码了。\n ✅ ssr: properly handle ssr empty slot and fallback (88f6b33)\n ✅ transition: ensure manual style manipulation in transition leave hooks work (cbaa380), closes #2720\n 在 onLeave hook 中增加\n1 2  forceReflow() addTransitionClass(el, leaveActiveClass)     去强制渲染，触发 leaveActiveClass 。\n ✅ transition: ensure styles from *-leave-active trigger transition (#2716) (3f8f9b6), closes #2712\n    DONE Features [1/1]  CLOSED: [2021-08-05 Thu 23:44]\n ✅ devtools: send instance (3626ff0)\n 将组件实例给开发工具。\n1 2 3 4 5 6 7 8 9 10 11 12 13  function createDevtoolsComponentHook(hook: DevtoolsHooks) { return (component: ComponentInternalInstance) =\u0026gt; { if (!devtools) return devtools.emit( hook, component.appContext.app, component.uid, - component.parent ? component.parent.uid : undefined + component.parent ? component.parent.uid : undefined, + component  ) } }           tests  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20  const url = process.env.VNEXT_PKG_RC + \u0026#34;/../compiler-sfc/dist/compiler-sfc.cjs.js\u0026#34;; const value = require(url.replace(\u0026#34;stb-\u0026#34;, \u0026#34;\u0026#34;)); const { compileScript, parse, compileStyle } = value; function compileScoped(source, options) { const res = compileStyle({ source, filename: \u0026#39;test.css\u0026#39;, id: \u0026#39;data-v-test\u0026#39;, scoped: true, ...options }) return res.code } const src = `::v-slotted(h1) { color: red; }` const code = compileScoped(src) console.log(code) return 0;    h1[data-v-test-s] { color: red; } 0    ","permalink":"https://www.cheng92.com/vue/vue-update-log-01/","tags":["vue,","vue3"],"title":"Vue3 更新日志 01(3.0.5 ~ 3.2.0-beta.1)"},{"categories":["react,","preact"],"contents":"  建议学习 preact 之前，先看 Build Your Own React - 若叶知秋 或 Build your own React\n 项目初始化   preact src 下最基础的目录结构\n/Users/simon/github/react/stb-preact/src: total used in directory 80K available 4.3 GiB drwxr-xr-x 4 simon staff 128 Jun 20 17:32 diff -rw-r--r-- 1 simon staff 56 Jun 20 17:29 clone-element.js -rw-r--r-- 1 simon staff 45 Jun 20 17:29 component.js -rw-r--r-- 1 simon staff 58 Jun 20 17:30 create-context.js -rw-r--r-- 1 simon staff 373 Jun 20 17:28 create-element.js -rw-r--r-- 1 simon staff 8.2K Jun 20 17:21 index.d.ts -rw-r--r-- 1 simon staff 391 Jun 20 17:28 index.js -rw-r--r-- 1 simon staff 4.9K Jun 20 17:32 internal.d.ts -rw-r--r-- 1 simon staff 31K Jun 20 17:21 jsx.d.ts -rw-r--r-- 1 simon staff 587 Jun 20 17:32 options.js -rw-r--r-- 1 simon staff 103 Jun 20 17:27 render.js   重点代码：\n  diff 节点比较算法核心代码\n  component.js Component 组件类\n  render.js render 函数\n    基本使用   官方的栗子：\n1 2 3 4 5 6 7 8 9 10 11 12  import { h, render } from \u0026#39;preact\u0026#39;; // Tells babel to use h for JSX. It\u0026#39;s better to configure this globally. // See https://babeljs.io/docs/en/babel-plugin-transform-react-jsx#usage // In tsconfig you can specify this with the jsxFactory /** @jsx h */ // create our tree and append it to document.body: render(\u0026lt;main\u0026gt;\u0026lt;h1\u0026gt;Hello\u0026lt;/h1\u0026gt;\u0026lt;/main\u0026gt;, document.body); // update the tree in-place: render(\u0026lt;main\u0026gt;\u0026lt;h1\u0026gt;Hello World!\u0026lt;/h1\u0026gt;\u0026lt;/main\u0026gt;, document.body); // ^ this second invocation of render(...) will use a single DOM call to update the text of the \u0026lt;h1\u0026gt;      函数组件：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  import { render, h } from \u0026#39;preact\u0026#39; import { useState } from \u0026#39;preact/hooks\u0026#39; /** @jsx h*/ const App = () =\u0026gt; { const [input, setInput] = useState(\u0026#39;\u0026#39;) return ( \u0026lt;div\u0026gt; \u0026lt;p\u0026gt;some thing....\u0026lt;/p\u0026gt; \u0026lt;input value={input} onChange={e =\u0026gt; setInput(e.target.value)}/\u0026gt; \u0026lt;/div\u0026gt; ) } render(\u0026lt;App/\u0026gt;, document.body)     所以，首先需要实现的是 h/createElement 和 render, 前者构造 VNode 树，后者利 用 VNode tree 实施渲染，加入 DOM 。\n  h/createElement 函数   feat: h -\u0026gt; createElement · gcclll/stb-preact@efb88ce\n src/create-element.js 内容：\n   name 参数 brief     createElement type, props, children h 函数，构造 VNode   createVNode type,props,key,ref,original createElement调用   createRef - {current: null}   Fragment props -   isValidElement vnode -     createElement(type, props, children):\n  props 处理，过滤出 key,ref 属性，这两个非元素原生属性\n  检测 children 合并成数组，当作改节点的子节点\n  如果 type 是个函数，考虑是否有初始化默认的 props\n  最后调用 createVNode 构造虚拟节点\n  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33  export function createElement(type, props, children) { let normalizedProps = {}, key, ref, i; for (i in props) { if (i == \u0026#39;key\u0026#39;) key = props[i]; else if (i == \u0026#39;ref\u0026#39;) ref = props[i]; else normalizedProps[i] = props[i]; } // 有 children 事的处理, \t// h(\u0026#39;div\u0026#39;, { ref: \u0026#39;xxx\u0026#39; }, children[]) \t// h(\u0026#39;div\u0026#39;, { ref: \u0026#39;xxx\u0026#39; }, child1, child2, child3, ...) \tif (arguments.length \u0026gt; 2) { normalizedProps.children = arguments.length \u0026gt; 3 ? slice.call(arguments, 2) : children; } // 函数组件？ \t// If a Component VNode, check for and apply defaultProps \t// Note: type may be undefined in development, must never error here. \tif (typeof type === \u0026#39;function\u0026#39; \u0026amp;\u0026amp; type.defaultProps != null) { for (i in type.defaultProps) { if (normalizedProps[i] === undefined) { normalizedProps[i] = type.defaultProps[i]; } } } return createVNode(type, normalizedProps, key, ref, null); }     createVNode(type, props, key, ref, original):\n 单纯初始化虚拟节点的结构。\n  _nextDom 用来链接下一个被渲染的节点\n 这跟 react 的 fiber 貌似有点关联，不知道这里有没用到 fiber. 根据 fiber 结构原 理，查找下一个执行单元的优先级是： first child -\u0026gt; sibling -\u0026gt; parent sibling\n  constructor 这里赋值为 undefined 目的是为了识别 VNode(vue 的 __v_isVNode ???) ?\n  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25  // 构造虚拟节点 export function createVNode(type, props, key, ref, original) { const vnode = { type, props, key, ref, _children: null, _parent: null, _depth: 0, _dom: null, // 必须初始化成 `undefined`, 最终回被设置成 dom.nextSibling 的值 \t// react fiber 结构查找优先级： first child -\u0026gt; sibling -\u0026gt; parent sibling \t_nextDom: undefined, _component: null, _hydrating: null, constructor: undefined, // 用来检测是不是有效的元素？ \t_original: original == null ? ++vnodeId : original }; // ？？？ 可以加工处理？？？ \tif (options.vnode != null) options.vnode(vnode); return vnode; }     最后有个 if (options.vnode != null) options.vnode(vnode); 判断，这个不知道是不 是提供给开发者对 vnode 进行加工处理的能力？\n1 2  const react = require(process.env.HOME + \u0026#39;/github/react/stb-preact/dist/preact.js\u0026#39;); console.log(react);    { render: [Function (anonymous)], hydrate: [Function (anonymous)], createElement: [Function: u], h: [Function: u], Fragment: [Function (anonymous)], createRef: [Function (anonymous)], isValidElement: [Function: o], Component: [Function (anonymous)], cloneElement: [Function (anonymous)], createContext: [Function (anonymous)], toChildArray: [Function (anonymous)], options: { __e: [Function: __e] } } undefined   虚拟节点：\n1 2 3  const { h } = require(process.env.HOME + \u0026#39;/github/react/stb-preact/dist/preact.js\u0026#39;); console.log(\u0026#34;\u0026gt;\u0026gt;\u0026gt; h(\u0026#39;div\u0026#39;, { key: 1 })\u0026#34;); console.log(h(\u0026#39;div\u0026#39;, { key: 1 }));    \u0026gt;\u0026gt;\u0026gt; h(\u0026#39;div\u0026#39;, { key: 1 }) { type: \u0026#39;div\u0026#39;, props: {}, key: 1, ref: undefined, __k: null, __: null, __b: 0, __e: null, __d: undefined, __c: null, __h: null, constructor: undefined, __v: 1 } undefined   上面输出结果，被别名化了，这跟 preact 用的打包方式有关系，对应关系在 mangle.json 中。\n   key value     __k _children   __ _list   __b _depth   __e _force   __d _nextDom   __c _cleanup   __h _pendingEffects   __v _original      render()   render(vnode, parentDom, replaceNode)\n feat: render · gcclll/stb-preact@dcd5b41\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22  export function render(vnode, parentDom, replaceNode) { if (options._root) options._root(vnode, parentDom); let isHydrating = typeof replaceNode === \u0026#39;function\u0026#39;; // 为了支持在同一个 DOM node 上多次调用 `render()`, 那么就需要有个 \t// 引用能之前上一次渲染的树结构。默认没有该属性，同时也代表是该树第一次 \t// 加载 \tlet oldVNode = isHydrating ? null : (replaceNode \u0026amp;\u0026amp; replaceNode._children) || parentDom._children; // 让父节点持有子节点引用 \tvnode = ( (!isHydrating \u0026amp;\u0026amp; replaceNode) || parentDom )._children = createElement(Fragment, null, [vnode]); // 1. diff()  // 2. commitRoot(commitQueue, vnode) }     Fragment 实现：\n1 2 3  export function Fragment(props) { return props.children; }     很奇怪吗？\n createElement(Fragment, null, [vnode]) 等价于\n createElement(props.children, null, [vnode])\n Fragment 是个函数，而 createElement 对 type 的判断为函数时的处理是对 default props 的检测和合并操作。\n 根据 函数组件处理 可知这个处理会在 commit 阶段完成，先不管这个。\n 继续往下，将涉及到两个核心内容：\n  diff, 进行对比更新 VNode\n  work unit commit, 提交渲染任务\n  两个都是重点且核心的内容。\n  Component   在阅读 diff 源码之前，先看下 Component 是如何实现的，里面又包含哪些内容？\n  diff()   feat: diff init · gcclll/stb-preact@0ec1eaa\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32  function render() { // 1. create element -\u0026gt; vnode  // 2. diff  // List of effects that need to be called after diffing. \tlet commitQueue = []; diff( parentDom, // Determine the new vnode tree and store it on the DOM element on \t// our custom `_children` property. \tvnode, // new vnode \toldVNode || EMPTY_OBJ, // old vnode \tEMPTY_OBJ, parentDom.ownerSVGElement !== undefined, !isHydrating \u0026amp;\u0026amp; replaceNode ? [replaceNode] : oldVNode ? null : parentDom.firstChild ? slice.call(parentDom.childNodes) : null, commitQueue, !isHydrating \u0026amp;\u0026amp; replaceNode ? replaceNode : oldVNode ? oldVNode._dom : parentDom.firstChild, isHydrating ); // 3. commit }     diff 函数目的：比较 vnode 更新，渲染更新后的节点。\n1 2 3 4 5 6 7 8 9 10 11  export function diff( parentDom, newVNode, oldVNode, globalContext, isSvg, excessDomChildren, commitQueue, oldDom, isHydrating ) { /*...*/ }      疑难点  TODO 为何用 Fragment 将 vnode 包一层？     ","permalink":"https://www.cheng92.com/react/preact-zero/","tags":["preact,","react"],"title":"Preact 源码学习（一）"},{"categories":["javascript,","web"],"contents":" TODO\n Array.prototype.reduce()\n 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36  function deepFindFirstChild( parent, path, ) { if (path \u0026amp;\u0026amp; Array.isArray(path)) { path.push(parent.id) } if (!parent?.children?.length) { return path ? [parent, path] : parent } return deepFindFirstChild(parent.children[0], path) } var obj = { id: 0, children: [{ id: 1, children: [{ id: 2, children: [{ id: 3, children: [{ id: 4 }] }] }] }] } try { const res = deepFindFirstChild(obj, []) console.log(res); } catch(e) { console.log(e.message); }    [{ id: 4 } (\\, [0 (\\, 1) (\\, 2) (\\, 3) (\\, 4)])]  ","permalink":"https://www.cheng92.com/web/apis/js-api-array-reduce/","tags":["javascript,","api,","reduce"],"title":"JavaScript Api - Array.prototype.reduce"},{"categories":["vue"],"contents":"  诗号：六道同坠，魔劫万千，引渡如来。  \n   insertCssLink(\"https://unpkg.com/element-plus/lib/theme-chalk/index.css\");    vue-i18n-next  1 2 3 4  alias: { \u0026#39;/@\u0026#39;: pathResolve(\u0026#39;src\u0026#39;), + \u0026#39;vue-i18n\u0026#39;: \u0026#39;vue-i18n/dist/vue-i18n.cjs.js\u0026#39; },       ","permalink":"https://www.cheng92.com/vue/how-to-build-a-vite-vue3-project/","tags":["vue3,","vite"],"title":"如何开始一个 vite + vue3 + ... 项目"},{"categories":["huawei"],"contents":" Harmony   Huawei Developers - Building a Better Connected World with Developers\n OpenHarmony: OpenHarmony是开放原子开源基金会（OpenAtom Foundation）旗下开源项目，定位是一款面向全场景的开源分布式操作系统，第一个版本支持128K-128M设备上运行。\n docs: OpenHarmony documentation | OpenHarmony开发者文档\n  前端相关   ace_engine_lite: ACE JS lite framework | 轻量级JS核心开发框架\n JS API参考-文件组织\n JS API参考-概述\n  问题    HarmonyOS Launch: The Huawei Lite Wearable Simulator supports only ?\n Tools -\u0026gt; HVD Manager  下面按照需要选一个模拟器：     ","permalink":"https://www.cheng92.com/post/huawei-harmony/","tags":["huawei,","harmony"],"title":"华为鸿蒙(Huawei Harmony) - 资源收集"},{"categories":["javascript,","web"],"contents":"  诗号：六道同坠，魔劫万千，引渡如来。  \n  --  insertCssLink(\"https://unpkg.com/element-plus/lib/theme-chalk/index.css\");      ==, === 运算符详解。\n ECMAScript® 2022 Language Specification - Equality Comparison\n  一般推荐使用相等比较的时候使用 === 是为了避免类型强转带来未知问题，但有时候后 端返回的数据结构如果不规范就经常会出现恒等不合理情况，这篇文章会从 ECMA 标准的实 现步骤，通过伪码形式来实现和展示相等和恒等的原理。\n 在开始之前，要做一些准备工作。。。\n  严格相等 === ：\n1 2 3 4  function strictEqual(x, y) { // TODO  return x === y; }     将字符串转成 BigInt 类型:\n 标准里的描述： 7.1.14 StringToBigInt ( argument ) Apply the algorithm in 7.1.4.1 with the following changes:\n Replace the StrUnsignedDecimalLiteral production with DecimalDigits to not allow Infinity, decimal points, or exponents. If the MV is NaN, return NaN, otherwise return the BigInt which exactly corresponds to the MV, rather than rounding to a Number.\n 实现： 通过测试，只要字符串里包含非数字的符号就会报错，这里提前拦截模拟报错，实 际最后还是通过 BigInt() 来进行转换，而对于非字符串类型最终会转成字符串之后再 处理。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35  function StringToBigInt(v) { if (typeof v !== \u0026#34;string\u0026#34;) v = \u0026#34;\u0026#34; + v; if (isNaN(v)) return NaN; if (/[^\\d]/g.test(v)) { // 包含非数字的都不合法报错  throw new SyntaxError(`不能将 ${v}转成 BigInt。`); } return MyBigInt(v); // 这里直接使用 BigInt } function MyBigInt(v) { if (this instanceof MyBigInt) { throw new TypeError(\u0026#34; 不支持 new 操作。\u0026#34;); } let prim = toPrimitive(v, \u0026#34;number\u0026#34;); if (typeof prim === \u0026#39;number\u0026#39;) { return NumberToBigInt(prim); } return BigInt(v); } function NumberToBigInt(v) { return BigInt(v); } function toPrimitive(v) { return +v } // 测试： let val = StringToBigInt(\u0026#34;100\u0026#34;) console.log(val); try { val = StringToBigInt(\u0026#39;100.00\u0026#39;) } catch(e) { console.log(e.message) }    100n 不能将 100.00 转成 BigInt。 undefined   toPrimitive 将对象转成原始类型，标准的实现有点复杂，主要原理还是实现类型的 Symbol.toPrimitive\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48  // 简化版：将 x 转成原始类型 function toPrimitive(x, ref) { if (!isRef(x)) return x; if (isString(ref)) { return \u0026#34;\u0026#34; + x; } else if (isNum(ref)) { return +x; } else if (isBigInt(ref)) { if (isNum(x)) { throw new TypeError(\u0026#34;BigInt 不能转成 number\u0026#34;); } else if (isString(x)) { return \u0026#34;\u0026#34; + x; } } else if (isSymbol(ref)) { return Symbol(x); } } // Symbol.toPrimitive // 实现如： obj = { [Symbol.toPrimitive](hint) { ... } } // 这里涉及到各种对象类型转成原始类型的，涉及内容太多这里就不展开去实现了 function _ToPrimitive(input, preferredType) { let hint; if (isRef(input)) { let exoticToPrim = GetMethod(input, \u0026#34;@@toPrimitive\u0026#34;); if (exoticToPrim !== undefined) { if (!preferredType) { hint = \u0026#34;default\u0026#34;; } else if (preferredType === \u0026#34;string\u0026#34;) { hint = \u0026#34;string\u0026#34;; } else { hint = \u0026#34;number\u0026#34;; } let result = exoticToPrim(input, hint); if (typeof result !== \u0026#34;object\u0026#34;) { return result; } else { throw TypeError(\u0026#34;类型不能转成原始类型\u0026#34;); } } else { if (!preferredType) { preferredType = \u0026#34;number\u0026#34;; } } return OrdinaryToPrimitive(input, preferredType); } return input; }     比如：\n1 2 3 4 5 6 7 8 9 10 11 12 13  const obj = { [Symbol.toPrimitive](hint) { if (hint === \u0026#34;number\u0026#34;) { return 100; } else if (hint === \u0026#34;string\u0026#34;) { return \u0026#34;foo\u0026#34;; } return null; }, }; console.log(Number(obj)); console.log(+obj); console.log(String(obj));    100 100 foo undefined   转成数字：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43  // 转成数字 function ToNumber(v) { if (v === undefined) { return NaN; } else if (v === null) { return +0; } else if (v === true) { return 1; } else if (v === false) { return +0; } else if (typeof v === \u0026#34;number\u0026#34;) { return v; } else if (typeof v === \u0026#34;string\u0026#34;) { return v; // TODO  } else if (Array.isArray(v)) { return Number(v.toString()); } else if (typeof v === \u0026#34;symbol\u0026#34;) { throw new TypeError(\u0026#34;Symbol 不能转成 number.\u0026#34;); } else if (typeof v === \u0026#34;bigint\u0026#34;) { throw Number(v); } else if (typeof v === \u0026#34;object\u0026#34;) { return Number(v); } return v; } function tryCatch(fn) { let val; try { val = fn(); } catch (e) { console.log(e.message); } return val; } // 测试 console.log(\u0026#34;null: \u0026#34; + ToNumber(null)); console.log(\u0026#34;unefined: \u0026#34; + ToNumber(undefined)); console.log(\u0026#34;{}: \u0026#34; + ToNumber({})); console.log(\u0026#34;[]: \u0026#34; + ToNumber([])); console.log(\u0026#34;Symbol(\u0026#39;xx\u0026#39;): \u0026#34; + tryCatch(() =\u0026gt; ToNumber(Symbol(\u0026#34;xx\u0026#34;)))); console.log(\u0026#34;BigInt(100): \u0026#34; + tryCatch(() =\u0026gt; ToNumber(BigInt(100))));     转换规则：\n   类型 结果 -     null 0    undefined NaN 先转成 \u0026#34;undefined\u0026#34;   [] 0 先 String([]) -\u0026gt; \u0026#39;\u0026#39;   {} NaN 先 String({}) -\u0026gt; [object Object]   \u0026#34;xx\u0026#34; NaN -   100n 100 BigInt 可以转成 Number   Symbol TypeError 不能转    1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78  // 非严格相等， == 的实现 function equal(x, y) { // 类型一样就直接返回 x === y 的结果  if (Type(x) === Type(y)) { return strictEqual(x, y); } // 1. 即 null == undefined =\u0026gt; true  if ((x === null \u0026amp;\u0026amp; y === undefined) || (x === undefined \u0026amp;\u0026amp; y === null)) { return true; } // 2. 内部属性无法直接获取，这里到时候使用对象普通属性模拟  if (isObject(x) \u0026amp;\u0026amp; hasOwn(x, \u0026#34;[[IsHTMLDDA]]\u0026#34;)) { if (y === null || y === undefined) { return true; } } if (isObject(y) \u0026amp;\u0026amp; hasOwn(y, \u0026#34;[[IsHTMLDDA]]\u0026#34;)) { if (x === null || x === undefined) { return true; } } // 3. 如果其中有一个是字符串，将字符串转成数字之后进行比较  if (isNum(x) \u0026amp;\u0026amp; isString(y)) { return strictEqual(x, ToNumber(y)); } if (isString(x) \u0026amp;\u0026amp; isNum(y)) { return strictEqual(ToNumber(x), y); } // 4. BigInt 类型和字符串比较，将字符串转成 BigInt 类型  if (isBigInt(x) \u0026amp;\u0026amp; isString(y)) { let n = StringToBigInt(y); if (isNaN(n)) { return false; } return equal(x, n); } if (isString(x) \u0026amp;\u0026amp; isBigInt(y)) { return equal(y, x); } // 5. 如果是布尔类型转成数字再进行比较  if (isBool(x)) { return equal(ToNumber(x), y); } if (isBool(y)) { return equal(x, ToNumber(y)); } // 6. 如果其中有一个是引用类型，将其转成原始类型再比较  if (isRef(y) \u0026amp;\u0026amp; (isString(x) || isNum(x) || isBigInt(x) || isSymbol(x))) { return equal(x, ToPrimitive(y)); } if (isRef(x) \u0026amp;\u0026amp; (isString(y) || isNum(y) || isBigInt(y) || isSymbol(y))) { return equal(ToPrimitive(x), y); } // 7. BigInt 和 Number 类型  if (isBigInt(x) \u0026amp;\u0026amp; isNum(y)) { if (isNaN(x) || strictEqual(x, +Infinity) || strictEqual(x === -Infinity)) { return false; } if (isNaN(y) || strictEqual(y, +Infinity) || strictEqual(y === -Infinity)) { return false; } return equal(R(x), R(y)); } return false; }     这里主要有 8 种情况(equal(x, y)):\n  如果 x, y 类型一样，直接返回 x === y 结果，不需要进行类型转换\n  如果 null == undefined 或 undefined == null 进行比较，直接返回 true\n  如果 x 是对象且有 [[IsHTMLDDA]] 内部属性，且 y 是 null 或 undefined 直接返 回 true, 反之亦然。\n  如果 x number, y string 则将其中字符串转成 number 再进行 x === y 比较，反之 亦然。\n  如果 x BigInt, y string 则将其中字符串转成 BigInt 再进行 x === y 比较，反之 亦然。\n  如果 x boolean 将 x 转成 number 再 equal(number(x), y) 重新比较，反之亦然。\n  如果 x 是引用类型(即 typeof x === \u0026#39;object\u0026#39;)，而 y 是普通类型(String, Number, BigInt, Symbol)，那么将 x 转成原始类型再比较，即 equal(toPrimitive(x), y), 反之亦然\n  如果 x BigInt, y number 又区分几种情况\n  如果 x: NaN 返回 NaN\n  如果 x: +Infinity 返回 false\n  如果 x: -Infinity 返回 false\n  否则返回 equal(R(x), R(y)) R 不太清楚啥意思？\n     测试：可以通过表格下面的输入框输入左右值点击提交会更新表格，有两个结果，一个是 equal(x,y) 是该文根据 ECMA 标准实现的相等比较， x==y 是直接使用 == 符号得 到的结果为了形成对比，最后一列信息是每一行的数据在执行 equal(x,y) 过程中标识了 哪个值进行了类型转换(/js/tests/web/equal.js), 表格采用 Vue + ElementPlus 生成， 源码文件： /js/tests/X6j10iPkmj.js。\n     最终总结(类型比较)：\n   类型1 类型2 需要强转类型     number string string -\u0026gt; number   null undefined 直接返回 true   bigint string string -\u0026gt; bigint   boolean number boolean -\u0026gt; number, false-0, true-1   object 普通类型 object -\u0026gt; 普通类型     根据上表的类型转换，可以轻松判断出一些诡异的现象，比如：\n 0 == [0] : [0] 先转字符串即 \u0026#34;0\u0026#34; 然后再转成数字 0 结果: true\n 10 == [\u0026#34;10\u0026#34;] =\u0026gt; [\u0026#34;10\u0026#34;] =\u0026gt; \u0026#34;10\u0026#34; =\u0026gt; 10\n false == 0, true == 1 结果都是 true 都是因为 boolean 转成了 0 或 1\nTODO IsHTMLDDA 问题   How does this interact with [[IsHTMLDDA]​] · Issue #108 · tc39/proposal-optional-chaining\n  ","permalink":"https://www.cheng92.com/web/apis/js-api-equality-comparison/","tags":["javascript"],"title":"JavaScript Equality Comparison, 等号运算符"},{"categories":["vue"],"contents":"  诗号：六道同坠，魔劫万千，引渡如来。  \n  --  insertCssLink(\"https://unpkg.com/element-plus/lib/theme-chalk/index.css\");       本文从源码角度讲解了组件的指令系统，包含各种内置指令以及自定义指令原理。\n  指令列表\n   指令名称 用途     v-text 替换元素 textContext   v-html 替换元素 innerHTML   v-show 显示隐藏元素 display 属性   v-if[else/else-if]​ 条件渲染，off-dom 操作   v-for 列表渲染，循环操作   v-on 事件绑定   v-bind 状态绑定   v-model 双向绑定   v-slot 插槽指令, v-slot:name=\u0026#34;scope\u0026#34;   v-pre 代码指令   v-cloak 组件渲染完成之前元素一直是 display:none   v-once 只渲染一次，缓存机制实现   v-is ?    TODO v-text   TODO v-html   TODO v-show   TODO v-if   TODO v-for   TODO v-on   TODO v-bind   TODO v-model   TODO v-slot   TODO v-pre   TODO v-cloak   TODO v-once   TODO v-is   ","permalink":"https://www.cheng92.com/vue/vue-teardown-5-directives/","tags":["vue3,","vue-next,","component,","directives"],"title":"Vue3 功能拆解⑤ directives 指令系统"},{"categories":["vue"],"contents":" 诗号：六道同坠，魔劫万千，引渡如来。  \n  --  insertCssLink(\"https://unpkg.com/element-plus/lib/theme-chalk/index.css\");       本文从源码角度讲解了，组件的属性归类问题，当给一个组件传递个属性时，在该组件内部 它属于props 还是 attrs 。\n  这两个属性在组件上是如何区分的？\n 当父组件给子组件传递属性的时候，最终都划分到那个对象上了？\n 先上实例，点击按钮可查看对应结果分析(/js/vue/tests/7jAWzTeF1O.js):\n    首先，在 compiler 阶段所有属性都会被编译到 vnode.props 上，在 runtime-core patch 阶段才会区分 props 和 attrs，那这些属性又是如何做的区分，当开发的时候给子组件传 递的属性最终都放到哪个里面了？\n 这里面就得好好掰扯掰扯了！！！\n 根据之前的源码分析，组件 patch 流程: processComponent -\u0026gt; mountComponent 或 updateComponent 这里我们以组件首次渲染进入 mountComponent 为例。\n mountComopnent 简化之后其实就两个部分：\n  setupComponent() 初始化 props, slots 执行 setup 等待\n  setupRenderEffect() 给当前组件实例注册 instance.update 组件更新时调用的 effect 函数。\n   所以这里先忽略第 2 点，只讲讲 mount 阶段 setupComopnent() 中属性初始化处理 (setupComponent: initProps())。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19  export function setupComponent( instance: ComponentInternalInstance, isSSR = false ) { isInSSRComponentSetup = isSSR const { props, children, shapeFlag } = instance.vnode // 这里区分有无状态组件，无状态组件就是函数组件，对象组件是有状态组件  const isStateful = shapeFlag \u0026amp; ShapeFlags.STATEFUL_COMPONENT // 这里是重点， isSSR 是服务端渲染的问题这里暂不讨论  initProps(instance, props, isStateful, isSSR) initSlots(instance, children) const setupResult = isStateful ? setupStatefulComponent(instance, isSSR) : undefined isInSSRComponentSetup = false return setupResult }     props 初始化操作：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30  export function initProps( instance: ComponentInternalInstance, rawProps: Data | null, isStateful: number, // result of bitwise flag comparison  isSSR = false ) { const props: Data = {} const attrs: Data = {} def(attrs, InternalObjectKey, 1) setFullProps(instance, rawProps, props, attrs) // validation  if (__DEV__) { validateProps(props, instance) } if (isStateful) { // stateful  instance.props = isSSR ? props : shallowReactive(props) } else { if (!instance.type.props) { // functional w/ optional props, props === attrs  instance.props = attrs } else { // functional w/ declared props  instance.props = props } } instance.attrs = attrs }     def(attrs, InternalObjectKey, 1)\n 增加: attrs.__vInterval = true 属性\n 函数最后的 isStateful 判断是检测函数组件或对象组件的，如果是函数组件，一般没有 props 属性，除非手动给函数增加一个 props ，不过一般不这么用，如果有 props 建议还 是用对象组件，所以这里等于说函数的 props 即 attrs， attrs 即 props。\n setFullProps(instance, rawProps, props, attrs) 这个是重点部分，因为在这里开始 区分 props 和 attrs。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42  function setFullProps( instance: ComponentInternalInstance, rawProps: Data | null, props: Data, attrs: Data ) { const [options, needCastKeys] = instance.propsOptions; if (rawProps) { for (const key in rawProps) { const value = rawProps[key]; // key, ref are reserved and never passed down  if (isReservedProp(key)) { continue; } // prop option names are camelized during normalization, so to support  // kebab -\u0026gt; camel conversion here we need to camelize the key.  let camelKey; if (options \u0026amp;\u0026amp; hasOwn(options, (camelKey = camelize(key)))) { props[camelKey] = value; } else if (!isEmitListener(instance.emitsOptions, key)) { // Any non-declared (either as a prop or an emitted event) props are put  // into a separate `attrs` object for spreading. Make sure to preserve  // original key casing  attrs[key] = value; } } } if (needCastKeys) { const rawCurrentProps = toRaw(props); for (let i = 0; i \u0026lt; needCastKeys.length; i++) { const key = needCastKeys[i]; props[key] = resolvePropValue( options!, rawCurrentProps, key, rawCurrentProps[key], instance ); } } }     两段处理代码\n  rawProps 处理，来自 compiler 阶段编译后的 vnode.props\n  key, ref 保留属性，即不会往下传递的属性，等于是作用于该元素自身的\n  其次，options -\u0026gt; instanceOptions 中存在的 key 的属性属于 props\n  最后，非 emits 选项中的属性属于 attrs\n    needCastKeys 一些需要初始化值的属性的 key，比如： Boolean 类型值需要初始化成 false 。\n   这里涉及 options 里的属性 instance.propsOptions 这个在初始化组件实例的时候顺带 初始化了\n propsOptions: normalizePropsOptions(type, appContext)\n 这个值是个数组： [normalized, needCastKeys]\n normalized 是检测类型定义之后的 props，比如：\n {foo: [Boolean, String]} =\u0026gt; normalized.foo = {type: [Boolean, String]}\n 表示 foo 可以是布尔类型或者字符串类型。\n {foo: Function} =\u0026gt; normalized.foo = { type: Function}\n needCastKeys 表示是需要对属性值进行处理或者叫初始化的keys，比如： { foo: Boolean, bar: { default: 1 } } 那么 foo 的值要在 setFullProps() 里面转成 false 值，以及 bar=1 ，所以最后这个 props 实际等于 {foo: false, bar: 1} 转换规则在 setFullProps() -\u0026gt; resolvePropValue() 中完成。\n 规则如下：\n  {foo: { default: function() {/*...*/} }}\n 类型不是 Function 但是 default 值是个函数，则需要执行这个函数得到该属性最终的 默认值 {foo: default(props) } 传给这个函数是整个 props 对象。\n  {foo: { default: function() {/*...*/}, type: Function }} 类型是函数，表示这个属性本身就是函数，不需要做什么处理，直接将这个函数当做默 认值处理 {foo: default}\n  {foo: {default: 100}} 等价于 {foo: 100} default 是普通类型的具体值的处理\n  BooleanFlags.shouldCast 表示类型定义中有 Boolean 类型\n BooleanFlags.shouldCastTrue 时可能情况 {foo: [Boolean, String]}, {foo: [Boolean]} 要么只有 Boolean 要么 Boolean 在 String 前面，表示优先级更 高。\n 几种情况：\n  \u0026lt;Child/\u0026gt;, {foo: Boolean}, 结果: {foo: false}\n  \u0026lt;Child/ foo=true\u0026gt;, {foo: Boolean}, 结果： {foo: true}\n  \u0026lt;Child foo=\u0026#34;\u0026#34;/\u0026gt;, {foo: [Boolean, String]}, 结果: {foo: true}\n 这种情况比较特殊，vue 的处理是当两种类型都存在，且 Boolean 在 String 前面的 时候，会将值为 \u0026#34;\u0026#34; 的空串，转成 true ，作为 foo 的默认值。\n     最后的结果会在 comp.__props = [normalized, needCastKeys] 保存一份。\n normalizePropsOptions() 函数就不展开分析了，这里我们只需要知道 needCastKeys 是 做什么的。\n 所以：\n props: option api props 里面的存在的 key 归结为 props\n attrs: 其他情况，除了 emits 中存在的 key 之外都归结为 attrs\n    实例 defined? props, 默认值 attrs     \u0026lt;Child name=\u0026#34;child\u0026#34;/\u0026gt; no no yes   \u0026lt;Child name=\u0026#34;child\u0026#34;/\u0026gt; yes yes no   \u0026lt;Child name=\u0026#39;\u0026#39; /\u0026gt; yes, Boolean yes, false no   \u0026lt;Child name=\u0026#39;\u0026#39; /\u0026gt; yes, [Boolean,String] yes, true no   \u0026lt;Child name=\u0026#34;child\u0026#34; /\u0026gt; yes, [String], default: fn yes, fn() no   \u0026lt;Child onClick=\u0026#34;fn\u0026#34;/\u0026gt; no yes no    ","permalink":"https://www.cheng92.com/vue/vue-teardown-4-props-attrs/","tags":["vue3,","vue-next,","component,","props,","attrs"],"title":"Vue3 功能拆解④ 组件 props \u0026 attrs"},{"categories":["javascript,","web"],"contents":" Number::toString ( x )\n 在进行伪码之前，这里先要弄清楚几点：\n  标准中的 n, k, s 分别代表什么意思？\n n: 这个数有点迷惑，比如： 100, n = 3; 0.01, n = -2，如果是整数表示正数位数， 如果是浮点数就表示小数点的位数\n s: 表示一个值的范围\n k: 应该表示整数部分\n  标准中为什么 n 的上限是 21 ?\n 上限是 21 是因为超过21位的数字会转成指数表示形式，如下：\n  所以这里将 n 上限设置为 21 一旦超出就会转成指数来表示，这个时候字符串化就是另 一种处理方式了。\n  标准步骤中使用到的一些16进制表示的符号都是什么？\n1  ;[0x002E, 0x0030, 0x0065, 0x002b, 0x002D /**/].forEach(n =\u0026gt; console.log(String.fromCharCode(n)))    . 0 e + - undefined     code char     0x002E .   0x0030 0   0x0065 e   0x002B +   0x002D -        弄清楚了上面的三点，接下来就可以逐步去实现数字转字符串操作了：\n 伪码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71  function floatn(n) { // 小数点后面数个数  let c = 0; while ((n *= 10) % 10) { console.log(\u0026#34;n =\u0026#34; + n); c++; } return c; } function intn(n) { let c = 0; while (n) { c++; n = Math.floor(n / 10); } return c; } function bit(m) { let c = 0, k = 0, n = 0; if (m \u0026gt; 0 \u0026amp;\u0026amp; m \u0026lt; 10) { // 1 ~ 10 之间的数包括浮点数  k = 1; } } function /*Number::*/ toString(x) { if (isNaN(x)) return NaN; if (x === +0 || x === -0) return \u0026#34;0\u0026#34;; if (x \u0026lt; +0) { // 负数  return; /*Numbr::*/ toString(-x); } if (x === +Infinity) { return \u0026#34;Infinity\u0026#34;; } const nx = Math.floor(x); let n = bit(x), // 整个数字的数字部分长度，不含小数点  k = bit(nx), // 整数部分长度  s; // 取值范围：k \u0026gt;= 1, Math.pow(10, k-1) \u0026lt;= s \u0026lt;= Math.pow(10, k)  // s x Math.pow(10, n - k)  if (k \u0026lt;= n \u0026lt;= 21) { return \u0026#34;\u0026#34; + x; // 直接转成字符串就可以了  } else if (0 \u0026lt; n \u0026lt;= 21) { // TODO  } else if (-6 \u0026lt; n \u0026lt;= 0) { return \u0026#34;\u0026#34; + x; // 0.000005  } else if (k === 1) { return s + \u0026#34;e\u0026#34; + (n - 1 \u0026lt; 0 ? \u0026#34;-\u0026#34; : \u0026#34;+\u0026#34;) + Math.abs(n - 1); // 1e+5 or 1e-5  } else { return ( s[0] + \u0026#34;.\u0026#34; + s.slice(1, k) + \u0026#34;e\u0026#34; + (n - 1 \u0026lt; 0 ? \u0026#34;-\u0026#34; : \u0026#34;+\u0026#34;) + Math.abs(n - 1) ); } return x; } console.log(floatn(0.1001), intn(100.12));    n =1.001 n =10.009999999999998 n =100.09999999999998 n =1000.9999999999998 n =10009.999999999998 n =100099.99999999999 n =1000999.9999999999 n =10009999.999999998 n =100099999.99999999 n =1000999999.9999999 n =10009999999.999998 n =100099999999.99998 n =1000999999999.9999 n =10009999999999.998 n =100099999999999.98 n =1000999999999999.9 n =10009999999999998 n =100099999999999980 n =1000999999999999900 n =10009999999999998000 n =100099999999999980000 n =1.0009999999999999e+21 n =1.001e+22 n =1.0009999999999999e+23 n =1.0009999999999999e+24 n =1.0009999999999998e+25 n =1.0009999999999997e+26 n =1.0009999999999998e+27 28 3 undefined  6 undefined  ","permalink":"https://www.cheng92.com/web/apis/js-api-number-tostring/","tags":["javascript,","api,","Number"],"title":"JavaScript Api - Number::toString ( x ) - TODO"},{"categories":["vue"],"contents":" 诗号：六道同坠，魔劫万千，引渡如来。  \n  --  insertCssLink(\"https://unpkg.com/element-plus/lib/theme-chalk/index.css\");      本系列为 vue-next 源码分析系列的旁系分支，主要目的在于对 vue3 源码中的一些细节进 行分析。本文讲述的是 vue3 中组件的更新机制，比如：属性变更父子组件更新顺序是如 何？。\n  根据组件的渲染流程，我们知道组件的更新实际是通过 effect 封装了一个 instance.update 函数，当组件状态发生变化时会自动触发这个 update 函数执行，因为这 状态代理属性有收集到这个 update 函数。\n instance.update:\n instance.update = effect(function componentEffect() {/*...*/})\n 在 vue-package-reactivity 一节中有更详细的 effect 源码分析。\n 组件简要渲染，函数执行流程:\n  精简之后的 instance.update 函数：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47  function componentEffect() { if (!instance.isMounted) { // mount component  // invoke beforeMount(bm) hook  // invoke vnode before mount hook  const subTree = (instance.subTree = renderComponentRoot(instance)); patch(null, subTree, container, anchor, instance, parentSuspense, isSVG); initialVNode.el = subTree.el; // queue post - mounted(m) hook  // queue post - vnode mounted hook  // queue post - activated(a) hook  instance.isMounted = true; // #2458: deference mount-only object parameters to prevent memleaks  initialVNode = container = anchor = null as any; } else { // updateComponent  if (next) { next.el = vnode.el; updateComponentPreRender(instance, next, optimized); } else { next = vnode; } // invoke beforeUpdate(bu) hook  // invoke onVnodeBeforeUpdate hook  const nextTree = renderComponentRoot(instance); const prevTree = instance.subTree; instance.subTree = nextTree; // patch  patch( prevTree, nextTree, // parent may have changed if it\u0026#39;s in a teleport  hostParentNode(prevTree.el!)!, // anchor may have changed if it\u0026#39;s in a fragment  getNextHostNode(prevTree), instance, parentSuspense, isSVG ); next.el = nextTree.el; // queue post - updated(u) hook  // queue post - onVnodeUpdated  } }     主要分为 mount 和 update 两部分(if…else)\n mount: beforeMount hook -\u0026gt; onVnodeBefoureMount -\u0026gt; renderComponentRoot subTree -\u0026gt; patch subTree -\u0026gt; mounted hook -\u0026gt; onVnodeMounted -\u0026gt; [ activated hook ]\n update: next ? -\u0026gt; beforeUpdate hook -\u0026gt; onVnodeBeforeUpdate -\u0026gt; renderComponentRoot nextTree -\u0026gt; patch -\u0026gt; updated hook -\u0026gt; onVnodeUpdated\n 两个阶段中，有一个相关联的部分， subTree \u0026lt;-\u0026gt; nextTree 等于一个是 old tree 一个是 new tree， mount 阶段 patch(null, subTree) update 阶段 patch(subTree, nextTree)\n tree 的产生一样来自同一个函数：\n mount: renderComponentRoot(instance)\n update: renderComponentRoot(instance)\n 这个函数里面会去执行 instance 的 render 函数得到最新的 vnode tree ，等于是状态更 新触发这个函数去执行 render 得到最新的组件 vnode truee。\n render 函数来源：如果是函数组件就是该函数本身(instance.type)，如果是对象组件则 是对象内部的 instance.render 函数(可能来自 setup 返回的函数)。\n 测试(/js/vue/tests/L3jBmxJfNN.js)：父子组件更新顺序\n   上面链接可以查看测试源码。\n 这里我们在父子组件中均增加组件更新 hook:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  const Child = defineComponent({ setup() { onUpdated(() =\u0026gt; log(\u0026#34;child updated\u0026#34;)); onBeforeUpdate(() =\u0026gt; log(\u0026#34;child before update\u0026#34;)); }, // ... }); const Parent = defineComponent({ setup() { onUpdated(() =\u0026gt; log(\u0026#34;parent updated\u0026#34;)); onBeforeUpdate(() =\u0026gt; log(\u0026#34;parent before update\u0026#34;)); }, // ... });     点击按钮可以改变父子组件颜色，查看输出结果，会发现\n  只更新父组件背景色，只会触发 parent log\n  只更新子组件背景色，只会触发 child log\n  更新父组件背景色，同时改变父组件中传递给子组件的属性\n 子组件 style.backgroud 属性绑定 bgcolor，该值来自 parent 传递进来的 attrs，这 里为何是 attrs 而不是 props ?\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31  function changeParentColorWithProp() { changeParentColor(); bgcolor.value = bgcolor.value === \u0026#34;black\u0026#34; ? \u0026#34;coral\u0026#34; : \u0026#34;black\u0026#34;; } const Child = defineComponent({ setup() { onUpdated(() =\u0026gt; log(\u0026#34;child updated\u0026#34;)); onBeforeUpdate(() =\u0026gt; log(\u0026#34;child before update\u0026#34;)); }, render() { const { bgcolor } = this.$attrs; return h( \u0026#34;p\u0026#34;, { style: { background: bgcolor.value || childBgColor.value, }, onVnodeUpdated(newVnode, oldVnode) { log( \u0026#34;child vnode updated, new: \u0026#34; + newVnode.props.style.background + \u0026#34;, old: \u0026#34; + oldVnode.props.style.background ); }, }, \u0026#34;我是子组件\u0026#34; ); }, });      ","permalink":"https://www.cheng92.com/vue/vue-teardown-3-update-flow/","tags":["vue3,","vue-next,","component"],"title":"Vue3 功能拆解③ 组件更新机制"},{"categories":["react"],"contents":"  诗号：半神半圣亦半仙，全儒全道是全贤，脑中真书藏万卷，掌握文武半边天。  \n  该文代码均来自：Build your own React， 所以文中代码会保持和原作者定义一致。\n 代码脑图  1 2 3  const element = \u0026lt;h1 title=\u0026#34;foo\u0026#34;\u0026gt;Hello\u0026lt;/h1\u0026gt;; const container = document.getElementById(\u0026#34;root\u0026#34;); ReactDOM.render(element, container);      实现主要分为几个步骤\n  createElement 函数实现\n  render 函数实现\n  并发模式，渲染任务的执行 workLoop() 函数\n  Fibers react 中通过 fiber 结构来链接 parent, first child, sibling 以及作为节 点的结构，类似 vue 的 VNode\n  渲染和 commit 阶段，为了解决渲染进程可能被浏览器中断的问题，采取的是延迟渲染， 即在所有的 fiber 处理完之后，在最后执行渲染操作。\n  更新，新增，删除操作\n  函数式组件实现\n  钩子函数的实现 useState\n    预览   react 使用实例：\n1 2 3  const element = \u0026lt;h1 title=\u0026#34;foo\u0026#34;\u0026gt;Hello\u0026lt;/h1\u0026gt;; const container = document.getElementById(\u0026#39;root\u0026#39;); ReactDOM.render(element, container)     首先 const element = \u0026lt;h1 title=\u0026#34;foo\u0026#34;\u0026gt;Hello\u0026lt;/h1\u0026gt;; 属于 JSX 书写风格，这个会被转 换成 JS 代码:\n1 2 3 4 5  // 参数： // 1. type: \u0026#39;h1\u0026#39; 标签名 // 2. props: {title: \u0026#39;foo\u0026#39;} 为元素的属性对象 // 3. children: \u0026#39;Hello\u0026#39; 为子元素 const element = React.createElement(\u0026#34;h1\u0026#34;, { title: \u0026#34;foo\u0026#34; }, \u0026#34;Hello\u0026#34;);     其次是 ReactDOM.render(element, container) 进行渲染到真实DOM的操作，这个函数的 功能简述：\n1 2 3 4 5 6 7 8 9 10 11 12  // 1. 根据 element.type 去创建 off-dom 元素 const node = document.createElement(element.type); // 2. 设置属性 props node[\u0026#39;title\u0026#39;] = element.props.title // 3. 处理 children 子元素 const text = document.createTextNode(\u0026#39;\u0026#39;) text[\u0026#39;nodeValue\u0026#39;] = element.props.children // 4. 最后更新到真实DOM树 node.appendChild(text) container.appendChild(node)     所以 render 函数的功能总结下来就分为四个步骤：\n  拿到节点的 fiber 结构，创建 off-dom 元素\n  处理 element.props 属性(可能是动态，静态，也可能是事件属性)\n  处理 element.children 子元素\n  更新到真实的 DOM 树\n   具体的实现都是围绕这个点去完成的，\n 比如 1 会使用 fiber 结构来组织每个节点，并且每个节点结构一般会有三个引用： parent、first child、sibling 这三个链接这个整个fiber 树的，这也为了后面节点操作 时方便查找。\n 又比如 2 中对 props 的处理，会考虑是不是事件属性 onXxx 。\n 以及最后更新真实DOM的时机等待。\n nodeValue: HTML DOM nodeValue Property\n   完整代码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21  // createElement: jsx -\u0026gt; js vnode 结构 const element = { type: \u0026#39;h1\u0026#39;, props: { title: \u0026#39;foo\u0026#39;, children: \u0026#39;Hello\u0026#39; } } const container = document.getElementById(\u0026#39;root\u0026#39;) // 创建节点 const node = document.createElement(element.type) node[\u0026#39;title\u0026#39;] = element.props.title // 创建子节点 const text = document.createTextNode(\u0026#39;\u0026#39;) text[\u0026#39;nodeValue\u0026#39;] = element.props.children node.appendChild(text) container.appendChild(node)    测试：   // createElement: jsx - js vnode 结构 const element = { type: 'h1', props: { title: 'foo', children: 'Hello' } } const container = document.getElementById('c07Rp8') // 创建节点 const node = document.createElement(element.type) node['title'] = element.props.title // 创建子节点 const text = document.createTextNode('') text['nodeValue'] = element.props.children node.appendChild(text) container.appendChild(node)     createElement   JSX 实例:\n1 2 3 4 5 6  const element = ( \u0026lt;div id=\u0026#34;foo\u0026#34;\u0026gt; \u0026lt;a\u0026gt;bar\u0026lt;/a\u0026gt; \u0026lt;b /\u0026gt; \u0026lt;/div\u0026gt; )     转成 JS 后调用 createElement:\n1 2 3 4 5 6 7 8  React.createElement( \u0026#34;div\u0026#34;, { id: \u0026#34;foo\u0026#34;, }, React.createElement(\u0026#34;a\u0026#34;, null, \u0026#34;bar\u0026#34;), React.createElement(\u0026#34;b\u0026#34;) );     一个节点在渲染到 DOM 之前都会是以一个VNode 形式存在，其中就包含最基本的 type, props 属性。\n {type: \u0026#39;div\u0026#39;, props: { id: \u0026#39;foo\u0026#39;, children: ... } }\n 这和 vue vnode 结构是类似的，只不过 vue vnode 的 children 不是在 props 里面：\n {type: \u0026#39;div\u0026#39;, props: {id: \u0026#39;foo\u0026#39;}, children: [...] }\n 这里只要知道 createElement 目的是解析节点，返回一个节点结构对象，下面就可以开始尝 试实现 createElement 了\n 最简单的实现：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30  // 第三个参数开始都当做子元素 function createElement(type, props, ...children) { return { type, props: { ...props, children, }, }; } // 所以，上面的实例会有如下结构： var div = { type: \u0026#34;div\u0026#34;, props: { id: \u0026#34;foo\u0026#34;, children: [a, b] }, }; var a = { type: \u0026#34;a\u0026#34;, props: { children: [\u0026#34;bar\u0026#34;], }, }; var b = { type: \u0026#34;b\u0026#34;, props: { children: [], // 没有的时候默认返回空数组  }, };     这里面对于 children 有两种类型\n  \u0026lt;a\u0026gt;bar\u0026lt;/a\u0026gt; 的 children 只有 \u0026#34;bar\u0026#34; 是个纯文本类型\n  \u0026lt;div\u0026gt;...\u0026lt;/div\u0026gt; 的 children 有两个节点 a 和 b ，他们经过 createElement 之后 都是对象，所以这里需要进行判断下，纯文本去创建文本节点\n  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44  function createElement(type, props, ...children) { return { type, props: { ...props, // 这里对于文本内容，去创建文本节点  children: children.map((child) =\u0026gt; typeof child === \u0026#34;object\u0026#34; ? child : createTextElement(child) ), }, }; } function createTextElement(text) { return { type: \u0026#34;TEXT_ELEMENT\u0026#34;, // 标记类型  props: { // node.nodeValue 属性可以设置文本节点的内容，类似 textContent  nodeValue: text, children: [], }, }; } // 测试 const element = createElement( \u0026#34;div\u0026#34;, { id: \u0026#34;foo\u0026#34; }, createElement(\u0026#34;a\u0026#34;, null, \u0026#34;bar\u0026#34;), createElement(\u0026#34;b\u0026#34;) ); console.log( \u0026#34;输出结构\u0026gt;\u0026gt;\u0026gt; \\n\u0026#34;, element, \u0026#34;\\n \u0026gt; element children: \\n\u0026#34;, element.props.children, \u0026#34;\\n \u0026gt; a children: \\n\u0026#34;, element.props.children[0].props.children ); // 为了区别 React，这里采用文字作者的命名空间： Didact const Didact = { createElement }    输出结构\u0026gt;\u0026gt;\u0026gt; { type: \u0026#39;div\u0026#39;, props: { id: \u0026#39;foo\u0026#39;, children: [ [Object], [Object] ] } } \u0026gt; element children: [ { type: \u0026#39;a\u0026#39;, props: { children: [Array] } }, { type: \u0026#39;b\u0026#39;, props: { children: [] } } ] \u0026gt; a children: [ { type: \u0026#39;TEXT_ELEMENT\u0026#39;, props: { nodeValue: \u0026#39;bar\u0026#39;, children: [] } } ] undefined   为了方便后面的测试，考虑到代码会慢慢变长问题，后面的代码会移到 /js/react/didact.js 中去。\n 之后测试方式：\n1 2 3 4 5 6 7 8 9 10 11  import(process.env.BLOG_JS + \u0026#34;/react/didact.js\u0026#34;).then(({ default: Didact }) =\u0026gt; { console.log(Didact); // 这样照样可以完成上面的测试  const element = Didact.createElement( \u0026#34;div\u0026#34;, { id: \u0026#34;foo\u0026#34; }, Didact.createElement(\u0026#34;a\u0026#34;, null, \u0026#34;bar\u0026#34;), Didact.createElement(\u0026#34;b\u0026#34;) ); console.log(element); });    undefined { createElement: [Function: createElement] } { type: \u0026#39;div\u0026#39;, props: { id: \u0026#39;foo\u0026#39;, children: [ [Object], [Object] ] } }    render   增加 render 函数，它的目的在一开始也说了，就是将 vnode 渲染到真实DOM，至于怎么渲 染，结构又是怎么处理的，这之后会慢慢的去完成。\n1 2 3 4 5 6 7 8 9  const Didact = { createElement, render } // ReactDOM.render function render(element, container) { // TODO }     渲染当前树根节点和子节点元素渲染工作：\n1 2 3 4 5 6 7 8 9 10  // ReactDOM.render function render(element, container) { // 1. 创建当前树根节点元素  const dom = document.createElement(element.type) // 2. 遍历所有的 children 创建子元素  element.props.children.forEach(child =\u0026gt; render(child, dom /*parent*/)) container.appendChild(dom) }     但是节点类型有可能是纯文本的，比如 createElement 一节 中的例子里面的 \u0026lt;a\u0026gt;bar\u0026lt;/a\u0026gt; 就有一个纯文本的 \u0026#34;bar\u0026#34; 节点，这个节点经过 createElement 之后结构 是： {type: \u0026#39;TEXT_ELEMENT\u0026#39;, props: {...}} ，所以这里面只需要针对 TEXT_ELEMENT 做下特殊处理，如果是文本就创建一个空的文本节点来容乃该文本内容。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14  // ReactDOM.render function render(element, container) { // 1. 创建当前树根节点元素 - const dom = document.createElement(element.type) + const dom = + element.type === \u0026#34;TEXT_ELEMENT\u0026#34; + ? document.createTextNode(\u0026#34;\u0026#34;) + : document.createElement(element.type);  // 2. 遍历所有的 children 创建子元素 element.props.children.forEach((child) =\u0026gt; render(child, dom /*parent*/)); container.appendChild(dom); }      最后是 props 的处理，这里记得要排除 props.children\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18  // ReactDOM.render function render(element, container) { // 1. 创建当前树根节点元素 const dom = element.type === \u0026#34;TEXT_ELEMENT\u0026#34; ? document.createTextNode(\u0026#34;\u0026#34;) : document.createElement(element.type); + const isProperty = (key) =\u0026gt; key !== \u0026#34;children\u0026#34;; + Object.keys(element.props) + .filter(isProperty) + .forEach((name) =\u0026gt; (dom[name] = element.props[name]));  // 2. 遍历所有的 children 创建子元素 element.props.children.forEach((child) =\u0026gt; render(child, dom /*parent*/)); container.appendChild(dom); }      最后该阶段完整的代码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47  console.log(\u0026#34;\\n\u0026#34;); const Didact = { createElement, render, }; // ReactDOM.render function render(element, container) { // 1. 创建当前树根节点元素  const dom = element.type === \u0026#34;TEXT_ELEMENT\u0026#34; ? document.createTextNode(\u0026#34;\u0026#34;) : document.createElement(element.type); const isProperty = (key) =\u0026gt; key !== \u0026#34;children\u0026#34;; Object.keys(element.props) .filter(isProperty) .forEach((name) =\u0026gt; (dom[name] = element.props[name])); // 2. 遍历所有的 children 创建子元素  element.props.children.forEach((child) =\u0026gt; render(child, dom /*parent*/)); container.appendChild(dom); } // React.createElement function createElement(type, props, ...children) { return { type, props: { ...props, children: children.map((child) =\u0026gt; typeof child === \u0026#34;object\u0026#34; ? child : createTextElement(child) ), }, }; } function createTextElement(text) { return { type: \u0026#34;TEXT_ELEMENT\u0026#34;, props: { nodeValue: text, // 类似 textContent 可以修改节点文本内容的属性  children: [], }, }; }     测试:\n  (function() { console.log(Didact) const container = document.getElementById('qoCIUr') const element = Didact.createElement('div', { id: 'foo', }, Didact.createElement('a', null, 'bar'), Didact.createElement('b')) Didact.render(element, container) }());   测试代码：\n1 2 3 4 5 6 7 8 9 10 11 12 13  console.log(Didact); const container = document.getElementById(\u0026#34;qoCIUr\u0026#34;); const element = Didact.createElement( \u0026#34;div\u0026#34;, { id: \u0026#34;foo\u0026#34;, }, Didact.createElement(\u0026#34;a\u0026#34;, null, \u0026#34;bar\u0026#34;), Didact.createElement(\u0026#34;b\u0026#34;) ); Didact.render(element, container);      并发模式(workLoop())   注意看上一节最后的代码，在 render 中会递归调用来完成 children 的渲染工作，这里就 会出现一个问题，只要 render 一旦执行，在渲染完整棵树之前是不能停止的，否则将导致 页面不完整。\n 昨天微信里面看到一篇文章：\n Event Loop 和 JS 引擎、渲染引擎的关系\n 这里面大概讲述了一些JS 和 渲染之间的一些关系，而这里的实现和这文章里讲述的一些原 理是相通的。\n  要解决 render 递归的问题，大致的思想是通过 Fiber 将渲染任务封装，在某一个空闲的 时刻去执行这些 Fibers 进行实际的渲染，这样不至于阻塞主任务的执行。\n 这里的每个 Fiber 也被称作 work unit，当一个 work unit 完成会自动找到下一个应该执 行的 work unit 也就是下一个 Fiber，为什么叫应该呢，因为每个 Fiber 上面不止有一个 引用指向下一个 Fiber，然后如何决定下一个 work unit 跟渲染的优先级有关系。\n 每个 Fiber 上面最多有三个引用 parent, first child, parent sibling 三个节点。\n 优先级是: first child \u0026gt; parent sibling \u0026gt; parent。\n 如何执行 work unit ?\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  let nextUnitOfWork = null function workLoop(deadline) { let shouldYield = false while (nextUnitOfWork \u0026amp;\u0026amp; !shouldYield) { // 执行当前的 work unit 返回下一个将要执行的 work unit  nextUnitOfWork = performUnitOfWork(nextUnitOfWork) // 没有空闲的时间了  shouldYield = deadline.timeRemaining() \u0026lt; 1 } // 下个空闲时间去执行下一次 work unit loop  requestIdleCallback(workLoop) } function performUnitOfWork(nextUnitOfWork) { // TODO }      这里使用 requestIdleCallback 这个函数会在渲染之前检查是不是有空闲的时间，如果 有则执行回调，或者超时了强制执行回调。\n React 已经不用这个了，而是自己实现了 react/packages/scheduler at master · facebook/react 来管理 fiber 的执行时机。\n   Fibers   上一节在实现 workLoop() 提到了 work unit 即 fiber。\n 为了方便管理一个 work unit ，需要一个比较合理的结构，里面能保存一些相关的信息， 比如 parent, first child, parent sibling 引用， VNode 节点信息，等待。\n 这个结果就是: Fiber tree 由一个个 fiber 结构通过链接组成的树，其实就是类似 Vue 中的 VNode 节点树。\n 例如：\n1 2 3 4 5 6 7 8 9 10  Didact.render( \u0026lt;div\u0026gt; \u0026lt;h1\u0026gt; \u0026lt;p /\u0026gt; \u0026lt;a /\u0026gt; \u0026lt;/h1\u0026gt; \u0026lt;h2 /\u0026gt; \u0026lt;/div\u0026gt;, container )     有如下的结构，该结构让每个节点都最多持有三个引用，从而更方便的找到下一个 work unit:\n  render 查找步骤拆解：\n root -\u0026gt; \u0026lt;div\u0026gt; -\u0026gt; \u0026lt;h1\u0026gt; -\u0026gt; \u0026lt;p\u0026gt; 这是遵循 first child 优先级最高查找的结果，一旦这个 过程渲染完成，接下来应该找 \u0026lt;p\u0026gt; 的 sibling(因为 sibling 优先级高于 parent 低于 first child):\n \u0026lt;a\u0026gt; -\u0026gt; \u0026lt;h2\u0026gt; 因为 \u0026lt;a\u0026gt; 既没有 first child 也没有 sibling 所以找 parent sibling 即 \u0026lt;h2\u0026gt; 然后继续找发现 \u0026lt;div\u0026gt; 并没有 sibling，一直如此知道根节点。\n 更新 render 函数，将 DOM 元素的创建从 render 中抽离出来成 createDom 函数，这里开始使用 fiber:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25  function createDom(fiber) { // 1. 创建当前树根节点元素  const dom = fiber.type === \u0026#34;TEXT_ELEMENT\u0026#34; ? document.createTextNode(\u0026#34;\u0026#34;) : document.createElement(fiber.type); const isProperty = (key) =\u0026gt; key !== \u0026#34;children\u0026#34;; Object.keys(fiber.props) .filter(isProperty) .forEach((name) =\u0026gt; (fiber[name] = fiber.props[name])); return dom; } let nextUnitOfWork = null function render(element, container) { // 构建 root fiber 作为第一个 nextUnitOfWork  nextUnitOfWork = { dom: container, props: { children: [element] } } }     在 render 一开始会创建一个 root fiber 并且将它作为第一个 nextUnitOfWork ，而后 面则是执行 performUnitOfWork 这里面主要完成三部分任务：\n  将 fiber 对应的 element 添加到 DOM\n  为 1 中的 element.children 创建 fibers\n  找到合适的下一个 work unit 返回\n  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58  function performUnitOfWork(fiber) { // 1. 创建 fiber dom 元素  if (!fiber.dom) { fiber.dom = createDom(fiber); } // 2. 将 fiber dom 添加到 parent DOM 树中去  if (fiber.parent) { fiber.parent.dom.appendChild(fiber.dom); } // 3. 处理 children  const elements = fiber.props.children; let index = 0; let prevSibling = null; while (index \u0026lt; elements.length) { const element = elements[index]; // 为每个 child 构建 fiber 结构  const newFiber = { type: element.type, props: element.props, parent: fiber, // 指向父级 fiber 的引用  dom: null, // 指向真实DOM元素的引用  }; if (indx === 0) { // 表示是 parent 的第一个 child，标记为 first child  firber.child = newFiber; // 第一个引用，优先级最高  } else { // 非第一次的时候，等于是节点的兄弟节点  // 第二个引用，优先级低于 first child  prevSibling.sibling = newFiber; } prevSibling = newFiber; index++; } // 到这里 fiber 结构初始化完成，此时每个 fiber 也有了自己的  // 三个引用 fiber.child, fiber.parent, fiber.sibling  // 下面将要去找到当前 Fiber 的下一个 work unit，查找遵循优先级:  // fiber.child \u0026gt; fiber.sibling \u0026gt; fiber.parent.sibling  if (fiber.child) { return fiber.child; } let nextFiber = fiber; while (nextFiber) { if (nextFiber.sibling) { // 第一次这里找的是当前节点的兄弟节点，如果没找到  // 依着 fiber 树往上找 parent 的 sibling  return nextFiber.sibling; } nextFiber = fiber.parent; } }      Render and Commit 阶段   到现在为止，前面都只是在 fiber tree 基础上去做了处理（创建 DOM 元素，链接 fiber tree，找下一个 work unit），但实际并没有开始渲染。\n 并且这里 performUnitOfWork 实现中有个问题：\n1 2 3  if (fiber.parent) { fiber.parent.dom.appendChild(fiber.dom); }     即这里每次执行 work unit 的时候都会立即将 fiber.dom 添加到 parent 的 DOM 🌲中去， 然后这个操作很有可能在完成整棵树的渲染之前被浏览器给终止了。\n 怎么解决这个问题？\n 从根上去解决这个问题，即在 render 中不用一开始就去进行 append 操作，而是从 root 开始去跟踪整个树的结构变化，将 root 也封装成 fiber。\n1 2 3 4 5 6 7 8 9 10 11  let wipRoot = null function render(element, container) { wipRoot = { dom: container, props: { children: [element] } } nextUnitOfWork = wipRoot }     然后，一旦 wookLoop() 的一次循环结束了就进行一次提交，去一次性完成渲染任务。\n 那怎么判断说一次循环结束了？\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34  function commitRoot() { // 执行 DOM 渲染  commitWork(wipRoot.child); // 提交完成之后要重置，等待下一次更新的任务  wipRoot = null; } function commitWork(fiber) { if (!fiber) return; // 这里顺序也是一样 fiber -\u0026gt; fiber.child -\u0026gt; fiber.sibling  const domParent = fiber.parent.dom; domParent.appendChild(fiber.dom); commitWork(fiber.child); commitWork(fiber.sibling); } function workLoop(deadline) { let shouldYield = false; while (nextUnitOfWork \u0026amp;\u0026amp; !shouldYield) { // 执行当前的 work unit 返回下一个将要执行的 work unit  nextUnitOfWork = performUnitOfWork(nextUnitOfWork); // 没有空闲的时间了  shouldYield = deadline.timeRemaining() \u0026lt; 1; } // 这里检测没有下一个 work unit 了，说明整个树遍历完成了  if (!nextUnitOfWork \u0026amp;\u0026amp; wipRoot) { commitRoot(); } // 下个空闲时间去执行下一次 work unit loop  requestIdleCallback(workLoop); }      updating and deleting 更新和删除   这一节将讲述如何将 old fiber 和 new fiber 进行比较来判断是进行 update 还是 delete 操作。\n 所以 Fiber 里面需要对上一次的提交的 fiber tree 进行备份。\n 这里用 currentRoot 表示 new fiber 用 fiber.alternate 来保存 old fiber。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20  + let currentRoot = null function commitRoot() { commitWork(wipRoot.child) + // 当前渲染的树进行备份 + currentRoot = wipRoot  wipRoot = null } function render(element, container) { wipRoot = { dom: container, props: { children: [element] }, + // 保存一份老树 + alternate: currentRoot  } nextUnitOfWork = wipRoot }      将 performUnitOfWork 中创建 Fiber 的抽离到 reconcileChildren 中去方便添加更 新和删除操作。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70  function reconcileChildren(wipFiber, elements) { let index = 0; let oldFiber = wipFiber.alternate \u0026amp;\u0026amp; wipFiber.alternate.child let prevSibling = null; while (index \u0026lt; elements.length) { // 这个 element 是将要更新到DOM中的节点  const element = elements[index]; let newFiber = null // 比较 oldFiber 和 element  // 类型一样，属于更新  const sameType = oldFiber \u0026amp;\u0026amp; element \u0026amp;\u0026amp; oldFiber.type === element.type // 下面的更新并非是直接立即更新，而是为 Fiber 赋予新的属性来标识该节点  // 在 commit 阶段应该执行什么操作  if (sameType) { // 更新节点  newFiber = { type: oldFiber.type, props: element.props, dom: oldFiber.dom, parent: wipFiber, alternate: oldFiber, effectTag: \u0026#39;UPDATE\u0026#39; } } if (element \u0026amp;\u0026amp; !sameType) { // 添加节点  newFiber = { type: element.type, props: element.props, dom: null, parent: wipFiber, alternate: null, effectTag: \u0026#39;PLACEMENT\u0026#39; } } if (oldFiber \u0026amp;\u0026amp; !sameType) { // 删除节点  oldFiber.effecTag = \u0026#39;DELETION\u0026#39; // 因为 commit 是从 root 从上往下提交的，且在提交阶段  // 已经丢失了 old fiber，因为上面结构已经更新了，因此这里需要记录  // 哪些节点需要删除  deletion.push(oldFiber) } // 为每个 child 构建 fiber 结构  newFiber = { type: element.type, props: element.props, parent: fiber, // 指向父级 fiber 的引用  dom: null, // 指向真实DOM元素的引用  }; if (indx === 0) { // 表示是 parent 的第一个 child，标记为 first child  firber.child = newFiber; // 第一个引用，优先级最高  } else { // 非第一次的时候，等于是节点的兄弟节点  // 第二个引用，优先级低于 first child  prevSibling.sibling = newFiber; } prevSibling = newFiber; index++; } }     然后修改 render ，初始化或重置 deletion:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17  let deletion = null // ReactDOM.render function render(element, container) { wipRoot = { dom: container, props: { children: [element], }, alternate: currentRoot, }; // 初始化或重置待删除的节点，因为 fiber tree 更新发生在 commit 之前  // 因此在 commit 阶段 old fiber 已经被替换了，所以在 fiber tree 更新的  // 时候就要将要删除的 old fiber 缓存起来  deletion = []; nextUnitOfWork = wipRoot; }     然后在提交阶段 commitRoot 中执行删除\n1 2 3 4 5 6  function commitRoot() { deletion.forEach(commitWork) // 执行节点删除  commitWork(wipRoot.child) currentRoot = wipRoot wipRoot = null }     最后修改 commitWork 去处理新增的 fiber.effectTag 根据不同类型执行相应的增加、删 除、更新操作。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18  function commitWork(fiber) { if (!fiber) return; // 这里顺序也是一样 fiber -\u0026gt; fiber.child -\u0026gt; fiber.sibling  const domParent = fiber.parent.dom; if (fiber.effectTag === \u0026#34;PLACEMENT\u0026#34; \u0026amp;\u0026amp; fiber.dom != null) { // 添加新节点  domParent.appendChild(fiber.dom); } else if (fiber.effectTag === \u0026#34;DELETION\u0026#34;) { domParent.removeChild(fiber.dom); } else if (fiber.effectTag === \u0026#34;UPDATE\u0026#34; \u0026amp;\u0026amp; fiber.dom != null) { // 更新节点  updateDom(fiber.dom, fiber.alternate.props, fiber.props); } commitWork(fiber.child); commitWork(fiber.sibling); }     更新节点，需要对状态进行对比，进行更新：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18  const isProperty = (key) =\u0026gt; key !== \u0026#34;children\u0026#34;; // 新属性 const isNew = (prev, next) =\u0026gt; (key) =\u0026gt; prev[key] !== next[key]; // 要删除的属性 const isGone = (prev, next) =\u0026gt; (key) =\u0026gt; !key in next; function updateDom(dom, prevProps, nextProps) { // 删除  Object.keys(prevProps) .filter(isProperty) .filter(isGone(prevProps, nextProps)) .forEach((name) =\u0026gt; (dom[name] = \u0026#34;\u0026#34;)); // 更新新增  Object.keys(nextProps) .filter(isProperty) .filter(isNew(prevProps, nextProps)) .forEach(name =\u0026gt; (dom[name] = nextProps[name])) }     处理特殊属性：事件属性的处理，需要将原来的 handler 先移除再添加新的 handler。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36  const isEvent = (key) =\u0026gt; key.startsWith(\u0026#34;on\u0026#34;); const isProperty = (key) =\u0026gt; key !== \u0026#34;children\u0026#34; \u0026amp;\u0026amp; !isEvent(key); // 新属性 const isNew = (prev, next) =\u0026gt; (key) =\u0026gt; prev[key] !== next[key]; // 要删除的属性 const isGone = (prev, next) =\u0026gt; (key) =\u0026gt; !key in next; function updateDom(dom, prevProps, nextProps) { // 移除或更新 event listeners  Object.keys(prevProps) .filter(isEvent) .filter((key) =\u0026gt; !(key in nextProps) || isNew(prevProps, nextProps)(key)) .forEach((name) =\u0026gt; { const eventType = name.toLowerCase().substring(2); dom.removeEventListener(eventType, prevProps[name]); }); // 删除  Object.keys(prevProps) .filter(isProperty) .filter(isGone(prevProps, nextProps)) .forEach((name) =\u0026gt; (dom[name] = \u0026#34;\u0026#34;)); // 更新新增  Object.keys(nextProps) .filter(isProperty) .filter(isNew(prevProps, nextProps)) .forEach((name) =\u0026gt; (dom[name] = nextProps[name])); // 新增事件属性  Object.keys(nextProps) .filter(isEvent) .filter(isNew(prevProps, nextProps)) .forEach((name) =\u0026gt; { const eventType = name.toLowerCase().substring(2); dom.addEventListener(eventType, nextProps[name]); }); }     修改 createDom 初创建 DOM 元素的时候执行一次 updateDom(dom, {}, fiber.props)\n1 2 3 4 5 6 7 8 9 10 11 12 13 14  function createDom(fiber) { const dom = fiber.type === \u0026#39;TEXT_ELEMENT\u0026#39; ? document.createTextNode(\u0026#39;\u0026#39;) : document.createElement(fiber.type) - const isProperty = (key) =\u0026gt; key !== \u0026#34;children\u0026#34;; - Object.keys(fiber.props) - .filter(isProperty) - .forEach((name) =\u0026gt; (fiber[name] = fiber.props[name]));  + updateDom(dom, {}, fiber.props)  return dom }       函数组件   如实例：\n1 2 3 4 5 6 7 8 9 10 11  function App(props) { return \u0026lt;h1\u0026gt;Hi {props.name}\u0026lt;/h1\u0026gt; } const element = \u0026lt;App name=\u0026#34;foo\u0026#34;/\u0026gt; // jsx -\u0026gt; js function App(props) { return Didact.createElement(\u0026#39;h1\u0026#39;, null, \u0026#34;Hi \u0026#34;, props.name) } const element = Didact.createElement(App, { name: \u0026#39;foo\u0026#39; })     函数组件与普通组件不同点:\n  来自函数组件的 Fiber 没有 DOM 节点\n  fiber.children 来自函数执行的结果，而不是直接从 props 中取\n   修改 performUnitOfWork 增加函数组件判断:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26  function performUnitOfWork(fiber) { const isFunctionComponent = fiber.type instanceof Function if (isFunctionComponent) { updateFunctionComponent(fiber) } else { updateHostComponent(fiber) } // 到这里 fiber 结构初始化完成，此时每个 fiber 也有了自己的  // 三个引用 fiber.child, fiber.parent, fiber.sibling  // 下面将要去找到当前 Fiber 的下一个 work unit，查找遵循优先级:  // fiber.child \u0026gt; fiber.sibling \u0026gt; fiber.parent.sibling  if (fiber.child) { return fiber.child; } let nextFiber = fiber; while (nextFiber) { if (nextFiber.sibling) { // 第一次这里找的是当前节点的兄弟节点，如果没找到  // 依着 fiber 树往上找 parent 的 sibling  return nextFiber.sibling; } nextFiber = nextFiber.parent; } }     更新函数组件 updateFunctionComponent(fiber) :\n1 2 3 4 5  function updateFunctionComponent(fiber) { // 执行函数组件得到 children  const children = [fiber.type(fiber.props)] reconcileChildren(fiber, children) }     更新普通组件 updateHostComponent(fiber) 直接把 performUnitOfWork 中原来的处理 挪进来就 OK:\n1 2 3 4 5 6 7 8  function updateHostComponent(fiber) { // 1. 创建 fiber dom 元素  if (!fiber.dom) { fiber.dom = createDom(fiber); } reconcileChildren(fiber, fiber.props.children); }     因为函数组件并没有 DOM 元素，所以 commit 阶段需要进行判断，如果没有就往上找父级 的 dom 元素作为 parent 。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24  function commitWork(fiber) { if (!fiber) return; // 这里顺序也是一样 fiber -\u0026gt; fiber.child -\u0026gt; fiber.sibling  const domParentFiber = fiber.parent; // 如果是函数组件是没有 dom 的，那么需要找到它的父级作为目标 parent  while (!domParentFiber.dom) { domParentFiber = domParentFiber.parent; } const domParent = domParentFiber.dom; if (fiber.effectTag === \u0026#34;PLACEMENT\u0026#34; \u0026amp;\u0026amp; fiber.dom != null) { // 添加新节点  domParent.appendChild(fiber.dom); } else if (fiber.effectTag === \u0026#34;UPDATE\u0026#34; \u0026amp;\u0026amp; fiber.dom != null) { // 更新节点  updateDom(fiber.dom, fiber.alternate.props, fiber.props); } else if (fiber.effectTag === \u0026#34;DELETION\u0026#34;) { commitDeletion(fiber, domParent); } commitWork(fiber.child); commitWork(fiber.sibling); }     删除的时候也必须找到有 child 的 fiber, commitDeletion ：\n1 2 3 4 5 6 7  function commitDeletion(fiber, domParent) { if (fiber.dom) { domParent.removeChild(fiber.dom) } else { commitDeletion(fiber.child, domParent) } }      hooks   添加状态和 hooks。\n 在函数组件中我们可以通过 useState hook 来获取状态以及改变状态的函数 setState 让我们能在函数组件中来更新状态，从而来更新UI。\n 实例：\n1 2 3 4 5 6 7 8 9  function Counter() { const [state, setState] = useState(1) return ( \u0026lt;h1 onClick={() =\u0026gt; setState(c =\u0026gt; c+1)}\u0026gt; Count: { state } \u0026lt;/h1\u0026gt; ) } const elment = \u0026lt;Counter/\u0026gt;     实现 useState 并且修改函数组件的更新函数 updateFunctionComponent 让状态的修改能 触发该函数执行:\n1 2 3 4 5 6 7 8 9 10 11 12 13  function useState(initial) { } let wipFiber = null let hookIndex = null function updateFunctionComponent(fiber) { wipFiber = fiber hookIndex = 0 wipFiber.hooks = [] const children = [fiber.type(fiber.props)] reconcileChildren(fiber, children) }     新增 fiber.hooks 目的是为了在同一个组件内可以多次调用 useState, 并且记录每个 hook 所在的索引 hookIndex 。\n 当组件调用 useState 时候，在里面要去检测是不是有 old hook，从 fiber.alternate 根据 hookIndex 去找。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33  function useState(initial) { const oldHook = wipFiber.alternate \u0026amp;\u0026amp; wipFiber.alternate.hooks \u0026amp;\u0026amp; wipFiber.alternate.hooks[hookIndex]; // 如果有老的 hook ，要将老的 hook state 更新过来  const hook = { state: oldHook ? oldHook.state : initial, // 缓存状态更新的 action  queue: [], }; // 更新之前先执行 actions 更新状态，因此在状态返回之前是最新的  const actions = oldHook ? oldHook.queue : []; actions.forEach((action) =\u0026gt; (hook.state = action(hook.state))); const setState = (action) =\u0026gt; { hook.queue.push(action); wipRoot = { dom: currentRoot.dom, props: currentRoot.props, alternate: currentRoot, }; // 状态更新，插入新的 work unit  nextUnitOfWork = wipRoot; deletion = []; }; wipFiber.hooks.push(hook); hookIndex++; return [hook.state, setState]; }      最终源码流程图     测试     diff 还没有深入实现，没做到 setState 只更新相应的文本 count = 0 组件。\n 还有待继续研究！！！\n  总结   通过作者的这个实现，对 react 的部分主要功能有了一定的认知，文内涉及的主要知识点：\n  createElement 实现\n  render 函数的实现\n  fiber tree 的处理(初始化，更新，删除，新增等)\n  commit 阶段处理，实际渲染DOM和 fiber tree 的遍历是分开的\n  useState hook 函数实现的基础原理，通过 wipFiber + hookIndex 来实现函数组件和 useState 的连接，从而互相影响。\n    ","permalink":"https://www.cheng92.com/react/react-zero/","tags":["react,","mini-react"],"title":"Build Your Own React"},{"categories":["react"],"contents":"   指南针： 老少皆宜的React源码通关指南 - 云+社区 - 腾讯云\n  Build your own React\n   ","permalink":"https://www.cheng92.com/react/react-study-roadmap/","tags":["react"],"title":"React Eco-System(React 生态学习资源)"},{"categories":["react"],"contents":"  react/packages/scheduler at master · facebook/react\nTODO   ","permalink":"https://www.cheng92.com/react/react-package-scheduler/","tags":["react,","scheduler"],"title":"React Package Scheduler 分析"},{"categories":["vue"],"contents":"  官方仓库： championswimmer/vuex-persist: A Vuex plugin to persist the store. (Fully Typescript enabled)\n  VuexPersistence   原理就一句话：通过 vuex.subscribe 订阅一个函数，在每次 commit mutation 的时候执 行去更新 persist store。\n  构造函数:\n1 2 3  function VuexPersistence(options) { // ... }    存储源   初始化，并且决定用哪种方式存储数据，主要有三种方式：\n  用户定义存到哪里 options.storage\n  H5 的 storage api localStorage 本地存储\n  MockStorage 库内部的一个封装，内存存储方案\n  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27  function VuexPersistence(options = {}) { // 创建一个队列管理器实例  const _mutex = new SimplePromiseQueue() this.key = options.key ?? \u0026#39;vuex\u0026#39; this.subscribed = false this.mergeOption = options.mergeOption || \u0026#39;replaceArrays\u0026#39; let localStorateLitmus = true // 支不支持 H5 storage api  try { window.localStorage.getItem(\u0026#39;\u0026#39;) } catch (err) { localStorageLitmus = false } // 几种 storage 存储机制  // 1. 用户定义的  // 2. H5 storage api localStorage  // 3. mock storage 内存里的一个全局变量  // 4. 都不是应该报错  if (options.storage) { this.storage = options.storage } }      [save|restore]State   这两个函数直接操作 store 存储源。\n1 2 3 4 5 6 7 8 9 10 11 12 13  // 清空数据 this.restoreState = (key, storage) =\u0026gt; { const value = storage.getItem(key); if (typeof value === \u0026#34;string\u0026#34;) { return JSON.parse(value || \u0026#34;{}\u0026#34;); } else { return value || {}; } }; this.saveState = (key, state, storage) =\u0026gt; { storage.setItem(key, JSON.stringify(state)); };      plugin(store)   给 vuex 使用的一个函数\n1 2 3 4 5 6 7 8 9 10 11 12 13  const vuexLocal = new VuexPersistence({ storage: window.localStorage, modules: [\u0026#34;permission\u0026#34;, \u0026#34;film\u0026#34;, \u0026#34;settings\u0026#34;], }); createStore({ // ...  plugins: [vuexLocal.plugin], }); // vuex Store: constructor \u0026gt; 安装插件 // apply plugins plugins.forEach((plugin) =\u0026gt; plugin(this));     实现:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29  // vuex 安装接口 this.plugin = (store) =\u0026gt; { const savedState = this.restoreState(this.key, this.storage); // TODO strict mode  store.replaceState(merge(store.state, savedState || {})); this.subscriber(store)((mutation, state) =\u0026gt; { if (this.filter(mutation)) { this.saveState(this.key, this.reducer(state), this.storage); } }); this.subscribed = true; }; // vuex replaceState，直接理解为替换 state 就行了 function replaceState(state) { this._withCommit(() =\u0026gt; { this._state.data = state; }); } // 订阅啥？ this.subscriber(store)((mutation: MutationPayload, state: S) =\u0026gt; { if (this.filter(mutation)) { this.saveState(this.key, this.reducer(state), this.storage); } });      subscriber(store)  1 2 3  const subscriber = (store: Store\u0026lt;S\u0026gt;) =\u0026gt; ( handler: (mutation: MutationPayload, state: S) =\u0026gt; any ) =\u0026gt; store.subscribe(handler);     vuex subscribe:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28  function subscribe(fn, options) { return genericSubscribe(fn, this._subscribers, options); } function genericSubscribe(fn, subs, options) { if (subs.indexOf(fn) \u0026lt; 0) { options \u0026amp;\u0026amp; options.prepend ? subs.unshift(fn) : subs.push(fn); } return () =\u0026gt; { const i = subs.indexOf(fn); if (i \u0026gt; -1) { subs.splice(i, 1); } }; } // commit function commit(_type, _payload, _options) { // ... 省略 commit mutation 操作  // 注意看这里，说明每次 commit mutation 操作  // 更新 state 的时候都会执行  this._subscribers .slice() // shallow copy to prevent iterator invalidation if subscriber synchronously calls unsubscribe  .forEach((sub) =\u0026gt; sub(mutation, this.state)); // ... warn }     有了上面的 vuex 源码部分，再来看这 vuex-persist 的 subscribe 干了啥\n1 2 3 4 5 6  // 订阅啥？ this.subscriber(store)((mutation: MutationPayload, state: S) =\u0026gt; { if (this.filter(mutation)) { this.saveState(this.key, this.reducer(state), this.storage); } });     这里等于是给 vuex this._subscribers 注入了一个函数，这个函数会在每次 vuex commit mutation 的时候去执行来更新 store 里面的 state。\n1 2 3  this.saveState = (key, state, storage) =\u0026gt; { storage.setItem(key, JSON.stringify(state)); };      modules   支持多模块 - 对应了 vuex 的 modules。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27  this.reducer = options.reducer != null ? options.reducer : options.modules == null ? (state: S) =\u0026gt; state : (state: any) =\u0026gt; (options!.modules as string[]).reduce( (a, i) =\u0026gt; merge(a, { [i]: state[i] }, this.mergeOption), { /* start empty accumulator*/ } ); // 使用：当 commit mutation 状态更新，根据是不是有 modules // 调用 recuder 决定如何存储，比如： modules [a, b] // 存储的时候 localStorage = { a: xxx, b: xxx } // 如果没有 modules ，默认用的是 key : \u0026#39;vuex\u0026#39; // 所以 localStorage = { vuex: xxx } this.subscriber(store)((mutation: MutationPayload, state: S) =\u0026gt; { if (this.filter(mutation)) { this._mutex.enqueue( this.saveState(this.key, this.reducer(state), this.storage) as Promise\u0026lt; void \u0026gt; ); } });        queue 队列   一个简单的队列刷新类：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29  function SimplePromiseQueue() { this._queue = [] this._flushing = false } const SPQ = SimplePromiseQueue const SPGP = SimplePromiseQueue.prototype // 入列，如果没有任务正在执行，立即 flush SPGP.enqueue = function enqueue(promise) { this._queue.push(promise) if (!this._flushing) return this.flushQueue() return Promise.resolve() } SPGP.flushQueue = function flushQueue() { this._flushing = true const chain = () =\u0026gt; { const nextTask = this._queue.shift() // 先进先出  if (nextTask) { // 递归，flush 所有任务  return nextTask.then(chain) } this._flushing = false } return Promise.resolve(chain()) }     任务入列的时候，会检测队列是不是正在刷新，如果是只执行入列操作，这里返回一个 Promise.resolve() 方便后面任务的依次进行。\n flushQueue() 将出列行为封装成一个函数，来达到所有任务按入列顺序执行。\n  ","permalink":"https://www.cheng92.com/vue/vue-vuex-persist/","tags":["vue,","vuex,","store,","persist"],"title":"Vue Vuex Persist Store(数据持久化) - 简化版"},{"categories":["web"],"contents":"    insertCssLink(\"https://unpkg.com/element-plus/lib/theme-chalk/index.css\"); insertCssLink(\"/js/vue/css/awesome.css\");     此文初衷，有时候去找一些库的时候，第一反应就是 awesome-xxx~， 比如： ~awesome-emacs, awesome-nodejs … ，但是这些项目基本就只有一个链接，当想决定 使用哪个的时候往往需要一个个点开去对比下星级和提交记录。\n  此文就是为了方便查看库的星级和 build status 而产生。\n  文中表格的实现基于 vue-next + element-plus\n  鼠标放在英文简介上面会出现中文翻译（自己+google翻译的仅供参考）。\n  鼠标放到表中名称链接上面会展示预览图或GIF动画(部分有)\n  描述前面如果有一个链接说明这个库有自己的文档网站\n   Tools    Shields.io: Quality metadata badges for open source projects\n 生成 github 图标的.\n    React Native      JavaScript   JavaScript 相关的库(比如：数字，日期，字符串，货币转换操作等)。\nURL      Number        Node.js  Logging 日志功能      Command-line utilities 命令行工具        stylelint      ","permalink":"https://www.cheng92.com/web/awesome-web/","tags":["nodejs,","web,","javascript,","typescript"],"title":"Awesome Web Development(WEB开发资源)"},{"categories":["vscode"],"contents":"  当前使用的 Doom-Emacs，但是在进行 vue 开发过程中总会遇到一些问题，用起来并不是很 丝滑！！！ 故。。。。。\n [2021-04-25 20:58:16] 习惯这东西真实难改，还是继续 Emacs 吧， 虽然 vscode 也整的 差不多了(\u0026#34;sync.gist\u0026#34;: \u0026#34;26eb4c3f161740254c0f21de867adf87\u0026#34;)。\n Settings Sync   配置上传和下载，绑定 Github \u0026amp; Gist。\n  key bindings(LeaderMode)   第一步先将按键绑定搞起来。\nSPC     key function     bookmark -   SPC b m 设置标签   SPC \u0026lt;RET\u0026gt; 列出标签      Command(⌘)     key function     \u0026lt;Command\u0026gt;    S-0 打开侧边栏并聚焦   S-b 打开/隐藏侧边栏   S-F1 打开项目Dashboard   S-\u0026#39; 引号切换(\u0026#34;\u0026#39;`)   S-shift-\\ 跳转到匹配括号     S-k Quokka, 实时调试 js/Ts   S-k j javascript   S-k t typescript   S-k q 在当前文件启动 Quokka      Emacs style     key function     C-c f 在当前目录下创建文件   C-c F 在当前目录下创建目录      vim 按键     key function     f/F ace jump，字符/单词   yw 复制光标后面的单词内容   dw 删除光标后面的单词内容        ","permalink":"https://www.cheng92.com/post/vscode-to-emacs/","tags":["vscode,","emacs"],"title":"将 VSCode 打造成 Emacs"},{"categories":["vue"],"contents":"  诗号：六道同坠，魔劫万千，引渡如来。  \n   insertCssLink(\"https://unpkg.com/element-plus/lib/theme-chalk/index.css\");     该文记录着实际开发过程中使用到的 vue3 及其生态中相关的框架或库遇到的各种问题，和 其他收集。\n 相关项目   xiaoxian521/vue-pure-admin: ✨ 🚀Vue3.0+TypeScript+Vite2.0+Element-Plus编写的一 套后台管理系统\n  vue3 + tsx   vue3+tsx环境创建及使用跳坑项-之间的个人博客\n 插件： @vitejs/plugin-vue-jsx\n vuejs/jsx-next: JSX for Vue 3\n  vue-next  template ref 使用   runtime-core ref 属性解析\u0026amp;分析\n 模板： attrs 形式使用 ref 将会绑定 elForm 。\n1 2 3  \u0026lt;templet\u0026gt; \u0026lt;el-form ref=\u0026#34;elForm\u0026#34;/\u0026gt; \u0026lt;/templet\u0026gt;     setup:\n1 2 3 4 5 6 7 8 9 10 11 12 13  defineComponent({ setup(props, ctx) { // 声明 element ref 变量  const elForm = ref(null) // 使用  onMounted(() =\u0026gt; { elForm.value.validate(/* bala bala... */) }) return { elForm } } })     注意点：\n  ref=\u0026#34;elForm\u0026#34; 不能使用 v-bind:ref 只能是 attrs\n  使用时 elForm.value 因为它是个 Ref 类型\n      vue-router-next   vuejs/vue-router-next: The Vue 3 official router\n  vuex   vuejs/vuex at 4.0\n Installation | Vuex\n使用   creation:\n1 2 3 4 5 6 7 8 9 10  import { createStore } from \u0026#34;vuex\u0026#34;; import permission from \u0026#34;./modules/permission\u0026#34;; const store = createStore({ modules: { permission, }, }); export default store;     模块： 权限菜单 (permission)\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45  // \u0026#39;./modules/permission\u0026#39; // State const state: PermissionState = { asyncMenus: [] as MenuItem[], minorRoutes: [] as RouteConfigRecord[], get mountedRoutes(): RouteConfigRecord[] { // TODO 根据当前用户从服务器获取权限菜单，跟新到 asyncMenus 中  // 根据过滤后的结果进行渲染  return toBeMounted; }, }; // mutation 不可直接调用的，必须通过 commit(SET_MENUS) 来调用 // 更新状态 const mutations = { [SET_MENUS](state: PermissionState, menus: MenuItem[]): void { state.asyncMenus = menus; }, [SET_MINOR_ROUTES](state: PermissionState, routes: RouteConfigRecord[]) { state.minorRoutes = routes; }, }; // action 组件中可通过 store.dispatch(\u0026#39;permission/getMenus\u0026#39;) 来触发 // 对应的 action, 注意这里如果是模块化需要加上 \u0026#39;permission/\u0026#39; const actions = { async getMenus({ commit }: ActionContext) { if (state.asyncMenus.length) { return state.asyncMenus; } const res = await getMenuList(); commit(SET_MENUS, res.data); return res.data; }, }; // 最后将结果导出，形成一个 store 模块 permission export default { state, mutations, actions, namespaced: true, };      数据持久化   vuex-persist 数据持久化，源码简析\n  疑难杂症  state: get mountedRoutes 没有触发？   问题缘由:\n  getMenus 从服务端请求权控菜单\n1 2 3 4 5 6 7 8 9 10 11 12  const actions: ActionTree\u0026lt;PermissionState, RootState\u0026gt; = { async getMenus({ commit, state }: ActionContext\u0026lt;PermissionState, RootState\u0026gt;) { if (state.asyncMenus.length) { return state.asyncMenus; } const res = await getMenuList(); commit(SET_MENUS, res.data); console.log(state.mountedRoutes, \u0026#34;xxx\u0026#34;); return res.data; }, };      state: get mountedRoutes()\n 然后，希望在之后取 mountedRoutes 的时候能从 asyncMenus 中过滤出特定权限的路由， 但是貌似这个 getter 怎么都没执行，因为里面的 console.log 并没有打印出来。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  const state = { get mountedRoutes(): RouteConfigRecord[] { console.log(this.asyncMenus, asyncRoutes, \u0026#34;0000\u0026#34;); const toBeMounted = filterRoutesByMenu(asyncRoutes, this.asyncMenus); toBeMounted.forEach((r: RouteConfigRecord) =\u0026gt; { if (r.children \u0026amp;\u0026amp; r.children.length \u0026amp;\u0026amp; r.meta!.showInMenu) { const menuRoutes = r.children.filter((child) =\u0026gt; child.meta!.showInMenu); if (menuRoutes.length) { r.redirect = menuRoutes[0].path; } } }); return toBeMounted; }, };       ❗ 在 vue3 中响应式通过 Proxy + Reflect 来实现的，去 get mountedRoutes 最后执行的是 Reflect.get(state, \u0026#39;mountedRoutes\u0026#39;, ...) 这底层估计不会去访问 getter 访问器， 才导致不生效。\n  解决方案(折中方案)：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37  const state: PermissionState = { asyncMenus: [] as MenuItem[], minorRoutes: [] as RouteConfigRecord[], // ADD1 不使用 getter  mountedRoutes: [] as RouteConfigRecord[] } const mutations: MutationTree\u0026lt;PermissionState\u0026gt; = { // ADD2 增加一个 mutation 去更新路由列表  [SET_MOUNTED_ROUTES](state: PermissionState) { const menus: MenuItem[] = state.asyncMenus const toBeMounted = filterRoutesByMenu(asyncRoutes, menus) toBeMounted.forEach((r: RouteConfigRecord) =\u0026gt; { if (r.children?.length \u0026amp;\u0026amp; r.meta?.showInMenu) { const menuRoutes = r.children.filter((child) =\u0026gt; child.meta!.showInMenu) if (menuRoutes.length) { r.redirect = menuRoutes[0].path } } }) state.mountedRoutes = toBeMounted } } const actions: ActionTree\u0026lt;PermissionState, RootState\u0026gt; = { async getMenus({ commit, state }: ActionContext\u0026lt;PermissionState, RootState\u0026gt;) { if (state.asyncMenus.length) { return state.asyncMenus } const res = await getMenuList() commit(SET_MENUS, res.data) // ADD3 这里当更新菜单的时候同步过滤出有效路由  commit(SET_MOUNTED_ROUTES) return res.data }, }     结果：\n1 2 3 4  [[Target]]: Object asyncMenus: (4) [{…}, {…}, {…}, {…}] minorRoutes: [] mountedRoutes: (4) [{…}, {…}, {…}, {…}]          vue-i18n-next   intlify/vue-i18n-next: Vue I18n for Vue 3\n Docs: Installation | Vue I18n\n Usage： Vue i18n: Building a multi-lingual app - Lokalise Blog\n  vue-i18n esm-bundler 警告\n You are running the esm-bundler build of vue-i18n. It is recommended to configure your bundler to explicitly replace feature flag globals with boolean literals to get proper tree-shaking in the final bundle.\n  fix：解决vue-i18n在开发环境下的告警 · xiaoxian521/vue-pure-admin@f2db3ac\n1 2 3 4  alias: { \u0026#34;@\u0026#34;: path.resolve(__dirname, \u0026#34;./src\u0026#34;), + \u0026#34;vue-i18n\u0026#34;: \u0026#34;vue-i18n/dist/vue-i18n.cjs.js\u0026#34;, };         element-plus  el-upload   使用(不自动上传)：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24  export function GlUpload(props, { slots }) { return h( E.ElUpload, _.extend( { class: \u0026#34;upload\u0026#34;, action: \u0026#34;#\u0026#34;, \u0026#34;list-type\u0026#34;: \u0026#34;picture-card\u0026#34;, \u0026#34;auto-upload\u0026#34;: false, onChange(file, fileList) { console.log(file, fileList, \u0026#34;xx\u0026#34;); }, }, props ), { default: () =\u0026gt; h(\u0026#34;i\u0026#34;, { class: \u0026#34;el-icon-plus\u0026#34;, }), ...slots, } ); }    TIP\n 不使用自动上传功能的时候，如果要向服务器发送数据，需要自己将数据变成表单 (FormData)数据，有点绕。\n  这里有个插件可以使用，将 json 转成 FormData: hyperatom/json-form-data: A library to convert javascript objects into form data.\n 看了下源码(140l) 实现原理中就是深度遍历 json 数据，需要注意的是对象类型的转换。\n1 2 3 4 5 6 7 8 9  如：{a:{b:1},{c:{d:2}}} -\u0026gt; a[b]: 1 -\u0026gt; a[c][d]:2 如： {a: [1,2,3,4]} -\u0026gt; a[0]:1 -\u0026gt; a[1]:2 -\u0026gt; a[2]:3 -\u0026gt; a[3]:4     实例：\npageId: 17 name: test5 status: 1 isDefault: 0 startTime: 2021-11-10 10:10 endTime: 2021-11-11 10:10 isPermanent: 0 targetType: 1 templateType: epg21 target[0]: 1001 target[1]: 1002 target[2]: 1003 target[3]: 1004 target[4]: 1005 target[5]: 1006 target[6]: 1007 target[7]: 1010 target[8]: 121 target[9]: 188 target[10]: 2001 target[11]: 2308 target[12]: 666 target[13]: 833 target[14]: 8513 hasBgPic: 1 hasBgMedia: 0 hasLogo: 0 hasSmallPic: 0 hasPicList: 1 hasWifi: 0 hasWeather: 0 hasWelcomeText: 1 welcomeText: [] IsPermanent: 0   即需要进行扁平化处理，将所有的嵌套转成路径方式 a[b][c][d][e]:1 等于是：\n { a: { b: { c: { d: { e:1 } } } } }\n  el-table index 全部为 0 问题   [bug report] El table column type = \u0026#34;index\u0026#34; error after using row key attribute in El table · Issue #2143 · element-plus/element-plus\n    ","permalink":"https://www.cheng92.com/vue/vue-project-ecosystem/","tags":["vue,","vue3,","vue-router,","vuex,","i18n"],"title":"Vue3 开发生态链(vuex, vue-router, ...)"},{"categories":["vue"],"contents":"  诗号：六道同坠，魔劫万千，引渡如来。  \n  --  insertCssLink(\"https://unpkg.com/element-plus/lib/theme-chalk/index.css\");     buffer  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27  export function createBuffer() { let appendable = false const buffer: SSRBuffer = [] return { getBuffer(): SSRBuffer { // Return static buffer and await on items during unroll stage  return buffer }, push(item: SSRBufferItem) { const isStringItem = isString(item) if (appendable \u0026amp;\u0026amp; isStringItem) { buffer[buffer.length - 1] += item as string } else { buffer.push(item) } appendable = isStringItem if (isPromise(item) || (isArray(item) \u0026amp;\u0026amp; item.hasAsync)) { // promise, or child buffer with async, mark as async.  // this allows skipping unnecessary await ticks during unroll stage  // 标记为异步 buffer  buffer.hasAsync = true } } } }      ","permalink":"https://www.cheng92.com/vue/vue-mind-map-server-renderer/","tags":["vue,","vue3,","server-renderer,","ssr"],"title":"Vue3 源码头脑风暴之 9 ☞ server-renderer"},{"categories":["vue"],"contents":"  诗号：六道同坠，魔劫万千，引渡如来。  \n  --  insertCssLink(\"https://unpkg.com/element-plus/lib/theme-chalk/index.css\");       stb-vue-next 完全拷贝于 vue-next ，主要目的用于学习。 \n 运行时的 DOM 操作。\n patch props  class  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22  export const patchProp: DOMRendererOptions[\u0026#39;patchProp\u0026#39;] = ( el, key, prevValue, nextValue, isSVG = false, prevChildren, parentComponent, parentSuspense, unmountChildren ) =\u0026gt; { switch (key) { // 特殊属性  case \u0026#39;class\u0026#39;: patchClass(el, nextValue, isSVG) break case \u0026#39;style\u0026#39;: break default: break } }     class patch 操作:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19  export function patchClass(el: Element, value: string | null, isSVG: boolean) { if (value == null) { value = \u0026#34;\u0026#34;; } if (isSVG) { el.setAttribute(\u0026#34;class\u0026#34;, value); } else { const transitionClasses = (el as any) /* TODO ElementWithTransition */._vtc; if (transitionClasses) { // 合并类名  value = (value ? [value, ...transitionClasses] : [...transitionClasses] ).join(\u0026#34;\u0026#34;); } el.className = value; } }    (function() { const { render, h, patchProp } = VueRuntimeDOM const el = document.createElement('div') patchProp(el, 'class', null, 'foo') console.log(el.className, el.outerHTML, '\\nafter') patchProp(el, 'class', null, null) console.log(el.className, el.outerHTML) }())   insertPreCode('x6c22Ir')   输出结果：\nfoo \u0026lt;div class=\u0026#34;foo\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; after \u0026lt;div class=\u0026#34;\u0026#34;\u0026gt;\u0026lt;/div\u0026gt;    style   feat(add): runtime-dom, patch props style · gcclll/stb-vue-next@50468d8\n 源码:\n  删除操作(next 为空的时候)\n  如果是字符串直接替换 cssText\n  如果是对象，将遍历所有属性重新设值，新有旧没有执行删除\n 比如：\n old = { color: \u0026#39;red\u0026#39;, \u0026#39;font-size\u0026#39;: \u0026#39;32px\u0026#39; }\n next = { color: \u0026#39;blue\u0026#39; }\n 那么最终字体颜色会变成 blue ，字体大小被重置为默认大小。\n  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28  export function patchStyle(el: Element, prev: Style, next: Style) { const style = (el as HTMLElement).style if (!next) { // 删除操作  el.removeAttribute(\u0026#39;style\u0026#39;) } else if (isString(next)) { // 更新操作，全替换操作  if (prev !== next) { style.cssText = next } } else { // 如果是对象，根据对象内的属性逐个进行更新  for (const key in next) { // 更新单个值  setStyle(style, key, next[key]) } if (prev \u0026amp;\u0026amp; !isString(prev)) { // 删除老的不在 next 中的值  for (const key in prev) { if (next[key] == null) { setStyle(style, key, \u0026#39;\u0026#39;) } } } } }     setStyle 代码：\n  支持对同一个属性设置不同的值，等于是取最后的那个值\n 如： color:red 设值 [\u0026#39;blue\u0026#39;, \u0026#39;black\u0026#39;, \u0026#39;red\u0026#39;] 最后还是 red\n  支持 --webkit-xxx 前缀设置\n  自动添加 webkit, moz, ms 前缀\n  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30  function setStyle( style: CSSStyleDeclaration, name: string, val: string | string[] ) { if (isArray(val)) { // 同一个属性设置多个值？取最后一个有效值  val.forEach(v =\u0026gt; setStyle(style, name, v)) } else { // 多浏览器的兼容处理，如： --webkit-...  if (name.startsWith(\u0026#39;--\u0026#39;)) { // custom property definition  style.setProperty(name, val) } else { // 自动添加前缀  const prefixed = autoPrefix(style, name) if (importantRE.test(val)) { // 优先级最高的处理  // !important  style.setProperty( hyphenate(prefixed), val.replace(importantRE, \u0026#39;\u0026#39;), \u0026#39;important\u0026#39; ) } else { style[prefixed as any] = val } } } }     添加前缀(WebKit, Mox, ms)：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22  const prefixes = [\u0026#39;Webkit\u0026#39;, \u0026#39;Moz\u0026#39;, \u0026#39;ms\u0026#39;] const prefixCache: Record\u0026lt;string, string\u0026gt; = {} // 自动添加前缀处理 function autoPrefix(style: CSSStyleDeclaration, rawName: string): string { const cached = prefixCache[rawName] if (cached) { return cached } let name = camelize(rawName) if (name !== \u0026#39;filter\u0026#39; \u0026amp;\u0026amp; name in style) { return (prefixCache[rawName] = name) } name = capitalize(name) for (let i = 0; i \u0026lt; prefixes.length; i++) { const prefixed = prefixes[i] + name if (prefixed in style) { return (prefixCache[rawName] = prefixed) } } return rawName }     测试代码和结果：\n  点击查看测试源码   onXxx   feat(add): runtime-dom event prop · gcclll/stb-vue-next@3402f03\n 源码：\n  prevValue 已经绑定到 el 上的一个事件句柄\n  nextValue 新的事件句柄，如果两者同时存在是会进行替换\n  rawName 事件名称，如： onClick\n  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26  export function patchEvent( el: Element \u0026amp; { _vei?: Record\u0026lt;string, Invoker | undefined\u0026gt; }, rawName: string, prevValue: EventValue | null, nextValue: EventValue | null, instance: ComponentInternalInstance | null = null ) { // vue event invokers  const invokers = el._vei || (el._vei = {}) const existingInvoker = invokers[rawName] if (nextValue \u0026amp;\u0026amp; existingInvoker) { // patch  existingInvoker.value = nextValue } else { const [name, options] = parseName(rawName) if (nextValue) { // add 添加事件  const invoker = (invokers[rawName] = createInvoker(nextValue, instance)) addEventListener(el, name, invoker, options) } else if (existingInvoker) { // remove 删除事件  removeEventListener(el, name, existingInvoker, options) invokers[rawName] = undefined } } }     上面主要有几个步骤:\n  如果已经存在的事件句柄直接更新 exisitingInvoker.value 的值\n  解析事件名称主要是解析出 Once|Passive|Capture 三个事件修饰符\n 如：\n onClick =\u0026gt; [\u0026#39;click\u0026#39;, {}]\n onClickOnce =\u0026gt; [\u0026#39;click\u0026#39;, {once: true}]\n onClickOnceCapture =\u0026gt; [\u0026#39;click\u0026#39;, {once: true, capture: true}]\n  添加事件 patchProp(el, \u0026#39;onClick\u0026#39;, null, fn)\n  删除事件 patchProp(el, \u0026#39;onClick\u0026#39;, oldFn|null, null)\n 当 newFn 传空值时，等于是删除该元素上绑定的 \u0026#39;onclick\u0026#39; 事件句柄。\n   事件名解析:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  // 解析事件名 onClick -\u0026gt; [\u0026#39;click\u0026#39;] // onClickOnce -\u0026gt; [\u0026#39;click\u0026#39;, { once: true }] // onClickOncePassive -\u0026gt; [\u0026#39;click\u0026#39;, { once: true, passive: true }] function parseName(name: string): [string, EventListenerOptions | undefined] { let options: EventListenerOptions | undefined if (optionsModifierRE.test(name)) { options = {} let m while ((m = name.match(optionsModifierRE))) { name = name.slice(0, name.length - m[0].length) ;(options as any)[m[0].toLowerCase()] = true options } } return [name.slice(2).toLowerCase(), options] }     invoker: 这个封装的重点在于当绑定事件的时候，记录绑定时的时间戳，然后在执行的时 候去比较“当前触发的事件的事件戳(e.timeStamp)” 和 “事件句柄绑定时的时间戳”，只要 前者比后者大就说明可以执行事件句柄了(说实话，这里并没有很懂！！！)。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25  function createInvoker( initialValue: EventValue, instance: ComponentInternalInstance | null ) { const invoker: Invoker = (e: Event) =\u0026gt; { // 异步边缘情况：内部点击事件触发 patch ，事件  // 句柄在 patch 阶段绑定在 outer element 上，  // 然后会被再次触发，这种情况的发生原因是浏览器在事件  // 冒泡期间触发了微任务时钟(microtask ticks)  // 解决方案：保存事件句柄被绑定瞬间的时间戳(timestamp)  // 然后事件句柄只有在“已保存的时间戳之后触发的事件”上去执行  const timeStamp = e.timeStamp || _getNow() if (timeStamp \u0026gt;= invoker.attached - 1) { callWithAsyncErrorHandling( patchStopImmediatePropagation(e, invoker.value), instance, ErrorCodes.NATIVE_EVENT_HANDLER, [e] ) } } invoker.value = initialValue invoker.attached = getNow() return invoker }     另外事件句柄执行又是进行了一次封装的(patchStopImmediatePropagation())，那这个 函数是做什么用的呢？\n 我们都知道一个元素是可以在一个事件名下绑定多个事件句柄的，当这个事件触发的时候会 自动执行所有绑定的事件句柄。\n Event.stopImmediatePropagation() - Web APIs | MDN\n Event.stopImmediatePropagation() The stopImmediatePropagation() method of the Event interface prevents other listeners of the same event from being called.\n 这段意思是说 stopImmediatePropagation() 会阻止其他 listeners 继续执行。\n If several listeners are attached to the same element for the same event type, they are called in the order in which they were added. If stopImmediatePropagation() is invoked during one such call, no remaining listeners will be called. 如果有多个 listeners 绑定到同一元素的同一事件类型上，他们会按照添加的顺序依次被 执行。如果 stopImmediatePropagation() 在任意一个 listener 执行期间被调用，那么剩 余的 listeners 就不会再被调用，也就是说在任意一个 listener 内可以控制后续的 listeners 是否会被执行。\n  再来看 patchStopImmediatePropagation() 源码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21  function patchStopImmediatePropagation( e: Event, value: EventValue ): EventValue { if (isArray(value)) { const originalStop = e.stopImmediatePropagation; // 这里对事件的 stopImmediatePropagation 进行了二次封装  e.stopImmediatePropagation = () =\u0026gt; { originalStop.call(e); // 加入了一个标识  (e as any)._stopped = true; }; // 这里又对所有的 listeners 进行了二次封装  // 即如果 _stopped 是假值的情况下才调用 listener  // 意思就是结合 stopImmediatePropagation 这里做了手动管理  return value.map((fn) =\u0026gt; (e: Event) =\u0026gt; !(e as any)._stopped \u0026amp;\u0026amp; fn(e)); } else { return value; } }     ❓ 初想会不会觉得多此一举 ❓\n  那么我们将关键的代码放一起来看看：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17  // patchEvent const invokers = el._vei || (el._vei = {}); const existingInvoker = invokers[rawName]; if (nextValue \u0026amp;\u0026amp; existingInvoker) { // patch  existingInvoker.value = nextValue; } // createInvoker -\u0026gt; invoker if (timeStamp \u0026gt;= invoker.attached - 1) { callWithAsyncErrorHandling( patchStopImmediatePropagation(e, invoker.value), instance, ErrorCodes.NATIVE_EVENT_HANDLER, [e] ); }     一个元素上不同 name 的事件都会保存到 DOM 元素的 el._vei上面，也就是说下次注册事 件的时候会直接从这里取出 invoker，直接更新invoker.value 而不是重新创建了一个函数 来接受这个事件句柄\n 比如：\n 普通使用情况:\n el.addEventListener(\u0026#39;click\u0026#39;, fn1)\n el.addEventListener(\u0026#39;click\u0026#39;, fn2)\n 那么在 el 上会有两个句柄 fn1, fn2\n 使用patchEvent:\n patchEvent(el, \u0026#39;click\u0026#39;, null, fn1)\n patchEvent(el, \u0026#39;click\u0026#39;, null,fn2)\n 这里实际上并没有添加两个句柄 fn1, fn2 而是等于 fn1 = fn2 覆盖了此时 fn1 其实 已经不存在了，并且此时绑定在 el 上的 click 事件的句柄就永远是第一次注册 fn1 时创 建的那个 invoker (除非执行 patchEvent(el, \u0026#39;click\u0026#39;, null, null) 删除了这个 invoker)\n 那如何实现一个元素一个事件绑定多个句柄呢？\n 这样: patchEvent(el, \u0026#39;click\u0026#39;, null, [fn1, fn2])\n 因为在 vue 中绑定的事件句柄最后都会被解析到一个数组中。\n 正如上面分析的结果，也就是说 patchEvent() 永远只会在 el 上对于同名事件注册一个 句柄 invoker，那么 event.stopImmediatePropagation() 在这里实际没有什么作用，它 实际并不能控制 invoker.value 中真正的事件句柄执行。\n 所以就有了 patchStopImmediatePropagation() 函数的封装，来变相实现 stopImmediatePropagation 对真正事件句柄的控制。\n 测试：\n  点击查看测试源码   props   一个函数处理几种情况，主要处理的是DOM元素上的一些内置属性\n  innerHTML 或 textContent\n 直接复制操作， el[key] = value || \u0026#39;\u0026#39; , 如果有 children 全部卸载掉。\n  key=value 且标签非 PROGRESS\n el._value = value 保存原始值，这种针对有 value 的元素，比如： \u0026lt;input/\u0026gt;\n  空值处理或真值处理(如： \u0026lt;select multiple\u0026gt;)\n boolean 处理成 true, string 处理成 \u0026#39;\u0026#39;, number 处理成 0 。\n  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65  // functions. The user is responsible for using them with only trusted content. export function patchDOMProp( el: any, key: string, value: any, // the following args are passed only due to potential innerHTML/textContent  // overriding existing VNodes, in which case the old tree must be properly  // unmounted.  prevChildren: any, parentComponent: any, parentSuspense: any, unmountChildren: any ) { if (key === \u0026#34;innerHTML\u0026#34; || key === \u0026#34;textContent\u0026#34;) { if (prevChildren) { unmountChildren(prevChildren, parentComponent, parentSuspense); } el[key] = value == null ? \u0026#34;\u0026#34; : value; return; } if (key === \u0026#34;value\u0026#34; \u0026amp;\u0026amp; el.tagName !== \u0026#34;PROGRESS\u0026#34;) { // store value as _value as well since  // non-string values will be stringified.  el._value = value; const newValue = value == null ? \u0026#34;\u0026#34; : value; if (el.value !== newValue) { el.value = newValue; } return; } // 空值处理  if (value === \u0026#34;\u0026#34; || value == null) { const type = typeof el[key]; if (value === \u0026#34;\u0026#34; \u0026amp;\u0026amp; type === \u0026#34;boolean\u0026#34;) { // 比如： \u0026lt;select multiple\u0026gt; 编译成： { multiple: \u0026#39;\u0026#39; }  el[key] = true; return; } else if (value == null \u0026amp;\u0026amp; type === \u0026#34;string\u0026#34;) { // 如： \u0026lt;div :id=\u0026#34;null\u0026#34;\u0026gt;  el[key] = \u0026#34;\u0026#34;; el.removeAttribute(key); return; } else if (type === \u0026#34;number\u0026#34;) { // 如： \u0026lt;img :width=\u0026#34;null\u0026#34;\u0026gt;  el[key] = 0; el.removeAttribute(key); return; } } // some properties perform value validation and throw  try { el[key] = value; } catch (e) { if (__DEV__) { warn( `Failed setting prop \u0026#34;${key}\u0026#34; on \u0026lt;${el.tagName.toLowerCase()}\u0026gt;: ` + `value ${value}is invalid.`, e ); } } }     测试：\n  点击查看测试源码   true/false-value   feat(add): runtime-dom patch v-model · gcclll/stb-vue-next@580b0f3\n true-value \u0026amp; false-value 属性在 compiler-ssr 中有详细分析，主要用于 SSR 下的 \u0026lt;input type=\u0026#34;checkbox\u0026#34;\u0026gt; 的时候。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42  // patchProp.ts // special case for \u0026lt;input v-model type=\u0026#34;checkbox\u0026#34;\u0026gt; with // :true-value \u0026amp; :false-value // store value as dom properties since non-string values will be // stringified. if (key === \u0026#34;true-value\u0026#34;) { (el as any)._trueValue = nextValue; } else if (key === \u0026#34;false-value\u0026#34;) { (el as any)._falseValue = nextValue; } patchAttr(el, key, nextValue, isSVG); // modules/attrs.ts export const xlinkNS = \u0026#34;http://www.w3.org/1999/xlink\u0026#34;; export function patchAttr( el: Element, key: string, value: any, isSVG: boolean ) { if (isSVG \u0026amp;\u0026amp; key.startsWith(\u0026#34;xlink:\u0026#34;)) { if (value == null) { el.removeAttributeNS(xlinkNS, key.slice(6, key.length)); } else { el.setAttributeNS(xlinkNS, key, value); } } else { // note we are only checking boolean attributes that don\u0026#39;t have a  // corresponding dom prop of the same name here.  const isBoolean = isSpecialBooleanAttr(key); if (value == null || (isBoolean \u0026amp;\u0026amp; value === false)) { el.removeAttribute(key); } else { el.setAttribute(key, isBoolean ? \u0026#34;\u0026#34; : value); } } } // shared/src/domAttrConfig.ts const specialBooleanAttrs = `itemscope,allowfullscreen,formnovalidate,ismap,nomodule,novalidate,readonly`; export const isSpecialBooleanAttr = /*#__PURE__*/ makeMap(specialBooleanAttrs);     测试：\n  点击查看测试源码     nodeOps   DOM 操作接口。\n feat(add): nodeOps · gcclll/stb-vue-next@88b8bda\n   接口名 描述 原生接口     insert(child, parent, anchor) 在 anchor 前面插入 child parent.insertBefore(child, anchor)   remove(child) 删除某个子元素 child.parentNode.removeChild(child)   createElement(tag, isSVG, is) 创建元素(svg或普通元素) document.createElement   createText(text) 创建文本节点 document.createTextNode(text)   createComment(text) 创建注释节点 document.createComment(text)   setText(node, text) 设置节点文本内容 node.nodeValue = text   setElementText(el, text) 设置 textContent el.textContent   parentNode(node) 取父元素 node.parentNode   nextSibling(node) 取后面的兄弟节点 node.nextSibling   querySelector(selector) 选择器查询 document.querySelector(selector)   setScopeId(el, id) 给元素增加 id 属性 el.setAttribute(id, \u0026#39;\u0026#39;)   cloneNode(el) 深度克隆元素 el.cloneNode(true)   insertStaticContent(content, parent, anchor, isSVG) 插入静态内容？ -     这个文件中就是一些对原生DOM增删改查接口的封装。\n  TODO Transition\u0026amp;Group   feat(add): Transition\u0026amp;Group · gcclll/stb-vue-next@444b0bb\n  v-on 事件   这里面主要处理的是一些修饰符处理。\n feat(add): v-on event · gcclll/stb-vue-next@9280816\n 系统修饰符(几个系统按键)：\n const systemModifiers = [\u0026#39;ctrl\u0026#39;, \u0026#39;shift\u0026#39;, \u0026#39;alt\u0026#39;, \u0026#39;meta\u0026#39;]\n 支持的事件类型(键盘、鼠标、触控)：\n type KeyedEvent = KeyboardEvent | MouseEvent | TouchEvent\n 修饰符对应在事件上的一些操作，因为修饰符最终的值体现是 boolean 值，因此这些布尔 值需要对应在具体的事件上，就需要找到事件上的对方方法去处理，比如 @click.stop 解析后的修饰符 {stop: true} 对应事件上的 e.stopPropagation() 调用，阻止事件 网上冒泡：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19  const modifierGuards: Record\u0026lt; string, (e: Event, modifiers: string[]) =\u0026gt; void | boolean \u0026gt; = { stop: (e) =\u0026gt; e.stopPropagation(), prevent: (e) =\u0026gt; e.preventDefault(), self: (e) =\u0026gt; e.target !== e.currentTarget, ctrl: (e) =\u0026gt; !(e as KeyedEvent).ctrlKey, shift: (e) =\u0026gt; !(e as KeyedEvent).shiftKey, alt: (e) =\u0026gt; !(e as KeyedEvent).altKey, meta: (e) =\u0026gt; !(e as KeyedEvent).metaKey, left: (e) =\u0026gt; \u0026#34;button\u0026#34; in e \u0026amp;\u0026amp; (e as MouseEvent).button !== 0, middle: (e) =\u0026gt; \u0026#34;button\u0026#34; in e \u0026amp;\u0026amp; (e as MouseEvent).button !== 1, right: (e) =\u0026gt; \u0026#34;button\u0026#34; in e \u0026amp;\u0026amp; (e as MouseEvent).button !== 2, exact: (e, modifiers) =\u0026gt; systemModifiers.some( (m) =\u0026gt; (e as any)[`${m}Key`] \u0026amp;\u0026amp; !modifiers.includes(m) ), };     最后根据修饰符守卫，将事件函数进一步封装，在执行这个函数之前执行修饰符对应的事件 处理：\n1 2 3 4 5 6 7 8 9 10 11 12  /** * @private */ export const withModifiers = (fn: Function, modifiers: string[]) =\u0026gt; { return (event: Event, ...args: unknown[]) =\u0026gt; { for (let i = 0; i \u0026lt; modifiers.length; i++) { const guard = modifierGuards[modifiers[i]] if (guard \u0026amp;\u0026amp; guard(event, modifiers)) return } return fn(event, ...args) } }     vue2.x 上的一些兼容按键：\n1 2 3 4 5 6 7 8 9 10 11  // Kept for 2.x compat. // Note: IE11 compat for `spacebar` and `del` is removed for now. const keyNames: Record\u0026lt;string, string | string[]\u0026gt; = { esc: \u0026#39;escape\u0026#39;, space: \u0026#39; \u0026#39;, up: \u0026#39;arrow-up\u0026#39;, left: \u0026#39;arrow-left\u0026#39;, right: \u0026#39;arrow-right\u0026#39;, down: \u0026#39;arrow-down\u0026#39;, delete: \u0026#39;backspace\u0026#39; }     以及对应的封装函数:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  /** * @private */ export const withKeys = (fn: Function, modifiers: string[]) =\u0026gt; { return (event: KeyboardEvent) =\u0026gt; { if (!(\u0026#39;key\u0026#39; in event)) return const eventKey = hyphenate(event.key) if ( // None of the provided key modifiers match the current event key  !modifiers.some(k =\u0026gt; k === eventKey || keyNames[k] === eventKey) ) { return } return fn(event) } }      v-show 处理   这里处理也很简单，一个是检测有没 \u0026lt;transition\u0026gt; 没有直接使用原生的 display 属 性。\n feat(add): v-show · gcclll/stb-vue-next@be2fd29\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44  // 生命周期处理 export const vShow: ObjectDirective\u0026lt;VShowElement\u0026gt; = { beforeMount(el, { value }, { transition }) { // 在加载之前检测检测是不是有 transition 动画  el._vod = el.style.display === \u0026#39;none\u0026#39; ? \u0026#39;\u0026#39; : el.style.display if (transition \u0026amp;\u0026amp; value) { transition.beforeEnter(el) } else { setDisplay(el, value) } }, mounted(el, { value }, { transition }) { if (transition \u0026amp;\u0026amp; value) { transition.enter(el) } }, updated(el, { value, oldValue }, { transition }) { if (transition \u0026amp;\u0026amp; value !== oldValue) { if (value) { transition.beforeEnter(el) setDisplay(el, true) transition.enter(el) } else { transition.leave(el, () =\u0026gt; { setDisplay(el, false) }) } } else { setDisplay(el, value) } }, beforeUnmount(el, { value }) { setDisplay(el, value) } } if (__NODE_JS__) { vShow.getSSRProps = ({ value }) =\u0026gt; { if (!value) { return { style: { display: \u0026#39;none\u0026#39; } } } } }     实现隐藏和显示:\n1 2 3 4 5  // 因为可能是 block 或者 inline-block 所以用 _vod 来记录 // 隐藏之前的 display 值，方便后面复原 function setDisplay(el: VShowElement, value: unknown): void { el.style.display = value ? el._vod : \u0026#34;none\u0026#34;; }      v-model 处理   feat(add): v-model · gcclll/stb-vue-next@5597055\n 四种类型 + 动态类型：\n  vModelText, \u0026lt;input type=\u0026#34;text\u0026#34; /\u0026gt;, 文本输入框\n created(), 监听事件 change(lazy?) 或 input\n mounted(), 修改 el.value 值，让结果体现出来\n beforeUpdate(), 在更新之前对值进行处理，比如： trim 修饰符去掉前后空格\n  vModelCheckbox, \u0026lt;input type=\u0026#34;checkbox\u0026#34; checked/\u0026gt;, 复选框\n created(), 监听 change 事件，初始元素值\n mounted(), setChecked, 更新值， value 可以是数组，集合，单个值\n beforeUpdate(), setChecked, 同上\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  function setChecked( el: HTMLInputElement, { value, oldValue }: DirectiveBinding, vnode: VNode ) { // store the v-model value on the element so it can be accessed by the  // change listener.  (el as any)._modelValue = value; if (isArray(value)) { el.checked = looseIndexOf(value, vnode.props!.value) \u0026gt; -1; } else if (isSet(value)) { el.checked = value.has(vnode.props!.value); } else if (value !== oldValue) { el.checked = looseEqual(value, getCheckboxValue(el, true)); } }     注意这里，在 compiler 阶段， checkbox 可以通过 true-value 和 false-value 来绑 定两个属性，一个是选中时绑定的变量，一个是未选中时绑定的变量\n1 2 3 4 5 6 7 8  // retrieve raw value for true-value and false-value set via :true-value or :false-value bindings function getCheckboxValue( el: HTMLInputElement \u0026amp; { _trueValue?: any; _falseValue?: any }, checked: boolean ) { const key = checked ? \u0026#34;_trueValue\u0026#34; : \u0026#34;_falseValue\u0026#34;; return key in el ? el[key] : checked; }      vModelRadio, \u0026lt;input type=\u0026#34;radio\u0026#34;\u0026gt;, 单选框\n created(), 监听 change\n beforeUpdate(), 用比较后的 boolean 值更新 el.checked 值\n  vModelSelect, \u0026lt;select\u0026gt;\u0026lt;option :value=\u0026#34;value\u0026#34;/\u0026gt;\u0026lt;/select\u0026gt;\n created(), 监听 change 事件，遍历 el.options(\u0026lt;option/\u0026gt;)，得到所有 \u0026lt;option selected\u0026gt; 组件的 selected 属性值，将值赋给实际的 option DOM 元素， 这里会检测 el.multiple 来区分是可以多选还是单选，单选只取第一个值。\n mounted(), setSelected()\n beforeUpdate(), 更新之前更新 el._assign\n updated(), 实际更新 DOM option selected 值。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22  function setSelected(el: HTMLSelectElement, value: any) { const isMultiple = el.multiple; for (let i = 0, l = el.options.length; i \u0026lt; l; i++) { const option = el.options[i]; const optionValue = getValue(option); if (isMultiple) { if (isArray(value)) { option.selected = looseIndexOf(value, optionValue) \u0026gt; -1; } else { option.selected = value.has(optionValue); } } else { if (looseEqual(getValue(option), value)) { el.selectedIndex = i; return; } } } if (!isMultiple) { el.selectedIndex = -1; } }      vModelDynamic, 标签名是动态的，只有运行期间才能决定是什么标签\n 有： \u0026lt;select\u0026gt;, \u0026lt;textarea\u0026gt;, \u0026lt;input type=\u0026#34;checkbox\u0026#34;\u0026gt;, \u0026lt;input type=\u0026#34;radio\u0026#34;\u0026gt; 最后默认为 \u0026lt;input type=\u0026#34;text\u0026#34;\u0026gt;\n 最后根据具体情况去使用 1~4 中对应类型指令。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  export const vModelDynamic: ObjectDirective\u0026lt; HTMLInputElement | HTMLSelectElement | HTMLTextAreaElement \u0026gt; = { created(el, binding, vnode) { callModelHook(el, binding, vnode, null, \u0026#34;created\u0026#34;); }, mounted(el, binding, vnode) { callModelHook(el, binding, vnode, null, \u0026#34;mounted\u0026#34;); }, beforeUpdate(el, binding, vnode, prevVNode) { callModelHook(el, binding, vnode, prevVNode, \u0026#34;beforeUpdate\u0026#34;); }, updated(el, binding, vnode, prevVNode) { callModelHook(el, binding, vnode, prevVNode, \u0026#34;updated\u0026#34;); }, };     动态决定类型：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30  function callModelHook( el: HTMLInputElement | HTMLSelectElement | HTMLTextAreaElement, binding: DirectiveBinding, vnode: VNode, prevVNode: VNode | null, hook: keyof ObjectDirective ) { let modelToUse: ObjectDirective; switch (el.tagName) { case \u0026#34;SELECT\u0026#34;: modelToUse = vModelSelect; break; case \u0026#34;TEXTAREA\u0026#34;: modelToUse = vModelText; break; default: switch (vnode.props \u0026amp;\u0026amp; vnode.props.type) { case \u0026#34;checkbox\u0026#34;: modelToUse = vModelCheckbox; break; case \u0026#34;radio\u0026#34;: modelToUse = vModelRadio; break; default: modelToUse = vModelText; } } const fn = modelToUse[hook] as DirectiveHook; fn \u0026amp;\u0026amp; fn(el, binding, vnode, prevVNode); }        useCssVars   vue SFC 文件中的 \u0026lt;style\u0026gt; 中的 v-bind(varName) 处理。\n feat(add): use css vars · gcclll/stb-vue-next@06b2291\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19  /** * Runtime helper for SFC\u0026#39;s CSS variable injection feature. * vue 文件中的样式，CSS变量注入特性， color: v-bind(fontColor) * @private */ export function useCssVars(getter: (ctx: any) =\u0026gt; Record\u0026lt;string, string\u0026gt;) { if (!__BROWSER__ \u0026amp;\u0026amp; !__TEST__) return const instance = getCurrentInstance() if (!instance) { __DEV__ \u0026amp;\u0026amp; warn(`useCssVars is called without current active component instance.`) return } const setVars = () =\u0026gt; setVarsOnVNode(instance.subTree, getter(instance.proxy!)) onMounted(() =\u0026gt; watchEffect(setVars, { flush: \u0026#39;post\u0026#39; })) onUpdated(setVars) }     给 vnode.el.style 设置自定义属性：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31  function setVarsOnVNode(vnode: VNode, vars: Record\u0026lt;string, string\u0026gt;) { if (__FEATURE_SUSPENSE__ \u0026amp;\u0026amp; vnode.shapeFlag \u0026amp; ShapeFlags.SUSPENSE) { const suspense = vnode.suspense! vnode = suspense.activeBranch! if (suspense.pendingBranch \u0026amp;\u0026amp; !suspense.isHydrating) { // 在 runtime-dom 中分析过 effects 会等到  // 异步请求完成之后并且是在 parent.effects 没有任务的情况下才会  // 执行，这里将 CSS 的处理加入到组件 effect 队列等待所以  // 异步结束再处理样式  suspense.effects.push(() =\u0026gt; { setVarsOnVNode(suspense.activeBranch!, vars) }) } } // drill down HOCs until it\u0026#39;s a non-component vnode  // 找到最内层的非组件的子树节点  while (vnode.component) { vnode = vnode.component.subTree } if (vnode.shapeFlag \u0026amp; ShapeFlags.ELEMENT \u0026amp;\u0026amp; vnode.el) { const style = vnode.el.style for (const key in vars) { style.setProperty(`--${key}`, vars[key]) } } else if (vnode.type === Fragment) { // 如果是个占位 fragment 直接给 children 设置  ;(vnode.children as VNode[]).forEach(c =\u0026gt; setVarsOnVNode(c, vars)) } }      useCssModule   feat(add): use css module · gcclll/stb-vue-next@2d47ce0\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27  export function useCssModule(name = \u0026#34;$style\u0026#34;): Record\u0026lt;string, string\u0026gt; { /* istanbul ignore else */ if (!__GLOBAL__) { const instance = getCurrentInstance()!; if (!instance) { __DEV__ \u0026amp;\u0026amp; warn(`useCssModule must be called inside setup()`); return EMPTY_OBJ; } const modules = instance.type.__cssModules; if (!modules) { __DEV__ \u0026amp;\u0026amp; warn(`Current instance does not have CSS modules injected.`); return EMPTY_OBJ; } const mod = modules[name]; if (!mod) { __DEV__ \u0026amp;\u0026amp; warn(`Current instance does not have CSS module named \u0026#34;${name}\u0026#34;.`); return EMPTY_OBJ; } return mod as Record\u0026lt;string, string\u0026gt;; } else { if (__DEV__) { warn(`useCssModule() is not supported in the global build.`); } return EMPTY_OBJ; } }      ","permalink":"https://www.cheng92.com/vue/vue-mind-map-runtime-dom/","tags":["vue,","vue3,","runtime-dom,","patch"],"title":"Vue3 源码头脑风暴之 8 ☞ runtime-dom"},{"categories":["vue"],"contents":"  诗号：六道同坠，魔劫万千，引渡如来。  \n  --  insertCssLink(\"https://unpkg.com/element-plus/lib/theme-chalk/index.css\");     本系列为 vue-next 源码分析系列的旁系分支，主要目的在于对 vue3 源码中的一些细节进 行分析。比如： PatchFlags, ShapeFlags, 等等\n PatchFlags.BAIL   使用：\n1 2 3 4 5 6  // renderer \u0026gt; patch() // transition 组件中标记为 BAIL 类型，需要进行 full-diff if (n2.patchFlag === PatchFlags.BAIL) { optimized = false; n2.dynamicChildren = null; }     设值：\n1 2 3 4 5 6 7 8 9 10 11 12 13  // components\u0026gt;BaseTranstion.ts \u0026gt; getTransitionRawChildren() // #1126 if a transition children list contains multiple sub fragments, these // fragments will be merged into a flat children array. Since each v-for // fragment may contain different static bindings inside, we need to de-op // these children to force full diffs to ensure correct behavior. if (keyedFragmentCount \u0026gt; 1) { for (let i = 0; i \u0026lt; ret.length; i++) { ret[i].patchFlag = PatchFlags.BAIL; } } // components\u0026gt;TransitionGroup.ts \u0026gt; .... // TODO       ","permalink":"https://www.cheng92.com/vue/vue-teardown-1-patch-flags/","tags":["vue3,","vue-next,","PatchFlags"],"title":"Vue3 功能拆解① PatchFlags"},{"categories":["vue"],"contents":"  诗号：六道同坠，魔劫万千，引渡如来。  \n  --  insertCssLink(\"https://unpkg.com/element-plus/lib/theme-chalk/index.css\");     本系列为 vue-next 源码分析系列的旁系分支，主要目的在于对 vue3 源码中的一些细节进 行分析。本文讲述的是 vue3 中的一些任务调度，主要集中内容在任务类别和调度顺序问题。\n  该链接是 vue3 scheduler 的源码分析：\n Vue3 源码头脑风暴之 7 ☞ runtime-core(1) - 若叶知秋 - scheduler 任务调度机制\n 而本文主要集中点在于 vue3 中哪里使用到了这个机制，执行顺序又是怎么样的❓❓❓\nscheduler Apis 回顾   这节是针对 vue3 里 scheduler api 的一些回顾，更详细的源码分析查看上面的链接。\n  下面列出 scheduler.ts 这个文件相关的 API，后面会根据这些 api 去查找哪里用到这个 机制(之前源码阅读分析过程中，并没有特别关注，因此也很难回想具体哪些地方有用到， 所以通过搜索更直接点)\n   name brief     nextTick(fn?) 下一个时钟执行 fn 后后面的代码   queueJob(job: SchedulerJob) job 入列   queueFlush() flush 所有 Jobs   flushJobs(seen?: CountMap) queueFlush 中调用   queuePreFlushCb(cb: SchedulerCb) pre 类型的任务   flushPreFlushCbs(seen, parentJob) flush pre 类型任务   queuePostFlushCb(cb: SchedulerCbs) post 类型的任务   flushPostFlushCbs(seen?: CountMap) flush post 类型任务     从表中可知这里有三种类型的任务 job | pre | post 。\n 本文也将是围绕这三种类型去分析，了解具体哪些操作属于上面三种类型(比如：组件渲 染，更新，删除等待)。\n 简单回顾每个 api 功能:\n  queueJob 任务入列之后会立即调用 queueFlush 去 flush jobs\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26  export function queueJob(job: SchedulerJob) { // the dedupe search uses the startIndex argument of Array.includes()  // by default the search index includes the current job that is being run  // so it cannot recursively trigger itself again.  // if the job is a watch() callback, the search will start with a +1 index to  // allow it recursively trigger itself - it is the user\u0026#39;s responsibility to  // ensure it doesn\u0026#39;t end up in an infinite loop.  if ( (!queue.length || !queue.includes( job, isFlushing \u0026amp;\u0026amp; job.allowRecurse ? flushIndex + 1 : flushIndex )) \u0026amp;\u0026amp; job !== currentPreFlushParentJob ) { queue.push(job); queueFlush(); } } function queueFlush() { if (!isFlushing \u0026amp;\u0026amp; !isFlushPending) { isFlushPending = true; currentFlushPromise = resolvedPromise.then(flushJobs); } }      queuePreFlushCb 针对 pre cb，调用 queueCb 去入列同时立即 queueFlush\n1 2 3  export function queuePreFlushCb(cb: SchedulerCb) { queueCb(cb, activePreFlushCbs, pendingPreFlushCbs, preFlushIndex); }     相关的全局变量:\n1 2 3 4 5 6 7 8 9  // 还未被执行的任务，如果当前 tick 正在 flush pre cbs 的时候 // 有新的任务进来，会被添加到这个数组中 const pendingPreFlushCbs: SchedulerCb[] = []; // 正在被执行的任务，此时如果 pendingPreFlushCbs 中有新的任务进来的 // 时候，会被合并到这个队列中被继续执行，因为 flushPreFlushCbs() 函数实现 // 最后是递归调用自身，而递归结束的条件就是 pendingPreFlushCbs.length let activePreFlushCbs: SchedulerCb[] | null = null; // flush 过程中正在执行的任务索引 let preFlushIndex = 0;     所以 pre cbs 在同一个 tick 下如果有新的任务会在正在被执行的任务队列执行完成之 后立即被执行。\n  queuePostFlushCb 针对 post cb，调用 queueCb 去入列同时立即执行 queueFlush\n  最后是 flushCbs 决定了三种类型任务执行优先级\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32  function flushJobs(seen?: CountMap) { // ...  // pre cbs 先执行  flushPreFlushCbs(seen); // jobs 后执行  try { for (flushIndex = 0; flushIndex \u0026lt; queue.length; flushIndex++) { const job = queue[flushIndex]; if (job) { if (__DEV__) { checkRecursiveUpdates(seen!, job); } callWithErrorHandling(job, null, ErrorCodes.SCHEDULER); } } } finally { // 最后再执行 post cbs  flushPostFlushCbs(seen); // 这里是为了保证 post cbs 和 jobs 全部执行，因为 post cbs  // 并没有向 pre cbs 那样递归调用自己，而只是为了防止嵌套使用增加  // 了个处理机制，将新来的 pending post cbs 加入队列后继续执行  // 而这里的检测是为了在前一次调用 flushPostFlushCbs 完全结束之后  // 再次调用了 queuePostFlushCb 进行了入列操作的一次清理操作  if (queue.length || pendingPostFlushCbs.length) { flushJobs(seen); } } }       这里借助 pre cbs 做个简单的例子：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60  let pendingPreFlushCbs = []; let activePreFlushCbs = null; let preFlushIndex = 0; let isFlushing = false let resolvedPromise = Promise.resolve() function queuePreFlushCb(cb) { // cb 没有正在执行才进入等待队列  if (!activePreFlushCbs || !activePreFlushCbs.includes(cb)) pendingPreFlushCbs.push(cb); // 立即刷新队列  if (!isFlushing) { // 这里需要异步执行，让所有任务在同一个 tick 里面执行  // 不然进来一个就会立即执行  resolvedPromise.then(flushPreFlushCbs) } } function flushPreFlushCbs() { isFlushing = true // 一开始入列的是 pending 所以最开始这里应该是有任务的  if (pendingPreFlushCbs.length) { // 为了去重使用集合，得到下面将执行的任务队列  activePreFlushCbs = [...new Set(pendingPreFlushCbs)]; // 这里情况等待队列，准备接受新的任务  pendingPreFlushCbs.length = 0; for ( preFlushIndex = 0; preFlushIndex \u0026lt; activePreFlushCbs.length; preFlushIndex++ ) { // 开始执行任务  activePreFlushCbs[preFlushIndex](); } // 执行完成之后，清理数据  activePreFlushCbs = null; preFlushIndex = 0; // 递归知道所有任务执行完成  flushPreFlushCbs(); } } const cb1 = () =\u0026gt; console.log(\u0026#34;\\ncb 1\u0026#34;); const cb2 = () =\u0026gt; { console.log(\u0026#34;cb 2\u0026#34;) // 这里在执行任务期间，插入新的任务 cb2.1 看它会在什么时候被执行  queuePreFlushCb(() =\u0026gt; console.log(\u0026#39;cb 2.1\u0026#39;)) }; const cb3 = () =\u0026gt; { // 同理，只不过这里放在打印之前  queuePreFlushCb(() =\u0026gt; console.log(\u0026#39;cb 3.1\u0026#39;)) console.log(\u0026#34;cb 3\u0026#34;) }; const cb4 = () =\u0026gt; console.log(\u0026#34;cb 4\u0026#34;); console.log(\u0026#34;\u0026gt;\u0026gt;\u0026gt; 结果\u0026#34;); [cb1, cb2, cb3, cb4].forEach((cb) =\u0026gt; queuePreFlushCb(cb));    \u0026gt;\u0026gt;\u0026gt; 结果 undefined cb 1 cb 2 cb 3 cb 4 cb 2.1 cb 3.1   结果如上， cb1 -\u0026gt; cb2 -\u0026gt; cb3 -\u0026gt; cb4 按照添加的顺序执行了，然后 cb2.1 和 cb3.1 均 在 1234 后面执行，这是因为 for 循环的缘故，动态取了 activePreFlushCbs.length 而这个 activePreFlushCbs 在循环执行过程中被扩充了，所以会继续执行直到最后一个 元素。\n 通过这个例子我们可以看到 pre cbs 会在同一个 tick 下先执行已存在的任务，当这些任 务(即 for 循环)还没结束执行又有了新的任务入列，则会随后立即执行。\n 而对于 post cbs 则有点区别：\n  并没有递归 flush\n  在任务嵌套的时候也和 pre cbs 有点类似，会将这些嵌套的任务放到队列后面继续执行\n  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63  let pendingPostFlushCbs = []; let activePostFlushCbs = null; let postFlushIndex = 0; let isFlushing = false; let resolvedPromise = Promise.resolve(); // 入列，这个跟 queuePreFlushCb 一样 function queuePostFlushCb(cb) { if (!activePostFlushCbs || !activePostFlushCbs.includes(cb)) { pendingPostFlushCbs.push(cb); } if (!isFlushing) { resolvedPromise.then(flushPostFlushCbs); } } // 出列 function flushPostFlushCbs() { isFlushing = true; if (pendingPostFlushCbs.length) { const deduped = [...new Set(pendingPostFlushCbs)]; pendingPostFlushCbs.length = 0; if (activePostFlushCbs) { // 表示有 post cbs 正在执行了，有嵌套调用，即之前调用 flushPostFlushCbs  // 还没结束，那么这里只需要扩充 activePostFlushCbs 队列就行了  activePostFlushCbs.push(...deduped); return; } // 首次调用 flushPostFlushCbs 或者前一次调用已经结束了  activePostFlushCbs = deduped; // 根据 job.id 升序先将任务排序  // activePostFlushCbs.sort((a, b) =\u0026gt; getId(a) - getId(b))  for ( postFlushIndex = 0; postFlushIndex \u0026lt; activePostFlushCbs.length; postFlushIndex++ ) { activePostFlushCbs[postFlushIndex](); } activePostFlushCbs = null; postFlushIndex = 0; } } function getId(job) { return job.id == null ? Infinity : job.id; } // 测试: const cb1 = () =\u0026gt; console.log(\u0026#34;\\ncb 1\u0026#34;); const cb2 = () =\u0026gt; { console.log(\u0026#34;cb 2\u0026#34;); queuePostFlushCb(() =\u0026gt; console.log(\u0026#34;cb 2.1\u0026#34;)); }; const cb3 = () =\u0026gt; { queuePostFlushCb(() =\u0026gt; console.log(\u0026#34;cb 3.1\u0026#34;)); console.log(\u0026#34;cb 3\u0026#34;); }; const cb4 = () =\u0026gt; console.log(\u0026#34;cb 4\u0026#34;); console.log(\u0026#34;\u0026gt;\u0026gt;\u0026gt; 结果：\u0026#34;); [cb1, cb2, cb3, cb4].forEach((cb) =\u0026gt; queuePostFlushCb(cb));    \u0026gt;\u0026gt;\u0026gt; 结果： undefined cb 1 cb 2 cb 3 cb 4 cb 2.1 cb 3.1   结果和 pre cb 实现也一样，而这里在 vue3 实现中 post cb 有根据 job.id 进行升序 排序，即 job.id 小的会先执行，那这个 job id 又是个怎么大小机制的？？？\n pre, post, job 小结：\n   类型 优先级 是否排序 flush 机制     pre 1 不排序，按照加入顺序 自动触发 flush, 递归自身直到所有任务结束，在任务未完全结束之前不会重复调用 flush   post 2 按照 job.id 排序 自动触发 flush, 不会递归，但支持嵌套调用来扩展执行任务队列   job 3 按照 job.id 排序 自动触发 flush，不会递归，flush 过程中接受新 job      queueJob(job)    如上图搜索结果，使用点：\n  runtime-core/src/componentPublicInstance.ts 文件中强制更新 api 里面使用\n $forceUpdate: i =\u0026gt; () =\u0026gt; queueJob(i.update)\n  runtime-core/src/hmr.ts 中调用\n queueJob(instance.parent.update)\n 将实例父组件的更新加入执行队列，热更新功能，发生在开发环境中，当重新加载的时 候强制去更新父组件。\n    queuePreFlushCb(cb)    runtime-core/src/apiWatch.ts 的 doWatch() 中调用\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21  function doWatch( source: WatchSource | WatchSource[] | WatchEffect | object, cb: WatchCallback | null, { immediate, deep, flush, onTrack, onTrigger }: WatchOptions = EMPTY_OBJ, instance = currentInstance ): WatchStopHandle { // ...  // default: \u0026#39;pre\u0026#39;  scheduler = () =\u0026gt; { if (!instance || instance.isMounted) { queuePreFlushCb(job); } else { // with \u0026#39;pre\u0026#39; option, the first call must happen before  // the component is mounted so it is called synchronously.  job(); } }; // ... }     没有实例或组件实例还没完全加载完的时候将 job 放入队列去执行，这里的含义就如源码 的注释， watch 的 job 首次执行必须发生在实例已创建完成组件未完成渲染之前。\n  queuePostFlushCb(cb)     runtime-core/src/hmr.ts 中 unmark 组件\n  Suspense 组件中使用   runtime-core/src/components/Suspense.ts 中 Suspense 组件使用\n 组件模板的 resolve 方法：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27  const suspense: SuspenseBoundary = { resolve(resume = false) { // ...  // flush buffered effects  // check if there is a pending parent suspense  let parent = suspense.parent; let hasUnresolvedAncestor = false; while (parent) { if (parent.pendingBranch) { // found a pending parent suspense, merge buffered post jobs  // into that parent  parent.effects.push(...effects); hasUnresolvedAncestor = true; break; } parent = parent.parent; } // no pending parent suspense, flush all jobs  if (!hasUnresolvedAncestor) { queuePostFlushCb(effects); } suspense.effects = []; // ...  }, };     注意代码中调用的前提是 hasUnresolvedAncestor 即不存在祖先组件中还有未完成的 分支(parent.pendingBranch)，随后才会将当前的 Suspense 的组件的 effects 推入 post cbs 队列等待执行。\n 第二个使用的地方(封装了一个 Suspense 组件的 effects 入列函数)：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14  export function queueEffectWithSuspense( fn: Function | Function[], suspense: SuspenseBoundary | null ): void { if (suspense \u0026amp;\u0026amp; suspense.pendingBranch) { if (isArray(fn)) { suspense.effects.push(...fn); } else { suspense.effects.push(fn); } } else { queuePostFlushCb(fn); } }     这个函数作用是可以手动给一个 Suspense 组件增加一个 effect ，封装之后的函数使用轨 迹。\n  renderer.ts -\u0026gt; queuePostRenderEffect:\n1 2 3  export const queuePostRenderEffect = __FEATURE_SUSPENSE__ ? queueEffectWithSuspense : queuePostFlushCb;     hydratation.ts 中执行 onVnodeMounted 钩子函数的 hooks:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21  const hydrateElement = ( el: Element, vnode: VNode, parentComponent: ComponentInternalInstance | null, parentSuspense: SuspenseBoundary | null, optimized: boolean ) =\u0026gt; { if (patchFlag !== PatchFlags.HOISTED) { // ...  if ((vnodeHooks = props \u0026amp;\u0026amp; props.onVnodeMounted) || dirs) { queueEffectWithSuspense(() =\u0026gt; { vnodeHooks \u0026amp;\u0026amp; invokeVNodeHook(vnodeHooks, parentComponent, vnode); dirs \u0026amp;\u0026amp; invokeDirectiveHook(vnode, null, parentComponent, \u0026#34;mounted\u0026#34;); }, parentSuspense); } // ...  } return el.nextSibling; };      queuePostRenderEffect() 使用轨迹   这个函数总结来说有三个地方使用到：\n  组件的 ref 属性值变更时的回调执行\n  组件的各个周期函数()的 hooks 执行\n  watch 函数中的选项如果指定为 flush: post 时，当做 post cb 执行\n  renderer.ts:  1 2 3  export const queuePostRenderEffect = __FEATURE_SUSPENSE__ ? queueEffectWithSuspense : queuePostFlushCb;       setRef() 中\n 设置组件 ref 属性，指向最终渲染之后DOM 树中的 DOM 元素引用。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37  export const setRef = ( rawRef: VNodeNormalizedRef, oldRawRef: VNodeNormalizedRef | null, parentSuspense: SuspenseBoundary | null, vnode: VNode | null ) =\u0026gt; { // ...  if (isString(ref)) { const doSet = () =\u0026gt; { refs[ref] = value; if (hasOwn(setupState, ref)) { setupState[ref] = value; } }; // #1789: for non-null values, set them after render  // null values means this is unmount and it should not overwrite another  // ref with the same key  if (value) { (doSet as SchedulerCb).id = -1; queuePostRenderEffect(doSet, parentSuspense); } else { doSet(); } } else if (isRef(ref)) { const doSet = () =\u0026gt; { ref.value = value; }; if (value) { (doSet as SchedulerCb).id = -1; queuePostRenderEffect(doSet, parentSuspense); } else { doSet(); } } // ... };     上面两次调用针对的是两种类型，实际作用都是一样的，等组件渲染完成之后去执行：\n1 2 3  (doSet as SchedulerCb).id = -1; // 这里 id 设置为 -1 表明执行优先级最高 // 因为 post 和 job 类型都有根据 job.id 进行排序，在执行所有 cbs/jobs 之前 queuePostRenderEffect(doSet, parentSuspense);      mountElement() 中\n 首次加载元素时调用的函数。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24  const mountElement = ( vnode: VNode, container: RendererElement, anchor: RendererNode | null, parentComponent: ComponentInternalInstance | null, parentSuspense: SuspenseBoundary | null, isSVG: boolean, optimized: boolean ) =\u0026gt; { // ...  hostInsert(el, container, anchor); if ( (vnodeHook = props \u0026amp;\u0026amp; props.onVnodeMounted) || needCallTransitionHooks || dirs ) { queuePostRenderEffect(() =\u0026gt; { vnodeHook \u0026amp;\u0026amp; invokeVNodeHook(vnodeHook, parentComponent, vnode); needCallTransitionHooks \u0026amp;\u0026amp; transition!.enter(el); dirs \u0026amp;\u0026amp; invokeDirectiveHook(vnode, null, parentComponent, \u0026#34;mounted\u0026#34;); }, parentSuspense); } };     渲染组件的时候， onVnodeMounted hooks 执行队列。\n  patchElement() 中\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17  const patchElement = ( n1: VNode, n2: VNode, parentComponent: ComponentInternalInstance | null, parentSuspense: SuspenseBoundary | null, isSVG: boolean, optimized: boolean ) =\u0026gt; { // ...  if ((vnodeHook = newProps.onVnodeUpdated) || dirs) { queuePostRenderEffect(() =\u0026gt; { vnodeHook \u0026amp;\u0026amp; invokeVNodeHook(vnodeHook, parentComponent, n2, n1); dirs \u0026amp;\u0026amp; invokeDirectiveHook(n2, n1, parentComponent, \u0026#34;updated\u0026#34;); }, parentSuspense); } };     onVnodeUpdated hooks 执行队列。\n  setupRenderEffect() 函数中\n 当组件状态更新时会调用 instance.update ，这里是执行 setup() 之后的一个组件更新 函数的一个封装函数。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58  const setupRenderEffect: SetupRenderEffectFn = ( instance, initialVNode, container, anchor, parentSuspense, isSVG, optimized ) =\u0026gt; { // create reactive effect for rendering  instance.update = effect( function componentEffect() { if (!instance.isMounted) { // ...  // mounted hook  if (m) { queuePostRenderEffect(m, parentSuspense); } // onVnodeMounted  if ((vnodeHook = props \u0026amp;\u0026amp; props.onVnodeMounted)) { const scopedInitialVNode = initialVNode; queuePostRenderEffect(() =\u0026gt; { invokeVNodeHook(vnodeHook!, parent, scopedInitialVNode); }, parentSuspense); } // activated hook for keep-alive roots.  // #1742 activated hook must be accessed after first render  // since the hook may be injected by a child keep-alive  const { a } = instance; if ( a \u0026amp;\u0026amp; initialVNode.shapeFlag \u0026amp; ShapeFlags.COMPONENT_SHOULD_KEEP_ALIVE ) { queuePostRenderEffect(a, parentSuspense); } instance.isMounted = true; // #2458: deference mount-only object parameters to prevent memleaks  initialVNode = container = anchor = null as any; } else { // updateComponent  // ...  next.el = nextTree.el; // updated hook  if (u) { queuePostRenderEffect(u, parentSuspense); } // onVnodeUpdated  if ((vnodeHook = next.props \u0026amp;\u0026amp; next.props.onVnodeUpdated)) { queuePostRenderEffect(() =\u0026gt; { invokeVNodeHook(vnodeHook!, parent, next!, vnode); }, parentSuspense); } } }, __DEV__ ? createDevEffectOptions(instance) : prodEffectOptions ); };     这里有四个调用也均和声明周期 hooks 有关\n mounted, onVnodeMounted, updated, onVnodeUpdated 四个周期的 hooks 执 行队列。\n  move() 函数\n 节点移动操作。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19  const move: MoveFn = ( vnode, container, anchor, moveType, parentSuspense = null ) =\u0026gt; { // ...  if (needTransition) { if (moveType === MoveType.ENTER) { transition!.beforeEnter(el!); hostInsert(el!, container, anchor); queuePostRenderEffect(() =\u0026gt; transition!.enter(el!), parentSuspense); } } else { hostInsert(el!, container, anchor); } };     当使用了 transition 组件的时候，进入动画的任务队列。\n  unmount() 函数\n 卸载组件。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  const unmount: UnmountFn = ( vnode, parentComponent, parentSuspense, doRemove = false, optimized = false ) =\u0026gt; { // ...  if ((vnodeHook = props \u0026amp;\u0026amp; props.onVnodeUnmounted) || shouldInvokeDirs) { queuePostRenderEffect(() =\u0026gt; { vnodeHook \u0026amp;\u0026amp; invokeVNodeHook(vnodeHook, parentComponent, vnode) shouldInvokeDirs \u0026amp;\u0026amp; invokeDirectiveHook(vnode, null, parentComponent, \u0026#39;unmounted\u0026#39;) }, parentSuspense) } }     组件卸载的一个周期函数 onVnodeUnmounted 的 hooks。\n  unmountComponent() 组件卸载函数\n1 2 3 4 5 6 7 8 9 10 11 12 13 14  const unmountComponent = ( instance: ComponentInternalInstance, parentSuspense: SuspenseBoundary | null, doRemove?: boolean ) =\u0026gt; { // ...  // unmounted hook  if (um) { queuePostRenderEffect(um, parentSuspense) } queuePostRenderEffect(() =\u0026gt; { instance.isUnmounted = true }, parentSuspense) }     组件卸载时的钩子函数 unmounted hooks\n    KeepAlive.ts    activated 周期函数\n  deactiveated 周期函数\n  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52  const KeepAliveImpl = { setup(props: KeepAliveProps, { slots }: SetupContext) { sharedContext.activate = (vnode, container, anchor, isSVG, optimized) =\u0026gt; { // ...  queuePostRenderEffect(() =\u0026gt; { instance.isDeactivated = false if (instance.a) { invokeArrayFns(instance.a) } const vnodeHook = vnode.props \u0026amp;\u0026amp; vnode.props.onVnodeMounted if (vnodeHook) { invokeVNodeHook(vnodeHook, instance.parent, vnode) } }, parentSuspense) } sharedContext.deactivate = (vnode: VNode) =\u0026gt; { const instance = vnode.component! move(vnode, storageContainer, null, MoveType.LEAVE, parentSuspense) queuePostRenderEffect(() =\u0026gt; { if (instance.da) { invokeArrayFns(instance.da) } const vnodeHook = vnode.props \u0026amp;\u0026amp; vnode.props.onVnodeUnmounted if (vnodeHook) { invokeVNodeHook(vnodeHook, instance.parent, vnode) } instance.isDeactivated = true }, parentSuspense) } // ...  onBeforeUnmount(() =\u0026gt; { cache.forEach(cached =\u0026gt; { const { subTree, suspense } = instance const vnode = getInnerChild(subTree) if (cached.type === vnode.type) { // current instance will be unmounted as part of keep-alive\u0026#39;s unmount  resetShapeFlag(vnode) // but invoke its deactivated hook here  const da = vnode.component!.da da \u0026amp;\u0026amp; queuePostRenderEffect(da, suspense) return } unmount(cached) }) }) return () =\u0026gt; { /* render */ } } }      apiWatch.ts   watch api 中，当指定选项 flush:post 时，会将 Job 当做 post cb 去执行(默认是 pre cb 类型)。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31  function doWatch( source: WatchSource | WatchSource[] | WatchEffect | object, cb: WatchCallback | null, { immediate, deep, flush, onTrack, onTrigger }: WatchOptions = EMPTY_OBJ, instance = currentInstance ): WatchStopHandle { // ...  let scheduler: ReactiveEffectOptions[\u0026#39;scheduler\u0026#39;] if (flush === \u0026#39;sync\u0026#39;) { scheduler = job } else if (flush === \u0026#39;post\u0026#39;) { scheduler = () =\u0026gt; queuePostRenderEffect(job, instance \u0026amp;\u0026amp; instance.suspense) } else { // default: \u0026#39;pre\u0026#39;  } // ...  recordInstanceBoundEffect(runner, instance) // initial run  if (cb) { // ...  } else if (flush === \u0026#39;post\u0026#39;) { queuePostRenderEffect(runner, instance \u0026amp;\u0026amp; instance.suspense) } else { runner() } return () =\u0026gt; { /*...*/ }          flushPreFlushCbs(seen, parentJob)    组件更新函数中：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  const updateComponentPreRender = ( instance: ComponentInternalInstance, nextVNode: VNode, optimized: boolean ) =\u0026gt; { nextVNode.component = instance; const prevProps = instance.vnode.props; instance.vnode = nextVNode; instance.next = null; updateProps(instance, nextVNode.props, prevProps, optimized); updateSlots(instance, nextVNode.children); // props update may have triggered pre-flush watchers.  // flush them before the render update.  flushPreFlushCbs(undefined, instance.update); };      flushPostFlushCbs(seen)   1 2 3 4 5 6 7 8 9 10 11  const render: RootRenderFunction = (vnode, container) =\u0026gt; { if (vnode == null) { if (container._vnode) { unmount(container._vnode, null, null, true); } } else { patch(container._vnode || null, vnode, container); } flushPostFlushCbs(); container._vnode = vnode; };     hydrate:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17  const hydrate: RootHydrateFunction = (vnode, container) =\u0026gt; { if (__DEV__ \u0026amp;\u0026amp; !container.hasChildNodes()) { warn( `Attempting to hydrate existing markup but container is empty. ` + `Performing full mount instead.` ); patch(null, vnode, container); return; } hasMismatch = false; hydrateNode(container.firstChild!, vnode, null, null); flushPostFlushCbs(); if (hasMismatch \u0026amp;\u0026amp; !__TEST__) { // this error should show up in production  console.error(`Hydration completed but contains mismatches.`); } };      总结   任务调度均发生在 runtime-core 阶段，所以下面的文件均在 runtime-core/src../ 下\n   如上表可得出结论：\n  watch api 的 Job 归纳为 pre cb 类型，先于 post 和 job 执行\n 特殊情况： watch api 指定了 {flush: \u0026#39;post\u0026#39;} 时候也属于 post cb 类型\n  组件的生命周期函数 hooks 归纳为 post cb 类型，后于 pre 和 job 执行\n  $forceUpdate 组件强制更新归纳为 job 类型，会在 pre cb 后面，先于 post cb 执行\n   所以: watch job \u0026gt; force update job \u0026gt; 声明周期 hooks job\n  测试(/js/vue/tests/b56ivpbdBF.js)：\n   通过上面的几个按钮可以测试看出 pre, post, job 执行顺序。\n 比如：点击 +/- 按钮，如下输出：\nwatch pre cb: {\u0026#34;newVal\u0026#34;:-1,\u0026#34;oldVal\u0026#34;:0} watch post cb: {\u0026#34;newVal\u0026#34;:-1,\u0026#34;oldVal\u0026#34;:0} updated hook post cb before updated hook post cb after   点击 $forceUpdate 按钮，如下输出：\njob: from $forceUpdate watch pre cb: {\u0026#34;newVal\u0026#34;:0,\u0026#34;oldVal\u0026#34;:-1} watch post cb: {\u0026#34;newVal\u0026#34;:0,\u0026#34;oldVal\u0026#34;:-1} updated hook post cb before updated hook post cb after   调换下： watch api 调用顺序，把 {flush: \u0026#39;post\u0026#39;} 放前面\n1 2 3 4 5 6 7 8 9 10 11  watch( count, (newVal, oldVal) =\u0026gt; { log(\u0026#34;watch post cb: \u0026#34; + toStr({ newVal, oldVal })); }, { flush: \u0026#34;post\u0026#34; } ); watch(count, (newVal, oldVal) =\u0026gt; { log(\u0026#34;watch pre cb: \u0026#34; + toStr({ newVal, oldVal })); });    watch pre cb: {\u0026#34;newVal\u0026#34;:-1,\u0026#34;oldVal\u0026#34;:0} watch post cb: {\u0026#34;newVal\u0026#34;:-1,\u0026#34;oldVal\u0026#34;:0} updated hook post cb before updated hook post cb after   输出结果依旧是 pre 先于 post 执行。\n  ","permalink":"https://www.cheng92.com/vue/vue-teardown-2-sheduler/","tags":["vue3,","vue-next,","PatchFlags"],"title":"Vue3 功能拆解② Scheduler 渲染机制"},{"categories":["vue"],"contents":"  诗号：六道同坠，魔劫万千，引渡如来。  \n  --  insertCssLink(\"https://unpkg.com/element-plus/lib/theme-chalk/index.css\");      stb-vue-next 完全拷贝于 vue-next ，主要目的用于学习。 \n 本文为 runtime-core(2) 续集，上篇： Vue3 源码头脑风暴之 7 ☞ runtime-core(2) - render\n 流程图(脑图)    这一节新增内容较多，主要新增以下几个函数\n  processComponent() 在 patch() 中执行 switch default 分支，满足 ShapeFlags.COMPONENT 条件\n  mountComponent(n2,...) 首次加载组件时调用的函数\n  setupComponent(instance) 建立组件实例，做一些结构初始化操作(如：props和 slots)等\n  setupStatefulComponent(instance,isSSR) 创建有状态组件，执行 setup() 函数\n  setupRenderEffect() 通过 effect() 函数返回 instance.update 创建一个监听- 更新函数。\n  finishComponentSetup(instance,isSSR) 这个函数在 setupStatefulComponent() 中调用，主要做的事情是处理 SSR，没有 render 函数有 template 时调用 compile 编 译出 render 函数，兼容 2.x 的 options api\n    processComponent(如何patch组件的？)   问题修复： TypeError: Cannot read property \u0026#39;allowRecurse\u0026#39; of null\n processComponent(n1,n2,...) 函数主要分三种情况\n  mount, 没有 n1 old 时候，属于纯 mount 操作\n  keep-alive 类型，只需要重新激活 activate\n  否则执行 mountComponent(n2, ….) 首次加载组件\n    update, 非首次加载执行更新操作\n  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36  const { log, f, shuffle, runtime_test, renderChildren } = require(process.env .BLOG_DIR_VUE + \u0026#34;/lib.js\u0026#34;); import(process.env.BLOG_DIR_VUE + \u0026#34;/runtime-test.global.js\u0026#34;).then( ({ h, render, nodeOps, serializeInner: inner, ref }) =\u0026gt; { const root = nodeOps.createElement(\u0026#34;div\u0026#34;); const logRoot = () =\u0026gt; log(\u0026#34;root: \u0026#34; + inner(root)); logRoot(); const value = ref(true); let parentVnode, childVnode1, childVnode2; const Parent = { render: () =\u0026gt; { // return h(\u0026#34;div\u0026#34;, \u0026#34;测试...\u0026#34;);  return (parentVnode = h(Child)); }, }; const Child = { render: () =\u0026gt; { return value.value ? (childVnode1 = h(\u0026#34;div\u0026#34;, \u0026#34;child 1\u0026#34;)) : (childVnode2 = h(\u0026#34;span\u0026#34;, \u0026#34;child 2\u0026#34;)); }, }; const p = h(Parent); render(p, root); logRoot(); value.value = false; logRoot(); }, (err) =\u0026gt; { console.log(err.message); } );    undefinedroot: component stateful ? 4 call setup no setup [Function: render] render mount component normalize vnode patch component component stateful ? 4 call setup no setup [Function: render] render mount component normalize vnode patch component root: \u0026lt;div\u0026gt;child 1\u0026lt;/div\u0026gt; root: \u0026lt;div\u0026gt;child 1\u0026lt;/div\u0026gt; component update   流程简图：\n  这里执行就是 mountComponent(n2,...) 行为，首次加载组件，完成：\n  setupComponent(instance) 执行 setup 函数，初始化 props\u0026amp;slots 等\n  setupRenderEffect(instance,...) 注册 instance.update effect\n 当实例状态发生改变时执行这个 effect fn，如果是首次(父级调用 processComponent) 执行!isMounted 分支进行组件首次加载，否则当组件自身状态改变是触发的 update 操 作\n   在 setupComponent 中，主要完成\n  initProps\n  initSlots\n  setupStatefulComponent(instance,isSSR) 有状态组件(非函数组件)\n   紧接着 setupStatefulComponent(instance,isSSR) 中检测 setup 函数，并执行它，如 果没有 setup 函数就进入 finishComponentSetup(instance) 检测 render 或 template 最终目的是获得 render 函数，如果没有 render 会通过 compile(template) 编译出 render 函数，最后在 instance.update 中执行 render 函数(在这前后会触发 beforeMount 和 mounted 周期函数)。\n 所以，一套流程下来可以简单描述为\n mount -\u0026gt; props\u0026amp;slots 初始化 -\u0026gt; setup() -\u0026gt; 有状态组件处理得到 render 函数 -\u0026gt; 最后 通过 instance.update effect 来监听实例状态变化，触发 mount 或者 update。\n 在 effect mount 阶段会触发生命周期函数：\n  beforeMount + mounted\n  onVnodeBeforeMount + onVnodeMounted(针对 vnode 结构变化而言)\n  activated(如果是 keep-alive 的话)\n  组件的渲染就发生在 beforeMount 之后 mounted 之前的 renderComponentRoot() 得到 vnode 交给 patch 去进行渲染。\n  示例代码中，后面修改了 value.value=false 后面 dom 并没改变，但是输出了 component update 说明进入了 instance.update effect 的 else 分支，因为不是第 一次，所以这里需要实现更新组件部分。\neffect update component   因为 instance.update 是通过 effect() 封装的函数，且这个函数中使用到了 instance 实例而这个实例又在 setupComponent 中有做过代理，因此对它的访问会触发 effect track，状态更新会触发 effect trigger(响应式原理)。\n feat(add): component update · gcclll/stb-vue-next@1254465\n 涉及的修改：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71  instance.update = effect( function componentEffect() { // 监听更新  if (!instance.isMounted) { // ...  } else { // updateComponent  // 当组件自身的状态或父组件调用 processComponent 时触发  console.log(\u0026#34;component update\u0026#34;); let { next, bu, u, parent, vnode } = instance; let originNext = next; let vnodeHook: VNodeHook | null | undefined; if (next) { next.el = vnode.el; updateComponentPreRender(instance, next, optimized); } else { next = vnode; } // beforeUpdate hook  if (bu) { invokeArrayFns(bu); } // onVnodeBeforeUpdate  if ((vnodeHook = next.props \u0026amp;\u0026amp; next.props.onVnodeBeforeUpdate)) { invokeVNodeHook(vnodeHook, parent, next, vnode); } //render  const nextTree = renderComponentRoot(instance); const prevTree = instance.subTree; instance.subTree = nextTree; patch( prevTree, nextTree, // 如果在 teleport 中，parent 可能会发生改变  hostParentNode(prevTree.el!)!, // anchor may have changed if it\u0026#39;s in a fragment  getNextHostNode(prevTree), instance, parentSuspense, isSVG ); next.el = nextTree.el; if (originNext === null) { // self-triggered update. In case of HOC, update parent component  // vnode el. HOC is indicated by parent instance\u0026#39;s subTree pointing  // to child component\u0026#39;s vnode  // TODO  } // updated hook  if (u) { queuePostRenderEffect(u, parentSuspense); } // onVnodeUpdated  if ((vnodeHook = next.props \u0026amp;\u0026amp; next.props.onVnodeUpdated)) { queuePostRenderEffect(() =\u0026gt; { invokeVNodeHook(vnodeHook!, parent, next!, vnode); }); } } }, __DEV__ ? // 提供 onTrack/onTrigger 选项执行 rtc\u0026amp;rtg 两个周期函数  createDevEffectOptions(instance) : prodEffectOptions );     和 updateComponentPreRender 实现这个函数让 instance.update 在 nextTick() 之后执 行 pre 优先于 post 和 job 任务(详情查看任务调度-\u0026gt;)：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  const updateComponentPreRender = ( instance: ComponentInternalInstance, nextVNode: VNode, optimized: boolean ) =\u0026gt; { nextVNode.component = instance // const prevProps = instance.vnode.props  instance.vnode = nextVNode instance.next = null // TODO update props  // TODO update slots  // props update may have triggered pre-flush watchers.  // flush them before the render update.  flushPreFlushCbs(undefined, instance.update) }     之前的用例再测试一遍：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47  const { log, f, shuffle, runtime_test, renderChildren } = require(process.env .BLOG_DIR_VUE + \u0026#34;/lib.js\u0026#34;); import(process.env.BLOG_DIR_VUE + \u0026#34;/runtime-test.global.js\u0026#34;).then( async ({ h, render, nodeOps, serializeInner: inner, ref, nextTick }) =\u0026gt; { const root = nodeOps.createElement(\u0026#34;div\u0026#34;); const logRoot = () =\u0026gt; log(\u0026#34;root: \u0026#34; + inner(root)); logRoot(); const value = ref(true); let parentVnode, childVnode1, childVnode2; const idValue = ref(\u0026#34;parent\u0026#34;); const Parent = { render: () =\u0026gt; { console.log(\u0026#34;parent render\u0026#34;); return (parentVnode = h(\u0026#34;div\u0026#34;, { id: idValue.value }, h(Child))); }, }; const Child = { render: () =\u0026gt; { console.log(\u0026#34;child render\u0026#34;); return value.value ? (childVnode1 = h(\u0026#34;div\u0026#34;, \u0026#34;child 1\u0026#34;)) : (childVnode2 = h(\u0026#34;span\u0026#34;, \u0026#34;child 2\u0026#34;)); }, }; const p = h(Parent); render(p, root); logRoot(); console.log(\u0026#34;before change value\u0026#34;); value.value = false; await nextTick(); console.log(\u0026#34;after change value\u0026#34;); logRoot(); console.log(\u0026#39;before id change\u0026#39;); idValue.value = \u0026#39;parent-id\u0026#39; await nextTick() console.log(\u0026#39;after id change\u0026#39;); logRoot() }, (err) =\u0026gt; { console.log(err.message); } );    undefinedroot: component stateful ? 4 call setup no setup [Function: render] render mount component normalize vnode parent render patch component component stateful ? 4 call setup no setup [Function: render] render mount component normalize vnode child render patch component root: \u0026lt;div id=\u0026#34;parent\u0026#34;\u0026gt;\u0026lt;div\u0026gt;child 1\u0026lt;/div\u0026gt;\u0026lt;/div\u0026gt; before change value component update normalize vnode child render after change value root: \u0026lt;div id=\u0026#34;parent\u0026#34;\u0026gt;\u0026lt;span\u0026gt;child 2\u0026lt;/span\u0026gt;\u0026lt;/div\u0026gt; before id change component update normalize vnode parent render after id change root: \u0026lt;div id=\u0026#34;parent\u0026#34;\u0026gt;\u0026lt;span\u0026gt;child 2\u0026lt;/span\u0026gt;\u0026lt;/div\u0026gt;   这里要让输出达到效果，需要将 resolve 改成 async function 并且要在 nextTick() 后 输出更新后的结果，因为 instance.update 调用了 flushPreFlushCbs(null, instane.update) 也就是说这个函数是个异步更新，且会在 nextTick() 后触发，详情 分析查看“任务调度机制分析”\n 问题： 如上面的结果，当我们改变 idValue.value=\u0026#34;parent-id\u0026#34; 的时候，实际结果并没 有改变？\n 答： 因为在 setupComponent() 中的 initProps() 以及 updateComponentPreRender() 中的 updateProps() 还没实现，下一节揭晓。\n   normalize props options   feat(add): normalize props options · gcclll/stb-vue-next@7d6ac55\n 对应官方文档内容： Props | Vue.js\n 这里作用简单描述就是，将 props 的定义在组件加载初始化时解析成具体的值，如： props: [\u0026#39;foo\u0026#39;] 解析成 foo={} 因为字符串数组的 props 会给每个属性初始化一个空 对象。\n  比如：\n  数组： props: [\u0026#39;foo\u0026#39;, \u0026#39;bar\u0026#39;, \u0026#39;foo-bar\u0026#39;]\n 转成 {foo: {}, bar: {}, fooBar: {}}\n  对象: props: { foo: [Boolean, String], bar: Function }\n 表示 foo 可以是布尔值或字符串，bar 是个函数\n 转换过程(0: BooleanFlags.shouldCast, 1: BooleanFlags.shouldCastTrue)\n foo = { type: [Boolean, String] } -\u0026gt; 找 Boolean\n foo = { type: [Boolean, String], 0: true } -\u0026gt;\n 找 String 需满足 stringIndex \u0026lt; 0 || booleanIndex \u0026lt; stringIndex\n foo = { type: [Boolean, String], 0: true, 1: true }\n 最后决定 foo 是不是应该进行 cast ? 条件是布尔类型或者有 default 默认值。\n   源码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88  export function normalizePropsOptions( comp: ConcreteComponent, appContext: AppContext, asMixin: false ): NormalizedPropsOptions { if (!appContext.deopt \u0026amp;\u0026amp; comp.__props) { return comp.__props } const raw = comp.props const normalized: NormalizedPropsOptions[0] = {} const needCastKeys: NormalizedPropsOptions[1] = [] // mixin/extends props 应用  let hasExtends = false // 必须开支 2.x options api 支持，且不是函数式组件  // 继承来的属性，用法： ~CompA = { extends: CompB, ... }~  // CompA 会继承 CompB 的 props  if (__FEATURE_OPTIONS_API__ \u0026amp;\u0026amp; !isFunction(comp)) { const extendProps = (raw: ComponentOptions) =\u0026gt; { hasExtends = true const [props, keys] = normalizePropsOptions(raw, appContext, true) extend(normalized, props) if (keys) { needCastKeys.push(...keys) } } // Comp: { extends: CompA } 处理  if (comp.extends) { extendProps(comp.extends) } // Comp: { mixins: [mixin] } 处理  if (!asMixin \u0026amp;\u0026amp; appContext.mixins.length) { appContext.mixins.forEach(extendProps) } } // 既没有自身的 props 也没有 extends 继承来的 props 初始化为 []  if (!raw \u0026amp;\u0026amp; !hasExtends) { return (comp.__props = EMPTY_ARR as any) } if (isArray(raw)) { // 当 props 是数组的时候，必须是字符类型，如: props: [\u0026#39;foo\u0026#39;, \u0026#39;bar\u0026#39;, \u0026#39;foo-bar\u0026#39;]  // \u0026#39;foo-bar\u0026#39; 会转成 \u0026#39;fooBar\u0026#39;，不允许 \u0026#39;$xxx\u0026#39; 形式的变量名  for (let i = 0; i \u0026lt; raw.length; i++) { const normalizedKey = camelize(raw[i]) // 组件的属性名不能是以 $xx 开头的名称，这个是作为内部属性的  if (validatePropName(normalizedKey)) { normalized[normalizedKey] = EMPTY_OBJ } } } else if (raw) { // 对象类型 props: { foo: 1, bar: 2, ... }  for (const key in raw) { // \u0026#39;foo-bar\u0026#39; -\u0026gt; \u0026#39;fooBar\u0026#39;  const normalizedKey = camelize(key) // 检查 $xxx 非法属性  if (validatePropName(normalizedKey)) { const opt = raw[key] // ? 值为数组或函数变成： { type: opt } ?  // 这里含义其实是： ~props: { foo: [Boolean, Function] }~  // 可以用数组定义该属性可以是多种类型的其中一种  const prop: NormalizedProp = (normalized[normalizedKey] = isArray(opt) || isFunction(opt) ? { type: opt } : opt) if (prop) { // 找到 Boolean 在 foo: [Boolean, Function] 中的索引  const booleanIndex = getTypeIndex(Boolean, prop.type) const stringIndex = getTypeIndex(String, prop.type) prop[BooleanFlags.shouldCast] = booleanIndex \u0026gt; -1 // [String, Boolean] 类型，String 在 Boolean 前面  prop[BooleanFlags.shouldCastTrue] = stringIndex \u0026lt; 0 || booleanIndex \u0026lt; stringIndex // 如果是布尔类型的值或者有默认值的属性需要转换  // 转换是根据 type 和 default 值处理  // type非函数，default是函数，执行 default() 得到默认值  if (booleanIndex \u0026gt; -1 || hasOwn(prop, \u0026#39;default\u0026#39;)) { needCastKeys.push(normalizedKey) } } } } } return (comp.__props = [normalized, needCastKeys]) }     然后这个处理之后的 props，会被保存到组件的 comp.__props=[normalied, needCastKeys] 上，而这个会在 resolvePropValue() 中进一步处理，这里的 needCastKeys 非常重要，它会决定最后的值应该如何被处理(resolvePropValue 中处 理)。\n 比如： { type: String, default: () =\u0026gt; \u0026#39;xxx\u0026#39; } 那么满足 type!==Function \u0026amp;\u0026amp; isFunction(dfault) 则会直接执行 default() 得到属性默认值。\n 如果属性的 opt[BooleanFlags.shouldCast] 为 true 如最开始的说明，其实就是 prop[\u0026#34;0\u0026#34;] 的值，只要 prop 的类型中有 Boolean 这个值就是 true 。\n 此时需要将属性的值转成\n  true : 类型声明中有 Boolean 且有 String 的时候，它的值如果是 \u0026#39;\u0026#39; 或者 key === value 情况下转成 true, 因为指定了可以是 String 类型，所以空字符 串是允许的。\n  false : (!hasOwn(props, key) \u0026amp;\u0026amp; !hasDefault), raw props 中没有这个属性且 没有 default 默认值的时候转成 false, 等于是假值类型。\n    component props   feat(add): init component props · gcclll/stb-vue-next@9a6aa70\n 新增代码：\n1 2 3 4 5 6 7 8 9 10 11  // component.ts \u0026gt; setupComponent() export function setupComponent( instance: ComponentInternalInstance, isSSR = false ) { // ...  // init props \u0026amp; slots  initProps(instance, props, isStateful, isSSR); // ...  return setupResult; }     componentProps.ts \u0026gt; initProps()\n  def -\u0026gt; attrs.__vInterval = 1\n  setFullProps 处理 rawProps 将结果反馈到 props 和 attrs\n  有状态组件？将 props reactive 化，SSR下不支持属性响应式其实就是服务器返回的属 性都是带有最终值的而不是在客户端动态能改变的\n  函数组件的 props 可选属性和必须属性？可选用 attrs 否则用 props\n  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25  export function initProps( instance: ComponentInternalInstance, rawProps: Data | null, isStateful: number, isSSR = false ) { const props: Data = {}; const attrs: Data = {}; def(attrs, InternalObjectKey, 1); setFullProps(instance, rawProps, props, attrs); // TODO validation  if (isStateful) { instance.props = isSSR ? props : shallowReactive(props); } else { if (!instance.type.props) { // functional optional props, props === attrs  instance.props = attrs; } else { // functional declared props  instance.props = props; } } instance.attrs = attrs; }     componentProps.ts \u0026gt; setFullProps() 这个函数目的是将 rawProps 组件的 props 解析出来根据各自特性 分派到 props 或 attrs\n  key, ref 属性不保留，因为组件更新时 key 可能发生改变，ref引用也会变好指向更新后的 DOM 元素\n  options 啥意思？\n  事件属性(onClick)会存放到 attrs !\n  needCastKeys ? 这是做啥呢 resolvePropValue？\n  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39  function setFullProps( instance: ComponentInternalInstance, rawProps: Data | null, props: Data, attrs: Data ) { const [options, needCastKeys] = instance.propsOptions; if (rawProps) { for (const key in rawProps) { const value = rawProps[key]; // key, ref 保留，不往下传  // 即这两个属性不会继承给 child  if (isReservedProp(key)) { continue; } let camelKey; if (options \u0026amp;\u0026amp; hasOwn(options, (camelKey = camelize(key)))) { props[camelKey] = value; } else if (!isEmitListener(instance.emitsOptions, key)) { attrs[key] = value; } } } if (needCastKeys) { const rawCurrentProps = toRaw(props); for (let i = 0; i \u0026lt; needCastKeys.length; i++) { const key = needCastKeys[i]; props[key] = resolvePropValue( options!, rawCurrentProps, key, rawCurrentProps[key], instance ); } } }     componentProps.ts -\u0026gt; resolvePropValue()\n  props:{name: {default: v=\u0026gt; myname }, type: String}\n 当 type 非函数时，说明 name 是个字符串类型，但是它的 default 又是个函数？ 那么这种情况会在这里被处理，最后将 name 的值赋值为 default(props) 执行之后的结果\n  props:{name: {default: v=\u0026gt; myname }, type: Function}\n 这种情况，说明 name 本身就是函数，不需要执行 default。\n  props:{name: value, type: String|Number} 普通类型情况\n  boolean 类型的值处理，最后都会转成 true 或 false\n  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45  function resolvePropValue( options: NormalizedProps, props: Data, key: string, value: unknown, instance: ComponentInternalInstance ) { /* * 这里面的处理是针对 props: { name: { ... } } 类型而言 * 1. 默认值的处理， default 可能是函数或普通类型值，如果是函数应该得到 * 函数执行的结果作为它的值，注意下面的检测函数时前置条件是该类型不是函数， * 如果类型也是函数，默认值就是该函数本身，而非执行后的结果值 * 2. 布尔值的处理，值转成 true or false */ const opt = options[key] if (opt != null) { const hasDefault = hasOwn(opt, \u0026#39;default\u0026#39;) // 默认值  if (hasDefault \u0026amp;\u0026amp; value === undefined) { const defaultValue = opt.default // props: { name: { default: (props) =\u0026gt; \u0026#39;xxx\u0026#39; } }  // 类型不是函数？但是默认值是函数，执行得到结果  if (opt.type !== Function \u0026amp;\u0026amp; isFunction(defaultValue)) { setCurrentInstance(instance) value = defaultValue(props) setCurrentInstance(null) } else { // props: { name: { default: \u0026#39;xxx\u0026#39; } }  value = defaultValue } } // boolean casting  if (opt[BooleanFlags.shouldCast]) { if (!hasOwn(props, key) \u0026amp;\u0026amp; !hasDefault) { value = false } else if ( opt[BooleanFlags.shouldCastTrue] \u0026amp;\u0026amp; (value === \u0026#39;\u0026#39; || value === hyphenate(key)) ) { value = true } } } return value }     ❓ 然后与 props 有关的 propsOptions 是来自哪里？\n  回顾下 component render 过程：\n patch -\u0026gt; switch default -\u0026gt; PatchFlags.COMPONENT -\u0026gt;\n processComponent -\u0026gt; mountComponent -\u0026gt;\n createComponentInstance -\u0026gt; setupComponent -\u0026gt; setupRenderEffect\n 有了？\n 是的，就是它 -\u0026gt; createComponentInstance 创建组件实例中，进行了初始化，其中组织 的结构里面就有一个\n propsOptions: normalizePropsOptions(type, appContext)\n 和\n emitsOptions: normalizeEmitsOptions(type, appContext)\n  component setup    setup 如果返回值是函数直接是 render 函数\n  setup 返回值是对象，则当做和 data 一样的组件状态处理\n    更多分析见注释，相关代码:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117  // 如果组件是个对象，而非函数是组件是会经过这个函数 function setupStatefulComponent( instance: ComponentInternalInstance, isSSR: boolean ) { const Component = instance.type as ComponentOptions; // 0. create render proxy property access cache  // 这个是针对 instance 上属性的 get 操作类型进行了 key 值缓存  // 比如：当你对 setupState 或 data的属性 进行了 get 访问，  // 那么该属性的key值会记录为该类型(accessCache[key]=AccessTypes.SETUP)  // 当你下次再在 instance 上访问这个key 的时候，那么这个时候就会知道这个 key  // 是在 setupState 上，那么就直接返回 setupState[key] 就行了  // 而不用去重复进行 if...elseif...else 去 setupData, data, context  // 或 props 判断然后决定去哪个上面取值，加快求值速度。  // 如： setupState={foo:1}, data={bar:2}  // 取值： this.foo 触发 get 操作，这个时候第一次取值的时候会进行  // if setupState else if data 检测\u0026#39;foo\u0026#39;在哪个对象上，发现在  // setupState 上，然后将 \u0026#39;foo\u0026#39; 缓存到 accessCache[\u0026#39;foo\u0026#39;] =\u0026#39;setup\u0026#39;  // 下次再次取值this.foo，那么本次就会直接返回 setupState[\u0026#39;foo\u0026#39;]  instance.accessCache = Object.create(null); // 1. create public instance / render proxy  // also mark it raw so it\u0026#39;s never observed  // 代理目的：让取值操作能在 setupState, data, ctx, props 及  // appContext.config.globalProperties 上依次查找对应的属性值  // 优先级：  // 1. 非 $xxx 属性， setupState \u0026gt; data \u0026gt; ctx \u0026gt; props  // 2. this.$xxx 取值， public 属性: $,$el,$data,$props,$attrs  // ,$slots,$refs,$parent,$root,$emit,$options,$forceUpdate,  // ,$nextTick,$watch  // \u0026gt; cssModule 属性 vue-loader 注入的css 变量  // \u0026gt; instance.ctx  // \u0026gt; appContext.config.globalProperties, 如： this.$router  instance.proxy = new Proxy(instance.ctx, PublicInstanceProxyHandlers); console.log(\u0026#34;call setup\u0026#34;); // 2. call setup()  const { setup } = Component; if (setup) { // 传递给 setup(props, setupContext) 的第二个参数  // setupContext: { attrs, slots, emit, expose }  const setupContext = (instance.setupContext = setup.length \u0026gt; 1 ? createSetupContext(instance) : null); currentInstance = instance; // 实例初始化期间，禁止 track 操作，get 收集依赖  pauseTracking(); // 执行 setup 函数  const setupResult = callWithErrorHandling( setup, instance, ErrorCodes.SETUP_FUNCTION, [__DEV__ ? shallowReadonly(instance.props) : instance.props, setupContext] ); resetTracking(); currentInstance = null; // 对setup 结果处理，返回值只能是对象或函数  if (isPromise(setupResult)) { if (isSSR) { // return the promise so server-renderer can wait on it  return setupResult.then((resolvedResult: unknown) =\u0026gt; { handleSetupResult(instance, resolvedResult, isSSR); }); } else if (__FEATURE_SUSPENSE__) { // async setup returned Promise.  // bail here and wait for re-entry.  instance.asyncDep = setupResult; } else if (__DEV__) { // TODO warn  } } else { // setup() 执行结果只能是函数或对象  // 1. 如果是对象，返回对象的所有属性当做状态处理，和 data 性质相同  // 2. 如果是函数，视为组件的 render 函数  // 即，支持在 setup 中直接手写 render 函数  handleSetupResult(instance, setupResult, isSSR); } } else { // ...  } } // handleSetupResult export function handleSetupResult( instance: ComponentInternalInstance, setupResult: unknown, isSSR: boolean ) { // 1. 如果是函数当做render函数处理  // 2. 如果是对象  if (isFunction(setupResult)) { // 返回内联 render 函数  if (__NODE_JS__ \u0026amp;\u0026amp; (instance.type as ComponentOptions).__ssrInlineRender) { // SSR 服务端渲染，替换 ssrRender 函数  // when the function\u0026#39;s name is `ssrRender` (compiled by SFC inline mode),  // set it as ssrRender instead.  instance.ssrRender = setupResult; } else { instance.render = setupResult as InternalRenderFunction; } } else if (isObject(setupResult)) { // 返回 bindings，这些变量可以直接在模板中使用  // 注意这里的 state 是 shallow ref，即非递归 reactive 的  instance.setupState = proxyRefs(setupResult); } else { // warn 必须返回对象  } // 最后完成render函数检查  // 可能是 SFC情况的 模板语法，没有直接的render函数，需要进行  // compile 操作生成 instance.rendder = Component.render函数  // render 执行不是这里，而是在 instance.update 的 effect 函数中的  // renderComponentRoot 中  finishComponentSetup(instance, isSSR); }     测试：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45  const { log, f, shuffle, runtime_test, renderChildren } = require(process.env .BLOG_DIR_VUE + \u0026#34;/lib.js\u0026#34;); import(process.env.BLOG_DIR_VUE + \u0026#34;/runtime-test.global.js\u0026#34;).then( async ({ h, render, nodeOps, serializeInner: inner, ref, nextTick, defineComponent, }) =\u0026gt; { const root = nodeOps.createElement(\u0026#34;div\u0026#34;); const logRoot = () =\u0026gt; log(\u0026#34;root: \u0026#34; + inner(root)); logRoot(); log(\u0026#34;\u0026gt;\u0026gt;\u0026gt;component setup return object\u0026#34;); let props, attrs; try { const Comp = defineComponent({ props: [\u0026#34;bar\u0026#34;], setup(_props, { attrs: _attrs }) { console.log(\u0026#34;setup...\u0026#34;); return () =\u0026gt; { props = _props; attrs = _attrs; }; }, }); render(h(Comp, { foo: 1, bar: 2 }), root); log([props, attrs]); render(h(Comp, { fooBar: 2, bar: 3, fooBaz: 4 }), root); log([props, attrs]); render(h(Comp, { qux: 5 }), root); log([props, attrs]); } catch (e) { log(e); } logRoot(); }, (err) =\u0026gt; { console.log(err.message); } );    undefinedroot: \u0026gt;\u0026gt;\u0026gt;component setup return object component stateful ? 4 call setup setup... [Function (anonymous)] render mount component normalize vnode patch component { bar: 2 } { foo: 1 } { bar: 2 } { foo: 1 } { bar: 2 } { foo: 1 } root:    component update   需要修改点：\n  在 processComponent 中增加 updateComponent 更新组件\n  在 instance.update effect 函数中增加 updateProps() diff-\u0026gt;update props\n   这里主要包含了 props 的更新规则，对于 children 的 diff 和 update 规则分析可以查 看 patchKeyedChildren diff 和 更新原理分析！\n 组件更新，代码执行流程：\n 状态变更 -\u0026gt; instance.update effect 执行 -\u0026gt;\n 如果有 next vnode 触发 updateComponentPreRender() 更新 props 和 slots\n 执行 beforeUpdate hook\n 执行 onVnodeBeforeUpdate hook\n 得到新树🌲 nextTree = renderComponentRoot(instance)\n 老树🌲 prevTree = instance.subTree\n 进行 patch(prevTree, nextTree) 操作\n 执行 updated hook 和 onVnodeUpdated hook\n 测试：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57  const { log, f, shuffle, runtime_test, renderChildren } = require(process.env .BLOG_DIR_VUE + \u0026#34;/lib.js\u0026#34;); import(process.env.BLOG_DIR_VUE + \u0026#34;/runtime-test.global.js\u0026#34;).then( async ({ h, render, nodeOps, serializeInner: inner, ref, nextTick, defineComponent, }) =\u0026gt; { const root = nodeOps.createElement(\u0026#34;div\u0026#34;); const logRoot = () =\u0026gt; log(\u0026#34;root: \u0026#34; + inner(root)); let oa = { a: 1 }, ob = { b: 1 }, i = 0, j = 0; const defaultFn = () =\u0026gt; (console.log(`fn called ${++i}`), oa); const defaultBaz = () =\u0026gt; (console.log(`baz called ${++j}`), ob); let proxy; logRoot(); try { const Comp = { props: { foo: { default: 1 }, bar: { default: defaultFn }, baz: { type: Function, default: defaultBaz }, }, render() { proxy = this; }, }; const print = (s) =\u0026gt; { log(\u0026#34;\u0026gt;\u0026gt;\u0026gt; \u0026#34; + s); const prevBar = proxy.bar; log(\u0026#34;proxy.foo = \u0026#34; + proxy.foo); // 因为无 type，而 default 是个函数，会被执行得到结果  log(\u0026#34;prevBar === oa: \u0026#34; + (prevBar === oa)); // 因为 type Function ，所以default 是 Function 的话不会被执行  log(\u0026#34;proxy.baz === defaultBaz, \u0026#34; + (proxy.baz === defaultBaz)); log(\u0026#34;proxy.bar === prevBar, \u0026#34; + (proxy.bar === prevBar)); }; render(h(Comp, { foo: 2 }), root); print(\u0026#34;first\u0026#34;); // update  render(h(Comp, { foo: 3 }), root); print(\u0026#34;update\u0026#34;); } catch (e) { log(e.message); } }, (err) =\u0026gt; { console.log(err.message); } );    undefinedroot: { type: { props: { foo: [Object], bar: [Object], baz: [Object] }, render: [Function: render] }, shapeFlag: 4 } fn called 1 component stateful ? 4 call setup no setup [Function: render] render mount component update effect normalize vnode patch component { type: Symbol(Comment), shapeFlag: 0 } \u0026gt;\u0026gt;\u0026gt; first proxy.foo = 2 prevBar === oa: true proxy.baz === defaultBaz, true proxy.bar === prevBar, true { type: { props: { foo: [Object], bar: [Object], baz: [Object] }, render: [Function: render], __props: [ [Object], [Array] ] }, shapeFlag: 4 } update component should update component has changed props should update component.... normal update update effect component update update comp pre render normalize vnode Cannot read property \u0026#39;parentNode\u0026#39; of null   ❓ 没有触发 instance.update ?\n fix: props update invalid · gcclll/stb-vue-next@3771bfb\n 修复后，回去重新测试。\n  FIX 增加代码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30  const updateComponent = (n1: VNode, n2: VNode, optimized: boolean) =\u0026gt; { console.log(\u0026#34;update component\u0026#34;); const instance = (n2.component = n1.component)!; if (shouldUpdateComponent(n1, n2, optimized)) { console.log(\u0026#34;should update component....\u0026#34;); if ( __FEATURE_SUSPENSE__ \u0026amp;\u0026amp; instance.asyncDep \u0026amp;\u0026amp; // async setup  instance.asyncResolved ) { // ...  return; } else { // 新增代码》》》》》》》》  // 正常更新  instance.next = n2; // 考虑到 child 组件可能正在队列中排队，移除它避免  // 在同一个 flush tick 重复更新同一个子组件  // 当下一次更新来到时，之前的一次更新取消？  invalidateJob(instance.update); // instance.update 是在 setupRenderEffect 中  // 定义的一个 reactive effect runner  // 主动触发更新  instance.update(); } return; } else { // ...  } };     ❓ Cannot read property \u0026#39;parentNode\u0026#39; of null\n 这个报错发生在 instance.update effect 的 else 更新组件中，\n patch(… hostParentNode(prevTree.el!)!, …)\n 的时候，去取值 prevTree.el 得到的是空值，进入 hostParentNode 调用 node.parentNode 报错的。\n 这里为什么 prevTree.el 是 null ? 更新的话之前的 node 不应该已经加载好了吗？\n   component slots   feat(add): init\u0026amp;update slots · gcclll/stb-vue-next@a788430\n 修改点：\n  初始化， setupComponent() 中的 initSlots()\n  updateComponent() -\u0026gt; updateComponentPreRender() 中 updateSlots() 更新 slots\n   对应动作： init -\u0026gt; update\n 对应组件阶段： 初始化(initSlots()) -\u0026gt; 更新(updateSlots())\n初始化(initSlots())：  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21  export const initSlots = ( instance: ComponentInternalInstance, children: VNodeNormalizedChildren ) =\u0026gt; { if (instance.vnode.shapeFlag \u0026amp; ShapeFlags.SLOTS_CHILDREN) { const type = (children as RawSlots)._ if (type) { instance.slots = children as InternalSlots // make compiler marker non-enumerable  def(children as InternalSlots, \u0026#39;_\u0026#39;, type) } else { normalizeObjectSlots(children as RawSlots, (instance.slots = {})) } } else { instance.slots = {} if (children) { normalizeVNodeSlots(instance, children) } } def(instance.slots, InternalObjectKey, 1) }     要分析整个，需要回顾下 normalizeChildren(vnode, children) 处理逻辑，要搞清楚什么 情况下会是 SLOTS_CHILDREN 。\n 根据 normalizeChildren() 的实现中，可知需要满足下面几个条件：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17  if (isObject(vnode.children)) { if (isElement(vnode.shapeFlag) || isTELEPORT(vnode.shapeFlag)) { // default slot  } else { // 非 ELEMENT 或 TELEPORT 类型  // 如： \u0026lt;Comp\u0026gt;\u0026lt;template v-slot:named\u0026gt;\u0026lt;div/\u0026gt;\u0026lt;/template\u0026gt;\u0026lt;/Comp\u0026gt;  // children 只有一个 template 会被解析成一个 vnode 对象  // 且 vnode type 是 template  type = ShapeFlags.SLOTS_CHILDREN; } } else if (isFunction(vnode.children)) { // children 是个函数  // 函数式组件 Comp = { render() {  // return h(\u0026#39;div\u0026#39;, null, () =\u0026gt; h(\u0026#39;div\u0026#39;) /* slot */)  // }}  type = ShapeFlags.SLOTS_CHILDREN; }      children = { _: ... } 内部插槽？\n  normalizeObjectSlots: children 是对象类型：\n {named: slotFn1, default: slotFn2 }\n 遍历所有 key-value =\u0026gt;\n (推荐)如果 value 是函数需要将 slotFn 用 withCtx 封装一层，让其在当前实例的上下文中正确✅执行。\n1 2 3 4 5 6 7 8 9  const normalizeSlot = ( key: string, rawSlot: Function, ctx: ComponentInternalInstance | null | undefined ): Slot =\u0026gt; withCtx((props: any) =\u0026gt; { // warn: 在 Render 函数外执行了 slot function  return normalizeSlotValue(rawSlot(props)); }, ctx);     (不推荐)如果 value 不是函数，经过\n1 2 3 4  const normalizeSlotValue = (value: unknown): VNode[] =\u0026gt; isArray(value) ? value.map(normalizeVNode) : [normalizeVNode(value as VNodeChild)]     处理之后转成函数赋值 slots[key] = () =\u0026gt; normalized\n 最终都是将 slot value 转成一个函数保存到 instance.slots{} 中\n  非 SLOTS_CHILDREN ，那只有一种情况\n children 中没有 \u0026lt;template v-slot:named ...\u0026gt; ，此时它所有的 child 都会被当做 默认插槽来处理。\n1 2 3 4 5 6 7  const normalizeVNodeSlots = ( instance: ComponentInternalInstance, children: VNodeNormalizedChildren ) =\u0026gt; { const normalized = normalizeSlotValue(children); instance.slots.default = () =\u0026gt; normalized; };     如：\n1 2 3 4 5 6 7 8 9 10 11 12 13  const { log, shuffle, runtime_test, renderChildren } = require(process.env .BLOG_DIR_VUE + \u0026#34;/lib.js\u0026#34;); import(process.env.BLOG_DIR_VUE + \u0026#34;/runtime-test.global.js\u0026#34;).then( async ({ h, createVNode: c }) =\u0026gt; { log.br(); const Comp = { template: \u0026#34;\u0026lt;div/\u0026gt;\u0026#34; }; const slot = () =\u0026gt; {}; const node = h(Comp, slot); log(\u0026#34;\u0026gt;\u0026gt;\u0026gt; 函数作为 children 解析为默认插槽\u0026#34;); log.f(node, [\u0026#34;children\u0026#34;, \u0026#34;type\u0026#34;]); log(node.children); } );    undefined \u0026gt;\u0026gt;\u0026gt; 函数作为 children 解析为默认插槽 { type: { template: \u0026#39;\u0026lt;div/\u0026gt;\u0026#39; }, children: { default: [Function: slot], _ctx: null } } { default: [Function: slot], _ctx: null }      更新(updateSlots())   更新插槽步骤：\n  合并 instance.slots 和 children\n  然后删除 children 中没有的插槽\n  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59  export const updateSlots = ( instance: ComponentInternalInstance, children: VNodeNormalizedChildren ) =\u0026gt; { const { vnode, slots } = instance; let needDeletionCheck = true; let deletionComparisonTarget = EMPTY_OBJ; console.log(\u0026#34;update slots\u0026#34;); // children 是 函数或对象类型(非数组)  if (vnode.shapeFlag \u0026amp; ShapeFlags.SLOTS_CHILDREN) { const type = (children as RawSlots)._; if (type) { console.log(\u0026#34;update slots type\u0026#34;); // compiled slots.  if (__DEV__ \u0026amp;\u0026amp; isHmrUpdating) { // TODO  } else if (type === SlotFlags.STABLE) { // compiled AND stable  // 不需要更新，跳过 slots 删除操作  needDeletionCheck = false; } else { // compiled but dynamic (v-if/v-for on slots)  // update slots, but skip normalization  extend(slots, children as Slots); } } else { console.log(\u0026#34;update slots no type\u0026#34;); needDeletionCheck = !(children as RawSlots).$stable; normalizeObjectSlots(children as RawSlots, slots); } // 对象类型直接合并，这里记录需要进行删除操作的对象，children  // 上面只是进行了简单的对象合并操作  // 如： slots={a,b,d}, children = {a,b,c}  // 合并之后： slots={a,b,c,d},后面需要删除的是 d 这个插槽  deletionComparisonTarget = children as RawSlots; } else if (children) { // \u0026lt;Comp\u0026gt;...这里没有 \u0026lt;template #named ...\u0026gt; 情况\u0026lt;/Comp\u0026gt;  // \u0026lt;Comp\u0026gt; 里面的所有内容都会被当做默认插槽来解析  console.log(\u0026#34;update slots children\u0026#34;); // non slot object children (direct value)  // passed to a component  // 当做默认插槽来处理，解析后： slots.default = () =\u0026gt; normalized  normalizeVNodeSlots(instance, children); // 这里目的是为了只保留 default 其他都需要删除  deletionComparisonTarget = { default: 1 }; } console.log({ needDeletionCheck }); // delete stale slots  // 删除旧的 slots  if (needDeletionCheck) { for (const key in slots) { // 非 `_` 内部插槽，且不再新的 children 中的  if (!isInternalKey(key) \u0026amp;\u0026amp; !(key in deletionComparisonTarget)) { delete slots[key]; } } } };        props tests   传入的 rawProps 和组件自身的 props 经过处理之后(setFullProps()) 会将 rawProps 根 据一定规则分派到组件 props 或 attrs 中去。\n 这里的 rawProps 代表是 parent 在渲染子组件的时候传递给它的 props ，如：\n render(h(Child, { foo:1, bar:2}),root)\n 中的 {foo:1,bar:2} 即 parent props，然后组件可以定义自身的 props 属性：\n defineComponent({ props: [\u0026#39;foo\u0026#39;] }) 意味着，该子组件只接受 \u0026#39;foo\u0026#39; 作为 props 而其他的会被解析成 attrs 。\n component props 测试：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42  const { log, f, shuffle, runtime_test, renderChildren } = require(process.env .BLOG_DIR_VUE + \u0026#34;/lib.js\u0026#34;); import(process.env.BLOG_DIR_VUE + \u0026#34;/runtime-test.global.js\u0026#34;).then( async ({ h, render, nodeOps, serializeInner: inner, ref, nextTick, defineComponent, }) =\u0026gt; { const root = nodeOps.createElement(\u0026#34;div\u0026#34;); const logRoot = () =\u0026gt; log(\u0026#34;root: \u0026#34; + inner(root)); logRoot(); log(\u0026#34;\u0026gt;\u0026gt;\u0026gt;stateful\u0026#34;); let props, attrs, proxy; try { const Comp = defineComponent({ props: [\u0026#34;fooBar\u0026#34;, \u0026#34;barBaz\u0026#34;, \u0026#34;foo-baz\u0026#34;], render() { console.log(\u0026#34;comp render\u0026#34;); props = this.$props; attrs = this.$attrs; proxy = this; }, }); render(h(Comp, { fooBar: 1, bar: 2, fooBaz: 3 }), root); } catch (e) { log(e); } console.log(\u0026#34;proxy.fooBar=\u0026#34; + proxy.fooBar); log([props, attrs]); logRoot(); }, (err) =\u0026gt; { console.log(err.message); } );    undefinedroot: \u0026gt;\u0026gt;\u0026gt;stateful { type: { props: [ \u0026#39;fooBar\u0026#39;, \u0026#39;barBaz\u0026#39;, \u0026#39;foo-baz\u0026#39; ], render: [Function: render] }, shapeFlag: 4 } component stateful ? 4 call setup no setup [Function: render] render mount component update effect normalize vnode comp render patch component { type: Symbol(Comment), shapeFlag: 0 } proxy.fooBar=1 { fooBar: 1, fooBaz: 3 } { bar: 2 } root:    component unmount   feat(add): add unmount component · gcclll/stb-vue-next@79c5061\n 主要工作：\n  执行 beforeUnmount 周期函数\n  停掉所有 effects 依赖\n  检查 update 函数，处理在异步 update 之前执行了 unmount\n  在 post queue 中执行 unmounted 周期函数\n  在 post queue 中标记 instance.isUnmounted=true 标记组件已经卸载了\n   三种队列任务， pre, post, job 执行顺序： pre \u0026gt; job \u0026gt; post，详情查看\n scheduler 任务调度机制\n 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33  const unmountComponent = ( instance: ComponentInternalInstance, parentSuspense: SuspenseBoundary | null, doRemove?: boolean ) =\u0026gt; { const { bum, effects, update, subTree, um } = instance; // beforeUnmount hook  if (bum) { invokeArrayFns(bum); } if (effects) { for (let i = 0; i \u0026lt; effects.length; i++) { stop(effects[i]); } } // update may be null if a component is unmounted before its async  // setup has resolved.  if (update) { stop(update); unmount(subTree, instance, parentSuspense, doRemove); } // unmounted hook  if (um) { queuePostRenderEffect(um, parentSuspense); } queuePostRenderEffect(() =\u0026gt; { instance.isUnmounted = true; }, parentSuspense); // TODO suspense };      normalize emits options   feat(add): props event init · gcclll/stb-vue-next@b918dde\n  问题  TypeError: Cannot read property \u0026#39;allowRecurse\u0026#39; of null  TypeError: Cannot read property \u0026#39;allowRecurse\u0026#39; of null at createReactiveEffect (/Users/simon/blog/cheng92.com/static/js/vue/runtime-test.global.js:251:39) at effect (/Users/simon/blog/cheng92.com/static/js/vue/runtime-test.global.js:199:22) at setupRenderEffect (/Users/simon/blog/cheng92.com/static/js/vue/runtime-test.global.js:2738:29) at mountComponent (/Users/simon/blog/cheng92.com/static/js/vue/runtime-test.global.js:2733:11) at processComponent (/Users/simon/blog/cheng92.com/static/js/vue/runtime-test.global.js:2724:19) at patch (/Users/simon/blog/cheng92.com/static/js/vue/runtime-test.global.js:2616:23) at render (/Users/simon/blog/cheng92.com/static/js/vue/runtime-test.global.js:3099:15) at /private/var/folders/1n/xw58p9v90tn42m87q527fvgr0000gn/T/babel-orafVD/js-script-Vmw0ga:29:5   因为实现问题：\n1 2 3 4 5 6 7 8 9  instance.update = effect(function componentEffect() { // 监听更新  if (!instance.isMounted) { // 还没加载完成，可能是第一次 mount 操作  // TODO  } else { // TODO  } }, __DEV__ ? /* TODO */ (null as any) : prodEffectOptions)     文字内的测试是基于 node development 环境测试的，这里 effect options 是 null 所以 报错。\n fix: effect null options · gcclll/stb-vue-next@63675a4\n      processText|Comment|Static   feat(add): processText updte · gcclll/stb-vue-next@636e870 · GitHub\n 本节包含(主要源码，没啥好分析的)：\n  文本节点\n  注释节点\n  静态节点\n  Text  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  const processText: ProcessTextOrCommentFn = (n1, n2, container, anchor) =\u0026gt; { if (n1 == null /* old */) { // 新节点，插入处理  hostInsert( (n2.el = hostCreateText(n2.children as string)), container, anchor ); } else { // has old vnode, need to diff  const el = (n2.el = n1.el!); if (n2.children !== n1.children) { hostSetText(el, n2.children as string); } } };     因为在 compiler-core parse 阶段的文本处理中，如果是响铃的文本节点会被合并，如：\n \u0026lt;div\u0026gt;{{ text1 }} {{ text2 }}\u0026lt;/div\u0026gt; 最终会合并：\n \u0026lt;div\u0026gt;{{ text1 + \u0026#39; \u0026#39; + text2 }}\u0026lt;/div\u0026gt; 最终替换的是 \u0026lt;div/\u0026gt; 整个内容。\n  Comment   feat(add): process comment node · gcclll/stb-vue-next@4489366 · GitHub\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17  const processCommentNode: ProcessTextOrCommentFn = ( n1, n2, container, anchor ) =\u0026gt; { if (n1 == null) { hostInsert( (n2.el = hostCreateComment((n2.children as string) || \u0026#39;\u0026#39;)), container, anchor ) } else { // there\u0026#39;s no support for dynamic comments  n2.el = n1.el } }      Static   patch -\u0026gt; case Static:\n1 2 3 4 5 6 7  // case Static: if (n1 == null) { mountStaticNode(n2, container, anchor, isSVG); } else if (__DEV__) { patchStaticNode(n1, n2, container, isSVG); } // break      没有 old vnode -\u0026gt; mount\n 有 old node -\u0026gt; patch\n mount:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  const mountStaticNode = ( n2: VNode, container: RendererElement, anchor: RendererNode | null, isSVG: boolean ) =\u0026gt; { // static nodes are only present when used with compiler-dom/runtime-dom  // which guarantees presence of hostInsertStaticContent.  [n2.el, n2.anchor] = hostInsertStaticContent!( n2.children as string, container, anchor, isSVG ); };     mount 时用到的 hostInsertStaticContent() 是在 runtime-dom 包中实现的，先预览下 代码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  function insertStaticContent(content, parent, anchor, isSVG) { const temp = isSVG ? tempSVGContainer || (tempSVGContainer = doc.createElementNS(svgNS, \u0026#34;svg\u0026#34;)) : tempContainer || (tempContainer = doc.createElement(\u0026#34;div\u0026#34;)); temp.innerHTML = content; const first = temp.firstChild as Element; let node: Element | null = first; let last: Element = node; while (node) { last = node; nodeOps.insert(node, parent, anchor); node = temp.firstChild as Element; } return [first, last]; }     可以看到 temp.innerHTML = content 一个简单的内容全替换操作。\n patchStaticNode: 因为静态节点在生产环境中会被提升，重用，因此不存在 patch 阶段。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23  const patchStaticNode = ( n1: VNode, n2: VNode, container: RendererElement, isSVG: boolean ) =\u0026gt; { // static nodes are only patched during dev for HMR  if (n2.children !== n1.children) { const anchor = hostNextSibling(n1.anchor!); // remove existing  removeStaticNode(n1); // insert new  [n2.el, n2.anchor] = hostInsertStaticContent!( n2.children as string, container, anchor, isSVG ); } else { n2.el = n1.el; n2.anchor = n1.anchor; } };     moveStaticNode: 在 diff -\u0026gt; update 阶段 move() 中触发\n1 2 3 4 5 6 7 8 9 10 11 12 13  const moveStaticNode = ( { el, anchor }: VNode, container: RendererElement, nextSibling: RendererNode | null ) =\u0026gt; { let next; while (el \u0026amp;\u0026amp; el !== anchor) { next = hostNextSibling(el); hostInsert(el, container, nextSibling); el = next; } hostInsert(anchor!, container, nextSibling); };     removeStaticNode: remove() 中触发\n1 2 3 4 5 6 7 8 9  const removeStaticNode = ({ el, anchor }: VNode) =\u0026gt; { let next; while (el \u0026amp;\u0026amp; el !== anchor) { next = hostNextSibling(el); hostRemove(el); el = next; } hostRemove(anchor!); };        processFragment   Fragment 的情况： children 有多个 child 的时候，会用一个 fragment 事先包起来。\n  STABLE_FRAGMENT 情况：\n  v-if\n 首先要满足 children.length !== 1 即有一个以上的 children, 如：\n \u0026lt;div\u0026gt;\u0026lt;p/\u0026gt;\u0026lt;p/\u0026gt;\u0026lt;/div\u0026gt;\n 或者非第一个 child ELEMENT 类型，如：\n \u0026lt;div\u0026gt;\u0026lt;Comp/\u0026gt;\u0026lt;/div\u0026gt;\n 其要满足 (children.length === 1 \u0026amp;\u0026amp; firstChild.type === NodeTypes.FOR) 如：\n \u0026lt;div v-for=\u0026#34;item in list\u0026#34;\u0026gt;\u0026lt;p/\u0026gt;\u0026lt;/div\u0026gt;\n 才会被当做 PatchFlags.STABLE_FRAGMENT\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  // vIf.ts  const needFragmentWrapper = children.length !== 1 || firstChild.type !== NodeTypes.ELEMENT; if (needFragmentWrapper) { if (children.length === 1 \u0026amp;\u0026amp; firstChild.type === NodeTypes.FOR) { // ...  } else { return createVNodeCall( // ...  PatchFlags.STABLE_FRAGMENT + (__DEV__ ? ` /* ${PatchFlagNames[PatchFlags.STABLE_FRAGMENT]}*/` : ``), // ...  ); } }      v-for\n1 2 3 4 5 6 7 8 9  // vFor.ts  const isStableFragment = forNode.source.type === NodeTypes.SIMPLE_EXPRESSION \u0026amp;\u0026amp; forNode.source.constType \u0026gt; 0 const fragmentFlag = isStableFragment ? PatchFlags.STABLE_FRAGMENT : keyProp ? PatchFlags.KEYED_FRAGMENT : PatchFlags.UNKEYED_FRAGMENT       源码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88  const processFragment = ( n1: VNode | null, n2: VNode, container: RendererElement, anchor: RendererNode | null, parentComponent: ComponentInternalInstance | null, parentSuspense: SuspenseBoundary | null, isSVG: boolean, optimized: boolean ) =\u0026gt; { const fragmentStartAnchor = (n2.el = n1 ? n1.el : hostCreateText(\u0026#39;\u0026#39;))! const fragmentEndAnchor = (n2.anchor = n1 ? n1.anchor : hostCreateText(\u0026#39;\u0026#39;))! let { patchFlag, dynamicChildren } = n2 if (patchFlag \u0026gt; 0) { optimized = true } if (__DEV__ \u0026amp;\u0026amp; isHmrUpdating) { // HMR updated, force full diff  patchFlag = 0 optimized = false dynamicChildren = null } if (n1 == null) { hostInsert(fragmentStartAnchor, container, anchor) hostInsert(fragmentEndAnchor, container, anchor) // fragment 的 children 只会是 array children  // 因为他们要么是通过 compiler 生成的，要么是由数组创建的  mountChildren( n2.children as VNodeArrayChildren, container, fragmentEndAnchor, parentComponent, parentSuspense, isSVG, optimized ) } else { if ( patchFlag \u0026gt; 0 \u0026amp;\u0026amp; patchFlag \u0026amp; PatchFlags.STABLE_FRAGMENT \u0026amp;\u0026amp; dynamicChildren \u0026amp;\u0026amp; // #2715 the previous fragment could\u0026#39;ve been a BAILed one as a result  // of renderSlot() with no valid children  n1.dynamicChildren ) { // a stable fragment (template root or \u0026lt;template v-for\u0026gt;) doesn\u0026#39;t need to  // patch children order, but it may contain dynamicChildren.  patchBlockChildren( n1.dynamicChildren, dynamicChildren, container, parentComponent, parentSuspense, isSVG ) if (__DEV__ \u0026amp;\u0026amp; parentComponent \u0026amp;\u0026amp; parentComponent.type.__hmrId) { traverseStaticChildren(n1, n2) } else if ( // #2080 if the stable fragment has a key, it\u0026#39;s a \u0026lt;template v-for\u0026gt; that may  // get moved around. Make sure all root level vnodes inherit el.  // #2134 or if it\u0026#39;s a component root, it may also get moved around  // as the component is being moved.  n2.key != null || (parentComponent \u0026amp;\u0026amp; n2 === parentComponent.subTree) ) { traverseStaticChildren(n1, n2, true /* shallow */) } } else { // keyed / unkeyed, or manual fragments.  // for keyed \u0026amp; unkeyed, since they are compiler generated from v-for,  // each child is guaranteed to be a block so the fragment will never  // have dynamicChildren.  patchChildren( n1, n2, container, fragmentEndAnchor, parentComponent, parentSuspense, isSVG, optimized ) } } }      TELEPORT   feat(init): Teleport · gcclll/stb-vue-next@0fcfa32 · GitHub\n 新增代码:   TeleportImpl: 组件模板\n1 2 3 4 5 6 7  export const TeleportImpl = { __isTeleport: true, process() {}, remove() {}, move: moveTeleport, hydrate: hydrateTeleport }     resolveTarget: 根据选择器找到目标元素\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19  const resolveTarget = \u0026lt;T = RendererElement\u0026gt;( props: TeleportProps | null, select: RendererOptions[\u0026#39;querySelector\u0026#39;] ): T | null =\u0026gt; { const targetSelector = props \u0026amp;\u0026amp; props.to if (isString(targetSelector)) { if (!select) { // 无效选择器  return null } else { const target = select(targetSelector) // Teleport 设置失败  return target as any } } else { // 无效的 Teleport 目标  return targetSelector as any } }     moveTeleport: 执行移动\n1 2 3 4 5 6 7 8 9  function moveTeleport( vnode: VNode, container: RendererElement, parentAnchor: RendererNode | null, { o: { insert }, m: move }: RendererInternals, moveType: TeleportMoveTypes = TeleportMoveTypes.REORDER ) { // TODO }     hydrateTeleport:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20  function hydrateTeleport( node: Node, vnode: TeleportVNode, parentComponent: ComponentInternalInstance | null, parentSuspense: SuspenseBoundary | null, optimized: boolean, { o: { nextSibling, parentNode, querySelector } }: RendererInternals\u0026lt;Node, Element\u0026gt;, hydrateChildren: ( node: Node | null, vnode: VNode, container: Element, parentComponent: ComponentInternalInstance | null, parentSuspense: SuspenseBoundary | null, optimized: boolean ) =\u0026gt; Node | null ): Node | null { return vnode.anchor \u0026amp;\u0026amp; nextSibling(vnode.anchor as Node) }     导出组件 ~Teleport~：\n1 2 3 4  // Force-casted public typing for h and TSX props inference export const Teleport = (TeleportImpl as any) as { __isTeleport: true new (): { $props: VNodeProps \u0026amp; TeleportProps }      process()  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72  function process(/*省略参数*/) { // ...  const disabled = isTeleportDisabled(n2.props); const { shapeFlag, children } = n2; if (n1 == null) { // insert anchors in the main view  // \u0026lt;container\u0026gt;\u0026lt;placeholder/\u0026gt;\u0026lt;anchor/\u0026gt;\u0026lt;/container\u0026gt;  insert(placeholder, container, anchor); // \u0026lt;container\u0026gt;\u0026lt;main-anchor/\u0026gt;\u0026lt;anchor/\u0026gt;\u0026lt;/container\u0026gt;  insert(mainAnchor, container, anchor); // 根据选择器 \u0026lt;Teleport to=\u0026#34;selector\u0026#34;/\u0026gt; selector  // 找到目标 DOM 元素  const target = (n2.target = resolveTarget(n2.props, querySelector)); // \u0026lt;target\u0026gt;\u0026lt;!-- \u0026#39;\u0026#39; --\u0026gt;\u0026lt;/target\u0026gt;，用来作为插入时的参考节点  const targetAnchor = (n2.targetAnchor = createText(\u0026#34;\u0026#34;)); if (target) { insert(targetAnchor, target); // #2652 we could be teleporting from a non-SVG tree into an SVG tree  isSVG = isSVG || isTargetSVG(target); } /* else if warn ... */ const mount = (container: RendererElement, anchor: RendererNode) =\u0026gt; { // 将 vnode children 渲染到 target 元素内  // 会插入到 anchor 的前面,如： ~\u0026lt;target\u0026gt;\u0026lt;children/\u0026gt;\u0026lt;!--\u0026#39;\u0026#39;--\u0026gt;\u0026lt;/target\u0026gt;~  }; if (disabled) { // 失效状态，不直接渲染到目标元素中，而是挂在了 #app 内对应的  // 节点里面，等待状态 enable 再渲染回 target 元素  mount(container, mainAnchor); } else if (target) { // 直接渲染进目标元素  mount(target, targetAnchor); } } else { // update content  // 非首次渲染  n2.el = n1.el; // 已经渲染到 tar  if (n2.dynamicChildren) { // 动态子节点 patch  } else if (!optimized) { // patch n1|n2 children  } if (disabled) { // n2 new teleport disabled -\u0026gt; n1 old target enabled  // n2 直接移到 #app 结构中的 container 上，暂时不直接渲染到  // 目标元素上  if (!wasDisabled) { // moveTeleport  } } else { // target changed  // teleport 的 to 属性值发生了变化，找到新的目标  // 进行移动  if ((n2.props \u0026amp;\u0026amp; n2.props.to) !== (n1.props \u0026amp;\u0026amp; n1.props.to)) { // 1. 找新目标  // 2. 将 n2 移动到新的目标中  // ...  } else if (wasDisabled) { // 状态变更  // disabled -\u0026gt; enabled  // move into teleport target  // 从 container 中将 n2 移到目标元素中  } } } }     对于 teleport 的 mount 和 update 两个共同点(也是重点)：\n  当 new teleport 是 disabled 时，不直接渲染到目标元素中，而是挂在当前 container 中待用\n  当 new teleport 状态 enabled 时，不论 old 什么状态，都会讲新的 teleport children 渲染到目标元素下面。\n   Teleport 的移动类型有：\n  TARGET_CHANGE 目标发生了变化， teleport 的 to 属性变化\n1 2 3 4  // move target anchor if this is a target change. if (moveType === TeleportMoveTypes.TARGET_CHANGE) { insert(vnode.targetAnchor!, container, parentAnchor); }      TOGGLE 状态发生了变化 enable -\u0026gt; disable 或 disable -\u0026gt; enable\n  REORDER 目标元素内进行重新排序 ?\n1 2 3 4  // move main view anchor if this is a re-order. if (isReorder) { insert(anchor!, container, parentAnchor); }        TODO 测试  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26  const { log, f, shuffle, runtime_test, renderChildren } = require(process.env .BLOG_DIR_VUE + \u0026#34;/lib.js\u0026#34;); import(process.env.BLOG_DIR_VUE + \u0026#34;/runtime-test.global.js\u0026#34;).then( ({ h, render, Teleport, nodeOps, serializeInner: inner, ref }) =\u0026gt; { const target = nodeOps.createElement(\u0026#34;div\u0026#34;); const root = nodeOps.createElement(\u0026#34;div\u0026#34;); try { render( h(() =\u0026gt; [ h(Teleport, { to: target }, h(\u0026#34;div\u0026#34;, \u0026#34;teleported\u0026#34;)), h(\u0026#34;div\u0026#34;, \u0026#34;root\u0026#34;), ]), root ); } catch (e) { console.log(e.message); } log([\u0026#34;\u0026gt;\u0026gt;\u0026gt; root\u0026#34;, inner(root)]); log([\u0026#34;\u0026gt;\u0026gt;\u0026gt; target\u0026#34;, inner(target)]); }, (err) =\u0026gt; { console.log(err.message); } );    undefinedcomponent stateful ? 0 mount component update effect patch component \u0026gt;\u0026gt;\u0026gt; root \u0026gt;\u0026gt;\u0026gt; target   ❓ 没结果！！！！！！\n     SUSPENSE   feat(add): suspense · gcclll/stb-vue-next@fd651ab\n Suspense 组件和 Teleport 一样的组织结构和使用方式\n 结构：\n1 2 3 4  var Tmpl = { __isSuspense: true, process() {} }     然后在 process 中处理 mount 或 patch 流程，这里面和普通标签或普通组件的处理是一 样的， mount or patch。\n 下面来看下这个组件是如何实现的，功能又是如何？\n 新增函数：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17  // 1. 模板 // 根据注释说明，之所以采用这种结构是为了能让 Suspense 适用 tree-shaking export const SuspenseImpl = { __isSuspense: true, process(n1: VNode | null, n2: VNode /*...*/) { if (n1 == null) { // mount  } else { // patch  } }, hydrate: hydrateSuspense, create: createSuspenseBoundary, }; // 2. mountSuspense // 3. patchSuspense      列表：\n   名称 描述     SuspenseImpl -   mountSuspense() -   patchSuspense() -   SuspenseBoundary -   createSuspenseBoundary() -   hydrateSuspense() -     脑图：\n  重点逻辑：\n  Suspense 的渲染转折点发生在 mountComponent 中，将 setupRenderEffect 做了 一次封装，让其在 setup() 返回的 Promise 状态完成之后去执行\n  在整个 Suspense mount 或 patch 过程中，使用了 suspense.deps 来记录异步事件， 只有当这个值为 0 的时候说明可以进行解析并挂在到真实DOM上了(比如. 服务器端数 据请求完成)\n   SuspenseBoundary 数据结构   只列出部分与 Suspense 关联性强的字段：\n   名称 描述     vnode VNode 结构   hiddenContainer -   activeBranch 请求完成之后显示的组件分支 #default   pendingBranch 请求中显示的分支 #fallback   deps 组件依赖   timeout 超时时间   isInFallback -   isHydrating -   effects [] 依赖列表   resolve(force) -   fallback() 参数： fallbackVnode   move() -   next() -   registerDep() 注册实例依赖    1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31  export interface SuspenseBoundary { vnode: VNode\u0026lt;RendererNode, RendererElement, SuspenseProps\u0026gt;; parent: SuspenseBoundary | null; parentComponent: ComponentInternalInstance | null; isSVG: boolean; container: RendererElement; hiddenContainer: RendererElement; anchor: RendererNode | null; activeBranch: VNode | null; pendingBranch: VNode | null; deps: number; pendingId: number; timeout: number; isInFallback: boolean; isHydrating: boolean; isUnmounted: boolean; effects: Function[]; resolve(force?: boolean): void; fallback(fallbackVNode: VNode): void; move( container: RendererElement, anchor: RendererNode | null, type: MoveType ): void; next(): RendererNode | null; registerDep( instance: ComponentInternalInstance, setupRenderEffect: SetupRenderEffectFn ): void; unmount(parentSuspense: SuspenseBoundary | null, doRemove?: boolean): void; }      mountSuspense()   feat(add): suspense mount · gcclll/stb-vue-next@802b9ad\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60  function mountSuspense() { const { p: patch, o: { createElement }, } = rendererInternals; const hiddenContainer = createElement(\u0026#34;div\u0026#34;); const suspense = (vnode.suspense = createSuspenseBoundary( vnode, parentSuspense, parentComponent, container, hiddenContainer, anchor, isSVG, optimized, rendererInternals )); // start mounting the content subtree in an off-dom container  patch( null, (suspense.pendingBranch = vnode.ssContent!), hiddenContainer, null, parentComponent, suspense, isSVG ); // now check if we have encountered any async deps  if (suspense.deps \u0026gt; 0) { // has async  // mount the fallback tree  patch( null, vnode.ssFallback!, container, anchor, parentComponent, null, // fallback tree will not have suspense context  isSVG ); setActiveBranch(suspense, vnode.ssFallback!); } else { // Suspense has no async deps. Just resolve.  suspense.resolve(); } } // 设置激活的 branch function setActiveBranch(suspense: SuspenseBoundary, branch: VNode) { suspense.activeBranch = branch; const { vnode, parentComponent } = suspense; const el = (vnode.el = branch.el); // in case suspense is the root node of a component,  // recursively update the HOC el  if (parentComponent \u0026amp;\u0026amp; parentComponent.subTree === vnode) { parentComponent.vnode.el = el; updateHOCHostEl(parentComponent, el); } }      创建一个 DOM 之后的 div，即还没渲染到 DOM 结构中的\n  构建 Suspense 组件结构，这个结构非 VNode ，而是挂在 vnode.suspense 上的一个 SuspenseBoundary 结构\n  开始 mount 内容里的子树\n  检测 Suspense 有没异步依赖，如果有，则需要先解析这些异步依赖，完成之后再激活 branch\n  没有异步依赖直接拿到结果解析出组件\n   也就是说这里面需要重点关注的其实是“有没异步依赖的问题”。\n 没有依赖的时候用到了 suspense.resolve() 这个应该是将创建的 off-dom div 挂到真 实 DOM 上去。\n  suspense.resolve()  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88  function resolve(resume = false) { const { vnode, activeBranch, pendingBranch, pendingId, effects, parentComponent, container, } = suspense; if (suspense.isHydrating) { suspense.isHydrating = false; } else if (!resume) { // 1. transition 支持，将 move() 操作注册到 afterLeave 回调  // 2. 卸载当前的 subTree 可能是 fallback  // 3. 不是 transition dely enter 进行 move()  // 这里最后执行的操作就是 move() 如果是 transition delay enter  // 则将 move() 注册到 afterLeave，否则直接执行 move() 将 suspense  // 内容渲染到真实DOM上  const delayEnter = activeBranch \u0026amp;\u0026amp; pendingBranch!.transition \u0026amp;\u0026amp; pendingBranch!.transition.mode === \u0026#34;out-in\u0026#34;; if (delayEnter) { activeBranch!.transition!.afterLeave = () =\u0026gt; { if (pendingId === suspense.pendingId) { move(pendingBranch!, container, anchor, MoveType.ENTER); } }; } // this is initial anchor on mount  let { anchor } = suspense; // unmount current active tree  if (activeBranch) { // if the fallback tree was mounted, it may have been moved  // as part of a parent suspense. get the latest anchor for insertion  anchor = next(activeBranch); unmount(activeBranch, parentComponent, suspense, true); } if (!delayEnter) { // move content from off-dom container to actual container  move(pendingBranch!, container, anchor, MoveType.ENTER); } } // 标记当前激活状态的分支，此时是 #default  setActiveBranch(suspense, pendingBranch!); suspense.pendingBranch = null; suspense.isInFallback = false; // flush buffered effects  // check if there is a pending parent suspense  // 注册的 effect 处理，这里的处理说明了 suspense 的父子依赖执行  // 的顺序问题， effects 是按照数组加入顺序执行的(详情可以查看 reactivity 文章)  // 所以 effects 的优先级是自上而下的，即 parent-parent \u0026gt; parent \u0026gt; children  let parent = suspense.parent; let hasUnresolvedAncestor = false; while (parent) { if (parent.pendingBranch) { // found a pending parent suspense, merge buffered post jobs  // into that parent  parent.effects.push(...effects); hasUnresolvedAncestor = true; break; } parent = parent.parent; } // no pending parent suspense, flush all jobs  // 如果没有挂起的 parent suspense 直接 flush 掉所有任务  // 结合上面的 while 举例：  // CompA -\u0026gt; CompB -\u0026gt; CompC  // 当解析到 CompC 时，一直往上检测 B 和 A 如果 B 有挂起的任务  // C 这里的任务不会被 flush，而是加入到 B 的队列等待执行  // 然后 C 解析完成，回溯到 B 的解析，此时又遵循同一套规则检测 A 的  // 挂起任务，直到最后要么立即执行 B 的任务要么 B 的任务也加入到 A  // 最后由 A 执行所有的任务(包含子 suspense 的)  if (!hasUnresolvedAncestor) { queuePostFlushCb(effects); } suspense.effects = []; // invoke @resolve event  const onResolve = vnode.props \u0026amp;\u0026amp; vnode.props.onResolve; if (isFunction(onResolve)) { onResolve(); } }     分析如上面的注释， resolve() 主要目的就是将 off-dom div 上的 suspense 组件在异 步事件完成后根据结果解析出对应的分支，将这个分支挂载到真实的 DOM 上去，同时激活 它(显示出来)。\n 其他处理：\n  transition 的延迟进入处理，通过将 move() 操作注册到 afterLeave() 回调实现\n  effects 任务处理，这里的任务处理机制是：\n 只有在 parent 没有任何挂起的任务时候才会立即得到执行，否则只会进行合并操作。\n   因为代码最后需要执行 move() 操作将 #default 替换 #fallback ，所以下面先实 现 suspense.move() 再来测试。\n  suspense.move()   实现这个 move 有几个地方需要修改\n  SuspenseBoundary 中的 move()\n1 2 3 4 5 6 7  var foo = { move(container, anchor, type) { suspense.activeBranch \u0026amp;\u0026amp; move(suspense.activeBranch, container, anchor, type); suspense.container = container; }, };      renderer.ts 中的 move() 函数，实现 SUSPENSE 组件的处理\n1 2 3 4 5 6 7 8 9 10  const move = () =\u0026gt; { // ...  // SUSPENSE  if (__FEATURE_SUSPENSE__ \u0026amp;\u0026amp; shapeFlag \u0026amp; ShapeFlags.SUSPENSE) { console.log(\u0026#34;move suspense\u0026#34;); vnode.suspense!.move(container, anchor, moveType); return; } // ... };      另外 mountComponent 中漏了对 SUSPENSE 的处理\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22  const mountComponent = () =\u0026gt; { // ... create instance  // ... setupComponent  // setup() 是个异步函数，返回了 promise ，在 setupComponent  // 中会将 setup 执行结果赋值给 instance.asyncDep，即 SUSPENSE 处理  if (__FEATURE_SUSPENSE__ \u0026amp;\u0026amp; instance.asyncDep) { // 将 setupRenderEffect 注册到 parent deps 这里的 deps  // 执行由一定的规则, 如果 parent suspense 没有结束，child deps  // 不会立即执行，而是将它们合并到 parent suspense deps 中等待 parent 状态完成了才会执行，对于  // parent deps 也遵循这个规则，直到没有未完成的 parent suspense为止  parentSuspense \u0026amp;\u0026amp; parentSuspense.registerDep(instance, setupRenderEffect); // 这里等于是说先用一个注释节点占位，等异步完成之后替换  if (!initialVNode.el) { const placeholder = (instance.subTree = createVNode(Comment)); processCommentNode(null, placeholder, container!, anchor); } return; } // ... setupRenderEffect SUSPENSE 不会进入到这里  };       测试：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62  const { log, f, shuffle, runtime_test, renderChildren } = require(process.env .BLOG_DIR_VUE + \u0026#34;/lib.js\u0026#34;); import(process.env.BLOG_DIR_VUE + \u0026#34;/runtime-test.global.js\u0026#34;).then( async ({ nextTick, h, render, nodeOps, serializeInner: inner, ref, Suspense, }) =\u0026gt; { log.br() const deps = []; function defineAsyncComponent(comp, delay = 0) { return { setup(props, { slots }) { const p = new Promise((resolve) =\u0026gt; { setTimeout(() =\u0026gt; { resolve(() =\u0026gt; h(comp, props, slots)); }, delay); }); deps.push(p.then(() =\u0026gt; Promise.resolve())); return p; }, }; } const Async = defineAsyncComponent({ render() { return h(\u0026#34;div\u0026#34;, \u0026#34;async\u0026#34;); }, }); const Comp = { setup() { return () =\u0026gt; h(Suspense, null, { default: h(Async), fallback: h(\u0026#34;div\u0026#34;, \u0026#34;fallback\u0026#34;), }); }, }; const root = nodeOps.createElement(\u0026#34;div\u0026#34;); try { render(h(Comp), root); } catch (e) { console.log(e); } console.log(\u0026#34;before\u0026#34;); console.log(inner(root)); await Promise.all(deps); await nextTick(); console.log(\u0026#34;after\u0026#34;); console.log(inner(root)); }, (err) =\u0026gt; { console.log(err); } );    undefined component stateful ? 4 call setup [Function (anonymous)] render mount component update effect normalize vnode patch component component stateful ? 4 call setup mount component process element mount elment { shapeFlag: 9 } before \u0026lt;div\u0026gt;fallback\u0026lt;/div\u0026gt; [Function (anonymous)] render update effect normalize vnode patch component component stateful ? 4 call setup no setup [Function: render] render mount component update effect normalize vnode patch component process element mount elment { shapeFlag: 9 } moving... move component moving... move component moving... move host insert after \u0026lt;div\u0026gt;async\u0026lt;/div\u0026gt;   ❓. 结果发现并没变化？？？\nbefore \u0026lt;!----\u0026gt; after \u0026lt;!----\u0026gt;   既没有渲染 fallback 也没有渲染 default 的，为何？\n  上面的第二点有说到在 renderer.ts 的 mountComponent() 中增加了对 SUSPENSE 的处理，这里面有个注册依赖的动作，这里注册的是 setupRenderEffect 函数，这个函 数正是用来 mount \u0026amp; update 组件的，而在 components/Suspense.ts 中并没有实现，所 以问题就出在这里了！！！\n FIX： suspense.registerDep()\n  suspense.registerDep()   feat(add): suspense registerDeps · gcclll/stb-vue-next@e0fa81e\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54  function registerDep(instance, setupRenderEffect) { const isInPendingSuspense = !!suspense.pendingBranch; if (isInPendingSuspense) { suspense.deps++; } const hydratedEl = instance.vnode.el; // 捕获 setup 执行的异常，或接受执行的结果  instance .asyncDep!.catch((err) =\u0026gt; { handleError(err, instance, ErrorCodes.SETUP_FUNCTION); }) .then((asyncSetupResult) =\u0026gt; { // 当 setup() 的 promise 状态变更之后重试  // 因为在解析之前组件可能已经被卸载了  if ( instance.isUnmounted || suspense.isUnmounted || suspense.pendingId !== instance.suspenseId ) { return; } // 从该组件开始重试，状态标记为已经完成  instance.asyncResolved = true; const { vnode } = instance; handleSetupResult(instance, asyncSetupResult, false); if (hydratedEl) { // 虚拟节点可能在 async dep 状态完成之前被某个更新替换掉了  vnode.el = hydratedEl; } const placeHolder = !hydratedEl \u0026amp;\u0026amp; instance.subTree.el; setupRenderEffect( instance, vnode, // 组件可能在 resolve 之前被移除了  // 如果这个不是一个 hydration，instance.subTree 将会是个注释  // 占位节点  parentNode(hydratedEl || instance.subTree.el!), hydratedEl ? null : next(instance.subTree), suspense, isSVG, optimized ); if (placeHolder) { remove(placeHolder); } updateHOCHostEl(instance, vnode.el); // only decrease deps count if suspense is not already resolved  // 没有任何依赖了就开始解析 Suspense  if (isInPendingSuspense \u0026amp;\u0026amp; --suspense.deps === 0) { suspense.resolve(); } }); }     这个函数主要实现点：\n  接受 setup() 执行的结果(Promise) asyncSetupResult 并捕获异常，对结果进行 分析处理\n  检测组件是不是已经卸载了，或者 suspense 被移除，就不需要继续处理了，退出即可\n1 2 3 4 5 6 7  if ( instance.isUnmounted || suspense.isUnmounted || suspense.pendingId !== instance.suspenseId ) { return; }      使用 handleSetupResult(instance, asyncSetupResult, false) 处理 setup 执行结 果，到底是 render 还是状态，需要解析\n  然后执行 setupRenderEffect 执行组件的 mount 或 update 操作\n  移除占位的注释节点\n  suspense.deps 执行完成之后就可以开始解析 suspense 组件 进行 move 操作了。\n    patchSuspense()   suspense.unmount\u0026amp;fallback\u0026amp;其他   feat(add): suspense unmount \u0026amp; fallback… · gcclll/stb-vue-next@080898d\n 新增：\n  patchSuspense() 和其他普通类型的处理差不多，无非就是检测 old 和 new branch 的 类型，进行 patch()，期间触发 onPending 事件\n  suspense.fallback() 处理，当异步事件未完成时显示的 #fallback 分支处理，期间 触发 onFallback 事件\n  suspense.unmount() 检测 activeBranch 和 pendingBranch 先卸载 active 随后卸载 pending 分支(前提是存在的情况下)\n    Suspense 组件测试  1 2  // `/js/vue/tests/Suspense.js\u0026#39; require(process.env.BLOG_DIR_VUE + \u0026#34;/tests/Suspense.js\u0026#34;);      小结   SUSPENSE 组件的大致执行流程\n  patch 进入 switch default 检测到 shapeFlag 是 SUSPENSE\n  调用 type.process(n1,n2,…) 处理 Suspense 组件，根据 n1 决定是 mountSuspense 还是 patchSuspense 这里和其他类型组件处理逻辑一致\n  首次(mount), 进行 mountSuspense 创建 Suspense 组件，对 pendingBranch 进行 patch 操作 (挂在到一个非DOM树中的 \u0026#39;div\u0026#39; 元素(off-dom)，待用)，即异步操作还未完成时显示 的分支，如： #fallback\n  非首次(update)，进行 patchSuspense 对比新旧的 branch 进行 patch\n   要点：在 mountComponent() 中不是直接调用 setupRenderEffect() 而是调 用 suspense.registerDep() 去处理 setup 执行的结果(instance.asyncDep)，它是 个Promise 在其后的 then() 中接受 setup 执行结果，然后开始调用 setupRenderEffect mount 或 update 子树节点，待 suspense 上的所有依赖都完成之后开始 resolve() Suspense 组件将其挂在到真实的 DOM 中。\n 原理： setup() 返回 Promise，render 过程中注册渲染函数，待 promise 状态完成调用 then 接受异步结果来渲染 Suspense 组件(任务为 post 类型)。\n     KEEP_ALIVE   feat(add): keep-alive render · gcclll/stb-vue-next@a192cb4\n KeepAlive 组件的 render 入口在 processComponent() 中，当 n1 == null 情况下， 会去检测该组件是不是 keep-alive 类型，如果是直接调用 activate() 激活。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  // 17. processComponent const processComponent = ( /*...*/) =\u0026gt; { if (n1 == null) { // mount - if (false /* keep alive */) { - // TODO + if (n2.shapeFlag \u0026amp; ShapeFlags.COMPONENT_KEPT_ALIVE) { + ;(parentComponent!.ctx as KeepAliveContext).activate( + n2, + container, + anchor, + isSVG, + optimized + )      unmount 操作时，如果是 keep-alive 直接调用 deactivate() 失效，而不是真正的从 DOM 移除。\n feat(add): keep-alive render unmount · gcclll/stb-vue-next@024b24b\n1 2 3 4 5 6 7 8 9 10  const unmount: UnmountFn = (...) =\u0026gt; { // ... - // TODO keep-alive - // keep-alive + if (shapeFlag \u0026amp; ShapeFlags.COMPONENT_SHOULD_KEEP_ALIVE) { + ;(parentComponent!.ctx as KeepAliveContext).deactivate(vnode) + return + } // ... }      在 mountComponent() 中：\n1 2 3 4 5 6 7 8 9 10 11  // 18. mountComponent const mountComponent: MountComponentFn = (...) =\u0026gt; { const instance: ComponentInternalInstance = (initialVNode.component = createComponentInstance( initialVNode, parentComponent, parentSuspense )) + if (isKeepAlive(initialVNode)) { + ;(instance.ctx as KeepAliveContext).renderer = internals + }      这里将 keep-alive 组件的 setup() 函数中用到的一些 renderer 函数保存引用到 ctx.renderer 上供后面 setup() 中使用。\n1 2 3 4 5 6  instance.ctx.renderer: { p: patch, m: move, um: _unmount, o: { createElement } }     keep-alive 作为内部组件，内置了 setup() 函数的实现，所以在\n patch -\u0026gt; processComponent -\u0026gt; mountComponent -\u0026gt; setupComponent\n 时调用的就是这个内置的 setup() 函数。\n setup() 函数体大致代码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39  function setup(props: KeepAliveProps, { slots }: SetupContext) { const cache: Cache = new Map(); const keys: Keys = new Set(); let current: VNode | null = null; const instance = getCurrentInstance()!; const parentSuspense = instance.suspense; const sharedContext = instance.ctx as KeepAliveContext; const { renderer: { p: patch, m: move, um: _unmount, o: { createElement }, }, } = sharedContext; const storageContainer = createElement(\u0026#34;div\u0026#34;); sharedContext.activate = (vnode, container, anchor, isSVG, optimized) =\u0026gt; {}; sharedContext.deactivate = (vnode: VNode) =\u0026gt; {}; // 对 renderer unmount 的一次封装  function unmount(vnode: VNode) {} // 过滤掉缓存  function pruneCache(filter?: (name: string) =\u0026gt; boolean) {} function pruneCacheEntry(key: CacheKey) {} // TODO 监听 include/exclude 属性变化  // TODO 在 render 之后缓存子树(subTree)  // TODO 注册生命周期  return () =\u0026gt; { // 该函数解析出原始 VNode 节点返回  }; }     上面代码提供了一下信息：\n  activate \u0026amp; deactivate() 函数是挂在 VNode 的 ctx 上的，并且是在 setup() 调 用期间产生\n  缓存机制\n  只注册了 mounted, unmounted, update 声明周期\n  最后返回的函数可以得到最原始的 VNode 节点\n   注意看 processComponent() 中的判断:\n if (n2.shapeFlag \u0026amp; ShapeFlags.COMPONENT_KEPT_ALIVE) { activate() }\n 而 COMPONENT_KEPT_ALIVE 标记的赋值又是发生在 setup() 函数中，也就是说对于 keep-alive 组件首次加载不会进入到 activate() 而是直接按照普通组件处理调用 mountComponent() 去调用 setup() 初始化该 keep-alive 组件的一些函数等(其中 就包含 activate 和 deactivate() 函数)\n 当状态发生变化时根据特定条件最后执行激活才会去调用 activate() 而不是进入 mountComponent()\n activate()   feat(add): keep-alive ctx.activate · gcclll/stb-vue-next@267fdbd\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26  sharedContext.activate = (vnode, container, anchor, isSVG, optimized) =\u0026gt; { const instance = vnode.component!; move(vnode, container, anchor, MoveType.ENTER, parentSuspense); // props 可能发生变化，这里执行一次 patch 操作  patch( instance.vnode, vnode, container, anchor, instance, parentSuspense, isSVG, optimized ); queuePostRenderEffect(() =\u0026gt; { instance.isDeactivated = false; if (instance.a) { // activated 周期函数  invokeArrayFns(instance.a); } const vnodeHook = vnode.props \u0026amp;\u0026amp; vnode.props.onVnodeMounted; if (vnodeHook) { invokeVNodeHook(vnodeHook, instance.parent, vnode); } }, parentSuspense); };     激活 keep-alive 组件的函数，只有当非首次的时候，状态发生变更时会被调用，注意上 面的任务类型 post ，周期函数的调用是异步发生的，会在下一个 tick 中赋值。\n  deactivate()   feat(add): keep-alive ctx.deactivate · gcclll/stb-vue-next@b340d57\n1 2 3 4 5 6 7 8 9 10 11 12 13 14  sharedContext.deactivate = (vnode: VNode) =\u0026gt; { const instance = vnode.component!; move(vnode, storageContainer, null, MoveType.LEAVE, parentSuspense); queuePostRenderEffect(() =\u0026gt; { if (instance.da) { invokeArrayFns(instance.da); } const vnodeHook = vnode.props \u0026amp;\u0026amp; vnode.props.onVnodeUnmounted; if (vnodeHook) { invokeVNodeHook(vnodeHook, instance.parent, vnode); } instance.isDeactivated = true; }, parentSuspense); };     如果看这里失活状态下组件是如何进行更新的？\n storageContainer 是在 setup 中创建的一个空的 off-dom div 元素，这里等于是当组 件失活时会将 keep-alive 先挂载到这个 off-dom div 上去.\n  unmount()   feat(add): keep-alive unmount · gcclll/stb-vue-next@4ce0b9b\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  // 对 renderer unmount 的一次封装 function unmount(vnode: VNode) { resetShapeFlag(vnode); _unmount(vnode, instance, parentSuspense); } function resetShapeFlag(vnode: VNode) { let shapeFlag = vnode.shapeFlag; if (shapeFlag \u0026amp; ShapeFlags.COMPONENT_SHOULD_KEEP_ALIVE) { shapeFlag -= ShapeFlags.COMPONENT_SHOULD_KEEP_ALIVE; } if (shapeFlag \u0026amp; ShapeFlags.COMPONENT_KEPT_ALIVE) { shapeFlag -= ShapeFlags.COMPONENT_KEPT_ALIVE; } vnode.shapeFlag = shapeFlag; }      include \u0026amp; exclude props   feat(add): keep-alive include \u0026amp; exclude props · gcclll/stb-vue-next@fdcc306\n 主要增加两个函数实现，一个监听动作(watch([include, exclude],...)):\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41  // 过滤掉缓存 function pruneCache(filter?: (name: string) =\u0026gt; boolean) { cache.forEach((vnode, key) =\u0026gt; { const name = getComponentName(vnode.type as ConcreteComponent); if (name \u0026amp;\u0026amp; (!filter || !filter(name))) { pruneCacheEntry(key); } }); } function pruneCacheEntry(key: CacheKey) { const cached = cache.get(key) as VNode; if (!current || cached.type !== current.type) { // 新增或节点类型发生变化，直接卸载掉老的  unmount(cached); } else if (current) { // 重置标记就可以了？  // 当前激活的实例不该再是 kept-alive  // 我们不能立即卸载但是稍后会进行卸载，所以这里先重置其标记  // 不能立即卸载？  // 是因为在 activate 和 deactivate 中的周期函数调用  // 是采用的 post 类型异步执行的缘故吗？  resetShapeFlag(current); } cache.delete(key); keys.delete(key); } // 监听 include/exclude 属性变化 watch( () =\u0026gt; [props.include, props.exclude], ([include, exclude]) =\u0026gt; { // 支持三种类型  // 1. 字符串, \u0026#39;a,b,c\u0026#39;  // 2. 正则表达式， /a|b|c/  // 3. 数组， [\u0026#39;a\u0026#39;, \u0026#39;b\u0026#39;, \u0026#39;c\u0026#39;, /d|e/]  include \u0026amp;\u0026amp; pruneCache((name) =\u0026gt; matches(include, name)); exclude \u0026amp;\u0026amp; pruneCache((name) =\u0026gt; !matches(exclude, name)); }, { flush: \u0026#34;post\u0026#34;, deep: true } );     include 指定需要缓存的组件名称\n exclude 指定不需要进行缓存的组件名称\n 类型： String, RegExp, Array\n  cache subtree   feat(add): keep-alive cache subtree · gcclll/stb-vue-next@efb7577\n 对 \u0026lt;keep-alive/\u0026gt; 的孩子节点🌲进行缓存。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28  // 在 render 之后缓存子树(subTree) let pendingCacheKey: CacheKey | null = null; const cacheSubtree = () =\u0026gt; { if (pendingCacheKey != null) { cache.set(pendingCacheKey, getInnerChild(instance.subTree)); } }; // 注册生命周期 onMounted(cacheSubtree); onUpdated(cacheSubtree); onBeforeUnmount(() =\u0026gt; { cache.forEach((cached) =\u0026gt; { const { subTree, suspense } = instance; const vnode = getInnerChild(subTree); if (cached.type === vnode.type) { // 有缓存的节点  // 当前实例会成为 keep-alive 的 unmount 一部分  resetShapeFlag(vnode); // 但是在这里执行它的 deactivated 钩子函数  const da = vnode.component!.da; da \u0026amp;\u0026amp; queuePostRenderEffect(da, suspense); return; } // 没有缓存的直接 unmount  unmount(cached); }); });     在 \u0026lt;keep-alive/\u0026gt; 卸载之前将已经缓存 deactivated 钩子函数推入队列等待执行，没 有缓存的直接调用 unmount() 卸载掉。\n  setup() -\u0026gt; render 函数   feat(add): keep-alive return render function · gcclll/stb-vue-next@9b75803\n 在 setupComponent() 中，最后调用 setup() 得到 setupResult ，最后会将这个 setupResult 传递给 handleSetupResult() 去处理，返回结果，这里面当检测到 setupResult 是个函数的时候，那么这个函数会被当做是 instance.render 函数处理。\n 即，这里的 setupResult 是 \u0026lt;keep-alive/\u0026gt; 组件 children 的 render 函数。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103  function setup() { // ...  return () =\u0026gt; { // 该函数解析出原始 VNode 节点返回  // 根据组件的执行流程，这个函数将会在 setupComponent() 中  // 执行 setup() 得到 setupResult ，传递给 handleSetupResult()  // 函数，这里面检测 setupResult 也就是这个匿名函数，如果它是函数  // 会直接被当做 render 函数处理(instance.render 或 instance.ssrRender)  // 结论就是，这个匿名函数是 render() 函数  pendingCacheKey = null; if (!slots.default) { // 组件支持默认插槽使用方式  return null; } const children = slots.default(); const rawVNode = children[0]; if (children.length \u0026gt; 1) { // KeepAlive 组件只能包含一个组件作为 child  // 也就是说 ~\u0026lt;keep-alive\u0026gt;\u0026lt;CompA/\u0026gt;\u0026lt;CompB/\u0026gt;\u0026lt;/keep-alive/\u0026gt;~  // 是不合法的使用  current = null; // warn...  return children; } else if ( !isVNode(rawVNode) || (!(rawVNode.shapeFlag \u0026amp; ShapeFlags.STATEFUL_COMPONENT) \u0026amp;\u0026amp; !(rawVNode.shapeFlag \u0026amp; ShapeFlags.SUSPENSE)) ) { // 1. 非 VNode 类型节点  // 2. 既不是有状态组件(对象类型组件)也不是 Suspense 的时候  // 相反意味着，节点必须满足下面几种情况  // 1. 是 VNode 类型且是有状态组件(非函数式组件)  // 2. 或者是 VNode 类型且是Suspense 组件  current = null; return rawVNode; } // 也就是说 keep-alive 只接受有状态组件或者 Suspense 作为唯一的 child  let vnode = getInnerChild(rawVNode); const comp = vnode.type as ConcreteComponent; const name = getComponentName(comp); const { include, exclude, max } = props; if ( // 无缓存的节点  (include \u0026amp;\u0026amp; (!name || !matches(include, name))) || // 在不缓存的节点们之列  (exclude \u0026amp;\u0026amp; name \u0026amp;\u0026amp; matches(exclude, name)) ) { current = vnode; return rawVNode; } const key = vnode.key == null ? comp : vnode.key; const cachedVNode = cache.get(key); // 克隆一份如果它有被复用的话，因为我们即将修改它  if (vnode.el) { vnode = cloneVNode(vnode); if (rawVNode.shapeFlag \u0026amp; ShapeFlags.SUSPENSE) { rawVNode.ssContent = vnode; } } pendingCacheKey = key; if (cachedVNode) { vnode.el = cachedVNode.el; vnode.component = cachedVNode.component; if (vnode.transition) { // 在 subTree 上递归更新 transition 钩子函数  setTransitionHooks(vnode, vnode.transition!); } // 避免 vnode 正在首次 mount  vnode.shapeFlag |= ShapeFlags.COMPONENT_KEPT_ALIVE; // 标记 key 为最新的  keys.delete(key); keys.add(key); } else { // 没有缓存的情况  keys.add(key); // 删除最老的 entry，缓冲池已经满了，删除掉最老的那个  if (max \u0026amp;\u0026amp; keys.size \u0026gt; parseInt(max as string, 10)) { // 因为 Set 没有直接取指定位置元素的值  // 这里的目的是变相的取 Set 中第一个元素，即最早 add 的那个 key  // 如： new Set([1,2,3,4]) =\u0026gt; keys.values() =\u0026gt; \u0026lt;1,2,3,4\u0026gt;  // next() 得到迭代器下一个值 { value: 1, done: false }  // .value 得到第一个集合元素的值  pruneCacheEntry(keys.values().next().value); } } // 避免 vnode 正在被卸载，在renderer unmount 中会检测  vnode.shapeFlag |= ShapeFlags.COMPONENT_SHOULD_KEEP_ALIVE; current = vnode; return rawVNode; }; }     最后返回的是 children[0] 节点。\n 里面有个置位标识值得注意： ShapeFlags.COMPONENT_SHOULD_KEEP_ALIVE\n 这个作用是啥？\n  unmount() 中调用 deactivate() 的条件\n1 2 3 4 5  // keep-alive if (shapeFlag \u0026amp; ShapeFlags.COMPONENT_SHOULD_KEEP_ALIVE) { (parentComponent!.ctx as KeepAliveContext).deactivate(vnode); return; }      instance.update 的 effect 中触发 activated 周期函数的条件\n1 2 3 4 5 6 7  // activated hook for keep-alive roots. // #1742 activated hook must be accessed after first render // since the hook may be injected by a child keep-alive const { a } = instance; if (a \u0026amp;\u0026amp; initialVNode.shapeFlag \u0026amp; ShapeFlags.COMPONENT_SHOULD_KEEP_ALIVE) { queuePostRenderEffect(a, parentSuspense); }        测试  1 2  // `/js/vue/tests/Suspense.js\u0026#39; require(process.env.BLOG_DIR_VUE + \u0026#34;/tests/KeepAlive.js\u0026#34;);    undefined Cannot read property \u0026#39;_vnode\u0026#39; of undefined   ⚠ 有错误，待完成。。。vue-next 测试见最后一章节《测试》\n     set ref   官方使用文档: Special Attributes | Vue.js\n 官方示例：\n1 2 3 4 5 6 7 8  \u0026lt;!-- vm.$refs.p will be the DOM node --\u0026gt; \u0026lt;p ref=\u0026#34;p\u0026#34;\u0026gt;hello\u0026lt;/p\u0026gt; \u0026lt;!-- vm.$refs.child will be the child component instance --\u0026gt; \u0026lt;child-component ref=\u0026#34;child\u0026#34;\u0026gt;\u0026lt;/child-component\u0026gt; \u0026lt;!-- When bound dynamically, we can define ref as a callback function, passing the element or component instance explicitly --\u0026gt; \u0026lt;child-component :ref=\u0026#34;(el) =\u0026gt; child = el\u0026#34;\u0026gt;\u0026lt;/child-component\u0026gt;     patch() 函数中对 ref 属性的处理(set ref)：\n feat(add): set ref · gcclll/stb-vue-next@a0a1344\n 源码实现主要有几个步骤：\n  ref 支持数据?\n  是不是异步组件 value = null\n  有状态组件(STATEFULL_COMPONENT, 分函数组件)\n value = vnode.component!.exposed || vnode.component!.proxy\n  其他情况下 value = vnode.el\n 即 2,3,4 都是为了设置 value 指向哪个引用，比如 vnode.el 在渲染之后会被赋值为当 前 vnode 对应的那个 DOM 元素。\n  断开 oldRef 引用\n  设置 ref，分三种情况\n  ref 是字符串直接 refs[ref] = value 取 key 设值\n  ref 是 Ref 类型， ref.value = value\n  ref 是函数类型， ref(value, refs) 调用\n     在设值的时候会根据 value 是否为空值来控制是否进行异步设置，等 Render 执行完 成之后再设置\n1 2 3 4 5 6  if (value) { (doSet as SchedulerCb).id = -1; queuePostRenderEffect(doSet, parentSuspense); } else { doSet(); }     源码:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98  const patch: PatchFn = (/*...*/) =\u0026gt; { // ...  // set ref  setRef(ref, n1 \u0026amp;\u0026amp; n1.ref, parentSuspense, n2); }; export const setRef = ( rawRef: VNodeNormalizedRef, oldRawRef: VNodeNormalizedRef | null, parentSuspense: SuspenseBoundary | null, vnode: VNode | null ) =\u0026gt; { if (isArray(rawRef)) { rawRef.forEach((r, i) =\u0026gt; setRef( r, oldRawRef \u0026amp;\u0026amp; (isArray(oldRawRef) ? oldRawRef[i] : oldRawRef), parentSuspense, vnode ) ); return; } let value: | ComponentPublicInstance | RendererNode | Record\u0026lt;string, any\u0026gt; | null; // async 组件，可以通过 defineAsyncComponent 声明的组件  // loader 会赋给 __asyncLoader，如果是异步组件需要等组件渲染完成之后  // 再去设置 ref  if (!vnode || isAsyncWrapper(vnode)) { value = null; } else { if (vnode.shapeFlag \u0026amp; ShapeFlags.STATEFUL_COMPONENT) { value = vnode.component!.exposed || vnode.component!.proxy; } else { value = vnode.el; } } const { i: owner, r: ref } = rawRef; if (__DEV__ \u0026amp;\u0026amp; !owner) { // warn 丢失 ref owner 上下文  return; } const oldRef = oldRawRef \u0026amp;\u0026amp; (oldRawRef as VNodeNormalizedRefAtom).r; const refs = owner.refs === EMPTY_OBJ ? (owner.refs = {}) : owner.refs; const setupState = owner.setupState; // unset old ref  if (oldRef != null \u0026amp;\u0026amp; oldRef !== ref) { if (isString(oldRef)) { refs[oldRef] = null; if (hasOwn(setupState, oldRef)) { setupState[oldRef] = null; } } else if (isRef(oldRef)) { oldRef.value = null; } } if (isString(ref)) { const doSet = () =\u0026gt; { refs[ref] = value; if (hasOwn(setupState, ref)) { setupState[ref] = value; } }; // #1789: 非空值，在 render 结束后设置  // 控制意味着是 unmount，它不应该重写同key 的其他 ref  if (value) { (doSet as SchedulerCb).id = -1; queuePostRenderEffect(doSet, parentSuspense); } else { doSet(); } } else if (isRef(ref)) { const doSet = () =\u0026gt; { ref.value = value; }; if (value) { (doSet as SchedulerCb).id = -1; queuePostRenderEffect(doSet, parentSuspense); } else { doSet(); } } else if (isFunction(ref)) { callWithErrorHandling(ref, owner, ErrorCodes.FUNCTION_REF, [value, refs]); } else if (__DEV__) { // warn ...  } };     这里可以简单理解为：将 ref 设值为 vnode.el 这是个引用，因此当它有值的时候也 等于是 ref 有值了，然后分为异步和同步，异步需要等 render 完成再去设置。\n  direcitve hooks   feat(add): directive hooks · gcclll/stb-vue-next@1343be2\n 执行指令声明周期钩子函数：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24  export function invokeDirectiveHook( vnode: VNode, prevVNode: VNode | null, instance: ComponentInternalInstance | null, name: keyof ObjectDirective ) { const bindings = vnode.dirs! const oldBindings = prevVNode \u0026amp;\u0026amp; prevVNode.dirs! for (let i = 0; i \u0026lt; bindings.length; i++) { const binding = bindings[i] if (oldBindings) { binding.oldValue = oldBindings[i].value } const hook = binding.dir[name] as DirectiveHook | undefined if (hook) { callWithAsyncErrorHandling(hook, instance, ErrorCodes.DIRECTIVE_HOOK, [ vnode.el, binding, vnode, prevVNode ]) } } }     给组件注册指令集：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31  export function withDirectives\u0026lt;T extends VNode\u0026gt;( vnode: T, directives: DirectiveArguments ): T { const internalInstance = currentRenderingInstance if (internalInstance === null) { __DEV__ \u0026amp;\u0026amp; warn(`withDirectives can only be used inside render functions.`) return vnode } const instance = internalInstance.proxy const bindings: DirectiveBinding[] = vnode.dirs || (vnode.dirs = []) for (let i = 0; i \u0026lt; directives.length; i++) { let [dir, value, arg, modifiers = EMPTY_OBJ] = directives[i] if (isFunction(dir)) { dir = { mounted: dir, updated: dir } as ObjectDirective } bindings.push({ dir, instance, value, oldValue: void 0, arg, modifiers }) } return vnode }     created, befoureMounted, mounted 发生在 mountElement()\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26  // 发生在 mountChildren 之后 if (dirs) { invokeDirectiveHook(vnode, null, parentComponent, \u0026#34;created\u0026#34;); } // ...  // 在插入DOM之前执行 if (dirs) { invokeDirectiveHook(vnode, null, parentComponent, \u0026#34;beforeMount\u0026#34;); } // hostInsert(el, container, anchor)  // 插入DOM之后执行，放入任务队列等待 render 结束 if ( (vnodeHook = props \u0026amp;\u0026amp; props.onVnodeMounted) || needCallTransitionHooks || dirs ) { queuePostRenderEffect(() =\u0026gt; { vnodeHook \u0026amp;\u0026amp; invokeVNodeHook(vnodeHook, parentComponent, vnode); needCallTransitionHooks \u0026amp;\u0026amp; transition!.enter(el); dirs \u0026amp;\u0026amp; invokeDirectiveHook(vnode, null, parentComponent, \u0026#34;mounted\u0026#34;); }, parentSuspense); }     beforeUpdate, updated 发生在 mountChildren()\n1 2 3 4 5 6 7 8 9 10 11 12 13 14  + if ((vnodeHook = newProps.onVnodeBeforeUpdate)) { + invokeVNodeHook(vnodeHook, parentComponent, n2, n1) + }  + if (dirs) { + invokeDirectiveHook(n2, n1, parentComponent, \u0026#39;beforeUpdate\u0026#39;) + }  + if ((vnodeHook = newProps.onVnodeUpdated) || dirs) { + queuePostRenderEffect(() =\u0026gt; { + vnodeHook \u0026amp;\u0026amp; invokeVNodeHook(vnodeHook, parentComponent, n2, n1) + dirs \u0026amp;\u0026amp; invokeDirectiveHook(n2, n1, parentComponent, \u0026#39;updated\u0026#39;) + }, parentSuspense) + }      unmounted 发生在 unmount()\n1 2 3 4 5 6 7  + if ((vnodeHook = props \u0026amp;\u0026amp; props.onVnodeUnmounted) || shouldInvokeDirs) { + queuePostRenderEffect(() =\u0026gt; { + vnodeHook \u0026amp;\u0026amp; invokeVNodeHook(vnodeHook, parentComponent, vnode) + shouldInvokeDirs \u0026amp;\u0026amp; + invokeDirectiveHook(vnode, null, parentComponent, \u0026#39;unmounted\u0026#39;) + }, parentSuspense) + }      测试：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121  const { log, f, shuffle, runtime_test, renderChildren } = require(process.env .BLOG_DIR_VUE + \u0026#34;/lib.js\u0026#34;); import(process.env.BLOG_DIR_VUE + \u0026#34;/runtime-test.global.js\u0026#34;).then( ({ h, render, nodeOps, serializeInner: inner, ref, currentInstance, withDirectives, }) =\u0026gt; { const count = ref(0); let _vnode = null, _prevVnode; const beforeMount = (el, binding, vnode, prevVnode) =\u0026gt; { log(\u0026#34;\u0026gt;\u0026gt;\u0026gt; before mounted\u0026#34;); log(\u0026#34;el.tag = \u0026#34; + el.tag); log(\u0026#34;el.parentNode = \u0026#34; + el.parentNode); log(\u0026#34;root.children.length = \u0026#34; + root.children.length); log(binding); log(\u0026#34;vnode = _vnode, \u0026#34; + (vnode === _vnode)); log(\u0026#34;prev vnode = \u0026#34; + prevVnode); }; const mounted = (el, binding, vnode, prevVnode) =\u0026gt; { log(\u0026#34;\u0026gt;\u0026gt;\u0026gt; mounted\u0026#34;); log(\u0026#34;el.tag = \u0026#34; + el.tag); log(\u0026#34;el.parentNode = root\u0026#34; + (el.parentNode === root)); log(\u0026#34;root.children[0] = el\u0026#34; + (el.children[0] === el)); log(binding); log(\u0026#34;vnode = _vnode, \u0026#34; + (vnode === _vnode)); log(\u0026#34;prev vnode = \u0026#34; + prevVnode); }; const beforeUpdate = (el, binding, vnode, prevVnode) =\u0026gt; { log(\u0026#34;\u0026gt;\u0026gt;\u0026gt; before update\u0026#34;); log(\u0026#34;el.tag = \u0026#34; + el.tag); log(\u0026#34;el.parentNode = root\u0026#34; + (el.parentNode === root)); log(\u0026#34;root.children[0] = el\u0026#34; + (el.children[0] === el)); log(\u0026#34;节点应该还没更新 el.children[0].text = \u0026#34; + (count.value - 1)); log(binding); log(\u0026#34;vnode = _vnode, \u0026#34; + (vnode === _vnode)); log(\u0026#34;prev vnode = _prevVnode\u0026#34; + (prevVNode === _prevVnode)); }; const updated = (el, binding, vnode, prevVnode) =\u0026gt; { log(\u0026#34;\u0026gt;\u0026gt;\u0026gt; updated\u0026#34;); log(\u0026#34;el.tag = \u0026#34; + el.tag); log(\u0026#34;el.parentNode = root\u0026#34; + (el.parentNode === root)); log(\u0026#34;root.children[0] = el\u0026#34; + (el.children[0] === el)); log(\u0026#34;节点应该已经更新 el.children[0].text = \u0026#34; + count.value); log(binding); log(\u0026#34;vnode = _vnode, \u0026#34; + (vnode === _vnode)); log(\u0026#34;prev vnode = _prevVnode\u0026#34; + (prevVNode === _prevVnode)); }; const beforeUnmount = (el, binding, vnode, prevVnode) =\u0026gt; { log(\u0026#34;\u0026gt;\u0026gt;\u0026gt; before unmount\u0026#34;); log(\u0026#34;el.tag = \u0026#34; + el.tag); log(\u0026#34;el.parentNode = root\u0026#34; + (el.parentNode === root)); log(\u0026#34;root.children[0] = el\u0026#34; + (el.children[0] === el)); log(\u0026#34;节点应该已经更新 el.children[0].text = \u0026#34; + count.value); log(binding); log(\u0026#34;vnode = _vnode, \u0026#34; + (vnode === _vnode)); log(\u0026#34;prev vnode = \u0026#34; + prevVNode); }; const unmounted = (el, binding, vnode, prevVnode) =\u0026gt; { log(\u0026#34;\u0026gt;\u0026gt;\u0026gt; unmounted\u0026#34;); log(\u0026#34;el.tag = \u0026#34; + el.tag); log(\u0026#34;el.parentNode = \u0026#34; + el.parentNode); log(\u0026#34;root.children.length = \u0026#34; + el.children.length); log(\u0026#34;节点应该已经更新 el.children[0].text = \u0026#34; + count.value); log(binding); log(\u0026#34;vnode = _vnode, \u0026#34; + (vnode === _vnode)); log(\u0026#34;prev vnode = \u0026#34; + prevVNode); }; const dir = { beforeMount, mounted, beforeUpdate, updated, beforeUnmount, unmounted, }; let _instance = null; const Comp = { setup() { _instance = currentInstance; }, render() { (_prevVnode = _vnode), (_vnode = withDirectives(h(\u0026#34;div\u0026#34;, count.value), [ [ dir, // dir, v-dir  count.value, // value, v-dir:foo.ok=value  \u0026#34;foo\u0026#34;, // argument  { ok: true }, // modifiers  ], ])); return _vnode; }, }; const root = nodeOps.createElement(\u0026#34;div\u0026#34;); render(h(Comp), root); }, (err) =\u0026gt; { console.log(err.message); } );    undefinedcomponent stateful ? 4 call setup [Function: render] render normalize vnode \u0026gt;\u0026gt;\u0026gt; before mounted el.tag = div el.parentNode = null root.children.length = 0 { dir: { beforeMount: [Function: beforeMount], mounted: [Function: mounted], beforeUpdate: [Function: beforeUpdate], updated: [Function: updated], beforeUnmount: [Function: beforeUnmount], unmounted: [Function: unmounted] }, instance: {}, value: 0, oldValue: undefined, arg: \u0026#39;foo\u0026#39;, modifiers: { ok: true } } vnode = _vnode, true prev vnode = null \u0026gt;\u0026gt;\u0026gt; mounted el.tag = div el.parentNode = roottrue root.children[0] = elfalse { dir: { beforeMount: [Function: beforeMount], mounted: [Function: mounted], beforeUpdate: [Function: beforeUpdate], updated: [Function: updated], beforeUnmount: [Function: beforeUnmount], unmounted: [Function: unmounted] }, instance: {}, value: 0, oldValue: undefined, arg: \u0026#39;foo\u0026#39;, modifiers: { ok: true } } vnode = _vnode, true prev vnode = null    TODO component props   feat(add): patch props · gcclll/stb-vue-next@6f6a0be\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52  const { log, f, shuffle, runtime_test, renderChildren } = require(process.env .BLOG_DIR_VUE + \u0026#34;/lib.js\u0026#34;); import(process.env.BLOG_DIR_VUE + \u0026#34;/runtime-test.global.js\u0026#34;).then( ({ h, render, nodeOps, serializeInner: inner, ref, currentInstance, withDirectives, defineComponent, }) =\u0026gt; { let props; let attrs; let proxy; const Comp = defineComponent({ props: [\u0026#34;fooBar\u0026#34;, \u0026#34;barBaz\u0026#34;], render() { props = this.$props; attrs = this.$attrs; proxy = this; }, }); const _log = (title) =\u0026gt; { log([ \u0026#39;\u0026gt;\u0026gt;\u0026gt; \u0026#39; + title, \u0026#39;\\nproxy.fooBar = \u0026#39; + proxy.fooBar, \u0026#39;\\n\u0026gt; props\\n\u0026#39;, props, \u0026#39;\\n\u0026gt; attrs\\n\u0026#39;, attrs ]) } const root = nodeOps.createElement(\u0026#39;div\u0026#39;) render(h(Comp, { fooBar: 1, bar: 2 }), root) _log(\u0026#39;test\u0026#39;) render(h(Comp, { \u0026#39;foo-bar\u0026#39;: 3, bar: 3, baz: 4, barBaz: 5 }), root) _log(\u0026#39;foo-bar 会转成 fooBar\u0026#39;) render(h(Comp, { qux: 5 }), root) _log(\u0026#39;删除 camel case\u0026#39;) log(\u0026#39;\\n\u0026gt;\u0026gt;\u0026gt; stateful with setup\u0026#39;) }, (err) =\u0026gt; { console.log(err.message); } );    undefinedcomponent stateful ? 4 call setup no setup [Function: render] render normalize vnode \u0026gt;\u0026gt;\u0026gt; test proxy.fooBar = 1 \u0026gt; props { fooBar: 1 } \u0026gt; attrs { bar: 2 } should update component has changed props normalize vnode \u0026gt;\u0026gt;\u0026gt; foo-bar 会转成 fooBar proxy.fooBar = 3 \u0026gt; props { fooBar: 3, barBaz: 5 } \u0026gt; attrs { bar: 3, baz: 4 } should update component has changed props normalize vnode \u0026gt;\u0026gt;\u0026gt; 删除 camel case proxy.fooBar = undefined \u0026gt; props { fooBar: undefined, barBaz: undefined } \u0026gt; attrs { qux: 5 }    测试  Teleport Testing...\n  Suspense Testing...\n  KeepAlive Testing...\n  Directive Testing...\n  脑图 \u0026amp; 测试结果 GIF    keep-alive 测试变化 GIF(13M):\n  结合源码\n1 2 3  // deactivate() const storageContainer = createElement(\u0026#34;div\u0026#34;); move(vnode, storageContainer, null, MoveType.LEAVE, parentSuspense);     即， deactivated 的 DOM 节点其实并非直接删除了，而是移到到了一个 off-dom 的元素上了，待重新激活的时候再移回来(在源码的 deactivate 和 activate 函数中增 加 storageContainer 打印).\n  测试脑图：\n       ","permalink":"https://www.cheng92.com/vue/vue-mind-map-runtime-core-3-component/","tags":["vue,","vue3,","runtime-core,","render,","component"],"title":"Vue3 源码头脑风暴之 7 ☞ runtime-core(3) - render component"},{"categories":["vue"],"contents":" 诗号：六道同坠，魔劫万千，引渡如来。  \n    insertCssLink(\"https://unpkg.com/element-plus/lib/theme-chalk/index.css\"); // insertCssLink(\"/js/vue/tables/index.css\");      var store = Vuex.createStore({ state() { return { count: 0 }}, mutations: { increment(state) { state.count++ }, decrement(state) { state.count-- } }, actions: { increment: ({ commit }) = commit('increment'), decrement: ({ commit }) = commit('decrement') }, modules: { m1: { state() { return { num: 0 } }, mutations: { incre(state) { state.num++ }, decre(state) { state.num-- } }, actions: { increment: ({ commit }) = commit('incre'), decrement: ({ commit }) = commit('decre'), } } } }) var Counter = { template: ` + - count: {{$store.state.count}}, num: {{$store.state.m1.num}} 注册before\u0026after {{this.registered ? \"已注册\" : \"\"}} `, data() { return { registered: false } }, methods: { ...Vuex.mapActions(['increment', 'decrement']), registerHooks() { if (this.registered) { console.log('registered, do not repeat.') return } this.registered = true store.subscribeAction({ before: (...args) = console.log(args,'before'), after: (...args) = console.log(args,'after'), }) }, } } var app = Vue.createApp(Counter) app.use(store).use(ElementPlus).mount('#tHrYBeArBS') console.log(app.config.globalProperties.$store, 'app.config.globalProperties.$store')    state, 所有子模块的 state 会以模块名嫁接到 rootState 上\n 如：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17  var root = { state: {count: 0}, actions: {}, mutations: {}, // ...  modules: { m1: { state: { num: 0 } }, m2: { state: { n: 0 } } } } // 经过 constructor -\u0026gt; installModule 处理之后 root.state = { count: 0, m1: { num: 0 }, m2: { n: 0 } }     实现部分：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26  function installModule(store, rootState, path, module, hot) { const isRoot = !path.length; const namespace = store._modules.getNamespace(path); // ...  // set state 就这一部分针对 state 的处理  // getNestedState 是个 recude -\u0026gt; state 取出当前 module 的 state 对象  if (!isRoot \u0026amp;\u0026amp; !hot) { const parentState = getNestedState(rootState, path.slice(0, -1)); const moduleName = path[path.length - 1]; store._withCommit(() =\u0026gt; { if (__DEV__) { if (moduleName in parentState) { console.warn( `[vuex] state field \u0026#34;${moduleName}\u0026#34; was overridden by a module with the same name at \u0026#34;${path.join( \u0026#34;.\u0026#34; )}\u0026#34;` ); } } parentState[moduleName] = module.state; }); } // ...  }      actions, 所有子模块的 actions 都会被击中到 this.actions 中\n 如：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20  var root = { actions: { decre: ({ commit }) =\u0026gt; commit(\u0026#34;decre\u0026#34;), }, modules: { m1: { actions: { decre: ({ commit }) =\u0026gt; commit(\u0026#34;decrement\u0026#34;), incre: ({ commit }) =\u0026gt; commit(\u0026#34;increment\u0026#34;), }, }, }, }; // 经过 constructor -\u0026gt; installModule -\u0026gt; forEachActions 之后 this.actions = { // 0 -\u0026gt; commit decre, 1 -\u0026gt; commit decrement  decre: [decre1, decre2], incre: [incre1], // 0 - commit increment };     所以当调用 dispatch decre 的时候 root 和 module m1 的 decre action都会被调用， 且所有的 action 会被封装成一个函数，该函数无论如何都会返回一个 Promise 实例而 在这些 actions 被调用的时候是通过 Promise.all 来调用的，因此无论是async action 还是 sync action 都会当做是 async 来执行。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48  function installModule(store, rootState, path, module, hot) { // ...  // ... actions 收集部分  module.forEachAction((action, key) =\u0026gt; { const type = action.root ? key : namespace + key; const handler = action.handler || action; registerAction(store, type, handler, local); }); // ... } // registerAction function registerAction(store, type, handler, local) { const entry = store._actions[type] || (store._actions[type] = []); entry.push(function wrappedActionHandler(payload) { let res = handler.call( store, { dispatch: local.dispatch, commit: local.commit, getters: local.getters, state: local.state, rootGetters: store.getters, rootState: store.state, }, payload ); if (!isPromise(res)) { // 这里确保了返回值一定是个 promise  res = Promise.resolve(res); } if (store._devtoolHook) { return res.catch((err) =\u0026gt; { store._devtoolHook.emit(\u0026#34;vuex:error\u0026#34;, err); throw err; }); } else { return res; } }); } // module.js -\u0026gt; forEachAction function forEachAction(fn) { if (this._rawModule.actions) { forEachValue(this._rawModule.actions, fn); } }      dispatch action\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67  function dispatch(_type, _payload) { // check object-style dispatch  const { type, payload } = unifyObjectStyle(_type, _payload); const action = { type, payload }; // 取出所有模块的 type 类型 actions  const entry = this._actions[type]; if (!entry) { if (__DEV__) { console.error(`[vuex] unknown action type: ${type}`); } return; } // 这里执行 before 钩子函数，在执行 actions 之前做的事情  try { this._actionSubscribers .slice() // shallow copy to prevent iterator invalidation if subscriber synchronously calls unsubscribe  .filter((sub) =\u0026gt; sub.before) .forEach((sub) =\u0026gt; sub.before(action, this.state)); } catch (e) { if (__DEV__) { console.warn(`[vuex] error in before action subscribers: `); console.error(e); } } // 这里将所有的 actions[type] 放到 Promise.all 中执行，意味着所有的  // action 无论同步异步的都执行完成了之后才会 settled  const result = entry.length \u0026gt; 1 ? Promise.all(entry.map((handler) =\u0026gt; handler(payload))) : entry[0](payload); // 最后返回 promise 完成 promise combo 链，注意这里面  // 包含了 after 和 error 两个钩子函数的触发动作  return new Promise((resolve, reject) =\u0026gt; { result.then( (res) =\u0026gt; { try { this._actionSubscribers .filter((sub) =\u0026gt; sub.after) .forEach((sub) =\u0026gt; sub.after(action, this.state)); } catch (e) { if (__DEV__) { console.warn(`[vuex] error in after action subscribers: `); console.error(e); } } resolve(res); }, (error) =\u0026gt; { try { this._actionSubscribers .filter((sub) =\u0026gt; sub.error) .forEach((sub) =\u0026gt; sub.error(action, this.state, error)); } catch (e) { if (__DEV__) { console.warn(`[vuex] error in error action subscribers: `); console.error(e); } } reject(error); } ); }); }      plugins 的用法\n plugins 的注册发生在 installModule 之后，因此在此时可以拿到所有模块的 state 数据，根据用例 modules.spec.js 的使用范例，在插件中可以进行 actions 的 before 和 after 钩子注册。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19  // store.js -\u0026gt; constructor -\u0026gt; installModule 之后 -\u0026gt;  // 执行插件 plugins.forEach((plugin) =\u0026gt; plugin(this)); // 使用示例， modules.spec.js const store = new Vuex.Store({ actions: { [TEST]: () =\u0026gt; Promise.resolve(), }, plugins: [ (store) =\u0026gt; { store.subscribeAction({ before: beforeSpy, after: afterSpy, }); }, ], });      before \u0026amp; after \u0026amp; error hooks\n 注册： store.subscribeAction({ before: fn, after: fn, error: fn })\n 执行：\n dispatch(type, payload)\n -\u0026gt; sub.before(action, this.state)\n -\u0026gt; Promise.all action\n -\u0026gt; sub.after(action, this.state)/sub.error(action, this.state, error)\n(2) [{…}, Proxy] 0: {type: \u0026#34;increment\u0026#34;, payload: PointerEvent} 1: Proxy {count: 1, m1: {…}} \u0026#34;before\u0026#34; (2) [{…}, Proxy] 0: {type: \u0026#34;increment\u0026#34;, payload: PointerEvent} 1: Proxy {count: 1, m1: {…}} \u0026#34;after\u0026#34;   源码调用时机：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47  function dispatch(_type, _payload) { // check object-style dispatch  // ...  try { // 1. 执行 before  this._actionSubscribers .slice() // shallow copy to prevent iterator invalidation if subscriber synchronously calls unsubscribe  .filter((sub) =\u0026gt; sub.before) .forEach((sub) =\u0026gt; sub.before(action, this.state)); } catch (e) { // ...  } // 2. 执行 actions  const result = entry.length \u0026gt; 1 ? Promise.all(entry.map((handler) =\u0026gt; handler(payload))) : entry[0](payload); return new Promise((resolve, reject) =\u0026gt; { result.then( (res) =\u0026gt; { try { // 3. after, 所有 action 执行完成且无异常情况  this._actionSubscribers .filter((sub) =\u0026gt; sub.after) .forEach((sub) =\u0026gt; sub.after(action, this.state)); } catch (e) { /*...*/ } resolve(res); }, (error) =\u0026gt; { try { // 4. error, 如果有 action rejected 会触发 error  this._actionSubscribers .filter((sub) =\u0026gt; sub.error) .forEach((sub) =\u0026gt; sub.error(action, this.state, error)); } catch (e) { /*...*/ } reject(error); } ); }); }       从注册和使用两点进行简要分析：\n 注册阶段:\n 注册时会将 store 对象用 ModuleCollection 类进行封装，这个类完成与 Module 相关的 注册、注销、和更新操作，而 Module 类完成具体的 children 相关的增删改查操作，而 Store 类是重点部分，里面包含状态相关的操作比如 mutations/actions/getters 等操 作的封装，以及提供 dispatch,commit 等修改状态的函数。\n 注册时，先注册根模块，然后递归检测 modules 对子模块进行注册，在模块注册过程中主 要有几个步骤： 更新 root state, 收集 actions、mutations、getters ，这里收集的原 则拿 actions 为例，不管是根模块还是子模块也无论模块层级嵌套多深，最后所有的 actions 都可以在实例的 this.actions 中找到。\n 使用阶段：\n 使用时的原则是只能通过 dispatch(type, payload) 来派发 ACTION ，内部实现找到对 应 actions 触发执行，而 action 的执行也是通过 commit mutation 来完成，因此使用原 则严格遵守： dispatch -\u0026gt; action -\u0026gt; commit -\u0026gt; mutation -\u0026gt; state ，而不能直接使用 commit 或 mutation 。\n 在使用是，执行阶段会依次触发 before -\u0026gt; action -\u0026gt; after/error 。\n 可通过 store.subscribeAction(fn)/* 等于 { before: fn }*/ 或\n store.subscribeAction({before:fn, after:fn1, error: fn2})\n 取注册钩子函数，这个动作可以在 createStore() 之后得到时候直接调用，也可以使用 插件的形式 plugins: [store =\u0026gt; store.subscribeAction(fn)] 去完成，因为插件会在 new Store() 构造函数中在 installModule() 安装模块之后得到执行，所以目的和结 果是一 样的。\n","permalink":"https://www.cheng92.com/vue/vue-vuex/","tags":["vue,","vue3,","vuex"],"title":"vuex for vue3 源码分析(附.脑图)"},{"categories":["vue"],"contents":"  诗号：六道同坠，魔劫万千，引渡如来。  \n   慎入😢\n vue-router-next 源码分析流程图，此文重点在图，附带一些总结性的文字分 析内容(图一般比较大，只保证自己能看懂系列~~~~)，学习过程中一些零碎的笔记。\n vue-router-next   脑图：  简要分析：\n vue-router 实现从使用上来说有三个部分：\n  路由注册初始化，以 VueRouter.createRoute({history, routes}) 为执行入口\n  创建匹配器 matcher 路由的一些匹配、添加、查找啊什么的操作都是有这个 matcher 来实现的\n1 2 3 4 5 6 7 8 9 10 11  export interface RouterMatcher { addRoute: (record: RouteRecordRaw, parent?: RouteRecordMatcher) =\u0026gt; () =\u0026gt; void; removeRoute: { (matcher: RouteRecordMatcher): void; (name: RouteRecordName): void; }; getRoutes: () =\u0026gt; RouteRecordMatcher[]; getRecordMatcher: (name: RouteRecordName) =\u0026gt; RouteRecordMatcher | undefined; resolve; }     而上面的接口操作的无非就是两个路由仓库：\n1 2 3 4 5  // 这个无论有没有名字的路由记录都会被存储到这个数组中 const matchers: RouteRecordMatcher[] = []; // 这个存储的是带 name 字段的路由 \u0026lt;name, record\u0026gt; 结构 // 方便直接可以通过 map.get(name) 就可以去到路由记录，减少数组查找消耗 const matcherMap = new Map\u0026lt;RouteRecordName, RouteRecordMatcher\u0026gt;();      初始化路由守卫存储器，其实就是个包含 {list,add,result} 的一个对象\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19  // 进入之前的的回调列表  const beforeGuards = useCallbacks\u0026lt;NavigationGuardWithThis\u0026lt;undefined\u0026gt;\u0026gt;(); // 解析路由之前的回调列表  const beforeResolveGuards = useCallbacks\u0026lt;NavigationGuardWithThis\u0026lt;undefined\u0026gt;\u0026gt;(); // 进入之后的回调列表  const afterGuards = useCallbacks\u0026lt;NavigationHookAfter\u0026gt;(); export function useCallbacks\u0026lt;T\u0026gt;() { let handlers: T[] = []; function add(handler: T): () =\u0026gt; void {} function reset() { handlers = []; } return { add, list: () =\u0026gt; handlers, reset, }; }      currentRoute 重要变量，是个 shallow ref 响应式类型的值，与 \u0026lt;router-view/\u0026gt; 当前显示的路由息息相关，或者说就是它，因为 RouterView 组件中有间接的监听这个值。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33  // RouterView.ts  // 就是这里的 matchedRouteRef  watch( () =\u0026gt; [viewRef.value, matchedRouteRef.value, props.name] as const, ([instance, to, name], [oldInstance, from, oldName]) =\u0026gt; { // ...  } ); // RouterView.ts \u0026gt; 为什么说是间接呢？看下面 matchedRouteRef 的由来  const injectedRoute = inject(routerViewLocationKey)!; const routeToDisplay = computed(() =\u0026gt; props.route || injectedRoute.value); const depth = inject(viewDepthKey, 0); const matchedRouteRef = computed\u0026lt;RouteLocationMatched | undefined\u0026gt;( () =\u0026gt; routeToDisplay.value.matched[depth] ); // router.ts \u0026gt; routerViewLocationKey ??? 不记得了吗? router.install... 啊  app.provide(routerKey, router); app.provide(routeLocationKey, reactive(reactiveRoute)); app.provide(routerViewLocationKey, currentRoute); // 看到没，关联上了吧!!!  // app.provide -\u0026gt; currentRoute -\u0026gt;  // injectedRoute -\u0026gt; routeToDisplay -\u0026gt;  // routeToDisplay.value.matched[depth]  /* 并且注意看 ~RouterView~ 组件中 setup最后返回的值是个函数，这个函数中有对 routeToDisplay, matchedRouteRef进行引用也就是在执行的时候会触发 track 操 作将它收集到这写值的依赖列表中，只要这些值发生变更就会 trigger这个 setup 执行，来更新 ~\u0026lt;router-view/\u0026gt;~ ,*/      初始化 router 实例\n 包含一些 api :\n 路由的增删改查主要来源 matcher： {addRoute, currentRoute, removeRoute, hasRoute, getRoutes, resolv}\n 路由的跳转行为： {push, replace, go, back: () =\u0026gt; go(-1), forward: () =\u0026gt; go(1)}, 这里的 push, replace 函数最终调用的都是 finalizeNavigation() 而 这里面主要有两个关键地方，一是 routerHistory.push/replace, 二是更新了 currentRoute.value 而正是这个更新会触发 \u0026lt;router-view/\u0026gt; 组件的更新。go 是直接使用了 routerHistory.go(delta) 接口\n 可以看到，不管是 push/replace 还是 go 最后都是使用了 history 的 api 。\n  路由插件的安装函数 install(app/* vue app */), 这里需要注意它做了几件事情：\n   注册 RouterLink, RouterView 两个 vue 组件   定义了全局属性 $route 指向 currentRoute   provide routerKey -\u0026gt; router 当前 router 实例   provide routeLocationKey -\u0026gt; reactiveRoute location 相关信息   provide routerViewLocationKey -\u0026gt; currentRoute 当前路由记录   重写 vue 组件的 unmount 函数，执行路由的清理工作，比如：移除事件监听，重置路由属性等        \u0026lt;router-view/\u0026gt; 组件的实现原理，通过 \u0026lt;router-link to/\u0026gt; 或 router.push/replace/go api 触发路由跳转动作实现\n  history 的实现原理(结合 Ref + history hash/H5api)，这个对用户是不可见的\n   vue-router 简要图：\n   TODO 守卫函数完整执行流程     HTML5 history api     api 描述     pushState(state, title, url) 向历史记录中增加一条记录   replaceState(state, title, url) 替换当前记录，不新增记录   back() 返回上一条记录，等价于 go(-1)   go(n) 跳转到第 n 条记录   forward() 等价于 go(1)   onpopstate 事件，当且执行 history.back() 或 history.forward() 或 history.go(n) 的时候触发   state 记录当前页面的状态信息，在执行 pushState 或 replaceState 之前为 null ，之后为第一个传入的参数，可以在 onpopstate 回调中通过 event.state 取到该信息     changeLocation() 测试。。。， 点击下面的按钮，注意观察 location 变化和 history.length 长度变化！ push ?q=1 push ?p=2 replace ?r=3 clear forward 随机跳转 back      针对 onpopstate 只有在执行实际跳转动作的时候才会触发，什么是实际跳转动作？\n 比如：浏览器的后台前进按钮，或者直接手动调用 history.back(), history.go(n), history.forward() 方法触发。\n  然后 vue-router 中是如何使用 history 实现路由功能的？\n  createWebHistory   H5 的 history api 封装，返回的结构： RouterHistory 包含以下成员\n   成员名 描述 -     base 站基地址，会添加到每个 url 前面 如： a.com/sub 那么 base 是 /sub   loation 当前 history location 非原生的 location, 封装之后的： {value: location}   state 当前的 history state 非原生 history state ，初始值是这个，但后续的值需要函数手动管理   push(to,data?) 对应 pushState 操作 不会触发 popstate   replace(to,data?) 对应 replaceState 操作 不会触发 popstate   go(delta, triggerListeners?) 调用 history.go(delta) 会触发 popstate 事件   listen(callback) 用户调用添加的监听函数 popstate 触发期间执行   createHref(location) 构建 href 地址 -   destory() 注销 listen() 注册的事件 -     Router 中的 back() 和 forward() 分别是调用这里的 go(-1) 和 go(1) 实现。\n 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38  export function createWebHistory(base?: string): RouterHistory { base = normalizeBase(base) const historyNavigation = useHistoryStateNavigation(base) const historyListeners = useHistoryListeners( base, historyNavigation.state, historyNavigation.location, historyNavigation.replace ) function go(delta: number, triggerListeners = true) { if (!triggerListeners) historyListeners.pauseListeners() history.go(delta) } const routerHistory: RouterHistory = assign( { // it\u0026#39;s overridden right after  location: \u0026#39;\u0026#39;, base, go, createHref: createHref.bind(null, base), }, historyNavigation, historyListeners ) Object.defineProperty(routerHistory, \u0026#39;location\u0026#39;, { get: () =\u0026gt; historyNavigation.location.value, }) Object.defineProperty(routerHistory, \u0026#39;state\u0026#39;, { get: () =\u0026gt; historyNavigation.state.value, }) return routerHistory }      base = normalizeBase(base)\n 解析网站基路径\n !base\n ? 无自定义地址首先取 \u0026lt;base href=\u0026#34;http://ip:port/path/to\u0026#34; /\u0026gt; 的 href， 取出 /path/to 部分作为 base\n \\: 有自定义的时候，加上开头 / 和去掉尾部 / ，如： path/to 变成 /path/to , 或 /path/to/ 变成 /path/to\n  const historyNavigation = useHistoryStateNavigation(base)\n 将 window.location 和 window.history 进行封装，返回\n {location, state, push, replace} 对象，所以这里重点就是这个函数。\n  const historyListeners = useHistoryListeners(...)\n history 变更监听器。\n  go(delta, triggerListeners) 函数\n 在调用 history.go(delta) 之前检测是否暂停 history listeners\n  组装 routerHistory\n 合并 { location: \u0026#39;\u0026#39;, base, go, createHref } 和 historyNavigation, historyListeners\n  在 routerHistory 上定义两个 getter 属性 location \u0026amp; state\n  返回 routerHistory 这个将来会被 createRouter({ history }) 用到\n   insertFrame('', '2.js', '/js/vue/router/')  useHistoryStateNavigation(base: string)   解构 window.history, window.location 组装 {location, state, push, replace} 结 构返回。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51  function useHistoryStateNavigation(base: string) { const { history, location } = window; // private variables  let currentLocation: ValueContainer\u0026lt;HistoryLocation\u0026gt; = { value: createCurrentLocation(base, location), }; let historyState: ValueContainer\u0026lt;StateEntry\u0026gt; = { value: history.state }; // build current history entry as this is a fresh navigation  if (!historyState.value) { changeLocation( currentLocation.value, { back: null, current: currentLocation.value, forward: null, // the length is off by one, we need to decrease it  position: history.length - 1, replaced: true, // don\u0026#39;t add a scroll as the user may have an anchor and we want  // scrollBehavior to be triggered without a saved position  scroll: null, }, true ); } function changeLocation( to: HistoryLocation, state: StateEntry, replace: boolean ): void { // ...  } function replace(to: HistoryLocation, data?: HistoryState) { // ...  } function push(to: HistoryLocation, data?: HistoryState) { //...  } return { location: currentLocation, state: historyState, push, replace, }; }      解析 location { pathname, search, hash } 返回不带域名的的 path\n 如：\n http://ip:port/ui/#/a/b/?limit=10\u0026amp;page=1 -\u0026gt; base: /ui/# -\u0026gt; /a/b\n http://ip:port/ui/a/b/?limit=10\u0026amp;page=1 -\u0026gt; base: /ui -\u0026gt; /a/b\n http://ip:port/a/ui/b/?limit=10\u0026amp;page=1 -\u0026gt; base: /ui -\u0026gt; /a/ui/b\n 结构： {value: url}\n  historyState = { value: history.state }\n 如果 historyState.value 为空，需要进行初始化 -\u0026gt; changeLocation()\n  changeLocation(to, state, replace) 函数\n  replace(to, data?) 函数\n  push(to, data?) 函数\n  最后返回结构 {location: currentLocation, state: historyState, push, replace}\n  createCurrentLocation(base: string,location: Location)   对 location { pathname, search, hash } 加工返回新的 url\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  function createCurrentLocation( base: string, location: Location ): HistoryLocation { const { pathname, search, hash } = location // allows hash based url  const hashPos = base.indexOf(\u0026#39;#\u0026#39;) if (hashPos \u0026gt; -1) { // prepend the starting slash to hash so the url starts with /#  let pathFromHash = hash.slice(1) if (pathFromHash[0] !== \u0026#39;/\u0026#39;) pathFromHash = \u0026#39;/\u0026#39; + pathFromHash return stripBase(pathFromHash, \u0026#39;\u0026#39;) } const path = stripBase(pathname, base) return path + search + hash }     函数作用： base 中含有 # 时，直接从 location.hash 中解析出 path。\n 比如：\n base=/ui/#/\n url=https://ip:port/ui/#/base/industry/grouping?limit=10\u0026amp;page=1\u0026amp;tradeId=19\u0026amp;times=1614652347338\n 最后解析出来的\n path=/base/industry/grouping?limit=10\u0026amp;page=1\u0026amp;tradeId=19\u0026amp;times=1614652347338\n 如果 base 不含 # 直接取出 path 中去掉 base 部分的 url，如：\n base=/ui/ -\u0026gt; url=http://ip:port/ui/path/to... 得到 /path/to\n 如果 base 在 url pathname 的中间，直接返回 pathname 因为这种情况非 base 情况 http://ip:port/path/ui/to 直接返回 /path/ui/to\n  changeLocation(to,state,replace)  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30  function changeLocation( to: HistoryLocation, state: StateEntry, replace: boolean ): void { //  const hashIndex = base.indexOf(\u0026#34;#\u0026#34;); // to:list -\u0026gt; /base/#/ui/ -\u0026gt; /ui/list  const url = hashIndex \u0026gt; -1 ? (location.host \u0026amp;\u0026amp; document.querySelector(\u0026#34;base\u0026#34;) ? base : base.slice(hashIndex)) + to // http://ip:port + base + to  : createBaseLocation() + base + to; try { // BROWSER QUIRK  // NOTE: Safari throws a SecurityError when calling this function 100 times in 30 seconds  history[replace ? \u0026#34;replaceState\u0026#34; : \u0026#34;pushState\u0026#34;](state, \u0026#34;\u0026#34;, url); historyState.value = state; } catch (err) { if (__DEV__) { warn(\u0026#34;Error with push/replace State\u0026#34;, err); } else { console.error(err); } // Force the navigation, this also resets the call count  location[replace ? \u0026#34;replace\u0026#34; : \u0026#34;assign\u0026#34;](url); } }     去掉 base hash 部分将 to 路由组合成 url 调用 history.replace|pushState(state, title, url) 改变 url，同时修改 historyState.value 值。\n  replace(to, data?)  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22  function replace(to: HistoryLocation, data?: HistoryState) { const state: StateEntry = assign( {}, history.state, buildState( historyState.value.back, // keep back and forward entries but override current position  to, historyState.value.forward, true ), data, // 替换操作，使用老的 position 替代新的  // 这个会在 changeLocation 中用来计算 delta 偏移量  { position: historyState.value.position } ); // 执行 replaceState  // 取 old historyState 然后设置 new historyState  changeLocation(to, state, true); currentLocation.value = to; }      push(to, data?)  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31  function push(to: HistoryLocation, data?: HistoryState) { // Add to current entry the information of where we are going  // as well as saving the current position  const currentState = assign( {}, // use current history state to gracefully handle a wrong call to  // history.replaceState  // https://github.com/vuejs/vue-router-next/issues/366  historyState.value, history.state as Partial\u0026lt;StateEntry\u0026gt; | null, { forward: to, scroll: computeScrollPosition(), } ); // ...  // 执行 pushState, 记录 old/new historyState  changeLocation(currentState.current, currentState, true); const state: StateEntry = assign( {}, buildState(currentLocation.value, to, null), { position: currentState.position + 1 }, data ); changeLocation(to, state, false); currentLocation.value = to; }        useHistoryListeners()  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18  function useHistoryListeners( base: string, historyState: ValueContainer\u0026lt;StateEntry\u0026gt;, currentLocation: ValueContainer\u0026lt;HistoryLocation\u0026gt;, replace: RouterHistory[\u0026#34;replace\u0026#34;] ) { // 1. popstate 事件处理句柄  // 2. pause listeners  // 3. listen(callback)  // 4. beforeUnloadListener()  // 5. destory()  // 6. add event listenner: popstate + beforeunload  // setup the listeners and prepare teardown callbacks  window.addEventListener(\u0026#34;popstate\u0026#34;, popStateHandler); window.addEventListener(\u0026#34;beforeunload\u0026#34;, beforeUnloadListener); // 7. return { pauseListeners, listn, destory } }    popStateHandler({ state })   因为 history.state 保存了执行跳转是 pushState/replaceState 传入的第一个参数值， 所以可以通过 to/from 上的 state 进行对比得到跳转的方向是 forward 还是 back。\n 但是 history.state 是实时的，执行完 push/replace 就会发生改变，这里怎么处理这个 问题呢，能让 to\u0026amp;from 状态得以保存？\n 答. 因为使用 historyState = { value: history.state } 做了个中介， 虽然 history.state 实时变化，但是这个 historyState 是不会的，手动用它来管理 to \u0026amp; from 的前后状态。\n 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48  const popStateHandler: PopStateListener = ({ state, }: { state: StateEntry | null }) =\u0026gt; { const to = createCurrentLocation(base, location) const from: HistoryLocation = currentLocation.value // 这里拿到的是跳转之前的 state  const fromState: StateEntry = historyState.value let delta = 0 if (state) { currentLocation.value = to // 这里 state 是执行路由跳转之后触发了 popstate 事件  // 去得到的最新状态，对应 to 更新老状态值  historyState.value = state // ignore the popstate and reset the pauseState  // 暂停？忽略事件重置 pauseState ?  if (pauseState \u0026amp;\u0026amp; pauseState === from) { pauseState = null return } // 根据 to \u0026amp; from state 计算出要执行跳转的方向或偏移  delta = fromState ? state.position - fromState.position : 0 } else { // 没有新状态，直接替换历史记录  replace(to) } // console.log({ deltaFromCurrent })  // Here we could also revert the navigation by calling history.go(-delta)  // this listener will have to be adapted to not trigger again and to wait for the url  // to be updated before triggering the listeners. Some kind of validation function would also  // need to be passed to the listeners so the navigation can be accepted  // call all listeners  listeners.forEach(listener =\u0026gt; { listener(currentLocation.value, from, { delta, type: NavigationType.pop, direction: delta ? delta \u0026gt; 0 ? NavigationDirection.forward : NavigationDirection.back : NavigationDirection.unknown, }) }) }      pauseListeners()  1 2 3  function pauseListeners() { pauseState = currentLocation.value; }      listen(callback)   纯粹的 add 操作，更新 listeners[] 和对应的移除函数列表 teardowns[]\n1 2 3 4 5 6 7 8 9 10 11 12 13  // 添加监听函数，返回对应的 teardown 函数  function listen(callback: NavigationCallback) { // setup the listener and prepare teardown callbacks  listeners.push(callback) const teardown = () =\u0026gt; { const index = listeners.indexOf(callback) if (index \u0026gt; -1) listeners.splice(index, 1) } teardowns.push(teardown) return teardown }      beforeUnloadListener()   整个页面执行卸载之前的事件，发生在 unload 之前。\n1 2 3 4 5 6 7 8  function beforeUnloadListener() { const { history } = window if (!history.state) return history.replaceState( assign({}, history.state, { scroll: computeScrollPosition() }), \u0026#39;\u0026#39; ) }      destroy() 注销事件  1 2 3 4 5 6  function destroy() { for (const teardown of teardowns) teardown(); teardowns = []; window.removeEventListener(\u0026#34;popstate\u0026#34;, popStateHandler); window.removeEventListener(\u0026#34;beforeunload\u0026#34;, beforeUnloadListener); }          createWebHashHistory   /vue-router-next/src/history/hash.ts\n 从源码可以看出，该函数是基于 createWebHistory(base) 完成的，也就是说这个也是基 于 history api 完成，只不过在这个基础上对 hash 值进行了情况分析和检测，做了进一 步优化处理。\n 参数 base，可以函数调用时提供，如果存在 \u0026lt;base href/\u0026gt; 标签会优先取这个标签的 href 值解析出 base 值。\n  如，函数注释，有以下几种可能情况(如： base=https://example.com/folder)\n  createWebHashHistory() 无参数\n 结果： https://example.com/folder#\n  createWebHashHistory(\u0026#39;/folder/\u0026#39;)\n 匹配 /folder 成功，结果： https://example.com/folder/#\n  createWebHashHistory(\u0026#39;/folder/#/app\u0026#39;)\n 中间有 # 符号的：\n 匹配 /folder 成功，结果： https://example.com/folder/#/app\n  createWebHashHistory(\u0026#39;other-folder\u0026#39;)\n 匹配失败，会直接替换，结果： https://example.com/other-folder/#\n 不推荐这种，因为它会改变根路径。\n  无主机的地址，比如本地文件访问： ///usr/etc/folder/index.html\n createWebHashHistory(\u0026#39;/iAmIgnored\u0026#39;)\n 结果： ///usr/etc/folder/index.html#\n 提供的 base 会被忽略。\n  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18  export function createWebHashHistory(base?: string): RouterHistory { // Make sure this implementation is fine in terms of encoding, specially for IE11  // for `file://`, directly use the pathname and ignore the base  // location.pathname contains an initial `/` even at the root: `https://example.com`  base = location.host ? base || location.pathname + location.search : \u0026#39;\u0026#39; // allow the user to provide a `#` in the middle: `/base/#/app`  if (base.indexOf(\u0026#39;#\u0026#39;) \u0026lt; 0) base += \u0026#39;#\u0026#39; if (__DEV__ \u0026amp;\u0026amp; !base.endsWith(\u0026#39;#/\u0026#39;) \u0026amp;\u0026amp; !base.endsWith(\u0026#39;#\u0026#39;)) { warn( `A hash base must end with a \u0026#34;#\u0026#34;:\\n\u0026#34;${base}\u0026#34; should be \u0026#34;${base.replace( /#.*$/, \u0026#39;#\u0026#39; )}\u0026#34;.` ) } return createWebHistory(base) }     更多请查看 createWebHistory 。\n  TODO createMemoryHistory   通过一个队列来管理路由。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83  export function createMemoryHistory(base: string = \u0026#39;\u0026#39;): RouterHistory { let listeners: NavigationCallback[] = [] let queue: HistoryLocation[] = [START] let position: number = 0 function setLocation(location: HistoryLocation) { position++ if (position === queue.length) { // we are at the end, we can simply append a new entry  queue.push(location) } else { // we are in the middle, we remove everything from here in the queue  queue.splice(position) queue.push(location) } } function triggerListeners( to: HistoryLocation, from: HistoryLocation, { direction, delta }: Pick\u0026lt;NavigationInformation, \u0026#39;direction\u0026#39; | \u0026#39;delta\u0026#39;\u0026gt; ): void { const info: NavigationInformation = { direction, delta, type: NavigationType.pop, } for (let callback of listeners) { callback(to, from, info) } } const routerHistory: RouterHistory = { // rewritten by Object.defineProperty  location: START, state: {}, base, createHref: createHref.bind(null, base), replace(to) { // remove current entry and decrement position  queue.splice(position--, 1) setLocation(to) }, push(to, data?: HistoryState) { setLocation(to) }, listen(callback) { listeners.push(callback) return () =\u0026gt; { const index = listeners.indexOf(callback) if (index \u0026gt; -1) listeners.splice(index, 1) } }, destroy() { listeners = [] }, go(delta, shouldTrigger = true) { const from = this.location const direction: NavigationDirection = // we are considering delta === 0 going forward, but in abstract mode  // using 0 for the delta doesn\u0026#39;t make sense like it does in html5 where  // it reloads the page  delta \u0026lt; 0 ? NavigationDirection.back : NavigationDirection.forward position = Math.max(0, Math.min(position + delta, queue.length - 1)) if (shouldTrigger) { triggerListeners(this.location, from, { direction, delta, }) } }, } Object.defineProperty(routerHistory, \u0026#39;location\u0026#39;, { get: () =\u0026gt; queue[position], }) return routerHistory }      ","permalink":"https://www.cheng92.com/vue/vue-router-next/","tags":["vue,","vue3,","vue-router-next"],"title":"vue-router-next for vue3 源码分析(附.脑图)"},{"categories":["tools"],"contents":"  杂七杂八的一些东西，总要往哪里放，今天解决明天又忘记了，好记性不如烂笔头，😄😄。\n 优质博文(含 github)    Jerry Qu, HTTP/HTTP2相关内容丰富的博客\n  浏览器是如何工作的：Chrome V8让你更懂JavaScript - SegmentFault 思否\n  程序员经常看的开源月刊《HelloGitHub》第 58 期 - 知乎\n  Troland/how-javascript-works: Knowledge about how javascript works, event loop,service worker,etc.\n 里面有些文章介绍了，事件循环等一些原理性的东西。\n  Openbase: choose the right package every time\n 技术选型网站，如 vue, react 等待。\n  (22 封私信 / 82 条消息) 国内有哪些类似于聚合数据这样的提供免费接口api的 服务供应商？ - 知乎\n    数学  数学符号大全   符号大全-特殊符号-特殊符号大全\n常用符号： ＋－×÷﹢﹣±／＝≈≡≠∧∨∑∏∪∩∈⊙⌒⊥∥∠∽≌＜＞≤≥≮≯∧∨√﹙﹚[]﹛﹜∫∮∝∞⊙∏º¹²³⁴ⁿ₁₂₃₄·∶½⅓⅔¼¾⅛⅜⅝⅞∴∵∷αβγδεζηθικλμνξοπρστυφχψω％‰℅°℃℉′″￠〒¤○㎎㎏㎜㎝㎞㎡㎥㏄㏎mlmol㏕Pa＄￡￥㏒㏑壹贰叁肆伍陆柒捌玖拾微毫厘分百千万亿兆吉 几何符号： ⊥ ‖ ∠ ⌒ ⊙ ≡ ≌ △ 代数符号： ∝ ∧ ∨ ～ ∫ ≠ ≤ ≥ ≈ ∞ ∶ 运算符号： × ÷ √ ± 集合符号： ∪ ∩ ∈ ⊆ ⊂ ⊇ ⊃ 特殊符号： ∑ π（圆周率） 推理符号： |a| ⊥ ∽ △ ∠ ∩ ∪ ≠ ≡ ± ≥ ≤ ∈ ← ↑ → ↓ ↖ ↗ ↘ ↙ ‖ ∧ ∨      程序员  ReadTheDocs 创建技术文档   Read the Docs Guides — Read the Docs 5.8.0 documentation\n Read the Docs Sphinx Theme — Read the Docs Sphinx Theme 0.5.0 documentation\n  go   go get golang.org/x/tools/gopls@latest\n  正则表达式    学习资料\n https://github.com/ziishaned/learn-regex\n  正则工具：\n https://regexper.com/#–%28%5C!%29%3E\n    初级阶段学习    w3schools 初学\n  GeeksforGeeks，全英文不止有算法\n       前端开发  不错的前端学习路线网站：https://objtube.github.io/front-end-roadmap/#/ 脑图方式 展示。\n插件列表  jsmind 一款 js 脑图工具。    BFW NEW PAGE  bready(function() { use([\"jsmind\", \"jsmind\"], function() { function load_jsmind() { var mind = { \"meta\": { \"name\": \"demo\", \"author\": \"hizzgdev@163.com\", \"version\": \"0.2\", }, \"format\": \"node_array\", \"data\": [{ \"id\": \"root\", \"isroot\": true, \"topic\": \"jsMind\" }, { \"id\": \"sub1\", \"parentid\": \"root\", \"topic\": \"sub1\", \"background-color\": \"#0000ff\" }, { \"id\": \"sub11\", \"parentid\": \"sub1\", \"topic\": \"sub11\" }, { \"id\": \"sub12\", \"parentid\": \"sub1\", \"topic\": \"sub12\" }, { \"id\": \"sub13\", \"parentid\": \"sub1\", \"topic\": \"sub13\" }, { \"id\": \"sub2\", \"parentid\": \"root\", \"topic\": \"sub2\" }, { \"id\": \"sub21\", \"parentid\": \"sub2\", \"topic\": \"sub21\" }, { \"id\": \"sub22\", \"parentid\": \"sub2\", \"topic\": \"sub22\", \"foreground-color\": \"#33ff33\" }, { \"id\": \"sub3\", \"parentid\": \"root\", \"topic\": \"sub3\" }, ] }; var options = { container: 'jsmind_container', editable: true, theme: 'primary' } var jm = jsMind.show(options, mind); // jm.set_readonly(true); // var mind_data = jm.get_data(); // alert(mind_data); jm.add_node(\"sub2\", \"sub23\", \"new node\", { \"background-color\": \"red\" }); jm.set_node_color('sub21', 'green', '#ccc'); } load_jsmind(); }); });  #jsmind_container { width: 800px; height: 500px; border: solid 1px #ccc; /*background:#f4f4f4;*/ background: #f4f4f4; }         xlsx-to-json  xlsx 文件转成 json 数据。\n    anujs   vue  vite(vue-cli)\n1 2 3 4  $ yarn create vite-app \u0026lt;project-name\u0026gt; $ cd \u0026lt;project-name\u0026gt; $ yarn $ yarn dev     或\n1 2 3 4 5  $ npm install -g @vue/cli $ vue create 01-vue3-cli $ cd 01-vue3-cli $ vue add vue-next $ npm run serve      v3boss(Based on vue3)  问题列表    请求出现 \u0026lt;font color=\u0026#34;red\u0026#34;\u0026gt;500\u0026lt;/font\u0026gt;，对比差异只有 RemoteAddress 有点异常???\n答：证书问题，使用 `secure: false` 配置选项跳过证书认证    assets 资源引入问题\n答：使用 `alias: {}` 选项配置别名，注意必须是 `/@assets/` 方式，以斜杠开始斜杠结束。  1 2 3 4  alias: { \u0026#39;/@/\u0026#39;: path.resolve(__dirname, \u0026#39;src\u0026#39;), \u0026#39;/@assets/\u0026#39;: path.resolve(__dirname, \u0026#39;src/assets\u0026#39;) }          工具    .gitignore 生成网站： https://www.toptal.com/developers/gitignore\n      神器???  nnn   author: https://github.com/jarun\n 终端文件管理工具   Surfingkeys   chrome/firefox 按键, https://github.com/brookhong/Surfingkeys。\n 按键： ? 查看按键表。\n 常用按键表：\n   key function     截屏    yg 截取当前视图   yG 截取当前整个页面，长图   yS capture current scroll target.     Alt/Option s on/off Surfingkeys     字符查找    f, ; 向下查找，向下重复查找结果   F, , 向上查找，向上重复查找结果     定位/导航    zz 将鼠标行定位到屏幕中间   t 搜索书签或历史   b 打开书签   og 打开搜索引擎，会弹出输入框   ow 同上     配置文件：\n1 2 3  mapkey(\u0026#39;\u0026lt;Ctrl-y\u0026gt;\u0026#39;, \u0026#39;Show me the money\u0026#39;, function() { Front.showPopup(\u0026#39;a well-known phrase uttered by characters in the 1996 film Jerry Maguire (Escape to close).\u0026#39;); });     chrome url 操作：  标记操作，添加-跳转  当前标签页URL操作：  tab 操作：  搜索，打开url操作：     Hugo    设置文章列表以 year-month 分类，如图：  修改：/theme/even/layouts/_default/section.html\n 其中的 \u0026#34;2006\u0026#34; 修改成 \u0026#34;2006-01\u0026#34; 即可。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20  {{- range $index, $element := $paginator.Pages -}} {{- $thisYear := $element.Date.Format \u0026#34;2006-01\u0026#34; }} {{- $lastElement := $index | add -1 | index $paginator.Pages }} {{- if or (eq $index 0) ( ne ($lastElement.Date.Format \u0026#34;2006-01\u0026#34;) $thisYear ) }} \u0026lt;div class=\u0026#34;collection-title\u0026#34;\u0026gt; \u0026lt;h2 class=\u0026#34;archive-year\u0026#34;\u0026gt;{{ $thisYear }}\u0026lt;/h2\u0026gt; \u0026lt;/div\u0026gt; {{- end }} \u0026lt;div class=\u0026#34;archive-post\u0026#34;\u0026gt; \u0026lt;span class=\u0026#34;archive-post-time\u0026#34;\u0026gt; {{ $element.Date.Format \u0026#34;01-02\u0026#34; }} \u0026lt;/span\u0026gt; \u0026lt;span class=\u0026#34;archive-post-title\u0026#34;\u0026gt; \u0026lt;a href=\u0026#34;{{ $element.RelPermalink }}\u0026#34; class=\u0026#34;archive-post-link\u0026#34;\u0026gt; {{ .Title }} \u0026lt;/a\u0026gt; \u0026lt;/span\u0026gt; \u0026lt;/div\u0026gt; {{- end -}}        api     名称 简介 其他     IPTV channels IPTV 频道接口 所有数据 json 文件      软件\u0026amp;命令  crontab 定时任务   OS X 添加定时任务 | Coding Pub\n  macos 重装系统必备步骤    安装 CommandLineTools ，直接官网下载就行-\u0026gt;\u0026gt;\n git 代理设置：\ngit ---------- 取消 git config --global --unset http.https://github.com.proxy git config --global --unset https.https://github.com.proxy git config --global --unset http.proxy git config --global --unset https.proxy 设置 git config --global http.https://github.com.proxysocks5://127.0.0.1:7891 git config --global https.https://github.com.proxysocks5://127.0.0.1:7891 git config --global http.https://github.com.proxyhttps://127.0.0.1:7890 git config --global https.https://github.com.proxyhttps://127.0.0.1:7890 git config --global http.proxy socks5://127.0.0.1:7891 git config --global https.proxy socks5://127.0.0.1:7891    下载 ssh 配置： git clone git@code.aliyun.com:wyu/dotdat.git\n 解决权限问题： chmod 400 ~/.ssh/id_rsa_ali\n  下载文档: git clone git@code.aliyun.com:wyu/documents.git\n  下载安装 MacPorts, Node.js , HomeBrew\n 解决安装冲突问题： sudo killall -1 installd 解决 npm 安装权限问题： sudo chown -R $USER /usr/local/lib/node_modules\n npm 代理设置和取消：\n1 2 3 4 5  npm config set proxy=http://127.0.0.1:8087 npm config set registry=http://registry.npmjs.org npm config delete proxy npm config delete https-proxy      下载 MacOS 工具： iTerm, oh-my-zsh, drawer.io drawer.io.pp\n  安装其他 shell 命令工具： fasd, autojump, n, ag, rg\n 均可以通过 brew/port 安装\n brew install fasd/... sudo port install fasd/...\n  安装 Emacs\n sudo port install emacs-app sudo port install emacs\n  安装 PicGo 截图，图床工具: brew cask install picgo\n 配置文件 ~/Library/Application\\ Support/picgo/data.json\n  七牛秘钥：https://portal.qiniu.com/user/key\n  hugo\n brew install hugo\n rust: curl --proto \u0026#39;=https\u0026#39; --tlsv1.2 -sSf https://sh.rustup.rs | sh\n  安装 alfred 及其 workflows\n  lsp languages\n https://emacs-lsp.github.io/lsp-mode/page/lsp-eslint/\n1 2 3 4 5 6 7 8 9 10 11 12  # js/ts, vue, css/less/scss/... $ npm i -g javascript-typescript-langserver \\  vls \\  vscode-css-languageserver-bin \\  bash-language-server \\  vscode-html-languageserver-bin \\  typescript \\  vscode-json-languageserver \\  yaml-language-server \u0026amp;\u0026amp; \\  pip install \u0026#39;python-language-server[all]\u0026#39; \\  brew install ccls \\  go get golang.org/x/tools/gopls@latest     gopls: ~~\n  ssh/sftp 工具： npm i -g electerm\n https://electerm.github.io/electerm/\n  rsync: brew install rsync\n download linux kernel src: git clone git://git.kernel.org/pub/scm/linux/kernel/git/next/linux-next.git\n    字体  1 2  $ brew tap homebrew/cask-fonts $ brew cask install font-fira-code      网站    图片/svg 转 favicon\n    MacOs 工具  其他    beyond compare\n 破解： https://www.jianshu.com/p/596b4463eacd\n 步骤：\n1 2 3 4 5 6 7  $ cd /Applications/Beyond Compare.app/Contents/MacOS $ mv BCompare BCompare.real $ echo \u0026#39;#!/bin/bash rm \u0026#34;/Users/$(whoami)/Library/Application Support/Beyond Compare/registry.dat\u0026#34; \u0026#34;`dirname \u0026#34;$0\u0026#34;`\u0026#34;/BCompare.real $@ \u0026#39; \u0026gt; BCompare $ chmod a+x ./BCompare        系统性工具    setapp\n  Karabiner-Elements A powerful and stable keyboard customizer for macOS.\n  SpaceLauncher 自定义快捷键\n    软件网站    xclient.info\n    分屏    Swish 手势分屏，付费\n 使用中文教程： https://sspai.com/post/55285\n  Melisandre，付费\n  Moom，付费\n  Mosaic，付费\n  Magnet，付费\n  BetterTouchTool，付费\n  Hammerspoon\n      Alfred    Text Shourtcut\n 如果用的是 Alfred 3 需要修改下 /Users/simon/Library/Application Support/Alfred 3/Alfred.alfredpreferences/workflows/user.workflow.ACE8BAEC-3702-436D-959C-4DBC14DBAFAB/workflows.php\n 将里面的 Alfred-2 改成 Alfred-3 就可以用了，不然会报找不到路径。\n 增加和删除都是针对增加的 abbrev 文件操作。\n 1 先复制内容到剪贴板\n  ts add [shortcut name] 增加\n  ts del [shortcut name] 删除\n  ts [shortcut name] 取出对应的内容，复制到当前活跃应用\n       command function     web 查询     bd, 百度    w3, w3c    mdn     open 搜索打开   find 查找文件   in 内容搜索   tags 查找被标记颜色的文件夹   j autojump   user can i use   cov 进制转换   rjs react docs   json json 格式化   twd tailwind css docs   v vuejs docs, ⌘Y 快速预览   v routing vuejs router docs   adb TODO   lc leetcode 搜索 (-e, -m, -h, 容易，中等，高难)   lct leetcode 话题搜索   gh github search   b64 图片转base64   fa 搜索 fontasesome 的 icons   gicon google icons 上搜索   qr 将文本生成二维码(奇慢无比)   giphy 搜索动态图片 gif   ip 查电脑内外网ip   gt google 翻译   emoj 表情搜索   emoji 表情搜索   ascii/rascii ASCII编码互转   http http 状态码   yd 有道翻译，支持双语互转,yd zh=\u0026gt;ja 我爱你，中转日    zh, ja, en, ko, fr,    ru(俄文), pt(葡萄牙文), es(西班牙文), auto   kill 杀进程   audiorec, screenrec, webcamred 音频/屏幕/视频录制(自带的QuickPlayer)   vd 视频下载(youtube, vimeo,dailymotion,…)   vd-update 更新自身   vd video-url 下载到桌面   vd-audio video-url 下载同时自动分离出音频文件   vd-info video-url 查看视频信息      qshell 批量下载七牛  https://github.com/qiniu/qshell\n  $ qshell account \u0026lt;Your AccessKey\u0026gt; \u0026lt;Your SecretKey\u0026gt; \u0026lt;Your Name\u0026gt;\n  $ qshell account -- \u0026lt;Your AccessKey\u0026gt; \u0026lt;Your SecretKey\u0026gt; \u0026lt;Your Name\u0026gt; key 可能 以是以 - 开头，就用这个。\n  配置文件：~/.qshell.json\n  git 命令   删除远程分支： $ git push origin :test1\n 删除本地分支： $ git branch -d test1\n 强制删除本地分支： $ git branch -D test1\n 新增本地分支： $ git branch test1\n 推送到远程分支： $ git push origin test1:test1\n 查看远程分支： $ git branch -r\n 查看本地分支： $ git branch -a\n  htop 可视化进程查看工具  $ brew install htop\n  Travis-CI(Blog 系统集成方案)    持续集成服务 Travis CI 教程-阮一峰\n  travis-ci-ssh-token 问题\n  1 2 3 4 5 6 7 8 9  $ travis login --pro --github-token xxxx $ ssh-keygen -t rsa -b 4096 -C \u0026#34;gccll.love@gmail.com\u0026#34; $ travis whoami $ ssh-keygen -t rsa $ ls # 这里是关键，登录的时候用的 --pro 这里也必须用 --pro，不然加到 .org 上去了 # 坑逼 $ travis encrypt-file deploy_key --add --pro $ ls      PicGo   https://github.com/PicGo\n    git   怎么只拉取代码而忽略 .git/ 文件夹 ?\n  ","permalink":"https://www.cheng92.com/post/cheng/","tags":["soft,","macos,","window"],"title":"我的私人空间"},{"categories":["vue"],"contents":" 该文为本人学习计划等相关信息，这里内容将均由 vue3 + element-plus 实现。\n 状态：DONE 已完成 DOING 进行中 PENDING 暂停中 WAITING 计划中      insertCssLink(\"https://unpkg.com/element-plus/lib/theme-chalk/index.css\"); insertCssLink(\"/js/vue/tables/index.css\");    ","permalink":"https://www.cheng92.com/vue/vue-my-plan/","tags":["vue3"],"title":"Vue3 周边源码学习计划表"},{"categories":["vue"],"contents":"  vue 资源: vuejs/awesome-vue: 🎉 A curated list of awesome things related to Vue.js\n SSR 框架： Ream - A Vue 3 framework for building amazing apps\n import.meta   类型声明：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50  interface ImportMeta { url: string readonly hot?: { readonly data: any accept(): void accept(cb: (mod: any) =\u0026gt; void): void accept(dep: string, cb: (mod: any) =\u0026gt; void): void accept(deps: readonly string[], cb: (mods: any[]) =\u0026gt; void): void /** * @deprecated */ acceptDeps(): never dispose(cb: (data: any) =\u0026gt; void): void decline(): void invalidate(): void on(event: string, cb: (...args: any[]) =\u0026gt; void): void } readonly env: ImportMetaEnv glob( pattern: string ): Record\u0026lt; string, () =\u0026gt; Promise\u0026lt;{ [key: string]: any }\u0026gt; \u0026gt; globEager( pattern: string ): Record\u0026lt; string, { [key: string]: any } \u0026gt; } interface ImportMetaEnv { [key: string]: string | boolean | undefined BASE_URL: string MODE: string DEV: boolean PROD: boolean }     实际项目输出结果：\n1 2 3 4 5 6 7 8 9 10 11  // import.meta import.meta.env = { url: \u0026#34;https://localhost:3000/src/main.ts\u0026#34;, env: { BASE_URL: \u0026#34;/\u0026#34;, MODE: \u0026#34;development\u0026#34;, DEV: true, PROD: false, SSR: false, }, };      问题列表    vite create-app 之后启动项目，在 import 的时候总提示文件不存在？\n   修改 vite.config.js 增加配置项 optimizeDeps -\u0026gt; exclude -\u0026gt; [\u0026#39;jsuites\u0026#39;]:\n   1 2 3 4 5 6 7 8 9 10  import { defineConfig } from \u0026#34;vite\u0026#34;; import vue from \u0026#34;@vitejs/plugin-vue\u0026#34;; // https://vitejs.dev/config/ export default defineConfig({ plugins: [vue()], optimizeDeps: { exclude: [\u0026#34;jsuites\u0026#34;], }, });      可用的 vue3 ui 库？\n Vue 3 UI component library for 2021 - DEV Community\n ElementUI ✅ \u0026gt; Ionic 移动端 ✅ \u0026gt; Primevue ✅ \u0026gt; Vuetify ❌ \u0026gt; Quasar ❌\n  import bgImg from \u0026#39;../assets/bg.jpg\u0026#39; 总是报错？\n9:21:21 PM [vite] Internal server error: Failed to resolve import \u0026#34;/@/assets/login_bg.jpg\u0026#34;. Does the file exist?   见 plugin-import-analysis 分析。\n    ","permalink":"https://www.cheng92.com/vue/vue-vite/","tags":["vue3,","vite"],"title":"Vue3 -\u003e Vite 脚手架"},{"categories":["issues"],"contents":"  各种疑难杂症集合。\n golang  go get 无法下载问题？   Get https://proxy.golang.org/golang.org/x/tools/gopls/@v/list: dial tcp 172.217.160.81:443: i/o timeout\n https://shockerli.net/post/go-get-golang-org-x-solution/\n  export GO111MODULE=on\n  export GOPROXY=https://goproxy.io\n      emacs  lsp 不能识别 webpack/vite 别名？   Default FAQ js(ts)config for webpack aliases doesn\u0026#39;t work. · Issue #890 · vuejs/vetur\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17  { \u0026#34;compilerOptions\u0026#34;: { \u0026#34;target\u0026#34;: \u0026#34;esnext\u0026#34;, \u0026#34;module\u0026#34;: \u0026#34;esnext\u0026#34;, \u0026#34;moduleResolution\u0026#34;: \u0026#34;node\u0026#34;, \u0026#34;strict\u0026#34;: true, \u0026#34;jsx\u0026#34;: \u0026#34;preserve\u0026#34;, \u0026#34;sourceMap\u0026#34;: true, \u0026#34;resolveJsonModule\u0026#34;: true, \u0026#34;esModuleInterop\u0026#34;: true, \u0026#34;lib\u0026#34;: [\u0026#34;esnext\u0026#34;, \u0026#34;dom\u0026#34;], + \u0026#34;paths\u0026#34;: { + \u0026#34;@/*\u0026#34;: [\u0026#34;src/*\u0026#34;] + }  }, \u0026#34;include\u0026#34;: [\u0026#34;src/**/*.ts\u0026#34;, \u0026#34;src/**/*.d.ts\u0026#34;, \u0026#34;src/**/*.tsx\u0026#34;, \u0026#34;src/**/*.vue\u0026#34;] }      在 tsconfig.json 中增加一项配置 paths 告诉 lsp 别名含义。\n  company-caf error   frontend company-pseudo-tooltip-frontend error - company-mode\nBut, I suppose I can get in ~/.emacs.d/.local/straight/repos/company-mode and git pull Did this but got this warning You are not currently on a branch. Please specify which branch you want to merge with. See git-pull(1) for details. =git pull \u0026lt;remote\u0026gt; \u0026lt;branch\u0026gt;=      web  require.cache 缓存问题?   在学习 vue3.0 代码中遇到一个问题，在 org-src-block 中 require vue package 文 件，在修改这个 js 的时候执行 org-src-block 最后的结果怎么都是没修改之前的。\n 答： 因为 require 之前引入过可能被缓存了起来，可以通过下面的函数来避免引入已缓存的 模块。\n1 2 3 4 5  function requireUncached(module) { delete require.cache[require.resolve(module)]; return require(module); }     即。在 require 之前先删除缓存，然后使用 requireUncached(path) 去引入文件。\n   怎么在 html 中使用 .svg 文件  1 2 3 4 5  \u0026lt;img src=\u0026#34;your.svg\u0026#34;/\u0026gt; \u0026lt;object data=\u0026#34;your.svg\u0026#34;/\u0026gt; \u0026lt;iframe src=\u0026#34;your.svg\u0026#34;/\u0026gt; \u0026lt;embed src=\u0026#34;your.svg\u0026#34;/\u0026gt; \u0026lt;div style=\u0026#34;background:url(your.svg)\u0026#34;\u0026gt;...\u0026lt;/div\u0026gt;      https://vecta.io/blog/best-way-to-embed-svg\n    google fonts 加速   直连更快…\n   site name ping     http://fonts.useso.com 360 unknown   http://fonts.lug.ustc.edu.cn 中科大 66ms   http://fonts.css.network 捷速网络 香港 160ms   http://fonts.gmirror.org 七牛 timeout      IE8 解决 Object.defineProperty 兼容性问题   http://lpsjj.cn/thread-222-1-1.html\n    typescript  TypeScript error: Property \u0026#39;X\u0026#39; does not exist on type \u0026#39;Window\u0026#39;  1  declare const window: any      TS2307: Cannot find module \u0026#39;X\u0026#39; or its corresponding type declarations.   是因为找不到 vue 文件，直接加上后缀 x.vue 就好了。\n    macos   Can\u0026#39;t delete APFS local snapshots | Apple Developer Forums\n $ tmutil thinlocalsnapshots / 999999999999999 4\nLaTeX  basictex   Reference -\u0026gt;\n $ brew install --cask basictex\n 安装之后，需要手动安装，不然找不到 pdflatex ：\n╭─simon@gcl ~ ╰─$ pdflatex zsh: command not found: pdflatex   手动安装过程：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  # simon @ gcl in ~ [10:31:59] C:1 $ bash --login ~ The default interactive shell is now zsh. To update your account to use zsh, please run `chsh -s /bin/zsh`. For more details, please visit https://support.apple.com/kb/HT208050. gcl:~ simon$ which pdflatex /Library/TeX/texbin/pdflatex gcl:~ simon$ cd /usr/local/Caskroom/basictex/ gcl:basictex simon$ ls 2021.0325 gcl:basictex simon$ cd 2021.0325/ gcl:2021.0325 simon$ ls mactex-basictex-20210325.pkg gcl:2021.0325 simon$ open mactex-basictex-20210325.pkg          其他  Pulling without specifying how to reconcile divergent branches is … ?  WARNING\n hint: Pulling without specifying how to reconcile divergent branches is hint: discouraged. You can squelch this message by running one of the following hint: commands sometime before your next pull: hint: hint: git config pull.rebase false # merge (the default strategy) hint: git config pull.rebase true # rebase hint: git config pull.ff only # fast-forward only hint: hint: You can replace \u0026#34;git config\u0026#34; with \u0026#34;git config –global\u0026#34; to set a default hint: preference for all repositories. You can also pass –rebase, –no-rebase, hint: or –ff-only on the command line to override the configured default per hint: invocation.\n  修复:\n1 2  # 全局设置 $ git config --global pull.ff only      kex_exchange_identification: read: Connection reset by peer?  WARNING\n $ git clone git@code.aliyun.com:gccll/cloudboss.git Cloning into \u0026#39;cloudboss\u0026#39;… kex_exchange_identification: read: Connection reset by peer fatal: Could not read from remote repository.\n Please make sure you have the correct access rights and the repository exists.\n  网络问题，直接换个网络就行了。\n  hugo even 修改 scss 没反应 ?   需要 hugo extended 版本：\n1 2 3 4 5 6 7  #/bin/bash mkdir $HOME/src cd $HOME/src git clone https://github.com/gohugoio/hugo.git cd hugo go install --tags extended     brew:\n1 2 3  $ brew install hugo $ cd /opt/local/bin $ ln -s /usr/local/bin/hugo /opt/local/bin/hugo      怎么更新项目中所有的 npm 包?   参考链接。\n1 2 3 4 5  $ npm install -g npm-check-updates $ ncu -u $ npm update $ npm install $ ncu -u \u0026amp;\u0026amp; npm update \u0026amp;\u0026amp; npm install      git ignore 无效(如： .log/)？  1 2 3 4 5 6 7  alias git-ignore-logs=\u0026#34;mv .log ~/Desktop \u0026amp;\u0026amp; git rm -r .log \u0026amp;\u0026amp; git commit -m \u0026#39;clear logs\u0026#39; \u0026amp;\u0026amp; git push\u0026#34; # commands $ mv .log ~/Desktop $ git rm -r .log $ git commit -m \u0026#34;clear logs\u0026#34; $ git push      华为手机📱现在哪里去现在谷歌商城?   -\u0026gt; 下载地址\n  添加 submodule 失败 ?  ➜ cheng92.com git:(master) ✗ g-subm-add https://github.com/gcclll/hugo-theme-even.git themes/even A git directory for \u0026#39;themes/even\u0026#39; is found locally with remote(s): origin\thttps://github.com/olOwOlo/hugo-theme-even.git If you want to reuse this local git directory instead of cloning again from https://github.com/gcclll/hugo-theme-even.git use the \u0026#39;--force\u0026#39; option. If the local git directory is not the correct repo or you are unsure what this means choose another name with the \u0026#39;--name\u0026#39; option.   本意就是 fork themes/even 出来修改，结果出现问题。\n 解决方案 1:\n  $ git ls-files stage themes/even\n  $ git rm --cached themes/even\n  $ git submodule add https://github.com/gcclll/hugo-theme-even.git themes/even\n  解决方案 2:\n  $ cd .git/modules\n  $ rm -rf themes/even\n  $ cd ../..\n  $ git submodule add https://github.com/gcclll/hugo-theme-even.git themes/even\n    ssh 登录次数过多问题(many authentication)   $ ssh-add -D 删除认证缓存\n  macos install adb   $ /bin/bash -c \u0026#34;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install.sh)\u0026#34;\n $ brew cask install android-platform-tools\n $ adb devices\n  批量下载 bilibili 视频(you-get 命令)？   macos in stall java environment ?   https://mkyong.com/java/how-to-install-java-on-mac-osx/\n $ brew tap adoptopenjdk/openjdk\n $ brew search jdk\n $ brew cask install adoptopenjdk11\n $ /usr/libexec/java_home -V\n $ java -version\n  git merge 的时候忽略指定文件？   https://www.jianshu.com/p/09b546b936a7\n  $ git config --global merge.ours.driver true\n  $ echo \u0026#39;index.php merge=ours\u0026#39; \u0026gt;\u0026gt; .gitattributes\n  $ git add .gitattributes\n  $ git commit -m \u0026#39;chore: Preserve index.php during merges\u0026#39;\n      ","permalink":"https://www.cheng92.com/post/issues/","tags":["issues"],"title":"开发过程中遇到的各种疑难杂症"},{"categories":["vue"],"contents":"  诗号：六道同坠，魔劫万千，引渡如来。  \n       stb-vue-next 完全拷贝于 vue-next ，主要目的用于学习。 \n 声明 ：vue-next runtime-core 中的 render 函数部分，\n本篇所使用的的测试例子是普 通的数字数组，实际中每个节点都是 VNode 结构，也就是说是唯一的，所以不存在不同节 点共享同一个内存空间问题，这也就是为何用例中没有重复数字的原因。(_就算是静态的可 复用节点也会执行 cloneVNode 克隆出一个全新的对象_)   更新日志\u0026amp;Todos ：\n  [2021-01-26 14:15:15] 创建\n     2229 - 423 = 1806 🤦‍♀️ 一个函数就将近两千行，😲！！\n 捷径👣：\n  如果只想了解如何 diff ？ 更新？\n   脑图  runtime-core/src/render.ts 脑图：\n  render 函数创建函数 baseCreateRender(options, createHydrationFns?)\n   init   feat(init): render function · gcclll/stb-vue-next@fb9738c · GitHub\n 两个 create render 函数：\n  createRenderer(options)\n  createHydrationRenderer(options)\n 这个还不清楚是干什么的，通过代码观察貌似跟 SSR 有关，先搁置先不管。\n   两个函数最终都是调用的 baseCreateRenderer(options, createHydrationFns)\n 并且就是这个函数将近两千行~~~~\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20  export function createRenderer\u0026lt; HostNode = RendererNode, HostElement = RendererElement \u0026gt;(options: RendererOptions\u0026lt;HostNode, HostElement\u0026gt;) { return baseCreateRenderer\u0026lt;HostNode, HostElement\u0026gt;(options); } export function createHydrationRenderer( options: RendererOptions\u0026lt;Node, Element\u0026gt; ) { return baseCreateRenderer(options, createHydrationFunctions); } // implementation function baseCreateRenderer( options: RendererOptions, createHydrationFns?: typeof createHydrationFunctions ) { // TODO }      function list   feat(init): renderer -\u0026gt; baseCreateRenderer TODOs · gcclll/stb-vue-next@b7f55a8 · GitHub\n baseCreateRenderer(options, createHydrationFns) 之所以这么长，是因为这里面包含 了三十几个函数的定义，下面将一个个按照流程逐一实现。\n   step what? step what?     options 解构 patch function   processText 文本处理 processCommentNode 注释节点   mountStaticNode 加载静态节点 patchStaticNode -   moveStaticNode - removeStaticNode 删除静态节点   processElement - mountElement -   setScopeId - mountChildren -   patchElement - patchBlockChildren -   patchProps - processFragment -   processComponent - mountComponent -   updateComponent - setupRenderEffect -   updateComponentPreRender - patchChildren -   patchUnkeyedChildren - patchKeyedChildren -   move  unmount    remove - removeFragment -   unmountComponent - unmountChildren -   getNextHostNode - render -   internals object, 上述函数别名 createHydrationFns -     最后函数返回 { render, hydrate, createApp }\n  render(vnode, container)   feat(init): baseCreateRender-\u0026gt; render · gcclll/stb-vue-next@9f5b40b · GitHub\n feat(init): baseCreateRender-\u0026gt; render with unmount · gcclll/stb-vue-next@d4e10d4 · GitHub\n1 2 3 4 5 6 7 8 9 10 11 12 13  const render: RootRenderFunction = (vnode, container) =\u0026gt; { // render(h(\u0026#39;div\u0026#39;), root)  if (vnode == null) { if (container._vnode) { unmount(container._vnode, null, null, true); } } else { patch(container._vnode || null, vnode, container); } // 执行所有 post 异步任务  flushPostFlushCbs(); container._vnode = vnode; };      vnode 为空，且 conatainer 上有注册过 _vnode，组要进行卸载\n 如： render(ref.value ? h(\u0026#39;div\u0026#39;) : null)\n ref.value = true 时候进入 else -\u0026gt; patch\n ref.value = false 时候进入 if -\u0026gt; unmount\n  否则执行 patch()，干什么了?\n  flushPostFlushCbs() 此时组件应该 mounted 了，手动刷掉所有 post cbs 。\n  保存 _vnode，方便下次进入是检测\n   接下来，需要继续实现 unmount() 和 patch()\n  patch(…args)   feat(init): baseCreateRender-\u0026gt; patch -\u0026gt; processElement · gcclll/stb-vue-next@eb48eb9 · GitHub\n 参数:\n   参数名 描述     n1 VNode, 老节点   n2 VNode, 新节点   container 容器   anchor ?   parentComponent 父级组件   parentSuspense Suspense ?   isSVG ?   optimized 是否优化过？      检测节点类型是不是一样，如果不一样直接卸载老的\n 因为类型都不一样了，可能整个🌲都发生了变化，直接卸载老的重新 patch 新的(n2)。\n1 2 3 4 5 6 7 8 9 10 11 12  export function isSameVNodeType(n1: VNode, n2: VNode): boolean { if ( __DEV__ \u0026amp;\u0026amp; n2.shapeFlag \u0026amp; ShapeFlags.COMPONENT \u0026amp;\u0026amp; hmrDirtyComponents.has(n2.type as ConcreteComponent) ) { // HMR only: if the component has been hot-updated, force a reload.  // 组件被热更新，强制重新加载  return false; } return n1.type === n2.type \u0026amp;\u0026amp; n1.key === n2.key; }      组件发生了热更新(HMR启用情况下)，强制重新加载组件\n  同时判断 type 和 key，有可能 type 一样(比如： ul\u0026gt;li 同类型元素的删除移动操作)\n    switch -\u0026gt; n2.type 根据类型不同走不同分支进行处理\n 只支持的类型： Text|Comment|Static 节点类型\n 组件类型(default 分支): ELEMENT/TELEPORT/COMPONENT/SUSPENSE\n    patch-\u0026gt;processElement(…args)   feat(init): baseCreateRender-\u0026gt; patch -\u0026gt; processElement imp · gcclll/stb-vue-next@761db2b · GitHub\n args 同 patch 的 args 。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27  const processElement = ( n1: VNode | null, n2: VNode, container: RendererElement, anchor: RendererNode | null, parentComponent: ComponentInternalInstance | null, parentSuspense: SuspenseBoundary | null, isSVB: boolean, isSVG: boolean, optimized: boolean ) =\u0026gt; { isSVG = isSVG || (n2.type as string) === \u0026#34;svg\u0026#34;; if (n1 == null) { // no old  mountElement( n2, container, anchor, parentComponent, parentSuspense, isSVG, optimized ); } else { patchElement(n1, n2, parentComponent, parentSuspense, isSVG, optimized); } };      没有 n1 老节点，直接 mount 新的 n2 节点\n  否则，进行 patch 操作\n   接下来按照 patchElement -\u0026gt; mountElement 顺序实现。\n  mountElement(…args)   进行到这里我们可以进行初步的判断， patch 和 mount 的区别，\n patch: 非首次加载组件的时候，用 new 和 old vnode 节点进行比较然后对发生变更的 节点进行替换或更新操作。\n mount: 属于首次加载组件的时候，属于重新创建节点的操作，不存在比较什么的一些操 作。\n 比如： render 里面的根据 vnode 来判断是 Unmount 还是 patch，以及 processElement 中根据 old vnode 来检测是不是有旧的节点(非首次)来判定是直接 Mount 组件还是 patch 比较更新组件。\ndefault ELEMENT   feat(add): patch element · gcclll/stb-vue-next@81af385 · GitHub\n render 函数实现， vnode 为空会进入卸载 unmount 流程，否则执行的是 patch ，这个应 该就是通过 vnode 节点结构执行 diff 和 dom 操作的入口了。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14  const render: RootRenderFunction = (vnode, container) =\u0026gt; { console.log(\u0026#39;render.......xxx\u0026#39;) // render(h(\u0026#39;div\u0026#39;), root)  if (vnode == null) { if (container._vnode) { unmount(container._vnode, null, null, true) } } else { patch(container._vnode || null, vnode, container) } // 执行所有 post 异步任务  flushPostFlushCbs() container._vnode = vnode }     注意上面的 flushPostFlushCbs() 是在 patch 之后执行的，也就是说 post cbs 会在组 件 mount/unmount 完成之后的下一个 tick 去执行的回调。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43  const patch: PatchFn = ( n1, n2, container, anchor = null, parentComponent = null, parentSuspense = null, isSVG = false, optimized = false ) =\u0026gt; { console.log(\u0026#39;patching...\u0026#39;) // 不同类型节点，直接卸载老的🌲  if (n1 \u0026amp;\u0026amp; !isSameVNodeType(n1, n2)) { // TODO  } // TODO patch bail, 进行全比较(full diff)  // 新节点处理  const { type, ref, shapeFlag } = n2 switch (type) { default: // ELEMENT/COMPONENT/TELEPORT/SUSPENSE  // 默认只支持这四种组件  if (shapeFlag \u0026amp; ShapeFlags.ELEMENT) { processElement( n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, optimized ) } break } if (ref != null \u0026amp;\u0026amp; parentComponent) { // TODO set ref  } }     patch 函数里面通过 switch 分支根据 ShapeFlags 的类型类调用对应的 processXxx 函数进行处理 old/new vnode 节点，而这里的 ShapeFlags 值的依据来自哪里？是在哪 里赋值的，由由什么作用？ 。\n 这里以普通的 ELEMENT 标签作为切入点来实现一个完整的过程，这里需要用到 processElement 。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27  const processElement = ( n1: VNode | null, n2: VNode, container: RendererElement, anchor: RendererNode | null, parentComponent: ComponentInternalInstance | null, parentSuspense: SuspenseBoundary | null, isSVG: boolean, optimized: boolean ) =\u0026gt; { isSVG = isSVG || (n2.type as string) === \u0026#39;svg\u0026#39; if (n1 == null) { // no old  mountElement( n2, container, anchor, parentComponent, parentSuspense, isSVG, optimized ) } else { // 该阶段还不会到这里  patchElement(n1, n2, parentComponent, parentSuspense, isSVG, optimized) } }     这里就是个很简单 if…else 判断是不是有旧的节点，没有是 mount 有则是 patch 操作， 所以需要完成 mountElement\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32  const mountElement = ( vnode: VNode, container: RendererElement, anchor: RendererNode | null, parentComponent: ComponentInternalInstance | null, parentSuspense: SuspenseBoundary | null, isSVG: boolean, optimized: boolean ) =\u0026gt; { console.log(\u0026#39;mount element...\u0026#39;) let el: RendererElement let vnodeHook: VNodeHook | undefined | null const { type, shapeFlag, patchFlag, props } = vnode if ( !__DEV__ \u0026amp;\u0026amp; vnode.el \u0026amp;\u0026amp; hostCloneNode !== undefined \u0026amp;\u0026amp; patchFlag === PatchFlags.HOISTED ) { // TODO  } else { el = vnode.el = hostCreateElement( vnode.type as string, isSVG, props \u0026amp;\u0026amp; props.is ) } // hostInsert  hostInsert(el, container, anchor) }     mountElement 里面两个核心的函数 hostCreateElement 和 hostInsert 分别来自 baseCreateRender(option) 的 option 参数。\n 这里就需要深入了解 runtime-test 这个包，它是作用为了能测试 runtime-core 编写的 一个测试报，这里包含了一些列的 DOM 操作函数，这些函数也会在封装 render 的时候 传递给 baseCreateRender(option) ，所以上面的 hostElement 和 hostInsert 就是来 自 runtime-test ，这里链接可以跳转查看该包里面具体包含哪些函数，又是做什么的， 这里就不展开细讲，主要看下相关的两个函数实现。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39  function createElement(tag: string): TestElement { const node: TestElement = { id: nodeId++, type: NodeTypes.ELEMENT, tag, children: [], props: {}, parentNode: null, eventListeners: null } // ... log  // avoid test nodes from being observed  markRaw(node) return node } function insert(child: TestNode, parent: TestElement, ref?: TestNode | null) { let refIndex if (ref) { refIndex = parent.children.indexOf(ref) if (refIndex === -1) { console.error(\u0026#39;ref: \u0026#39;, ref) console.error(\u0026#39;parent: \u0026#39;, parent) throw new Error(\u0026#39;ref is not a child of parent\u0026#39;) } } //...log  // remove the node first, but don\u0026#39;t log it as a REMOVE op  remove(child, false) // re-calculate the ref index because the child\u0026#39;s removal may have affected it  refIndex = ref ? parent.children.indexOf(ref) : -1 if (refIndex === -1) { parent.children.push(child) child.parentNode = parent } else { parent.children.splice(refIndex, 0, child) child.parentNode = parent } }     所以说，截至目前还并没有涉及到实际的 DOM 操作，还只是在 vnode 结构上进行插入删除 操作。\n 这里开始应该可以测试了：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  const { log, runtime_test } = require(process.env.BLOG_DIR_VUE + \u0026#34;/lib.js\u0026#34;); log(\u0026#34;xx\u0026#34;); runtime_test().then( ({ h, render, nodeOps, serializeInner: inner }) =\u0026gt; { let root = nodeOps.createElement(\u0026#34;div\u0026#34;); log(\u0026#39;\u0026gt;\u0026gt;\u0026gt; root ast, 这里 children 里面应该还没有节点\u0026#39;) log.f(root, [\u0026#39;type\u0026#39;, \u0026#39;children\u0026#39;]) log.f(h(\u0026#34;div\u0026#34;), [\u0026#34;type\u0026#34;]); log(\u0026#39;\u0026gt;\u0026gt;\u0026gt; begin render...\u0026#39;) render(h(\u0026#34;div\u0026#34;), root); log(\u0026#39;\u0026gt;\u0026gt;\u0026gt; after seririlize inner\u0026#39;) log(inner(root), [\u0026#39;type\u0026#39;, \u0026#39;children\u0026#39;]); }, (e) =\u0026gt; console.log(e.message) );    xx undefinedfalse \u0026gt;\u0026gt;\u0026gt; root ast, 这里 children 里面应该还没有节点 { type: \u0026#39;element\u0026#39;, children: [] } { type: \u0026#39;div\u0026#39; } \u0026gt;\u0026gt;\u0026gt; begin render... render.......xxx patching... mount element... mountElment else... el = vnode.el = hostCreateElement = { id: 1, type: \u0026#39;element\u0026#39;, tag: \u0026#39;div\u0026#39;, children: [], props: {}, parentNode: null, eventListeners: null } \u0026lt;ref *1\u0026gt; { id: 0, type: \u0026#39;element\u0026#39;, tag: \u0026#39;div\u0026#39;, children: [ { id: 1, type: \u0026#39;element\u0026#39;, tag: \u0026#39;div\u0026#39;, children: [], props: {}, parentNode: [Circular *1], eventListeners: null } ], props: {}, parentNode: null, eventListeners: null } \u0026gt;\u0026gt;\u0026gt; after seririlize inner \u0026lt;div\u0026gt;\u0026lt;/div\u0026gt;   注意看上面的结果，最后 h(\u0026#39;div\u0026#39;) 生成的节点别 insert 进了 root.children 中， 然后注意 insert 最后的实现插入替换部分: 当没有找到时 refIndex = -1，直接执行 尾部插入操作 push(...), 如果找到了就执行 splice(refIndex, 1, child)\n 所以这里直接执行的是直接尾部插入操作。\n 最后输出的 \u0026lt;div\u0026gt;\u0026lt;/div\u0026gt; 是由于调用了 serializeInner(root) 结果，也是相当于 DOM 操作了(serializeInner -\u0026gt; seririlize\u0026gt;children -\u0026gt; serializeElement -\u0026gt; 最后根据 tag, props, children 递归解析生成对应的 DOM 元素结构)。\n serializeElement 实现：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23  function serializeElement( node: TestElement, indent: number, depth: number ): string { const props = Object.keys(node.props) .map(key =\u0026gt; { const value = node.props[key] return isOn(key) || value == null ? `` : value === `` ? key : `${key}=${JSON.stringify(value)}` }) .filter(Boolean) .join(\u0026#39; \u0026#39;) const padding = indent ? ` `.repeat(indent).repeat(depth) : `` return ( `${padding}\u0026lt;${node.tag}${props ? ` ${props}` : ``}\u0026gt;` + `${serializeInner(node, indent, depth)}` + `${padding}\u0026lt;/${node.tag}\u0026gt;` ) }     所以到此应该是完成了最普通的 ELEMENT 类型元素从\n ast -\u0026gt; compiler-dom \u0026gt;\u0026gt; compiler-core \u0026gt;\u0026gt; compiler-sfc vnode -\u0026gt; runtime-core \u0026gt;\u0026gt; runtime-test(测试用) render -\u0026gt; runtime-core \u0026gt;\u0026gt; baseCreateRender \u0026gt;\u0026gt; render \u0026gt;\u0026gt; mount/unmount/patch -\u0026gt; 生成 DOM 元素结构较为完整的代码。\n  with props   feat(add): baseRenderer-\u0026gt;element with props · gcclll/stb-vue-next@46fc2a0 · GitHub\n1 2 3 4 5 6 7 8 9 10 11  const { log, f, runtime_test } = require(process.env.BLOG_DIR_VUE + \u0026#34;/lib.js\u0026#34;); import(process.env.BLOG_DIR_VUE + \u0026#34;/runtime-test.global.js\u0026#34;).then( ({ h, render, nodeOps, serializeInner: inner }) =\u0026gt; { const root = nodeOps.createElement(\u0026#34;div\u0026#34;); render(h(\u0026#34;div\u0026#34;, { id: \u0026#34;foo\u0026#34;, class: \u0026#34;bar\u0026#34; }), root); log(inner(root)); }, (err) =\u0026gt; { console.log(err.message); } );    undefinedfalse render....... patching... mount element... mountElment else... \u0026lt;div id=\u0026#34;foo\u0026#34; class=\u0026#34;bar\u0026#34;\u0026gt;\u0026lt;/div\u0026gt;   最后输出结果： \u0026lt;div id=\u0026#34;foo\u0026#34; class=\u0026#34;bar\u0026#34;\u0026gt;\u0026lt;/div\u0026gt;\n 还记得 runtime-core \u0026gt; h function 一节我们详细描述了 h 函数的用法，这里简单回顾下\n   h 第二个参数 描述     普通对象 当做 props 处理   数组类型 当做 children 处理   是个 VNode 类型对象 带有 __v_isVNode = true 属性， [vnode] 当做 children 处理     所以上面的 { id: \u0026#39;foo\u0026#39;, class: \u0026#39;bar\u0026#39; } 被当做属性传递给 createVNode(type, props, children ...) 函数\n 新增代码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56  // mountElement 增加 props 处理逻辑 const mountElement = ( vnode: VNode, container: RendererElement, anchor: RendererNode | null, parentComponent: ComponentInternalInstance | null, parentSuspense: SuspenseBoundary | null, isSVG: boolean, optimized: boolean ) =\u0026gt; { console.log(\u0026#39;mount element...\u0026#39;) // TODO  let el: RendererElement let vnodeHook: VNodeHook | undefined | null const { type, shapeFlag, patchFlag, props } = vnode if ( !__DEV__ \u0026amp;\u0026amp; vnode.el \u0026amp;\u0026amp; hostCloneNode !== undefined \u0026amp;\u0026amp; patchFlag === PatchFlags.HOISTED ) { // ...  } else { // 新增 start  if (props) { for (const key in props) { // vue 保留属性 ref/key/onVnodeXxx 生命周期  if (!isReservedProp(key)) { hostPatchProp( el, key, null, props[key], isSVG, vnode.children as VNode[], parentComponent, parentSuspense, unmountChildren ) } } if ((vnodeHook = props.onVnodeBeforeMount)) { // 执行 before mount hook  invokeVNodeHook(vnodeHook, parentComponent, vnode) } } // end 新增  } // ...  }     render -\u0026gt; patch -\u0026gt; case ELEMENT -\u0026gt; processElement -\u0026gt; mountElement\n 在 mountElement 中增加 props 处理逻辑，针对每个 prop 检测是不是保留名字\n key/ref/onVnodeXxx 等生命周期名，非保留名字才需要处理，调用 hostPatchProp() 处 理，后面加上 BeforeMount 生命周期钩子函数调用。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20  // runtime-test/src/patchProp.ts export function patchProp( el: TestElement, key: string, prevValue: any, nextValue: any ) { logNodeOp({ type: NodeOpTypes.PATCH, targetNode: el, propKey: key, propPrevValue: prevValue, propNextValue: nextValue }) el.props[key] = nextValue if (isOn(key)) { const event = key.slice(2).toLowerCase() ;(el.eventListeners || (el.eventListeners = {}))[event] = nextValue } }     普通属性直接更新到 el.props 中，如果是 onXxx 类型的事件，取出 xxx 作为 el.eventListeners 的 key 将事件名和其处理句柄保存起来。\n 这里的 el 实际上是个 ast 结构类型的对象，保存这每个节点的所有信息。\n  with text children  纯文本单节点 child   将纯文本做为 child ，将会被 h 函数转成 [child] 传递给 createVNode(type, props, children, ...) 做为它的children 参数处理。\n1 2 3 4 5 6 7 8 9 10 11 12 13  const { log, f, runtime_test } = require(process.env.BLOG_DIR_VUE + \u0026#34;/lib.js\u0026#34;); import(process.env.BLOG_DIR_VUE + \u0026#34;/runtime-test.global.js\u0026#34;).then( ({ h, render, nodeOps, serializeInner: inner }) =\u0026gt; { const _root = tag =\u0026gt; nodeOps.createElement(tag || \u0026#34;div\u0026#34;) log(\u0026#39;\u0026gt;\u0026gt;\u0026gt; 纯文本作为 children\u0026#39;) const r1 = _root() render(h(\u0026#39;div\u0026#39;, \u0026#39;pure test as children\u0026#39;), r1); log(inner(r1)); }, (err) =\u0026gt; { console.log(err.message); } );    undefinedfalse \u0026gt;\u0026gt;\u0026gt; 纯文本作为 children render....... patching... mount element... mountElment else... \u0026lt;div\u0026gt;pure test as children\u0026lt;/div\u0026gt;   上面示例是将纯文本作为 children 去渲染进 root 节点，涉及代码修改(mountElement()):\n feat(add): pure text as children to render · gcclll/stb-vue-next@43b868e · GitHub\n   数组类型(多个) children:   feat(add): render-\u0026gt;array children · gcclll/stb-vue-next@e6a5e61 · GitHub\n 当 h(type, propsOrChildren) 第二个参数为数组时会被当做 children 给 createVNode 。\n1 2 3 4 5 6 7 8 9 10 11  const { log, f, runtime_test } = require(process.env.BLOG_DIR_VUE + \u0026#34;/lib.js\u0026#34;); import(process.env.BLOG_DIR_VUE + \u0026#34;/runtime-test.global.js\u0026#34;).then( ({ h, render, nodeOps, serializeInner: inner }) =\u0026gt; { const root = nodeOps.createElement(\u0026#34;div\u0026#34;); render(h(\u0026#34;div\u0026#34;, [\u0026#34;foo\u0026#34;, \u0026#34; \u0026#34;, \u0026#34;bar\u0026#34;]), root); log(inner(root)); }, (err) =\u0026gt; { console.log(err.message); } );    undefinedfalse render....... patching... { type: \u0026#39;div\u0026#39;, shapeFlag: 17 } xxxx case default... process element... mount element... mountElment else... patching... { type: Symbol(Text), shapeFlag: 8 } process text... patching... { type: Symbol(Text), shapeFlag: 8 } process text... patching... { type: Symbol(Text), shapeFlag: 8 } process text... \u0026lt;div\u0026gt;foo bar\u0026lt;/div\u0026gt;   从上面的输出可得出 render(h(\u0026#39;div\u0026#39;), [\u0026#39;foo\u0026#39;, \u0026#39; \u0026#39;, \u0026#39;bar\u0026#39;]), root) 大概执行流程:\n  root-\u0026gt;div\n  render, 根据 vnode 为空检测决定是 unmount 还是 patch\n  patch, 根据 new vnode 的 type(四种类 型 Text|Comment|Fragment|Static|default ) 决 定调用什么 processXxx 进行处理\n  case default 由于这里是根节点，且是 \u0026#39;div\u0026#39; 普通类型元素，进入 processElement\n  processElement, 根据 old vnode 判断是 mount 还是 patch 操作\n  无 old vnode, 没有旧的vnode表示是新节点，需要执行 mount 操作\n  mountElement, 需要检测 vnode.el 来判断是不是静态提升的节点，如果是静态节点 属于可复用的节点，需要 cloneVNode 出来使用，否则创建新的\n  else: hostCreateElement 创建新的元素，然后通过 shapeFlag 判断 children 是什么类型进入不同分支进行处理，这里是数组(ShapeFlags.ARRAY_CHILDREN) 所 以会调用 mountChildren(vnode.children, el, ...) 开始 mount children.\n  mountChldren , 会对 children 进行遍历，如果 child.el 存在说明是可复用节点 (静态提升的)，则将 child clone 出来使用，否则进行 normailize 处理(其实也就 是根据 child 数据类型不同执行 createVNode 返回新的 vnode 给 child)，最后将 child 传入 patch 回到第 二步进行递归 mount children\n    root-\u0026gt;div-\u0026gt;\u0026#39;foo\u0026#39;\n 在 1 最后进入递归之后，会进入到 patch 检测到 type 是 Text 类型，去调用 processText() 处理 \u0026#39;foo\u0026#39; 完成之后，再回溯递归处理下一个元素 \u0026#39; \u0026#39; 直到结束。\n  root-\u0026gt;div-\u0026gt;\u0026#39; \u0026#39; 同 2\n  root-\u0026gt;idv-\u0026gt;\u0026#39;bar\u0026#39; 同 2\n   涉及修改内容(renderer.ts -\u0026gt; baseCreateRender)：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96  // patch() // 增加 Text 类型分支处理 children: [\u0026#39;foo\u0026#39;, \u0026#39; \u0026#39;, \u0026#39;bar\u0026#39;] switch (type) { case Text: processText(n1, n2, container, anchor); break; } // 新增 processText(n1, n2, container, anchor) const processText: ProcessTextOrCommentFn = (n1, n2, container, anchor) =\u0026gt; { console.log(\u0026#34;process text...\u0026#34;); if (n1 == null /* old */) { // 新节点，插入处理  hostInsert( (n2.el = hostCreateText(n2.children as string)), container, anchor ); } else { // has old vnode, need to diff  } }; // hostInert -\u0026gt; 将 child insert 到 container.children 中去 // hostCreateText -\u0026gt; 创建 TEXT 类型的节点结构 // runtime-test/src/nodeOps.ts -\u0026gt; createText const node: TestText = { id: nodeId++, type: NodeTypes.TEXT, text, parentNode: null, }; // processElement -\u0026gt; mountElement 增加 ARRAY_CHILDREN // 分支处理， mountChildren /* else */ if (shapeFlag \u0026amp; ShapeFlags.ARRAY_CHILDREN) { mountChildren( vnode.children as VNodeArrayChildren, el, null, parentComponent, parentSuspense, isSVG \u0026amp;\u0026amp; type !== \u0026#34;foreignObject\u0026#34;, optimized || !!vnode.dynamicChildren ); } // mountChildren 遍历 vnode.children // 递归调用 patch() 处理每个 child // cloneIfMounted 是需要优化(静态提升的节点)，可复用的节点 // 将其 clone 出一份新的 vnode 出来使用 // normailizeVNode 是根据 child 的数据类型不同执行 createVNode 返回 // 新的 vnode 或 child 本身(vnode.el 存在的情况，被复用了) const mountChildren: MountChildrenFn = ( children, container, anchor, parentComponent, parentSuspense, isSVG, optimized, start = 0 ) =\u0026gt; { for (let i = start; i \u0026lt; children.length; i++) { const child = (children[i] = optimized ? // 这里是检测 child.el 是不是存在，如果存在则是可服用的 vnode  // 即需要提升的静态节点，则需要进行 cloneVNode 之后返回  // 新的 vnode 对象  cloneIfMounted(children[i] as VNode) : // 根据 child 的类型进行拆分处理  // 1. boolean, 创建一个空的 Comment  // 2. array, 使用 Fragment 将 child 包起来  // 3. object, 如果是对象，child.el 存在与否进行 clone  // 4. 其他情况，字符串或数字，当做 Text 类型处理  normalizeVNode(children[i])); // 然后进入 patch 递归处理 children  patch( null, child, container, anchor, parentComponent, parentSuspense, isSVG, optimized ); } }; // cloneIfMounted 是检测 vnode.el 是不是存在，如果存在说明有复用的情况 // 针对 template-compiled render fns 做的优化 export function cloneIfMounted(child: VNode): VNode { // child.el 如果存在的话，child 属于静态节点会被静态提升  // 所以需要 clone 一份出来，否则直接返回 child  return child.el === null ? child : cloneVNode(child); }        children+props 混合测试  1 2 3 4 5 6 7 8 9 10 11  const { log, f, runtime_test } = require(process.env.BLOG_DIR_VUE + \u0026#34;/lib.js\u0026#34;); import(process.env.BLOG_DIR_VUE + \u0026#34;/runtime-test.global.js\u0026#34;).then( ({ h, render, nodeOps, serializeInner: inner }) =\u0026gt; { const root = nodeOps.createElement(\u0026#34;div\u0026#34;); render(h(\u0026#34;div\u0026#34;, { id: \u0026#34;foo\u0026#34;, class: \u0026#39;baz\u0026#39; }, [\u0026#34;bar\u0026#34;, \u0026#39; \u0026#39;, h(\u0026#39;div\u0026#39;)]), root); log(inner(root)); }, (err) =\u0026gt; { console.log(err.message); } );    undefinedfalse render....... patching... { type: \u0026#39;div\u0026#39;, shapeFlag: 17 } xxxx case default... process element... mount element... mountElment else... patching... { type: Symbol(Text), shapeFlag: 8 } process text... patching... { type: Symbol(Text), shapeFlag: 8 } process text... patching... { type: \u0026#39;div\u0026#39;, shapeFlag: 1 } xxxx case default... process element... mount element... mountElment else... \u0026lt;div id=\u0026#34;foo\u0026#34; class=\u0026#34;baz\u0026#34;\u0026gt;bar \u0026lt;div\u0026gt;\u0026lt;/div\u0026gt;\u0026lt;/div\u0026gt;    小结   执行流程：\n render() -\u0026gt; vnode !== null -\u0026gt; patch() -\u0026gt; switch case -\u0026gt;\n default: processElement() -\u0026gt; 由于是首次加载 old vnode 为 null -\u0026gt;\n 所以执行 mountElement() 新创建元素进行 mount 操作。\n mountElement() 里面区分是否是可复用组件(HOISTED, 静态提升的组件)，通过检测 vnode.el 是否有值，因为如果曾经被使用过必定会进入 mountElement -\u0026gt; else 对 vnode.el 进行赋值操作。\n 如果是可复用的组件，直接 clone 一份新的 vnode 出来使用，否则进入 else 分支 createElement 创建新的节点 el = vnode.el = hostCreateElement(...) 。\n 在 mountElement 中优先对 children 进行 mount，然后处理 props ，因为有些时候 props 需要依赖 children 是不是加载完成了，比如: \u0026lt;option value\u0026gt; 元素，需要根据 value 最终的值选择使用哪个 child(前提是这个 child 必须已经加载完成了) 。\n children 的处理，有两个类型分支处理(TEXT_CHILDREN 和 ARRAY_CHILDREN)，为什么 只有两个呢？\n 这是因为在 createVNode() 函数中会调用 normalizeChildren() 对 children 进行 检测，分几种情况处理：\n   children 类型 type(ShapeFlags) 描述     Array ARRAY_CHILDREN -   Object SLOTS_CHILDREN 区分是 ELEMENT/TELEPORT 或其他类型   Function SLOTS_CHILDREN 函数直接当做插槽处理   String 或 Number TEXT_CHILDREN 当做文本处理     上面有个插槽类型，还记得 compiler-core 里面对插槽的编译结果吗？\n compiler-core 阶段对 slot标签和 v-slot 的解析源码分析 -\u0026gt;\n 大致解析结果就是组件内的所有元素按照一定的规则解析成插槽，最后生成的 render 函数 大概是：\n1 2 3 4 5 6  return (_openBlock(), _createBlock(\u0026#39;Comp\u0026#39;, null /* props */, { // 默认插槽  defualt: _withCtx(() =\u0026gt; [ /* ...slot children... */ ]), [named]: _withCtx(() =\u0026gt; [/* 动态具名插槽 */]), name: _withCtx(() =\u0026gt; [/* 具名插槽 */]), }))     所以当 children 是个对象的时候在 createVNode() -\u0026gt; normalizeChildren() 中会被 当做插槽来处理。\n    patchElement   render() -\u0026gt; patch() -\u0026gt; processElement() -\u0026gt;\n 当检测到 old vnode 存在的时候会进入到这个函数 patchElement() 进行更新操作。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39  const patchElement = ( n1: VNode, n2: VNode, parentComponent: ComponentInternalInstance | null, parentSuspense: SuspenseBoundary | null, isSVG: boolean, optimized: boolean ) =\u0026gt; { // 旧的 el 替换掉新的 el ?  // const el = (n2.el = n1.el!)  let { patchFlag, dynamicChildren } = n2 // #1426 take the old vnode\u0026#39;s patch flag into account since user may clone a  // compiler-generated vnode, which de-opts to FULL_PROPS  patchFlag |= n1.patchFlag \u0026amp; PatchFlags.FULL_PROPS // const oldProps = n1.props || EMPTY_OBJ  // const newProps = n2.props || EMPTY_OBJ  // TODO before update hooks  // TODO dirs, 指令处理  // TODO HRM updating  if (patchFlag \u0026gt; 0) { console.log(`patch flag \u0026gt; 0 ? ${patchFlag}`) } else if (!optimized \u0026amp;\u0026amp; dynamicChildren == null) { console.log({ optimized, patchFlag }) } // const areaChildrenSVG = isSVG \u0026amp;\u0026amp; n2.type !== \u0026#39;foreignObject\u0026#39;  if (dynamicChildren) { console.log(\u0026#39;dynamic children...\u0026#39;) } else if (!optimized) { console.log(\u0026#39;optimized null, 非可复用节点\u0026#39;) } // TODO vnode hook or dirs 处理  }    先做个测试，看下代码执行流程(patchElement() 里面加了点打印)：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25  const { log, f, shuffle, toSpan: _toSpan, runtime_test } = require(process.env .BLOG_DIR_VUE + \u0026#34;/lib.js\u0026#34;); import(process.env.BLOG_DIR_VUE + \u0026#34;/runtime-test.global.js\u0026#34;).then( ({ h, render, nodeOps, serializeInner: inner }) =\u0026gt; { let elm let root = nodeOps.createElement(\u0026#34;div\u0026#34;); const toSpan = (v) =\u0026gt; _toSpan(v, h); const renderChildren = (arr) =\u0026gt; { // 给 root\u0026gt;div 中插入 children  // \u0026lt;div\u0026gt;\u0026lt;span\u0026gt;1\u0026lt;/span\u0026gt;...\u0026lt;/div\u0026gt;  render(h(\u0026#34;div\u0026#34;, arr.map(toSpan)), root); return root.children[0]; }; // root 上挂一个 \u0026#39;\u0026lt;div id=\u0026#34;1\u0026#34;\u0026gt;hello\u0026lt;/div\u0026gt;\u0026#39;  render(h(\u0026#34;div\u0026#34;, { id: 1 }, \u0026#34;hello\u0026#34;), root); // 增加一个 \u0026lt;span\u0026gt;1\u0026lt;/span\u0026gt;  elm = renderChildren([1]) log(`elm.children.length = ${elm.children.length}`) }, (err) =\u0026gt; { console.log(err.message); } );    undefinedfalse render()... patch()... processElement()... mountElement()... mountElment else... render()... patch()... processElement()... patchElement()... { optimized: false, patchFlag: 0 } optimized null, 非可复用节点 patchChildren()... patchChildren, 非 text children patchChildren, 非 text children, 非 array children... elm.children.length = 1   从上面的结果可知我们该阶段需要实现的部分代码为：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42  // patchElement() // 这里是 props 处理 /* else */ if (!optimized \u0026amp;\u0026amp; dynamicChildren == null) { console.log({ optimized, patchFlag }); // TODO patchProps } // 和 /* else */ if (!optimized) { console.log(\u0026#34;optimized null, 非可复用节点\u0026#34;); } // patchChildren() /* else */ { console.log(\u0026#34;patchChildren, old 非 text children\u0026#34;); /* else */ { console.log( \u0026#34;patchChildren, old 非 text children, new 非 array children...\u0026#34; ); // prev children was text or null  // new children is array or null  // 老的 children 是 text，新的又是数组情况  if (prevShapeFlag \u0026amp; ShapeFlags.TEXT_CHILDREN) { // 先清空？  hostSetElementText(container, \u0026#34;\u0026#34;); } // 然后直接重新加载新的 array children -\u0026gt; c2  // old children 是 array  if (shapeFlag \u0026amp; ShapeFlags.ARRAY_CHILDREN) { mountChildren( c2 as VNodeArrayChildren, container, anchor, parentComponent, parentSuspense, isSVG, optimized ); } } }     重新测试：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25  const { log, f, shuffle, toSpan: _toSpan, runtime_test } = require(process.env .BLOG_DIR_VUE + \u0026#34;/lib.js\u0026#34;); import(process.env.BLOG_DIR_VUE + \u0026#34;/runtime-test.global.js\u0026#34;).then( ({ h, render, nodeOps, serializeInner: inner }) =\u0026gt; { let elm let root = nodeOps.createElement(\u0026#34;div\u0026#34;); const toSpan = (v) =\u0026gt; _toSpan(v, h); const renderChildren = (arr) =\u0026gt; { // 给 root\u0026gt;div 中插入 children  // \u0026lt;div\u0026gt;\u0026lt;span\u0026gt;1\u0026lt;/span\u0026gt;...\u0026lt;/div\u0026gt;  render(h(\u0026#34;div\u0026#34;, arr.map(toSpan)), root); return root.children[0]; }; // root 上挂一个 \u0026#39;\u0026lt;div id=\u0026#34;1\u0026#34;\u0026gt;hello\u0026lt;/div\u0026gt;\u0026#39;  render(h(\u0026#34;div\u0026#34;, { id: 1 }, \u0026#34;hello\u0026#34;), root); // 增加一个 \u0026lt;span\u0026gt;1\u0026lt;/span\u0026gt;  elm = renderChildren([1]) log(`elm.children.length = ${elm.children.length}`) }, (err) =\u0026gt; { console.log(err.message); } );    undefinedfalse render()... patch()... processElement()... mountElement()... mountElment else... render()... patch()... processElement()... patchElement()... { optimized: false, patchFlag: 0 } optimized null, 非可复用节点 patchChildren()... patchChildren, old 非 text children patchChildren, old 非 text children, new 非 array children... patch()... processElement()... mountElement()... mountElment else... elm.children.length = 1   因此到这里将会进入 patchChildren(n1, n2, …) 去解析 \u0026#34;hello\u0026#34; 这个文本孩子节点。\n feat(add): patchElement-\u0026gt;patchChildren · gcclll/stb-vue-next@26d2bfd\n  patchChildren(n1,n2,…)    简化代码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48  const patchChildren: PatchChildrenFn = (n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, optimized = false) { if (patchFlag \u0026gt; 0) { if (patchFlag \u0026amp; PatchFlags.KEYED_FRAGMENT) { // 针对有 key 属性被 fragment 包裹起来的元素(例如： v-for)  // ... patchKeyedChildren(...)  return } else if (patchFlag \u0026amp; PatchFlags.UNKEYED_FRAGMENT) { // ... patchUnkeyedChildren(...)  return } } // children 有三种可能，text, array, 或没有孩子节点  if (shapeFlag \u0026amp; ShapeFlags.TEXT_CHILDREN) { // text children  if (prevShapeFlag \u0026amp; ShapeFlags.ARRAY_CHILDREN) { // 如果是数组，直接 unmount 掉  // unmountChildren(c1, ...)  } if (c2 !== c1) { // hostSetElementText(container, c2) 直接替换文本  } } else { // 非文本节点处理  if (prevShapeFlag \u0026amp; ShapeFlags.ARRAY_CHILDREN) { // 之前的 children 是 数组类型  if (shapeFlag \u0026amp; shapeFlag.ARRAY_CHILDREN) { // 新的也是数组，直接进行 full diff  // patchKeyedChildren(...)  } else { // 到这里表示没有新的孩子节点，等价于删除操作，直接卸载老的就行  // unmountChildren(c1, ...)  } } else { // 这种情况，old 是 text | null  // 新的是数组或 null  if (prevShapeFlag \u0026amp; ShapeFlags.TEXT_CHILDREN){ // 先清空老的文本节点  // hostSetElementText(container, \u0026#39;\u0026#39;)  } // 如果新的是数组，直接 mount，因为之前的如果是文本在上面已经清空了  if (shapeFlag \u0026amp; ShapeFlags.ARRAY_CHILDREN) { // mountChildren(c2, container, ...)  } } } }     所以总结下来有几种情况的组合：\n  首先是 patchFlag \u0026gt; 0 情况，需要局部 diff update(比如： v-for)，这里需要区分是 否有 key 属性\n  keyed: patchKeyedChildren(c1, c2, …)\n  unkeyed: patchUnkeyedChildren(c1, c2, …)\n    到这里 patchFlag \u0026lt;= 0 ，需要进行 full diff 的情况\n 这种情况下只有三种可能的 children: text|array|null\n 这三种情况结合 old + new 有多重组合需要考虑。\n  new text + old array: 直接卸载 old array, 将 parent 内容设置成 new text\n  new array + old array: 当做 keyed children 调用 patchKeyedChildren(c1, c2, …) 处理\n  new null + old array: 直接卸载 old array(unmountChildren(c1, …))\n  new array + old null: 直接 mount new array(mountChildren(c2, …))\n     这里涉及到几个相关函数：\n patchKeyedChildren(c1, c2, container, parentAnchor, parentComponent, parentSuspense, isSVG, optimized)\n patchUnkeyedChildren(c1, c2, container, parentAnchor, parentComponent, parentSuspense, isSVG, optimized)\n unmountChildren(children, parentComponent, parentSuspense, doRemove, optimized, start)\n mountChildren(children, container, anchor, parentComponent, parentSuspense, isSVG, optimized, start)\n 根据上面的分析，会逐一实现各种情况。\n1 2 3 4 5 6 7 8 9 10 11  digraph G{ rankdir=LR; node[shape=box, style=filled, color=\u0026#34;.7.3 1.0\u0026#34;];//一个node的属性 size = \u0026#34;6, 4\u0026#34;;//图片大小 patch-\u0026gt;processElement processElement-\u0026gt;n1[label=\u0026#34;节点已存在?\u0026#34;] n1[shape=diamond]; n1-\u0026gt;mountElement[label=\u0026#34;no\u0026#34;] n1-\u0026gt;patchElement[label=\u0026#34;yes\u0026#34;] mountElement-\u0026gt;patch[style=dotted, color = red] }    new text + old array   feat(add): new text + old array · gcclll/stb-vue-next@7019c9d\n patchChildren: 先 unmountChildren(c1) -\u0026gt; hostSetElementText(container, c2)\n1 2 3 4 5 6 7 8 9 10 11 12  // children 有三种可能： text, array, 或没有 children if (shapeFlag \u0026amp; ShapeFlags.TEXT_CHILDREN) { console.log(\u0026#34;patchChildren, new text...\u0026#34;); // text children fast path  if (prevShapeFlag \u0026amp; ShapeFlags.ARRAY_CHILDREN) { unmountChildren(c1 as VNode[], parentComponent, parentSuspense); } if (c2 !== c1) { hostSetElementText(container, c2 as string); } }     unmountChildren(…) -\u0026gt; 遍历 children 调用 unmount(children[i], ..)\n unmount(vnode, …) 中递归调用 unmountChildren(children, …)\n 但是这部分逻辑自始至终 doRemove 都是 false，所以不会执行 doRemove: remove(vnode)， 因为如上面的代码，在 c1 !== c2 的时候执行了 hostSetElementText(container, c2)这 里面首先会直接清空 container.children 然后重新赋值，因此 remove(vnode) 没有执 行也会实现直接替换操作，这里属于 full diff。\n 测试:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24  const { log, f, shuffle, runtime_test } = require(process.env .BLOG_DIR_VUE + \u0026#34;/lib.js\u0026#34;); import(process.env.BLOG_DIR_VUE + \u0026#34;/runtime-test.global.js\u0026#34;).then( ({ h, render, nodeOps, serializeInner: inner }) =\u0026gt; { let elm let root = nodeOps.createElement(\u0026#34;div\u0026#34;); // root 上挂一个  // \u0026#39;\u0026lt;div id=\u0026#34;1\u0026#34;\u0026gt;\u0026lt;span\u0026gt;1\u0026lt;/span\u0026gt;\u0026lt;span\u0026gt;2\u0026lt;/span\u0026gt;\u0026lt;/div\u0026gt;\u0026#39;  render(h(\u0026#34;div\u0026#34;, { id: 1 }, [ // #1  h(\u0026#39;span\u0026#39;, \u0026#39;1\u0026#39;), h(\u0026#39;span\u0026#39;, \u0026#39;2\u0026#39;) ]), root); // 增加一个 \u0026lt;span\u0026gt;1\u0026lt;/span\u0026gt;  log([\u0026#39;1. div children length = \u0026#39;, root.children[0].children.length]) render(h(\u0026#39;div\u0026#39;, { id: 1 }, \u0026#39;hello\u0026#39;), root) // #2  log([\u0026#39;2. div children length = \u0026#39;, root.children[0].children.length]) }, (err) =\u0026gt; { console.log(err.message); } );    undefinedfalse render()... patch()... processElement()... mountElement()... mountElment else... patch()... processElement()... mountElement()... mountElment else... patch()... processElement()... mountElement()... mountElment else... 1. div children length = 2 render()... patch()... processElement()... patchElement()... { optimized: false, patchFlag: 0 } optimized null, 非可复用节点 patchChildren()... patchChildren, new text... 2. div children length = 1   如上结果，最开始有三个递归：\n patch() -\u0026gt; processElement() -\u0026gt; mountElement() -\u0026gt; patch()\n1 2 3 4 5 6 7 8  digraph G{ rankdir=LR; size = \u0026#34;6, 4\u0026#34;;//图片大小 node[shape = box, style = filled, color = \u0026#34;.7.3 1.0\u0026#34;];//一个node的属性 patch-\u0026gt;processElement; processElement-\u0026gt;mountElement; mountElement-\u0026gt;patch[style = dotted, color = red] }     #1 渲染过程中，分别处理 div -\u0026gt; span 1 -\u0026gt; span 2 。\n #2 渲染过程中，属于 full diff 操作，检测到 old array, new text，所以直接清空 了 div.children~，然后复制 ~div.children = [text node]\n  new null + old array   feat(add): patchChildren -\u0026gt; patch new null, old array · gcclll/stb-vue-next@3f45ac5\n 新增代码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14  if (prevShapeFlag \u0026amp; ShapeFlags.ARRAY_CHILDREN) { if (shapeFlag \u0026amp; ShapeFlags.ARRAY_CHILDREN) { console.log(\u0026#34;patchChildren, new array, old array...\u0026#34;); // TODO patchKeyedChildren  } else { // new null, old array 直接卸载 old  unmountChildren( c1 as VNode[], parentComponent, parentSuspense, true /* doRemove */ ); } }     如果 new null 直接卸载 old array 就好了，注意第四个参数传的是 doRemove:true 这 样 unmount() 里面就会去调用 remove()\n 测试:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25  const { log, f, shuffle, runtime_test } = require(process.env .BLOG_DIR_VUE + \u0026#34;/lib.js\u0026#34;); import(process.env.BLOG_DIR_VUE + \u0026#34;/runtime-test.global.js\u0026#34;).then( ({ h, render, nodeOps, serializeInner: inner }) =\u0026gt; { let elm let root = nodeOps.createElement(\u0026#34;div\u0026#34;); // root 上挂一个  // \u0026#39;\u0026lt;div id=\u0026#34;1\u0026#34;\u0026gt;\u0026lt;span\u0026gt;1\u0026lt;/span\u0026gt;\u0026lt;span\u0026gt;2\u0026lt;/span\u0026gt;\u0026lt;/div\u0026gt;\u0026#39;  render(h(\u0026#34;div\u0026#34;, { id: 1 }, [ // #1  h(\u0026#39;span\u0026#39;, \u0026#39;1\u0026#39;), h(\u0026#39;span\u0026#39;, \u0026#39;2\u0026#39;) ]), root); // 增加一个 \u0026lt;span\u0026gt;1\u0026lt;/span\u0026gt;  log([\u0026#39;1. div children length = \u0026#39;, root.children[0].children.length]) render(h(\u0026#39;div\u0026#39;, { id: 1 }, null), root) // #2  log([\u0026#39;2. div children length = \u0026#39;, root.children[0].children.length]) }, (err) =\u0026gt; { console.log(err.message); } );    undefinedfalse render()... patch()... processElement()... mountElement()... mountElment else... patch()... processElement()... mountElement()... mountElment else... patch()... processElement()... mountElement()... mountElment else... 1. div children length = 2 render()... patch()... processElement()... patchElement()... { optimized: false, patchFlag: 0 } optimized null, 非可复用节点 patchChildren()... patchChildren, new not text... patchChildren, new null, old array... 2. div children length = 0  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  digraph G{ rankdir=LR; size = \u0026#34;6, 4\u0026#34;;//图片大小 node[shape = box, style = filled, color = \u0026#34;.7.3 1.0\u0026#34;];//一个node的属性 render2,render1[shape=circle,fillcolor=red] render1-\u0026gt;patch[label=\u0026#34;two span\u0026#34;]; patch-\u0026gt;processElement; processElement-\u0026gt;mountElement[label=\u0026#34;节点不存在\u0026#34;]; processElement-\u0026gt;patchElement[label=\u0026#34;节点存在\u0026#34;,color=\u0026#34;blue\u0026#34;]; mountElement-\u0026gt;patch[style=dotted, color=red] render2-\u0026gt;patch[label=\u0026#34;null\u0026#34;,color=\u0026#34;blue\u0026#34;]; patchElement-\u0026gt;patchChildren[color=\u0026#34;blue\u0026#34;]; patchChildren-\u0026gt;unmountChildren[label=\u0026#34;new null\u0026#34;,color=\u0026#34;blue\u0026#34;] }      new array + old null/text   这种情况，如果是 old text，会先执行\n1 2 3  if (prevShapeFlag \u0026amp; ShapeFlags.TEXT_CHILDREN) { hostSetElementText(container, \u0026#34;\u0026#34;); }     将 conteiner.children 清空。\n 然后执行 mountChidren(c2) 插入新的 array node 。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17  // prev children was text OR null // new children is array OR null if (prevShapeFlag \u0026amp; ShapeFlags.TEXT_CHILDREN) { hostSetElementText(container, \u0026#34;\u0026#34;); } // mount new if array if (shapeFlag \u0026amp; ShapeFlags.ARRAY_CHILDREN) { mountChildren( c2 as VNodeArrayChildren, container, anchor, parentComponent, parentSuspense, isSVG, optimized ); }     测试：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25  const { log, f, shuffle, runtime_test } = require(process.env .BLOG_DIR_VUE + \u0026#34;/lib.js\u0026#34;); import(process.env.BLOG_DIR_VUE + \u0026#34;/runtime-test.global.js\u0026#34;).then( ({ h, render, nodeOps, serializeInner: inner }) =\u0026gt; { let elm let root = nodeOps.createElement(\u0026#34;div\u0026#34;); // root 上挂一个  // \u0026#39;\u0026lt;div id=\u0026#34;1\u0026#34;\u0026gt;\u0026lt;span\u0026gt;1\u0026lt;/span\u0026gt;\u0026lt;span\u0026gt;2\u0026lt;/span\u0026gt;\u0026lt;/div\u0026gt;\u0026#39;  render(h(\u0026#34;div\u0026#34;, { id: 1 }, null), root); // 增加一个 \u0026lt;span\u0026gt;1\u0026lt;/span\u0026gt;  log([\u0026#39;1. div children length = \u0026#39;, root.children[0].children.length]) render(h(\u0026#39;div\u0026#39;, { id: 1 }, [ // #1  h(\u0026#39;span\u0026#39;, \u0026#39;1\u0026#39;), h(\u0026#39;span\u0026#39;, \u0026#39;2\u0026#39;) ]), root) // #2  log([\u0026#39;2. div children length = \u0026#39;, root.children[0].children.length]) }, (err) =\u0026gt; { console.log(err.message); } );    undefinedfalse render()... patch()... processElement()... mountElement()... mountElment else... 1. div children length = 0 render()... patch()... processElement()... patchElement()... { optimized: false, patchFlag: 0 } optimized null, 非可复用节点 patchChildren()... patchChildren, new not text... patchChildren, old text | null... patchChildren, new array... patch()... processElement()... mountElement()... mountElment else... patch()... processElement()... mountElement()... mountElment else... 2. div children length = 2    new array + old array     patchKeyedChildren    feat(add): patchKeyedChildren · gcclll/stb-vue-next@4a6a1f2\n 代码中列出了几种可能的情况：\n  old, new nodes 开头相同，从左到右方向以不同位置为起点开始比较\n  old, new nodes 结尾相同，从右到左方向以不同位置为起点开始比较\n  old ⊂ new，old 为 new 的真子集，这种情况视为新增节点，需要对新增的节点进行 mount 操作\n  old ⊃ new , new 为 old 的真子集，这种情况视为删除节点，需要对多余的节点进行 unmount 操作\n  old,new 没有特别明显的规律可遵循的，处理起来会比较麻烦\n  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60  // 24. 可能所有都是 keyed 也可能部分 const patchKeyedChildren = ( c1: VNode[], c2: VNodeArrayChildren, container: RendererElement, parentAnchor: RendererNode | null, parentComponent: ComponentInternalInstance | null, parentSuspense: SuspenseBoundary | null, isSVG: boolean, optimized: boolean ) =\u0026gt; { let i = 0; const l2 = c2.length; let e1 = c1.length - 1; // 上一个结束索引  let e2 = l2 - 1; // 下一个结束索引  // 1. sync from start  // (a b) c  // (a b) d e  while (i \u0026lt;= e1 \u0026amp;\u0026amp; i \u0026lt;= e2) { // TODO  } // 2. sync from end  // a (b c)  // d e (b c)  while (i \u0026lt;= e1 \u0026amp;\u0026amp; i \u0026lt;= e2) { // TODO  } // 3. common sequence + mount  // (a b)  // (a b) c  // i = 2, e1 = 1, e2 = 2  // (a b)  // c (a b)  // i = 0, e1 = -1, e2 = 0  if (i \u0026gt; e1) { // TODO  } // 4. common sequence + unmount  // (a b) c  // (a b)  // i = 2, e1 = 2, e2 = 1  // a (b c)  // (b c)  // i = 0, e1 = 0, e2 = -1  else if (i \u0026gt; e2) { // TODO  } // 5. unknown sequence, 未知序列  // [i ... e1 + 1]: a b [c d e] f g  // [i ... e2 + 1]: a b [e d c h] f g  // i = 2, e1 = 4, e2 = 5  else { // TODO  } };     下面来一个个实现，揭开 diff -\u0026gt; patch 的神秘面纱！！！\n 在进行之前先看下一个函数 isSameVNodeType(n1,n2) ：\n1 2 3 4 5 6 7 8 9 10 11 12  export function isSameVNodeType(n1: VNode, n2: VNode): boolean { if ( __DEV__ \u0026amp;\u0026amp; n2.shapeFlag \u0026amp; ShapeFlags.COMPONENT \u0026amp;\u0026amp; hmrDirtyComponents.has(n2.type as ConcreteComponent) ) { // HMR only: if the component has been hot-updated, force a reload.  // 组件被热更新，强制重新加载  return false } return n1.type === n2.type \u0026amp;\u0026amp; n1.key === n2.key }     这个函数用来检测两个节点是不是类似节点(需同时满足 type 和 key 相同)。\n 有点复杂，整的头疼🤕🤕。。。休息会😴😴！！！\n [2021-02-24 18:16:56] 通过画图终于把这块逻辑搞得有点清楚了！！！\n  剧情有点复杂，还是根据官方的测试用例来逐步熟悉各种情况的 diff -\u0026gt; patch 吧。\n 声明：\n  所有 children [1,2,3] 都将自身值作为节点的属性 key 值\n  下面的所有用例都基于节点有 key 属性为前提\n    fix: patchKeydChildren if · gcclll/stb-vue-next@b7edc1b\n 大致移动规则流程图：\n append([1] -\u0026gt; [1,2,3])  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24  const { log, f, shuffle, runtime_test, renderChildren } = require(process.env .BLOG_DIR_VUE + \u0026#34;/lib.js\u0026#34;); import(process.env.BLOG_DIR_VUE + \u0026#34;/runtime-test.global.js\u0026#34;).then( ({ h, render, nodeOps, serializeInner: inner }) =\u0026gt; { let elm; let root = nodeOps.createElement(\u0026#34;div\u0026#34;); // \u0026lt;div\u0026gt;hello\u0026lt;/div\u0026gt;  render(h(\u0026#34;div\u0026#34;, { id: 1 }, \u0026#34;hello\u0026#34;), root); const rc = (arr) =\u0026gt; renderChildren(render, root, h, arr); const logRoot = () =\u0026gt; log(\u0026#34;root: \u0026#34; + inner(root)); logRoot(); elm = rc([1]); log(\u0026#34;\u0026gt;\u0026gt;\u0026gt; render [1] DONE.\u0026#34;); logRoot(); elm = rc([1, 2, 3]); log(\u0026#34;\u0026gt;\u0026gt;\u0026gt; render [1,2,3] DONE.\u0026#34;); logRoot(); }, (err) =\u0026gt; { console.log(err.message); } );    undefinedfalse root: \u0026lt;div id=1\u0026gt;hello\u0026lt;/div\u0026gt; \u0026gt;\u0026gt;\u0026gt; render [1] DONE. root: \u0026lt;div id=1\u0026gt;\u0026lt;span\u0026gt;1\u0026lt;/span\u0026gt;\u0026lt;/div\u0026gt; patchKeyedChildren... while 1, sync from start... patch keyed 新增 ... \u0026gt;\u0026gt;\u0026gt; render [1,2,3] DONE. root: \u0026lt;div id=1\u0026gt;\u0026lt;span\u0026gt;1\u0026lt;/span\u0026gt;\u0026lt;span\u0026gt;2\u0026lt;/span\u0026gt;\u0026lt;span\u0026gt;3\u0026lt;/span\u0026gt;\u0026lt;/div\u0026gt;   如上结果，当执行 patchChildren 的时候，由于 old array ， new array 所以会执行 patchKeyedChildren 对两个 array 进行对比更新。\n while 1: 从左到右对同类型的 VNode 进行 patch ，所以这里 1 节点会在这里被 patch 掉 。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24  while (i \u0026lt;= e1 \u0026amp;\u0026amp; i \u0026lt;= e2) { console.log(\u0026#34;while 1, sync from start...\u0026#34;); const n1 = c1[i]; const n2 = (c2[i] = optimized // 静态节点  ? cloneIfMounted(c2[i] as VNode) : normalizeVNode(c2[i])); // type \u0026amp; key 相同  if (isSameVNodeType(n1, n2)) { patch( n1, n2, container, null, parentComponent, parentSuspense, isSVG, optimized ); } else { break; } i++; }     然后： i=1,e1=0,e2=2 满足 if(i\u0026gt;e1) 新增节点条件，对 [2,3] 进入新增节点逻辑 代码(if 分支)\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21  if (i \u0026gt; e1) { console.log(\u0026#34;patch keyed 新增 ...\u0026#34;); if (i \u0026lt;= e2) { const nextPos = e2 + 1; const anchor = nextPos \u0026lt; l2 ? (c2[nextPos] as VNode).el : parentAnchor; while (i \u0026lt;= e2) { patch( null, (c2[i] = optimized ? cloneIfMounted(c2[i] as VNode) : normalizeVNode(c2[i])), container, anchor, parentComponent, parentSuspense, isSVG ); i++; } } }     针对 [2,3] 分别执行：\n patch(null, c2[i], container, anchor,...)\n 注意这里 anchor 是 [3] 这个节点，但是由于在 container.children 是不存在的， 所以对于 [2] 会执行 append 操作(具体请查看 runtime-test/src/nodeOpts.ts:insert 函数实现)。\n 直到全部 append 到 container.children 结束。\n old: [1], new: [1,2,3]\n 这种情况还是比较简单的，直接 append 2,3 就行了。\n   prepend([4,5]-\u0026gt;[1,2,3,4,5])   实例分析： n1=[4,5], n2=[1,2,3,4,5] 经过 while1 什么都没做，经过 while2 同化掉 尾部 [4,5],i=0,e1=-1,e2=2= 满足 if(i\u0026gt;e1)\u0026amp;\u0026amp;if(i\u0026lt;e2) 属于新增节点操作，插入时 的参考节点为 c2[e2+1] ，之前分析过如果需要经过前两个 while 处理的节点都会在 patch 的过程中直接替换掉，比如这里的 [4,5] 会在 while2 中被替换掉(体现在 container.children 中)，新的 [4,5] 替换掉老的 [4,5] ，所以这里发生插入时的 anchor 实际是对应 container.children 中的 [4] 位置。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24  const { log, f, shuffle, runtime_test, renderChildren } = require(process.env .BLOG_DIR_VUE + \u0026#34;/lib.js\u0026#34;); import(process.env.BLOG_DIR_VUE + \u0026#34;/runtime-test.global.js\u0026#34;).then( ({ h, render, nodeOps, serializeInner: inner }) =\u0026gt; { let elm; let root = nodeOps.createElement(\u0026#34;div\u0026#34;); // \u0026lt;div\u0026gt;hello\u0026lt;/div\u0026gt;  render(h(\u0026#34;div\u0026#34;, { id: 1 }, \u0026#34;hello\u0026#34;), root); const rc = (arr) =\u0026gt; renderChildren(render, root, h, arr); const logRoot = () =\u0026gt; log(\u0026#34;root: \u0026#34; + inner(root)); logRoot(); elm = rc([4, 5]); log(\u0026#34;\u0026gt;\u0026gt;\u0026gt; render [4,5] DONE.\u0026#34;); logRoot(); elm = rc([1, 2, 3, 4, 5]); log(\u0026#34;\u0026gt;\u0026gt;\u0026gt; render [1,2,3,4,5] DONE.\u0026#34;); logRoot(); }, (err) =\u0026gt; { console.log(err.message); } );    undefinedfalse root: \u0026lt;div id=1\u0026gt;hello\u0026lt;/div\u0026gt; \u0026gt;\u0026gt;\u0026gt; render [4,5] DONE. root: \u0026lt;div id=1\u0026gt;\u0026lt;span\u0026gt;4\u0026lt;/span\u0026gt;\u0026lt;span\u0026gt;5\u0026lt;/span\u0026gt;\u0026lt;/div\u0026gt; patchKeyedChildren... while 1, sync from start... while 2, sync from end... while 2, sync from end... patch keyed 新增 ... \u0026gt;\u0026gt;\u0026gt; render [1,2,3,4,5] DONE. root: \u0026lt;div id=1\u0026gt;\u0026lt;span\u0026gt;1\u0026lt;/span\u0026gt;\u0026lt;span\u0026gt;2\u0026lt;/span\u0026gt;\u0026lt;span\u0026gt;3\u0026lt;/span\u0026gt;\u0026lt;span\u0026gt;4\u0026lt;/span\u0026gt;\u0026lt;span\u0026gt;5\u0026lt;/span\u0026gt;\u0026lt;/div\u0026gt;   上面两次 while 2 分别对应的是 5-\u0026gt;4 同化过程。\n 同类用例，不做多余分析了，直接看结果吧！\n  [1,2,4,5] 和 [1,2,3,4,5] 经过 while1(替换12) 和 while2(替换45) 之后 i=2,e1=1,e2=2 满足~if(i\u0026gt;e1)\u0026amp;\u0026amp;if(i\u0026lt;=e2)~ 插入操作，参考节点: anchor=c2[e2+1]=4 所以执行 patch时候会在 4(因为 anchor 有值) 之前插入 3 。\n     insert begin\u0026amp;end([2,3,4]-\u0026gt;[1,2,3,4,5])  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24  const { log, f, shuffle, runtime_test, renderChildren } = require(process.env .BLOG_DIR_VUE + \u0026#34;/lib.js\u0026#34;); import(process.env.BLOG_DIR_VUE + \u0026#34;/runtime-test.global.js\u0026#34;).then( ({ h, render, nodeOps, serializeInner: inner }) =\u0026gt; { let elm; let root = nodeOps.createElement(\u0026#34;div\u0026#34;); // \u0026lt;div\u0026gt;hello\u0026lt;/div\u0026gt;  render(h(\u0026#34;div\u0026#34;, { id: 1 }, \u0026#34;hello\u0026#34;), root); const rc = (arr) =\u0026gt; renderChildren(render, root, h, arr); const logRoot = () =\u0026gt; log(\u0026#34;root: \u0026#34; + inner(root)); logRoot(); elm = rc([2,3,4]); log(\u0026#34;\u0026gt;\u0026gt;\u0026gt; render [2,3,4] DONE.\u0026#34;); logRoot(); elm = rc([1, 2, 3, 4, 5]); log(\u0026#34;\u0026gt;\u0026gt;\u0026gt; render [1,2,3,4,5] DONE.\u0026#34;); logRoot(); }, (err) =\u0026gt; { console.log(err.message); } );    undefinedfalse root: \u0026lt;div id=1\u0026gt;hello\u0026lt;/div\u0026gt; \u0026gt;\u0026gt;\u0026gt; render [4,5] DONE. root: \u0026lt;div id=1\u0026gt;\u0026lt;span\u0026gt;2\u0026lt;/span\u0026gt;\u0026lt;span\u0026gt;3\u0026lt;/span\u0026gt;\u0026lt;span\u0026gt;4\u0026lt;/span\u0026gt;\u0026lt;/div\u0026gt; patchKeyedChildren... while 1, sync from start... while 2, sync from end... \u0026gt;\u0026gt;\u0026gt; render [1,2,3,4,5] DONE. root: \u0026lt;div id=1\u0026gt;\u0026lt;span\u0026gt;1\u0026lt;/span\u0026gt;\u0026lt;span\u0026gt;2\u0026lt;/span\u0026gt;\u0026lt;span\u0026gt;3\u0026lt;/span\u0026gt;\u0026lt;span\u0026gt;4\u0026lt;/span\u0026gt;\u0026lt;span\u0026gt;5\u0026lt;/span\u0026gt;\u0026lt;/div\u0026gt;   [2,3,4] 和 [1,2,3,4,5] 经过 while1 和 while2 什么都没做， i=0,e1=2,e2=4 既 不满足 if(i\u0026gt;e1) 也不满足 elseif(i\u0026gt;e2) 所以会进入 else 的无规则比较阶段。根 据之前脑图分析结果可知， else 执行的步骤大致是：\n  遍历 old children 替换 [2,3,4]\n 用 old [2,3,4] 的每个元素的 key 去 new [1,2,3,4,5] 里面去找对应的 key(type,key相等的节点)去替换老的，那么这里将会找到 [2,3,4] ，此时经过一个 for old children 循环执行替换，这里重点在于 newIndexToOldIndexMap 结果会更 新为 [0,1,2,3,0] 这里的 123 分别对应 [2,3,4] 在 old children 中的索引 + 1 的结果。\n  遍历 new children 检测 newIndexToOldIndexMap\n 这一步的循环是针对 new children 而言，作用是找出 newIndexToOldIndexMap 中不 为 0 的元素(也就是还未被使用的元素)，来执行插入操作。循环顺序从右到左执行， 则有(i-递减索引，index-newchild 的索引值,el-newchild,val-使用状态)：\n i=4,index=4,el=c2[index],val=0,anchor=null:\n 未使用，没有参考节点，属于纯 append 操作。\n i=3,2,1,val!==0 已经被使用了，跳过\n i=0,index=0,el=c2[index],val=0,anchor=c2[index+1]=1:\n 未使用，插入节点为 [1] 参考节点为 [2] 属于插入操作，在 [1] 之前插入。\n 最后得到结果： children=[1,2,3,4,5] 完成。\n   其实这里还是比较容易理解的，因为还没用到“有序递增序列”算法，因为 for old children 中的 key 是有序的且是 new children 的子集，所以遍历过程中 newIndex 为 0,1,2 后面的总是比前面的大，因此 maxNewIndexSoFar=2 直到结束🔚。\n 类似用例：\n  [] 和 [1,2,3,4,5] 这种情况等于是 newIndexToOldIndexMap=[0,0,0,0,0] 所有 new child 元素执行的都是尾部 append 操作。\n  [1,2,3,4,5] 和 render(h(\u0026#39;div\u0026#39;), root) 等于是 children=[] 直接删除 old children 操作\n  [1,2,3,4,5] 和 [3,4,5] 经过 while2 替换掉 [3,4,5] 剩下 old [1,2] 因在 new children 中找不到对应的元素，则会被删除。\n  [1,2,3,4,5] 和 [1,2,3] 经过 while1 替换掉 [1,2,3] 剩下的 old [4,5] 因 找不到对应的 new child 被删除。\n  [1,2,3,4,5] 和 [1,2,4,5] 经过 while1 替换掉 [1,2] 经过 while2 替换掉 [4,5] 剩下 [3] 因找不到 new child 而被删除。\n     move([1,2,3,4]-\u0026gt;[2,3,1,4])   这种情况会触发“最长递增序列”规则，进行替换，因为发生 diff-update 的原则是：更新 之后的顺序要和 new children 顺序一致，即原来是 1234 更新之后要保持 2314 顺序。\n 更新过程：\n  经过 while1 什么都不发生，因为 [1]-\u0026gt;[2] 非同类节点\n  经过 while2 替换掉 [4],i=0,e1=2,e2=2\n  if(i\u0026gt;e1) 不满足新增条件\n  elif(i\u0026gt;e2) 不满足删除条件\n  进入 else 无规则比较更新\n   测试：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24  const { log, f, shuffle, runtime_test, renderChildren } = require(process.env .BLOG_DIR_VUE + \u0026#34;/lib.js\u0026#34;); import(process.env.BLOG_DIR_VUE + \u0026#34;/runtime-test.global.js\u0026#34;).then( ({ h, render, nodeOps, serializeInner: inner }) =\u0026gt; { let elm; let root = nodeOps.createElement(\u0026#34;div\u0026#34;); // \u0026lt;div\u0026gt;hello\u0026lt;/div\u0026gt;  render(h(\u0026#34;div\u0026#34;, { id: 1 }, \u0026#34;hello\u0026#34;), root); const rc = (arr) =\u0026gt; renderChildren(render, root, h, arr); const logRoot = () =\u0026gt; log(\u0026#34;root: \u0026#34; + inner(root)); logRoot(); elm = rc([1,2,3,4]); log(\u0026#34;\u0026gt;\u0026gt;\u0026gt; render [1,2,3,4] DONE.\u0026#34;); logRoot(); elm = rc([2,3,1,4]); log(\u0026#34;\u0026gt;\u0026gt;\u0026gt; render [2,3,1,4] DONE.\u0026#34;); logRoot(); }, (err) =\u0026gt; { console.log(err.message); } );    undefinedfalse root: \u0026lt;div id=1\u0026gt;hello\u0026lt;/div\u0026gt; \u0026gt;\u0026gt;\u0026gt; render [1,2,3,4] DONE. root: \u0026lt;div id=1\u0026gt;\u0026lt;span\u0026gt;1\u0026lt;/span\u0026gt;\u0026lt;span\u0026gt;2\u0026lt;/span\u0026gt;\u0026lt;span\u0026gt;3\u0026lt;/span\u0026gt;\u0026lt;span\u0026gt;4\u0026lt;/span\u0026gt;\u0026lt;/div\u0026gt; patchKeyedChildren... while 1, sync from start... while 2, sync from end... while 2, sync from end... { arr: [ 2, 3, 1 ] } { result: [ 2, 1 ] } 最长增长序列: 0,1 move 交换... \u0026gt;\u0026gt;\u0026gt; render [2,3,1,4] DONE. root: \u0026lt;div id=1\u0026gt;\u0026lt;span\u0026gt;2\u0026lt;/span\u0026gt;\u0026lt;span\u0026gt;3\u0026lt;/span\u0026gt;\u0026lt;span\u0026gt;1\u0026lt;/span\u0026gt;\u0026lt;span\u0026gt;4\u0026lt;/span\u0026gt;\u0026lt;/div\u0026gt;   在上面执行过程中，进入 else 分支，执行：\n  for old children\n 执行完之后(i=0,e1=2,e2=2)， newIndexToOldIndexMap=[2,3,1] 分别对应 [1,2,3] 在 [2,3,1] 中的索引值 + 1，因为存在 newIndex \u0026lt; maxNewIndexSoFar 所以 moved=true 在随后的流程中用来触发“最长增长序列”操作。\n  for new children\n 在执行这个循环之前，我们需要用到 newIndexToOldIndexMap=[2,3,1] 并且从中找 到最长增长序列([2,3])，然而 getSequence(arr) 返回的是它们的索引值，所以是 [0,1] 所以最后 increasingNewIndexSequence=[0,1] 。\n 然后在 for toBePatched new children 里面，因为检测到 moved=true 则会进入到 移动交换操作，这里执行 move() 也有个条件： j\u0026lt;0 || i !== increasingNewIndexSequence[j] 这两个条件 有分别代表两种情况(假设： val=increasingNewIndexSequence[j])：\n  j\u0026lt;0 代表 increasingNewIndexSequence 增长序列没有内容，这说明什么？说明 newIndexToOldIndexMap 是个完全递减数组，如： [3,2,1] 这种情况每个元素都 需要进行移动，最后变成 [1,2,3] ， 1移到3位置，2不变，3移动1的位置。\n  i!==val\n 比如这里(newIndexToOldIndexMap=[2,3,1],old=[1,2,3,4],new=[2,3,1,4])\n i=2,val=1,nextchild=[1],anchor=[4] 意味着要在 [4] 前面插入 [1] 记住这 里执行的依旧是插入操作，只是在插入之前会将原来的 [1] 从 container.children 中删除，所以看似是交换实际只是变相插入而已。\n i=1,val=1,nextchild=[3],anchor=[1] 这里 i===val 所以执行 j--\n i=0,val=0,nextchild=[2],anchor=[3] 这里 i===val 所以执行 j--\n 到此 for 循环已经退出了，上面两个 j-- 说明触及的是增长序列里面的元素即不 需要移动的元素，所以最后 children 由 [1,2,3,4] 变成 [2,3,1,4], 只是 1 进 行了移动。\n     只需要移动一次就可完成。。。。。。。我是分界点~~~~~~~~~\n  同案例分析：\n  [1, 2, 3, 4] 和 [1, 4, 2, 3]\n 在经过 while1 之后开始进入 else 分支， newIndexToOldIndexMap=[4,2,3] 最后得 到增长序列： [2,3]~对应的索引 ~[1,2] 即需要执行插入的逻辑是：\n i=2,j=1,val=2,next=[3],anchor=null ： i===val, j–\n i=1,j=0,val=1,next=[2],anchor=[3] : i===val, j–\n i=0,j=-1,val=undefined,next=[4],anchor=[2] : 4 要插入到 2 前面， children=[1,4,2,3]\n i=-1 结束。\n 所以只需要执行一次移动就可以了，在递增序列内的元素是不需要动的。\n  [1,2,3] 和 [2,3,1]\n 由于前后都不一样，所以 while1,while2 都没处理，并且进入 else 乱序情况处理。\n newIndexToOldIndexMap=[2,4,1] 增长序列= [2,4] ，索引： [0,1]\n i=2,j=1,val=1,next=[1],anchor=null ： 1 append 到最后，变成 children=[2,3,1]\n i=1,j=1,val=1,next=[3],anchor=[1] : i===val, j–\n i=0,j=0,val=0,next=[2],anchor=[3] : i ===val, j–\n i=-1 结束.\n 只需要将 [1] 移到最后就完成了交换。\n  [1,2,3,4] 和 [4,2,3,1]\n newIndexToOldIndexMap=[4,2,3,1] 增长序列： [2,3] ，索引： [1,2]\n i=3,j=1,val=2,next=[1],anchor=null : [1] append 到最后， children=[2,3,4,1]\n i=2,j=1,val=2,next=[3],anchor=[1] : i===val, j–\n i=1,j=0,val=1,next=[2],anchor=[3] : i===val, j–\n i=0,j=-1,val=undefined,next=[4],anchor=[2]: j\u0026lt;0, 执行移动， children=[4,2,3,1], 将 4 移动到 2 前面。\n i=-1 结束。\n 这里只需要执行两次移动操作， 1\u0026lt;-\u0026gt;4 交换。\n    move\u0026amp;replace([1,2,3,4,5]-\u0026gt;[4,1,2,3,6])   这里需要完成的动作有： 用 6 替换 5，将 4移到 1 前面 。\n 测试：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24  const { log, f, shuffle, runtime_test, renderChildren } = require(process.env .BLOG_DIR_VUE + \u0026#34;/lib.js\u0026#34;); import(process.env.BLOG_DIR_VUE + \u0026#34;/runtime-test.global.js\u0026#34;).then( ({ h, render, nodeOps, serializeInner: inner }) =\u0026gt; { let elm; let root = nodeOps.createElement(\u0026#34;div\u0026#34;); // \u0026lt;div\u0026gt;hello\u0026lt;/div\u0026gt;  render(h(\u0026#34;div\u0026#34;, { id: 1 }, \u0026#34;hello\u0026#34;), root); const rc = (arr) =\u0026gt; renderChildren(render, root, h, arr); const logRoot = () =\u0026gt; log(\u0026#34;root: \u0026#34; + inner(root)); logRoot(); elm = rc([1,2,3,4,5]); log(\u0026#34;\u0026gt;\u0026gt;\u0026gt; render [1,2,3,4,5] DONE.\u0026#34;); logRoot(); elm = rc([4,1,2,3,6]); log(\u0026#34;\u0026gt;\u0026gt;\u0026gt; render [4,1,2,3,6] DONE.\u0026#34;); logRoot(); }, (err) =\u0026gt; { console.log(err.message); } );    undefinedfalse root: \u0026lt;div id=1\u0026gt;hello\u0026lt;/div\u0026gt; \u0026gt;\u0026gt;\u0026gt; render [1,2,3,4,5] DONE. root: \u0026lt;div id=1\u0026gt;\u0026lt;span\u0026gt;1\u0026lt;/span\u0026gt;\u0026lt;span\u0026gt;2\u0026lt;/span\u0026gt;\u0026lt;span\u0026gt;3\u0026lt;/span\u0026gt;\u0026lt;span\u0026gt;4\u0026lt;/span\u0026gt;\u0026lt;span\u0026gt;5\u0026lt;/span\u0026gt;\u0026lt;/div\u0026gt; patchKeyedChildren... while 1, sync from start... while 2, sync from end... { arr: [ 4, 1, 2, 3, 0 ] } { result: [ 1, 2, 3 ] } { toBePatched: 5 } 最长增长序列: 1,2,3 { val: 3, i: 3, j: 2, toBePatched: 5 } { val: 2, i: 2, j: 1, toBePatched: 5 } { val: 1, i: 1, j: 0, toBePatched: 5 } { val: undefined, i: 0, j: -1, toBePatched: 5 } moving... move 交换... \u0026gt;\u0026gt;\u0026gt; render [4,1,2,3,6] DONE. root: \u0026lt;div id=1\u0026gt;\u0026lt;span\u0026gt;4\u0026lt;/span\u0026gt;\u0026lt;span\u0026gt;1\u0026lt;/span\u0026gt;\u0026lt;span\u0026gt;2\u0026lt;/span\u0026gt;\u0026lt;span\u0026gt;3\u0026lt;/span\u0026gt;\u0026lt;span\u0026gt;6\u0026lt;/span\u0026gt;\u0026lt;/div\u0026gt;   分析 ：\n 经过 while1, while2 实际什么都没做，因为前后并没有共通节点，也因此会进入 else 进 行无序序列处理。\n old=[1,2,3,4,5]\n new=[4,1,2,3,6]\n newIndexToOldIndexMap=[0,0,0,0,0] 经过 for old 之后\n newIndexToOldIndexMap=[4,1,2,3,0] 最后 5 由于没找到对应 key 的 new node或者无 key 的 new node而 被执行删除(unmount())操作。\n 找最长增长序列： [1,2,3] 得到 newIndexToOldIndexMap 中对应的索引 increasingNewIndexSequence=[1,2,3],j=2\n 开始从右到左遍历 new children(val=increasingNewIndexSequence[j])：\n i=4,map=0,newchild=6: 由于 index map 中的值为 0，说明并没有对应的 old child 属 于需要新增的节点，执行 mount new 节点操作 children=[1,2,3,4,6] (注意 ： 5 在 上面已经被 unmount 掉了)\n i=3,j=2,val=3,next=3,anchor=6 : i===val, j–\n i=2,j=1,val=2,next=2,anchor=3 : i===val, j–\n i=1,j=0,val=1,next=1,anchor=2 : i===val, j–\n i=0,j=-1,val=undefined,next=4,anchor=1 : j\u0026lt;0, 执行 move() ，将 4 移动到 1 前面，变成： children=[4,1,2,3,6]\n i=-1 结束。\n 这里实际上有三个动作：\n  5 在 new children 中没找到 keyed child，也没有 non-keyed child 所以被 unmount 删除了;\n  6 在 newIndexToOldIndexMap 中对应的值为 0，说明并没有 old child 与之对应， 属于新节点，执行 mount new 操作;\n  4 节点满足 move 条件，将其移动到 1 前面。\n    同案例分析 ：\n  [1,4,5] 和 [4,6]\n for old 时 1 和 5 被 unmount 掉\n newIndexToOldIndexMap=[2,0] 因为不存在 newIndex \u0026gt; maxNewIndexSoFar 导致 moved=false 随之 increasingNewIndexSequence=[]\n for new 时，由于增长序列为空，所以只会进入 newIndexToOldIndexMap 检测是否为 0 的 if 分支执行 mount new 操作，即新增 6 这个节点：\n i=1,newIndexToOldIndexMap[i]===0 进入 if mount new 6 node.\n  [2,4,5] 和 [4,5,3] 删除 2，新增 3\n  [1,2,3,4,5,6,7,8] 和 [8,7,6,5,4,3,2,1]\n 这应该是最糟糕的情况了\n newIndexToOldIndexMap=[8,7,6,5,4,3,2,1],moved=true\n 增长序列为 [7] ，所以 increasingNewIndexSequence=[1],j=0\n i=7,j=0,val=7,next=1,anchor=undefined, i===val, j–, 即节点 [1] 不需要动\n i=6,j=-1,next=2,anchor=1 -\u0026gt;2移到1前面-\u0026gt; children=[3,4,5,6,7,8,2,1]\n i=5,j=-1,next=3,anchor=2 -\u0026gt;3移到2前面-\u0026gt; children=[4,5,6,7,8,3,2,1]\n i=4,j=-1,next=4,anchor=3 -\u0026gt;4移到3前面-\u0026gt; children=[5,6,7,8,4,3,2,1]\n i=3,j=-1,next=5,anchor=4 -\u0026gt;5移到4前面-\u0026gt; children=[6,7,8,5,4,3,2,1]\n i=2,j=-1,next=6,anchor=5 -\u0026gt;6移到5前面-\u0026gt; children=[7,8,6,5,4,3,2,1]\n i=1,j=-1,next=7,anchor=6 -\u0026gt;7移到6前面-\u0026gt; children=[8,7,6,5,4,3,2,1]\n i=0,j=-1,next=8,anchor=7 这里也会执行一次插入吗(如下面测试结果)？\n i=-1 结束，共执行了七次移动。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24  const { log, f, shuffle, runtime_test, renderChildren } = require(process.env .BLOG_DIR_VUE + \u0026#34;/lib.js\u0026#34;); import(process.env.BLOG_DIR_VUE + \u0026#34;/runtime-test.global.js\u0026#34;).then( ({ h, render, nodeOps, serializeInner: inner }) =\u0026gt; { let elm; let root = nodeOps.createElement(\u0026#34;div\u0026#34;); // \u0026lt;div\u0026gt;hello\u0026lt;/div\u0026gt; render(h(\u0026#34;div\u0026#34;, { id: 1 }, \u0026#34;hello\u0026#34;), root); const rc = (arr) =\u0026gt; renderChildren(render, root, h, arr); const logRoot = () =\u0026gt; log(\u0026#34;root: \u0026#34; + inner(root)); logRoot(); elm = rc([1,2,3,4,5,6,7,8]); log(\u0026#34;\u0026gt;\u0026gt;\u0026gt; render [1,2,3,4,5,6,7,8] DONE.\u0026#34;); logRoot(); elm = rc([1,2,3,4,5,6,7,8].reverse()); log(\u0026#34;\u0026gt;\u0026gt;\u0026gt; render [8,7,6,5,4,3,2,1] DONE.\u0026#34;); logRoot(); }, (err) =\u0026gt; { console.log(err.message); } );    undefinedfalse root: \u0026lt;div id=1\u0026gt;hello\u0026lt;/div\u0026gt; \u0026gt;\u0026gt;\u0026gt; render [1,2,3,4,5,6,7,8] DONE. root: \u0026lt;div id=1\u0026gt;\u0026lt;span\u0026gt;1\u0026lt;/span\u0026gt;\u0026lt;span\u0026gt;2\u0026lt;/span\u0026gt;\u0026lt;span\u0026gt;3\u0026lt;/span\u0026gt;\u0026lt;span\u0026gt;4\u0026lt;/span\u0026gt;\u0026lt;span\u0026gt;5\u0026lt;/span\u0026gt;\u0026lt;span\u0026gt;6\u0026lt;/span\u0026gt;\u0026lt;span\u0026gt;7\u0026lt;/span\u0026gt;\u0026lt;span\u0026gt;8\u0026lt;/span\u0026gt;\u0026lt;/div\u0026gt; patchKeyedChildren... while 1, sync from start... while 2, sync from end... { arr: [ 8, 7, 6, 5, 4, 3, 2, 1 ] } { result: [ 7 ] } { toBePatched: 8 } 最长增长序列: 7 { val: 7, i: 7, j: 0, next: \u0026#39;1\u0026#39;, anchor: null, toBePatched: 8 } { val: undefined, i: 6, j: -1, next: \u0026#39;2\u0026#39;, anchor: \u0026#39;1\u0026#39;, toBePatched: 8 } move 交换... { val: undefined, i: 5, j: -1, next: \u0026#39;3\u0026#39;, anchor: \u0026#39;2\u0026#39;, toBePatched: 8 } move 交换... { val: undefined, i: 4, j: -1, next: \u0026#39;4\u0026#39;, anchor: \u0026#39;3\u0026#39;, toBePatched: 8 } move 交换... { val: undefined, i: 3, j: -1, next: \u0026#39;5\u0026#39;, anchor: \u0026#39;4\u0026#39;, toBePatched: 8 } move 交换... { val: undefined, i: 2, j: -1, next: \u0026#39;6\u0026#39;, anchor: \u0026#39;5\u0026#39;, toBePatched: 8 } move 交换... { val: undefined, i: 1, j: -1, next: \u0026#39;7\u0026#39;, anchor: \u0026#39;6\u0026#39;, toBePatched: 8 } move 交换... { val: undefined, i: 0, j: -1, next: \u0026#39;8\u0026#39;, anchor: \u0026#39;7\u0026#39;, toBePatched: 8 } move 交换... \u0026gt;\u0026gt;\u0026gt; render [8,7,6,5,4,3,2,1] DONE. root: \u0026lt;div id=1\u0026gt;\u0026lt;span\u0026gt;8\u0026lt;/span\u0026gt;\u0026lt;span\u0026gt;7\u0026lt;/span\u0026gt;\u0026lt;span\u0026gt;6\u0026lt;/span\u0026gt;\u0026lt;span\u0026gt;5\u0026lt;/span\u0026gt;\u0026lt;span\u0026gt;4\u0026lt;/span\u0026gt;\u0026lt;span\u0026gt;3\u0026lt;/span\u0026gt;\u0026lt;span\u0026gt;2\u0026lt;/span\u0026gt;\u0026lt;span\u0026gt;1\u0026lt;/span\u0026gt;\u0026lt;/div\u0026gt;        patchUnkeyedChildren   feat(add): unkeyd children patch · gcclll/stb-vue-next@2d06710\n 对于明确 unkeyed 的 children 处理和 keyed 处理区别在于，会将前面的 children 先进 行 patch, 因为在 patchKeyedChildren 一节已经详细分析过，如果没有 old child 是 unkeyed 会从 new children 中依序找到第一个符合条件的 unkeyed child 去替换。\n 所以这里分三步走：\n  找到最小长度，针对此长度内的 child 进行 patch，因为对于 unkeyed old child 只 需要找到对应的 unkeyed new child 替换就行\n  新增的情况 new child len \u0026gt; old child len\n  减少的情况 new child len \u0026lt; old child len\n  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56  const patchUnkeyedChildren = ( c1: VNode[], c2: VNodeArrayChildren, container: RendererElement, anchor: RendererNode | null, parentComponent: ComponentInternalInstance | null, parentSuspense: SuspenseBoundary | null, isSVG: boolean, optimized: boolean ) =\u0026gt; { c1 = c1 || EMPTY_ARR; c2 = c2 || EMPTY_ARR; const oldLength = c1.length; const newLength = c2.length; const commonLength = Math.min(oldLength, newLength); let i; for (i = 0; i \u0026lt; commonLength; i++) { const nextChild = (c2[i] = optimized ? cloneIfMounted(c2[i] as VNode) : normalizeVNode(c2[i])); patch( c1[i], nextChild, container, null, parentComponent, parentSuspense, isSVG, optimized ); } if (oldLength \u0026gt; newLength) { // remove old  unmountChildren( c1, parentComponent, parentSuspense, true, false, commonLength ); } else { // mount new  mountChildren( c2, container, anchor, parentComponent, parentSuspense, isSVG, optimized, commonLength ); } };      patch-\u0026gt;processComponent(如何patch组件的？)   测试         ","permalink":"https://www.cheng92.com/vue/vue-mind-map-runtime-core-2-render/","tags":["vue,","vue3,","runtime-core,","render"],"title":"Vue3 源码头脑风暴之 7 ☞ runtime-core(2) - render"},{"categories":["javascript,","web"],"contents":" parseInt(string, radix)\n  在使用过程中发现一个问题，看下面的测试代码结果：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22  const noop = () =\u0026gt; {} var vals = [ 1, // 0  \u0026#39;1\u0026#39;, // 1  NaN, // 2  null, // 3  {}, // 4  false, // 5  true, // 6  { length: 2, 0: \u0026#39;a\u0026#39;, 1: \u0026#39;b\u0026#39; }, // 7  { a: 1 }, //8  [], // 9  [1, 2], // 10  noop, // 11  undefined, // 12  void 0 // 13 ] // 在执行之前，上面结果会是什么呢？ const result = vals.map(v =\u0026gt; parseInt(v, 10)) console.log(\u0026#39;\\n\u0026#39;, result) console.log(\u0026#39;[1,2] =\u0026gt; \u0026#39;, result[10])    [ 1, 1, NaN, NaN, NaN, NaN, NaN, NaN, NaN, NaN, 1, NaN, NaN, NaN ] [1,2] =\u0026gt; 1 undefined   发现问题没，疑惑点就 parseInt 在 [1,2] // 10 的时候，结果居然是 1 ?\n parseInt 实现伪码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101  const ToString = (s) =\u0026gt; \u0026#34;\u0026#34; + s; const TrimString = (s) =\u0026gt; (s || \u0026#34;\u0026#34;).trim(); const ToInt32 = (v) =\u0026gt; +v; const log = console.log; function parseInt(string, radix) { let inputString = ToString(string); // ~捂脸~，这一行就说明问题了  let S = TrimString(inputString); let sign = 1; // 0x002D -\u0026gt; \u0026#39;-\u0026#39;, S.codePointAt(0) === 0x002D  if (S) { const ch = S[0]; if (ch === \u0026#34;-\u0026#34;) { sign = -1; // 删除 -  S = S.slice(1); } else if (ch === \u0026#34;+\u0026#34;) { sign = 1; // 删除 +  S = S.slice(1); } } // 进制  let R = ToInt32(radix || 0); let stripPrefix = true; if (R !== 0) { // 只支持 2~36 进制  if (R \u0026lt; 2 || R \u0026gt; 36) return NaN; if (R !== 16) { stripPrefix = false; } } else { // 为 0 时默认 10 进制  R = 10; } if (stripPrefix) { if (S.length \u0026gt; 2 \u0026amp;\u0026amp; S.slice(0, 2).toLowerCase() === \u0026#34;0x\u0026#34;) { S = S.slice(2); // delete \u0026#39;0x\u0026#39; or \u0026#39;0X\u0026#39;  R = 16; } } // 如果 S 中包含非进制内的字符，将 end 重置为该字符的索引值  let len = S.length, end = len - 1; const table = \u0026#34;0123456789abcdefghijklmnopqrstuvwxyz\u0026#34;.slice(0, radix); for (let i = 0; i \u0026lt; len; i++) { const c = S[i].toLowerCase(); // 10 进制是 0 - 9  // 2 -\u0026gt; 0, 1  // 3 -\u0026gt; 0, 1, 2  // ...  // 36 -\u0026gt; 0, ..., 9, a, ..., z  if (!table.includes(c)) { // 这里假设是 10进制  end = i; // 第一个非进制内的字符  break; } } let Z = S.slice(0, end \u0026gt; 0 ? end + 1 : 0); if (!Z) return NaN; let mathInt = parseWithRadix(Z, R); // mathInt 转成对应进制的数  if (mathInt === 0) { return sign === -1 ? -0 : +0; } return sign * mathInt; } function parseWithRadix(Z, radix = 10) { let mathInt = 0; const zLen = Z.length; const base = \u0026#34;a\u0026#34;.codePointAt(0); for (let i = 0; i \u0026lt; zLen; i++) { let c = Z[i].toLowerCase(); if (c \u0026gt;= \u0026#34;a\u0026#34; \u0026amp;\u0026amp; c \u0026lt;= \u0026#34;z\u0026#34; \u0026amp;\u0026amp; radix \u0026gt; 10) { c = 10 + c.codePointAt(0) - base; } mathInt += +c * Math.pow(radix, zLen - i - 1); } return mathInt; } function test(val) { let result = []; for (let i = 0; i \u0026lt; 40; i++) { result.push(`R: ${i}, V: ${parseInt(val, i)}`); } log(\u0026#34;\\n\u0026#34;, result); } test(\u0026#34;EEE\u0026#34;); log(parseInt(\u0026#34;0xEEE\u0026#34;, 16)); log(parseInt(\u0026#34;111111\u0026#34;, 2)); test(\u0026#34;-20AFE\u0026#34;);    [ \u0026#39;R: 0, V: NaN\u0026#39;, \u0026#39;R: 1, V: NaN\u0026#39;, \u0026#39;R: 2, V: NaN\u0026#39;, \u0026#39;R: 3, V: NaN\u0026#39;, \u0026#39;R: 4, V: NaN\u0026#39;, \u0026#39;R: 5, V: NaN\u0026#39;, \u0026#39;R: 6, V: NaN\u0026#39;, \u0026#39;R: 7, V: NaN\u0026#39;, \u0026#39;R: 8, V: NaN\u0026#39;, \u0026#39;R: 9, V: NaN\u0026#39;, \u0026#39;R: 10, V: NaN\u0026#39;, \u0026#39;R: 11, V: NaN\u0026#39;, \u0026#39;R: 12, V: NaN\u0026#39;, \u0026#39;R: 13, V: NaN\u0026#39;, \u0026#39;R: 14, V: NaN\u0026#39;, \u0026#39;R: 15, V: 3374\u0026#39;, \u0026#39;R: 16, V: 3822\u0026#39;, \u0026#39;R: 17, V: 4298\u0026#39;, \u0026#39;R: 18, V: 4802\u0026#39;, \u0026#39;R: 19, V: 5334\u0026#39;, \u0026#39;R: 20, V: 5894\u0026#39;, \u0026#39;R: 21, V: 6482\u0026#39;, \u0026#39;R: 22, V: 7098\u0026#39;, \u0026#39;R: 23, V: 7742\u0026#39;, \u0026#39;R: 24, V: 8414\u0026#39;, \u0026#39;R: 25, V: 9114\u0026#39;, \u0026#39;R: 26, V: 9842\u0026#39;, \u0026#39;R: 27, V: 10598\u0026#39;, \u0026#39;R: 28, V: 11382\u0026#39;, \u0026#39;R: 29, V: 12194\u0026#39;, \u0026#39;R: 30, V: 13034\u0026#39;, \u0026#39;R: 31, V: 13902\u0026#39;, \u0026#39;R: 32, V: 14798\u0026#39;, \u0026#39;R: 33, V: 15722\u0026#39;, \u0026#39;R: 34, V: 16674\u0026#39;, \u0026#39;R: 35, V: 17654\u0026#39;, \u0026#39;R: 36, V: 18662\u0026#39;, \u0026#39;R: 37, V: NaN\u0026#39;, \u0026#39;R: 38, V: NaN\u0026#39;, \u0026#39;R: 39, V: NaN\u0026#39; ] 3822 63 [ \u0026#39;R: 0, V: NaN\u0026#39;, \u0026#39;R: 1, V: NaN\u0026#39;, \u0026#39;R: 2, V: NaN\u0026#39;, \u0026#39;R: 3, V: NaN\u0026#39;, \u0026#39;R: 4, V: NaN\u0026#39;, \u0026#39;R: 5, V: NaN\u0026#39;, \u0026#39;R: 6, V: NaN\u0026#39;, \u0026#39;R: 7, V: NaN\u0026#39;, \u0026#39;R: 8, V: NaN\u0026#39;, \u0026#39;R: 9, V: NaN\u0026#39;, \u0026#39;R: 10, V: NaN\u0026#39;, \u0026#39;R: 11, V: -2787\u0026#39;, \u0026#39;R: 12, V: -3591\u0026#39;, \u0026#39;R: 13, V: -4539\u0026#39;, \u0026#39;R: 14, V: -5643\u0026#39;, \u0026#39;R: 15, V: -6915\u0026#39;, \u0026#39;R: 16, V: -133886\u0026#39;, \u0026#39;R: 17, V: -170201\u0026#39;, \u0026#39;R: 18, V: -213476\u0026#39;, \u0026#39;R: 19, V: -264551\u0026#39;, \u0026#39;R: 20, V: -324314\u0026#39;, \u0026#39;R: 21, V: -393701\u0026#39;, \u0026#39;R: 22, V: -473696\u0026#39;, \u0026#39;R: 23, V: -565331\u0026#39;, \u0026#39;R: 24, V: -669686\u0026#39;, \u0026#39;R: 25, V: -787889\u0026#39;, \u0026#39;R: 26, V: -921116\u0026#39;, \u0026#39;R: 27, V: -1070591\u0026#39;, \u0026#39;R: 28, V: -1237586\u0026#39;, \u0026#39;R: 29, V: -1423421\u0026#39;, \u0026#39;R: 30, V: -1629464\u0026#39;, \u0026#39;R: 31, V: -1857131\u0026#39;, \u0026#39;R: 32, V: -2107886\u0026#39;, \u0026#39;R: 33, V: -2383241\u0026#39;, \u0026#39;R: 34, V: -2684756\u0026#39;, \u0026#39;R: 35, V: -3014039\u0026#39;, \u0026#39;R: 36, V: -3372746\u0026#39;, \u0026#39;R: 37, V: NaN\u0026#39;, \u0026#39;R: 38, V: NaN\u0026#39;, \u0026#39;R: 39, V: NaN\u0026#39; ] undefined   关键点：\n  输入值一进来就会进行字符串化，这也就解释了为什么数组 [1,2] 最后得到的结果是 1 了\n  进制数的处理，为 0 时 radix = 10, 非 [2, 36] 区间的数视为非法进制\n  输入的内容(string) 如何转成对应进制的数，即 parse(Z, radix) 函数\n    字符串转数字函数：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19  function parse(Z, radix = 10) { let mathInt = 0; const zLen = Z.length; const base = \u0026#39;a\u0026#39;.codePointAt(0) for (let i = 0; i \u0026lt; zLen; i++) { let c = Z[i].toLowerCase() if (c \u0026gt;= \u0026#39;a\u0026#39; \u0026amp;\u0026amp; c \u0026lt;= \u0026#39;z\u0026#39; \u0026amp;\u0026amp; radix === 16) { c = 10 + c.codePointAt(0) - base } mathInt += +c * Math.pow(radix, zLen - i - 1); } return mathInt } const log = console.log log(parse(\u0026#39;EEE\u0026#39;, 16))    3822 undefined   ❓❓❓ parseInt(0.0000005) = 5 ❓❓❓\n  测试：\n1 2 3 4 5 6 7 8 9 10 11 12 13  function test(res) { console.log(`parseInt(${res}) = ` + parseInt(res)) } test(0.5) test(0.05) test(0.005) test(0.0005) test(0.00005) test(0.000005) test(0.0000005) test(0.00000005) test(0.000000005)    parseInt(0.5) = 0 parseInt(0.05) = 0 parseInt(0.005) = 0 parseInt(0.0005) = 0 parseInt(0.00005) = 0 parseInt(0.000005) = 0 parseInt(5e-7) = 5 parseInt(5e-8) = 5 parseInt(5e-9) = 5 undefined   😭😭😭😭😭😭😭😭😭😭\n 结果不用分析了吧，上面的结果很明显了，超过6位的小数在 toString 的时候被转成了指 数表示形式了，而 parseInt 实现伪码一开始就会将传进去的数字转成字符串，所以最后在 识别字符串的时候遇到了 e 就终止了，最终得到 5 的结果。\n 本着追根究底的原则，还是去看下 toString 里面是怎么处理的吧 🚆\n ECMAScript® 2022 Language Specification - toString\n  这里就要看下数字是如何转成字符串的： Number::toString ( x )\n","permalink":"https://www.cheng92.com/web/apis/js-api-number-parseint/","tags":["javascript,","api,","Number"],"title":"JavaScript Api - Number.parseInt(s, r)"},{"categories":["vue"],"contents":"  诗号：六道同坠，魔劫万千，引渡如来。  \n   stb-vue-next 完全拷贝于 vue-next ，主要目的用于学习。 \n 声明 ：vue-next runtime-core 运行时核心代码，这部分内容较多，可能会分为几篇来 叙述, f 过滤掉对象空值属性。\n 更新日志\u0026amp;Todos ：\n  [2021-01-08 10:12:50] 创建\n  DONE [2021-01-15 10:24:00] scheduler\n  TODO apiWatch -\u0026gt; post cb \u0026amp; ssr\n  TODO STATEFUL_COMONENT\n  TODO patchFlag 测试和用途\n  TODO transformVNodeArgs\n  TODO Suspense 组件\n  TODO shouldTrack, currentBlock 和 block 相关函数的作用\n  TODO setup() 返回值用来做了啥？\n  TODO setup() 里面是如何收集生命周期函数，又是如何？在什么时候？执行他们的？\n  TODO async component\n    模块初始化： feat(init): runtime-core · gcclll/stb-vue-next@b22b4db · GitHub\n ⚠ Tips    class 支持数组([\u0026#39;foo\u0026#39;, \u0026#39;bar\u0026#39;])，对象({foo:true,bar:false})，字符串(\u0026#39;foo bar\u0026#39;)\n  style 支持数组([\u0026#39;color:red\u0026#39;, {foo:\u0026#39;foo\u0026#39;}])，对象({color:\u0026#39;red\u0026#39;,foo:\u0026#39;foo\u0026#39;})，字符串(color:red)\n  class component 条件：\n  function\n  含 __vccOpts = { template: \u0026#39;\u0026lt;div /\u0026gt;\u0026#39;}\n    vnode ref 属性合并处理逻辑？\n  vnode key 属性简单的值覆盖操作？\n  h() 和 createVNode 函数多种使用方式组合？\n h(type, propsOrChildren, ...children), 参数个数多变，对于这个函数的使用方法 记忆只要记住一点：\n props 总是对象，children 可以是对象(必须是 VNode 类型 __v_isVNode)也可以是 数组，所以：\n  argc = 2, 如果是数组就一定是 children\n  argc = 2, 如果是对象且有 __v_isVNode 标识，一定是 children 否则是 props\n  argc = 3, 按照 h(type, props, children) 处理\n  argc \u0026gt; 3, 按照 h(type, props, ...children) 处理，从第三个开始都是 children\n    createVNode(type, props, children), 固定三个参数，第二个一定是 props, 第三 个一定是数组类型的 children，因为它后面还有更多的其他参数(patchFlag, dynamicProps, isBlockNode)，所以前三个必须确定下来。\n  scheduler, vue-next 中的任务调度器如何实现？\n  api watch(source, cb, option) 中的 source 只能是 reactive/ref/function/array 类型， 如果是数组时其元素只能是 reactive/ref/function\n  api watch(…, { deep: true }) 是如何做到深度监听的？\n  api watch(shallowRef, cb (newVal) =\u0026gt; {}) 是如何直接使用 newVal.a 的？\n1 2 3 4  var obj = shallowRef({ a: 0 }); watch(shallowRef, (newVal) =\u0026gt; { dummy = newVal.a; // 这里为什么可以直接访问 obj.a，obj 又是什么？ });      provide \u0026amp; inject 如何实现？\n provide(key,value) 向组件 provides[key] = value 设置\n inject(key) 从组件 provides[key] 取值\n  TODO setup() 返回值用来做了啥？\n  组件声明周期函数(onBeforeXxx, onXxx)触发顺序是什么？\n    🐂 init   导出已完成模块(reactiviy)里的 Apis: feat(init): runtime-core\u0026gt; add exports from @vue/reactivity · gcclll/stb-vue-next@38e91a8 · GitHub\n 这部分代码有点多，所以这里事先将所有类型定义添加好：\n feat(add): runtime-core\u0026gt;all types · gcclll/stb-vue-next@e3f7b94 · GitHub\n 有关类型定义请移步最后一节(纯贴代码的，所以放到最后)\n  😜 h function   feat(add): runtime-core\u0026gt;h function · gcclll/stb-vue-next@e48d5e2 · GitHub\n h, render 函数初始化。\n1 2 3 4 5  // Actual implementation export function h(type: any, propsOrChildren?: any, children?: any): VNode { // TODO  return {} as VNode; }     实现：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25  // Actual implementation export function h(type: any, propsOrChildren?: any, children?: any): VNode { const l = arguments.length; if (l === 2) { if (isObject(propsOrChildren) \u0026amp;\u0026amp; !isArray(propsOrChildren)) { // 没有 props 的 单节点(single vnode)  if (isVNode(propsOrChildren)) { return createVNode(type, null, [propsOrChildren]); } // 有 props 没有 children  return createVNode(type, propsOrChildren); } else { // omit props  return createVNode(type, null, propsOrChildren); } } else { // 从第三个参数开始全当做孩子节点处理  if (l \u0026gt; 3) { children = Array.prototype.slice.call(arguments, 2); } else if (l === 3 \u0026amp;\u0026amp; isVNode(children)) { children = [children]; } return createVNode(type, propsOrChildren, children); } }     h, 接受不定参数\n 逻辑脑图:\n  从脑图分支得出支持的情况代码示例：\n  h(\u0026#39;div\u0026#39;) 无参数无孩子\n  h(\u0026#39;div\u0026#39;, { id: \u0026#39;foo\u0026#39; }) 有 props 无 children\n  h(\u0026#39;div\u0026#39;, [\u0026#39;foo\u0026#39;]) 数组当做 chilren\n  h(\u0026#39;div\u0026#39;, vnode) 有 __v_isVNode 标识当做 children，并转成数组 [vnode]\n  h(\u0026#39;div\u0026#39;, {}, [\u0026#39;foo\u0026#39;]) 有 props 有 children\n  h(\u0026#39;div\u0026#39;, {}, vnode) 有 props, 有 children 且 = [vnode]\n  接下来需要具体去实现 createVNode 函数。\n  🌿 createVNode function   feat(add): rc-\u0026gt;createVNode · gcclll/stb-vue-next@194f72f · GitHub\n 这个函数最终是构造了 vnode: VNode 虚拟节点结构，返回。\n 这里面分为以下几个步骤实现：\n  type 是 vnode 时候处理\n  class 组件处理\n  props 处理\n  shapeFlag 检测，是什么类型 的 vnode\n  组件对象不应该 reactive(有状态的组件, STATEFUL_COMONENT)\n  构建 vnode: VNode 对象\n  检测 vnode.key 是不是 NaN\n  normalize children\n  normalize suspense children\n  currentBlock 处理\n  返回 vnode 节点\n  1 2 3 4 5 6 7 8 9 10 11  // 源文件：/js/vue/lib.js const { rc: { h, createVNode, reactive }, f, log, } = require(process.env.BLOG_JS + \u0026#34;/vue/lib.js\u0026#34;); const _h = (...args) =\u0026gt; f(h(...args)); log([\u0026#34;\u0026gt;\u0026gt;\u0026gt; type only\\n\u0026#34;, _h(\u0026#34;div\u0026#34;)]); log([\u0026#34;\u0026gt;\u0026gt;\u0026gt; type + props\\n\u0026#34;, _h(\u0026#34;div\u0026#34;, { id: \u0026#34;foo\u0026#34; })]); log([\u0026#34;\u0026gt;\u0026gt;\u0026gt; type + omit props\\n\u0026#34;, _h(\u0026#34;div\u0026#34;, [\u0026#34;foo\u0026#34;])]);    \u0026gt;\u0026gt;\u0026gt; type only { __v_isVNode: true, __v_skip: true, type: \u0026#39;div\u0026#39;, shapeFlag: 1 } \u0026gt;\u0026gt;\u0026gt; type + props { __v_isVNode: true, __v_skip: true, type: \u0026#39;div\u0026#39;, props: { id: \u0026#39;foo\u0026#39; }, shapeFlag: 1 } \u0026gt;\u0026gt;\u0026gt; type + omit props { __v_isVNode: true, __v_skip: true, type: \u0026#39;div\u0026#39;, shapeFlag: 1 } \u0026gt;\u0026gt;\u0026gt; default slot { __v_isVNode: true, __v_skip: true, type: { template: \u0026#39;\u0026lt;br /\u0026gt;\u0026#39; }, shapeFlag: 4 } undefined  d3c6563 props   feat(add): rc-\u0026gt;createVNode, props · gcclll/stb-vue-next@d3c6563 · GitHub\n 处理 class 和 style 属性。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30  // 3. props 处理, class \u0026amp; style normalization  if (props) { // for reactive or proxy objects, we need to clone it to enable mutation.  if (isProxy(props) || InternalObjectKey in props) { props = extend({}, props); } let { class: klass, style } = props; if (klass \u0026amp;\u0026amp; !isString(klass)) { // 1. string -\u0026gt; klass  // \u0026#39;foo\u0026#39; -\u0026gt; \u0026#39;foo\u0026#39;  // 2. array -\u0026gt; \u0026#39;\u0026#39; + arr.join(\u0026#39; \u0026#39;)  // [\u0026#39;foo\u0026#39;, \u0026#39;bar\u0026#39;] -\u0026gt; \u0026#39;foo bar\u0026#39;  // 3. object -\u0026gt; \u0026#39;\u0026#39; + value ? \u0026#39; value\u0026#39; : \u0026#39;\u0026#39;  // { foo: true, bar: false, baz: true } -\u0026gt; \u0026#39;foo baz\u0026#39;  props.class = normalizeClass(klass); } if (isObject(style)) { // reactive state objects need to be cloned since they are likely to be  // mutated  if (isProxy(style) \u0026amp;\u0026amp; !isArray(style)) { style = extend({}, style); } // 1. array -\u0026gt; object  // [{ color: \u0026#39;red\u0026#39; }, \u0026#39;font-size:10px;height:100px;\u0026#39;] -\u0026gt;  // { color: \u0026#39;red\u0026#39;, \u0026#39;font-size\u0026#39;: \u0026#39;10px\u0026#39;, height: \u0026#39;100px\u0026#39; }  // 2. object -\u0026gt; object 原样返回  props.style = normalizeStyle(style); } }      class 数组，对象，字符串？\n 数组： 合并成字符串， [\u0026#39;foo\u0026#39;, \u0026#39;bar\u0026#39;] -\u0026gt; \u0026#39;foo bar\u0026#39;\n 对象： 合并成字符串， {foo: true, bar: false, baz: true} -\u0026gt; \u0026#39;foo baz\u0026#39;\n 字符串： 原样输出\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17  export function normalizeClass(value: unknown): string { let res = \u0026#34;\u0026#34;; if (isString(value)) { res = value; } else if (isArray(value)) { for (let i = 0; i \u0026lt; value.length; i++) { res += normalizeClass(value[i]) + \u0026#34; \u0026#34;; } } else if (isObject(value)) { for (const name in value) { if (value[name]) { res += name + \u0026#34; \u0026#34;; } } } return res.trim(); }      style 数组，对象，字符串？\n 数组： 合并成对象， [\u0026#39;color:red\u0026#39;, { \u0026#39;font-size\u0026#39;: \u0026#39;10px\u0026#39;, height: \u0026#39;100px\u0026#39; }] -\u0026gt; {color: \u0026#39;red\u0026#39;, \u0026#39;font-size\u0026#39;: \u0026#39;10px\u0026#39;, height: \u0026#39;100px\u0026#39;}\n 对象： 原样返回\n 字符串：解析成对象， 如数组内字符串部分\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19  export function normalizeStyle(value: unknown): NormalizedStyle | undefined { if (isArray(value)) { const res: Record\u0026lt;string, string | number\u0026gt; = {}; for (let i = 0; i \u0026lt; value.length; i++) { const item = value[i]; const normalized = normalizeStyle( isString(item) ? parseStringStyle(item) : item ); if (normalized) { for (const key in normalized) { res[key] = normalized[key]; } } } return res; } else if (isObject(value)) { return value; } }       测试：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19  // 源文件：/js/vue/lib.js const { rc: { h, createVNode: c }, f, log } = require(process.env.BLOG_JS + \u0026#39;/vue/lib.js\u0026#39;) let _h = (...args) =\u0026gt; f(c(...args), \u0026#39;props\u0026#39;) // class 合并成字符串 log([\u0026#39;\u0026gt;\u0026gt;\u0026gt; class: string\\n\u0026#39;, _h(\u0026#39;p\u0026#39;, { class: \u0026#39;foo baz\u0026#39; })]) log([\u0026#39;\u0026gt;\u0026gt;\u0026gt; class: array\\n\u0026#39;, _h(\u0026#39;p\u0026#39;, { class: [\u0026#39;foo\u0026#39;, \u0026#39;baz\u0026#39;] })]) log([\u0026#39;\u0026gt;\u0026gt;\u0026gt; class: array\u0026lt;object|string\u0026gt;\\n\u0026#39;, _h(\u0026#39;p\u0026#39;, { class: [{ foo: \u0026#39;foo\u0026#39; }, \u0026#39;baz\u0026#39;, { baz: \u0026#39;baz\u0026#39; }] })]) log([\u0026#39;\u0026gt;\u0026gt;\u0026gt; class: object\\n\u0026#39;, _h(\u0026#39;p\u0026#39;, { class: {\u0026#39;foo\u0026#39;: true, \u0026#39;baz\u0026#39;: false, \u0026#39;bar\u0026#39;: true} })]) // style 合并成对象 log([\u0026#39;\u0026gt;\u0026gt;\u0026gt; style: array\\n\u0026#39;, _h(\u0026#39;p\u0026#39;, { style: [{ foo: \u0026#39;foo\u0026#39; }, { baz: \u0026#39;baz\u0026#39; }] })]) log([\u0026#39;\u0026gt;\u0026gt;\u0026gt; style: object\\n\u0026#39;, _h(\u0026#39;p\u0026#39;, { style: { foo: \u0026#39;foo\u0026#39;, baz: \u0026#39;baz\u0026#39; } })]) log([\u0026#39;\u0026gt;\u0026gt;\u0026gt; style: array\u0026lt;object|string\u0026gt;\\n\u0026#39;, _h(\u0026#39;p\u0026#39;, { style: [{ foo: \u0026#39;foo\u0026#39; }, \u0026#39;color:red\u0026#39;, { baz: \u0026#39;baz\u0026#39; }] })])    \u0026gt;\u0026gt;\u0026gt; class: string { props: { class: \u0026#39;foo baz\u0026#39; } } \u0026gt;\u0026gt;\u0026gt; class: array { props: { class: \u0026#39;foo baz\u0026#39; } } \u0026gt;\u0026gt;\u0026gt; class: array\u0026lt;object|string\u0026gt; { props: { class: \u0026#39;foo baz baz\u0026#39; } } \u0026gt;\u0026gt;\u0026gt; class: object { props: { class: \u0026#39;foo bar\u0026#39; } } \u0026gt;\u0026gt;\u0026gt; style: array { props: { style: { foo: \u0026#39;foo\u0026#39;, baz: \u0026#39;baz\u0026#39; } } } \u0026gt;\u0026gt;\u0026gt; style: object { props: { style: { foo: \u0026#39;foo\u0026#39;, baz: \u0026#39;baz\u0026#39; } } } \u0026gt;\u0026gt;\u0026gt; style: array\u0026lt;object|string\u0026gt; { props: { style: { foo: \u0026#39;foo\u0026#39;, color: \u0026#39;red\u0026#39;, baz: \u0026#39;baz\u0026#39; } } } undefined    class component   是类组件前提是：\n  必须是函数\n  必须包含 __vccOpts 属性\n  1 2 3 4 5 6 7 8  // 2. class component  if (isClassComponent(type)) { type = type.__vccOpts; } export function isClassComponent(value: unknown): value is ClassComponent { return isFunction(value) \u0026amp;\u0026amp; \u0026#34;__vccOpts\u0026#34; in value; }     测试：\n1 2 3 4 5 6 7 8 9 10 11  // 源文件：/js/vue/lib.js const { rc: { h, createVNode: c }, f, log } = require(process.env.BLOG_JS + \u0026#39;/vue/lib.js\u0026#39;) const _h = (...args) =\u0026gt; f(c(...args)) class Component { $props static __vccOpts = { template: \u0026#39;\u0026lt;div /\u0026gt;\u0026#39; } } log(_h(Component))    { __v_isVNode: true, __v_skip: true, type: { template: \u0026#39;\u0026lt;div /\u0026gt;\u0026#39; }, shapeFlag: 4 // STATEFUL_COMPONENT } undefined    TODO stateful component \u0026amp; key NaN   有状态的组件？\n 即 type 为对象时候视为有状态的组件。\n 如果是 STATEFUL_COMPONENT 且是个 proxy 的时候，开发模式下给出警告⚠️。\n1 2 3 4 5 6  // 源文件：/js/vue/lib.js const { rc: { h, createVNode: c, reactive:r }, f, log } = require(process.env.BLOG_JS + \u0026#39;/vue/lib.js\u0026#39;) const _h = (...args) =\u0026gt; f(c(...args)) log(_h(\u0026#39;div\u0026#39;, { key: NaN }))    { __v_isVNode: true, __v_skip: true, type: \u0026#39;div\u0026#39;, props: { key: NaN }, shapeFlag: 1 } undefined    88eaf09 type is vnode   feat(add): rc-\u0026gt;createVNode, type is vnode · gcclll/stb-vue-next@88eaf09 · GitHub\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56  // \u0026gt; in createVNode  // 1. type is vnode  if (isVNode(type)) { // createVNode receiving an existing vnode. This happens in cases like  // \u0026lt;component :is=\u0026#34;vnode\u0026#34;/\u0026gt;  // #2078 make sure to merge refs during the clone instead of overwriting it  const cloned = cloneVNode(type, props, true /* mergeRef: true */); if (children) { normalizeChildren(cloned, children); } return cloned; } // cloneVNode  // 省略直接取 vnode 值部分  export function cloneVNode\u0026lt;T, U\u0026gt;( vnode: VNode\u0026lt;T, U\u0026gt;, extraProps?: (Data \u0026amp; VNodeProps) | null, mergeRef = false ): VNode\u0026lt;T, U\u0026gt; { // This is intentionally NOT using spread or extend to avoid the runtime  // key enumeration cost.  const { props, ref, patchFlag } = vnode; const mergedProps = extraProps ? mergeProps(props || {}, extraProps) : props; return { __v_isVNode: true, [ReactiveFlags.SKIP]: true, type: vnode.type, props: mergedProps, key: mergedProps \u0026amp;\u0026amp; normalizeKey(mergedProps), ref: extraProps \u0026amp;\u0026amp; extraProps.ref ? // #2078 in the case of \u0026lt;component :is=\u0026#34;vnode\u0026#34; ref=\u0026#34;extra\u0026#34;/\u0026gt;  // if the vnode itself already has a ref, cloneVNode will need to merge  // the refs so the single vnode can be set on multiple refs  mergeRef \u0026amp;\u0026amp; ref ? isArray(ref) ? ref.concat(normalizeRef(extraProps)!) : [ref, normalizeRef(extraProps)!] : normalizeRef(extraProps) : ref, // if the vnode is cloned with extra props, we can no longer assume its  // existing patch flag to be reliable and need to add the FULL_PROPS flag.  // note: perserve flag for fragments since they use the flag for children  // fast paths only.  patchFlag: extraProps \u0026amp;\u0026amp; vnode.type !== Fragment ? patchFlag === -1 // hoisted node  ? PatchFlags.FULL_PROPS : patchFlag | PatchFlags.FULL_PROPS : patchFlag, ssContent: vnode.ssContent \u0026amp;\u0026amp; cloneVNode(vnode.ssContent), ssFallback: vnode.ssFallback \u0026amp;\u0026amp; cloneVNode(vnode.ssFallback), }; }     cloneVNode 绝大部分属性都是直接引用自 vnode，上面列出的都是需要处理的属性，比如：\n  props 会将 vnode 和 cloneVNode 传入的 props 进行合并，并且是传入的 props 覆盖 vnode.props。\n  key 属性，取合并之后的 key(测试-\u0026gt;)\n1 2 3 4 5  // normalize 合并后的 key  const key = mergedProps \u0026amp;\u0026amp; normalizeKey(mergedProps); const normalizeKey = ({ key }: VNodeProps): VNode[\u0026#34;key\u0026#34;] =\u0026gt; key != null ? key : null;      ref 属性，合并规则(测试-\u0026gt;)：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25  // 1. mergeRef: boolean 可以手动指定是否需要合并  // 2. extraProps.ref 调用 cloneVNode 时候传入的 props ref  // 3. ref 如果是数组，加上新的 ref 扩展原数组  // 4. ref 不是数组，用 ref 和 extra ref 合并成新数组  // 5. 如果 ref null, 则直接用 extra ref normalize 出新的 ref  const ref = extraProps \u0026amp;\u0026amp; extraProps.ref ? // #2078 in the case of \u0026lt;component :is=\u0026#34;vnode\u0026#34; ref=\u0026#34;extra\u0026#34;/\u0026gt;  // if the vnode itself already has a ref, cloneVNode will need to merge  // the refs so the single vnode can be set on multiple refs  mergeRef \u0026amp;\u0026amp; ref ? isArray(ref) ? ref.concat(normalizeRef(extraProps)!) : [ref, normalizeRef(extraProps)!] : normalizeRef(extraProps) : ref; // normalization  const normalizeRef = ({ ref }: VNodeProps): VNodeNormalizedRefAtom | null =\u0026gt; { return (ref != null ? isString(ref) || isRef(ref) || isFunction(ref) ? { i: currentRenderingInstance, r: ref } : ref : null) as any; };      patchFlag 属性(测试-\u0026gt;)\n1 2 3 4 5 6  const patchFlag = extraProps \u0026amp;\u0026amp; vnode.type !== Fragment ? patchFlag === -1 // hoisted node  ? PatchFlags.FULL_PROPS : patchFlag | PatchFlags.FULL_PROPS : patchFlag;      ssContent 递归调用 cloneVNode(vnode.ssContent)\n  ssFallback 递归调用 cloneVNode(vnode.ssFallback)\n   测试：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  // 源文件：/js/vue/lib.js const { rc: { h, createVNode: c, cloneVNode: cv }, f, log, } = require(process.env.BLOG_JS + \u0026#34;/vue/lib.js\u0026#34;); const _h = (...args) =\u0026gt; f(c(...args)); const node1 = _h(\u0026#34;div\u0026#34;, { foo: 1 }, null /* children */); log([\u0026#34;\u0026gt;\u0026gt;\u0026gt; vnode 1\\n\u0026#34;, node1]); const node2 = _h({}, null, [node1]); const cloned2 = cv(node2); // cloneVNode 只是一次浅拷贝 log([\u0026#34;\u0026gt;\u0026gt;\u0026gt; node2 == cloned2\\n\u0026#34;, f(cloned2), \u0026#34;\\n \u0026gt; node2 \\n\u0026#34;, node2]);    \u0026gt;\u0026gt;\u0026gt; vnode 1 { __v_isVNode: true, __v_skip: true, type: \u0026#39;div\u0026#39;, props: { foo: 1 }, shapeFlag: 1 } \u0026gt;\u0026gt;\u0026gt; node2 == cloned2 { __v_isVNode: true, __v_skip: true, type: {}, children: [ { __v_isVNode: true, __v_skip: true, type: \u0026#39;div\u0026#39;, props: [Object], shapeFlag: 1 } ], shapeFlag: 20 } \u0026gt; node2 { __v_isVNode: true, __v_skip: true, type: {}, children: [ { __v_isVNode: true, __v_skip: true, type: \u0026#39;div\u0026#39;, props: [Object], shapeFlag: 1 } ], shapeFlag: 20 } undefined   feat(add): rc-\u0026gt;createVNode, currentRenderingInstance · gcclll/stb-vue-next@4fbd98f · GitHub\nkey test   vnode.key 的 clone 操作，属于单纯的值覆盖操作。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19  // 源文件：/js/vue/lib.js const { rc: { h, createVNode: c, cloneVNode: cv }, f, log, } = require(process.env.BLOG_JS + \u0026#34;/vue/lib.js\u0026#34;); const _h = (...args) =\u0026gt; f(c(...args)); log([\u0026#34;\u0026gt;\u0026gt;\u0026gt; 保留 vnode.key 值\\n\u0026#34;, f(cv(c(\u0026#34;div\u0026#34;, { key: 1 })), \u0026#34;key\u0026#34;)]); log([ \u0026#34;\u0026gt;\u0026gt;\u0026gt; 替换 vnode.key 值\\n\u0026#34;, f(cv(c(\u0026#34;div\u0026#34;, { key: 1 }), { key: 2 }), \u0026#34;key\u0026#34;), ]); log([\u0026#34;\u0026gt;\u0026gt;\u0026gt; 新 props.key 值\\n\u0026#34;, f(cv(c(\u0026#34;div\u0026#34;), { key: 2 }), \u0026#34;key\u0026#34;)]); log(\u0026#34;\u0026gt;\u0026gt;\u0026gt; 测试 vnode.key 各种情况值\u0026#34;); for (const key of [\u0026#34;\u0026#34;, \u0026#34;a\u0026#34;, 0, 1, NaN]) { log(f(c(\u0026#34;div\u0026#34;, { key }), \u0026#34;key\u0026#34;)); }    \u0026gt;\u0026gt;\u0026gt; 保留 vnode.key 值 { key: 1 } \u0026gt;\u0026gt;\u0026gt; 替换 vnode.key 值 { key: 2 } \u0026gt;\u0026gt;\u0026gt; 新 props.key 值 { key: 2 } \u0026gt;\u0026gt;\u0026gt; 测试 vnode.key 各种情况值 {} { key: \u0026#39;a\u0026#39; } {} { key: 1 } [Vue warn]: VNode created with invalid key (NaN). VNode type:div {} undefined    ref test   流程脑图：  测试\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46  // 源文件：/js/vue/lib.js const { rc: { h, createVNode: c, cloneVNode: cv, ssrUtils: { setCurrentRenderingInstance: s }, }, f, log, } = require(process.env.BLOG_JS + \u0026#34;/vue/lib.js\u0026#34;); const _h = (...args) =\u0026gt; f(c(...args)); const mockIns1 = { ins: 1 }, mockIns2 = { ins: 2 }; s(mockIns1); let original = c(\u0026#34;div\u0026#34;, { ref: \u0026#34;foo\u0026#34; }); // 本身没有的时候会将 extraProps.ref 作为新的 vnode.ref 值 log([\u0026#34;\u0026gt;\u0026gt;\u0026gt; 1. vnode 本身无 ref\\n\u0026#34;, f(original, \u0026#34;ref\u0026#34;)]); let cloned1 = cv(original); log([\u0026#34;\u0026gt;\u0026gt;\u0026gt; 2. 保留原有的 vnode.ref\\n\u0026#34;, f(cloned1, \u0026#34;ref\u0026#34;)]); // 这里没指定 mergeProp 所以会替换原来的 let cloned2 = cv(original, { ref: \u0026#34;bar\u0026#34; }); log([\u0026#39;\u0026gt;\u0026gt;\u0026gt; 3. ref: \u0026#34;bar\u0026#34; 替换原有的 vnode.ref\\n\u0026#39;, f(cloned2, \u0026#34;ref\u0026#34;)]); let original2 = c(\u0026#34;div\u0026#34;); let cloned3 = cv(original2, { ref: \u0026#34;bar\u0026#34; }); log([\u0026#34;\u0026gt;\u0026gt;\u0026gt; 4. 没有 vnode.ref 情况，新增 ref\\n\u0026#34;, f(cloned3, \u0026#34;ref\u0026#34;)]); s(mockIns2); // 应该保留原有的 context instance let cloned4 = cv(original); log([\u0026#34;\u0026gt;\u0026gt;\u0026gt; 5. 应该保留原有的 context instance\\n\u0026#34;, f(cloned4, \u0026#34;ref\u0026#34;)]); // ref 覆盖，使用新的 context instance: mockIns2 let cloned5 = cv(original, { ref: \u0026#34;bar\u0026#34; }); log([\u0026#34;\u0026gt;\u0026gt;\u0026gt; 6. ref 改变，使用新的 context instance\\n\u0026#34;, f(cloned5, \u0026#34;ref\u0026#34;)]); s(null); // 置空 context instance  log(\u0026#39;\\n\\n// mergeRef 情况测试\\n\u0026#39;) s(mockIns1) original = c(\u0026#39;div\u0026#39;, { ref: \u0026#39;foo\u0026#39; }) s(mockIns2) cloned1 = cv(original, { ref: \u0026#39;bar\u0026#39; }, true) log([\u0026#39;\u0026gt;\u0026gt;\u0026gt; mergeRef: true 合并 vnode.ref\\n\u0026#39;, f(cloned1, \u0026#39;ref\u0026#39;)]) log(cloned1.ref[0]) log(cloned1.ref[1])    \u0026gt;\u0026gt;\u0026gt; 1. vnode 本身无 ref { ref: { i: { ins: 1 }, r: \u0026#39;foo\u0026#39; } } \u0026gt;\u0026gt;\u0026gt; 2. 保留原有的 vnode.ref { ref: { i: { ins: 1 }, r: \u0026#39;foo\u0026#39; } } \u0026gt;\u0026gt;\u0026gt; 3. ref: \u0026#34;bar\u0026#34; 替换原有的 vnode.ref { ref: { i: { ins: 1 }, r: \u0026#39;bar\u0026#39; } } \u0026gt;\u0026gt;\u0026gt; 4. 没有 vnode.ref 情况，新增 ref { ref: { i: { ins: 1 }, r: \u0026#39;bar\u0026#39; } } \u0026gt;\u0026gt;\u0026gt; 5. 应该保留原有的 context instance { ref: { i: { ins: 1 }, r: \u0026#39;foo\u0026#39; } } \u0026gt;\u0026gt;\u0026gt; 6. ref 改变，使用新的 context instance { ref: { i: { ins: 2 }, r: \u0026#39;bar\u0026#39; } } // mergeRef 情况测试 \u0026gt;\u0026gt;\u0026gt; mergeRef: true 合并 vnode.ref { ref: [ { i: [Object], r: \u0026#39;foo\u0026#39; }, { i: [Object], r: \u0026#39;bar\u0026#39; } ] } { i: { ins: 1 }, r: \u0026#39;foo\u0026#39; } { i: { ins: 2 }, r: \u0026#39;bar\u0026#39; } undefined    TODO patchFlag test   TODO need openBlock\u0026amp;createBlock support.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  // 源文件：/js/vue/lib.js const { rc: { h, createVNode: c, cloneVNode: cv, ssrUtils: { setCurrentRenderingInstance: s }, }, f, log, } = require(process.env.BLOG_JS + \u0026#34;/vue/lib.js\u0026#34;); const _h = (...args) =\u0026gt; f(c(...args)); const hoist = c(\u0026#39;div\u0026#39;) // 静态节点 let vnode1 const vnode = (openBlock(), createBlock(\u0026#39;div\u0026#39;))      shapeFlag test  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18  // 源文件：/js/vue/lib.js const { rc: { h, createVNode: c, cloneVNode: cv, Text }, f, log, } = require(process.env.BLOG_JS + \u0026#34;/vue/lib.js\u0026#34;); const _h = (...args) =\u0026gt; f(c(...args)); log([\u0026#34;\u0026gt;\u0026gt;\u0026gt; ELEMENT\\n\u0026#34;, f(c(\u0026#34;div\u0026#34;), \u0026#34;shapeFlag\u0026#34;)]); log([\u0026#34;\u0026gt;\u0026gt;\u0026gt; STATEFUL_COMONENT\\n\u0026#34;, f(c({}), \u0026#34;shapeFlag\u0026#34;)]); log([ \u0026#34;\u0026gt;\u0026gt;\u0026gt; FUNCTION_COMONENT\\n\u0026#34;, f( c(() =\u0026gt; {}), \u0026#34;shapeFlag\u0026#34; ), ]); log([\u0026#34;\u0026gt;\u0026gt;\u0026gt; Text\\n\u0026#34;, f(c(Text), \u0026#34;shapeFlag\u0026#34;)]);    \u0026gt;\u0026gt;\u0026gt; ELEMENT { shapeFlag: 1 } \u0026gt;\u0026gt;\u0026gt; STATEFUL_COMONENT { shapeFlag: 4 } \u0026gt;\u0026gt;\u0026gt; FUNCTION_COMONENT { shapeFlag: 2 } \u0026gt;\u0026gt;\u0026gt; Text { shapeFlag: 0 } undefined    mergeProps test  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33  // 源文件：/js/vue/lib.js const { rc: { h, createVNode: c, cloneVNode: cv, Text, mergeProps }, f, log, } = require(process.env.BLOG_JS + \u0026#34;/vue/lib.js\u0026#34;); let p1 = { class: \u0026#34;c\u0026#34; }; let p2 = { class: [\u0026#34;cc\u0026#34;] }; let p3 = { class: [{ ccc: true }] }; let p4 = { class: { cccc: true } }; log([\u0026#34;\u0026gt;\u0026gt;\u0026gt; merge class\\n\u0026#34;, mergeProps(p1, p2, p3, p4)]); let ps1 = { style: { color: \u0026#34;red\u0026#34;, fontSize: 10 }, }; let ps2 = { style: [ { color: \u0026#34;blue\u0026#34;, width: \u0026#34;200px\u0026#34; }, { width: \u0026#34;300px\u0026#34;, height: \u0026#34;300px\u0026#34;, fontSize: 30, }, ], }; let ps3 = { style: \u0026#39;width:100px;right:10;top:10\u0026#39; } log([\u0026#34;\u0026gt;\u0026gt;\u0026gt; merge style\\n\u0026#34;, mergeProps(ps1, ps2, ps3)]); let clickHandler1 = function(){} let clickHandler2 = function(){} let focusHandler3 = function(){} let ph1 = { onClick: clickHandler1 } let ph2 = { onClick: clickHandler2, onFocus: focusHandler3 } log([\u0026#39;\u0026gt;\u0026gt;\u0026gt; merge handlers\\n\u0026#39;, mergeProps(ph1, ph2)])    \u0026gt;\u0026gt;\u0026gt; merge class { class: \u0026#39;c cc ccc cccc\u0026#39; } \u0026gt;\u0026gt;\u0026gt; merge style { style: { color: \u0026#39;blue\u0026#39;, fontSize: 30, width: \u0026#39;100px\u0026#39;, height: \u0026#39;300px\u0026#39;, right: \u0026#39;10\u0026#39;, top: \u0026#39;10\u0026#39; } } \u0026gt;\u0026gt;\u0026gt; merge handlers { onClick: [ [Function: clickHandler1], [Function: clickHandler2] ], onFocus: [Function: focusHandler3] } undefined    TODO dynamic children test   \u0026gt; need openBlock\u0026amp;createBlock support\n1 2 3 4 5 6 7 8  const { rc: { h, createVNode: c, cloneVNode: cv, Text, mergeProps }, f, log, } = require(process.env.BLOG_JS + \u0026#34;/vue/lib.js\u0026#34;); const hoist = createVNode(\u0026#39;div\u0026#39;) let vnode1      TODO transformVNodeArgs test     TODO 7ec1d30 suspense component   feat(add): rc-\u0026gt;createVNode, type is suspense component · gcclll/stb-vue-next@7ec1d30 · GitHub\n Suspense 的 children 必须有且只有一个根节点。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65  // 7. normalize suspense children  if (__FEATURE_SUSPENSE__ \u0026amp;\u0026amp; shapeFlag \u0026amp; ShapeFlags.SUSPENSE) { const { content, fallback } = normalizeSuspenseChildren(vnode); vnode.ssContent = content; vnode.ssFallback = fallback; } // normalizeSuspenseChildren  export function normalizeSuspenseChildren( vnode: VNode ): { content: VNode; fallback: VNode; } { const { shapeFlag, children } = vnode; let content: VNode, fallback: VNode; if (shapeFlag \u0026amp; ShapeFlags.SLOTS_CHILDREN) { content = normalizeSuspenseSlot((children as Slots).default); fallback = normalizeSuspenseSlot((children as Slots).fallback); } else { content = normalizeSuspenseSlot(children as VNodeChild); fallback = normalizeVNode(null); } return { content, fallback, }; } // \u0026gt;\u0026gt;\u0026gt; normalizeSuspenseSlot function normalizeSuspenseSlot(s: any) { if (isFunction(s)) { s = s() } if (isArray(s)) { // ROOT 必须是单节点 \u0026lt;div\u0026gt;...\u0026lt;/div\u0026gt;  const singleChild = filterSingleRoot(s) if (__DEV__ \u0026amp;\u0026amp; !singleChild) { warn(`\u0026lt;Suspense\u0026gt; slots expect a single root node.`) } s = singleChild } return normalizeVNode(s) } // normalizeVNode export function normalizeVNode(child: VNodeChild): VNode { if (child == null || typeof child === \u0026#39;boolean\u0026#39;) { // empty placeholder  return createVNode(Comment) } else if (isArray(child)) { // fragment  return createVNode(Fragment, null, child) } else if (typeof child === \u0026#39;object\u0026#39;) { // already vnode, this should be the most common since compiled templates  // always produce all-vnode children arrays  // 这是最常用的情况，因为使用模板的时候最后生成的 children 是数组  return child.el === null ? child : cloneVNode(child) } else { // strings and numbers  return createVNode(Text, null, String(child)) } }     检测是不是 single root 函数： filterSingleRoot\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23  export function filterSingleRoot( children: VNodeArrayChildren ): VNode | undefined { let singleRoot; for (let i = 0; i \u0026lt; children.length; i++) { const child = children[i]; if (isVNode(child)) { // ignore user comment  if (child.type !== Comment || child.children === \u0026#34;v-if\u0026#34;) { if (singleRoot) { // has more than 1 non-comment child, return now  return; } else { singleRoot = child; } } } else { return; } } return singleRoot; }      TODO 23fc943 currentBlock 优化   feat(add): rc-\u0026gt;createVNode, optimize diff, currentBlock · gcclll/stb-vue-next@23fc943 · GitHub\n 这里的处理没怎么搞明白❓\n  注意这里增加的几个变量‼\n blockStack, currentBlock:\n1 2 3 4 5 6 7 8 9  // Since v-if and v-for are the two possible ways node structure can dynamically // change, once we consider v-if branches and each v-for fragment a block, we // can divide a template into nested blocks, and within each block the node // structure would be stable. This allows us to skip most children diffing // and only worry about the dynamic nodes (indicated by patch flags). // 针对 v-if, v-for 动态性做的由于，减少对静态节点的 diff ，只需要关心动态节点即可 export const blockStack: (VNode[] | null)[] = [] let currentBlock: VNode[] | null = null     shouldTrack:\n1 2 3 4 5 6  // Whether we should be tracking dynamic child nodes inside a block. // Only tracks when this value is \u0026gt; 0 // We are not using a simple boolean because this value may need to be // incremented/decremented by nested usage of v-once (see below) // 是否应该 tracking block 内动态的孩子节点 let shouldTrack = 1;     新增处理逻辑：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18  // 8. currentBlock  if ( shouldTrack \u0026gt; 0 \u0026amp;\u0026amp; // 避免 block 节点 tracking 自己  !isBlockNode \u0026amp;\u0026amp; // has current parent block  currentBlock \u0026amp;\u0026amp; // presence of a patch flag indicates this node needs patching on updates.  // component nodes also should always be patched, because even if the  // component doesn\u0026#39;t need to update, it needs to persist the instance on to  // the next vnode so that it can be properly unmounted later.  (patchFlag \u0026gt; 0 || shapeFlag \u0026amp; ShapeFlags.COMPONENT) \u0026amp;\u0026amp; // the EVENTS flag is only for hydration and if it is the only flag, the  // vnode should not be considered dynamic due to handler caching.  patchFlag !== PatchFlags.HYDRATE_EVENTS ) { currentBlock.push(vnode); }     跟这几个变量有关的函数：\n  TODO block related(open/close/create)   feat(add): rc-\u0026gt;block related, open/create/closeBlock · gcclll/stb-vue-next@a2afc70 · GitHub\n 这里的所有函数都和 createVNode 里面的 currentBlock 有关。\n openBlock:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19  /** ,* Open a block. ,* This must be called before `createBlock`. It cannot be part of `createBlock` ,* because the children of the block are evaluated before `createBlock` itself ,* is called. The generated code typically looks like this: ,* ,* ```js ,* function render() { ,* return (openBlock(),createBlock(\u0026#39;div\u0026#39;, null, [...])) ,* } ,* ``` ,* disableTracking is true when creating a v-for fragment block, since a v-for ,* fragment always diffs its children. ,* ,* @private ,*/ export function openBlock(disableTracking = false) { blockStack.push((currentBlock = disableTracking ? null : [])); }     closeBlock:\n1 2 3 4  export function closeBlock() { blockStack.pop(); currentBlock = blockStack[blockStack.length - 1] || null; }     setBlockTracking:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19  /** * Block tracking sometimes needs to be disabled, for example during the * creation of a tree that needs to be cached by v-once. The compiler generates * code like this: * * ``` js * _cache[1] || ( * setBlockTracking(-1), * _cache[1] = createVNode(...), * setBlockTracking(1), * _cache[1] * ) * ``` * * @private */ export function setBlockTracking(value: number) { shouldTrack += value }     createBlock:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33  /** * Create a block root vnode. Takes the same exact arguments as `createVNode`. * A block root keeps track of dynamic nodes within the block in the * `dynamicChildren` array. * * @private */ export function createBlock( type: VNodeTypes | ClassComponent, props?: Record\u0026lt;string, any\u0026gt; | null, children?: any, patchFlag?: number, dynamicProps?: string[] ): VNode { const vnode = createVNode( type, props, children, patchFlag, dynamicProps, true /* isBlock: prevent a block from tracking itself */ ); // save current block children on the block vnode  vnode.dynamicChildren = currentBlock || (EMPTY_ARR as any); // close block  closeBlock(); // a block is always going to be patched, so track it as a child of its  // parent block  if (shouldTrack \u0026gt; 0 \u0026amp;\u0026amp; currentBlock) { currentBlock.push(vnode); } return vnode; }     相关脑图：   normalizeChildren function   shapeFlag 初始值检测：\n1 2 3 4 5 6 7 8 9 10 11 12  // encode the vnode type information into a bitmap const shapeFlag = isString(type) ? ShapeFlags.ELEMENT // 1  : __FEATURE_SUSPENSE__ \u0026amp;\u0026amp; isSuspense(type) ? ShapeFlags.SUSPENSE // 1 \u0026lt;\u0026lt; 7, 128  : isTeleport(type) ? ShapeFlags.TELEPORT // 1 \u0026lt;\u0026lt; 6, 64  : isObject(type) ? ShapeFlags.STATEFUL_COMPONENT // 1 \u0026lt;\u0026lt; 2, 4  : isFunction(type) ? ShapeFlags.FUNCTIONAL_COMPONENT // 1 \u0026lt;\u0026lt; 1, 2  : 0;     测试:\n1 2 3 4 5 6 7  // 源文件：/js/vue/lib.js const { rc: { h, createVNode: c }, f, log } = require(process.env.BLOG_JS + \u0026#39;/vue/lib.js\u0026#39;) const _h = (...args) =\u0026gt; f(c(...args)) log([\u0026#39;\u0026gt;\u0026gt;\u0026gt; only tag\\n\u0026#39;, _h(\u0026#39;p\u0026#39;)]) log([\u0026#39;\u0026gt;\u0026gt;\u0026gt; tag + props\\n\u0026#39;, _h(\u0026#39;p\u0026#39;, { foo: \u0026#39;foo\u0026#39; })]) log([\u0026#39;\u0026gt;\u0026gt;\u0026gt; tag + props + children\\n\u0026#39;, _h(\u0026#39;p\u0026#39;, { foo: \u0026#39;foo\u0026#39; }, [\u0026#39;foo\u0026#39;])])    \u0026gt;\u0026gt;\u0026gt; only tag { __v_isVNode: true, __v_skip: true, type: \u0026#39;p\u0026#39;, shapeFlag: 1 } \u0026gt;\u0026gt;\u0026gt; tag + props { __v_isVNode: true, __v_skip: true, type: \u0026#39;p\u0026#39;, props: { foo: \u0026#39;foo\u0026#39; }, shapeFlag: 1 } \u0026gt;\u0026gt;\u0026gt; tag + props + children { __v_isVNode: true, __v_skip: true, type: \u0026#39;p\u0026#39;, props: { foo: \u0026#39;foo\u0026#39; }, children: [ \u0026#39;foo\u0026#39; ], shapeFlag: 17 } undefined  children is function   feat(add): rc-\u0026gt;propsOrChildren is function · gcclll/stb-vue-next@28d4a55 · GitHub\n 如果是函数，当做 slot 的 children 处理。\n normalizeChildren:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19  export function normalizeChildren(vnode: VNode, children: unknown) { let type = 0 if (children == null) { children = null } else if (false /*array*/) { // TODO  } else if (false /*object*/) { // TODO  } else if (isFunction(children)) { // 如果是函数当做 slot children ?  children = { default: children, _ctx: currentRenderingInstance } type = ShapeFlags.SLOTS_CHILDREN } else { // TODO 普通类型  } vnode.children = children as VNodeNormalizedChildren vnode.shapeFlag |= type }     测试：\n1 2 3 4 5 6 7 8 9 10  // 源文件：/js/vue/lib.js const { rc: { h, createVNode:c }, log, f } = require(process.env.BLOG_JS + \u0026#39;/vue/lib.js\u0026#39;) const _h = (...args) =\u0026gt; f(h(...args)); const _c = (...args) =\u0026gt; f(c(...args)); const Component = { template: \u0026#39;\u0026lt;br /\u0026gt;\u0026#39; } const slot = () =\u0026gt; {} log([\u0026#39;\u0026gt;\u0026gt;\u0026gt; default slot\\n\u0026#39;, _h(Component, slot)]) log([\u0026#39;\u0026gt;\u0026gt;\u0026gt; children is function\\n\u0026#39;, _c(\u0026#39;div\u0026#39;, {}, slot)])    \u0026gt;\u0026gt;\u0026gt; default slot { __v_isVNode: true, __v_skip: true, type: { template: \u0026#39;\u0026lt;br /\u0026gt;\u0026#39; }, children: { default: [Function: slot], _ctx: null }, shapeFlag: 36 } \u0026gt;\u0026gt;\u0026gt; children is function { __v_isVNode: true, __v_skip: true, type: \u0026#39;div\u0026#39;, props: {}, children: { default: [Function: slot], _ctx: null }, shapeFlag: 33 } undefined    children is array or 普通类型   feat(add): rc-\u0026gt;createVNode, children is array or primitive · gcclll/stb-vue-next@850c0bc · GitHub\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23  // 数组类型 if (isArray(children)) { type = ShapeFlags.ARRAY_CHILDREN; } // 非对象，数组，函数的普通类型处理 { children = String(children); // force teleport children to array so it can be moved around  if (shapeFlag \u0026amp; ShapeFlags.TELEPORT) { type = ShapeFlags.ARRAY_CHILDREN; children = [createTextVNode(children as string)]; } else { type = ShapeFlags.TEXT_CHILDREN; } } // createTextVNode export function createTextVNode(text: string = \u0026#34; \u0026#34;, flag: number = 0): VNode { return createVNode(Text, null, text, flag); } export const Text = Symbol(__DEV__ ? \u0026#39;Text\u0026#39; : undefined)     普通类型处理中如果是 ShapeFlags.TELETPORT 当做 ARRAY_CHILDREN 处理，且 children 按照文本节点处理。\n1 2 3 4 5 6 7 8 9 10  const { rc: { h, createVNode: c }, f, log, } = require(process.env.BLOG_JS + \u0026#34;/vue/lib.js\u0026#34;); const _h = (...args) =\u0026gt; f(h(...args)); const _c = (...args) =\u0026gt; f(c(...args)); log([`\u0026gt;\u0026gt;\u0026gt; array will be children(${1 | (1 \u0026lt;\u0026lt; 4)})\\n`, _h(\u0026#34;div\u0026#34;, [\u0026#34;foo\u0026#34;])]); log([\u0026#34;\u0026gt;\u0026gt;\u0026gt; string will be children()\\n\u0026#34;, _h(\u0026#34;div\u0026#34;, \u0026#34;foo\u0026#34;)]);    \u0026gt;\u0026gt;\u0026gt; array will be children(17) { __v_isVNode: true, __v_skip: true, type: \u0026#39;div\u0026#39;, children: [ \u0026#39;foo\u0026#39; ], shapeFlag: 17 } \u0026gt;\u0026gt;\u0026gt; string will be children() { __v_isVNode: true, __v_skip: true, type: \u0026#39;div\u0026#39;, children: \u0026#39;foo\u0026#39;, shapeFlag: 9 } undefined    children is object   feat(add): rc-\u0026gt;createVNode, normalizeChildren is object · gcclll/stb-vue-next@959879e · GitHub\n shapeFlag 可能是 ShapeFlags.ELEMENT 或者 ShapeFalgs.TELEPORT 。\n 这里先测试 ELEMENT 情况，因为 TELEPORT 还需要实现 components/Teleport 。\n 如果 type 是 对象， shapeFlag 初始类型会是 ShapeFlags.STATEFULL_COMPONENT, 1 \u0026lt;\u0026lt; 2\n1 2 3 4 5 6 7 8 9 10 11 12  // 源文件：/js/vue/lib.js const { rc: { h, createVNode: c }, f, log, } = require(process.env.BLOG_JS + \u0026#34;/vue/lib.js\u0026#34;); const _h = (...args) =\u0026gt; f(c(...args)); // 因为 type = {} , shapeFlag = 1 \u0026lt;\u0026lt; 2, 4 // 所以在 normalizeChildren 里面 isObject 分支会进入 else // 进行处理，经过处理之后成为 4 | SLOTS_CHILDREN,2\u0026lt;\u0026lt;5,32 = 36 log([\u0026#34;\u0026gt;\u0026gt;\u0026gt; object\\n\u0026#34;, _h({}, null, { foo: \u0026#34;foo\u0026#34; })]);    \u0026gt;\u0026gt;\u0026gt; object { __v_isVNode: true, __v_skip: true, type: {}, children: { foo: \u0026#39;foo\u0026#39;, _ctx: null }, shapeFlag: 36 } undefined        ⏱ api watch(source, cb, options)   feat(add): api watch TODOs · gcclll/stb-vue-next@4f0301e · GitHub\n 脑图：  为了更好的完成 apiWatch， 需要先完成了 scheduler 任务调度部分。\n  watch(source, cb, options) 函数以下种使用方式(下面的 cb 均可选参数)：\n  watch(fn) 等价于 watchEffect(fn), 无 cb\n  watch(fn, cb) 监听函数\n  watch(ref(0), cb)\n  watch(reactive({ count: 0}), cb) , reactive 对象默认 deep = true\n  watch([ref(0), reactive({count: 0})], cb)\n  watch(fn, cb, { immediate: true }) 此时， cb 必须为函数， job-\u0026gt;fn 被立即执 行一次， cb 接受新旧值\n  watch(ref({ count: 0}), cb, { deep: true }) 手动指定 deep: true 深度监听\n  …\n  执行具体实现的函数： doWatch()\n   Arg value description     source WatchSource, WatchSource[], WatchEffect, object object watched   cb WatchCallback or null callback     options WatchOptions = EMPTY_OBJ     immediate     deep     flush     onTrack     onTrigger      instance currentInstance -     watch(source, cb, options?) 函数中的 cb 是必选项，如果想直接 watch effect，可使 用 watchEffect(fn, options?) api 。\n  watch 函数基本流程：\n  cb, immediate, deep 检测\n  getter， 根据 source 不同类型设置 getter\n  cb + deep: true\n  SSR node env\n  将 cb 封装成 job\n  runner = effect(getter, option)\n  runner 如何执行？\n  stop, remove，函数返回一个 stop+remove 该 runner 操作的函数\n   下面章节中测试的用例分析脑图： source is ref   feat(add): apiWatch-\u0026gt;no cb, getter is ref · gcclll/stb-vue-next@b9b7ac6 · GitHub\n fix: watch-\u0026gt;source is ref, cb -\u0026gt; job · gcclll/stb-vue-next@6752326 · GitHub 测试:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22  // 源文件：/js/vue/lib.js const { rc: { ref, nextTick, watch }, log, } = require(process.env.BLOG_JS + \u0026#34;/vue/lib.js\u0026#34;); const run = async () =\u0026gt; { const count = ref(0); let dummy, i = 0; watch(count, (count, prevCount) =\u0026gt; { log(\u0026#34;\\nvalue changed: \u0026#34; + i++); dummy = [count, prevCount]; count + 1; if (prevCount) { prevCount + 1; } }); count.value++; await nextTick(); log(dummy); }; run();    undefined value changed: 0 1 0   有关代码(doWatch):\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52  // -\u0026gt; getter let getter: () =\u0026gt; any; let forceTrigger = false; // 2.1 source is ref if (isRef(source)) { getter = () =\u0026gt; (source as Ref).value; forceTrigger = !!(source as Ref)._shallow; } // cb -\u0026gt; job 封装 let oldValue = isArray(source) ? [] : INITIAL_WATCHER_VALUE; const job: SchedulerJob = () =\u0026gt; { if (cb) { // watch(source, cb)  const newValue = runner(); if (deep || forceTrigger || hasChanged(newValue, oldValue)) { // cleanup  if (cleanup) cleanup(); callWithAsyncErrorHandling(cb, instance, ErrorCodes.WATCH_CALLBACK, [ newValue, // pass undefined as the old value when it\u0026#39;s changed for the first time  // 第一次的时候 oldValue 为 undefined  oldValue === INITIAL_WATCHER_VALUE ? undefined : oldValue, onInvalidate, ]); oldValue = newValue; } } else { // TODO  } }; // scheduler 封装 scheduler = () =\u0026gt; { if (!instance || instance.isMounted) { queuePreFlushCb(job); } else { } }; // 什么方式执行 runner? // 8. TODO runner 如何执行？ if (cb) { if (immediate) { // TODO  } else { oldValue = runner(); } } else if (false /*flush-\u0026gt;post*/) { } else { runner(); }      source is reactive   如果要 watch 的对象是个 reactive ，需要进行递归 watch ，得到 getter.\n fix: watch-\u0026gt;source is reactive · gcclll/stb-vue-next@697f7f2 · GitHub\n 新增相关代码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37  // 1. 如果是 reactive，需要深度监听 if (isReactive(source)) { getter = () =\u0026gt; source; deep = true; } // 2. deep: true if (cb \u0026amp;\u0026amp; deep) { const baseGetter = getter; // a. deep: true  // b. source is reactive  getter = () =\u0026gt; traverse(baseGetter()); } // traverse 函数 function traverse(value: unknown, seen: Set\u0026lt;unknown\u0026gt; = new Set()) { if (!isObject(value) || seen.has(value)) { return value; } seen.add(value); if (isRef(value)) { traverse(value.value, seen); } else if (isArray(value)) { for (let i = 0; i \u0026lt; value.length; i++) { traverse(value[i], seen); } } else if (isSet(value) || isMap(value)) { value.forEach((v: any) =\u0026gt; { traverse(v, seen); }); } else { for (const key in value) { traverse(value[key], seen); } } return value; }     递归监听 reactive 对象任意层级上的属性变化。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20  // 源文件：/js/vue/lib.js const { rc: { nextTick, watchEffect, reactive, watch }, log, } = require(process.env.BLOG_JS + \u0026#34;/vue/lib.js\u0026#34;); const run = async () =\u0026gt; { const state = reactive({ count: 0, r1: { count: 10 } }); let dummy; watch(state, (newVal, preVal) =\u0026gt; { dummy = [newVal, preVal]; }); state.count++; await nextTick(); log.br(dummy); state.r1.count-- await nextTick() log.br(dummy) }; run();    undefined { count: 1, r1: { count: 10 } } { count: 1, r1: { count: 10 } } { count: 1, r1: { count: 9 } } { count: 1, r1: { count: 9 } }   注意: newVal 和 preVal 返回的是整个 state 而非当前所发生变更的属性 (count/r1.count)，因为在 job 里面执行 runner() 得到新值是在 traverse(baseGetter()) 之前发生的，此时取到的值是 state 自身。\n    soure is array   feat(add): apiWatch-\u0026gt;source is array · gcclll/stb-vue-next@af1e590 · GitHub\n 如果要监听的对象是个数组的时候，需要检测数组元素的类型，针对不同类型进行处理。\n 要点：\n  数组元素不能是除 ref/reactive/function 之外的类型\n  对数组元素设值时必须通过元素原始设值方式进行(比如： ref 要 ref.value = xxx)， 因为该数组本身不是 reactive 的\n  1 2 3 4 5 6 7 8 9 10 11 12 13 14  if (isArray(source)) { getter = () =\u0026gt; source.map((s) =\u0026gt; { if (isRef(s)) { return s.value; } else if (isReactive(s)) { return traverse(s); } else if (isFunction(s)) { return callWithErrorHandling(s, instance, ErrorCodes.WATCH_GETTER); } else { // TODO warn invalid source  } }); }      isRef -\u0026gt; 监听 item.value\n  isReactive -\u0026gt; traverse(item) 递归\n  isFunction -\u0026gt; callWithErrorHandling(item, instance, …) 监听函数返回值\n  其他类型不支持 -\u0026gt; warn invalid source\n  测试：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17  // 源文件：/js/vue/lib.js const { rc: { ref, watch, nextTick, reactive }, log, } = require(process.env.BLOG_JS + \u0026#34;/vue/lib.js\u0026#34;); const run = async () =\u0026gt; { const array = reactive([]); let dummy; watch(array, (newArr, preArr) =\u0026gt; { dummy = [newArr, \u0026#34;\\n\u0026#34;]; }); array.push(1); await nextTick(); log.br(dummy); }; run();    undefined [ 1 ]   数组混合模式(元素只支持 ref, reactive, function)：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27  const { rc: { ref, watch, nextTick, reactive, effect }, log, } = require(process.env.BLOG_JS + \u0026#34;/vue/lib.js\u0026#34;); let dummy, val = reactive([10, 1]); effect(() =\u0026gt; { dummy = val[0]; }); val[0]++; log(`dummy = ${dummy}\\n`); console.warn(\u0026#34;---\u0026#34;); const run = async () =\u0026gt; { const state = reactive({ count: 1 }); const status = ref(false); let dummy; watch([() =\u0026gt; state.count, status], (vals, oldVals) =\u0026gt; { dummy = [vals, oldVals]; }); state.count++; status.value = true; await nextTick(); log.br(dummy); }; run();    dummy = 11 undefined [ [ 2, true ], [ 1, false ] ]   Tip. watch 数组的时候，需要通过数组元素原来的对象去操作值的变更，如果通过数组下 标设值是不会成功的，因为这个数组本身不是 reactive 的。\n 比如： array[0]++ 并不会改变 state.count\n 只有通过 state.count++ 自身赋值操作才会触发更新。\n   source is function   feat(add): rc-\u0026gt;api watch-\u0026gt;source is function · gcclll/stb-vue-next@694a389 · GitHub\n 当要 watch 的对象是个函数的时候，无论是否有 cb 最后的 getter 都是通过\n callWithErrorHandling(source, instance, ErrorCodes.WATCH_GETTER)\n 或无 cb 时等价于普通的 effect 函数\n callWithErrorHandling(source, instance,ErrorCodes.WATCH_CALLBACK,[onInvalidate])\n 直接执行这个函数去收集依赖。\n  新增代码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25  if (isFunction(source)) { // 如果是函数，直接执行取得函数执行结果  if (cb) { // getter with cb  getter = () =\u0026gt; callWithErrorHandling(source, instance, ErrorCodes.WATCH_GETTER); } else { // no cb -\u0026gt; simple effect  getter = () =\u0026gt; { if (instance \u0026amp;\u0026amp; instance.isUnmounted) { // 组件已经卸载了  return; } if (cleanup) cleanup(); return callWithErrorHandling( source, instance, ErrorCodes.WATCH_CALLBACK, [onInvalidate] ); }; } }     feat(add): rc-\u0026gt;api watch-\u0026gt;source is function without cb · gcclll/stb-vue-next@9565b4a · GitHub\n 测试：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27  // 源文件：/js/vue/lib.js const { rc: { nextTick, watchEffect, watch, ref }, log, } = require(process.env.BLOG_JS + \u0026#34;/vue/lib.js\u0026#34;); const run = async () =\u0026gt; { let dummy, val = ref(0); watch(() =\u0026gt; (dummy = val.value)); val.value++; await nextTick(); log.br({ dummy }); log(\u0026#34;with cb\\n\u0026#34;); // function with cb  watch( () =\u0026gt; val.value, (val, oldVal) =\u0026gt; { dummy = [val, oldVal]; } ); val.value = 100; await nextTick(); log([dummy, \u0026#34;\\n\u0026#34;]); }; run();    undefined { dummy: 1 } with cb [ 100, 1 ]   feat(add): rc-\u0026gt;api watch-\u0026gt;source invalid warning · gcclll/stb-vue-next@11ee8ef · GitHub\n   这里有个容易搞混淆的地方， watch(fn, cb) 的时候，虽然 fn 和 cb 都是函数，但 是要区分开这两者，并搞清楚他们是啥和关系是啥。\n  fn 是被检测的对象，如果是 function 那在被监听之前需要先执行它，等于是监听 函数里面的内容，比如：函数内有访问某个 reactive 变量\n  而 cb 是属于回调性质，且是当数据有更新的时候的回调函数，它只会在一个地方被 执行，即封装 job 的时候，需要将数据更新前后的变化值通过它传递出来(如下面👇的 代码)\n     1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21  const job: SchedulerJob = () =\u0026gt; { if (cb) { // watch(source, cb)  const newValue = runner(); if (deep || forceTrigger || hasChanged(newValue, oldValue)) { // cleanup  if (cleanup) cleanup(); callWithAsyncErrorHandling(cb, instance, ErrorCodes.WATCH_CALLBACK, [ newValue, // pass undefined as the old value when it\u0026#39;s changed for the first time  // 第一次的时候 oldValue 为 undefined  oldValue === INITIAL_WATCHER_VALUE ? undefined : oldValue, onInvalidate, ]); oldValue = newValue; } } else { // watchEffect, no cb  runner(); } };      option deep   对于深度监听主要是因为 traverse() 函数对 reactive 对象进行了递归遍历，对每个属 性进行了访问，从而让它收集到当前的 effect 作为依赖，这样将来这些被遍历到的值发生 改变时就会触发这个收集到的 effect 执行，达到深度监听效果。\n1 2 3 4 5 6 7 8  // 3. cb + deep: true  if (cb \u0026amp;\u0026amp; deep) { const baseGetter = getter; // a. deep: true  // b. source is reactive  getter = () =\u0026gt; traverse(baseGetter()); }     traverse() 作用就是递归遍历所有属性通过 return value 来执行 get 操作收集依赖。\n  测试：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50  // 源文件：/js/vue/lib.js const { rc: { ref, reactive, watch, nextTick }, log, } = require(process.env.BLOG_JS + \u0026#34;/vue/lib.js\u0026#34;); const run = async () =\u0026gt; { const count = ref(0); const state = reactive({ nested: { count }, array: [1, 2, 3], map: new Map([ [\u0026#34;a\u0026#34;, 1], [\u0026#34;b\u0026#34;, 2], ]), set: new Set([1, 2, 3]), }); let dummy; watch( () =\u0026gt; state, (state) =\u0026gt; { dummy = [ state.nested.count, state.array[0], state.map.get(\u0026#34;a\u0026#34;), state.set.has(1), ]; }, { deep: true } ); state.nested.count++; await nextTick(); log([\u0026#34;\\n\u0026#34;, dummy]); state.array[0] = 2; await nextTick(); log([\u0026#34;\\n\u0026#34;, dummy]); state.map.set(\u0026#34;a\u0026#34;, 100); await nextTick(); log([\u0026#34;\\n\u0026#34;, dummy]); state.set.delete(1); await nextTick(); log([\u0026#34;\\n\u0026#34;, dummy]); }; run();    undefined [ 1, 1, 1, true ] [ 1, 2, 1, true ] [ 1, 2, 100, true ] [ 1, 2, 100, false ]  TODO deep ref     option immediate   feat(add): rc-\u0026gt;api watch-\u0026gt;immediate option · gcclll/stb-vue-next@204ce68 · GitHub\n immediate 选项，会让 cb/job 立即执行一次，而不是在队列中等待异步执行。\n 新增代码只需要加一行：\n1 2 3 4 5 6 7 8 9 10  if (cb) { if (immediate) { job(); // 这里直接调用 Job  } else { oldValue = runner(); } } else if (false /*flush-\u0026gt;post*/) { } else { runner(); }     测试：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40  // 源文件：/js/vue/lib.js const { rc: { nextTick, watch, ref }, log, } = require(process.env.BLOG_JS + \u0026#34;/vue/lib.js\u0026#34;); const run = async () =\u0026gt; { const _log = (desc, newline) =\u0026gt; log([newline ? \u0026#34;\\n\u0026#34; : \u0026#34;\u0026#34;, `${desc}\u0026gt; dummy = ${dummy}`]); const cb = (val) =\u0026gt; (dummy = val); const option = { immediate: true }; const count = ref(0); let dummy; watch(count, cb, option); _log(\u0026#34;改变值之前\u0026#34;); count.value++; await nextTick(); _log(\u0026#34;改变值之后\u0026#34;, true); const nul = ref(null); watch(() =\u0026gt; nul.value, cb, option); _log(\u0026#34;当初始值为 null\u0026#34;); const undef = ref(); watch(() =\u0026gt; undef.value, cb, option); _log(\u0026#34;当初始值为 undefined\u0026#34;); undef.value = 3; await nextTick(); _log(\u0026#34;当初始值为 undefined, set 3\u0026#34;); undef.value = undefined; await nextTick(); _log(\u0026#34;当初始值为 undefined, set undefined\u0026#34;); // undefined === undefined -\u0026gt; hasChanged() -\u0026gt; false  undef.value = undefined; await nextTick(); _log(\u0026#34;当初始值为 undefined, set undefined\u0026#34;); }; run();    改变值之前 \u0026gt; dummy = 0 undefined 改变值之后 \u0026gt; dummy = 1 当初始值为 null \u0026gt; dummy = null 当初始值为 undefined \u0026gt; dummy = undefined 当初始值为 undefined, set 3 \u0026gt; dummy = 3 当初始值为 undefined, set undefined \u0026gt; dummy = undefined 当初始值为 undefined, set undefined \u0026gt; dummy = undefined   如上结果， cb 会立即执行。\n 在使用 deep 和 immediate 选项的时候如果没有 cb 会给出警告，直接看源码吧:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  // 1. cb, immediate, deep 检测 if (__DEV__ \u0026amp;\u0026amp; !cb) { if (immediate !== undefined) { warn( `watch() \u0026#34;immediate\u0026#34; option is only respected when using the ` + `watch(source, callback, options?) signature.` ); } if (deep !== undefined) { warn( `watch() \u0026#34;deep\u0026#34; option is only respected when using the ` + `watch(source, callback, options?) signature.` ); } }     也就是说， deep 和 immediate 建议在 watch(s, cb, options) 形式下使用，即在 有 cb 参数的情况下使用。\n 那为什么呢？\n   option onTrack + onTrigger   这部分实现逻辑主要在 reactivity 模块。\n onTrack 在 reactivity 中使用的，用来在触发 get 取值操作时调用 track() 函数收集依 赖时的一个自定义事件回调。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27  // track() 函授最后 add 操作之后 if (!dep.has(activeEffect)) { dep.add(activeEffect); // 自身保存一份被依赖者名单  activeEffect.deps.push(dep); if (__DEV__ \u0026amp;\u0026amp; activeEffect.options.onTrack) { activeEffect.options.onTrack({ effect: activeEffect, target, type, key, }); } } // trigger() 函数中实现 if (effect.options.onTrigger) { effect.options.onTrigger({ effect, target, key, type, newValue, oldValue, oldTarget, }); }     这里会将 当前 target 的 key 属性所收集的依赖 activeEffect 暴露出来。\n 测试：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34  // 源文件：/js/vue/lib.js const { rc: { nextTick, watchEffect, reactive }, log, } = require(process.env.BLOG_JS + \u0026#34;/vue/lib.js\u0026#34;); const run = async () =\u0026gt; { const trackEvents = []; const triggerEvents = []; let dummy; const onTrack = (e /* activeEffect */) =\u0026gt; trackEvents.push(e); const onTrigger = (e /* effect */) =\u0026gt; triggerEvents.push(e); const obj = reactive({ foo: 1, bar: 2 }); watchEffect( () =\u0026gt; { dummy = [obj.foo, \u0026#34;bar\u0026#34; in obj, Object.keys(obj)]; }, { onTrack, onTrigger } ); await nextTick(); log([\u0026#34;\\n\u0026#34;, dummy]); // 有多少个就等于呗调用了多少次  log(\u0026#34;track events count = \u0026#34; + trackEvents.length); trackEvents.forEach((e) =\u0026gt; log.props(e, [\u0026#34;target\u0026#34;, \u0026#34;type\u0026#34;, \u0026#34;key\u0026#34;, \u0026#34;deps\u0026#34;])); obj.foo = 3; obj.bar = 4; log(\u0026#34;trigger events count = \u0026#34; + triggerEvents.length); triggerEvents.forEach((e) =\u0026gt; log.props(e, [\u0026#34;type\u0026#34;, \u0026#34;key\u0026#34;, \u0026#34;oldValue\u0026#34;, \u0026#34;newValue\u0026#34;]) ); }; run();    undefined [ 1, true, [ \u0026#39;foo\u0026#39;, \u0026#39;bar\u0026#39; ] ] track events count = 3 { target: { foo: 1, bar: 2 }, type: \u0026#39;get\u0026#39;, key: \u0026#39;foo\u0026#39; } { target: { foo: 1, bar: 2 }, type: \u0026#39;has\u0026#39;, key: \u0026#39;bar\u0026#39; } { target: { foo: 1, bar: 2 }, type: \u0026#39;iterate\u0026#39;, key: Symbol(iterate) } trigger events count = 2 { key: \u0026#39;foo\u0026#39;, type: \u0026#39;set\u0026#39;, newValue: 3, oldValue: 1 } { key: \u0026#39;bar\u0026#39;, type: \u0026#39;set\u0026#39;, newValue: 4, oldValue: 2 }  这里还需要开发环境才能测试 onTrack，只能改一改去掉 __DEV__ 试试。\n   stop \u0026amp; cleanup   stop: watch() 的返回值，用来停掉 effect 使其 effect.active = false，让 effect 失效。\n1 2 3 4 5 6 7  // 9. return runner-\u0026gt;stop, remove runner from instance.effects return () =\u0026gt; { stop(runner); if (instance) { remove(instance.effects!, runner); } };     cleanup: 清理工作，这有两个被调用的地方(cleanup + onStop它们被注册了同一个函数)， 一个是调动 cb/fn 之前，一个是 runner effect 调用 stop 的时候。\n1 2 3 4 5 6  let cleanup: () =\u0026gt; void; const onInvalidate: InvalidateCbRegistrator = (fn: () =\u0026gt; void) =\u0026gt; { cleanup = runner.options.onStop = () =\u0026gt; { callWithErrorHandling(fn, instance, ErrorCodes.WATCH_CLEANUP); }; };    stop  stop 是 watch 调用的返回值，里面会 stop runner 然后将 runner 从 instance.effects 里面删除。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26  // 源文件：/js/vue/lib.js const { rc: { reactive, nextTick, watch }, log, } = require(process.env.BLOG_JS + \u0026#34;/vue/lib.js\u0026#34;); const run = async () =\u0026gt; { const state = reactive({ count: 0 }); let dummy; const stop = watch( () =\u0026gt; state.count, (count) =\u0026gt; { dummy = count; } ); state.count++; await nextTick(); log.br({ dummy }); stop(); state.count = 100; await nextTick(); log({ dummy }); }; run();    undefined { dummy: 1 } { dummy: 1 }   可以看到 stop 之后两次输出结果是一样，即 stop 后面的 state.count 失效了，因为 stop effect 会将 effect.active 置为 false ，有如下代码被执行:\n1 2 3 4  // reactivity/src/effect.ts -\u0026gt; createReactiveEffect() if (!effect.active) { return options.scheduler ? undefined : fn(); }     又， watch 函数里面无论如何 scheduler 都是有值的，所以当 effect 为非激活状态，什 么都不会干。\n  cleanup(无 cb)   cleanup 相关源码，可能有点绕:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48  // cleanup 和注册 cleanup 的一个函数 // 如下，cleanup 和 effect onStop 是同一个函数，清理 effect 用 let cleanup: () =\u0026gt; void; const onInvalidate: InvalidateCbRegistrator = (fn: () =\u0026gt; void) =\u0026gt; { cleanup = runner.options.onStop = () =\u0026gt; { callWithErrorHandling(fn, instance, ErrorCodes.WATCH_CLEANUP); }; }; // runtime-core/src/apiWatch.ts:watch(source, cb, option) // Job 封装中和 cleanup 有关的 const job: SchedulerJob = () =\u0026gt; { if (!runner.active) { return; } if (cb) { // watch(source, cb)  const newValue = runner(); if (deep || forceTrigger || hasChanged(newValue, oldValue)) { // cleanup，在执行 cb 之前先执行 cleanup  if (cleanup) cleanup(); // call cb with catch error  // 这里等价于 cb(newValue, oldValue, onInvalidate)  oldValue = newValue; } } /* else... */ }; // 然后还有个地方与 cleanup 有关，且这里要讲到的内容会在这部分执行 // 获取 getter函数时候，如果 source 是函数等价于 // watchEffect(source) if (isFunction(source)) { // 如果是函数，直接执行取得函数执行结果  if (cb) { // ...  } else { // no cb -\u0026gt; simple effect  getter = () =\u0026gt; { if (instance \u0026amp;\u0026amp; instance.isUnmounted) { // 组件已经卸载了  return; } if (cleanup) cleanup(); // 等价于 return source(onInvalidate)  }; } }     测试：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29  // 源文件：/js/vue/lib.js const { rc: { reactive, nextTick, watchEffect }, log, } = require(process.env.BLOG_JS + \u0026#34;/vue/lib.js\u0026#34;); const run = async () =\u0026gt; { const state = reactive({ count: 0 }); let n = 0; const cleanup = () =\u0026gt; log(`\\ncalled ${++n}times.`); let dummy; const stop = watchEffect((onCleanup) =\u0026gt; { // 这里执行的实际上是 onInvalidate 函数，将cleanup 封装后注册到  // cleanup 和 onStop 上，在 cb 执行之前或 effect stop 时候调用  onCleanup(cleanup); dummy = state.count; }); state.count++; await nextTick(); // 这里会输出一次 \u0026#39;called 1 times.\u0026#39;  // 因为 cb 之前之前进行了清理工作(cleanup())  log.br({ dummy }); // 这里会输出一次 \u0026#39;called 2 times.\u0026#39;  // 这里是 effect stop 的 onStop 触发的  stop(); }; run();    undefined called 1 times. { dummy: 1 } called 2 times.   即. 如果想在 effect fn 之前或停止的时候进行清理工作，可以使用 watchEffect(effect) 的参数 effect 函数的第一个参数来注册 一个函数作为清理工作 或做其他事情。 如： watchEffect((onCleanup) =\u0026gt; { onCleanup(cleanup) ... }\n   cleanup(有 cb)   当有 cb 的时候： watch(source, cb, ...) ，将 onCleanup 注册函数从 cb 的第三个参数暴露出来\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29  // 源文件：/js/vue/lib.js const { rc: { nextTick, watch, ref }, log, } = require(process.env.BLOG_JS + \u0026#34;/vue/lib.js\u0026#34;); const run = async () =\u0026gt; { const count = ref(0); let n = 0; const cleanup = () =\u0026gt; log(`\\ncalled ${++n}times, dummy = ${dummy}`); let dummy; const stop = watch(count, (newVal, oldVal, onCleanup) =\u0026gt; { onCleanup(cleanup); dummy = newVal; }); // 这里 cleanup 尚不会执行 // 因为第一次执行是注册 cleanup 行为  count.value++; await nextTick(); // 这里会执行一次 cleanup ，因为第一次赋值时注册过了  count.value = 100; await nextTick(); // stop 时候执行一次，所以总共会执行两次 cleanup, n = 2  stop(); log({n}) }; run();    undefined called 1 times, dummy = 1 called 2 times, dummy = 100 { n: 2 }   脑图分析：\n  文字分析：\n  cleanup 注册时机分为两种情况\n  一是无 cb 的 watchEffect(fn) ，是在 getter 设置阶段封装到 getter 函数里面 注册的，此时作为 fn 的第一个参数暴露出来 fn(onCleanUp) ，\n  二是有 cb 的 watch(ref(0), cb) , 在 job 封装期间在调用 cb 的时候注册，此 时作为 cb 的第三个参数暴露出来 cb(newVal, oldVal, onCleanup)\n   两者区别 ： watchEffect 由于无 cb 会立即执行一次 runner, 此时就收集到了 cleanup， 而 watch 有 cb 时则是会在第一次值更新触发 runner 执行才开始收集 cleanup。\n   执行时机，该阶段和注册时机相辅相成，且在 cb/fn 执行之前就会被执行，因此 cb/fn 的第一次执行都属于对 cleanup 的注册\n      flush sync   feat(add): rc-\u0026gt;api watch-\u0026gt;option flush=sync · gcclll/stb-vue-next@e1436f2 · GitHub\n 支持同步代码，即所有任务立即执行（在值发生改变之后），而不是进入队列异步执行。\n 只需要增加一行代码就行：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22  // 6. TODO scheduler 设置 let scheduler: ReactiveEffectOptions[\u0026#34;scheduler\u0026#34;]; // 6.1 flush is \u0026#39;sync\u0026#39; if (flush === \u0026#34;sync\u0026#34;) { scheduler = job; // 新增 } // 6.2 TODO flush is \u0026#39;post\u0026#39; else if (false /* post */) { } // 6.3 TODO flush is \u0026#39;pre\u0026#39;(default) else { // default: \u0026#39;pre\u0026#39;  scheduler = () =\u0026gt; { if (!instance || instance.isMounted) { queuePreFlushCb(job); } else { // 带 { pre: true } 选项，第一次调用必须发生在组件 mounted 之前  // 从而使他被同步调用，立即执行一次  job(); } }; }     新增 scheduler = job 直接让任务函数赋值给调度器，这个时候如果有值发生变化，会 触发 effect\u0026gt; trigger() 在这里面会检测是不是有 option.scheduler 如果有会立即执行这 个函数。\n1 2 3 4 5 6  // reactivity/effect.ts\u0026gt;trigger() if (effect.options.scheduler) { effect.options.scheduler(effect); } else { effect(); }     测试:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  // 源文件：/js/vue/lib.js const { rc: { watch, ref }, log, } = require(process.env.BLOG_JS + \u0026#34;/vue/lib.js\u0026#34;); const run = async () =\u0026gt; { const value = ref(0); let calls = 0; watch(value, () =\u0026gt; ++calls, { flush: \u0026#34;sync\u0026#34; }); log({ calls }); // -\u0026gt; 0  value.value = 100; log({ calls }); // -\u0026gt; 1 }; run();    { calls: 0 } { calls: 1 } undefined   注意看上面的测试用例并没有用 await nextTick() ，而是同步代码执行。\n  shallow ref  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27  // 源文件：/js/vue/lib.js const { rc: { watch, shallowRef, nextTick, triggerRef }, f, log, } = require(process.env.BLOG_JS + \u0026#34;/vue/lib.js\u0026#34;); const run = async () =\u0026gt; { const v = shallowRef({ a: 1 }); // #1  let sideEffect = 0; watch(v, (obj) =\u0026gt; { // #2 cb -\u0026gt; cb(newVal, oldVal, onCleanUp)  sideEffect = obj.a; }); v.value = v.value; // #3  await nextTick(); log([\u0026#34;\\nshould not trigger: \u0026#34;, sideEffect]); // #4  v.value.a++; // #5  await nextTick(); log([\u0026#34;\\nshould not trigger: \u0026#34;, sideEffect]); // #6  triggerRef(v); // #7  await nextTick(); log([\u0026#34;\\nshould trigger now: \u0026#34;, sideEffect]); // #8 }; run();    undefined should not trigger: 0 should not trigger: 0 should trigger now: 2   ref 这一块还没深入去分析过，先暂停⏸去完成下这部分。\n  DONE [2021-01-20 15:18:37] ref 完成，可以往下继续了\n    triggerRef 作用是手动触发 ref.value 上收集的所有依赖。\n 结果分析：\n  #1 shallowRef 意味着 {a: 1} 中的属性 a 非 reactive\n  #2 watch v 基于 1 所以只是对 ref value 进行了监听，后面是值变更回调\n  #3 值没发生改变，所有 #4 输出还是 0\n  #5 由于 a 属性非 reactive 所以它没有依赖收集所以不会执行 cb，所以 #6 出 依然是 0\n  #7 这里手动调用 triggerRef(v) 等价于 trigger(v, SET, \u0026#39;value\u0026#39;) 触发 ref value 的依赖执行，此时 cb 会得到执行，sideEffect 被赋值新的 v.a 值\n 这里有一点需要注意，在 cb 里面是用的 v.a 而不是 v.value.a 因为在 watch(s,cb,option) 里面检测到如果 s 是 ref 类型，会将 getter 设置为 getter = () =\u0026gt; s.value\n 而在执行 cb 之前取新值是通过 newVal = runner() 得到的，而这个 runner = effect(getter, {...}) 所以等于是 effect(() =\u0026gt; s.value, {...})\n 所以对于 ref 类型 effect 封装的其实是 () =\u0026gt; s.value 这个函 数，那么对于 s.value 的依赖列表中就会有这个箭头函数。\n 然后在 watch 里面会将 cb 的执行封装进 job ，然后根据情况将 job 封装或直接赋值 给 scheduler ，这个会作为 effect(, { scheduler }) 的选项传递进去。\n 那么在 trigger 的时候检测到提供了 scheduler 就会调用它，所以最终调用 triggerRef(v) 会触发 cb 的调用将 obj.a~复制给 ~sideEffect ，这个 obj 就是 runner() 执行的返回值也就是 () =\u0026gt; s.value 这个函数执行的返回值。\n    TODO flush pre(default) cb   TODO flush post cb   feat(add): rc-\u0026gt;watch-\u0026gt;flush = \u0026#39;post\u0026#39; · gcclll/stb-vue-next@ec14879 · GitHub\n feat(add): rc-\u0026gt;watch-\u0026gt;cb-\u0026gt;flush = \u0026#39;post\u0026#39; · gcclll/stb-vue-next@9f3ac7d · GitHub\n 新增代码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27  // apiWatch.ts -\u0026gt; scheduler when flush=post if (flush === \u0026#34;post\u0026#34;) { scheduler = () =\u0026gt; queuePostRenderEffect(job, instance \u0026amp;\u0026amp; instance.suspense); } // renderer.ts -\u0026gt; queuePostRenderEffect // 将任务加入到 suspense.effects 或 调用 queuePostFlushCb // 加入到 pendingPostFlushCbs export const queuePostRenderEffect = __FEATURE_SUSPENSE__ ? queueEffectWithSuspense : queuePostFlushCb; // components/Suspense.ts export function queueEffectWithSuspense( fn: Function | Function[], suspense: SuspenseBoundary | null ): void { if (suspense \u0026amp;\u0026amp; suspense.pendingBranch) { if (isArray(fn)) { suspense.effects.push(...fn); } else { suspense.effects.push(fn); } } else { queuePostFlushCb(fn); } }      TODO ssr support   TODO instance watch   feat(add): rc-\u0026gt;watch-\u0026gt;instance watch · gcclll/stb-vue-next@9ec5d51 · GitHub\n1 2 3 4 5 6 7 8 9 10 11 12 13  // this.$watch export function instanceWatch( this: ComponentInternalInstance, source: string | Function, cb: WatchCallback, options?: WatchOptions ): WatchStopHandle { const publicThis = this.proxy as any const getter = isString(source) ? () =\u0026gt; publicThis[source] : source.bind(publicThis) return doWatch(getter, cb.bind(publicThis), options, this) }     将监听源，与当前实例绑定，如果是字符串转成函数。\n  🍺 小结   这一节所描述的主要是 watch/watchEffect 函数的实现和使用，用来监听数据变化做出相 应。\n watch(source, cb, option) -\u0026gt; doWatch(source, cb, option)\n watchEffect(effect, option) -\u0026gt; doWatch(source /*function*/, null, option)\n 重点回顾 watch ，因为 watchEffect 是在 source 为 function 且无 cb 时候的情况。\n 使用方法，我们可以按照 watch 函数的实现内容来逐个回顾，函数实现代码有三个重点\n 注🐖：watch 里面函数的调用(source 或 cb) 都是通过 callWithErrorHandling 去完成的， 这里其实就是个异常拦截的作用(try…catch)，防止执行报错阻碍整体页面的执行。\n   getter: 根据 source 类型封装 getter\n Ref : getter = () =\u0026gt; source.value\n Reactive: deep = true, traverse(source) 对对象所有属性触发一次 getter 操作。\n Array: 根据元素类型不同做不同处理(比如： ref/reactive/function 且只支持这 三种)\n Function: getter =\u0026gt; { …直接执行 source } 不同点在于如果有 cb 时，执行 source() ，没有时 source(onInvalidate) 这个 onInvalidate 是 watch 暴露出 去的一个清理函数它会被绑定到 cleanup 和 option.onStop 上，在 effect 被 stop 或在调用之前做的一些清理工作。\n 这个最终目的是为了对每个属性进行一次 getter 调用，用来 effect -\u0026gt; track 收集每 个属性的依赖列表(reactivity: targetMap -\u0026gt; depsMap -\u0026gt; dep)。\n  job: 根据 cb 参数封装 job(将来在值变更是触发执行的函数)\n job 的封装分为两种情况，分别是 cb 是函数或为空值时候，这里的区别也是体现在 cb 的调用上面(具体就是给 cb 的参数)。\n if(cb) 那么其调用参数会是： cb(newVal, oldVal, onCleanup/*onInvalidate*/)\n else 没有 cb 的时候会直接执行 runner() 触发更新。\n 注意到和 1 中有点类似地方了没，这里的 cb(…) 和 getter 封装阶段对 source(onInvalidate) 的调用，即不管是有 cb 还是没有 cb， onInvalidate 这个 回调总是会被暴露出去，无非是作为 cb 参数还是 function source 的参数，这使得我 们可以在每个任务执行之前和执行结束的时间点做一些事情(比如： cleanup)。\n   scheduler 的封装(根据选项类型，主要是 flush = sync|post|pre)，值变更 effect trigger 中调用的函数\n scheduler 是将 job 进一步封装，将来当值发生变化的时候 effect -\u0026gt; trigger 里面 会被调用到。\n 这个函数的值主要由 flush 选项决定，默认值是 pre ，其次有 post|sync\n post: 异步执行，会添加到异步任务队列中等待执行(pendingPostFlushCbs)\n sync: 表示为同步更新，即当值发生变化了会立即更新，详情。\n1 2 3  // 比如：ref.value = 0 ref.value++; ref.value === 1; // true, 而不用 await nextTick() 就可以取到更新后的值      pre: 默认是 pre 类型，这里区分组件是否加载完成， instance.isUnmounted 如果 加载完成，调用 queuePreFlushCb(job) 添加到 pendingPreFlushCbs[] 中等待执 行，如果组件没有加载完成需要立即执行 job() 。\n   在前面三个基本条件(getter/job/scheduler)封装完成之后，接下来是调用 effect(getter, { lazy: true, scheduler, ... }) 得到 runner() 这个 runner 是 对 getter 函数的 ReactiveEffect 封装。\n runner: 随后决定什么时机执行这个 runner() 触发 track 收集依赖，判定条件有 cb, option.immediate, option.flush=\u0026#34;post\u0026#34;\n  cb \u0026amp;\u0026amp; immediate 时候立即执行 job() 不走 runner\n  cb \u0026amp;\u0026amp; !immediate 立即执行 runner() 根据任务性质决定是同步还是异步\n  !cb \u0026amp;\u0026amp; flush===\u0026#39;post\u0026#39; 检测如果是 suspense 加入到 instance.suspense.effects 否则直接 queuePostFlushCb(runner)\n 这个需要开启 Suspense 组件支持，这个 ast render 函数其实就是在一个 async 函数里面执行的代码。\n  else 直接执行 runner()\n      🍎 api createApp  declaration  这里就两个函数\n  createAppContext 上下文创建\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18  export function createAppContext(): AppContext { return { app: null as any, config: { isNativeTag: NO, performance: false, globalProperties: {}, optionMergeStrategies: {}, isCustomElement: NO, errorHandler: undefined, warnHandler: undefined, }, mixins: [], components: {}, directives: {}, provides: Object.create(null), }; }      createAppAPI 创建 createApp 函数\n1 2 3 4 5 6  export function createAppAPI\u0026lt;HostElement\u0026gt;( render: RootRenderFunction, hydrate?: RootHydrateFunction ): CreateAppFunction\u0026lt;HostElement\u0026gt; { return function createApp(rootComponent, rootProps = null) {}; }      所以一个 App 上下文包含内容：\n   name - -     app -    config -     isNativeTag NO    performance false    globalProperties {}    optionMergeStrategies {}    isCustomElement NO    errorHandler undefined    warnHandler undefined   mixins []    components {}    directives {}    provides Object.create(null)       implementation   feat(add): createApp app apis · gcclll/stb-vue-next@1facd1b · GitHub\n  context = createAppContext() 创建上下文\n  installedPlugins = new Set() 插件列表\n  isMounted = false 加载完成标识\n  app = context.app = {...}\n  return app\n   所以重点就在 4 构造 app，其包含的 API 如下：\n   name function     get config() 获取上下文配置信息，不可更改，可以通过创建实例时的 option 改变   use(pugin, …options) 插件系统   mixin(mixin) 混合器系统   component(name, component) 组件系统   directive(name, directive) 指令系统   mount(rootContainer, isHydrate) mount 函数   unmount() -   provide(key, value) 注入系统    app.use(plugin, …options)   feat(add): createApp use plugin · gcclll/stb-vue-next@a3abcba · GitHub\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20  function use(plugin: Plugin, ...options: any[]) { if (installedPlugins.has(plugin)) { __DEV__ \u0026amp;\u0026amp; warn(`Plugin has already been applied to target app.`); } else if (plugin \u0026amp;\u0026amp; isFunction(plugin.install)) { // 函数直接执行  installedPlugins.add(plugin); plugin.install(app, ...options); } else if (isFunction(plugin)) { // 没有 install 函数时  installedPlugins.add(plugin); plugin(app, ...options); } else if (__DEV__) { // plugin 必须要么自己是函数，要么是包含 install 函数的对象  warn( `A plugin must either be a function or an object with an \u0026#34;install\u0026#34; ` + `function.` ); } return app; }     所以插件 plugin 必须要么自己是函数。\n  app.mixin(mixin)   feat(add): createApp mixin api · gcclll/stb-vue-next@b96afcf · GitHub\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21  function mixin(mixin: ComponentOptions) { if (__FEATURE_OPTIONS_API__) { if (!context.mixins.includes(mixin)) { context.mixins.push(mixin); // 带有 props/emits 的全局 mixin 会是的 props/emits 缓存优化失效  if (mixin.props || mixin.emits) { context.deopt = true; } } else if (__DEV__) { warn( \u0026#34;Mixin has already been applied to target app\u0026#34; + (mixin.name ? `: ${mixin.name}` : \u0026#34;\u0026#34;) ); } } else if (__DEV__) { // 必须开启了 options api 特性才能使用，即 vue3 里面可根据需要  // 关闭这个功能  warn(\u0026#34;Mixins are only available in builds supporting Options API\u0026#34;); } return app; }     可根据需要在打包的时候由 __FEATURE_OPTIONS_API__ 决定是否继续支持 mixin 功能。\n  app.component(name, component)   feat(add): createApp component api · gcclll/stb-vue-next@9b2579d · GitHub\n 内置标签： slot,component\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19  function component(name: string, component?: Component): any { if (__DEV__) { // 验证组件名称是否合法  validateComponentName(name, context.config); } // 没有对应组件，视为根据名称获取组件操作  if (!component) { return context.components[name]; } if (__DEV__ \u0026amp;\u0026amp; context.components[name]) { // 组件已经注册过了，再次注册等于覆盖原有的  warn(`Component \u0026#34;${name}\u0026#34; has already been registered in target app.`); } context.components[name] = component; return app; }      验证组件名，不能用内置(isBuiltInTag())或自定义(isCustomElement())的标签作为组件名\n  没有 component 参数的时候视为根据 name 去获取组件\n  当 name - component 存在时属于覆盖操作，给出警告\n    app.directive(name, directive)   feat(add): createApp directive api · gcclll/stb-vue-next@ec1a20e · GitHub\n 内置指令集： bind,cloak,else-if,else,for,html,if,model,on,once,pre,show,slot,text\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  function directive(name: string, directive?: Directive) { if (__DEV__) { validateDirectiveName(name); } if (!directive) { return context.directives[name] as any; } if (__DEV__ \u0026amp;\u0026amp; context.directives[name]) { warn(`Directive \u0026#34;${name}\u0026#34; has already been registered in target app.`); } context.directives[name] = directive; return app; }      app.mount(rootContainer, isHydrate)  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41  function mount(rootContainer: HostElement, isHydrate?: boolean): any { // TODO  if (!isMounted) { const vnode = createVNode(rootComponent as ConcreteComponent, rootProps); // 保存 app context 到 root VNode 节点上  // 这个将会在初始化 mount 时候被设置到根实例上  vnode.appContext = context; // HMR root reload  if (__DEV__) { context.reload = () =\u0026gt; { render(cloneVNode(vnode), rootContainer); }; } if (isHydrate \u0026amp;\u0026amp; hydrate) { hydrate(vnode as VNode\u0026lt;Node, Element\u0026gt;, rootContainer as any); } else { render(vnode, rootContainer); } isMounted = true; app._container = rootContainer; // for devtools and telemetry  (rootContainer as any).__vue_app__ = app; if (__DEV__ || __FEATURE_PROD_DEVTOOLS__) { devtoolsInitApp(app, version); } return vnode.component!.proxy; } else if (__DEV__) { warn( `App has already been mounted.\\n` + `If you want to remount the same app, move your app creation logic ` + `into a factory function and create fresh app instances for each ` + `mount - e.g. \\`const createMyApp = () =\u0026gt; createApp(App)\\`` ); } }      vnode = createVNode(rootComponent, rootProps) 创建虚拟节点\n  vnode.appContext = context 保存上下文到虚拟节点上，组件初始化时使用\n  context.reload = () =\u0026gt; render(cloneVNode(vnode), rootContainer) HMR 开发时 有变更的热加载\n  rootContainer.__vue_app__ = app\n  devtool 开发工具相关\n  返回 vnode.component.proxy 这个是干啥的？\n   最后，如果 app 已经被加载了不能重复 mount。如果需要对一个app做重复 mount，可能的 需求是存在同时创建多个 app 情况？\n 那么这个时候应该使用函数方式使用，如：\n myCreateApp = (...) =\u0026gt; createApp(App)\n  app.unmount()   feat(add): createApp unmount api · gcclll/stb-vue-next@63354d3 · GitHub\n1 2 3 4 5 6 7 8 9 10  function unmount() { if (isMounted) { render(null, app._container); if (__DEV__ || __FEATURE_PROD_DEVTOOLS__) { devtoolsUnmountApp(app); } } else { warn(`Cannot unmount an app that is not mounted.`); } }     render(null, ...) ?\n  app.provide(key, value)   feat(add): createApp provide api · gcclll/stb-vue-next@18fb22b · GitHub\n1 2 3 4 5 6 7 8 9 10 11 12 13 14  function provide(key, value) { if (__DEV__ \u0026amp;\u0026amp; (key as string | symbol) in context.provides) { warn( `App already provides property with key \u0026#34;${String(key)}\u0026#34;. ` + `It will be overwritten with the new value.` ); } // TypeScript doesn\u0026#39;t allow symbols as index type  // https://github.com/Microsoft/TypeScript/issues/24587  context.provides[key as string] = value; return app; }     就是简单的给 context.provides 设置操作。\n   做什么的呢？\n       test   这里目前只能测试 mount 和 unmount 其他的 api(provide/…) 需要等它们被实现了才能 继续测试。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45  // 源文件：/js/vue/lib.js const { rcTest: { defineComponent, nodeOps, createApp, serializeInner }, f, log, } = require(process.env.BLOG_JS + \u0026#34;/vue/lib.js\u0026#34;); const Comp = defineComponent({ props: { count: { default: 0, }, }, setup(props) { return () =\u0026gt; props.count; }, }); const root1 = nodeOps.createElement(\u0026#34;div\u0026#34;); createApp(Comp).mount(root1); let si = serializeInner(root1); log(\u0026#34;root1 serialize, \u0026#34; + si); // mount with props const root2 = nodeOps.createElement(\u0026#34;div\u0026#34;); const app2 = createApp(Comp, { count: 1 }); app2.mount(root2); si = serializeInner(root2); log(\u0026#34;root2 serialize, \u0026#34; + si); // unmount const root3 = nodeOps.createElement(\u0026#34;div\u0026#34;); const app3 = createApp(Comp, { foo: 1 }); // 在 mount 之前卸载 try { app3.unmount(root3); // warnning } catch (e) { log(\u0026#34;unmount failed.\u0026#34;); } app3.mount(root3); app3.unmount(root3); si = serializeInner(root3); log(\u0026#34;root3 serialize, \u0026#34; + si);    root1 serialize, 0 root2 serialize, 1 root3 serialize, undefined      ⛏ api provide \u0026amp; inject   feat(add): provide \u0026amp; inject api · gcclll/stb-vue-next@b4a1cbc · GitHub\n 作用： 在父组件中 provide(key,value) 向子组件传值， inject(key) 在子组件中可以取到该值。\n1 2 3 4 5 6 7 8 9 10 11  export function provide\u0026lt;T\u0026gt;(key: InjectionKey\u0026lt;T\u0026gt; | string | number, value: T) { // TODO } export function inject( key: InjectionKey\u0026lt;any\u0026gt; | string, defaultValue?: unknown, treatDefaultAsFactory = false ) { // TODO }     涉及内容\n  provides 继承 parent provides，需要自己的就创建新对象继承自 parent provides， 所以查找 injections 可以在原型链查找。\n  inject(key, defaultValue, treatDefaultAsFactory = false) 你只是个简单的取值 操作 (provides[key])？😭？😭？\n   Imp. provide 和 inject 只能在 setup() 或函数式组件中使用，它们的作用是根据原 型链特性实现从父组件向子组件传递一些值。\n  provide(key, value)   feat(add): provide \u0026amp; inject provide implementation · gcclll/stb-vue-next@42f3d05 · GitHub\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27  export function provide\u0026lt;T\u0026gt;(key: InjectionKey\u0026lt;T\u0026gt; | string | number, value: T) { if (!currentInstance) { if (__DEV__) { warn(`provide() can only be used inside setup().`); } } else { let provides = currentInstance.provides; // 默认情况实例会继承它父亲的 provides 对象  // 但是当它需要 provide 自己的 values 时候，那么使用它  // 父亲的 provides 作为原型创建一个新的对象出来变成自己的 provides  // 这样在 `inject` 里面可以简便的从原型链中查找 injections  // 简单说就是：  // 1. 需要自己的就创建个新的对象继承自 Parent provides  // 2. 这样在查找的时候就可以含方便的通过原型链查找 injections  const parentProvides = currentInstance.parent \u0026amp;\u0026amp; currentInstance.parent.provides; // 当父组件和当前实例相同的时候，从父组件的 provides 创建一个备份出来  if (parentProvides === provides) { provides = currentInstance.provides = Object.create(parentProvides); } // TS doesn\u0026#39;t allow symbol as index type  provides[key as string] = value; } }     Object.create(parentProvides) 创新新的对象来容纳新的 key-value\n   inject(key, defaultValue, treatDefaultAsFactory = false)  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27  export function inject(defaultValue?: unknown, treatDefaultAsFactory = false) { // TODO  // currentRenderingInstance 兼容函数式组件  const instance = currentInstance || currentRenderingInstance; if (instance) { // #2400  // to support `app.use` plugins,  // fallback to appContext\u0026#39;s `provides` if the intance is at root  const provides = instance.parent == null // root  ? instance.vnode.appContext \u0026amp;\u0026amp; instance.vnode.appContext.provides : instance.parent.provides; if (provides \u0026amp;\u0026amp; (key as string | symbol) in provides) { // TS doesn\u0026#39;t allow symbol as index type  return provides[key as string]; } else if (arguments.length \u0026gt; 1) { return treatDefaultAsFactory \u0026amp;\u0026amp; isFunction(defaultValue) ? defaultValue() : defaultValue; } else if (__DEV__) { warn(`injection \u0026#34;${String(key)}\u0026#34; not found.`); } } else if (__DEV__) { warn(`inject() can only be used inside setup() or functional components.`); } }     inject 就是个简单的取值操作而已。\n 取值来源需要检测是不是根节点，如果是根节点\n provides = instance.vnode.appContext.provides\n 否则，使用 instance.parent.provides\n 然后根据 key 取出值 provides[key]\n 如果有默认值需要返回默认值?\n defaultValue 或 defaultValue()\n 居然如此简单~~~，还是先看下怎么用吧！！！\n  test  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57  // 源文件：/js/vue/lib.js const { rcTest: { provide, inject, h, nodeOps, render, serialize, ref, nextTick }, f, log, } = require(process.env.BLOG_JS + \u0026#34;/vue/lib.js\u0026#34;); const run = async () =\u0026gt; { const skey = Symbol(); const count = ref(1); const Provider = { setup() { provide(\u0026#34;foo\u0026#34;, \u0026#34;foo-p1\u0026#34;); // 支持符号属性名  provide(skey, 2); // 可以是其他类型 ref, reactive, ...  provide(\u0026#34;count\u0026#34;, count); return () =\u0026gt; h(Provider2); }, }; const Provider2 = { setup() { provide(\u0026#34;foo\u0026#34;, \u0026#34;foo-p2\u0026#34;); provide(\u0026#34;baz\u0026#34;, \u0026#34;baz\u0026#34;); return () =\u0026gt; h(Middle); }, }; const Middle = { render: () =\u0026gt; h(Consumer), }; const Consumer = { setup() { const symb = inject(skey); // 这里 foo 拿到的会是 Provider2 的 foo 值  // 因为 provides 原型链是基于组件父子关系来创建的  const foo = inject(\u0026#34;foo\u0026#34;); // 默认值  const bar = inject(\u0026#34;bar\u0026#34;, \u0026#34;bar\u0026#34;); // 因为是简单的赋值操作，所以这里的 count 就是 ref(1) 返回的那个 count  const count = inject(\u0026#34;count\u0026#34;); return () =\u0026gt; [symb, foo, bar, count.value].join(\u0026#34;,\u0026#34;); }, }; const root = nodeOps.createElement(\u0026#34;div\u0026#34;); render(h(Provider), root); let s = serialize(root); log(\u0026#34;1. root serialize, \u0026#34; + s); count.value++; await nextTick(); s = serialize(root); log(\u0026#34;2. root serialize, \u0026#34; + s); }; run();    1. root serialize, \u0026lt;div\u0026gt;2,foo-p2,bar,1\u0026lt;/div\u0026gt; undefined2. root serialize, \u0026lt;div\u0026gt;2,foo-p2,bar,2\u0026lt;/div\u0026gt;   组件层级关系(父-\u0026gt;子)： Provider -\u0026gt; Middle -\u0026gt; Consumer\n 在 provide(\u0026#39;foo\u0026#39;, 1) 则在 Provider 组件的 provides 中增加了 { foo: 1 } ,由于 子组件的 provides 是沿用或继承了父级的 provides。\n 所以在子组件 Consumer 中直接调用 inject(\u0026#39;foo\u0026#39;) 是在 instance.provides 里面去 找这个属性对应的值，如果没找到则一直在原型链上往上找，最后找到顶级父组件 Provider 上找到包含 \u0026#39;foo\u0026#39; 属性，则返回这个值。\n 所以， inject\u0026amp;provide 的应用其实就是原型链的应用，目的是为了让父组件可以像子组 件注入一些值。\n   那么为什么注入的值直接变成了 \u0026lt;div\u0026gt;1\u0026lt;/div\u0026gt; 子节点了？\n       ✨ api computed   这个 api 是对 reactivity\u0026gt;computed 的一次简单封装，详情请直接查看 reactivity对应的 computed 一节。\n 代码：\n1 2 3 4 5 6 7 8 9 10 11  export function computed\u0026lt;T\u0026gt;(getter: ComputedGetter\u0026lt;T\u0026gt;): ComputedRef\u0026lt;T\u0026gt; export function computed\u0026lt;T\u0026gt;( options: WritableComputedOptions\u0026lt;T\u0026gt; ): WritableComputedRef\u0026lt;T\u0026gt; export function computed\u0026lt;T\u0026gt;( getterOrOptions: ComputedGetter\u0026lt;T\u0026gt; | WritableComputedOptions\u0026lt;T\u0026gt; ) { const c = _computed(getterOrOptions as any) recordInstanceBoundEffect(c.effect) return c }      🌀 api lifecycle   feat(add): api lifecycle init · gcclll/stb-vue-next@071d868 · GitHub\n feat(add): api lifecycle exports · gcclll/stb-vue-next@ee88856 · GitHub 组件声明周期 api 。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21  export function injectHook( type: LifecycleHooks, hook: Function \u0026amp; { __weh?: Function }, target: ComponentInternalInstance | null = currentInstance, prepend: boolean = false ): Function | undefined { // TODO  return } export const createHook = \u0026lt;T extends Function = () =\u0026gt; any\u0026gt;( lifecycle: LifecycleHooks ) =\u0026gt; (hook: T, target: ComponentInternalInstance | null = currentInstance) =\u0026gt; !isInSSRComponentSetup \u0026amp;\u0026amp; injectHook(lifecycle, hook, target) export const onBeforeMount = createHook(LifecycleHooks.BEFORE_MOUNT) export const onMounted = createHook(LifecycleHooks.MOUNTED) export const onBeforeUpdate = createHook(LifecycleHooks.BEFORE_UPDATE) export const onUpdated = createHook(LifecycleHooks.UPDATED) export const onUnMount = createHook(LifecycleHooks.UNMOUNTED)     如上，所有的声明周期函数都是通过 createHook -\u0026gt; injectHook 实现，所以这部分的重点 就是这个 injectHook(type, hook, targt, prepend) 。\n 在 createHook() 里面有检测是不是 SSR 环境，只有非 SSR 环境下才会有声明周期。\n feat(add): api lifecycle injectHook · gcclll/stb-vue-next@6e9cd14 · GitHub\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37  export function injectHook( type: LifecycleHooks, hook: Function \u0026amp; { __weh?: Function }, target: ComponentInternalInstance | null = currentInstance, prepend: boolean = false ): Function | undefined { if (target) { const hooks = target[type] || (target[type] = []); // 将 hook 的执行封装成一个 error handling warpper 函数，并且缓存到 hook.__weh  // 上，这样在调度器里面调用的时候可以进行去重，因为 scheduler 里面执行的时候  // 有去重操作，这里的 __weh = \u0026#39;with error handling\u0026#39;  const wrappedHook = hook.__weh || (hook.__weh = (...args: unknown[]) =\u0026gt; { if (target.isUnmounted) { return; } // 在所有的声明周期函数中都 disable tracking  // 因为它们有可能在 effects 中被调用  pauseTracking(); // 在 hook 执行期间设置 currentInstance = targt  // 假设 hook 没有同步地触发其他 hooks，即在一个 hook 里面同步调用  // 另一个声明周期函数？  setCurrentInstance(target); const res = callWithAsyncErrorHandling(hook, target, type, args); setCurrentInstance(null); resetTracking(); return res; }); prepend ? hooks.unshift(wrappedHook) : hooks.push(wrappedHook); return wrappedHook; } else if (__DEV__) { // ...  } return; }      lifecycle hook 可以在 setup() 中执行\n  这里的所有声明周期函数都以事件形式存在，意味着可以通过这些 api 注册哪个声明周 期需要执行操作的函数\n  在声明周期函数执行期间不进行 track 收集依赖操作，它有可能在 setup() 中进行\n   使用原理：调用 onXxx(fn, ins) 声明周期函数时，实际上只是向当前的实例 currentInstane[type] = [] 上注册了一个回调函数 fn。比如：\n target.onMounted = [fn1, fn2] // target -\u0026gt; currentInstance 当前实例\n 然后在组件 render/update 过程中根据声明周期的阶段调用对应的 fns 。\n test base  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50  // 源文件：/js/vue/lib.js const { rcTest: { render, nodeOps, onBeforeMount, h, serializeInner, onMounted, onBeforeUpdate, onUpdated, onBeforeUnmount, onBeforeUnmounted, ref, nextTick, }, f, log, } = require(process.env.BLOG_JS + \u0026#34;/vue/lib.js\u0026#34;); const root = nodeOps.createElement(\u0026#34;div\u0026#34;); let called = 0; const s = () =\u0026gt; serializeInner(root); const fn = (stage) =\u0026gt; { called++; log(`\\n-\u0026gt; ${stage}, called = ${called}, serialize root = \u0026#34;${s()}\u0026#34; }`); // count.value++ }; const count = ref(0); const run = async () =\u0026gt; { const Comp = { setup() { // 这里故意将 onMounted 放在前面  // 结果会发现这个还是最后才执行  onMounted(() =\u0026gt; fn(\u0026#34;onMounted\u0026#34;)); onBeforeMount(() =\u0026gt; fn(\u0026#34;onBeforeMount\u0026#34;)); onBeforeUpdate(() =\u0026gt; fn(\u0026#34;onBeforeUpdate\u0026#34;)); onUpdated(() =\u0026gt; fn(\u0026#34;onUpdated\u0026#34;)); return () =\u0026gt; h(\u0026#34;div\u0026#34;, count.value); }, }; render(h(Comp), root); count.value++; await nextTick(); log(\u0026#34;after set value...\u0026#34;); log(s()); }; run();    -\u0026gt; onBeforeMount, called = 1, serialize root = \u0026#34;\u0026#34; } -\u0026gt; onMounted, called = 2, serialize root = \u0026#34;\u0026lt;div\u0026gt;0\u0026lt;/div\u0026gt;\u0026#34; } undefined -\u0026gt; onBeforeUpdate, called = 3, serialize root = \u0026#34;\u0026lt;div\u0026gt;0\u0026lt;/div\u0026gt;\u0026#34; } -\u0026gt; onUpdated, called = 4, serialize root = \u0026#34;\u0026lt;div\u0026gt;1\u0026lt;/div\u0026gt;\u0026#34; } after set value... \u0026lt;div\u0026gt;1\u0026lt;/div\u0026gt;    test update   测试在 onBeforeUpdate 中执行值更新操作会怎样？\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43  // 源文件：/js/vue/lib.js const { rcTest: { render, nodeOps, onBeforeMount, h, serializeInner, onBeforeUpdate, onUpdated, ref, nextTick, }, f, log, } = require(process.env.BLOG_JS + \u0026#34;/vue/lib.js\u0026#34;); const root = nodeOps.createElement(\u0026#34;div\u0026#34;); let called = 0; const s = () =\u0026gt; serializeInner(root); const fn = (stage) =\u0026gt; { called++; log(`\\n-\u0026gt; ${stage}, called = ${called}, serialize root = \u0026#34;${s()}\u0026#34; }`); count.value++ }; const count = ref(0); const run = async () =\u0026gt; { const Comp = { setup() { onUpdated(() =\u0026gt; log(\u0026#39;-\u0026gt; onUpdated, count.value = \u0026#39; + count.value + \u0026#39;, \u0026#39; + s())) onBeforeUpdate(() =\u0026gt; fn(\u0026#34;onBeforeUpdate\u0026#34;)); return () =\u0026gt; h(\u0026#34;div\u0026#34;, count.value); }, }; render(h(Comp), root); count.value++; await nextTick(); log(\u0026#34;after set value...\u0026#34;); log(s()); }; run();    undefined -\u0026gt; onBeforeUpdate, called = 1, serialize root = \u0026#34;\u0026lt;div\u0026gt;0\u0026lt;/div\u0026gt;\u0026#34; } -\u0026gt; onUpdated, count.value = 2, \u0026lt;div\u0026gt;2\u0026lt;/div\u0026gt; after set value... \u0026lt;div\u0026gt;2\u0026lt;/div\u0026gt;     最后 count.value 渲染出来是 2？\n     test unmount  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54  // 源文件：/js/vue/lib.js const { rcTest: { render, nodeOps, onBeforeMount, h, serializeInner, onBeforeUpdate, onUpdated, onBeforeUnmount, onUnmounted, onMounted, ref, nextTick, }, f, log, } = require(process.env.BLOG_JS + \u0026#34;/vue/lib.js\u0026#34;); const root = nodeOps.createElement(\u0026#34;div\u0026#34;); let called = 0; const s = () =\u0026gt; serializeInner(root); const fn = (stage) =\u0026gt; { called++; log(`\\n-\u0026gt; ${stage}, called = ${called}, serialize root = \u0026#34;${s()}\u0026#34; }`); }; const toggle = ref(true); const run = async () =\u0026gt; { const Comp = { setup() { return () =\u0026gt; (toggle.value ? h(Child) : null); }, }; const Child = { setup() { onBeforeUnmount(() =\u0026gt; fn(\u0026#34;onBeforeUnmount\u0026#34;)); onUnmounted(() =\u0026gt; fn(\u0026#34;onUnmounted\u0026#34;)); onMounted(() =\u0026gt; { // 这等于是等组件加载完成之后在注册 unmount  onBeforeUnmount(() =\u0026gt; log(\u0026#34;-\u0026gt; onBeforeUnmount called in onMounted\u0026#34;)); }); return () =\u0026gt; h(\u0026#34;div\u0026#34;); }, }; render(h(Comp), root); toggle.value = false; await nextTick(); log(\u0026#34;\\nafter set value...\u0026#34;); log(s()); }; run();    undefined -\u0026gt; onBeforeUnmount, called = 1, serialize root = \u0026#34;\u0026lt;div\u0026gt;\u0026lt;/div\u0026gt;\u0026#34; } -\u0026gt; onBeforeUnmount called in onMounted -\u0026gt; onUnmounted, called = 2, serialize root = \u0026#34;\u0026lt;!----\u0026gt;\u0026#34; } after set value... \u0026lt;!----\u0026gt;    test order   测试声明周期函数执行顺序(和调用顺序无关)\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78  // 源文件：/js/vue/lib.js const { rcTest: { render, nodeOps, h, serializeInner, onBeforeMount, onMounted, onBeforeUpdate, onUpdated, onBeforeUnmount, onUnmounted, ref, nextTick, }, f, log, } = require(process.env.BLOG_JS + \u0026#34;/vue/lib.js\u0026#34;); const root = nodeOps.createElement(\u0026#34;div\u0026#34;); let calls = []; const count = ref(0); const run = async () =\u0026gt; { const Root = { setup() { onBeforeMount(() =\u0026gt; calls.push(\u0026#39;root onBeforeMount\u0026#39;)) onMounted(() =\u0026gt; calls.push(\u0026#39;root onMounted\u0026#39;)) onBeforeUpdate(() =\u0026gt; calls.push(\u0026#39;root onBeforeUpdate\u0026#39;)) onUpdated(() =\u0026gt; calls.push(\u0026#39;root onUpdated\u0026#39;)) onBeforeUnmount(() =\u0026gt; calls.push(\u0026#39;root onBeforeUnmount\u0026#39;)) onUnmounted(() =\u0026gt; calls.push(\u0026#39;root onUnmounted\u0026#39;)) return () =\u0026gt; h(Mid, { count: count.value }); }, }; const Mid = { setup(props) { onBeforeMount(() =\u0026gt; calls.push(\u0026#39;Mid onBeforeMount\u0026#39;)) onMounted(() =\u0026gt; calls.push(\u0026#39;Mid onMounted\u0026#39;)) onBeforeUpdate(() =\u0026gt; calls.push(\u0026#39;Mid onBeforeUpdate\u0026#39;)) onUpdated(() =\u0026gt; calls.push(\u0026#39;Mid onUpdated\u0026#39;)) onBeforeUnmount(() =\u0026gt; calls.push(\u0026#39;Mid onBeforeUnmount\u0026#39;)) onUnmounted(() =\u0026gt; calls.push(\u0026#39;Mid onUnmounted\u0026#39;)) return () =\u0026gt; h(Child, { count: props.count }); }, }; const Child = { setup(props) { onBeforeMount(() =\u0026gt; calls.push(\u0026#39;Child onBeforeMount\u0026#39;)) onMounted(() =\u0026gt; calls.push(\u0026#39;Child onMounted\u0026#39;)) onBeforeUpdate(() =\u0026gt; calls.push(\u0026#39;Child onBeforeUpdate\u0026#39;)) onUpdated(() =\u0026gt; calls.push(\u0026#39;Child onUpdated\u0026#39;)) onBeforeUnmount(() =\u0026gt; calls.push(\u0026#39;Child onBeforeUnmount\u0026#39;)) onUnmounted(() =\u0026gt; calls.push(\u0026#39;Child onUnmounted\u0026#39;)) return () =\u0026gt; h(\u0026#39;div\u0026#39;, props.count); }, }; render(h(Root), root) log([\u0026#39;\\n0. before update value \u0026gt;\u0026#39;, calls]) calls.length = 0 // update  count.value++ await nextTick() log([\u0026#39;\\n1. update value \u0026gt;\u0026#39;, calls]) calls.length = 0 // unmount  render(null, root) log([\u0026#39;\\n2. unmount \u0026gt;\u0026#39;, calls]) calls.length = 0 }; run();    0. before update value \u0026gt; [ \u0026#39;root onBeforeMount\u0026#39;, \u0026#39;Mid onBeforeMount\u0026#39;, \u0026#39;Child onBeforeMount\u0026#39;, \u0026#39;Child onMounted\u0026#39;, \u0026#39;Mid onMounted\u0026#39;, \u0026#39;root onMounted\u0026#39; ] undefined 1. update value \u0026gt; [ \u0026#39;root onBeforeUpdate\u0026#39;, \u0026#39;Mid onBeforeUpdate\u0026#39;, \u0026#39;Child onBeforeUpdate\u0026#39;, \u0026#39;Child onUpdated\u0026#39;, \u0026#39;Mid onUpdated\u0026#39;, \u0026#39;root onUpdated\u0026#39; ] 2. unmount \u0026gt; [ \u0026#39;root onBeforeUnmount\u0026#39;, \u0026#39;Mid onBeforeUnmount\u0026#39;, \u0026#39;Child onBeforeUnmount\u0026#39;, \u0026#39;Child onUnmounted\u0026#39;, \u0026#39;Mid onUnmounted\u0026#39;, \u0026#39;root onUnmounted\u0026#39; ]   从上面的结果可知整个组件声明周期发生过程。\n  组件 mount 顺序， child -\u0026gt; mid -\u0026gt; comp，子组件 -\u0026gt; … -\u0026gt; 父组件\n  组件 update 顺序， child -\u0026gt; mid -\u0026gt; comp, 子组件 -\u0026gt; … -\u0026gt; 父组件\n  组件 unmount 顺序， child -\u0026gt; mid -\u0026gt; comp, 子组件 -\u0026gt; … -\u0026gt; 父组件\n  组件的 before 声明周期触发顺序是： child -\u0026gt; mid -\u0026gt; comp 完成之后的顺序刚好相反。\n  test render track \u0026amp; trigger  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51  // 源文件：/js/vue/lib.js const { rcTest: { render, nodeOps, h, serializeInner, ref, nextTick, reactive, onRenderTracked, onRenderTriggered }, f, log, } = require(process.env.BLOG_JS + \u0026#34;/vue/lib.js\u0026#34;); const run = () =\u0026gt; { const events = []; let called = 0; const fn = (e) =\u0026gt; { called++; events.push(e); }; const obj = reactive({ foo: 1, bar: 2 }); const Comp = { setup() { onRenderTriggered(fn) onRenderTracked(fn); return () =\u0026gt; h(\u0026#34;div\u0026#34;, [obj.foo, \u0026#34;bar\u0026#34; in obj, Object.keys(obj).join(\u0026#34;\u0026#34;)]); }, }; render(h(Comp), nodeOps.createElement(\u0026#39;div\u0026#39;)) log(\u0026#39;called = \u0026#39; + called) // 3  log(\u0026#39;\u0026gt;\u0026gt; track events\u0026#39;) events.forEach(e =\u0026gt; log(f(e, [\u0026#39;target\u0026#39;, \u0026#39;type\u0026#39;, \u0026#39;key\u0026#39;]))) events.length = 0 log(\u0026#39;\u0026gt;\u0026gt; trigger events\u0026#39;) obj.foo++ events.forEach(e =\u0026gt; log(f(e, [\u0026#39;target\u0026#39;, \u0026#39;type\u0026#39;, \u0026#39;key\u0026#39;]))) events.length = 0 delete obj.bar events.forEach(e =\u0026gt; log(f(e, [\u0026#39;target\u0026#39;, \u0026#39;type\u0026#39;, \u0026#39;key\u0026#39;]))) events.length = 0 obj.baz = 3 events.forEach(e =\u0026gt; log(f(e, [\u0026#39;target\u0026#39;, \u0026#39;type\u0026#39;, \u0026#39;key\u0026#39;]))) events.length = 0 }; run();    called = 3 \u0026gt;\u0026gt; track events { target: { foo: 1, bar: 2 }, type: \u0026#39;get\u0026#39;, key: \u0026#39;foo\u0026#39; } { target: { foo: 1, bar: 2 }, type: \u0026#39;has\u0026#39;, key: \u0026#39;bar\u0026#39; } { target: { foo: 1, bar: 2 }, type: \u0026#39;iterate\u0026#39;, key: Symbol(iterate) } \u0026gt;\u0026gt; trigger events { target: { foo: 2, bar: 2 }, key: \u0026#39;foo\u0026#39;, type: \u0026#39;set\u0026#39; } { target: { foo: 2 }, key: \u0026#39;bar\u0026#39;, type: \u0026#39;delete\u0026#39; } { target: { foo: 2, baz: 3 }, key: \u0026#39;baz\u0026#39;, type: \u0026#39;add\u0026#39; } undefined      🦉 api define component  1 2 3 4  // implementation, close to no-op export function defineComponent(options: unknown) { return isFunction(options) ? { setup: options, name: options.name } : options }      🆘 api setup helpers   feat(add): api setup helpers · gcclll/stb-vue-next@3e71787 · GitHub\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31  // runtime-core/src/apiSetupHelpers.ts // implementation export function defineProps() { if (__DEV__) { warn( `defineProps() is a compiler-hint helper that is only usable inside ` + `\u0026lt;script setup\u0026gt; of a single file component. Its arguments should be ` + `compiled away and passing it at runtime has no effect.` ); } return null as any; } export function defineEmit() { if (__DEV__) { warn( `defineEmit() is a compiler-hint helper that is only usable inside ` + `\u0026lt;script setup\u0026gt; of a single file component. Its arguments should be ` + `compiled away and passing it at runtime has no effect.` ); } return null as any; } export function useContext(): SetupContext { const i = getCurrentInstance()!; if (__DEV__ \u0026amp;\u0026amp; !i) { warn(`useContext() called without active instance.`); } return i.setupContext || (i.setupContext = createSetupContext()); }     这里包含三个函数，其中 defineProps\u0026amp;defineEmit 都是且只会在 \u0026lt;script setup\u0026gt; 里 面使用，他们的作用只是用于 compiler-sfc 包中在 babel/parser 解析语法树期间， 用来标识他们是 props或 emits 的一部分，然后给他们的参数会被当做 props 和 emits 合并到最终 export 出去的对应属性上，所以这两个 define 函数实际上什么都没做。\n 看实例吧 -\u0026gt;\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22  // 源文件：/js/vue/lib.js const { compile, f, log } = require(process.env.BLOG_JS + \u0026#39;/vue/lib.js\u0026#39;) const { content } = compile(` \u0026lt;script setup\u0026gt; import { defineProps, defineEmit } from \u0026#39;vue\u0026#39; ref: value = 1 const myEmit = defineEmit([\u0026#39;foo\u0026#39;, \u0026#39;bar\u0026#39;]) const props = defineProps({ fox: String, foy: () =\u0026gt; baz \u0026gt; 1 }) \u0026lt;/script\u0026gt; \u0026lt;script\u0026gt; export default { props: { box: 2 } } \u0026lt;/script\u0026gt; `) log(content)    import { ref as _ref } from \u0026#39;vue\u0026#39; function setup(__props, { emit: myEmit }) { const props = __props const value = _ref(1) return { value, myEmit, props } } const __default__ = { props: { box: 2 } } export default /*#__PURE__*/ Object.assign(__default__, { expose: [], props: { fox: String, foy: () =\u0026gt; baz \u0026gt; 1 }, emits: [\u0026#39;foo\u0026#39;, \u0026#39;bar\u0026#39;], setup }) undefined   我们把上面结果格式化下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24  import { ref as _ref } from \u0026#34;vue\u0026#34;; function setup(__props, { emit: myEmit }) { const props = __props; const value = _ref(1); return { value, myEmit, props }; } const __default__ = { props: { box: 2, }, }; export default /*#__PURE__*/ Object.assign(__default__, { expose: [], props: { fox: String, foy: () =\u0026gt; baz \u0026gt; 1, }, emits: [\u0026#34;foo\u0026#34;, \u0026#34;bar\u0026#34;], setup, });     从上面的代码可发现：\n  defineProps 最后被合并成一个 props 对象，并且会和 \u0026lt;script\u0026gt; 中的 export default 中的 props 进行再次合并，并且这种合并属于简单的替换操作\n 所以如果 defineProps 和 script 中同时存在 props 的情况最终 \u0026lt;script\u0026gt; 中 的 props 会被丢弃掉，所以尽量避免这种情况发生。\n  defineEmit 中的属性会被合并到 emits 上\n  更多有关 \u0026lt;script setup\u0026gt; 的内容请查看 compiler-sfc 包的分析 -\u0026gt;\n useContext() 是获取当前实例的上下文对象，这个需要继续实现复杂的 render 部分才 可能会使用到。\n   🌊 TODO api async comopnent   feat(add): async component · gcclll/stb-vue-next@cb4474a · GitHub\n 定义异步组件(defineAsyncComponent(source))。\n 新增初始化：\n1 2 3 4 5 6 7 8 9 10 11 12 13  export const isAsyncWrapper = (i: ComponentInternalInstance | VNode) =\u0026gt; !!(i.type as ComponentOptions).__asyncLoader; export function defineAsyncComponent\u0026lt; T extends Component = { new (): ComponentPublicInstance } \u0026gt;(source: AsyncComponentLoader\u0026lt;T\u0026gt; | AsyncComponentOptions\u0026lt;T\u0026gt;): T { // 1. TODO retry 封装  //  // 2. TODO 函数封装  //  // 3. TODO 返回组件，检测如果是对象直接返回，or 函数当做 setup() 函数处理  return defineComponent({} as any) as any; }     通过搜索 __asyncLoader 只在 hydration.ts 中有使用到，而这个貌似又和 SSR 服务 端渲染由关系，所以这里先暂时不继续了，先完成 renderer.ts 的 render 函数部分，然 后在实现了 SSR + hydration 之后再回头来继续。\n implementation(init)   feat(add): async component-\u0026gt;load · gcclll/stb-vue-next@bd6e903 · GitHub\n feat: async component pause await render · gcclll/stb-vue-next@1c73e72 · GitHub 实现主要分几步：\n  封装 retry() 重试函数\n  load() 函数，分支 source.loader() 异步函数\n  组装组件返回 defineComponent({__asyncLoader: load, setup() {...}, ...})\n 前面 1, 2 都是对 source.loader 进行封装处理，这一步是真正的创建异步组件。\n defineComponent(option) 实现很简单，就是检测 option 如果是函数当做\n {setup: option, name: option.name} 处理，否则直接返回 option\n   测试：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37  // 源文件：/js/vue/lib.js const { rc: { nextTick, h, ref, defineAsyncComponent }, rcTest: { createApp, nodeOps, serializeInner: si }, f, log, } = require(process.env.BLOG_JS + \u0026#34;/vue/lib.js\u0026#34;); const run = async () =\u0026gt; { const timeout = (n) =\u0026gt; new Promise((r) =\u0026gt; setTimeout(r, n)); let resolve; const Foo = defineAsyncComponent(() =\u0026gt; new Promise((r) =\u0026gt; (resolve = r))); const toggle = ref(true); const root = nodeOps.createElement(\u0026#34;div\u0026#34;); createApp({ render: () =\u0026gt; ( console.log(toggle.value, \u0026#34;xxx\u0026#34;), toggle.value ? h(Foo) : null ), }).mount(root); console.log(si(root)); // 手动 resolve, 触发 loader().then(comp =\u0026gt; { ... })  resolve(() =\u0026gt; \u0026#34;resolved\u0026#34;); await timeout(); si(root); // 到这里 component 已经 resolved 了  toggle.value = false; await nextTick(); si(root); // -\u0026gt; null  toggle.value = true; await nextTick(); si(root); // -\u0026gt; resolved }; run();    true xxx resolved comp before loaded.value = false \u0026lt;!----\u0026gt; undefined async comp load ok, resolved      🔥 render function   篇幅太长，另起单独文章 -\u0026gt; Vue3 源码头脑风暴之 7 ☞ runtime-core(2) - render\n  🚒 scheduler 任务调度机制   让我们跟着 scheduler.spec.ts 测试用例来逐步属性 scheduler 的调度机制。\n 在做这个之前先把 scheduler.ts 中逻辑代码全清空，这个文件还是相对独立的\n feat: rc-\u0026gt;reset scheduler.ts · gcclll/stb-vue-next@a54cc00 · GitHub\n 我们从零开始一步步来分析实现。\n  这部分包含三种任务的 flush 逻辑代码：\n  queue jobs -\u0026gt; flushIndex -\u0026gt; queue[] -\u0026gt; queueJob() -\u0026gt; queueFlush() -\u0026gt; flushJobs()\n  pre jobs -\u0026gt; preFlushIndex -\u0026gt; pendingPreFlushCbs[] -\u0026gt; activePreFlushCbs[] -\u0026gt; queuePreFlushCb() -\u0026gt; flushPreFlushCbs() -\u0026gt; flushJobs()\n  TODO post jobs -\u0026gt; …\n  nextTick   feat(add): rc-\u0026gt;scheduler -\u0026gt; nextTick · gcclll/stb-vue-next@32b4827 · GitHub\n 在 queue 所有队列清空之后执行的一个异步操作，有重要关联的两个变量：\n  resolvedPromise，一个空的 promise then\n  currentFlushPromise，当 queue 队列中的所有任务执行完成之后返回的一个 promise\n 是的，是所有 queue jobs 完成之后，因为 flushJobs 函数里面都是同步操作，重要代 码：\n1 2 3 4 5 6 7  for (flushIndex = 0; flushIndex \u0026lt; queue.length; flushIndex++) { const job = queue[flushIndex]; if (job) { // TODO DEV -\u0026gt; 检查递归更新问题  callWithErrorHandling(job, null, ErrorCodes.SCHEDULER); } }       所以 nextTick 任务总是在 queue jobs 所有任务完成之后执行。\n 1 2 3 4 5 6 7 8 9 10 11  const resolvedPromise: Promise\u0026lt;any\u0026gt; = Promise.resolve(); // 当前正在被执行的 promise 任务 let currentFlushPromise: Promise\u0026lt;void\u0026gt; | null = null; export function nextTick( this: ComponentPublicInstance | void, fn?: () =\u0026gt; void ): Promise\u0026lt;void\u0026gt; { const p = currentFlushPromise || resolvedPromise; return fn ? p.then(this ? fn.bind(this) : fn) : p; }     函数作用：在当前正在执行的 job promise 之后执行 nextTick 的任务，等于说 nextTick 属于个插队任务。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21  // 源文件：/js/vue/lib.js const { rc: { nextTick }, log, } = require(process.env.BLOG_JS + \u0026#34;/vue/lib.js\u0026#34;); const run = async () =\u0026gt; { const calls = []; const pr = Promise.resolve(); const dummyThen = Promise.resolve().then(); const job1 = () =\u0026gt; calls.push(\u0026#34;job1\u0026#34;); const job2 = () =\u0026gt; calls.push(\u0026#34;job2\u0026#34;); nextTick(job1); job2(); log([\u0026#34;\\nbefore await, \u0026#34;, calls.length, \u0026#34;\\n\u0026#34;]); await dummyThen; log([\u0026#34;\\nafter await, \u0026#34;, calls.length, \u0026#34;\\n\u0026#34;]); log(calls.join(\u0026#34;-\u0026#34;)); }; run();    before await, 1 after await, 2 job2-job1   Tip. nextTick() 异步代码执行，经过 babel 转换后的代码，请查看 nextTick question\n   queueJob   feat(add): rc-\u0026gt;scheduler-\u0026gt;queueJob · gcclll/stb-vue-next@eb33b40 · GitHub\n 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31  export function queueJob(job: SchedulerJob) { // the dedupe search uses the startIndex argument of Array.includes()  // by default the search index includes the current job that is being run  // so it cannot recursively trigger itself again.  // if the job is a watch() callback, the search will start with a +1 index to  // allow it recursively trigger itself - it is the user\u0026#39;s responsibility to  // ensure it doesn\u0026#39;t end up in an infinite loop.  if ( (!queue.length || !queue.includes( job, isFlushing \u0026amp;\u0026amp; job.allowRecurse ? flushIndex + 1 : flushIndex )) \u0026amp;\u0026amp; job !== currentPreFlushParentJob ) { queue.push(job) queueFlush } } function queueFlush() { if (!isFlushing \u0026amp;\u0026amp; !isFlushPending) { isFlushPending = true currentFlushPromise = resolvedPromise.then(flushJobs) } } // 请查看下一节的实现 function flushJobs(seen?: CountMap) { // TODO }     需要 flushJobs 支持，请到 flushJobs(👇) 一节查看测试情况。\n  flushJobs   feat(add): rc-\u0026gt;scheduler-\u0026gt;flushJobs function · gcclll/stb-vue-next@e23be11 · GitHub\n  isFlushPending, isFlushing 标识重置\n  flushPreFlushCbs, 对 pre 类型的 jobs 进行 flush 操作，有关函数 flushPreFlushCbs(flush函数) 和 queuePreFlushCb(入列函数)\n  flush 之前进行排序\n  try -\u0026gt; callWithErrorHandling 执行任务回调\n  finally -\u0026gt; 重置，清空 queue 队列内容和标识\n  TODO flushPostFlushCbs, 对 post 类型的 jobs 进行 flush 操作，有关函数 flushPostFlushCbs 和 queuePostFlushCb\n  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41  function flushJobs(seen?: CountMap) { isFlushPending = false; isFlushing = true; if (__DEV__) { seen = seen || new Map(); } // flushPreFLushCbs(seen)，默认的 job 类型  // flush 之前对 queue 排序  // 1. 组件更新顺序：parent -\u0026gt; child，因为 parent 总是在 child 之前  // 被创建，因此 parent render effect 有更低的优先级数字(数字越小越先创建？)  // 2. 如果组件在 parent 更新期间被卸载了，那么它的更新都会被忽略掉  queue.sort((a, b) =\u0026gt; getId(a) - getId(b)); // 开始 flush  try { for (flushIndex = 0; flushIndex \u0026lt; queue.length; flushIndex++) { const job = queue[flushIndex]; if (job) { // TODO DEV -\u0026gt; 检查递归更新问题  callWithErrorHandling(job, null, ErrorCodes.SCHEDULER); } } } finally { // 情况队列  flushIndex = 0; queue.length = 0; // TODO flush `post` 类型的 flush cbs  isFlushing = false; currentFlushPromise = null; // TDOO 代码执行到当前 tick 的时候，有可能有新的 job 加入  // some postFlushCb queued jobs!  // keep flushing until it drains.  } }     测试：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26  // 源文件：/js/vue/lib.js const { rc: { queueJob, nextTick }, log, } = require(process.env.BLOG_JS + \u0026#34;/vue/lib.js\u0026#34;); const run = async () =\u0026gt; { const calls = []; const job1 = () =\u0026gt; { // #1  log.newline(\u0026#34;job1 running\u0026#34;); calls.push(\u0026#34;job1\u0026#34;); }; const job2 = () =\u0026gt; { // #2  log.newline(\u0026#34;job2 running\u0026#34;); calls.push(\u0026#34;job2\u0026#34;); }; // 支持去重  queueJob(job1); // #3  queueJob(job2); // #4  queueJob(job1); queueJob(job2); log(\u0026#34;before await \u0026#34; + calls); // #5  await nextTick(); // #6  log(\u0026#34;after await \u0026#34; + calls); // #7 }; run();    before await undefined job1 running job2 running after await job1,job2   如果在没有 #6 的情况下，在所有 Log 之后会立即执行 queue jobs。\n1 2 3 4 5 6  function queueFlush() { if (!isFlushing \u0026amp;\u0026amp; !isFlushPending) { isFlushPending = true; currentFlushPromise = resolvedPromise.then(flushJobs); } }     这里 nextTick() 调用并没有传递 fn ，因此 await nextTick() 在这里的作用就是等 resolvedPromise 执行完成(此时并没有正在执行的 promise)\n const resolvedPromise: Promise\u0026lt;any\u0026gt; = Promise.resolve()\n 再执行后面的代码。\n queueJob 函数分为两步：\n  push 收集任务 queue.push(job) ，同步执行\n  随后立即调用 queueFlush() 刷掉任务，任务异步 flush\n  在这个实例中，按照同步执行顺序，\n  queueJob(job1) 执行，将 job1 -\u0026gt; push -\u0026gt; queue 中， queueFlush 中的 promise 等待\n  queueJob(job2) 执行，将 job2 -\u0026gt; push -\u0026gt; queue 中， queueFlush 中的 promise 继续等待\n  log before 执行，由于 job 虽然已经在 queue 中了，但是需要等待 queueFlush 去 异步执行他们，所以这里 calls 依旧是空的\n  await nextTick() 异步操作\n 这一句目的只是为了让后面的 log 在 job1,job2 后面执行。\n1 2  const p = currentFlushPromise || resolvedPromise; return fn ? p.then(this ? fn.bind(this) : fn) : p;     nextTick 会在刚刚执行完毕的 promise 后面取执行后面的任务，所以 log after 肯定是后于 job1,job2 的执行的。\n  所有同步任务执行完成，开始进入异步任务执行，由于 job1,job2 先入队列，在事件循 环中会先于 log after 执行，然后在执行 log after，所以就有了上面的输出结果。\n   实例执行脑图：\n   queueJob while flushing   当 queue 中 jobs 正在被执行的时候调用 queueJob 进入新的任务。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20  // 源文件：/js/vue/lib.js const { rc: { queueJob, nextTick }, log, } = require(process.env.BLOG_JS + \u0026#34;/vue/lib.js\u0026#34;); const run = async () =\u0026gt; { const calls = []; const job1 = () =\u0026gt; { calls.push(\u0026#34;job1\u0026#34;); // job2 任务会在 job1 执行到这里的时候加入到了 queue  // 但是它的执行需等到 queue 中的任务执行完成之后再执行  // 因为任务收集是同步的，任务执行是异步的，而 queue flush 操作又是同步的  queueJob(job2); }; const job2 = () =\u0026gt; calls.push(\u0026#34;job2\u0026#34;); queueJob(job1); await nextTick(); log([\u0026#34;\\nafter await\\n\u0026#34;, calls]); }; run();    undefined after await [ \u0026#39;job1\u0026#39;, \u0026#39;job2\u0026#39; ]   看下面的测试代码（在 for 循环过程中改变数组长度，会检测到这种改变）：\n1 2 3 4 5 6  const nums = [1, 2, 3]; const add = (i) =\u0026gt; nums.push(++i); for (let i = 0; i \u0026lt; nums.length; i++) { if (i === 1) add(i); console.log({ i, v: nums[i], l: nums.length }); }    { i: 0, v: 1, l: 3 } { i: 1, v: 2, l: 4 } { i: 2, v: 3, l: 4 } { i: 3, v: 2, l: 4 } undefined   所以上面的 Job 实例，就很好理解了\n 在 for queue jobs 过程中发现有新的 job 进入，之前说过了 queue 的入列操作是同步 的，所以会立即执行改变 queue 长度，最后加入的任务会在 for 循环过程中最后得到执行。\n  queuePreFlushCb   feat(add): rc-\u0026gt;scheduler-\u0026gt;queuePreFlushCb -\u0026gt; pre jobs, pendingPreFlus… · gcclll/stb-vue-next@2c72cdc · GitHub\n 新增代码：\n  queuePreFlushCb, 入列 pre jobs 函数\n  flushPreFlushCbs, flush pre jobs 函数\n  flushJobs 中调用 flushPreFlushCbs() 刷掉 pre jobs\n  这个是用来收集和 flush pre 类型(默认类型的任务)的队列 pendingPreFlushCbs[] 的函数。\n 逻辑脑图：  相关代码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25  export function queuePreFlushCb(cb: SchedulerCb) { queueCb(cb, activePreFlushCbs, pendingPreFlushCbs, preFlushIndex); } function queueCb( cb: SchedulerCbs, activeQueue: SchedulerCb[] | null, pendingQueue: SchedulerCb[], index: number ) { if (!isArray(cb)) { if ( !activeQueue || !activeQueue.includes( cb, (cb as SchedulerJob).allowRecurse ? index + 1 : index ) ) { pendingQueue.push(cb); } } else { pendingQueue.push(...cb); } queueFlush(); }     对比 queueCb 和 queueJob 会发现两者没多大的差别，先同步收集再异步 flush，两者判 断条件有细微差别，另外 queueJob 支持数组形式的 cb：\n1 2 3 4 5 6 7 8 9 10 11 12  // queueJob if ( (!queue.length || !queue.includes( job, isFlushing \u0026amp;\u0026amp; job.allowRecurse ? flushIndex + 1 : flushIndex )) \u0026amp;\u0026amp; job !== currentPreFlushParentJob ) { queue.push(job); queueFlush(); }     最后也都是调用 queueFlush() -\u0026gt; flushJobs() 来清空队列 pendingQueue/queue 。\n 所以下面还需要在 flushJobs() 里面去实现对 pre -\u0026gt; pendingQueue 类型队列 flush 操 作(flushPreFlushCbs())。\n  flushPreFlushCbs   有关函数和变量\n   name type description     preFlushIndex number used in `for` to flush pre jobs   pendingPreFlushCbs array the queue to store pre jobs   activePreFlushCbs array the non-repeat copy of pendingPreFlushCbs, used to flushing   queuePreFlushCb function 与 flushPreFlushCbs 对应的 pre job 入列函数   queueFlush function 执行队列任务的函数，三个类型的任务都在这里面执行(pre,post,queue)   flushJobs function 具体执行任务的函数，三种任务执行顺序是： pre -\u0026gt; queue -\u0026gt; post     Tip. activePreFlushCbs 和 pendingPreFlushCbs 的关系： 前者是后者的一个拷贝， 拷贝完会立即清空 pending, 目的是为了让 pending 在 active flushing 期间能继续收集 新的任务，这样如果在执行期间有新的任务入列，那么在函数最后的递归操作会对这些新入 列的任务继续 flush 掉，直到再也没有新的任务入列为止。\n 注意点 ：当 queuePreFlushCb 在 queueJob 中使用时不会主动触发 cbs 执行，如果 需要立即执行这些 cbs 需要手动调用 flushPreFlushCbs(seen, parentJob) 去刷掉 pre cbs 任务，或者等到当前 job 执行完了下一个 flushJobs() 调用中执行，因为 queueJob() 执行期间 isFlushing = true ，而在 queueFlush() 中有检测这个值， 如果正在执行 flushing 是不会继续执行的，更多详情查看后面的测试和分析。\n  源码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28  export function flushPreFlushCbs( seen?: CountMap, parentJob: SchedulerJob | null = null ) { if (pendingPreFlushCbs.length) { currentPreFlushParentJob = parentJob; activePreFlushCbs = [...new Set(pendingPreFlushCbs)]; pendingPreFlushCbs.length = 0; if (__DEV__) { seen = seen || new Map(); } for ( preFlushIndex = 0; preFlushIndex \u0026lt; activePreFlushCbs.length; preFlushIndex++ ) { // TODO 检查递归更新问题  activePreFlushCbs[preFlushIndex](); } activePreFlushCbs = null; preFlushIndex = 0; currentPreFlushParentJob = null; // 递归 flush 直到所有 pre jobs 被执行完成  flushPreFlushCbs(seen, parentJob); } }     用途： api watch 里面对默认类型(pre)的任务的入列操作，如下代码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27  // default: \u0026#39;pre\u0026#39; function doWatch( source: WatchSource | WatchSource[] | WatchEffect | object, cb: WatchCallback | null, { immediate, deep, flush, onTrack, onTrigger }: WatchOptions = EMPTY_OBJ, instance = currentInstance ): WatchStopHandle { // ...  let scheduler: ReactiveEffectOptions[\u0026#34;scheduler\u0026#34;]; if (flush === \u0026#34;sync\u0026#34;) { // ...  } else if (flush === \u0026#34;post\u0026#34;) { // ...  } else { // default: \u0026#39;pre\u0026#39;  scheduler = () =\u0026gt; { if (!instance || instance.isMounted) { queuePreFlushCb(job); } else { // with \u0026#39;pre\u0026#39; option, the first call must happen before  // the component is mounted so it is called synchronously.  job(); } }; } // ... }     测试：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23  // 源文件：/js/vue/lib.js const { rc: { queueJob, queuePreFlushCb, flushPreFlushCbs, nextTick }, log, } = require(process.env.BLOG_JS + \u0026#34;/vue/lib.js\u0026#34;); const run = async () =\u0026gt; { const calls = []; const job1 = () =\u0026gt; { // #1  queuePreFlushCb(cb1); // #2  queuePreFlushCb(cb2); // #3  // 手动触发 cb1, cb2  flushPreFlushCbs(undefined, job1); // #4  calls.push(\u0026#34;job1\u0026#34;); // #5  }; const cb1 = () =\u0026gt; calls.push(\u0026#34;cb1\u0026#34;); // #6  const cb2 = () =\u0026gt; calls.push(\u0026#34;cb2\u0026#34;); // #7  queueJob(job1); // #8  await nextTick(); // #9  log.newline(calls); // #10 }; run();    undefined cb1 cb2 job1   测试分析代码脑图：  文字分析：\n  #8 先执行， queueJob -\u0026gt; push job1 -\u0026gt; queue:[job1] -\u0026gt; queueFlush()\n 在 queueFlush() 中调用 resolvedPromise.then(flushJobs) 异步执行 flushJobs() 函数刷掉所有任务(pre/job/post)\n 并且记录当前 tick 下的 promise: currentFlushPromise\n 此时的 pendingPreFlushCbs[] 中是没有任何任务的，所以继续执行 try{…} 开始 flush queue[] jobs，这个时候 flushIndex = 0 得到 job1，开始按顺序执行 job1\n  #1 开始执行\n  #2 将 cb1 push -\u0026gt; pendingPreFlushCbs=[cb1]\n  #3 将 cb2 push -\u0026gt; pendingPreFlushCbs=[cb1, cb2]\n  #4 手动 flush pre cbs\n 在 flushPreFlushCbs(undefind, job1) 中会记录 currentPreFlushParentJob = job1 这个变量将会在 queueJob(job) 中用来检测 job 是不是当前的 job1 如果是 就不允许 push，因为 job1 下有子任务正在执行，必须等这些子任务(cb1, cb2) 执行完。\n  #6 开始执行， push \u0026#39;cb1\u0026#39; -\u0026gt; calls: [\u0026#39;cb1\u0026#39;]\n  #7 开始执行， push \u0026#39;cb2\u0026#39; -\u0026gt; calls: [\u0026#39;cb1\u0026#39;, \u0026#39;cb2\u0026#39;]\n  #5 开始执行， push \u0026#39;job1\u0026#39; -\u0026gt; alls: [\u0026#39;cb1\u0026#39;, \u0026#39;cb2\u0026#39;, \u0026#39;job1\u0026#39;]\n  #9 开始执行，因为 nextTick()\n1 2 3 4 5 6 7  export function nextTick( this: ComponentPublicInstance | void, fn?: () =\u0026gt; void ): Promise\u0026lt;void\u0026gt; { const p = currentFlushPromise || resolvedPromise; return fn ? p.then(this ? fn.bind(this) : fn) : p; }     这里的 await 会等 job1 queueFlush() 触发的 promise.then(flushJobs) 返回的 promise 完成之后再执行后面的代码。\n  #10 log 输出 \u0026#39;cb1,cb2,job1\u0026#39;\n    queuePostFlushCb + flushPostFlushCbs   feat(add): rc-\u0026gt;scheduler-\u0026gt;queuePostFlushCb+flushPostFlushCbs · gcclll/stb-vue-next@845c21b · GitHub\n 逻辑脑图：  有了 queue job 和 pre cb 的基础分析，这部分也就很好理解了。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35  export function queuePostFlushCb(cb: SchedulerCbs) { queueCb(cb, activePostFlushCbs, pendingPostFlushCbs, postFlushIndex); } export function flushPostFlushCbs(seen?: CountMap) { if (pendingPostFlushCbs.length) { const deduped = [...new Set(pendingPostFlushCbs)]; pendingPostFlushCbs.length = 0; // #1947 already has active queue, nested flushPostFlushCbs call  if (activePostFlushCbs) { activePostFlushCbs.push(...deduped); return; } activePostFlushCbs = deduped; if (__DEV__) { seen = seen || new Map(); } activePostFlushCbs.sort((a, b) =\u0026gt; getId(a) - getId(b)); for ( postFlushIndex = 0; postFlushIndex \u0026lt; activePostFlushCbs.length; postFlushIndex++ ) { // TODO 递归 update 检查  activePostFlushCbs[postFlushIndex](); } activePostFlushCbs = null; postFlushIndex = 0; } }     和 pre cb 的处理有两个不同点：\n  非回调形式处理 flushing 期间接受到的新任务，而是通过改变执行器 activePostFlushCbs 来实现(和 queue job 类似)\n  没有递归回调形式处理后续的新任务，参考 1\n  测试：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41  // 源文件：/js/vue/lib.js const { rc: { queuePostFlushCb, nextTick, queueJob }, log, } = require(process.env.BLOG_JS + \u0026#34;/vue/lib.js\u0026#34;); // len = activePostFlushCbs.length const run = async () =\u0026gt; { const calls = []; const cb1 = () =\u0026gt; { calls.push(\u0026#34;cb1\u0026#34;); // 会在同一个 tick 期间执行，因为它在for flushing 期间改变了  // activePostFlushCbs，并且紧随 cb1,cb2,cb3 之后执行  queuePostFlushCb(cb4); }; const cb2 = () =\u0026gt; calls.push(\u0026#34;cb2\u0026#34;); const cb3 = () =\u0026gt; calls.push(\u0026#34;cb3\u0026#34;); // job1 会在 cb4 之后执行，因为 flushJobs 在按顺序执行完  // pre -\u0026gt; job -\u0026gt; post 最后的 finally 里面对 queue 进行了检测  // 此时 queue = [job1] 随意会递归调用 flushJobs() 继续刷  // 但是为什么 cb5 会在 job1 之后呢？？？  // 因为 queuePostFlushCb push 的是 pendingPostFlushCbs 而不是  // activePostFlushCbs，所以在 queuePostFlushCb 中调用自身增加的新  // cbs 会在 finally 后面的检测递归 flushJobs() 调用中执行  // 而 post 的优先级又低于 job 所以 job1 会优先输出  const cb4 = () =\u0026gt; (queuePostFlushCb(cb5), queueJob(job1), calls.push(\u0026#34;cb4\u0026#34;)); // 会在 job1,cb5 之后执行  const job1 = () =\u0026gt; (queuePostFlushCb(cb6), calls.push(\u0026#34;job1\u0026#34;)); const cb5 = () =\u0026gt; calls.push(\u0026#34;cb5\u0026#34;); const cb6 = () =\u0026gt; calls.push(\u0026#34;cb6\u0026#34;); queuePostFlushCb([cb1, cb2]); queuePostFlushCb(cb3); // 应该去重  queuePostFlushCb([cb1, cb3]); queuePostFlushCb(cb2); await nextTick(); log.newline(calls); }; run();    undefined cb1 cb2 cb3 cb4 job1 cb5 cb6   对于 queuePostFlushCb 和 queueJob 的混用只要记住一点， queuePostFlushCb 不 会触发 activePostFlushCbs 改变，因为 isFlushing = true，所以只会在当前 flushJobs() 执行到最后递归检测的时候才会进入下一次的 post+job 调用。\n   test nested(pre/job/post)   完整的测试用例，结合 pre, post, queue 三种类型的任务进行测试。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50  // 源文件：/js/vue/lib.js const { rc: { queueJob, queuePreFlushCb, nextTick, flushPreFlushCbs }, log, } = require(process.env.BLOG_JS + \u0026#34;/vue/lib.js\u0026#34;); const run = async () =\u0026gt; { const calls = []; const cb1 = () =\u0026gt; { calls.push(\u0026#34;cb1\u0026#34;); }; const cb2 = () =\u0026gt; { calls.push(\u0026#34;cb2\u0026#34;); // queueJob 和 queuePreFlushCb 结合使用  queueJob(job1); }; const cb3 = () =\u0026gt; { calls.push(\u0026#34;cb3\u0026#34;); // 链式使用，cb4 会在 cb1,2,3 执行完成之后才会执行  queuePreFlushCb(cb4); }; const cb4 = () =\u0026gt; { calls.push(\u0026#34;cb4\u0026#34;); }; const cb5 = () =\u0026gt; { calls.push(\u0026#34;cb5\u0026#34;); }; const job1 = () =\u0026gt; { calls.push(\u0026#34;job1\u0026#34;); // queuePreFlushCb 在 queueJob 中调用  // pre cbs 在 job 中调用的时候不会被执行，除非在这后面手动 flush  // 或者有新的任务进来，发起 flushJobs 调用才会执行  queuePreFlushCb(cb5); // 必须手动触发, 这样 cb5 才会输出  flushPreFlushCbs(undefined, job1 /* currentPreFlushParentJob */); }; const cb6 = () =\u0026gt; { calls.push(\u0026#34;cb6\u0026#34;); }; queuePreFlushCb(cb1); queuePreFlushCb(cb2); queuePreFlushCb(cb1); queuePreFlushCb(cb2); queuePreFlushCb(cb3); await nextTick(); log(\u0026#34;\\n\u0026#34; + calls); }; run();    undefined cb1,cb2,cb3,cb4,job1,cb5    pendingPreFlushCbs 虽然是个数组，但是 flush 期间通过 [...new Set(pendingPreFlushCbs)] 进行了去重操作。\n  链式操作，因为在执行期间使用的是 activePreFlushCbs 且此时的 pendingPreFlushCbs 清空了，等待新任务入列\n 在执行 cb3 期间，调用 queuePreFlushCb(cb4) 此时 push cb4 -\u0026gt; pendingPreFlushCbs ，但实际不会影响本次的 for 循环执行\n 这点和 queueJob 有点不同，它直接使用的是 queue -\u0026gt; for 所以有新的任务入列会改 变 for 的执行长度(queue.length)\n pre 处理会等到 activePreFlushCbs for 执行循环结束后，在函数的最后递归调用 flushPreFlushCbs() 来刷掉新入列的任务(如： cb4)\n  queueJob 在 queuePreFlushCb 中调用的时候， queue job 总是在 pre cb 之后被执行，这也 是 flushJobs 中处理代码应体现出的结果。\n1 2 3 4 5  function flushJobs() { // 1. flush pre -\u0026gt; flushPreFlushCbs()  // 2. for -\u0026gt; queue job -\u0026gt; callWithErrorHandling(job, ...)  // 3. flush post -\u0026gt; flushPostFlushCbs() }     并且如上面实例结果 cb4 嵌套在 cb3 ，job1 嵌套在了 cb2 中，但是最后还是 cb4 先 得到执行了，job1 再执行。\n Tip. 因此，对于 pre cbs 和 queue jobs 两个类型的任务，不管什么时机入列的，都会 是先执行 pre cbs 再执行 queue jobs\n   queuePreFlushCb 在 queueJob 中调用的时候，新的 pre job 会在 queue job 后执行\n fix: rc-\u0026gt;scheduler-\u0026gt;flushJobs recursive · gcclll/stb-vue-next@b0155c5 · GitHub\n 原因： flushPreFlushCbs 先于 queue jobs 执行，因此 queue jobs(job1) 执行 的时候 queuePreFlushCb() 加入的任务(cb5)此时不会执行，而是等 queue jobs 都执行完之后在finally 里面会做一次检测\n1 2 3  if (queue.length || pendingPreFlushCbs.length) { flushJobs(seen) }     这个时候会去递归 flushJobs() 此时才发现有新的 pendingPreFlushCbs (如： cb5)，则将执行他们，所以结果是 job1,cb5 。\n    invalidateJob(job)   feat(add): rc-\u0026gt;scheduler-\u0026gt;invalidateJob · gcclll/stb-vue-next@24808b1 · GitHub\n 是任务失效，其实就是单纯的将 Job 从 queue 中删除了。\n1 2 3 4 5 6  export function invalidateJob(job: SchedulerJob) { const i = queue.indexOf(job); if (i \u0026gt; -1) { queue.splice(i, 1); } }     测试:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31  // 源文件：/js/vue/lib.js const { rc: { queueJob, queuePostFlushCb, invalidateJob, nextTick }, log, } = require(process.env.BLOG_JS + \u0026#34;/vue/lib.js\u0026#34;); const run = async () =\u0026gt; { const calls = []; const job1 = () =\u0026gt; { calls.push(\u0026#34;job1\u0026#34;); invalidateJob(job2); // 这里将 job2 从 queue[] 中删除了  job2(); // 注释这个结果会是： job1 job3 job4  }; const job2 = () =\u0026gt; { calls.push(\u0026#34;job2\u0026#34;); }; const job3 = () =\u0026gt; { calls.push(\u0026#34;job3\u0026#34;); }; const job4 = () =\u0026gt; { calls.push(\u0026#34;job4\u0026#34;); }; queueJob(job1); queueJob(job2); queueJob(job3); queuePostFlushCb(job4); await nextTick(); log.newline(calls); }; run();    undefined job1 job2 job3 job4    job sort id 任务可以排序   只有 post 和 job 支持排序。\n 测试：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32  // 源文件：/js/vue/lib.js const { rc: { queueJob, queuePostFlushCb, nextTick }, log, } = require(process.env.BLOG_JS + \u0026#34;/vue/lib.js\u0026#34;); const run = async () =\u0026gt; { const calls = []; const job1 = () =\u0026gt; calls.push(\u0026#34;job1\u0026#34;); const job2 = () =\u0026gt; calls.push(\u0026#34;job2\u0026#34;); const job3 = () =\u0026gt; calls.push(\u0026#34;job3\u0026#34;); // job1 no id  job2.id = 2; job3.id = 1; const cb1 = () =\u0026gt; calls.push(\u0026#34;cb1\u0026#34;); const cb2 = () =\u0026gt; calls.push(\u0026#34;cb2\u0026#34;); const cb3 = () =\u0026gt; calls.push(\u0026#34;cb3\u0026#34;); cb1.id = 2; // cb2 no id  cb3.id = 1; queueJob(job1); queueJob(job2); queueJob(job3); queuePostFlushCb(cb1); queuePostFlushCb(cb2); queuePostFlushCb(cb3); await nextTick(); log.newline(calls); }; run();    undefined job3 job2 job1 cb3 cb1 cb2    allowRecurse 自身递归   用 job.allowRecurse 来控制 job 是否可以自己触发自己执行(PS. pre/job/post 都支持 该属性)。\n 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28  // 源文件：/js/vue/lib.js const { rc: { queueJob, nextTick }, log, } = require(process.env.BLOG_JS + \u0026#34;/vue/lib.js\u0026#34;); const run = async () =\u0026gt; { let count = 0; const job = () =\u0026gt; { if (count \u0026lt; 3) { count++; queueJob(job); } }; queueJob(job); queueJob(job); await nextTick(); log.newline(\u0026#34;before count: \u0026#34; + count); // 设置 allowRecurse = true 允许自我调度  count = 0; job.allowRecurse = true; // 重复入列同一个任务会在 push 阶段就检测和自身递归调用不同  queueJob(job); queueJob(job); await nextTick(); log.newline(\u0026#34;after count: \u0026#34; + count); }; run();    undefined before count: 1 after count: 3    checkRecursiveUpdates   feat(add): rc-\u0026gt;scheduler-\u0026gt;checkRecursiveUpdates · gcclll/stb-vue-next@7bcc14b · GitHub\n 限制调用自身的次数，在 allowRecurse = true 情况下使用。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23  // 源文件：/js/vue/lib.js const { rc: { queueJob, nextTick }, log, } = require(process.env.BLOG_JS + \u0026#34;/vue/lib.js\u0026#34;); const run = async () =\u0026gt; { let count = 0; const job = () =\u0026gt; { if (count \u0026lt; 101) { count++; queueJob(job); } }; job.allowRecurse = true; queueJob(job); try { await nextTick(); } catch (e) { log.newline(e.message); } }; run();    undefined Maximum recursive updates exceeded. This means you have a reactive effect that is mutating its own dependencies and thus recursively triggering itself. Possible sources include component template, render function, updated hook or watcher source function.    小结    pre cbs: 执行优先级最高，在同一 tick 中会递归调用自身清空 pendingPreFlushCbs 中的任务，在 queueJob 中调用时不会自动触发需要手动触发执行，因为此时 isFlushing = true 。\n job: 执行优先级次之，在同一 tick 中同一个 for queue -\u0026gt; flushIndex 下会处理此 时接受到的新任务，在 pre cbs 中调用时会在所有 pre cbs 执行之后执行。\n post cbs: 执行优先级最低，在同一 tick 同一次 flushPostFlushCbs() 调用中不会 处理新的 post 任务，而是在 flushJobs() 执行到最后 finally 部分检 测 pendingPostFlushCbs 任务队列来处理当前 tick 下新接受到的任务， 在 queuePreFlushCb() 和 queueJob() 中调用的时候会在他们的任务之后执行。\n    🐛 BUGs fix \u0026amp; Questions   fix: no import EMPTY_ARR · gcclll/stb-vue-next@2a1ab04 · GitHub\nnextTick() 后面的代码最后执行？   测试代码： nextTick\n 先看一段代码，以及 babeljs.io 转换之后的结果：\n babel 之前：\n1 2 3 4 5 6 7 8 9 10 11 12  const run = async () =\u0026gt; { const p = Promise.resolve().then(); const p1 = p.then(() =\u0026gt; console.log(\u0026#34;before await\u0026#34;)); console.log(\u0026#34;between await and p1\u0026#34;); await p1; console.log(\u0026#34;after await\u0026#34;); const p2 = Promise.resolve().then(); await p2; console.log(\u0026#34;after p2\u0026#34;); }; run();     babel 之后(只贴出核心部分)：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25  while (1) { switch ((_context.prev = _context.next)) { case 0: p = Promise.resolve().then(); p1 = p.then(function () { return console.log(\u0026#34;before await\u0026#34;); }); console.log(\u0026#34;between await and p1\u0026#34;); _context.next = 5; return p1; case 5: console.log(\u0026#34;after await\u0026#34;); p2 = Promise.resolve().then(); _context.next = 9; return p2; case 9: console.log(\u0026#34;after p2\u0026#34;); case 10: case \u0026#34;end\u0026#34;: return _context.stop(); } }     即上面的代码被转换之后变成了一个 switch，里面是一个 while 循环，异步代码最终的顺 序执行由 _context.next 来衔接。\n case 0 -\u0026gt; next = 5 -\u0026gt; case 5 -\u0026gt; next = 9 -\u0026gt; …\n 所以说 nextTick() 后面的代码都会被放到异步代码\n    runtime-test 模块简介   这里测试需要用到这个模块，所以简单用脑图描述下这里面有哪些东西和干什么的。\n  重要代码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89  // nodeOpts.ts  // 1. createElement // 2. createText // 3. createComment // 上面三个函数分别创建了三种类型节点 const node = { id: nodeId++, type: NodeTypes.ELEMENT, // TEXT | COMMENT  text: value, // 节点具体内容  parentNode: null, // 下面是 ELEMENT 类型拥有的属性  children: [], props: {}, tag, eventListeners: null, }; // 4. setText(node, text), 直接修改 node.text function setText(node: TestText, text: string) { logNodeOp({ type: NodeOpTypes.SET_TEXT, targetNode: node, text, }); node.text = text; } // 5. 插入 insert(child, parent, ref?) function insert(child: TestNode, parent: TestElement, ref?: TestNode | null) { let refIndex; if (ref) { refIndex = parent.children.indexOf(ref); if (refIndex === -1) { console.error(\u0026#34;ref: \u0026#34;, ref); console.error(\u0026#34;parent: \u0026#34;, parent); throw new Error(\u0026#34;ref is not a child of parent\u0026#34;); } } // ...log  // remove the node first, but don\u0026#39;t log it as a REMOVE op  remove(child, false); // re-calculate the ref index because the child\u0026#39;s removal may have affected it  refIndex = ref ? parent.children.indexOf(ref) : -1; if (refIndex === -1) { parent.children.push(child); child.parentNode = parent; } else { parent.children.splice(refIndex, 0, child); child.parentNode = parent; } } // 6. remove(child) function remove(child: TestNode, logOp: boolean = true) { const parent = child.parentNode; if (parent) { const i = parent.children.indexOf(child); if (i \u0026gt; -1) { parent.children.splice(i, 1); } else { console.error(\u0026#34;target: \u0026#34;, child); console.error(\u0026#34;parent: \u0026#34;, parent); throw Error(\u0026#34;target is not a childNode of parent\u0026#34;); } child.parentNode = null; } } // 7. setElementText(), 直接清空替换 children，不如 patchChildren 中 // 对 new/old 类型不同的时候需要 full diff 时更新节点 function setElementText(el: TestElement, text: string) { // ...  el.children.forEach((c) =\u0026gt; { c.parentNode = null; }); if (!text) { el.children = []; } else { el.children = [ { id: nodeId++, type: NodeTypes.TEXT, text, parentNode: el, }, ]; } }      重要类型声明    异步组件选项\n1 2 3 4 5 6 7 8 9 10 11 12 13 14  export interface AsyncComponentOptions\u0026lt;T = any\u0026gt; { loader: AsyncComponentLoader\u0026lt;T\u0026gt; loadingComponent?: Component errorComponent?: Component delay?: number timeout?: number suspensible?: boolean onError?: ( error: Error, retry: () =\u0026gt; void, fail: () =\u0026gt; void, attempts: number ) =\u0026gt; any }      Vue App 类型\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23  export interface App\u0026lt;HostElement = any\u0026gt; { version: string; config: AppConfig; use(plugin: Plugin, ...options: any[]): this; mixin(mixin: ComponentOptions): this; component(name: string): Component | undefined; component(name: string, component: Component): this; directive(name: string): Directive | undefined; directive(name: string, directive: Directive): this; mount( rootContainer: HostElement | string, isHydrate?: boolean ): ComponentPublicInstance; unmount(rootContainer: HostElement | string): void; provide\u0026lt;T\u0026gt;(key: InjectionKey\u0026lt;T\u0026gt; | string, value: T): this; // internal, but we need to expose these for the server-renderer and devtools  _uid: number; _component: ConcreteComponent; _props: Data | null; _container: HostElement | null; _context: AppContext; }     App 配置:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19  export interface AppConfig { // @private  readonly isNativeTag?: (tag: string) =\u0026gt; boolean; performance: boolean; optionMergeStrategies: Record\u0026lt;string, OptionMergeFunction\u0026gt;; globalProperties: Record\u0026lt;string, any\u0026gt;; isCustomElement: (tag: string) =\u0026gt; boolean; errorHandler?: ( err: unknown, instance: ComponentPublicInstance | null, info: string ) =\u0026gt; void; warnHandler?: ( msg: string, instance: ComponentPublicInstance | null, trace: string ) =\u0026gt; void; }     Vue 插件类型：\n1 2 3 4 5 6  type PluginInstallFunction = (app: App, ...options: any[]) =\u0026gt; any; export type Plugin = | (PluginInstallFunction \u0026amp; { install?: PluginInstallFunction }) | { install: PluginInstallFunction; };      api watch 类型\n1 2 3 4 5 6 7 8 9 10  export interface WatchOptionsBase { flush?: \u0026#34;pre\u0026#34; | \u0026#34;post\u0026#34; | \u0026#34;sync\u0026#34;; onTrack?: ReactiveEffectOptions[\u0026#34;onTrack\u0026#34;]; onTrigger?: ReactiveEffectOptions[\u0026#34;onTrigger\u0026#34;]; } export interface WatchOptions\u0026lt;Immediate = boolean\u0026gt; extends WatchOptionsBase { immediate?: Immediate; deep?: boolean; }      component 组件类型\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69  // 内部选项  export interface ComponentInternalOptions { /** ,* @internal ,*/ __props?: NormalizedPropsOptions; /** ,* @internal ,*/ __emits?: ObjectEmitsOptions | null; /** ,* @internal ,*/ __scopeId?: string; /** ,* @internal ,*/ __cssModules?: Data; /** ,* @internal ,*/ __hmrId?: string; /** ,* This one should be exposed so that devtools can make use of it ,*/ __file?: string; } // 函数式组件  export interface FunctionalComponent\u0026lt;P = {}, E extends EmitsOptions = {}\u0026gt; extends ComponentInternalOptions { // use of any here is intentional so it can be a valid JSX Element constructor  (props: P, ctx: Omit\u0026lt;SetupContext\u0026lt;E\u0026gt;, \u0026#34;expose\u0026#34;\u0026gt;): any; props?: ComponentPropsOptions\u0026lt;P\u0026gt;; emits?: E | (keyof E)[]; inheritAttrs?: boolean; displayName?: string; } // 类组件  export interface ClassComponent { new (...args: any[]): ComponentPublicInstance\u0026lt;any, any, any, any, any\u0026gt;; __vccOpts: ComponentOptions; } // 生命周期函数缩写  export const enum LifecycleHooks { BEFORE_CREATE = \u0026#34;bc\u0026#34;, CREATED = \u0026#34;c\u0026#34;, BEFORE_MOUNT = \u0026#34;bm\u0026#34;, MOUNTED = \u0026#34;m\u0026#34;, BEFORE_UPDATE = \u0026#34;bu\u0026#34;, UPDATED = \u0026#34;u\u0026#34;, BEFORE_UNMOUNT = \u0026#34;bum\u0026#34;, UNMOUNTED = \u0026#34;um\u0026#34;, DEACTIVATED = \u0026#34;da\u0026#34;, ACTIVATED = \u0026#34;a\u0026#34;, RENDER_TRIGGERED = \u0026#34;rtg\u0026#34;, RENDER_TRACKED = \u0026#34;rtc\u0026#34;, ERROR_CAPTURED = \u0026#34;ec\u0026#34;, } // setup 函数  export interface SetupContext\u0026lt;E = EmitsOptions\u0026gt; { attrs: Data; slots: Slots; emit: EmitFn\u0026lt;E\u0026gt;; expose: (exposed: Record\u0026lt;string, any\u0026gt;) =\u0026gt; void; }      component internal instance\n 这里涵盖了一个组件都有哪些属性：\n uid, type, parent, root, appContext, vnode, next, subTree, update,\n render, ssrRender, provides, effects, accessCache, renderCache,\n components, directives, propsOptions, emitsOptions,\n proxy, exposed, withProxy, ctx,\n data, props, attrs, slots, refs, emit,\n emitted, setupState, devtoolsRawSetupState, setupContext,\n suspense, suspenseId, asyncDep, asyncResolved,\n isMounted, isUnmounted, isDeactivated,\n bc, c, bm, m, bu, u, bum, um, da, a, rtg, rtc, ec\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  export const enum LifecycleHooks { BEFORE_CREATE = \u0026#34;bc\u0026#34;, CREATED = \u0026#34;c\u0026#34;, BEFORE_MOUNT = \u0026#34;bm\u0026#34;, MOUNTED = \u0026#34;m\u0026#34;, BEFORE_UPDATE = \u0026#34;bu\u0026#34;, UPDATED = \u0026#34;u\u0026#34;, BEFORE_UNMOUNT = \u0026#34;bum\u0026#34;, UNMOUNTED = \u0026#34;um\u0026#34;, DEACTIVATED = \u0026#34;da\u0026#34;, ACTIVATED = \u0026#34;a\u0026#34;, RENDER_TRIGGERED = \u0026#34;rtg\u0026#34;, RENDER_TRACKED = \u0026#34;rtc\u0026#34;, ERROR_CAPTURED = \u0026#34;ec\u0026#34;, }     类型：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207  /** * We expose a subset of properties on the internal instance as they are * useful for advanced external libraries and tools. */ export interface ComponentInternalInstance { uid: number; type: ConcreteComponent; parent: ComponentInternalInstance | null; root: ComponentInternalInstance; appContext: AppContext; /** * Vnode representing this component in its parent\u0026#39;s vdom tree */ vnode: VNode; /** * The pending new vnode from parent updates * @internal */ next: VNode | null; /** * Root vnode of this component\u0026#39;s own vdom tree */ subTree: VNode; /** * The reactive effect for rendering and patching the component. Callable. */ update: ReactiveEffect; /** * The render function that returns vdom tree. * @internal */ render: InternalRenderFunction | null; /** * SSR render function * @internal */ ssrRender?: Function | null; /** * Object containing values this component provides for its descendents * @internal */ provides: Data; /** * Tracking reactive effects (e.g. watchers) associated with this component * so that they can be automatically stopped on component unmount * @internal */ effects: ReactiveEffect[] | null; /** * cache for proxy access type to avoid hasOwnProperty calls * @internal */ accessCache: Data | null; /** * cache for render function values that rely on _ctx but won\u0026#39;t need updates * after initialized (e.g. inline handlers) * @internal */ renderCache: (Function | VNode)[]; /** * Resolved component registry, only for components with mixins or extends * @internal */ components: Record\u0026lt;string, ConcreteComponent\u0026gt; | null; /** * Resolved directive registry, only for components with mixins or extends * @internal */ directives: Record\u0026lt;string, Directive\u0026gt; | null; /** * reoslved props options * @internal */ propsOptions: NormalizedPropsOptions; /** * resolved emits options * @internal */ emitsOptions: ObjectEmitsOptions | null; // the rest are only for stateful components ---------------------------------  // main proxy that serves as the public instance (`this`)  proxy: ComponentPublicInstance | null; // exposed properties via expose()  exposed: Record\u0026lt;string, any\u0026gt; | null; /** * alternative proxy used only for runtime-compiled render functions using * `with` block * @internal */ withProxy: ComponentPublicInstance | null; /** * This is the target for the public instance proxy. It also holds properties * injected by user options (computed, methods etc.) and user-attached * custom properties (via `this.x = ...`) * @internal */ ctx: Data; // state  data: Data; props: Data; attrs: Data; slots: InternalSlots; refs: Data; emit: EmitFn; /** * used for keeping track of .once event handlers on components * @internal */ emitted: Record\u0026lt;string, boolean\u0026gt; | null; /** * setup related * @internal */ setupState: Data; /** * devtools access to additional info * @internal */ devtoolsRawSetupState?: any; /** * @internal */ setupContext: SetupContext | null; /** * suspense related * @internal */ suspense: SuspenseBoundary | null; /** * suspense pending batch id * @internal */ suspenseId: number; /** * @internal */ asyncDep: Promise\u0026lt;any\u0026gt; | null; /** * @internal */ asyncResolved: boolean; // lifecycle  isMounted: boolean; isUnmounted: boolean; isDeactivated: boolean; /** * @internal */ [LifecycleHooks.BEFORE_CREATE]: LifecycleHook; /** * @internal */ [LifecycleHooks.CREATED]: LifecycleHook; /** * @internal */ [LifecycleHooks.BEFORE_MOUNT]: LifecycleHook; /** * @internal */ [LifecycleHooks.MOUNTED]: LifecycleHook; /** * @internal */ [LifecycleHooks.BEFORE_UPDATE]: LifecycleHook; /** * @internal */ [LifecycleHooks.UPDATED]: LifecycleHook; /** * @internal */ [LifecycleHooks.BEFORE_UNMOUNT]: LifecycleHook; /** * @internal */ [LifecycleHooks.UNMOUNTED]: LifecycleHook; /** * @internal */ [LifecycleHooks.RENDER_TRACKED]: LifecycleHook; /** * @internal */ [LifecycleHooks.RENDER_TRIGGERED]: LifecycleHook; /** * @internal */ [LifecycleHooks.ACTIVATED]: LifecycleHook; /** * @internal */ [LifecycleHooks.DEACTIVATED]: LifecycleHook; /** * @internal */ [LifecycleHooks.ERROR_CAPTURED]: LifecycleHook; }      emit fn 事件\n1 2 3 4 5 6 7 8 9 10 11 12 13 14  export type EmitFn\u0026lt; Options = ObjectEmitsOptions, Event extends keyof Options = keyof Options \u0026gt; = Options extends Array\u0026lt;infer V\u0026gt; ? (event: V, ...args: any[]) =\u0026gt; void : {} extends Options // if the emit is empty object (usually the default value for emit) should be converted to function  ? (event: string, ...args: any[]) =\u0026gt; void : UnionToIntersection\u0026lt; { [key in Event]: Options[key] extends (...args: infer Args) =\u0026gt; any ? (event: key, ...args: Args) =\u0026gt; void : (event: key, ...args: any[]) =\u0026gt; void; }[Event] \u0026gt;;        ","permalink":"https://www.cheng92.com/vue/vue-mind-map-runtime-core-1/","tags":["vue,","vue3,","runtime-core"],"title":"Vue3 源码头脑风暴之 7 ☞ runtime-core(1)"},{"categories":["vue"],"contents":"  诗号：六道同坠，魔劫万千，引渡如来。  \n   stb-vue-next 完全拷贝于 vue-next ，主要目的用于学习。 \n 声明 ：vue-next compiler-ssr 服务端渲染模块，相关的所有测试代码均在 /js/vue/ 目录下面。\n 更新日志\u0026amp;Todos ：\n  [2021-01-04 20:11:43] 创建\n  [2021-01-08 10:11:47] 完成\n    模块初始化：feat(init): compiler-ssr · gcclll/stb-vue-next@dff9d31 · GitHub\n 脑图：\n Tip    ssr 不处理 v-on/v-once/v-cloak 三个指令\n  v-show 转成 exp ? \u0026#39;null\u0026#39; : {display: \u0026#39;none\u0026#39;} 合并到 style\n  \u0026lt;Suspense\u0026gt; 组件，会将所有 children 放到一个 await 函数里面执行\n  \u0026lt;Teleport\u0026gt; 作用？\n    05db578 compiler-ssr init   feat(init): compiler-ssr -\u0026gt; compile function · gcclll/stb-vue-next@05db578 · GitHub\n 源码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43  export function compile( template: string, options: CompilerOptions = {} ): CodegenResult { options = { ...options, // 引用 DOM parser 选项  ...parserOptions, ssr: true, scopeId: options.mode === \u0026#39;function\u0026#39; ? null : options.scopeId, // 总是加上前缀，ssr 不需要关系大小  prefixIdentifiers: true, // ssr 下不需要缓存和静态提升优化  cacheHandlers: false, hoistStatic: false } const ast = baseParse(template, options) // TODO Save raw options for AST. This is needed when performing sub-transforms  // on slot vnode branches.  transform(ast, { ...options, nodeTransforms: [ // TODO ... ssr transforms  ...(options.nodeTransforms || []) // user transforms  ], directiveTransforms: { // 复用 compiler-core 的 v-bind  bind: transformBind, // TODO ... more ssr directive transforms  ...(options.directiveTransforms || {}) // user transforms  } }) // TODO traverse the template AST and convert into SSR codegen AST  // by replacing ast.codegenNode.  // 将 compiler-core 阶段生成的 codegenNode 转换成 SSR codegen AST  return generate(ast, options) }     沿用 compiler-core 的三个阶段(parse -\u0026gt; transform -\u0026gt; generate)，另加上 SSR 渲染相 关的选项和其对应的 transforms 函数。\nssr text testing  1 2 3 4 5 6 7 8 9 10 11 12 13  // 源文件：/js/vue/lib.js const { compileSFCScript, compileStyle, getCompiledSSRString: ssr, compileSSR, log, } = require(process.env.BLOG_JS + \u0026#34;/vue/lib.js\u0026#34;); const { code, matched, ast } = ssr(\u0026#34;foo\u0026#34;); log([\u0026#34;codegenNode: \u0026#34;, ast.codegenNode || \u0026#34;null\u0026#34;]); log(\u0026#39;\u0026gt;\u0026gt;\u0026gt; render function\u0026#39;) log(code)    codegenNode: null \u0026gt;\u0026gt;\u0026gt; render function return function ssrRender(_ctx, _push, _parent, _attrs) { null } undefined   结果显示没有 codegenNode， ssrRender 函数体内也就啥都没有。\n FIX: 应该需要需要实现 ssrCodegenTransform 。\n 后面的所有测试都会依赖下面的正则(官方用例中的代码)：\n /_push\\(\\`\u0026lt;div\\${\\s*_ssrRenderAttrs\\(_attrs\\)\\s*}\u0026gt;([^]*)\u0026lt;\\/div\u0026gt;\\`\\)/\n      54ad7e2 coding ssrCodegenTransform function   feat(add): compiler-ssr-\u0026gt; ssrCodegenTransform function · gcclll/stb-vue-next@54ad7e2 · GitHub\n 生成 ssr codegenNode 的 transform 函数。\n 大致流程和 compiler-core 差不多。\n  创建上下文 context = createSSRTransformContext(ast, options)\n  options.ssrCssVars 样式变量处理\n  如果多个且至少有一个为非文本节点，需要用到 fragment\n  processChildren 递归处理所有孩子节点，生成 codegenNode , 所以这里是 核心\n  helpers 合并\n  1 2 3 4 5 6 7 8 9 10 11 12 13  // 源文件：/js/vue/lib.js const { compileSFCScript, compileStyle, getCompiledSSRString, compileSSR: ssr, log, } = require(process.env.BLOG_JS + \u0026#34;/vue/lib.js\u0026#34;); const { code, ast, matched } = ssr(\u0026#34;foo\u0026#34;); log([\u0026#34;\u0026gt;\u0026gt;\u0026gt; ast.children\\n\u0026#34;, ast.children]); log([\u0026#34;\u0026gt;\u0026gt;\u0026gt; ast.codegenNode.body\\n\u0026#34;, ast.codegenNode.body]); log([\u0026#34;\u0026gt;\u0026gt;\u0026gt; code\\n\u0026#34;, code]);    \u0026gt;\u0026gt;\u0026gt; ast.children [ { type: 2, content: \u0026#39;foo\u0026#39;, loc: { start: [Object], end: [Object], source: \u0026#39;foo\u0026#39; } } ] \u0026gt;\u0026gt;\u0026gt; ast.codegenNode.body [ { type: 14, loc: { source: \u0026#39;\u0026#39;, start: [Object], end: [Object] }, callee: \u0026#39;_push\u0026#39;, arguments: [ [Object] ] } ] \u0026gt;\u0026gt;\u0026gt; code return function ssrRender(_ctx, _push, _parent, _attrs) { _push(`foo`) } undefined   Bug1: body 里面没东西, fix: body null · gcclll/stb-vue-next@f6d22c1 · GitHub\n Bug2: div 没有被解析到，因为没有实现 ssrTransformElement 所有这里要先实现它， 测试用例中默认是 \u0026lt;div\u0026gt;${src}\u0026lt;/div\u0026gt; 包起来的。\n 因为测试函数 getCompiledSSRString 中会将 src 用 \u0026lt;div\u0026gt; 包裹起来，所以需要先实 现 div 的解析，即 NodeTypes.ELEMENT 类型解析。\n   561d41b ELEMENT: ssrTransformElement   feat(add): ssr-\u0026gt;ssrTransformElement · gcclll/stb-vue-next@561d41b · GitHub\n 新增两个函数实现：\n  ssrProcessElement 处理标签\n  ssrPostTransformElement ELEMENT 的转换函数\n  1 2 3 4 5 6 7 8 9 10  const { compileSFCScript, compileStyle, getCompiledSSRString: ssrs, compileSSR: ssr, log, } = require(process.env.BLOG_JS + \u0026#34;/vue/lib.js\u0026#34;); const { code, ast, matched } = ssrs(\u0026#34;foo\u0026#34;); log([\u0026#34;\u0026gt;\u0026gt;\u0026gt; code\\n\u0026#34;, code]);    \u0026gt;\u0026gt;\u0026gt; code return function ssrRender(_ctx, _push, _parent, _attrs) { _push(`\u0026lt;div\u0026gt;foo\u0026lt;/div\u0026gt;`) } undefined   还是没有 _ssrRenderAttrs 匹配失败，与期待结果还差一步：属性解析。\n feat(add): directives and node transforms from compiler-core · gcclll/stb-vue-next@dc15719 · GitHub\n  ea6bb01 add ssrInjectFallthroughAttrs 注入属性   feat(add): ssr-\u0026gt; add ssrInjectFallthroughAttrs · gcclll/stb-vue-next@ea6bb01 · GitHub\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19  export const ssrInjectFallthroughAttrs: NodeTransform = (node, context) =\u0026gt; { // _attrs is provided as a function argument.  // mark it as a known identifier so that it doesn\u0026#39;t get prefixed by  // transformExpression.  if (node.type === NodeTypes.ROOT) { context.identifiers._attrs = 1; } const parent = context.parent; if (!parent || parent.type !== NodeTypes.ROOT) { return; } if (node.type === NodeTypes.IF_BRANCH \u0026amp;\u0026amp; hasSingleChild(node)) { injectFallThroughAttrs(node.children[0]); } else if (hasSingleChild(parent)) { injectFallThroughAttrs(node); } };     这个函数是用来将 render 函数的 attrs 参数处理成 v-bind 指令。\n 前提条件：\n  必须要有 parent 父元素，即 ROOT 节点不会处理\n  且 parent 必须是 ROOT 节点，即 attrs 会注入到第一个最外层的元素上\n 比如：实例中的 \u0026lt;div\u0026gt;${src}\u0026lt;/div\u0026gt; ， render 函数中的 attrs 会被注入到这个 div 上，这也是 _ssrRenderAttrs 的由来。\n   测试：\n1 2 3 4 5 6 7 8 9 10 11  const { compileSFCScript, compileStyle, getCompiledSSRString: ssrs, compileSSR: ssr, log, } = require(process.env.BLOG_JS + \u0026#34;/vue/lib.js\u0026#34;); const { code, ast, matched } = ssrs(\u0026#34;foo\u0026#34;); log([\u0026#34;\u0026gt;\u0026gt;\u0026gt; code\\n\u0026#34;, code]); log([\u0026#39;\u0026gt;\u0026gt;\u0026gt; ast.children[0].props\\n\u0026#39;, ast.children[0].props])    \u0026gt;\u0026gt;\u0026gt; code return function ssrRender(_ctx, _push, _parent, _attrs) { _push(`\u0026lt;div\u0026gt;foo\u0026lt;/div\u0026gt;`) } \u0026gt;\u0026gt;\u0026gt; ast.children[0].props [ { type: 7, name: \u0026#39;bind\u0026#39;, arg: undefined, exp: { type: 4, loc: [Object], content: \u0026#39;_attrs\u0026#39;, isStatic: false, constType: 0 }, modifiers: [], loc: { source: \u0026#39;\u0026#39;, start: [Object], end: [Object] } } ] undefined   虽然结果还没达预期，但是上面结果显示已经有属性了，那么接下来就是要处理这个属性了， 这个在 ssrTransformElement 中处理。\n  7d20acd ELEMENT: ssrTransformElement\u0026gt;v-bind   feat(add): ssr-\u0026gt;element:v-bind · gcclll/stb-vue-next@7d20acd · GitHub\n 新增处理代码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27  // 需要运行时做特殊处理 const needTagForRuntime = node.tag === \u0026#34;textarea\u0026#34; || node.tag.indexOf(\u0026#34;-\u0026#34;) \u0026gt; 0; // 1. TODO v-bind // v-bind=\u0026#34;obj\u0026#34; or v-bind:[key] can potentially overwrite other static // attrs and can affect final rendering result, so when they are present // we need to bail out to full `renderAttrs` const hasDynamicVBind = hasDynamicKeyVBind(node); if (hasDynamicVBind) { const { props } = buildProps(node, context, node.props, true /* ssr */); if (props) { const propsExp = createCallExpression(context.helper(SSR_RENDER_ATTRS), [ props, ]); if (node.tag === \u0026#34;textarea\u0026#34;) { // TODO  } else if (node.tag === \u0026#34;input\u0026#34;) { // TODO  } if (needTagForRuntime) { propsExp.arguments.push(`\u0026#34;${node.tag}\u0026#34;`); } openTag.push(propsExp); } }     因为在上一节中将 attrs 注册为了 v-bind 属性，因此在 transform element 中就有 Props 需要处理了， ssrRenderAttrs 就是在这里增加了 SSR_RENDER_ATTRS 。\n1 2 3 4 5 6 7 8 9 10  const { compileSFCScript, compileStyle, getCompiledSSRString: ssrs, compileSSR: ssr, log, } = require(process.env.BLOG_JS + \u0026#34;/vue/lib.js\u0026#34;); const { code, ast, matched } = ssrs(\u0026#34;foo\u0026#34;); log([\u0026#34;\u0026gt;\u0026gt;\u0026gt; code\\n\u0026#34;, code]);    \u0026gt;\u0026gt;\u0026gt; code const { ssrRenderAttrs: _ssrRenderAttrs } = require(\u0026#34;@vue/server-renderer\u0026#34;) return function ssrRender(_ctx, _push, _parent, _attrs) { _push(`\u0026lt;div${_ssrRenderAttrs(_attrs)}\u0026gt;foo\u0026lt;/div\u0026gt;`) } undefined   到这里算是能满足测试用例中的正则要求了。\n _attrs 注入逻辑脑图：   f6d22c1 TEXT 节点类型解析   fix: body null · gcclll/stb-vue-next@f6d22c1 · GitHub\n 新增 pushStringPart 函数的实现，用来处理 NodeTypes.TEXT 节点类型。\n1 2 3 4 5  switch (child.type) { case NodeTypes.TEXT: context.pushStringPart(escapeHtml(child.content)); break; }     测试：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  // 源文件：/js/vue/lib.js const { compileSFCScript, compileStyle, getCompiledSSRString: ssrs, compileSSR, log, } = require(process.env.BLOG_JS + \u0026#34;/vue/lib.js\u0026#34;); log([\u0026#34;\u0026gt;\u0026gt;\u0026gt; 静态文本\\n\u0026#34;, ssrs(\u0026#34;foo\u0026#34;).code]); log([\u0026#34;\u0026gt;\u0026gt;\u0026gt; 静态文本，含反斜杠\\n\u0026#34;, ssrs(`\\\\$foo`).code]); log([\u0026#34;\u0026gt;\u0026gt;\u0026gt; 静态文本，\u0026amp;lt; 等符号的\\n\u0026#34;, ssrs(`\u0026amp;lt;foo\u0026amp;gt;`).code]); log([ \u0026#34;\u0026gt;\u0026gt;\u0026gt; 静态文本，元素嵌套\\n\u0026#34;, ssrs(`\u0026lt;div\u0026gt;\u0026lt;span\u0026gt;hello\u0026lt;/span\u0026gt;\u0026lt;span\u0026gt;bye\u0026lt;/span\u0026gt;\u0026lt;/div\u0026gt;`).code, ]);    \u0026gt;\u0026gt;\u0026gt; 静态文本 const { ssrRenderAttrs: _ssrRenderAttrs } = require(\u0026#34;@vue/server-renderer\u0026#34;) return function ssrRender(_ctx, _push, _parent, _attrs) { _push(`\u0026lt;div${_ssrRenderAttrs(_attrs)}\u0026gt;foo\u0026lt;/div\u0026gt;`) } \u0026gt;\u0026gt;\u0026gt; 静态文本，含反斜杠 const { ssrRenderAttrs: _ssrRenderAttrs } = require(\u0026#34;@vue/server-renderer\u0026#34;) return function ssrRender(_ctx, _push, _parent, _attrs) { _push(`\u0026lt;div${_ssrRenderAttrs(_attrs)}\u0026gt;\\\\\\$foo\u0026lt;/div\u0026gt;`) } \u0026gt;\u0026gt;\u0026gt; 静态文本，\u0026amp;lt; 等符号的 const { ssrRenderAttrs: _ssrRenderAttrs } = require(\u0026#34;@vue/server-renderer\u0026#34;) return function ssrRender(_ctx, _push, _parent, _attrs) { _push(`\u0026lt;div${_ssrRenderAttrs(_attrs)}\u0026gt;\u0026amp;lt;foo\u0026amp;gt;\u0026lt;/div\u0026gt;`) } \u0026gt;\u0026gt;\u0026gt; 静态文本，元素嵌套 const { ssrRenderAttrs: _ssrRenderAttrs } = require(\u0026#34;@vue/server-renderer\u0026#34;) return function ssrRender(_ctx, _push, _parent, _attrs) { _push(`\u0026lt;div${_ssrRenderAttrs(_attrs)}\u0026gt;\u0026lt;div\u0026gt;\u0026lt;span\u0026gt;hello\u0026lt;/span\u0026gt;\u0026lt;span\u0026gt;bye\u0026lt;/span\u0026gt;\u0026lt;/div\u0026gt;\u0026lt;/div\u0026gt;`) } undefined    8f09472 INTERPOLATION 插值处理   feat(add): ssr-\u0026gt;interpolation · gcclll/stb-vue-next@8f09472 · GitHub\n 增加代码：\n1 2 3 4 5  case NodeTypes.INTERPOLATION: context.pushStringPart( createCallExpression(context.helper(SSR_INTERPOLATE), [child.content]) ) break     测试：\n1 2 3 4 5 6 7 8 9 10 11  // 源文件：/js/vue/lib.js const { compileSFCScript, compileStyle, getCompiledSSRString: ssr, compileSSR, log, } = require(process.env.BLOG_JS + \u0026#34;/vue/lib.js\u0026#34;); log([\u0026#34;\u0026gt;\u0026gt;\u0026gt; 插值处理\\n\u0026#34;, ssr(`\\`\\${foo}\\``).code]) log([\u0026#34;\u0026gt;\u0026gt;\u0026gt; 插值处理，元素嵌套\\n\u0026#34;, ssr(`\u0026lt;div\u0026gt;\u0026lt;span\u0026gt;{{ foo }} bar\u0026lt;/span\u0026gt;\u0026lt;span\u0026gt;baz {{ qux }}\u0026lt;/span\u0026gt;\u0026lt;/div\u0026gt;`).code])    \u0026gt;\u0026gt;\u0026gt; 插值处理 const { ssrRenderAttrs: _ssrRenderAttrs } = require(\u0026#34;@vue/server-renderer\u0026#34;) return function ssrRender(_ctx, _push, _parent, _attrs) { _push(`\u0026lt;div${_ssrRenderAttrs(_attrs)}\u0026gt;\\`\\${foo}\\`\u0026lt;/div\u0026gt;`) } \u0026gt;\u0026gt;\u0026gt; 插值处理，元素嵌套 const { ssrRenderAttrs: _ssrRenderAttrs, ssrInterpolate: _ssrInterpolate } = require(\u0026#34;@vue/server-renderer\u0026#34;) return function ssrRender(_ctx, _push, _parent, _attrs) { _push(`\u0026lt;div${ _ssrRenderAttrs(_attrs) }\u0026gt;\u0026lt;div\u0026gt;\u0026lt;span\u0026gt;${ _ssrInterpolate(_ctx.foo) } bar\u0026lt;/span\u0026gt;\u0026lt;span\u0026gt;baz ${ _ssrInterpolate(_ctx.qux) }\u0026lt;/span\u0026gt;\u0026lt;/div\u0026gt;\u0026lt;/div\u0026gt;`) } undefined   第一个并非直接的差值，而是字符串形式，所以并没有当做插值处理。\n 后面的差值调用 _ssrInterpolate(_ctx.foo) 处理\n  ssrTransformElement 续  954a9ee static class 属性处理   feat(add): ssr-\u0026gt;static class attr · gcclll/stb-vue-next@954a9ee · GitHub\n 静态 class 属性处理:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29  for (let i = 0; i \u0026lt; node.props.length; i++) { const prop = node.props[i]; // 忽略 input 上的 true 值或 false 值  if (node.tag === \u0026#34;input\u0026#34; \u0026amp;\u0026amp; isTrueFalseValue(prop)) { continue; } // special cases with children override  if (prop.type === NodeTypes.DIRECTIVE) { // TODO 指令处理  } else { if (node.tag === \u0026#34;textarea\u0026#34; \u0026amp;\u0026amp; prop.name === \u0026#34;value\u0026#34; \u0026amp;\u0026amp; prop.value) { // TODO 特殊情况：value on \u0026lt;textarea\u0026gt;  } else if (!hasDynamicVBind) { if (prop.name === \u0026#34;key\u0026#34; || prop.name === \u0026#34;ref\u0026#34;) { continue; } // static prop  if (prop.name === \u0026#34;class\u0026#34; \u0026amp;\u0026amp; prop.value) { staticClassBinding = JSON.stringify(prop.value.content); } openTag.push( ` ${prop.name}` + (prop.value ? `=\u0026#34;${escapeHtml(prop.value.content)}\u0026#34;` : ``) ); } } }     class 处理部分：\n1 2 3 4 5 6 7  // static prop if (prop.name === \u0026#34;class\u0026#34; \u0026amp;\u0026amp; prop.value) { staticClassBinding = JSON.stringify(prop.value.content); } openTag.push( ` ${prop.name}` + (prop.value ? `=\u0026#34;${escapeHtml(prop.value.content)}\u0026#34;` : ``) );     等于是将 class=\u0026#34;bar\u0026#34; 原样添加到 openTag 中了，只不过这里对值用 escapeHtml 处 理了一下。\n 匹配： const escapeRE = /[\u0026#34;\u0026#39;\u0026amp;\u0026lt;\u0026gt;]/ 替换成对应的\n   char value     \u0026#34; \u0026amp;quot;   \u0026amp; \u0026amp;amp;   \u0026#39; \u0026amp;#39;   \u0026lt; \u0026amp;lt;   \u0026gt; \u0026amp;gt;     如下测试：\n1 2 3 4 5 6 7 8 9 10 11 12  // 源文件：/js/vue/lib.js const { compileSFCScript, compileStyle, getCompiledSSRString: ssr, compileSSR, log, } = require(process.env.BLOG_JS + \u0026#34;/vue/lib.js\u0026#34;); log([\u0026#34;\u0026gt;\u0026gt;\u0026gt; static class\\n\u0026#34;, ssr(\u0026#39;\u0026lt;div class=\u0026#34;bar\u0026#34;\u0026gt;\u0026lt;/div\u0026gt;\u0026lt;p class=\u0026#34;foo\u0026gt;\u0026#34;\u0026gt;\u0026lt;/p\u0026gt;\u0026#39;).code]); log([\u0026#39;\u0026gt;\u0026gt;\u0026gt; ref/key 属性会被忽略，不论静态还是动态\\n\u0026#39;, ssr(\u0026#39;\u0026lt;div key=\u0026#34;1\u0026#34; ref=\u0026#34;el\u0026#34;\u0026gt;\u0026lt;/div\u0026gt;\u0026#39;).code]) log([\u0026#39;\u0026gt;\u0026gt;\u0026gt; ref/key 属性会被忽略，不论静态还是动态\\n\u0026#39;, ssr(\u0026#39;\u0026lt;div :key=\u0026#34;1\u0026#34; :ref=\u0026#34;el\u0026#34;\u0026gt;\u0026lt;/div\u0026gt;\u0026#39;).code])    \u0026gt;\u0026gt;\u0026gt; static class const { ssrRenderAttrs: _ssrRenderAttrs } = require(\u0026#34;@vue/server-renderer\u0026#34;) return function ssrRender(_ctx, _push, _parent, _attrs) { _push(`\u0026lt;div${_ssrRenderAttrs(_attrs)}\u0026gt;\u0026lt;div class=\u0026#34;bar\u0026#34;\u0026gt;\u0026lt;/div\u0026gt;\u0026lt;p class=\u0026#34;foo\u0026amp;gt;\u0026#34;\u0026gt;\u0026lt;/p\u0026gt;\u0026lt;/div\u0026gt;`) } \u0026gt;\u0026gt;\u0026gt; ref/key 属性会被忽略，不论静态还是动态 const { ssrRenderAttrs: _ssrRenderAttrs } = require(\u0026#34;@vue/server-renderer\u0026#34;) return function ssrRender(_ctx, _push, _parent, _attrs) { _push(`\u0026lt;div${_ssrRenderAttrs(_attrs)}\u0026gt;\u0026lt;div\u0026gt;\u0026lt;/div\u0026gt;\u0026lt;/div\u0026gt;`) } \u0026gt;\u0026gt;\u0026gt; ref/key 属性会被忽略，不论静态还是动态 const { ssrRenderAttrs: _ssrRenderAttrs } = require(\u0026#34;@vue/server-renderer\u0026#34;) return function ssrRender(_ctx, _push, _parent, _attrs) { _push(`\u0026lt;div${_ssrRenderAttrs(_attrs)}\u0026gt;\u0026lt;div\u0026gt;\u0026lt;/div\u0026gt;\u0026lt;/div\u0026gt;`) } undefined    c28d528 dynamic class 属性处理   feat(add): ssr-\u0026gt;dynamic class · gcclll/stb-vue-next@c28d528 · GitHub\n 当既有 static 也有 dynamic class 时需要进行合并，且是将 static 往 dynamic 上进行 合并，最后成为动态的 class。\n 新增处理逻辑：\n1 2 3 4 5 6 7 8 9 10  if (attrName === \u0026#34;class\u0026#34;) { openTag.push( ` class=\u0026#34;`, (dynamicClassBinding = createCallExpression( context.helper(SSR_RENDER_CLASS), [value] )), `\u0026#34;` ); }     如果也有静态属性的时候，将两者合并，需要用到两个函数：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20  function mergeCall(call: CallExpression, arg: string | JSChildNode) { const existing = call.arguments[0] as ExpressionNode | ArrayExpression; if (existing.type === NodeTypes.JS_ARRAY_EXPRESSION) { existing.elements.push(arg); } else { call.arguments[0] = createArrayExpression([existing, arg]); } } function removeStaticBinding( tag: TemplateLiteral[\u0026#34;elements\u0026#34;], binding: string ) { const regExp = new RegExp(`^ ${binding}=\u0026#34;.+\u0026#34;$`); const i = tag.findIndex((e) =\u0026gt; typeof e === \u0026#34;string\u0026#34; \u0026amp;\u0026amp; regExp.test(e)); if (i \u0026gt; -1) { tag.splice(i, 1); } }     mergeCall: 将静态 class 合并到动态 class 上 removeStaticBinding: 删除原来的静态 class 属性\n 测试：\n1 2 3 4 5 6 7  // 源文件：/js/vue/lib.js const { compileSFCScript, compileStyle, getCompiledSSRString: ssr, compileSSR, log } = require(process.env.BLOG_JS + \u0026#39;/vue/lib.js\u0026#39;) log([\u0026#39;\u0026gt;\u0026gt;\u0026gt; dynamic class\\n\u0026#39;, ssr(\u0026#39;\u0026lt;div :class=\u0026#34;bar\u0026#34;\u0026gt;\u0026lt;/div\u0026gt;\u0026#39;).code]) log([\u0026#39;\u0026gt;\u0026gt;\u0026gt; static class\\n\u0026#39;, ssr(\u0026#39;\u0026lt;div class=\u0026#34;foo\u0026#34;\u0026gt;\u0026lt;/div\u0026gt;\u0026#39;).code]) log([\u0026#39;\u0026gt;\u0026gt;\u0026gt; static + dynamic class\\n\u0026#39;, ssr(\u0026#39;\u0026lt;div class=\u0026#34;foo\u0026#34; :class=\u0026#34;bar\u0026#34;\u0026gt;\u0026lt;/div\u0026gt;\u0026#39;).code])    \u0026gt;\u0026gt;\u0026gt; dynamic class const { ssrRenderClass: _ssrRenderClass, ssrRenderAttrs: _ssrRenderAttrs } = require(\u0026#34;@vue/server-renderer\u0026#34;) return function ssrRender(_ctx, _push, _parent, _attrs) { _push(`\u0026lt;div${ _ssrRenderAttrs(_attrs) }\u0026gt;\u0026lt;div class=\u0026#34;${ _ssrRenderClass(_ctx.bar) }\u0026#34;\u0026gt;\u0026lt;/div\u0026gt;\u0026lt;/div\u0026gt;`) } \u0026gt;\u0026gt;\u0026gt; static class const { ssrRenderAttrs: _ssrRenderAttrs } = require(\u0026#34;@vue/server-renderer\u0026#34;) return function ssrRender(_ctx, _push, _parent, _attrs) { _push(`\u0026lt;div${_ssrRenderAttrs(_attrs)}\u0026gt;\u0026lt;div class=\u0026#34;foo\u0026#34;\u0026gt;\u0026lt;/div\u0026gt;\u0026lt;/div\u0026gt;`) } \u0026gt;\u0026gt;\u0026gt; static + dynamic class const { ssrRenderClass: _ssrRenderClass, ssrRenderAttrs: _ssrRenderAttrs } = require(\u0026#34;@vue/server-renderer\u0026#34;) return function ssrRender(_ctx, _push, _parent, _attrs) { _push(`\u0026lt;div${ _ssrRenderAttrs(_attrs) }\u0026gt;\u0026lt;div class=\u0026#34;${ _ssrRenderClass([_ctx.bar, \u0026#34;foo\u0026#34;]) }\u0026#34;\u0026gt;\u0026lt;/div\u0026gt;\u0026lt;/div\u0026gt;`) } undefined   逻辑脑图：   ca39229 style 属性处理   feat(add): ssr-\u0026gt;style prop · gcclll/stb-vue-next@ca39229 · GitHub\n 新增处理代码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  if (attrName === \u0026#34;style\u0026#34;) { // :style  if (dynamicStyleBinding) { // 已经有 style 合并  mergeCall(dynamicStyleBinding, value); } else { openTag.push( ` style=\u0026#34;`, (dynamicStyleBinding = createCallExpression( context.helper(SSR_RENDER_STYLE), [value] )), `\u0026#34;` ); } }    1 2 3 4 5 6 7  // 源文件：/js/vue/lib.js const { compileSFCScript, compileStyle, getCompiledSSRString: ssr, compileSSR, log } = require(process.env.BLOG_JS + \u0026#39;/vue/lib.js\u0026#39;) log([\u0026#39;\u0026gt;\u0026gt;\u0026gt; static style\\n\u0026#39;, ssr(\u0026#39;\u0026lt;div style=\u0026#34;color:red\u0026#34;\u0026gt;\u0026lt;/div\u0026gt;\u0026#39;).code]) log([\u0026#39;\u0026gt;\u0026gt;\u0026gt; dynamic style\\n\u0026#39;, ssr(\u0026#39;\u0026lt;div :style=\u0026#34;bar\u0026#34;\u0026gt;\u0026lt;/div\u0026gt;\u0026#39;).code]) log([\u0026#39;\u0026gt;\u0026gt;\u0026gt; dynamic + static style\\n\u0026#39;, ssr(\u0026#39;\u0026lt;div :style=\u0026#34;bar\u0026#34; style=\u0026#34;color:red\u0026#34;\u0026gt;\u0026lt;/div\u0026gt;\u0026#39;).code])    \u0026gt;\u0026gt;\u0026gt; static style const { ssrRenderStyle: _ssrRenderStyle, ssrRenderAttrs: _ssrRenderAttrs } = require(\u0026#34;@vue/server-renderer\u0026#34;) return function ssrRender(_ctx, _push, _parent, _attrs) { _push(`\u0026lt;div${ _ssrRenderAttrs(_attrs) }\u0026gt;\u0026lt;div style=\u0026#34;${ _ssrRenderStyle({\u0026#34;color\u0026#34;:\u0026#34;red\u0026#34;}) }\u0026#34;\u0026gt;\u0026lt;/div\u0026gt;\u0026lt;/div\u0026gt;`) } \u0026gt;\u0026gt;\u0026gt; dynamic style const { ssrRenderStyle: _ssrRenderStyle, ssrRenderAttrs: _ssrRenderAttrs } = require(\u0026#34;@vue/server-renderer\u0026#34;) return function ssrRender(_ctx, _push, _parent, _attrs) { _push(`\u0026lt;div${ _ssrRenderAttrs(_attrs) }\u0026gt;\u0026lt;div style=\u0026#34;${ _ssrRenderStyle(_ctx.bar) }\u0026#34;\u0026gt;\u0026lt;/div\u0026gt;\u0026lt;/div\u0026gt;`) } \u0026gt;\u0026gt;\u0026gt; dynamic + static style const { ssrRenderStyle: _ssrRenderStyle, ssrRenderAttrs: _ssrRenderAttrs } = require(\u0026#34;@vue/server-renderer\u0026#34;) return function ssrRender(_ctx, _push, _parent, _attrs) { _push(`\u0026lt;div${ _ssrRenderAttrs(_attrs) }\u0026gt;\u0026lt;div style=\u0026#34;${ _ssrRenderStyle([_ctx.bar, {\u0026#34;color\u0026#34;:\u0026#34;red\u0026#34;}]) }\u0026#34;\u0026gt;\u0026lt;/div\u0026gt;\u0026lt;/div\u0026gt;`) } undefined    dfd4fb9 v-html 指令处理   feat(add): ssr-\u0026gt;v-html directive · gcclll/stb-vue-next@dfd4fb9 · GitHub\n 这个处理在 ssrTransformElement 中只需要增加一行代码就OK，但是需要结合 ssrProcessElement 来进行处理。\n1 2 3  if (prop.name === \u0026#34;html\u0026#34; \u0026amp;\u0026amp; prop.exp /* v-html */) { rawChildrenMap.set(node, prop.exp); }     ssrProcessElement 中会对 rawChildrenMap 进行处理：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  export function ssrProcessElement( node: PlainElementNode, context: SSRTransformContext ) { // ...  // 已缓存的处理结果  const rawChildren = rawChildrenMap.get(node); if (rawChildren) { context.pushStringPart(rawChildren); } else if (node.children.length) { processChildren(node.children, context); } // ... }     测试：\n1 2 3 4 5  // 源文件：/js/vue/lib.js const { compileSFCScript, compileStyle, getCompiledSSRString: ssr, compileSSR, log } = require(process.env.BLOG_JS + \u0026#39;/vue/lib.js\u0026#39;) log([\u0026#39;\u0026gt;\u0026gt;\u0026gt; v-html\\n\u0026#39;, ssr(\u0026#39;\u0026lt;div v-html=\u0026#34;foo\u0026#34;/\u0026gt;\u0026#39;).code])     直接进行值替换。\n   678e98a v-text 指令处理   feat(add): ssr-\u0026gt;v-text directive · gcclll/stb-vue-next@678e98a · GitHub\n 这里是用插值方式来处理了 v-text ：\n1 2 3  if (prop.name === \u0026#34;text\u0026#34; \u0026amp;\u0026amp; prop.exp /* v-text */) { node.children = [createInterpolation(prop.exp, prop.loc)]; }     测试：\n1 2 3 4 5  // 源文件：/js/vue/lib.js const { compileSFCScript, compileStyle, getCompiledSSRString: ssr, compileSSR, log } = require(process.env.BLOG_JS + \u0026#39;/vue/lib.js\u0026#39;) log(ssr(\u0026#39;\u0026lt;div v-text=\u0026#34;foo\u0026#34;/\u0026gt;\u0026#39;).code)    const { ssrRenderAttrs: _ssrRenderAttrs, ssrInterpolate: _ssrInterpolate } = require(\u0026#34;@vue/server-renderer\u0026#34;) return function ssrRender(_ctx, _push, _parent, _attrs) { _push(`\u0026lt;div${ _ssrRenderAttrs(_attrs) }\u0026gt;\u0026lt;div\u0026gt;${ _ssrInterpolate(_ctx.foo) }\u0026lt;/div\u0026gt;\u0026lt;/div\u0026gt;`) } undefined     0472dfd v-slot 指令错误   feat(add): ssr-\u0026gt;v-slot directive · gcclll/stb-vue-next@0472dfd · GitHub\n 由于指令不能应用于非 component 或 template 组件上，所以这里无法适用。\n  45e78e1 v-bind 指令   feat(add): ssr-\u0026gt;v-bind · gcclll/stb-vue-next@45e78e1 · GitHub\n 下面的测试为综合情况测试，包含大部分使用情况。\n  v-bind:arg(non-boolean)\n  v-bind:[arg] 动态参数处理\n  v-bind:[arg] + v-bind 混合方式\n  style + :style\n  class + :class\n  v-on 会被忽略\n  key/ref 无论静态动态都会被忽略\n  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24  // 源文件：/js/vue/lib.js const { compileSFCScript, compileStyle, getCompiledSSRString: ssr, compileSSR, log, } = require(process.env.BLOG_JS + \u0026#34;/vue/lib.js\u0026#34;); log( ssr(`\u0026lt;div style=\u0026#34;color:red\u0026#34; :style=\u0026#34;baz\u0026#34; class=\u0026#34;foo\u0026#34; :class=\u0026#34;bar\u0026#34; :[key]=\u0026#34;value\u0026#34; :id=\u0026#34;id\u0026#34; v-bind=\u0026#34;obj\u0026#34; v-on=\u0026#34;fxx\u0026#34; @click=\u0026#34;fxc\u0026#34; :key=\u0026#34;1\u0026#34; :ref=\u0026#34;el\u0026#34; \u0026gt;\u0026lt;/div\u0026gt;`).code );    const { mergeProps: _mergeProps } = require(\u0026#34;vue\u0026#34;) const { ssrRenderAttrs: _ssrRenderAttrs } = require(\u0026#34;@vue/server-renderer\u0026#34;) return function ssrRender(_ctx, _push, _parent, _attrs) { _push(`\u0026lt;div${ _ssrRenderAttrs(_attrs) }\u0026gt;\u0026lt;div${ _ssrRenderAttrs(_mergeProps({ style: [{\u0026#34;color\u0026#34;:\u0026#34;red\u0026#34;}, _ctx.baz], class: [\u0026#34;foo\u0026#34;, _ctx.bar], [_ctx.key || \u0026#34;\u0026#34;]: _ctx.value, id: _ctx.id }, _ctx.obj, { key: 1, ref: _ctx.el })) }\u0026gt;\u0026lt;/div\u0026gt;\u0026lt;/div\u0026gt;`) } undefined   key, ref 为什么没有忽略？？？\n    value on textarea   e79e343 static value   feat(add): ssr-\u0026gt;static value on textarea · gcclll/stb-vue-next@e79e343 · GitHub\n 静态 value 处理很简单，直接当做子节点替换。\n1 2 3 4  if (node.tag === \u0026#34;textarea\u0026#34; \u0026amp;\u0026amp; prop.name === \u0026#34;value\u0026#34; \u0026amp;\u0026amp; prop.value) { // 特殊情况：value on \u0026lt;textarea\u0026gt;  rawChildrenMap.set(node, escapeHtml(prop.value.content)); }     测试\n1 2 3 4 5  // 源文件：/js/vue/lib.js const { compileSFCScript, compileStyle, getCompiledSSRString:ssr, compileSSR, log } = require(process.env.BLOG_JS + \u0026#39;/vue/lib.js\u0026#39;) log([\u0026#39;\u0026gt;\u0026gt;\u0026gt; static value on textarea\\n\u0026#39;, ssr(\u0026#39;\u0026lt;textarea value=\u0026#34;fo\u0026amp;gt;o\u0026#34;/\u0026gt;\u0026#39;).code])    \u0026gt;\u0026gt;\u0026gt; static value on textarea const { ssrRenderAttrs: _ssrRenderAttrs } = require(\u0026#34;@vue/server-renderer\u0026#34;) return function ssrRender(_ctx, _push, _parent, _attrs) { _push(`\u0026lt;div${_ssrRenderAttrs(_attrs)}\u0026gt;\u0026lt;textarea\u0026gt;fo\u0026amp;gt;o\u0026lt;/textarea\u0026gt;\u0026lt;/div\u0026gt;`) } undefined    dynamic value   处理代码：\n1 2 3 4 5  if (isTextareaWithValue(node, prop) \u0026amp;\u0026amp; prop.exp /* textarea with value */) { if (!hasDynamicVBind) { node.children = [createInterpolation(prop.exp, prop.loc)]; } }     当做插值类型处理，作为孩子节点。\n1 2 3 4 5 6 7 8 9 10  // 源文件：/js/vue/lib.js const { compileSFCScript, compileStyle, getCompiledSSRString: ssr, compileSSR, log, } = require(process.env.BLOG_JS + \u0026#34;/vue/lib.js\u0026#34;); log(ssr(\u0026#39;\u0026lt;textarea :value=\u0026#34;foo\u0026#34;/\u0026gt;\u0026#39;).code);    const { ssrRenderAttrs: _ssrRenderAttrs, ssrInterpolate: _ssrInterpolate } = require(\u0026#34;@vue/server-renderer\u0026#34;) return function ssrRender(_ctx, _push, _parent, _attrs) { _push(`\u0026lt;div${ _ssrRenderAttrs(_attrs) }\u0026gt;\u0026lt;textarea\u0026gt;${ _ssrInterpolate(_ctx.foo) }\u0026lt;/textarea\u0026gt;\u0026lt;/div\u0026gt;`) } undefined    cdd8fd0 dynamic arg 动态参数   feat(add): ssr-\u0026gt;dynamic arg on textarea · gcclll/stb-vue-next@cdd8fd0 · GitHub\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39  if (node.tag === \u0026#34;textarea\u0026#34;) { // TODO  const existingText = node.children[0] as | TextNode | InterpolationNode | undefined; // If interpolation, this is dynamic \u0026lt;textarea\u0026gt; content, potentially  // injected by v-model and takes higher priority than v-bind value  // v-model 的优先级高于 v-bind value  if (!existingText || existingText.type !== NodeTypes.INTERPOLATION) { // \u0026lt;textarea\u0026gt; with dynamic v-bind. We don\u0026#39;t know if the final props  // will contain .value, so we will have to do something special:  // assign the merged props to a temp variable, and check whether  // it contains value (if yes, render is as children).  // 当 textarea 包含动态参数时，我们并不能确定最后的结果是否包含 .value  // 因此我们将不得不做些特殊处理来应对：  // 将已合并的 props 保存成一个临时变量，然后检查它是否包含 value 属性(如果  // 包含，则将它当做 children 来渲染)  const tempId = `_temp${context.temps++}`; propsExp.arguments = [ createAssignmentExpression(createSimpleExpression(tempId, false), props), ]; rawChildrenMap.set( node, createCallExpression(context.helper(SSR_INTERPOLATE), [ createConditionalExpression( createSimpleExpression(`\u0026#34;value\u0026#34; in ${tempId}`, false), createSimpleExpression(`${tempId}.value`, false), createSimpleExpression( existingText ? existingText.content : ``, true ), false ), ]) ); } }     在包含动态参数的时候，并不能确定最终参数名就是 value 所以需要做些特殊处理。\n1 2 3 4 5  // 源文件：/js/vue/lib.js const { compileSFCScript, compileStyle, getCompiledSSRString, compileSSR:ssr, log } = require(process.env.BLOG_JS + \u0026#39;/vue/lib.js\u0026#39;) log(ssr(`\u0026lt;textarea v-bind=\u0026#34;obj\u0026#34;\u0026gt;fallback\u0026lt;/textarea\u0026gt;`).code)    const { mergeProps: _mergeProps } = require(\u0026#34;vue\u0026#34;) const { ssrRenderAttrs: _ssrRenderAttrs, ssrInterpolate: _ssrInterpolate } = require(\u0026#34;@vue/server-renderer\u0026#34;) return function ssrRender(_ctx, _push, _parent, _attrs) { let _temp0 _push(`\u0026lt;textarea${ _ssrRenderAttrs(_temp0 = _mergeProps(_ctx.obj, _attrs), \u0026#34;textarea\u0026#34;) }\u0026gt;${ _ssrInterpolate((\u0026#34;value\u0026#34; in _temp0) ? _temp0.value : \u0026#34;fallback\u0026#34;) }\u0026lt;/textarea\u0026gt;`) } undefined   等于先将所有属性合并起来，在运行时决定是否有 value 属性，如果存在就使用这个值 内容填充 \u0026lt;textarea\u0026gt; 孩子节点，否则直接使用原来的孩子节点内容(如: \u0026#34;fallback\u0026#34;)\n 源码处理中有两个前提条件，才会这样处理\n  没有孩子节点\n  或者孩子节点不是插值类型\n  即如果有插值类型的孩子节点，是不会进行如上的处理的，看下面的实例：\n1 2 3 4 5  // 源文件：/js/vue/lib.js const { compileSFCScript, compileStyle, getCompiledSSRString, compileSSR: ssr, log } = require(process.env.BLOG_JS + \u0026#39;/vue/lib.js\u0026#39;) log(ssr(\u0026#39;\u0026lt;textarea v-bind=\u0026#34;obj\u0026#34;\u0026gt;{{ foo }}\u0026lt;/textarea\u0026gt;\u0026#39;).code)    const { mergeProps: _mergeProps } = require(\u0026#34;vue\u0026#34;) const { ssrRenderAttrs: _ssrRenderAttrs, ssrInterpolate: _ssrInterpolate } = require(\u0026#34;@vue/server-renderer\u0026#34;) return function ssrRender(_ctx, _push, _parent, _attrs) { _push(`\u0026lt;textarea${ _ssrRenderAttrs(_mergeProps(_ctx.obj, _attrs), \u0026#34;textarea\u0026#34;) }\u0026gt;${ _ssrInterpolate(_ctx.foo) }\u0026lt;/textarea\u0026gt;`) } undefined   结果如上 ↑。\n    b97d467 input + boolean attr   feat(add): ssr-\u0026gt;v-bind boolean on input · gcclll/stb-vue-next@b97d467 · GitHub\n1 2 3 4 5 6 7 8 9 10 11 12 13 14  // 源文件：/js/vue/lib.js const { compileSFCScript, compileStyle, getCompiledSSRString: ssr, compileSSR, log, } = require(process.env.BLOG_JS + \u0026#34;/vue/lib.js\u0026#34;); log([\u0026#34;\u0026gt;\u0026gt;\u0026gt; input\\n\u0026#34;, ssr(\u0026#34;\u0026lt;input\u0026gt;\u0026#34;).code]); log([ \u0026#34;\u0026gt;\u0026gt;\u0026gt; input with v-bind:arg(boolean)\\n\u0026#34;, ssr(`\u0026lt;input type=\u0026#34;checkbox\u0026#34; :checked=\u0026#34;checked\u0026#34;\u0026gt;`).code, ]);    \u0026gt;\u0026gt;\u0026gt; input const { ssrRenderAttrs: _ssrRenderAttrs } = require(\u0026#34;@vue/server-renderer\u0026#34;) return function ssrRender(_ctx, _push, _parent, _attrs) { _push(`\u0026lt;div${_ssrRenderAttrs(_attrs)}\u0026gt;\u0026lt;input\u0026gt;\u0026lt;/div\u0026gt;`) } \u0026gt;\u0026gt;\u0026gt; input with v-bind:arg(boolean) const { ssrRenderAttrs: _ssrRenderAttrs } = require(\u0026#34;@vue/server-renderer\u0026#34;) return function ssrRender(_ctx, _push, _parent, _attrs) { _push(`\u0026lt;div${ _ssrRenderAttrs(_attrs) }\u0026gt;\u0026lt;input type=\u0026#34;checkbox\u0026#34;${ (_ctx.checked) ? \u0026#34; checked\u0026#34; : \u0026#34;\u0026#34; }\u0026gt;\u0026lt;/div\u0026gt;`) } undefined   TODO 对于 v-bind + v-model 的结合使用，需要实现 ssrTransformModel 函数，这里暂时不做处理。\n   TODO e58d062 dynamic key attr   feat(add): ssr-\u0026gt;dynamic key attr · gcclll/stb-vue-next@e58d062 · GitHub\n    893681b v-model transform   feat(add): ssr-\u0026gt;v-model, text type · gcclll/stb-vue-next@893681b · GitHub\n1 2 3 4 5  // 源文件：/js/vue/lib.js const { compileSFCScript, compileStyle, getCompiledSSRString:ssr, compileSSR, log } = require(process.env.BLOG_JS + \u0026#39;/vue/lib.js\u0026#39;) log([\u0026#39;\u0026gt;\u0026gt;\u0026gt; \u0026lt;input\u0026gt; (text types，默认)\u0026#39;, ssr(`\u0026lt;input v-model=\u0026#34;bar\u0026#34;\u0026gt;`).code])     脑图：\n 7502230 input type: radio   feat(add): ssr-\u0026gt;v-model, type radio · gcclll/stb-vue-next@7502230 · GitHub\n v-model 根据 model表达式的值和 value 属性的值，判断最终转成 checked 属性 (\u0026lt;input type=\u0026#34;radio\u0026#34; checked\u0026gt;)。\n1 2 3 4 5 6 7 8 9 10 11 12 13  if (type.value) { // 静态类型  switch (type.value.content) { case \u0026#34;radio\u0026#34;: res.props = [ createObjectProperty( `checked`, createCallExpression(context.helper(SSR_LOOSE_EQUAL), [model, value]) ), ]; break; } }     测试：\n1 2 3 4 5  // 源文件：/js/vue/lib.js const { compileSFCScript, compileStyle, getCompiledSSRString:ssr, compileSSR, log } = require(process.env.BLOG_JS + \u0026#39;/vue/lib.js\u0026#39;) log(ssr(`\u0026lt;input type=\u0026#34;radio\u0026#34; value=\u0026#34;foo\u0026#34; v-model=\u0026#34;bar\u0026#34;\u0026gt;`).code)    const { ssrLooseEqual: _ssrLooseEqual, ssrRenderAttrs: _ssrRenderAttrs } = require(\u0026#34;@vue/server-renderer\u0026#34;) return function ssrRender(_ctx, _push, _parent, _attrs) { _push(`\u0026lt;div${ _ssrRenderAttrs(_attrs) }\u0026gt;\u0026lt;input type=\u0026#34;radio\u0026#34; value=\u0026#34;foo\u0026#34;${ (_ssrLooseEqual(_ctx.bar, \u0026#34;foo\u0026#34;)) ? \u0026#34; checked\u0026#34; : \u0026#34;\u0026#34; }\u0026gt;\u0026lt;/div\u0026gt;`) } undefined    input type: checkbox   类型为 checkbox 的时候要检查 true-value/false-value 属性。\n880eaf3 with true/false-value   feat(add): ssr-\u0026gt;v-model, type checkbox with true/false-value · gcclll/stb-vue-next@880eaf3 · GitHub\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24  switch (type.value.content) { // ...  case \u0026#34;checkbox\u0026#34;: const trueValueBinding = findProp(node, \u0026#34;true-value\u0026#34;); if (trueValueBinding) { const trueValue = trueValueBinding.type === NodeTypes.ATTRIBUTE ? JSON.stringify(trueValueBinding.value!.content) : trueValueBinding.exp!; res.props = [ createObjectProperty( `checked`, createCallExpression(context.helper(SSR_LOOSE_EQUAL), [ model, trueValue, ]) ), ]; } else { } break; // ... }     如果存在 true-value/false-value 的时候，检测条件就是这两个值的比较结果，只有这 两个值相等的情况下才会 checked 。\n1 2 3 4 5 6 7  // 源文件：/js/vue/lib.js const { compileSFCScript, compileStyle, getCompiledSSRString:ssr, compileSSR, log } = require(process.env.BLOG_JS + \u0026#39;/vue/lib.js\u0026#39;) log([\u0026#39;\u0026gt;\u0026gt;\u0026gt; v-bind true-value/false-value\\n\u0026#39;, ssr(`\u0026lt;input type=\u0026#34;checkbox\u0026#34; :true-value=\u0026#34;foo\u0026#34; :false-value=\u0026#34;bar\u0026#34; v-model=\u0026#34;baz\u0026#34;\u0026gt;`).code]) log([\u0026#39;\u0026gt;\u0026gt;\u0026gt; static true-value/false-value\\n\u0026#39;, ssr(`\u0026lt;input type=\u0026#34;checkbox\u0026#34; true-value=\u0026#34;foo\u0026#34; false-value=\u0026#34;bar\u0026#34; v-model=\u0026#34;baz\u0026#34;\u0026gt;`).code]) log([\u0026#39;\u0026gt;\u0026gt;\u0026gt; true-value/false-value 只有其中一个\\n\u0026#39;, ssr(`\u0026lt;input type=\u0026#34;checkbox\u0026#34; false-value=\u0026#34;bar\u0026#34; v-model=\u0026#34;baz\u0026#34;\u0026gt;`).code])    \u0026gt;\u0026gt;\u0026gt; v-bind true-value/false-value const { ssrLooseEqual: _ssrLooseEqual, ssrRenderAttrs: _ssrRenderAttrs } = require(\u0026#34;@vue/server-renderer\u0026#34;) return function ssrRender(_ctx, _push, _parent, _attrs) { _push(`\u0026lt;div${ _ssrRenderAttrs(_attrs) }\u0026gt;\u0026lt;input type=\u0026#34;checkbox\u0026#34;${ (_ssrLooseEqual(_ctx.baz, _ctx.foo)) ? \u0026#34; checked\u0026#34; : \u0026#34;\u0026#34; }\u0026gt;\u0026lt;/div\u0026gt;`) } \u0026gt;\u0026gt;\u0026gt; static true-value/false-value const { ssrLooseEqual: _ssrLooseEqual, ssrRenderAttrs: _ssrRenderAttrs } = require(\u0026#34;@vue/server-renderer\u0026#34;) return function ssrRender(_ctx, _push, _parent, _attrs) { _push(`\u0026lt;div${ _ssrRenderAttrs(_attrs) }\u0026gt;\u0026lt;input type=\u0026#34;checkbox\u0026#34;${ (_ssrLooseEqual(_ctx.baz, \u0026#34;foo\u0026#34;)) ? \u0026#34; checked\u0026#34; : \u0026#34;\u0026#34; }\u0026gt;\u0026lt;/div\u0026gt;`) } \u0026gt;\u0026gt;\u0026gt; true-value/false-value 只有其中一个 const { ssrLooseContain: _ssrLooseContain, ssrRenderAttrs: _ssrRenderAttrs } = require(\u0026#34;@vue/server-renderer\u0026#34;) return function ssrRender(_ctx, _push, _parent, _attrs) { _push(`\u0026lt;div${ _ssrRenderAttrs(_attrs) }\u0026gt;\u0026lt;input type=\u0026#34;checkbox\u0026#34;${ ((Array.isArray(_ctx.baz)) ? _ssrLooseContain(_ctx.baz, null) : _ctx.baz) ? \u0026#34; checked\u0026#34; : \u0026#34;\u0026#34; }\u0026gt;\u0026lt;/div\u0026gt;`) } undefined   ❓ 为什么 false-value 还在？\n FIX: fix: false.value -\u0026gt; false-value · gcclll/stb-vue-next@e0fc173 · GitHub\n  从结果看，貌似 false-value 并没有被用到，用到的只有 true-value 去和 v-model 表达式值进行比较。\n  59b1577 without true/false-value   feat(add): ssr-\u0026gt;v-model, type checkbox without true/false-value · gcclll/stb-vue-next@59b1577 · GitHub\n1 2 3 4 5 6 7 8 9 10  // 源文件：/js/vue/lib.js const { compileSFCScript, compileStyle, getCompiledSSRString: ssr, compileSSR, log, } = require(process.env.BLOG_JS + \u0026#34;/vue/lib.js\u0026#34;); log(ssr(`\u0026lt;input type=\u0026#34;checkbox\u0026#34; value=\u0026#34;foo\u0026#34; v-model=\u0026#34;bar\u0026#34;\u0026gt;`).code);    const { ssrLooseContain: _ssrLooseContain, ssrRenderAttrs: _ssrRenderAttrs } = require(\u0026#34;@vue/server-renderer\u0026#34;) return function ssrRender(_ctx, _push, _parent, _attrs) { _push(`\u0026lt;div${ _ssrRenderAttrs(_attrs) }\u0026gt;\u0026lt;input type=\u0026#34;checkbox\u0026#34; value=\u0026#34;foo\u0026#34;${ ((Array.isArray(_ctx.bar)) ? _ssrLooseContain(_ctx.bar, \u0026#34;foo\u0026#34;) : _ctx.bar) ? \u0026#34; checked\u0026#34; : \u0026#34;\u0026#34; }\u0026gt;\u0026lt;/div\u0026gt;`) } undefined   _ssrLooseContain(_ctx.bar, \u0026#34;foo\u0026#34;) 简单的数组找值操作：\n1 2 3  export function ssrLooseContain(arr: unknown[], value: unknown): boolean { return looseIndexOf(arr, value) \u0026gt; -1; }     相当于，如果 v-model=\u0026#34;bar\u0026#34; 的值 bar 是个数组，只需要其中有一个满足条件就会 checked ，这也是经常使用到的方式，将一组数据保存到一个数组里面，然后对应一组 checkboxs 用来控制这些组件的选中未选中状态。\n1 2 3 4 5 6 7 8 9 10 11 12  \u0026lt;template\u0026gt; \u0026lt;input type=\u0026#34;checkbox\u0026#34; value=\u0026#34;1\u0026#34; v-model=\u0026#34;checkedBoxes\u0026#34;\u0026gt; \u0026lt;input type=\u0026#34;checkbox\u0026#34; value=\u0026#34;2\u0026#34; v-model=\u0026#34;checkedBoxes\u0026#34;\u0026gt; \u0026lt;input type=\u0026#34;checkbox\u0026#34; value=\u0026#34;3\u0026#34; v-model=\u0026#34;checkedBoxes\u0026#34;\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script\u0026gt; export default { data() { return { checkedBoxes: [1, 2, 3] } } } \u0026lt;script\u0026gt;     就如上面的例子，只要 checkedBoxes 里面的值发生改变，就会触发 checkbox 状态更 新，且只有在数组内的值与当前 checkbox 的 value 属性值相等就会被选中，反之不会 被选中。\n    a0d4a40 input type: file 时不能用 v-model   feat(add): ssr-\u0026gt;v-model, type file with v-model error · gcclll/stb-vue-next@a0d4a40 · GitHub\n1 2 3 4 5 6 7 8 9 10 11 12 13 14  // 源文件：/js/vue/lib.js const { compileSFCScript, compileStyle, getCompiledSSRString: ssr, compileSSR, log, } = require(process.env.BLOG_JS + \u0026#34;/vue/lib.js\u0026#34;); try { ssr(\u0026#39;\u0026lt;input type=\u0026#34;file\u0026#34; v-model=\u0026#34;foo\u0026#34;\u0026gt;\u0026#39;); } catch (e) { console.log(e.message); }    v-model cannot be used on file inputs since they are read-only. Use a v-on:change listener instead. undefined    d7309be v-model on textarea   feat(add): ssr-\u0026gt;v-model on textarea · gcclll/stb-vue-next@d7309be · GitHub\n 当做插值处理，替换成孩子节点。\n1 2 3 4 5  // 源文件：/js/vue/lib.js const { compileSFCScript, compileStyle, getCompiledSSRString:ssr, compileSSR, log } = require(process.env.BLOG_JS + \u0026#39;/vue/lib.js\u0026#39;) log(ssr(`\u0026lt;textarea v-model=\u0026#34;foo\u0026#34;\u0026gt;bar\u0026lt;/textarea\u0026gt;`).code)    const { ssrRenderAttrs: _ssrRenderAttrs, ssrInterpolate: _ssrInterpolate } = require(\u0026#34;@vue/server-renderer\u0026#34;) return function ssrRender(_ctx, _push, _parent, _attrs) { _push(`\u0026lt;div${ _ssrRenderAttrs(_attrs) }\u0026gt;\u0026lt;textarea\u0026gt;${ _ssrInterpolate(_ctx.foo) }\u0026lt;/textarea\u0026gt;\u0026lt;/div\u0026gt;`) } undefined      169027e v-show transform   feat(add): ssr-\u0026gt;v-show · gcclll/stb-vue-next@169027e · GitHub\n v-show 指令的处理相对简单，根据指令表达式值，创建一个三元条件表达式，利用 display:none 属性隐藏元素(非删除操作)。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27  export const ssrTransformShow: DirectiveTransform = (dir, node, context) =\u0026gt; { if (!dir.exp) { context.onError( createDOMCompilerError(DOMErrorCodes.X_V_SHOW_NO_EXPRESSION) ); } return { props: [ createObjectProperty( `style`, // -\u0026gt; dir.exp ? `null` : `display:none`  createConditionalExpression( dir.exp!, createSimpleExpression(`null`, false), createObjectExpression([ createObjectProperty( `display`, createSimpleExpression(`none`, true) ), ]), false /* no newline */ ) ), ], }; };     测试：\n1 2 3 4 5 6 7  // 源文件：/js/vue/lib.js const { compileSFCScript, compileStyle, getCompiledSSRString:ssrs, compileSSR:ssr, log } = require(process.env.BLOG_JS + \u0026#39;/vue/lib.js\u0026#39;) log([\u0026#39;\u0026gt;\u0026gt;\u0026gt; basic 作为根节点\\n\u0026#39;, ssr(`\u0026lt;div v-show=\u0026#34;foo\u0026#34;/\u0026gt;`).code]) log([\u0026#39;\\n\u0026gt;\u0026gt;\u0026gt; basic 非根节点\\n\u0026#39;, ssrs(`\u0026lt;div v-show=\u0026#34;foo\u0026#34;/\u0026gt;`).code]) log([\u0026#39;\\n\u0026gt;\u0026gt;\u0026gt; basic 非根节点，包含静态和动态 style\\n\u0026#39;, ssrs(`\u0026lt;div v-show=\u0026#34;foo\u0026#34; style=\u0026#34;color:red\u0026#34; :style=\u0026#34;bar\u0026#34;/\u0026gt;`).code])    \u0026gt;\u0026gt;\u0026gt; basic 作为根节点 const { mergeProps: _mergeProps } = require(\u0026#34;vue\u0026#34;) const { ssrRenderAttrs: _ssrRenderAttrs } = require(\u0026#34;@vue/server-renderer\u0026#34;) return function ssrRender(_ctx, _push, _parent, _attrs) { _push(`\u0026lt;div${_ssrRenderAttrs(_mergeProps({ style: (_ctx.foo) ? null : { display: \u0026#34;none\u0026#34; } }, _attrs))}\u0026gt;\u0026lt;/div\u0026gt;`) } \u0026gt;\u0026gt;\u0026gt; basic 非根节点 const { ssrRenderStyle: _ssrRenderStyle, ssrRenderAttrs: _ssrRenderAttrs } = require(\u0026#34;@vue/server-renderer\u0026#34;) return function ssrRender(_ctx, _push, _parent, _attrs) { _push(`\u0026lt;div${ _ssrRenderAttrs(_attrs) }\u0026gt;\u0026lt;div style=\u0026#34;${ _ssrRenderStyle((_ctx.foo) ? null : { display: \u0026#34;none\u0026#34; }) }\u0026#34;\u0026gt;\u0026lt;/div\u0026gt;\u0026lt;/div\u0026gt;`) } \u0026gt;\u0026gt;\u0026gt; basic 非根节点，包含静态和动态 style const { ssrRenderStyle: _ssrRenderStyle, ssrRenderAttrs: _ssrRenderAttrs } = require(\u0026#34;@vue/server-renderer\u0026#34;) return function ssrRender(_ctx, _push, _parent, _attrs) { _push(`\u0026lt;div${ _ssrRenderAttrs(_attrs) }\u0026gt;\u0026lt;div style=\u0026#34;${ _ssrRenderStyle([ (_ctx.foo) ? null : { display: \u0026#34;none\u0026#34; }, {\u0026#34;color\u0026#34;:\u0026#34;red\u0026#34;}, _ctx.bar ]) }\u0026#34;\u0026gt;\u0026lt;/div\u0026gt;\u0026lt;/div\u0026gt;`) } undefined    5bf3644 v-if transform   feat(add): ssr-\u0026gt;v-if · gcclll/stb-vue-next@5bf3644 · GitHub\n ssrTransformIf 也是直接使用了 compiler-core: transformIf 进行处理。\n fix: ssr-\u0026gt;template v-if no ] · gcclll/stb-vue-next@094d5c0 · GitHub\n1 2 3 4 5 6  // Plugin for the first transform pass, which simply constructs the AST node // 先经过 core: transformIf 处理一道 export const ssrTransformIf = createStructuralDirectiveTransform( /^(if|else|else-if)$/, processIf )     剩下的 ssr 的部分，需要用到 ssrProcessIf() 进行单独处理。\n1 2 3 4 5  // 源文件：/js/vue/lib.js const { compileSFCScript, compileStyle, getCompiledSSRString, compileSSR:ssr, log } = require(process.env.BLOG_JS + \u0026#39;/vue/lib.js\u0026#39;) const { code, ast } = ssr(\u0026#39;\u0026lt;div v-if=\u0026#34;foo\u0026#34;\u0026gt;\u0026lt;/div\u0026gt;\u0026#39;) log([ast.children[0].branches[0], \u0026#39;\\n\u0026#39;, code])    { type: 10, loc: { start: { column: 1, line: 1, offset: 0 }, end: { column: 23, line: 1, offset: 22 }, source: \u0026#39;\u0026lt;div v-if=\u0026#34;foo\u0026#34;\u0026gt;\u0026lt;/div\u0026gt;\u0026#39; }, condition: { type: 4, content: \u0026#39;_ctx.foo\u0026#39;, isStatic: false, constType: 0, loc: { start: [Object], end: [Object], source: \u0026#39;foo\u0026#39; } }, children: [ { type: 1, ns: 0, tag: \u0026#39;div\u0026#39;, tagType: 0, props: [Array], isSelfClosing: false, children: [], loc: [Object], codegenNode: undefined, ssrCodegenNode: [Object] } ], userKey: undefined } const { ssrRenderAttrs: _ssrRenderAttrs } = require(\u0026#34;@vue/server-renderer\u0026#34;) return function ssrRender(_ctx, _push, _parent, _attrs) { } undefined   啥也没有？\n 但是从 ast.children[0].branches[0] 结果看确实被 core 正确处理了\n 所以还是需要实现 ssrProcessIf() 并且在 ssrCodegenTransform-\u0026gt;processChildren 增加 NodeTypes.IF 分支处理。\n 加上 ssrProcessIf 再测试一遍(测试均来自官方测试用例 ssrVIf.spec.ts 其他同)：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14  // 源文件：/js/vue/lib.js const { compileSFCScript, compileStyle, getCompiledSSRString, compileSSR:ssr, log } = require(process.env.BLOG_JS + \u0026#39;/vue/lib.js\u0026#39;) log([\u0026#39;\u0026gt;\u0026gt;\u0026gt; basic\\n\u0026#39;, ssr(\u0026#39;\u0026lt;div v-if=\u0026#34;foo\u0026#34;\u0026gt;\u0026lt;/div\u0026gt;\u0026#39;).code]) log([\u0026#39;\\n\u0026gt;\u0026gt;\u0026gt; with nested content\\n\u0026#39;, ssr(`\u0026lt;div v-if=\u0026#34;foo\u0026#34;\u0026gt;hello\u0026lt;span\u0026gt;ok\u0026lt;/span\u0026gt;\u0026lt;/div\u0026gt;`).code]) log([\u0026#39;\u0026gt;\u0026gt;\u0026gt; v-if + v-else\\n\u0026#39;, ssr(`\u0026lt;div v-if=\u0026#34;foo\u0026#34;/\u0026gt;\u0026lt;span v-else/\u0026gt;`).code]) log([\u0026#39;\u0026gt;\u0026gt;\u0026gt; v-if + v-else-if\\n\u0026#39;, ssr(`\u0026lt;div v-if=\u0026#34;foo\u0026#34;/\u0026gt;\u0026lt;span v-else-if=\u0026#34;bar\u0026#34;/\u0026gt;`).code]) log([\u0026#39;\u0026gt;\u0026gt;\u0026gt; v-if + v-else-if + v-else\\n\u0026#39;, ssr(`\u0026lt;div v-if=\u0026#34;foo\u0026#34;/\u0026gt;\u0026lt;span v-else-if=\u0026#34;bar\u0026#34;/\u0026gt;\u0026lt;span v-else/\u0026gt;`).code]) log([\u0026#39;\u0026gt;\u0026gt;\u0026gt; \u0026lt;template v-if\u0026gt;(text)\u0026#39;, ssr(`\u0026lt;template v-if=\u0026#34;foo\u0026#34;\u0026gt;hello\u0026lt;/template\u0026gt;`).code]) log([\u0026#39;\u0026gt;\u0026gt;\u0026gt; \u0026lt;template v-if\u0026gt;(single element)\u0026#39;, ssr(`\u0026lt;template v-if=\u0026#34;foo\u0026#34;\u0026gt;\u0026lt;div\u0026gt;hi\u0026lt;/div\u0026gt;\u0026lt;/template\u0026gt;`).code]) log([\u0026#39;\u0026gt;\u0026gt;\u0026gt; \u0026lt;template v-if\u0026gt;(multiple element)\u0026#39;, ssr(`\u0026lt;template v-if=\u0026#34;foo\u0026#34;\u0026gt;\u0026lt;div\u0026gt;hi\u0026lt;/div\u0026gt;\u0026lt;div\u0026gt;hi\u0026lt;/div\u0026gt;\u0026lt;div\u0026gt;ho\u0026lt;/div\u0026gt;\u0026lt;/template\u0026gt;`).code]) // v-for transform 到此还没实现，所以这个会报错 // log([\u0026#39;\u0026gt;\u0026gt;\u0026gt; \u0026lt;template v-if\u0026gt; (with v-for inside)\u0026#39;, ssr(`\u0026lt;template v-if=\u0026#34;foo\u0026#34;\u0026gt;\u0026lt;div v-for=\u0026#34;i in list\u0026#34;/\u0026gt;\u0026lt;/template\u0026gt;`).code]) log([\u0026#39;\u0026gt;\u0026gt;\u0026gt; \u0026lt;template v-if\u0026gt; + normal v-else\u0026#39;, ssr(`\u0026lt;template v-if=\u0026#34;foo\u0026#34;\u0026gt;\u0026lt;div\u0026gt;hi\u0026lt;/div\u0026gt;\u0026lt;/template\u0026gt;\u0026lt;div v-else/\u0026gt;`).code])    \u0026gt;\u0026gt;\u0026gt; basic const { ssrRenderAttrs: _ssrRenderAttrs } = require(\u0026#34;@vue/server-renderer\u0026#34;) return function ssrRender(_ctx, _push, _parent, _attrs) { if (_ctx.foo) { _push(`\u0026lt;div${_ssrRenderAttrs(_attrs)}\u0026gt;\u0026lt;/div\u0026gt;`) } else { _push(`\u0026lt;!----\u0026gt;`) } } \u0026gt;\u0026gt;\u0026gt; with nested content const { ssrRenderAttrs: _ssrRenderAttrs } = require(\u0026#34;@vue/server-renderer\u0026#34;) return function ssrRender(_ctx, _push, _parent, _attrs) { if (_ctx.foo) { _push(`\u0026lt;div${_ssrRenderAttrs(_attrs)}\u0026gt;hello\u0026lt;span\u0026gt;ok\u0026lt;/span\u0026gt;\u0026lt;/div\u0026gt;`) } else { _push(`\u0026lt;!----\u0026gt;`) } } \u0026gt;\u0026gt;\u0026gt; v-if + v-else const { ssrRenderAttrs: _ssrRenderAttrs } = require(\u0026#34;@vue/server-renderer\u0026#34;) return function ssrRender(_ctx, _push, _parent, _attrs) { if (_ctx.foo) { _push(`\u0026lt;div${_ssrRenderAttrs(_attrs)}\u0026gt;\u0026lt;/div\u0026gt;`) } else { _push(`\u0026lt;span${_ssrRenderAttrs(_attrs)}\u0026gt;\u0026lt;/span\u0026gt;`) } } \u0026gt;\u0026gt;\u0026gt; v-if + v-else-if const { ssrRenderAttrs: _ssrRenderAttrs } = require(\u0026#34;@vue/server-renderer\u0026#34;) return function ssrRender(_ctx, _push, _parent, _attrs) { if (_ctx.foo) { _push(`\u0026lt;div${_ssrRenderAttrs(_attrs)}\u0026gt;\u0026lt;/div\u0026gt;`) } else if (_ctx.bar) { _push(`\u0026lt;span${_ssrRenderAttrs(_attrs)}\u0026gt;\u0026lt;/span\u0026gt;`) } else { _push(`\u0026lt;!----\u0026gt;`) } } \u0026gt;\u0026gt;\u0026gt; v-if + v-else-if + v-else const { ssrRenderAttrs: _ssrRenderAttrs } = require(\u0026#34;@vue/server-renderer\u0026#34;) return function ssrRender(_ctx, _push, _parent, _attrs) { if (_ctx.foo) { _push(`\u0026lt;div${_ssrRenderAttrs(_attrs)}\u0026gt;\u0026lt;/div\u0026gt;`) } else if (_ctx.bar) { _push(`\u0026lt;span${_ssrRenderAttrs(_attrs)}\u0026gt;\u0026lt;/span\u0026gt;`) } else { _push(`\u0026lt;span${_ssrRenderAttrs(_attrs)}\u0026gt;\u0026lt;/span\u0026gt;`) } } \u0026gt;\u0026gt;\u0026gt; \u0026lt;template v-if\u0026gt;(text) return function ssrRender(_ctx, _push, _parent, _attrs) { if (_ctx.foo) { _push(`\u0026lt;!--[--\u0026gt;hello\u0026lt;!--]--\u0026gt;`) } else { _push(`\u0026lt;!----\u0026gt;`) } } \u0026gt;\u0026gt;\u0026gt; \u0026lt;template v-if\u0026gt;(single element) const { ssrRenderAttrs: _ssrRenderAttrs } = require(\u0026#34;@vue/server-renderer\u0026#34;) return function ssrRender(_ctx, _push, _parent, _attrs) { if (_ctx.foo) { _push(`\u0026lt;div${_ssrRenderAttrs(_attrs)}\u0026gt;hi\u0026lt;/div\u0026gt;`) } else { _push(`\u0026lt;!----\u0026gt;`) } } \u0026gt;\u0026gt;\u0026gt; \u0026lt;template v-if\u0026gt;(multiple element) return function ssrRender(_ctx, _push, _parent, _attrs) { if (_ctx.foo) { _push(`\u0026lt;!--[--\u0026gt;\u0026lt;div\u0026gt;hi\u0026lt;/div\u0026gt;\u0026lt;div\u0026gt;hi\u0026lt;/div\u0026gt;\u0026lt;div\u0026gt;ho\u0026lt;/div\u0026gt;\u0026lt;!--]--\u0026gt;`) } else { _push(`\u0026lt;!----\u0026gt;`) } } \u0026gt;\u0026gt;\u0026gt; \u0026lt;template v-if\u0026gt; + normal v-else const { ssrRenderAttrs: _ssrRenderAttrs } = require(\u0026#34;@vue/server-renderer\u0026#34;) return function ssrRender(_ctx, _push, _parent, _attrs) { if (_ctx.foo) { _push(`\u0026lt;div${_ssrRenderAttrs(_attrs)}\u0026gt;hi\u0026lt;/div\u0026gt;`) } else { _push(`\u0026lt;div${_ssrRenderAttrs(_attrs)}\u0026gt;\u0026lt;/div\u0026gt;`) } } undefined   为什么是 if(){}else{} ???\n 这个要追溯到 compiler-core: codegen.ts 里面对 ssr 环境下的 if 指令的处理代码：\n1 2 3 4 5  switch (node.type) { case NodeTypes.JS_IF_STATEMENT: !__BROWSER__ \u0026amp;\u0026amp; genIfStatement(node, context); break; }     这个 genIfStatement 就是用来生成 if...else 代码的。\n 脑图：  所以 ssr v-if 处理大致流程简单分两步：\n  core: transformIf 得到 node.branches\n  ssrProcessIf 处理，生成 if -\u0026gt; else if -\u0026gt; else\n    4839090 v-for transform   fix: ssr-\u0026gt;v-for add transform · gcclll/stb-vue-next@4839090 · GitHub\n 主要还是借助了 compiler-core: transformFor 处理逻辑，加上 ssrProcessFor 加工处理 了下。\n1 2 3 4 5 6 7 8 9 10 11 12  // 源文件：/js/vue/lib.js const { compileSFCScript, compileStyle, getCompiledSSRString, compileSSR:ssr, log } = require(process.env.BLOG_JS + \u0026#39;/vue/lib.js\u0026#39;) log([\u0026#39;\u0026gt;\u0026gt;\u0026gt; basic\\n\u0026#39;, ssr(`\u0026lt;div v-for=\u0026#34;i in list\u0026#34; /\u0026gt;`).code]) log([\u0026#39;\u0026gt;\u0026gt;\u0026gt; nested content\\n\u0026#39;, ssr(`\u0026lt;div v-for=\u0026#34;i in list\u0026#34;\u0026gt;foo\u0026lt;span\u0026gt;bar\u0026lt;/span\u0026gt;\u0026lt;/div\u0026gt;`).code]) log([\u0026#39;\u0026gt;\u0026gt;\u0026gt; nested v-for\\n\u0026#39;, ssr(`\u0026lt;div v-for=\u0026#34;row, i in list\u0026#34;\u0026gt;` + `\u0026lt;div v-for=\u0026#34;j in row\u0026#34;\u0026gt;{{ i }},{{ j }}\u0026lt;/div\u0026gt;` + `\u0026lt;/div\u0026gt;`).code]) log([\u0026#39;\u0026gt;\u0026gt;\u0026gt; template v-for(text)\\n\u0026#39;, ssr(`\u0026lt;template v-for=\u0026#34;i in list\u0026#34;\u0026gt;{{ i }}\u0026lt;/template\u0026gt;`).code]) log([\u0026#39;\u0026gt;\u0026gt;\u0026gt; template v-for (single element)\\n\u0026#39;, ssr(`\u0026lt;template v-for=\u0026#34;i in list\u0026#34;\u0026gt;\u0026lt;span\u0026gt;{{ i }}\u0026lt;/span\u0026gt;\u0026lt;/template\u0026gt;`).code]) log([\u0026#39;\u0026gt;\u0026gt;\u0026gt; template v-for (multi element)\\n\u0026#39;, ssr(`\u0026lt;template v-for=\u0026#34;i in list\u0026#34;\u0026gt;\u0026lt;span\u0026gt;{{ i }}\u0026lt;/span\u0026gt;\u0026lt;span\u0026gt;{{ i + 1 }}\u0026lt;/span\u0026gt;\u0026lt;/template\u0026gt;`).code]) log([\u0026#39;\u0026gt;\u0026gt;\u0026gt; render loop args should not be prefixed\\n\u0026#39;, \u0026#39;\u0026gt; render loop 循环回调的参数不应该加前缀\\n\u0026#39;, ssr(`\u0026lt;div v-for=\u0026#34;{ foo }, index in list\u0026#34;\u0026gt;{{ foo + bar + index }}\u0026lt;/div\u0026gt;`).code])    \u0026gt;\u0026gt;\u0026gt; basic const { ssrRenderList: _ssrRenderList } = require(\u0026#34;@vue/server-renderer\u0026#34;) return function ssrRender(_ctx, _push, _parent, _attrs) { _push(`\u0026lt;!--[--\u0026gt;`) _ssrRenderList(_ctx.list, (i) =\u0026gt; { _push(`\u0026lt;div\u0026gt;\u0026lt;/div\u0026gt;`) }) _push(`\u0026lt;!--]--\u0026gt;`) } \u0026gt;\u0026gt;\u0026gt; nested content const { ssrRenderList: _ssrRenderList } = require(\u0026#34;@vue/server-renderer\u0026#34;) return function ssrRender(_ctx, _push, _parent, _attrs) { _push(`\u0026lt;!--[--\u0026gt;`) _ssrRenderList(_ctx.list, (i) =\u0026gt; { _push(`\u0026lt;div\u0026gt;foo\u0026lt;span\u0026gt;bar\u0026lt;/span\u0026gt;\u0026lt;/div\u0026gt;`) }) _push(`\u0026lt;!--]--\u0026gt;`) } \u0026gt;\u0026gt;\u0026gt; nested v-for const { ssrInterpolate: _ssrInterpolate, ssrRenderList: _ssrRenderList } = require(\u0026#34;@vue/server-renderer\u0026#34;) return function ssrRender(_ctx, _push, _parent, _attrs) { _push(`\u0026lt;!--[--\u0026gt;`) _ssrRenderList(_ctx.list, (row, i) =\u0026gt; { _push(`\u0026lt;div\u0026gt;\u0026lt;!--[--\u0026gt;`) _ssrRenderList(row, (j) =\u0026gt; { _push(`\u0026lt;div\u0026gt;${ _ssrInterpolate(i) },${ _ssrInterpolate(j) }\u0026lt;/div\u0026gt;`) }) _push(`\u0026lt;!--]--\u0026gt;\u0026lt;/div\u0026gt;`) }) _push(`\u0026lt;!--]--\u0026gt;`) } \u0026gt;\u0026gt;\u0026gt; template v-for(text) const { ssrInterpolate: _ssrInterpolate, ssrRenderList: _ssrRenderList } = require(\u0026#34;@vue/server-renderer\u0026#34;) return function ssrRender(_ctx, _push, _parent, _attrs) { _push(`\u0026lt;!--[--\u0026gt;`) _ssrRenderList(_ctx.list, (i) =\u0026gt; { _push(`\u0026lt;!--[--\u0026gt;${_ssrInterpolate(i)}\u0026lt;!--]--\u0026gt;`) }) _push(`\u0026lt;!--]--\u0026gt;`) } \u0026gt;\u0026gt;\u0026gt; template v-for (single element) const { ssrInterpolate: _ssrInterpolate, ssrRenderList: _ssrRenderList } = require(\u0026#34;@vue/server-renderer\u0026#34;) return function ssrRender(_ctx, _push, _parent, _attrs) { _push(`\u0026lt;!--[--\u0026gt;`) _ssrRenderList(_ctx.list, (i) =\u0026gt; { _push(`\u0026lt;span\u0026gt;${_ssrInterpolate(i)}\u0026lt;/span\u0026gt;`) }) _push(`\u0026lt;!--]--\u0026gt;`) } \u0026gt;\u0026gt;\u0026gt; template v-for (multi element) const { ssrInterpolate: _ssrInterpolate, ssrRenderList: _ssrRenderList } = require(\u0026#34;@vue/server-renderer\u0026#34;) return function ssrRender(_ctx, _push, _parent, _attrs) { _push(`\u0026lt;!--[--\u0026gt;`) _ssrRenderList(_ctx.list, (i) =\u0026gt; { _push(`\u0026lt;!--[--\u0026gt;\u0026lt;span\u0026gt;${ _ssrInterpolate(i) }\u0026lt;/span\u0026gt;\u0026lt;span\u0026gt;${ _ssrInterpolate(i + 1) }\u0026lt;/span\u0026gt;\u0026lt;!--]--\u0026gt;`) }) _push(`\u0026lt;!--]--\u0026gt;`) } \u0026gt;\u0026gt;\u0026gt; render loop args should not be prefixed \u0026gt; render loop 循环回调的参数不应该加前缀 const { ssrInterpolate: _ssrInterpolate, ssrRenderList: _ssrRenderList } = require(\u0026#34;@vue/server-renderer\u0026#34;) return function ssrRender(_ctx, _push, _parent, _attrs) { _push(`\u0026lt;!--[--\u0026gt;`) _ssrRenderList(_ctx.list, ({ foo }, index) =\u0026gt; { _push(`\u0026lt;div\u0026gt;${_ssrInterpolate(foo + _ctx.bar + index)}\u0026lt;/div\u0026gt;`) }) _push(`\u0026lt;!--]--\u0026gt;`) } undefined   代码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40  export function ssrProcessFor( node: ForNode, context: SSRTransformContext, disableNestedFragments = false ) { // 需要 Fragment 的条件  // 1. disableNestedFragments = false  // 2. 有两个及以上的孩子节点或者第一个孩子节点的类型不是 ELEMENT（可能是用户组件）  const needFragmentWrapper = !disableNestedFragments \u0026amp;\u0026amp; (node.children.length !== 1 || node.children[0].type !== NodeTypes.ELEMENT) // 创建 for (...) 表达式  const renderLoop = createFunctionExpression( createForLoopParams(node.parseResult) ) renderLoop.body = processChildrenAsStatement( node.children, context, needFragmentWrapper ) // v-for always renders a fragment unless explicitly disabled  if (!disableNestedFragments) { context.pushStringPart(`\u0026lt;!--[--\u0026gt;`) } // 创建表达式  context.pushStatement( createCallExpression(context.helper(SSR_RENDER_LIST), [ node.source, renderLoop ]) ) if (!disableNestedFragments) { context.pushStringPart(`\u0026lt;!--]--\u0026gt;`) } }     v-for 处理除了 tranformFor 剩下的处理都在这个 ssrProcessFor 里面了。\n  8036837 其他不需要处理的情况   fix: ssr-\u0026gt;add other useless cases in process children · gcclll/stb-vue-next@8036837 · GitHub\n 比如：\n  IF_BRANCH 在 ssrProcessIf 中被处理了\n  TEXT_CALL 和 COMPOUND_EXPRESSION 在 ssr 中不会被用到\n  COMMENT 注释简单的还原处理即可\n    TODO 16833be component transform   fix: ssr-\u0026gt;component transform · gcclll/stb-vue-next@16833be · GitHub\n 1 2 3 4 5 6 7  // 源文件：/js/vue/lib.js const { compileSFCScript, compileStyle, getCompiledSSRString, compileSSR: ssr, log } = require(process.env.BLOG_JS + \u0026#39;/vue/lib.js\u0026#39;) log([\u0026#39;\u0026gt;\u0026gt;\u0026gt; basic\\n\u0026#39;, ssr(`\u0026lt;foo id=\u0026#34;a\u0026#34; :prop=\u0026#34;b\u0026#34; /\u0026gt;`).code]) log([\u0026#39;\u0026gt;\u0026gt;\u0026gt; 动态组件 is\\n\u0026#39;, ssr(`\u0026lt;component is=\u0026#34;foo\u0026#34; prop=\u0026#34;b\u0026#34; /\u0026gt;`).code]) log([\u0026#39;\u0026gt;\u0026gt;\u0026gt; 动态组件 :is\\n\u0026#39;, ssr(`\u0026lt;component :is=\u0026#34;foo\u0026#34; prop=\u0026#34;b\u0026#34; /\u0026gt;`).code])    \u0026gt;\u0026gt;\u0026gt; basic const { resolveComponent: _resolveComponent, mergeProps: _mergeProps } = require(\u0026#34;vue\u0026#34;) const { ssrRenderComponent: _ssrRenderComponent } = require(\u0026#34;@vue/server-renderer\u0026#34;) return function ssrRender(_ctx, _push, _parent, _attrs) { const _component_foo = _resolveComponent(\u0026#34;foo\u0026#34;) _push(_ssrRenderComponent(_component_foo, _mergeProps({ id: \u0026#34;a\u0026#34;, prop: _ctx.b }, _attrs), null, _parent)) } \u0026gt;\u0026gt;\u0026gt; 动态组件 is const { resolveDynamicComponent: _resolveDynamicComponent, mergeProps: _mergeProps, createVNode: _createVNode } = require(\u0026#34;vue\u0026#34;) const { ssrRenderVNode: _ssrRenderVNode } = require(\u0026#34;@vue/server-renderer\u0026#34;) return function ssrRender(_ctx, _push, _parent, _attrs) { _ssrRenderVNode(_push, _createVNode(_resolveDynamicComponent(\u0026#34;foo\u0026#34;), _mergeProps({ prop: \u0026#34;b\u0026#34; }, _attrs), null), _parent) } \u0026gt;\u0026gt;\u0026gt; 动态组件 :is const { resolveDynamicComponent: _resolveDynamicComponent, mergeProps: _mergeProps, createVNode: _createVNode } = require(\u0026#34;vue\u0026#34;) const { ssrRenderVNode: _ssrRenderVNode } = require(\u0026#34;@vue/server-renderer\u0026#34;) return function ssrRender(_ctx, _push, _parent, _attrs) { _ssrRenderVNode(_push, _createVNode(_resolveDynamicComponent(_ctx.foo), _mergeProps({ prop: \u0026#34;b\u0026#34; }, _attrs), null), _parent) } undefined    cdba013 component slot outlet   feat(add): ssr-\u0026gt;slot outlet transform · gcclll/stb-vue-next@cdba013 · GitHub\n \u0026lt;slot\u0026gt;\u0026lt;/slot\u0026gt; 插槽处理。\n 处理逻辑：\n  transform 阶段 -\u0026gt; ssrTransformSlotOutlet\n 这里还只是创建了 ssrCodegenNode 并没有实际创建 render 函数\n1  _ssrRenderSlot(_ctx.$slots, slotName, slotProps, fallback, _push, _parent)      codegen 处理 -\u0026gt; ssrCodgenTransform\n 这个阶段是扩展 1 中的第四个参数，也就是 fallback，检测 \u0026lt;slot\u0026gt;\u0026lt;/slot\u0026gt; 下是不 是有孩子节点，如果有当做 fallback 处理，替换 node.ssrCodegenNode.arguments[3] 的值。\n   1 2 3 4 5 6 7 8 9  // 源文件：/js/vue/lib.js const { compileSFCScript, compileStyle, getCompiledSSRString, compileSSR:ssr, log } = require(process.env.BLOG_JS + \u0026#39;/vue/lib.js\u0026#39;) log([\u0026#39;\u0026gt;\u0026gt;\u0026gt; basic\\n\u0026#39;, ssr(`\u0026lt;slot/\u0026gt;`).code]) log([\u0026#39;\u0026gt;\u0026gt;\u0026gt; with named\\n\u0026#39;, ssr(`\u0026lt;slot name=\u0026#34;foo\u0026#34;/\u0026gt;`).code]) log([\u0026#39;\u0026gt;\u0026gt;\u0026gt; with dynamic named\\n\u0026#39;, ssr(`\u0026lt;slot :name=\u0026#34;bar.baz\u0026#34;/\u0026gt;`).code]) log([\u0026#39;\u0026gt;\u0026gt;\u0026gt; with props and fallback\\n\u0026#39;, ssr(`\u0026lt;slot name=\u0026#34;foo\u0026#34; :p1=\u0026#34;1\u0026#34; bar=\u0026#34;2\u0026#34; \u0026gt;some {{ fallback }} content\u0026lt;/slot\u0026gt;`).code]) log([\u0026#39;\u0026gt;\u0026gt;\u0026gt; with fallback\\n\u0026#39;, ssr(`\u0026lt;slot\u0026gt;some {{ fallback }} content\u0026lt;/slot\u0026gt;`).code])    \u0026gt;\u0026gt;\u0026gt; basic const { ssrRenderSlot: _ssrRenderSlot } = require(\u0026#34;@vue/server-renderer\u0026#34;) return function ssrRender(_ctx, _push, _parent, _attrs) { _ssrRenderSlot(_ctx.$slots, \u0026#34;default\u0026#34;, {}, null, _push, _parent) } \u0026gt;\u0026gt;\u0026gt; with named const { ssrRenderSlot: _ssrRenderSlot } = require(\u0026#34;@vue/server-renderer\u0026#34;) return function ssrRender(_ctx, _push, _parent, _attrs) { _ssrRenderSlot(_ctx.$slots, \u0026#34;foo\u0026#34;, {}, null, _push, _parent) } \u0026gt;\u0026gt;\u0026gt; with dynamic named const { ssrRenderSlot: _ssrRenderSlot } = require(\u0026#34;@vue/server-renderer\u0026#34;) return function ssrRender(_ctx, _push, _parent, _attrs) { _ssrRenderSlot(_ctx.$slots, _ctx.bar.baz, {}, null, _push, _parent) } \u0026gt;\u0026gt;\u0026gt; with props and fallback const { ssrRenderSlot: _ssrRenderSlot, ssrInterpolate: _ssrInterpolate } = require(\u0026#34;@vue/server-renderer\u0026#34;) return function ssrRender(_ctx, _push, _parent, _attrs) { _ssrRenderSlot(_ctx.$slots, \u0026#34;foo\u0026#34;, { p1: 1, bar: \u0026#34;2\u0026#34; }, () =\u0026gt; { _push(`some ${_ssrInterpolate(_ctx.fallback)} content`) }, _push, _parent) } \u0026gt;\u0026gt;\u0026gt; with fallback const { ssrRenderSlot: _ssrRenderSlot, ssrInterpolate: _ssrInterpolate } = require(\u0026#34;@vue/server-renderer\u0026#34;) return function ssrRender(_ctx, _push, _parent, _attrs) { _ssrRenderSlot(_ctx.$slots, \u0026#34;default\u0026#34;, {}, () =\u0026gt; { _push(`some ${_ssrInterpolate(_ctx.fallback)} content`) }, _push, _parent) } undefined   ssrRenderSlot 函数实现：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29  export function ssrRenderSlot( slots: Slots | SSRSlots, slotName: string, slotProps: Props, fallbackRenderFn: (() =\u0026gt; void) | null, push: PushFn, parentComponent: ComponentInternalInstance ) { // template-compiled slots are always rendered as fragments  push(`\u0026lt;!--[--\u0026gt;`) const slotFn = slots[slotName] if (slotFn) { const scopeId = parentComponent \u0026amp;\u0026amp; parentComponent.type.__scopeId const ret = slotFn( slotProps, push, parentComponent, scopeId ? ` ${scopeId}-s` : `` ) if (Array.isArray(ret)) { // normal slot  renderVNodeChildren(push, ret, parentComponent) } } else if (fallbackRenderFn) { fallbackRenderFn() } push(`\u0026lt;!--]--\u0026gt;`) }     fallback 用途：在没有任何 slot template 时候会默认用 fallback 里的内容来渲染这个 slot。\n 如：\n1 2 3 4 5 6 7 8  \u0026lt;template\u0026gt; \u0026lt;div\u0026gt; \u0026lt;slot\u0026gt;some content\u0026lt;/slot\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;!-- 当引用这个组件的组件没有提供任何 slot 模板的时候： 相当于直接使用 fallback 替换插槽--\u0026gt; \u0026lt;div\u0026gt;some content\u0026lt;/div\u0026gt;      359f856 suspense 内置组件   feat(add): ssr-\u0026gt;slot suspense component · gcclll/stb-vue-next@359f856 · GitHub\n 1 2 3 4 5 6 7 8 9 10 11 12 13  // 源文件：/js/vue/lib.js const { compileSFCScript, compileStyle, getCompiledSSRString, compileSSR:ssr, log } = require(process.env.BLOG_JS + \u0026#39;/vue/lib.js\u0026#39;) log([\u0026#39;\u0026gt;\u0026gt;\u0026gt; implicit default\\n\u0026#39;, ssr(`\u0026lt;suspense\u0026gt;\u0026lt;foo/\u0026gt;\u0026lt;/suspense\u0026gt;`).code]) log([\u0026#39;\u0026gt;\u0026gt;\u0026gt; explicit slots\\n\u0026#39;, ssr(`\u0026lt;suspense\u0026gt; \u0026lt;template #default\u0026gt; \u0026lt;foo/\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;template #fallback\u0026gt; loading... \u0026lt;/template\u0026gt; \u0026lt;/suspense\u0026gt;`).code])    \u0026gt;\u0026gt;\u0026gt; implicit default const { resolveComponent: _resolveComponent, withCtx: _withCtx } = require(\u0026#34;vue\u0026#34;) const { ssrRenderComponent: _ssrRenderComponent, ssrRenderSuspense: _ssrRenderSuspense } = require(\u0026#34;@vue/server-renderer\u0026#34;) return function ssrRender(_ctx, _push, _parent, _attrs) { const _component_foo = _resolveComponent(\u0026#34;foo\u0026#34;) _ssrRenderSuspense(_push, { default: () =\u0026gt; { _push(_ssrRenderComponent(_component_foo, null, null, _parent)) }, _: 1 /* STABLE */ }) } \u0026gt;\u0026gt;\u0026gt; explicit slots const { resolveComponent: _resolveComponent, withCtx: _withCtx } = require(\u0026#34;vue\u0026#34;) const { ssrRenderComponent: _ssrRenderComponent, ssrRenderSuspense: _ssrRenderSuspense } = require(\u0026#34;@vue/server-renderer\u0026#34;) return function ssrRender(_ctx, _push, _parent, _attrs) { const _component_foo = _resolveComponent(\u0026#34;foo\u0026#34;) _ssrRenderSuspense(_push, { default: () =\u0026gt; { _push(_ssrRenderComponent(_component_foo, null, null, _parent)) }, fallback: () =\u0026gt; { _push(` loading... `) }, _: 1 /* STABLE */ }) } undefined   ssrRenderSuspense 实际上只是一个 await 异步函数封装：\n1 2 3 4 5 6 7 8 9 10 11  export async function ssrRenderSuspense( push: PushFn, { default: renderContent }: Record\u0026lt;string, (() =\u0026gt; void) | undefined\u0026gt; ) { if (renderContent) { renderContent() } else { push(`\u0026lt;!----\u0026gt;`) } }     最终将 SUSPENSE 中的组件异步渲染。\n  e27a5e4 teleport 内置组件   feat(add): ssr-\u0026gt;teleport component · gcclll/stb-vue-next@e27a5e4 · GitHub\n  作用❓\n1 2 3 4 5 6 7  // 源文件：/js/vue/lib.js const { compileSFCScript, compileStyle, getCompiledSSRString, compileSSR:ssr, log } = require(process.env.BLOG_JS + \u0026#39;/vue/lib.js\u0026#39;) log([\u0026#39;\u0026gt;\u0026gt;\u0026gt; basic\\n\u0026#39;, ssr(`\u0026lt;teleport :to=\u0026#34;target\u0026#34;\u0026gt;\u0026lt;div/\u0026gt;\u0026lt;/teleport\u0026gt;`).code]) log([\u0026#39;\u0026gt;\u0026gt;\u0026gt; disabled prop\\n\u0026#39;, ssr(`\u0026lt;teleport :to=\u0026#34;target\u0026#34; disabled\u0026gt;\u0026lt;div/\u0026gt;\u0026lt;/teleport\u0026gt;`).code]) log([\u0026#39;\u0026gt;\u0026gt;\u0026gt; disabled prop with value\\n\u0026#39;, ssr(`\u0026lt;teleport :to=\u0026#34;target\u0026#34; :disabled=\u0026#34;foo\u0026#34;\u0026gt;\u0026lt;div/\u0026gt;\u0026lt;/teleport\u0026gt;`).code])    \u0026gt;\u0026gt;\u0026gt; basic const { ssrRenderTeleport: _ssrRenderTeleport } = require(\u0026#34;@vue/server-renderer\u0026#34;) return function ssrRender(_ctx, _push, _parent, _attrs) { _ssrRenderTeleport(_push, (_push) =\u0026gt; { _push(`\u0026lt;div\u0026gt;\u0026lt;/div\u0026gt;`) }, _ctx.target, false, _parent) } \u0026gt;\u0026gt;\u0026gt; disabled prop const { ssrRenderTeleport: _ssrRenderTeleport } = require(\u0026#34;@vue/server-renderer\u0026#34;) return function ssrRender(_ctx, _push, _parent, _attrs) { _ssrRenderTeleport(_push, (_push) =\u0026gt; { _push(`\u0026lt;div\u0026gt;\u0026lt;/div\u0026gt;`) }, _ctx.target, true, _parent) } \u0026gt;\u0026gt;\u0026gt; disabled prop with value const { ssrRenderTeleport: _ssrRenderTeleport } = require(\u0026#34;@vue/server-renderer\u0026#34;) return function ssrRender(_ctx, _push, _parent, _attrs) { _ssrRenderTeleport(_push, (_push) =\u0026gt; { _push(`\u0026lt;div\u0026gt;\u0026lt;/div\u0026gt;`) }, _ctx.target, _ctx.foo, _parent) } undefined   ssrRenderTeleport :\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34  export function ssrRenderTeleport( parentPush: PushFn, contentRenderFn: (push: PushFn) =\u0026gt; void, target: string, disabled: boolean, parentComponent: ComponentInternalInstance ) { parentPush(\u0026#39;\u0026lt;!--teleport start--\u0026gt;\u0026#39;) let teleportContent: SSRBufferItem if (disabled) { contentRenderFn(parentPush) teleportContent = `\u0026lt;!----\u0026gt;` } else { const { getBuffer, push } = createBuffer() contentRenderFn(push) push(`\u0026lt;!----\u0026gt;`) // teleport end anchor  teleportContent = getBuffer() } const context = parentComponent.appContext.provides[ ssrContextKey as any ] as SSRContext const teleportBuffers = context.__teleportBuffers || (context.__teleportBuffers = {}) if (teleportBuffers[target]) { teleportBuffers[target].push(teleportContent) } else { teleportBuffers[target] = [teleportContent] } parentPush(\u0026#39;\u0026lt;!--teleport end--\u0026gt;\u0026#39;) }      e0fc173 transition group transform   fix: false.value -\u0026gt; false-value · gcclll/stb-vue-next@e0fc173 · GitHub\n1 2 3 4 5 6 7 8 9 10 11 12  // 源文件：/js/vue/lib.js const { compileSFCScript, compileStyle, getCompiledSSRString, compileSSR:ssr, log } = require(process.env.BLOG_JS + \u0026#39;/vue/lib.js\u0026#39;) log([\u0026#39;\u0026gt;\u0026gt;\u0026gt; basic\\n\u0026#39;, ssr(`\u0026lt;transition-group\u0026gt;\u0026lt;div v-for=\u0026#34;i in list\u0026#34;/\u0026gt;\u0026lt;/transition-group\u0026gt;`).code]) log([\u0026#39;\u0026gt;\u0026gt;\u0026gt; with static tag\\n\u0026#39;, ssr(`\u0026lt;transition-group tag=\u0026#34;ul\u0026#34;\u0026gt;\u0026lt;div v-for=\u0026#34;i in list\u0026#34;/\u0026gt;\u0026lt;/transition-group\u0026gt;`).code]) log([\u0026#39;\u0026gt;\u0026gt;\u0026gt; with dynamic tag\\n\u0026#39;, ssr(`\u0026lt;transition-group :tag=\u0026#34;someTag\u0026#34;\u0026gt;\u0026lt;div v-for=\u0026#34;i in list\u0026#34;/\u0026gt;\u0026lt;/transition-group\u0026gt;`).code]) log([\u0026#39;\u0026gt;\u0026gt;\u0026gt; with multi fragments children\\n\u0026#39;, ssr(`\u0026lt;transition-group\u0026gt; \u0026lt;div v-for=\u0026#34;i in 10\u0026#34;/\u0026gt; \u0026lt;div v-for=\u0026#34;i in 10\u0026#34;/\u0026gt; \u0026lt;template v-if=\u0026#34;ok\u0026#34;\u0026gt;\u0026lt;div\u0026gt;ok\u0026lt;/div\u0026gt;\u0026lt;/template\u0026gt; \u0026lt;/transition-group\u0026gt;`).code])    \u0026gt;\u0026gt;\u0026gt; basic const { ssrRenderList: _ssrRenderList } = require(\u0026#34;@vue/server-renderer\u0026#34;) return function ssrRender(_ctx, _push, _parent, _attrs) { _push(`\u0026lt;!--[--\u0026gt;`) _ssrRenderList(_ctx.list, (i) =\u0026gt; { _push(`\u0026lt;div\u0026gt;\u0026lt;/div\u0026gt;`) }) _push(`\u0026lt;!--]--\u0026gt;`) } \u0026gt;\u0026gt;\u0026gt; with static tag const { ssrRenderList: _ssrRenderList } = require(\u0026#34;@vue/server-renderer\u0026#34;) return function ssrRender(_ctx, _push, _parent, _attrs) { _push(`\u0026lt;ul\u0026gt;`) _ssrRenderList(_ctx.list, (i) =\u0026gt; { _push(`\u0026lt;div\u0026gt;\u0026lt;/div\u0026gt;`) }) _push(`\u0026lt;/ul\u0026gt;`) } \u0026gt;\u0026gt;\u0026gt; with dynamic tag const { ssrRenderList: _ssrRenderList } = require(\u0026#34;@vue/server-renderer\u0026#34;) return function ssrRender(_ctx, _push, _parent, _attrs) { _push(`\u0026lt;${_ctx.someTag}\u0026gt;`) _ssrRenderList(_ctx.list, (i) =\u0026gt; { _push(`\u0026lt;div\u0026gt;\u0026lt;/div\u0026gt;`) }) _push(`\u0026lt;/${_ctx.someTag}\u0026gt;`) } \u0026gt;\u0026gt;\u0026gt; with multi fragments children const { ssrRenderList: _ssrRenderList } = require(\u0026#34;@vue/server-renderer\u0026#34;) return function ssrRender(_ctx, _push, _parent, _attrs) { _push(`\u0026lt;!--[--\u0026gt;`) _ssrRenderList(10, (i) =\u0026gt; { _push(`\u0026lt;div\u0026gt;\u0026lt;/div\u0026gt;`) }) _ssrRenderList(10, (i) =\u0026gt; { _push(`\u0026lt;div\u0026gt;\u0026lt;/div\u0026gt;`) }) if (_ctx.ok) { _push(`\u0026lt;div\u0026gt;ok\u0026lt;/div\u0026gt;`) } else { _push(`\u0026lt;!----\u0026gt;`) } _push(`\u0026lt;!--]--\u0026gt;`) } undefined   ssrRenderList:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32  export function ssrRenderList( source: unknown, renderItem: (value: unknown, key: string | number, index?: number) =\u0026gt; void ) { if (isArray(source) || isString(source)) { for (let i = 0, l = source.length; i \u0026lt; l; i++) { renderItem(source[i], i) } } else if (typeof source === \u0026#39;number\u0026#39;) { if (__DEV__ \u0026amp;\u0026amp; !Number.isInteger(source)) { warn(`The v-for range expect an integer value but got ${source}.`) return } for (let i = 0; i \u0026lt; source; i++) { renderItem(i + 1, i) } } else if (isObject(source)) { if (source[Symbol.iterator as any]) { const arr = Array.from(source as Iterable\u0026lt;any\u0026gt;) for (let i = 0, l = arr.length; i \u0026lt; l; i++) { renderItem(arr[i], i) } } else { const keys = Object.keys(source) for (let i = 0, l = keys.length; i \u0026lt; l; i++) { const key = keys[i] renderItem(source[key], key, i) } } } }       也就是将 children 直接调用 renderItem 渲染出来，那这个跟动画有什么关系呢❓\n     c8e1d56 ssrCssVars inject   feat(add): ssr-\u0026gt;ssrCssVars inject · gcclll/stb-vue-next@c8e1d56 · GitHub\n1 2 3 4 5 6  // 源文件：/js/vue/lib.js const { compileSFCScript, compileStyle, getCompiledSSRString, compileSSR:ssr, log } = require(process.env.BLOG_JS + \u0026#39;/vue/lib.js\u0026#39;) log([\u0026#39;\u0026gt;\u0026gt;\u0026gt; basic\\n\u0026#39;, ssr(`\u0026lt;div/\u0026gt;`, { ssrCssVars: `{ color }` }).code]) log([\u0026#39;\u0026gt;\u0026gt;\u0026gt; fragment\\n\u0026#39;, ssr(`\u0026lt;div/\u0026gt;\u0026lt;div/\u0026gt;\u0026lt;div\u0026gt;\u0026lt;p/\u0026gt;\u0026lt;/div\u0026gt;`, { ssrCssVars: `{ color }` }).code])    \u0026gt;\u0026gt;\u0026gt; basic const { mergeProps: _mergeProps } = require(\u0026#34;vue\u0026#34;) const { ssrRenderAttrs: _ssrRenderAttrs } = require(\u0026#34;@vue/server-renderer\u0026#34;) return function ssrRender(_ctx, _push, _parent, _attrs) { const _cssVars = { style: { color: _ctx.color }} _push(`\u0026lt;div${_ssrRenderAttrs(_mergeProps(_attrs, _cssVars))}\u0026gt;\u0026lt;/div\u0026gt;`) } \u0026gt;\u0026gt;\u0026gt; fragment const { ssrRenderAttrs: _ssrRenderAttrs } = require(\u0026#34;@vue/server-renderer\u0026#34;) return function ssrRender(_ctx, _push, _parent, _attrs) { const _cssVars = { style: { color: _ctx.color }} _push(`\u0026lt;!--[--\u0026gt;\u0026lt;div${ _ssrRenderAttrs(_cssVars) }\u0026gt;\u0026lt;/div\u0026gt;\u0026lt;div${ _ssrRenderAttrs(_cssVars) }\u0026gt;\u0026lt;/div\u0026gt;\u0026lt;div${ _ssrRenderAttrs(_cssVars) }\u0026gt;\u0026lt;p\u0026gt;\u0026lt;/p\u0026gt;\u0026lt;/div\u0026gt;\u0026lt;!--]--\u0026gt;`) } undefined   cssVars 属性会注入到每个外层同级元素上。\n  总结    ELEMENT 解析\n  v-html: \u0026lt;div v-html=\u0026#34;foo\u0026#34;/\u0026gt; =\u0026gt; \u0026lt;div\u0026gt;${foo}\u0026lt;/div\u0026gt;\n  v-text: \u0026lt;div v-text=\u0026#34;foo\u0026#34;/\u0026gt; =\u0026gt; \u0026lt;div\u0026gt;${_ssrInterpolate(_ctx.foo)}\u0026lt;/div\u0026gt;\n  v-slot: 只能用在 \u0026lt;template\u0026gt; 和 \u0026lt;component\u0026gt; 或用户组件上\n  v-on: ssr 中不处理\n  v-bind: 忽略 ref和key 属性，class 合并成动态 class 属性(style 也一样)\n \u0026lt;div class=\u0026#34;foo\u0026#34; :class=\u0026#34;bar\u0026#34;/\u0026gt; \u0026gt; ~\u0026lt;div class\u0026#34;${_ssrRenderCalss([_ctx.bar, \u0026#39;foo\u0026#39;])}\u0026#34;\u0026gt;\u0026lt;/div\u0026gt;~\n    input: radio\n \u0026lt;input type=\u0026#34;radio\u0026#34; value=\u0026#34;foo\u0026#34; v-model=\u0026#34;bar\u0026#34;\u0026gt;\n =\u0026gt;\n1  \u0026lt;input type=\u0026#34;radio\u0026#34; value=\u0026#34;${(_ssrLooseEqual(_ctx.bar, \u0026#39;foo\u0026#39;)) ? \u0026#39;checked\u0026#39; : \u0026#39;\u0026#39;}\u0026#34;\u0026gt;      input: checkbox, 详情-\u0026gt;\n 有关属性： value, true-value, false-value, v-model\n 如果使用 true/false-value 配套，则只支持 v-model 绑定单个属性值。\n 如果单独使用 value ，则 v-model 支持绑定一个数组，只要当前 checkbox 的 value 值在该数组里面，则为 checked 状态，否则非选中状态。\n  input: file 不支持，如果没有 type 属性，默认为 text\n  ssrInjectFallthroughAttrs ，将 ssrRender 函数的 _attrs 参数作为属性注入到最外 层的元素上。\n  INTEROLATION: 插值调用 _ssrInterpolate(_ctx.foo) 处理\n  v-show 指令处理，就是在元素上增加一个 style = { display: \u0026#39;none\u0026#39; } 来切换元 素显示隐藏\n  v-if 先调用 compiler-core 的 transformIf 解析出 node.branches，然后使用 ssr 端的 processIf 处理成 if (condition) {} else if () {} else {} 语句，而不是 非 ssr 情况下的三元表达式(?:)\n  v-for 指令使用 _ssrRenderList(_ctx.list, (row, i) =\u0026gt; {...})\n  \u0026lt;slot/\u0026gt; 标签的处理\n1 2 3 4 5 6 7  // `\u0026lt;slot name=\u0026#34;foo\u0026#34; :p1=\u0026#34;1\u0026#34; bar=\u0026#34;2\u0026#34; \u0026gt;some {{ fallback }} content\u0026lt;/slot\u0026gt; _ssrRenderSlot(_ctx.$slots, \u0026#34;foo\u0026#34;, { p1: 1, bar: \u0026#34;2\u0026#34; }, () =\u0026gt; { _push(`some ${_ssrInterpolate(_ctx.fallback)}content`) }, _push, _parent)      \u0026lt;Suspense/\u0026gt; 内置组件，内部处理其实等于将 children 用一个 await 函数包裹 起来了，成为异步操作。\n  \u0026lt;Teleport/\u0026gt; 内置组件，需要制定 to=\u0026#34;target\u0026#34;\n 支持 disabled 属性\n1 2 3 4  // \u0026lt;teleport :to=\u0026#34;target\u0026#34; :disabled=\u0026#34;foo\u0026#34;\u0026gt;\u0026lt;div/\u0026gt;\u0026lt;/teleport\u0026gt; _ssrRenderTeleport(_push, (_push) =\u0026gt; { _push(`\u0026lt;div\u0026gt;\u0026lt;/div\u0026gt;`) }, _ctx.target, _ctx.foo, _parent)      ssr css vars 简单在元素上注入 style = { color } 属性\n    ","permalink":"https://www.cheng92.com/vue/vue-mind-map-compiler-ssr/","tags":["vue,","vue3,","compiler-ssr"],"title":"Vue3 源码头脑风暴之 6 ☞compiler-ssr"},{"categories":["web"],"contents":"  HTML 标准首页 HTML Standard\n 13 The HTML syntax  13.5 Named character references   这下面包含了所有符号 名字 - Unicode - 符号 对应关系表。\n    Element textContent, innerHTML, innerText   textContent\n innerText\n  ","permalink":"https://www.cheng92.com/web/html-spec-whatwg-st/","tags":["html"],"title":"HTML 标准"},{"categories":["vue"],"contents":"  诗号：六道同坠，魔劫万千，引渡如来。  \n   stb-vue-next 完全拷贝于 vue-next ，主要目的用于学习。 \n 声明 ：vue-next compiler-sfc 模块，相关的所有测试代码均在 /js/vue/ 目录下面。\n 更新日志\u0026amp;Todos ：\n  [2020-12-19 13:58:31] 创建\n  [2021-01-04 19:47:10] 完成\n  TODO defineProps 和 defineEmit 原理和用途\n  TODO inlineTemplate with ssr: true options\n  TODO more mind-maps\n    重点、特性、问题     🔗 \u0026lt;style\u0026gt; 标签中可通过 v-bind() 引用CSS 模块化后的变量\n  \u0026lt;script\u0026gt; 和 \u0026lt;script setup\u0026gt; 中的 export default 会合并，且是 setup 优先级 更高，因此尽量不要存在重复属性。\n    f21c84c init 初始化工作   feat(init): compiler-sfc · gcclll/stb-vue-next@f21c84c\n cp compiler-sfc form vue-next:/packages/compiler-dom\n 删除 compiler-sfc/src/* 下所有文件\n 新建 compiler-sfc/src/index.ts 入口文件\n 初始化 index.ts:\n1 2 3 4 5 6 7 8 9  // API export { generateCodeFrame } from \u0026#39;@vue/compiler-core\u0026#39; // Types export { CompilerOptions, CompilerError, BindingMetadata } from \u0026#39;@vue/compiler-core\u0026#39;      feat(init): parse function · gcclll/stb-vue-next@e7e1cc1\n 声明一些基本类型，比如： \u0026lt;template\u0026gt;, \u0026lt;script\u0026gt;, \u0026lt;style\u0026gt; 这也是 *.vue 文件的三 大要素，这里需要多关注一点就是会发现 \u0026lt;script\u0026gt; 标签里面多有一个 setup 属性， 这个是 vue 自身定义的一种标签类型，比如在这里面可以直接使用 ref 声明变量，这里 面的变量都会自动变成响应式的等等。\n SFC 块类型定义：\n1 2 3 4 5 6 7 8 9  export interface SFCBlock { type: string content: string attrs: Record\u0026lt;string, string | true\u0026gt; loc: SourceLocation map?: RawSourceMap lang?: string src?: string }     SFC \u0026lt;template\u0026gt; 标签类型定义：\n1 2 3 4  export interface SFCTemplateBlock extends SFCBlock { type: \u0026#39;template\u0026#39; ast: ElementNode }     SFC \u0026lt;script\u0026gt; 脚本标签类型定义\n1 2 3 4 5 6 7  export interface SFCScriptBlock extends SFCBlock { type: \u0026#39;script\u0026#39; setup?: string | boolean bindings?: BindingMetadata scriptAst?: Statement[] scriptSetupAst?: Statement[] }     SFC \u0026lt;style\u0026gt; 样式标签类型定义\n1 2 3 4 5  export interface SFCStyleBlock extends SFCBlock { type: \u0026#39;style\u0026#39; scoped?: boolean // 指定是不是只能用于当前文件  module?: string | boolean // 是不是模块化样式 }     SFC 文件类型定义\n1 2 3 4 5 6 7 8 9 10  export interface SFCDescriptor { filename: string source: string template: SFCTemplateBlock | null script: SFCScriptBlock | null scriptSetup: SFCScriptBlock | null styles: SFCStyleBlock[] customBlocks: SFCBlock[] cssVars: string[] }     parse 函数定义：\n1 2 3 4 5 6  export function parse( source: string, { sourceMap = true }: SFCParseOptions ): SFCParseResult { return {} as SFCParseResult }      49ee210 parse function 实现部分   feat: sfc-\u0026gt; code parse function · gcclll/stb-vue-next@49ee210\n 实现 parse 函数的基本架构:\n  sourceToSFC\u0026lt;key, source\u0026gt; 用来缓存 vue文件解析结果，首先取缓存结果\n  通过调用 compiler-dom 中的 compiler.parse 将文件内容 source解析成 AST\n  遍历所有 ast.children 根据 node.tag 类型决定走什么分支处理\n \u0026lt;template\u0026gt; 模板分支，这里面的所有内容会被 parse 继续解析出 ast\n \u0026lt;script [setup]\u0026gt; 脚本分支, 当做 RAWDATA 文本类型处理，如果有 setup 属性， 则所有 script 都不能带 src 属性，即不能引用外部文件，因为所有 script 内容会合 并到一起去处理。\n \u0026lt;style [lang=\u0026#34;\u0026#34;]\u0026gt; 样式分支，当做 RAWDATA 文本类型处理\n  错误用法检测，主要是 \u0026lt;script setup\u0026gt; 脚本标签不能有 src 的检测\n  souremap 的处理\n  descriptor.cssVars = parseCssVars(descriptor) CSS 变量的解析，会全部解析到 数组 cssVars 里面去\n  缓存解析后的结果到 sourceToSFC.set(sourceKey, result)\n  对了，在 switch case 分支里面默认走的是自定义块的处理(vue 文件中还可以自定 义？)\n   CSS vars 变量处理：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14  export const CSS_VARS_HELPER = `useCssVars`; export const cssVarRE = /\\bv-bind\\(\\s*(?:\u0026#39;([^\u0026#39;]+)\u0026#39;|\u0026#34;([^\u0026#34;]+)\u0026#34;|([^\u0026#39;\u0026#34;][^)]*))\\s*\\)/g; export function parseCssVars(sfc: SFCDescriptor): string[] { const vars: string[] = []; sfc.styles.forEach((style) =\u0026gt; { let match; // v-bind(\u0026#39;xxx\u0026#39;), v-bind(\u0026#34;xxx\u0026#34;), v-bind()  while ((match = cssVarRE.exec(style.content))) { vars.push(match[1] || match[2] || match[3]); } }); return vars; }     这里有个 cssVarRE 正则，来看下：\n  这个正则可以匹配结果： v-bind(\u0026#39;...\u0026#39;), v-bind(\u0026#34;...\u0026#34;), v-bind(...)\n 从 compiler-src/__tests__/cssVars.spec.ts 用例中可窥见这种用法：\n1 2 3 4 5  `\u0026lt;script\u0026gt;const a = 1\u0026lt;/script\u0026gt;\\n` + `\u0026lt;style\u0026gt;div{ color: v-bind(color); font-size: v-bind(\u0026#39;font.size\u0026#39;); }\u0026lt;/style\u0026gt;`     💟 现在可以直接在 \u0026lt;style\u0026gt; 变迁里面通过 v-bind() 来直接使用引入的 CSS 变量。\n  feat(add): sfc-\u0026gt;parse add sourcemap · gcclll/stb-vue-next@afd8044\ne32d508 parse \u0026lt;template\u0026gt; case   feat: sfc-\u0026gt; add \u0026lt;template\u0026gt; parse · gcclll/stb-vue-next@e32d508\n 主要增加代码： switch case -\u0026gt; \u0026#39;template\u0026#39;:  增加函数： createBlock() 用来处理 SFC 标签的属性(如： lang, setup, src, scoped, module)\n 回顾下 compiler-dom, compiler-core 其实对于 \u0026lt;template\u0026gt; 标签的处理工作依然集中 在这两个包里面，所以这里就不再赘述模板 ast 的解析了。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17  const { parse } = require(process.env.PWD + \u0026#39;/../../static/js/vue/compiler-sfc.global.js\u0026#39;) const source = ` \u0026lt;template\u0026gt; \u0026lt;div\u0026gt;{{ test }}\u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;style\u0026gt; div { color:v-bind(\u0026#39;fontColor\u0026#39;); } \u0026lt;/style\u0026gt;` const res = parse(source) console.log(res)    { descriptor: { filename: \u0026#39;anonymous.vue\u0026#39;, source: \u0026#39;\\n\u0026#39; + \u0026#39;\u0026lt;template\u0026gt;\\n\u0026#39; + \u0026#39; \u0026lt;div\u0026gt;{{ test }}\u0026lt;/div\u0026gt;\\n\u0026#39; + \u0026#39;\u0026lt;/template\u0026gt;\\n\u0026#39; + \u0026#39;\u0026lt;script\u0026gt;\u0026lt;/script\u0026gt;\\n\u0026#39; + \u0026#39;\u0026lt;style\u0026gt;\\n\u0026#39; + \u0026#39; div {\\n\u0026#39; + \u0026#34; color:v-bind(\u0026#39;fontColor\u0026#39;);\\n\u0026#34; + \u0026#39; }\\n\u0026#39; + \u0026#39;\u0026lt;/style\u0026gt;\u0026#39;, template: { type: \u0026#39;template\u0026#39;, content: \u0026#39;\\n \u0026lt;div\u0026gt;{{ test }}\u0026lt;/div\u0026gt;\\n\u0026#39;, loc: [Object], attrs: {}, ast: [Object] }, script: null, scriptSetup: null, styles: [], customBlocks: [], cssVars: [] }, errors: [] } undefined   如上：一个最简单的 SFC 解析后的结构。\n  3160fed parse \u0026lt;script\u0026gt; case   feat(add): sfc-\u0026gt; script parse · gcclll/stb-vue-next@3160fed\n 增加 switch case script 逻辑：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  case \u0026#39;script\u0026#39;: // 脚本标签处理  const scriptBlock = createBlock(node, source, pad) as SFCScriptBlock const isSetup = !!scriptBlock.attrs.setup if (isSetup \u0026amp;\u0026amp; !descriptor.scriptSetup) { descriptor.scriptSetup = scriptBlock break } if (!isSetup \u0026amp;\u0026amp; !descriptor.script) { descriptor.script = scriptBlock break } errors.push(createDuplicateBlockError(node, isSetup)) break break     createBlock() 中增加各属性的解析和设置：\n lang -\u0026gt; block.lang\n src -\u0026gt; block.src\n style \u0026gt; scoped -\u0026gt; block.scoped\n style \u0026gt; module -\u0026gt; block.module\n script \u0026gt; setup -\u0026gt; block.setup\n 另外增加了 padContent() 检测回车换行符替换？\n 测试：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14  const { parse } = require(process.env.PWD + \u0026#39;/../../static/js/vue/compiler-sfc.global.js\u0026#39;) const source = ` \u0026lt;script setup\u0026gt; import { x } from \u0026#39;./x\u0026#39; let a = 1 const b = 2 function c() {} class d {} \u0026lt;/script\u0026gt;` const res = parse(source) console.log(res.descriptor)    { filename: \u0026#39;anonymous.vue\u0026#39;, source: \u0026#39;\\n\u0026#39; + \u0026#39;\u0026lt;script setup\u0026gt;\\n\u0026#39; + \u0026#34;import { x } from \u0026#39;./x\u0026#39;\\n\u0026#34; + \u0026#39;let a = 1\\n\u0026#39; + \u0026#39;const b = 2\\n\u0026#39; + \u0026#39;function c() {}\\n\u0026#39; + \u0026#39;class d {}\\n\u0026#39; + \u0026#39;\u0026lt;/script\u0026gt;\u0026#39;, template: null, script: null, scriptSetup: { type: \u0026#39;script\u0026#39;, content: \u0026#39;\\n\u0026#39; + \u0026#34;import { x } from \u0026#39;./x\u0026#39;\\n\u0026#34; + \u0026#39;let a = 1\\n\u0026#39; + \u0026#39;const b = 2\\n\u0026#39; + \u0026#39;function c() {}\\n\u0026#39; + \u0026#39;class d {}\\n\u0026#39;, loc: { source: \u0026#39;\\n\u0026#39; + \u0026#34;import { x } from \u0026#39;./x\u0026#39;\\n\u0026#34; + \u0026#39;let a = 1\\n\u0026#39; + \u0026#39;const b = 2\\n\u0026#39; + \u0026#39;function c() {}\\n\u0026#39; + \u0026#39;class d {}\\n\u0026#39;, start: [Object], end: [Object] }, attrs: { setup: true }, setup: true }, styles: [], customBlocks: [], cssVars: [] } undefined    aa037fe parse \u0026lt;style\u0026gt; case   feat(add): sfc-\u0026gt; parse \u0026lt;style\u0026gt; · gcclll/stb-vue-next@aa037fe\n 解析后的结果保存到 descriptor.styles.push(styleBlock) 所以可以有多个 \u0026lt;style\u0026gt; 存在。\n Tip: 这里还有一个 styleBlock.attrs.vars 检测，难不成将来会支持直接 SFC 里面 声明 CSS 变量?\n  测试：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14  const { parse } = require(process.env.PWD + \u0026#39;/../../static/js/vue/compiler-sfc.global.js\u0026#39;) const source = ` \u0026lt;style scoped\u0026gt; h1 { color: red; font-size: v-bind(fontSize); border: v-bind(\u0026#39;border\u0026#39;); } \u0026lt;/style\u0026gt;` const res = parse(source) console.log(res.descriptor)    { filename: \u0026#39;anonymous.vue\u0026#39;, source: \u0026#39;\\n\u0026#39; + \u0026#39;\u0026lt;style scoped\u0026gt;\\n\u0026#39; + \u0026#39;h1 {\\n\u0026#39; + \u0026#39; color: red;\\n\u0026#39; + \u0026#39; font-size: v-bind(fontSize);\\n\u0026#39; + \u0026#34; border: v-bind(\u0026#39;border\u0026#39;);\\n\u0026#34; + \u0026#39;}\\n\u0026#39; + \u0026#39;\u0026lt;/style\u0026gt;\u0026#39;, template: null, script: null, scriptSetup: null, styles: [ { type: \u0026#39;style\u0026#39;, content: \u0026#39;\\n\u0026#39; + \u0026#39;h1 {\\n\u0026#39; + \u0026#39; color: red;\\n\u0026#39; + \u0026#39; font-size: v-bind(fontSize);\\n\u0026#39; + \u0026#34; border: v-bind(\u0026#39;border\u0026#39;);\\n\u0026#34; + \u0026#39;}\\n\u0026#39;, loc: [Object], attrs: [Object], scoped: true } ], customBlocks: [], cssVars: [ \u0026#39;fontSize\u0026#39;, \u0026#39;border\u0026#39; ] } undefined   对于 v-bind() 变量的引用，不管有没引号，都会当做变量处理。\n    compile \u0026lt;template\u0026gt;  c26e76c init compileTemplate   feat(init): sfc-\u0026gt;compile \u0026lt;template\u0026gt; · gcclll/stb-vue-next@c26e76c\n 增加两个类型和 compileTemplate 函数定义：\n SFCTemplateCompileResults 模板便后的结果类型\n1 2 3 4 5 6 7 8 9  export interface SFCTemplateCompileResults { code: string ast?: RootNode preamble?: string source: string tips: string[] errors: (string | CompilerError)[] map?: RawSourceMap }     SFCTemplateCompileOptions 模板编译器选项\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26  export interface SFCTemplateCompileOptions { source: string filename: string id: string scoped?: boolean isProd?: boolean ssr?: boolean ssrCssVars?: string[] inMap?: RawSourceMap compiler?: TemplateCompiler compilerOptions?: CompilerOptions preprocessLang?: string preprocessOptions?: any /** * In some cases, compiler-sfc may not be inside the project root (e.g. when * linked or globally installed). In such cases a custom `require` can be * passed to correctly resolve the preprocessors. */ preprocessCustomRequire?: (id: string) =\u0026gt; any /** * Configure what tags/attributes to transform into asset url imports, * or disable the transform altogether with `false`. */ transformAssetUrls?: AssetURLOptions | AssetURLTagConfig | boolean }     及 compileTemplate 函数\n1 2 3 4 5  export function compileTemplate( options: SFCTemplateCompileOptions ): SFCTemplateCompileResults { return {} as SFCTemplateCompileResults }      TODO 1b2965f coding compileTemplate   feat: sfc-\u0026gt;compile compileTemplate code · gcclll/stb-vue-next@1b2965f\n 这个函数相关的内容：\n  preprocessLang\n  preprocessCustomRequire\n  TODO 模板预处理器，没搞明白这里是要做什么？\n 代码逻辑：\n if preprocessor -\u0026gt; doCompileTemplate()\n elseif preprocessLang -\u0026gt; …\n else -\u0026gt; doCompileTemplate()\n ⏹ 等待探索……\n   7b49db4 coding doCompileTemplate 函数实现   feat(add): sfc-\u0026gt;compile doCompileTemplate · gcclll/stb-vue-next@7b49db4\n 函数功能：收集两个 transform 给 compiler.compile 在模板编译期间使用。\n  asset url 资源地址转换用的 transform\n 要处理的标签和对应的包含 url 的属性:\n   tag prop with url     \u0026lt;video\u0026gt; \u0026#39;src\u0026#39;, \u0026#39;poster\u0026#39;   \u0026lt;source\u0026gt; \u0026#39;src\u0026#39;   \u0026lt;img\u0026gt; \u0026#39;src\u0026#39;   \u0026lt;image\u0026gt; \u0026#39;xlink:href\u0026#39;, \u0026#39;href\u0026#39;   \u0026lt;use\u0026gt; \u0026#39;xlink:href\u0026#39;, \u0026#39;href\u0026#39;      img/source 标签 src 地址转换\n   重点代码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20  const shortId = id.replace(/^data-v-/, \u0026#39;\u0026#39;) const longId = `data-v-${shortId}` let { code, ast, preamble, map } = compiler.compile(source, { mode: \u0026#39;module\u0026#39;, prefixIdentifiers: true, hoistStatic: true, cacheHandlers: true, ssrCssVars: ssr \u0026amp;\u0026amp; ssrCssVars \u0026amp;\u0026amp; ssrCssVars.length ? \u0026#39;\u0026#39; /* TODO genCssVarsFromList(ssrCssVars, shortId, isProd) */ : \u0026#39;\u0026#39;, // css 局部使用，加上对应的唯一 id  scopeId: scoped ? longId : undefined, ...compilerOptions, nodeTransforms: nodeTransforms.concat(compilerOptions.nodeTransforms || []), filename, sourceMap: true, onError: e =\u0026gt; errors.push(e) })     将 nodeTransforms: [transformAssetUrl, transformSrcset] 传递给编译器处理。\n 注意这里设置了几个属性： mode = \u0026#39;module\u0026#39;, prefixIdentifiers = true 所以这个应 该只能运行在非浏览器环境。\n 下面来实现一个相对简单的 transformAssetUrl() 函数 ……\n  2d82400 coding transformAssetUrl 转换资源 url   feat(add): sfc-\u0026gt;compile templateTransformAssetUrl · gcclll/stb-vue-next@2d82400\n fix: sfc preprocess function · gcclll/stb-vue-next@e08f805\n 几种URL使用情况和转换结果如下实例：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20  const { compileTemplate } = require(process.env.VNEXT_PKG_SFC + \u0026#39;/dist/compiler-sfc.cjs.js\u0026#39;) const { code, ast } = compileTemplate({ source: `\u0026lt;template\u0026gt;\u0026lt;div id=\u0026#34;test\u0026#34;\u0026gt; \u0026lt;img src=\u0026#34;./test/test.png\u0026#34; /\u0026gt; \u0026lt;img src=\u0026#34;./test/test.png\u0026#34; /\u0026gt; \u0026lt;img :src=\u0026#34;imgUrl\u0026#34; /\u0026gt; \u0026lt;img src=\u0026#34;\u0026#34; /\u0026gt; \u0026lt;img src=\u0026#34;http://1.1.1.1:100/imgs/test/test.png\u0026#34; /\u0026gt; \u0026lt;img src=\u0026#34;data:....\u0026#34; /\u0026gt; \u0026lt;img src=\u0026#34;#test/test.png\u0026#34; /\u0026gt; \u0026lt;img src=\u0026#34;~test/test.png\u0026#34; /\u0026gt; \u0026lt;img src=\u0026#34;~/test/test.png\u0026#34; /\u0026gt; \u0026lt;img src=\u0026#34;@test/test.png\u0026#34; /\u0026gt; \u0026lt;video src=\u0026#34;./test/video.mp4\u0026#34; poster=\u0026#34;./test/poster.png\u0026#34; /\u0026gt; \u0026lt;div src=\u0026#34;./test/test.png\u0026#34; /\u0026gt; \u0026lt;/div\u0026gt;\u0026lt;/template\u0026gt;`, id: \u0026#39;\u0026#39;, filename: \u0026#39;test.vue\u0026#39; }) console.log(code)    import { createVNode as _createVNode, openBlock as _openBlock, createBlock as _createBlock } from \u0026#34;vue\u0026#34; import _imports_0 from \u0026#39;./test/test.png\u0026#39; import _imports_1 from \u0026#39;test/test.png\u0026#39; import _imports_2 from \u0026#39;@test/test.png\u0026#39; import _imports_3 from \u0026#39;./test/video.mp4\u0026#39; import _imports_4 from \u0026#39;./test/poster.png\u0026#39; const _hoisted_1 = { id: \u0026#34;test\u0026#34; } const _hoisted_2 = /*#__PURE__*/_createVNode(\u0026#34;img\u0026#34;, { src: _imports_0 }, null, -1 /* HOISTED */) const _hoisted_3 = /*#__PURE__*/_createVNode(\u0026#34;img\u0026#34;, { src: _imports_0 }, null, -1 /* HOISTED */) const _hoisted_4 = /*#__PURE__*/_createVNode(\u0026#34;img\u0026#34;, { src: \u0026#34;\u0026#34; }, null, -1 /* HOISTED */) const _hoisted_5 = /*#__PURE__*/_createVNode(\u0026#34;img\u0026#34;, { src: \u0026#34;http://1.1.1.1:100/imgs/test/test.png\u0026#34; }, null, -1 /* HOISTED */) const _hoisted_6 = /*#__PURE__*/_createVNode(\u0026#34;img\u0026#34;, { src: \u0026#34;data:....\u0026#34; }, null, -1 /* HOISTED */) const _hoisted_7 = /*#__PURE__*/_createVNode(\u0026#34;img\u0026#34;, { src: \u0026#34;#test/test.png\u0026#34; }, null, -1 /* HOISTED */) const _hoisted_8 = /*#__PURE__*/_createVNode(\u0026#34;img\u0026#34;, { src: _imports_1 }, null, -1 /* HOISTED */) const _hoisted_9 = /*#__PURE__*/_createVNode(\u0026#34;img\u0026#34;, { src: _imports_1 }, null, -1 /* HOISTED */) const _hoisted_10 = /*#__PURE__*/_createVNode(\u0026#34;img\u0026#34;, { src: _imports_2 }, null, -1 /* HOISTED */) const _hoisted_11 = /*#__PURE__*/_createVNode(\u0026#34;video\u0026#34;, { src: _imports_3, poster: _imports_4 }, null, -1 /* HOISTED */) const _hoisted_12 = /*#__PURE__*/_createVNode(\u0026#34;div\u0026#34;, { src: \u0026#34;./test/test.png\u0026#34; }, null, -1 /* HOISTED */) export function render(_ctx, _cache) { return (_openBlock(), _createBlock(\u0026#34;template\u0026#34;, null, [ _createVNode(\u0026#34;div\u0026#34;, _hoisted_1, [ _hoisted_2, _hoisted_3, _createVNode(\u0026#34;img\u0026#34;, { src: _ctx.imgUrl }, null, 8 /* PROPS */, [\u0026#34;src\u0026#34;]), _hoisted_4, _hoisted_5, _hoisted_6, _hoisted_7, _hoisted_8, _hoisted_9, _hoisted_10, _hoisted_11, _hoisted_12 ]) ])) } undefined   模板中资源URL不转换几种情况：\n  属性不是静态属性(NodeTypes.ATTRIBUTE)\n  非特定标签的不转换(或者通过 options.tags 里指定的标签)\n1 2 3 4 5 6 7  tags: { video: [\u0026#39;src\u0026#39;, \u0026#39;poster\u0026#39;], source: [\u0026#39;src\u0026#39;], img: [\u0026#39;src\u0026#39;], image: [\u0026#39;xlink:href\u0026#39;, \u0026#39;href\u0026#39;], use: [\u0026#39;xlink:href\u0026#39;, \u0026#39;href\u0026#39;] }      没有属性值的属性\n  外部链接的URL(https 开头的)\n  data: 开头的资源地址\n  属性值以 # 开头的地址\n  非绝对路径且费相对路径的(以， .|~|@ 开头的地址)\n   需要处理的又分两种情况：\n  给定了 options.base 基地址的(.|~|@ 为第一个字符的)\n 直接用 options.base + assert url 处理\n  非1中清空的使用 import imgName from \u0026#39;...img url\u0026#39; 引入\n   PS. 对于 CSS 中的URL引用放到后续 compileStyle 中去展示。\n     56358a8 compile \u0026lt;style\u0026gt;   feat(add): sfc-\u0026gt; compile style · gcclll/stb-vue-next@56358a8\n 这部分代码都是直接 Ctrl-c, Ctrl-v 来的，也没深入研究，所以这节也没什么好讲述的。\n 待到以后有时间再来研究。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74  const { compileStyle } = require(process.env.VNEXT_PKG_SFC + \u0026#39;/dist/compiler-sfc.cjs.js\u0026#39;) const c = (source, option = {}) =\u0026gt; compileStyle({ source, filename: \u0026#39;test.css\u0026#39;, id: \u0026#39;data-v-test\u0026#39;, scoped: true, ...option }) const log = console.log const res = c(` h1 { color: red; } .foo { color: red; } h1 .foo { color: red; } h1 .foo, .bar, .baz { color: red; } .foo:after { color: red; } ::selection { display: none; } .abc, ::selection { color: red; } :deep(.foo) { color: red; } ::v-deep(.foo) { color: red; } ::v-deep(.foo .bar) { color: red; } .baz .qux ::v-deep(.foo .bar) { color: red; } :slotted(.foo) { color: red; } ::v-slotted(.foo) { color: red; } ::v-slotted(.foo .bar) { color: red; } .baz .qux ::v-slotted(.foo .bar) { color: red; } :global(.foo) { color: red; } ::v-global(.foo) { color: red; } ::v-global(.foo .bar) { color: red; } .baz .qux ::v-global(.foo .bar) { color: red; } @media print { .foo { color: red }} @supports(display: grid) { .foo { display: grid }} .anim { animation: color 5s infinite, other 5s; } .anim-2 { animation-name: color; animation-duration: 5s; } .anim-3 { animation: 5s color infinite, 5s other; } .anim-multiple { animation: color 5s infinite, opacity 2s; } .anim-multiple-2 { animation-name: color, opacity; animation-duration: 5s, 2s; } @keyframes color { from { color: red; } to { color: green; } } @-webkit-keyframes color { from { color: red; } to { color: green; } } @keyframes opacity { from { opacity: 0; } to { opacity: 1; } } @-webkit-keyframes opacity { from { opacity: 0; } to { opacity: 1; } } `) log(res.code)    h1[data-v-test] { color: red; } .foo[data-v-test] { color: red; } h1 .foo[data-v-test] { color: red; } h1 .foo[data-v-test], .bar[data-v-test], .baz[data-v-test] { color: red; } .foo[data-v-test]:after { color: red; } [data-v-test]::selection { display: none; } .abc[data-v-test],[data-v-test]::selection { color: red; } [data-v-test] .foo { color: red; } [data-v-test] .foo { color: red; } [data-v-test] .foo .bar { color: red; } .baz .qux[data-v-test] .foo .bar { color: red; } .foo[data-v-test-s] { color: red; } .foo[data-v-test-s] { color: red; } .foo .bar[data-v-test-s] { color: red; } .baz .qux .foo .bar[data-v-test-s] { color: red; } .foo { color: red; } .foo { color: red; } .foo .bar { color: red; } .foo .bar { color: red; } @media print { .foo[data-v-test] { color: red }} @supports(display: grid) { .foo[data-v-test] { display: grid }} .anim[data-v-test] { animation: color-test 5s infinite, other 5s; } .anim-2[data-v-test] { animation-name: color-test; animation-duration: 5s; } .anim-3[data-v-test] { animation: 5s color-test infinite, 5s other; } .anim-multiple[data-v-test] { animation: color-test 5s infinite,opacity-test 2s; } .anim-multiple-2[data-v-test] { animation-name: color-test,opacity-test; animation-duration: 5s, 2s; } @keyframes color-test { from { color: red; } to { color: green; } } @-webkit-keyframes color-test { from { color: red; } to { color: green; } } @keyframes opacity-test { from { opacity: 0; } to { opacity: 1; } } @-webkit-keyframes opacity-test { from { opacity: 0; } to { opacity: 1; } } undefined   PS. 对于 CSS 的解析需要 postcss 以及各种预处理来处理，这里暂时不展开。\n   4d66531 compile \u0026lt;script\u0026gt;重点   这节会是重点部分。\n init compileScript function   初始化 compileScript() 函数以及参数选项类型 SFCScriptCompileOptions\n SFCScriptCompileOptions:\n  id: string, 传递给 compileStyle 用于作为 injected CSS 变量前缀用\n  isProd?: boolean 决定生成的 CSS 变量是否要加上 hash 值\n  babelParserPlugins?: ParserPlugin[]\n  refSugar?: boolean 使能 ref 语法糖\n  inlineTemplate?: boolean 内联模板？？？\n   compileScript:\n1 2 3 4 5 6 7 8 9 10 11  /** * Compile `\u0026lt;script setup\u0026gt;` * It requires the whole SFC descriptor because we need to handle and merge * normal `\u0026lt;script\u0026gt;` + `\u0026lt;script setup\u0026gt;` if both are present. */ export function compileScript( sfc: SFCDescriptor, options: SFCScriptCompileOptions ): SFCScriptBlock { return {} as SFCScriptBlock }     feat(add): sfc-\u0026gt;script, compileScript steps comment · gcclll/stb-vue-next@54ea72a\n 列出 compileScript() 将要完成的任务：\n   No. Desc Link     0 前置处理 -   1 处理存在的 \u0026lt;script\u0026gt; 代码体 -   2 解析 \u0026lt;script setup\u0026gt;，遍历置顶的语句 -   3 将 ref访问转换成对 ref.value 的引用 -   4 释放 setup 上下文类型的运行时 props/emits 代码 -   5 检查用户选项(useOptions)参数，确保它没有引用 setup 下的变量 -   6 删除 non-script 的内容 -   7 分析 binding metadata -   8 注入 `useCssVars` 调用 -   9 完成 setup() 参数签名 -   10 生成返回语句(return) -   11 完成 default export -   12 完成 Vue helpers imports -     接下来就是按照上表的步骤来一步步完成 compileScript()\n PS. 下面每个对应章节都有对应的原版英文注释，英语不好~~~~~。\n  增加一些逻辑无关的变量声明： feat(add): sfc-\u0026gt;script compileScript declarations · gcclll/stb-vue-next@06f1d95\n 在进入正式步骤之前，来简单看看使用到的 @babel/parser 这个插件是如何使用的，输 出结果又是啥？\n1 2 3 4 5 6 7 8 9 10 11 12  const { parse } = require(process.env.BABEL_DIR + \u0026#39;/parser/lib/index.js\u0026#39;) const log = console.log let code = ` import { a } from \u0026#39;./a.js\u0026#39;; const value = 1 * 10 + 100 - 20 / 30 + 1 export const name = a.getName(); export default { name } ` const res = parse(code, { sourceType: \u0026#39;module\u0026#39; }) console.log(res.program.body.map(body =\u0026gt; body.type).join(\u0026#39;\\n\u0026#39;))    ImportDeclaration VariableDeclaration ExportNamedDeclaration ExportDefaultDeclaration undefined   以上输出是每个语句在 parser 中对应的 AST 类型。\n  0⃣ d7369ae 无 \u0026lt;script setup\u0026gt; 时   feat(add): script without setup-script parse · gcclll/stb-vue-next@d7369ae\n 一开始会检测有没有 script setup 如果没有，继续检测 \u0026lt;script\u0026gt; 普通标签，如果两 者都不存在，抛出异常。\n 如果 \u0026lt;script\u0026gt; 存在，则直接调用 @babel/parser 的 parse 函数进行解析，因此后面 一坨代码在这种情况下(只有普通的 script 时)是不需要的。\n 新增代码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  const scriptAst = _parse(script.content, { plugins, sourceType: \u0026#39;module\u0026#39; }).program.body const bindings = analyzeScriptBindings(scriptAst) const needRewrite = cssVars.length || hasInheritAttrsFlag let content = script.content if (needRewrite) { // TODO need rewrite } return { ...script, content, bindings, scriptAst }     测试:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14  const { compileScript, parse } = require(process.env.VNEXT_PKG_SFC + \u0026#39;/dist/compiler-sfc.cjs.js\u0026#39;) const compile = (src, options) =\u0026gt; { const { descriptor } = parse(src) return compileScript(descriptor, { ...options, id: \u0026#39;xxxx\u0026#39; }) } const code = ` \u0026lt;script\u0026gt; import { a } from \u0026#39;./a.js\u0026#39;; \u0026lt;/script\u0026gt; ` const res = compile(code) console.log(res.type, \u0026#39;\\n\u0026#39;, res.scriptAst)    script [ Node { type: \u0026#39;ImportDeclaration\u0026#39;, start: 1, end: 28, loc: SourceLocation { start: [Position], end: [Position], filename: undefined, identifierName: undefined }, range: undefined, leadingComments: undefined, trailingComments: undefined, innerComments: undefined, extra: undefined, specifiers: [ [Node] ], source: Node { type: \u0026#39;StringLiteral\u0026#39;, start: 19, end: 27, loc: [SourceLocation], range: undefined, leadingComments: undefined, trailingComments: undefined, innerComments: undefined, extra: [Object], value: \u0026#39;./a.js\u0026#39; } } ] undefined   示例：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26  const { compileScript, parse } = require(process.env.VNEXT_PKG_SFC + \u0026#39;/dist/compiler-sfc.cjs.js\u0026#39;) const { log } = require(process.env.BLOG_JS + \u0026#39;/utils.js\u0026#39;) const compile = (src, options) =\u0026gt; { const { descriptor } = parse(src) return compileScript(descriptor, { ...options, id: \u0026#39;xxxx\u0026#39; }) } const code = ` \u0026lt;script\u0026gt; export default { props: [\u0026#39;foo\u0026#39;, \u0026#39;bar\u0026#39;] } \u0026lt;/script\u0026gt;` const { type, scriptAst: ast } = compile(code) // 首先是个 ExportDefaultDeclaration 类型 // export 的值为一个 ObjectExpression 类型 log(`\u0026gt;\u0026gt;\u0026gt; \u0026lt;script\u0026gt; 解析后的类型`) console.log(type) const node = ast[0] log(`\u0026gt;\u0026gt;\u0026gt; export default 解析后的类型`) log(node.type) log(`\u0026gt;\u0026gt;\u0026gt; { props : ... } 解析后的 ast 包含的 keys`) log(Object.keys(node.declaration)) log(`\u0026gt; properties 为 ObjectExpression 对象的成员列表，如： props`) log.props(node.declaration.properties[0], [\u0026#39;type\u0026#39;, \u0026#39;key\u0026#39;, \u0026#39;value\u0026#39;]) log(node.declaration.properties[0].value.elements)     +RESULTS: 精简之后的输出\n\u0026gt;\u0026gt;\u0026gt; \u0026lt;script\u0026gt; 解析后的类型 script \u0026gt;\u0026gt;\u0026gt; export default 解析后的类型 ExportDefaultDeclaration \u0026gt;\u0026gt;\u0026gt; { props : ... } 解析后的 ast 包含的 keys [ \u0026#39;type\u0026#39;, \u0026#39;start\u0026#39;, \u0026#39;end\u0026#39;, \u0026#39;loc\u0026#39;, \u0026#39;range\u0026#39;, \u0026#39;leadingComments\u0026#39;, \u0026#39;trailingComments\u0026#39;, \u0026#39;innerComments\u0026#39;, \u0026#39;extra\u0026#39;, \u0026#39;properties\u0026#39; ] \u0026gt; properties 为 ObjectExpression 对象的成员列表，如： props { type: \u0026#39;ObjectProperty\u0026#39;, key: Node { type: \u0026#39;Identifier\u0026#39;, name: \u0026#39;props\u0026#39; }, value: Node { type: \u0026#39;ArrayExpression\u0026#39;, elements: [ [Node], [Node] ] } } [ Node { type: \u0026#39;StringLiteral\u0026#39;, extra: { rawValue: \u0026#39;foo\u0026#39;, raw: \u0026#34;\u0026#39;foo\u0026#39;\u0026#34; }, value: \u0026#39;foo\u0026#39; }, Node { type: \u0026#39;StringLiteral\u0026#39;, extra: { rawValue: \u0026#39;bar\u0026#39;, raw: \u0026#34;\u0026#39;bar\u0026#39;\u0026#34; }, value: \u0026#39;bar\u0026#39; } ]    819a413 export default {} 解析   feat(add): sfc-\u0026gt;script, parse export default members into bindings · gcclll/stb-vue-next@819a413\n (property.type === \u0026#39;ObjectMethod\u0026#39; \u0026amp;\u0026amp;property.key.type === \u0026#39;Identifier\u0026#39; \u0026amp;\u0026amp;(property.key.name === \u0026#39;setup\u0026#39; || property.key.name === \u0026#39;data\u0026#39;))\n 成员最后在 bindings 里面存在类型值：\n   name type(BindingTypes) value     props \u0026#39;PROPS\u0026#39; \u0026#39;props\u0026#39;   inject \u0026#39;PROPS\u0026#39; \u0026#39;props\u0026#39;   computed \u0026#39;OPTIONS\u0026#39; \u0026#39;options\u0026#39;   methods \u0026#39;OPTIONS\u0026#39; \u0026#39;options\u0026#39;     setup SETUP_MAYBE_REF \u0026#39;setup-maybe-ref\u0026#39;   data SETUP_MAYBE_REF \u0026#39;setup-maybe-ref\u0026#39;     到这里还只是借助 @babel/parser 进行了解析，vue 自身的一些特性处理在 analyzeScriptBindings() 中，这个函数解析的类型是 ExportDefaultDeclaration 也 就是 export default {} 的代码部分。\n 然后调用 analyzeBindingsFromOptions(node.declaration) 解析对象成员，这里要处理 的主要有两种：\n  ObjectProperty 属性类型成员\n (property.type === \u0026#39;ObjectProperty\u0026#39; \u0026amp;\u0026amp;!property.computed \u0026amp;\u0026amp;property.key.type === \u0026#39;Identifier\u0026#39;)\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28  const { compileScript, parse } = require(process.env.VNEXT_PKG_SFC + \u0026#39;/dist/compiler-sfc.cjs.js\u0026#39;) const { log } = require(process.env.BLOG_JS + \u0026#39;/utils.js\u0026#39;) const compile = (src, options) =\u0026gt; { const { descriptor } = parse(src) return compileScript(descriptor, { ...options, id: \u0026#39;xxxx\u0026#39; }) } const res = compile(` \u0026lt;script\u0026gt; export default { props: [\u0026#39;firstName\u0026#39;, \u0026#39;secondName\u0026#39;], inject: { foo: {} }, computed: { fullName() { return this.firstName + this.secondName + this.thirdName } }, methods: { getName() { return this.fullName } } } \u0026lt;/script\u0026gt; `) console.log(res.bindings)    { firstName: \u0026#39;props\u0026#39;, secondName: \u0026#39;props\u0026#39;, foo: \u0026#39;options\u0026#39;, fullName: \u0026#39;options\u0026#39;, getName: \u0026#39;options\u0026#39; } undefined    ObjectMethod 方法类型成员，且只处理 setup 和 data 方法\n feat(add): sfc-\u0026gt;script, parse export default data\u0026amp;setup into bingdings · gcclll/stb-vue-next@c7b617b\n 需要增加代码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24  if ( property.type === \u0026#39;ObjectMethod\u0026#39; \u0026amp;\u0026amp; property.key.type === \u0026#39;Identifier\u0026#39; \u0026amp;\u0026amp; (property.key.name === \u0026#39;setup\u0026#39; || property.key.name === \u0026#39;data\u0026#39;) ) { for (const bodyItem of property.body.body) { // setup() {  // return {  // foo: null  // }  // }  if ( bodyItem.type === \u0026#39;ReturnStatement\u0026#39; \u0026amp;\u0026amp; bodyItem.argument \u0026amp;\u0026amp; bodyItem.argument.type === \u0026#39;ObjectExpression\u0026#39; ) { for (const key of getObjectExpressionKeys(bodyItem.argument)) { bindings[key] = property.key.name = \u0026#39;setup\u0026#39; ? BindingTypes.SETUP_MAYBE_REF : BindingTypes.DATA } } } }     测试：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26  const { compileScript, parse } = require(process.env.VNEXT_PKG_SFC + \u0026#39;/dist/compiler-sfc.cjs.js\u0026#39;) const { log } = require(process.env.BLOG_JS + \u0026#39;/utils.js\u0026#39;) const compile = (src, options) =\u0026gt; { const { descriptor } = parse(src) return compileScript(descriptor, { ...options, id: \u0026#39;xxxx\u0026#39; }) } const code = ` \u0026lt;script\u0026gt; export default { setup() { return { foo: null } }, data() { return { bar: null } }, props: [\u0026#39;baz\u0026#39;] } \u0026lt;/script\u0026gt;` const res = compile(code) log(res.bindings)    { foo: \u0026#39;setup-maybe-ref\u0026#39;, bar: \u0026#39;setup-maybe-ref\u0026#39;, baz: \u0026#39;props\u0026#39; } undefined      测试  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75  const { compileScript, parse } = require(process.env.VNEXT_PKG_SFC + \u0026#39;/dist/compiler-sfc.cjs.js\u0026#39;) const { log } = require(process.env.BLOG_JS + \u0026#39;/utils.js\u0026#39;) const compile = (src, options) =\u0026gt; { const { descriptor } = parse(src) return compileScript(descriptor, { ...options, id: \u0026#39;xxxx\u0026#39; }) } log(`\u0026gt;\u0026gt;\u0026gt; setup return`) log(compile(` \u0026lt;script\u0026gt; const bar = 2 export default { setup() { return { foo: 1, bar } } } \u0026lt;/script\u0026gt;`).bindings) log(`\u0026gt;\u0026gt;\u0026gt; async setup return`) log(compile(` \u0026lt;script\u0026gt; const bar = 2 export default { async setup() { return { foo: 1, bar } } } \u0026lt;/script\u0026gt;`).bindings) log(`\u0026gt;\u0026gt;\u0026gt; computeds`) log(compile(` \u0026lt;script\u0026gt; export default { computed: { foo() {}, bar: { get() {}, set() {}, } } } \u0026lt;/script\u0026gt; `).bindings) log(`\u0026gt;\u0026gt;\u0026gt; 混合 bindings`) log(compile(` \u0026lt;script\u0026gt; export default { inject: [\u0026#39;foo\u0026#39;], props: { bar: String, }, setup() { return { baz: null, } }, data() { return { qux: null } }, methods: { quux() {} }, computed: { quuz() {} } } \u0026lt;/script\u0026gt; `).bindings)      1⃣ eb650ca 解析 \u0026lt;script\u0026gt;   feat(add): sfc-\u0026gt;script, export default handle · gcclll/stb-vue-next@eb650ca\nprocess normal \u0026lt;script\u0026gt; first if it exists\n  用到的插件：\n   Plugin     @babel/parser · Babel     这一节中的普通 \u0026lt;script\u0026gt; 前提是，至少有一个 \u0026lt;script setup\u0026gt; 存在，否则会直接在 上一节 就退出解析了。\n @babel/parser 解析 import 结果对照表\n   段 类型 值     import { a } from \u0026#39;./x\u0026#39; ImportDeclaration …   a ImportSpecifier node.specifiers[i].imported.name   \u0026#39;./x\u0026#39; StringLiteral node.source.value    1 2 3 4 5 6 7 8 9 10 11 12 13  const { parse } = require(process.env.BABEL_DIR + \u0026#39;/parser/lib/index.js\u0026#39;) const code = ` import { a } from \u0026#39;./x\u0026#39;` const res = parse(code, { sourceType: \u0026#39;module\u0026#39; }).program.body const node = res[0] const spec = node.specifiers[0] console.log(`\u0026gt;\u0026gt;\u0026gt; node type \u0026gt; ${node.type}`) console.log(`\u0026gt;\u0026gt;\u0026gt; node source type \u0026gt; ${node.source.type}`) console.log(`\u0026gt;\u0026gt;\u0026gt; node source value \u0026gt; ${node.source.value}`) console.log(`\u0026gt;\u0026gt;\u0026gt; spec type \u0026gt; ${spec.type}`) console.log(`\u0026gt;\u0026gt;\u0026gt; spec imported type \u0026gt; ${spec.imported.type}`) console.log(`\u0026gt;\u0026gt;\u0026gt; spec imported name \u0026gt; ${spec.imported.name}`)    \u0026gt;\u0026gt;\u0026gt; node type \u0026gt; ImportDeclaration \u0026gt;\u0026gt;\u0026gt; node source type \u0026gt; StringLiteral \u0026gt;\u0026gt;\u0026gt; node source value \u0026gt; ./x \u0026gt;\u0026gt;\u0026gt; spec type \u0026gt; ImportSpecifier \u0026gt;\u0026gt;\u0026gt; spec imported type \u0026gt; Identifier \u0026gt;\u0026gt;\u0026gt; spec imported name \u0026gt; a   所以 vue-next 中新增的代码处理逻辑：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19  // import ... from \u0026#39;./x\u0026#39; 语句类型 if (node.type === \u0026#39;ImportDeclaration\u0026#39;) { // record imports for dedupe  // import 进来的变量列表  for (const specifier of node.specifiers) { // 变量名  const imported = specifier.type === \u0026#39;ImportSpecifier\u0026#39; \u0026amp;\u0026amp; specifier.imported.type === \u0026#39;Identifier\u0026#39; \u0026amp;\u0026amp; specifier.imported.name // 注册到 userImports[local] = { isType, imported, source } 中  registerUserImport( node.source.value, specifier.local.name, imported, node.importKind === \u0026#39;type\u0026#39; ) } }     然后 compileScript 中有一段处理不明白：\n1 2 3 4  if (scriptSetup \u0026amp;\u0026amp; scriptSetupLang !== \u0026#39;ts\u0026#39;) { // do not process non js/ts script blocks  return scriptSetup }     这里是说如果有 \u0026lt;script setup\u0026gt; 但是类型不是 ts 就直接返回 scriptSetup ?\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  const { compileScript, parse } = require(process.env.VNEXT_PKG_SFC + \u0026#34;/dist/compiler-sfc.cjs.js\u0026#34;); const { log } = require(process.env.BLOG_JS + \u0026#34;/utils.js\u0026#34;); const compile = (src, options) =\u0026gt; { const { descriptor } = parse(src); return compileScript(descriptor, { ...options, id: \u0026#34;xxxx\u0026#34; }); }; const res = compile(` \u0026lt;script lang=\u0026#34;ts\u0026#34;\u0026gt; import { a, a1, a2 } from \u0026#39;./a\u0026#39; \u0026lt;/script\u0026gt; \u0026lt;script lang=\u0026#34;ts\u0026#34; setup\u0026gt; import { b } from \u0026#39;./b\u0026#39; \u0026lt;/script\u0026gt; `);    handling script ... with setup userImports \u0026gt; [Object: null prototype] { a: { isType: false, imported: \u0026#39;a\u0026#39;, source: \u0026#39;./a\u0026#39; }, a1: { isType: false, imported: \u0026#39;a1\u0026#39;, source: \u0026#39;./a\u0026#39; }, a2: { isType: false, imported: \u0026#39;a2\u0026#39;, source: \u0026#39;./a\u0026#39; } } userImportAlias \u0026gt; [Object: null prototype] {} undefined   到此，因为还没实现 \u0026lt;script setup\u0026gt; 解析，所以只能看到普通 script 标签的处理结果。\nimport … from 处理  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20  for (const node of scriptAst) { // import ... from \u0026#39;...\u0026#39;  if (node.type === \u0026#34;ImportDeclaration\u0026#34;) { // record imports for dedupe  for (const specifier of node.specifiers) { const imported = specifier.type === \u0026#34;ImportSpecifier\u0026#34; \u0026amp;\u0026amp; specifier.imported.type === \u0026#34;Identifier\u0026#34; \u0026amp;\u0026amp; specifier.imported.name; registerUserImport( node.source.value, specifier.local.name, imported, node.importKind === \u0026#34;type\u0026#34; ); } console.log(\u0026#34;userImports \u0026gt; \\n\u0026#34;, userImports); console.log(\u0026#34;userImportAlias \u0026gt; \\n\u0026#34;, userImportAlias); } }     上面处理：遍历 script 中所有 ast 节点，找出 import ... from ... 语句，取出\n 引入的文件源部分： node.source.value\n 引入之后的变量或解构后的变量： imported.name\n 组成新的结构 { isType: false, imported: \u0026#39;a\u0026#39;, source: \u0026#39;./a\u0026#39;} 保存到 userImports 中\n 修改下，引入多个变量呢？结果如下：\nuserImports \u0026gt; [Object: null prototype] { a: { isType: false, imported: \u0026#39;a\u0026#39;, source: \u0026#39;./a\u0026#39; }, a1: { isType: false, imported: \u0026#39;a1\u0026#39;, source: \u0026#39;./a\u0026#39; }, a2: { isType: false, imported: \u0026#39;a2\u0026#39;, source: \u0026#39;./a\u0026#39; }   每个变量作为一项保存。\n  export default {} 处理   export default {} 语法的处理：\n1 2 3 4 5 6 7 8 9 10  /* else */ if (node.type === \u0026#34;ExportDefaultDeclaration\u0026#34;) { // export default  defaultExport = node; const start = node.start! + scriptStartOffset!; s.overwrite( start, start + `export default`.length, `const ${defaultTempVar}=` ); }     变量 s :\n const s = new MagicString(source)\n 等于是将 export default 内容赋值给 __default__ 变量上。\n export default {...} 处理成 const __default__ =\n GitHub - Rich-Harris/magic-string: Manipulate strings like a wizard\n 从仓库介绍:\n Suppose you have some source code. You want to make some light modifications to it - replacing a few characters here and there…\n 这个库的作用是用来替换源码中的部分代码的(字符串的一些操作)。\n 先看测试吧：输出处理前后的 source -\u0026gt; s\n1 2 3 4 5 6 7 8 9 10 11 12 13 14  // 源文件：/js/vue/lib.js const { compileSFC, log } = require(process.env.BLOG_JS + \u0026#34;/vue/lib.js\u0026#34;); const [result] = compileSFC(` \u0026lt;script lang=\u0026#34;ts\u0026#34;\u0026gt; export default { data() {}, computed: {} } \u0026lt;/script\u0026gt; \u0026lt;script lang=\u0026#34;ts\u0026#34; setup\u0026gt; export default {} \u0026lt;/script\u0026gt; `);    handling script ... with setup ----- before ----- \u0026lt;script lang=\u0026#34;ts\u0026#34;\u0026gt; export default { data() {}, computed: {} } \u0026lt;/script\u0026gt; \u0026lt;script lang=\u0026#34;ts\u0026#34; setup\u0026gt; export default {} \u0026lt;/script\u0026gt; ----- after ----- \u0026lt;script lang=\u0026#34;ts\u0026#34;\u0026gt; const __default__ = { data() {}, computed: {} } \u0026lt;/script\u0026gt; \u0026lt;script lang=\u0026#34;ts\u0026#34; setup\u0026gt; export default {} \u0026lt;/script\u0026gt; undefined   结果如上。\n Tip: 请忽略 setup 部分，因为必须要有一个 \u0026lt;script setup\u0026gt; 且必须是 ts 语言才能进 入到这部分处理。\n   export … [from] 处理   export { ...} from \u0026#39;...\u0026#39; 的处理。\n 如：\n export { x as default } from \u0026#39;./x\u0026#39;\n export { x as default }\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33  /*else*/ if (node.type === \u0026#34;ExportNamedDeclaration\u0026#34; \u0026amp;\u0026amp; node.specifiers) { const defaultSpecifier = node.specifiers.find( (s) =\u0026gt; s.exported.type === \u0026#34;Identifier\u0026#34; \u0026amp;\u0026amp; s.exported.name === \u0026#34;default\u0026#34; ) as ExportSpecifier; if (defaultSpecifier) { defaultExport = node; // 1. remove specifier  if (node.specifiers.length \u0026gt; 1) { s.remove( defaultSpecifier.start! + scriptStartOffset!, defaultSpecifier.end! + scriptStartOffset! ); } else { s.remove( node.start! + scriptStartOffset!, node.end! + scriptStartOffset! ); } if (node.source) { // export { x as default } from \u0026#39;./x\u0026#39;  // 重写成 rewrite to `import { x as __default } from \u0026#39;./x\u0026#39;  // 然后添加到顶部  s.prepend( `import { ${defaultSpecifier.local.name}as ${defaultTempVar}} from \u0026#39;${node.source.value}\u0026#39;\\n` ); } else { // export { x as default }  // 重写成 `const __default__ = x` 且移到最后  s.append(`\\nconst ${defaultTempVar}= ${defaultSpecifier.local.name}\\n`); } } }     测试\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  // 源文件：/js/vue/lib.js const { compileSFC, log } = require(process.env.BLOG_JS + \u0026#34;/vue/lib.js\u0026#34;); compileSFC(` \u0026lt;script lang=\u0026#34;ts\u0026#34;\u0026gt;export { a as default } from \u0026#39;./x\u0026#39;\u0026lt;/script\u0026gt; \u0026lt;script lang=\u0026#34;ts\u0026#34; setup\u0026gt;export default {}\u0026lt;/script\u0026gt; `); compileSFC(` \u0026lt;script lang=\u0026#34;ts\u0026#34;\u0026gt; const a = {} export { a as default } \u0026lt;/script\u0026gt; \u0026lt;script lang=\u0026#34;ts\u0026#34; setup\u0026gt;export default {}\u0026lt;/script\u0026gt; `);    handling script ... with setup ----- s, source, before ----- \u0026lt;script lang=\u0026#34;ts\u0026#34;\u0026gt;export { a as default } from \u0026#39;./x\u0026#39;\u0026lt;/script\u0026gt; \u0026lt;script lang=\u0026#34;ts\u0026#34; setup\u0026gt;export default {}\u0026lt;/script\u0026gt; ----- s, source, after ----- import { a as __default__ } from \u0026#39;./x\u0026#39; \u0026lt;script lang=\u0026#34;ts\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;script lang=\u0026#34;ts\u0026#34; setup\u0026gt;export default {}\u0026lt;/script\u0026gt; handling script ... with setup ----- s, source, before ----- \u0026lt;script lang=\u0026#34;ts\u0026#34;\u0026gt; const a = {} export { a as default } \u0026lt;/script\u0026gt; \u0026lt;script lang=\u0026#34;ts\u0026#34; setup\u0026gt;export default {}\u0026lt;/script\u0026gt; ----- s, source, after ----- \u0026lt;script lang=\u0026#34;ts\u0026#34;\u0026gt; const a = {} \u0026lt;/script\u0026gt; \u0026lt;script lang=\u0026#34;ts\u0026#34; setup\u0026gt;export default {}\u0026lt;/script\u0026gt; const __default__ = a undefined   从文件导入的，放到 source 最前面去了\n 用变量导出的，放到 source 最后面去了\n    2⃣ 8edf0d7 解析 \u0026lt;script setup\u0026gt;   feat(add): sfc-\u0026gt;script, setup ref process · gcclll/stb-vue-next@8edf0d7\n 如果只保留关键代码，这里的处理主要在 processRefExpression() 中\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34  // @babel/parser 解析出\u0026lt;script setup\u0026gt; 的 ast const scriptSetupAst = parse( scriptSetup.content, { plugins: [ ...plugins, // allow top level await but only inside \u0026lt;script setup\u0026gt;  \u0026#34;topLevelAwait\u0026#34;, ], sourceType: \u0026#34;module\u0026#34;, }, startOffset ); for (const node of scriptSetupAst) { // ... 省略  // 处理 `ref: x` 绑定，转成 refs  if ( node.type === \u0026#34;LabeledStatement\u0026#34; \u0026amp;\u0026amp; node.label.name === \u0026#34;ref\u0026#34; \u0026amp;\u0026amp; node.body.type === \u0026#34;ExpressionStatement\u0026#34; ) { // 必须要开启 ref 功能  if (enableRefSugar) { warnExperimental(`ref: sugar`, 228); s.overwrite( node.label.start! + startOffset, node.boy.start! + startOffset, \u0026#34;const \u0026#34; ); processRefExpression(node.body.expression, node); } } }     下面是 processRefExpression 对 ref: 语法糖的各种使用情况分析。\nd4f6497 ref: n = 100   feat(add): sfc-\u0026gt;script, ref: in setup · gcclll/stb-vue-next@d4f6497\n 将 ref: n = 100 翻译成 const n = _ref(100)\n 新增核心处理代码： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  // 源文件：/js/vue/lib.js const { compileSFC, log } = require(process.env.BLOG_JS + \u0026#34;/vue/lib.js\u0026#34;); compileSFC( ` \u0026lt;script lang=\u0026#34;ts\u0026#34;\u0026gt; const a = {} export { a as default } \u0026lt;/script\u0026gt; \u0026lt;script lang=\u0026#34;ts\u0026#34; setup\u0026gt; ref: n = 100 \u0026lt;/script\u0026gt; `, { enableRefSugar: true } );      db7cb02 ref: { n = 1 } = useFoo()   feat(add): sfc-\u0026gt;script, ref: ({ b: 1} = {}) · gcclll/stb-vue-next@db7cb02\n 对象解构语法支持。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  // 源文件：/js/vue/lib.js const { compileSFC, log } = require(process.env.BLOG_JS + \u0026#34;/vue/lib.js\u0026#34;); compileSFC( ` \u0026lt;script\u0026gt; export default { b: 2 } \u0026lt;/script\u0026gt; \u0026lt;script setup\u0026gt; ref: ({ b = 1, foo: bar, nested: { baz: bax } } = { count: 0, b: 2 }) \u0026lt;/script\u0026gt; `, { enableRefSugar: true } );    ---- before ---- \u0026lt;script\u0026gt; const __default__ = { b: 2 } \u0026lt;/script\u0026gt; \u0026lt;script setup\u0026gt; ref: ({ b = 1, foo: bar, nested: { baz: bax } } = { count: 0, b: 2 }) \u0026lt;/script\u0026gt; ---- after ---- \u0026lt;script\u0026gt; const __default__ = { b: 2 } \u0026lt;/script\u0026gt; \u0026lt;script setup\u0026gt; const { b: __b = 1, foo: __bar, nested: { baz: __bax } } = { count: 0, b: 2 } \u0026lt;/script\u0026gt; undefined   支持解构后重命名：feat(add): sfc-\u0026gt;script, ref: ({ b: bb} = {}) rename · gcclll/stb-vue-next@e83d25a\n 对象嵌套解构：feat(add): sfc-\u0026gt;script, ref deconstruct nested object · gcclll/stb-vue-next@5c615d5\n 解构重命名：feat(add): sfc-\u0026gt;script, ref deconstruct object rename · gcclll/stb-vue-next@e3ffe6f\n  af26553 ref: [a] = useFoo() 数据解构   feat(add): sfc-\u0026gt;script, ref deconstruct array · gcclll/stb-vue-next@af26553\n1 2 3 4 5 6 7 8 9 10 11 12 13  const { compileSFC, log } = require(process.env.BLOG_JS + \u0026#34;/vue/lib.js\u0026#34;); compileSFC( ` \u0026lt;script\u0026gt; export default { b: 2 } \u0026lt;/script\u0026gt; \u0026lt;script setup\u0026gt; ref: ({ foo: [bar], baz: [,,bax]} = useFoo()) \u0026lt;/script\u0026gt; `, { enableRefSugar: true } );    ---- before ---- \u0026lt;script\u0026gt; const __default__ = { b: 2 } \u0026lt;/script\u0026gt; \u0026lt;script setup\u0026gt; ref: ({ foo: [bar], baz: [,,bax]} = useFoo()) \u0026lt;/script\u0026gt; ---- after ---- \u0026lt;script\u0026gt; const __default__ = { b: 2 } \u0026lt;/script\u0026gt; \u0026lt;script setup\u0026gt; const { foo: [__bar], baz: [,,__bax]} = useFoo() const bar = _ref(__bar); const bax = _ref(__bax); \u0026lt;/script\u0026gt; undefined    a9f4469 ref: ({…foo} = useFoo()) 展开符   feat(add): sfc-\u0026gt;script, ref deconstruct with es6 rest element · gcclll/stb-vue-next@a9f4469\n1 2 3 4 5 6 7 8 9 10 11 12 13  const { compileSFC, log } = require(process.env.BLOG_JS + \u0026#34;/vue/lib.js\u0026#34;); compileSFC( ` \u0026lt;script\u0026gt; export default { b: 2 } \u0026lt;/script\u0026gt; \u0026lt;script setup\u0026gt; ref: ({...foo} = useFoo()) \u0026lt;/script\u0026gt; `, { enableRefSugar: true } );    ---- before ---- \u0026lt;script\u0026gt; const __default__ = { b: 2 } \u0026lt;/script\u0026gt; \u0026lt;script setup\u0026gt; ref: ({...fo} = useFoo()) \u0026lt;/script\u0026gt; ---- after ---- \u0026lt;script\u0026gt; const __default__ = { b: 2 } \u0026lt;/script\u0026gt; \u0026lt;script setup\u0026gt; const {...__fo} = useFoo() \u0026lt;/script\u0026gt; undefined    d52a6d0 _ref(…) 增加 ref 声明   feat(add): sfc-\u0026gt;script, ref all variables · gcclll/stb-vue-next@d52a6d0\n 在解析完所有 ref: xxx 语法之后，需要将解构出来的编码，进行 ref 化。\n1 2 3 4 5 6 7 8 9 10 11  const { compileSFC, log } = require(process.env.BLOG_JS + \u0026#39;/vue/lib.js\u0026#39;) compileSFC(` \u0026lt;script\u0026gt;export default {}\u0026lt;/script\u0026gt; \u0026lt;script setup\u0026gt; ref: ({ a, b: { foo, bar: bax }, c = 1, d: [doo1,, doo3], e: e1 = 2 } = useFoo()); \u0026lt;/script\u0026gt; `, { enableRefSugar: true })    ---- before ---- \u0026lt;script\u0026gt;const __default__ = {}\u0026lt;/script\u0026gt; \u0026lt;script setup\u0026gt; ref: ({ a, b: { foo, bar: bax }, c = 1, d: [doo1,, doo3], e: e1 = 2 } = useFoo()); \u0026lt;/script\u0026gt; ---- after ---- \u0026lt;script\u0026gt;const __default__ = {}\u0026lt;/script\u0026gt; \u0026lt;script setup\u0026gt; const { a: __a, b: { foo: __foo, bar: __bax }, c: __c = 1, d: [__doo1,, __doo3], e: __e1 = 2 } = useFoo(); const a = _ref(__a); const foo = _ref(__foo); const bax = _ref(__bax); const c = _ref(__c); const doo1 = _ref(__doo1); const doo3 = _ref(__doo3); const e1 = _ref(__e1); \u0026lt;/script\u0026gt; undefined   到这里 ref 语法才算解析完成了。\n  借助 @babel/parser 得到 script[setup] ast 处理 ref 及解构语法\n  将解构之后的变量进行 ref 语法化。\n    168041c ref: a = 1, b = 2 多条语句   feat(add): sfc-\u0026gt;script, multiple statements after ref: · gcclll/stb-vue-next@168041c\n1 2 3 4 5 6 7 8 9 10 11  const { compileSFC, log } = require(process.env.BLOG_JS + \u0026#34;/vue/lib.js\u0026#34;); compileSFC( ` \u0026lt;script\u0026gt;export default {}\u0026lt;/script\u0026gt; \u0026lt;script setup\u0026gt; ref: a = 1, b = 2, c = 3 \u0026lt;/script\u0026gt; `, { enableRefSugar: true } );    ---- before ---- \u0026lt;script\u0026gt;const __default__ = {}\u0026lt;/script\u0026gt; \u0026lt;script setup\u0026gt; ref: a = 1, b = 2, c = 3 \u0026lt;/script\u0026gt; ---- after ---- \u0026lt;script\u0026gt;const __default__ = {}\u0026lt;/script\u0026gt; \u0026lt;script setup\u0026gt; const a = _ref(1), b = _ref(2), c = _ref(3) \u0026lt;/script\u0026gt; undefined    6e337c5 imports 置顶🔝   feat(add): sfc-\u0026gt;script, hoist imports to top · gcclll/stb-vue-next@6e337c5\n1 2 3 4 5 6 7 8 9 10 11 12 13  const { compileSFC, log } = require(process.env.BLOG_JS + \u0026#34;/vue/lib.js\u0026#34;); compileSFC( ` \u0026lt;script\u0026gt;export default {}\u0026lt;/script\u0026gt; \u0026lt;script setup\u0026gt; import { a } from \u0026#39;./a\u0026#39; import { b } from \u0026#39;./b\u0026#39; import { foo, bar } from \u0026#39;./baz\u0026#39; \u0026lt;/script\u0026gt; `, { enableRefSugar: true } );    ---- before ---- \u0026lt;script\u0026gt;const __default__ = {}\u0026lt;/script\u0026gt; \u0026lt;script setup\u0026gt; import { a } from \u0026#39;./a\u0026#39; import { b } from \u0026#39;./b\u0026#39; import { foo, bar } from \u0026#39;./baz\u0026#39; \u0026lt;/script\u0026gt; ---- after ---- import { a } from \u0026#39;./a\u0026#39; \u0026lt;script\u0026gt;const __default__ = {}\u0026lt;/script\u0026gt; \u0026lt;script setup\u0026gt; import { b } from \u0026#39;./b\u0026#39; import { foo, bar } from \u0026#39;./baz\u0026#39; \u0026lt;/script\u0026gt; ---- before ---- import { a } from \u0026#39;./a\u0026#39; \u0026lt;script\u0026gt;const __default__ = {}\u0026lt;/script\u0026gt; \u0026lt;script setup\u0026gt; import { b } from \u0026#39;./b\u0026#39; import { foo, bar } from \u0026#39;./baz\u0026#39; \u0026lt;/script\u0026gt; ---- after ---- import { a } from \u0026#39;./a\u0026#39; import { b } from \u0026#39;./b\u0026#39; \u0026lt;script\u0026gt;const __default__ = {}\u0026lt;/script\u0026gt; \u0026lt;script setup\u0026gt; import { foo, bar } from \u0026#39;./baz\u0026#39; \u0026lt;/script\u0026gt; ---- before ---- import { a } from \u0026#39;./a\u0026#39; import { b } from \u0026#39;./b\u0026#39; \u0026lt;script\u0026gt;const __default__ = {}\u0026lt;/script\u0026gt; \u0026lt;script setup\u0026gt; import { foo, bar } from \u0026#39;./baz\u0026#39; \u0026lt;/script\u0026gt; ---- after ---- import { a } from \u0026#39;./a\u0026#39; import { b } from \u0026#39;./b\u0026#39; import { foo, bar } from \u0026#39;./baz\u0026#39; \u0026lt;script\u0026gt;const __default__ = {}\u0026lt;/script\u0026gt; \u0026lt;script setup\u0026gt; \u0026lt;/script\u0026gt; undefined   如上，经过几轮循环，将三个 import 提升到了最开始位置。\n  TODO 68d4940 defineProps/Emit() 处理   feat(add): sfc-\u0026gt;script, defineProps/Emit · gcclll/stb-vue-next@68d4940\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34  const { compile, log } = require(process.env.BLOG_JS + \u0026#34;/vue/lib.js\u0026#34;); const {content, bindings} = compile(` \u0026lt;script setup lang=\u0026#34;ts\u0026#34;\u0026gt; import { defineProps } from \u0026#39;vue\u0026#39; interface Test {} type Alias = number[] defineProps\u0026lt;{ string: string number: number boolean: boolean object: object objectLiteral: { a: number } fn: (n: number) =\u0026gt; void functionRef: Function objectRef: Object array: string[] arrayRef: Array\u0026lt;any\u0026gt; tuple: [number, number] set: Set\u0026lt;string\u0026gt; literal: \u0026#39;foo\u0026#39; optional?: any recordRef: Record\u0026lt;string, null\u0026gt; interface: Test alias: Alias union: string | number literalUnion: \u0026#39;foo\u0026#39; | \u0026#39;bar\u0026#39; literalUnionMixed: \u0026#39;foo\u0026#39; | 1 | boolean intersection: Test \u0026amp; {} }\u0026gt;() \u0026lt;/script\u0026gt;`)        3⃣ 5160a6d ref -\u0026gt; ref.value   feat(add): sfc-\u0026gt;script, ref -\u0026gt; ref.value · gcclll/stb-vue-next@5160a6d\n 将对 ref 变量的访问转成对 ref.value 的访问。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  const { compileSFC, log, compile } = require(process.env.BLOG_JS + \u0026#34;/vue/lib.js\u0026#34;); const { content } = compile( ` \u0026lt;script setup\u0026gt; ref: a = 1 console.log(a) function get() { return a + 1 } \u0026lt;/script\u0026gt; ` ); console.log(content);    { enableRefSugar: true, refBindings: [Object: null prototype] { a: \u0026#39;setup-ref\u0026#39; } } \u0026lt;script setup\u0026gt; const a = _ref(1) console.log(a.value) function get() { return a.value + 1 } \u0026lt;/script\u0026gt; undefined    TODO 4⃣ a6f4dae extract define props/emits   feat(add): sfc-\u0026gt;script, extract props/emits · gcclll/stb-vue-next@a6f4dae\n1 2 3 4 5 6 7 8 9 10  const { compile, log } = require(process.env.BLOG_JS + \u0026#39;/vue/lib.js\u0026#39;) const { content } = compile(` \u0026lt;script setup\u0026gt; defineProps({ foo: String }) \u0026lt;/script\u0026gt; `) console.log(content)    ExpressionStatement -- undefined {} xx undefined    TODO 5⃣ 480acf0 checkInvalidScopeReference   feat(add): sfc-\u0026gt;script, check invalid scope references · gcclll/stb-vue-next@480acf0\n 检查 useOptions ，是否包含 \u0026lt;setup\u0026gt; 中已经存在的变量，即 useOptions 中不能 有 setup 中声明的变量。\n  TODO 6⃣ 25662c6 删除非 script 内容   feat(add): sfc-\u0026gt;script, delete non-script content · gcclll/stb-vue-next@25662c6\n  7⃣ deed8c1 analyze binding metadata(bindingMetadata)   feat(add): sfc-\u0026gt;script, analyze binding metadata · gcclll/stb-vue-next@deed8c1\n1 2 3 4 5 6 7 8 9 10 11  const { compile, log } = require(process.env.BLOG_JS + \u0026#34;/vue/lib.js\u0026#34;); const res = compile(` \u0026lt;script setup\u0026gt; const props = defineProps({ foo: String }) ref: a = 1 const b = 2 \u0026lt;/script\u0026gt; `); console.log(res.bindings);    { foo: \u0026#39;props\u0026#39;, props: \u0026#39;setup-const\u0026#39;, a: \u0026#39;setup-ref\u0026#39;, b: \u0026#39;setup-const\u0026#39; } undefined    8⃣ 9cd2fd5 inject useCssVars, css 变量处理   feat(add): sfc-\u0026gt;script, inject useCssVars · gcclll/stb-vue-next@9cd2fd5\n\u0026lt;style\u0026gt; v-bind css 变量   处理 style 中使用的 css 变量\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  // compileScript.ts // TODO 8. 注入 `useCssVars` 调用  if (cssVars.length) { helperImports.add(CSS_VARS_HELPER) helperImports.add(\u0026#39;unref\u0026#39;) s.prependRight( startOffset, `\\n${genCssVarsCode( cssVars, bindingMetadata, scopeId, !!options.isProd )}\\n` ) }     测试：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25  const { compile, log } = require(process.env.BLOG_JS + \u0026#34;/vue/lib.js\u0026#34;); const { content } = compile(` \u0026lt;script\u0026gt;const a = 1\u0026lt;/script\u0026gt; \u0026lt;script setup\u0026gt; import { defineProps, ref } from \u0026#39;vue\u0026#39; const color = \u0026#39;red\u0026#39; const height = ref(\u0026#39;10px\u0026#39;) defineProps({ foo: Striing }) \u0026lt;/script\u0026gt; \u0026lt;style\u0026gt; div { color: v-bind(color); font-size: v-bind(\u0026#39;font.size\u0026#39;); height: v-bind(height); border: v-bind(foo) } \u0026lt;/style\u0026gt; `); // 1. 本地变量绑定 // 2. 本地 ref 绑定 // 3. props 绑定 console.log(content);    import { ref } from \u0026#39;vue\u0026#39; const a = 1 _useCssVars(_ctx =\u0026gt; ({ \u0026#34;xxxxxxxx-color\u0026#34;: (color), \u0026#34;xxxxxxxx-font_size\u0026#34;: (_ctx.font.size), \u0026#34;xxxxxxxx-height\u0026#34;: (height.value), \u0026#34;xxxxxxxx-foo\u0026#34;: (__props.foo) })) const color = \u0026#39;red\u0026#39; const height = ref(\u0026#39;10px\u0026#39;) undefined    css 变量重写：   源码处理：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18  const needRewrite = cssVars.length || hasInheritAttrsFlag; let content = script.content; if (needRewrite) { content = rewriteDefault(content, `__default__`, plugins); if (cssVars.length) { content += genNormalScriptCssVarsCode( cssVars, bindings, scopeId, !!options.isProd ); } if (hasInheritAttrsFlag) { content += `__default__.inheritAttrs = false`; } content += `\\nexport default __default__`; }     测试：\n1 2 3 4 5 6 7 8 9 10 11 12  const { compileStyle, log } = require(process.env.BLOG_JS + \u0026#34;/vue/lib.js\u0026#34;); const { code } = compileStyle({ source: `.foo { color: v-bind(color); font-size: v-bind(\u0026#39;font.size\u0026#39;); }`, filename: \u0026#34;test.css\u0026#34;, id: \u0026#34;data-v-test\u0026#34;, }); console.log(code);    .foo { color: var(--test-color); font-size: var(--test-font_size); } undefined    isProd option 使用 hash 变量名   生产模式，使用随机 hash 值作为名字：\n1 2 3 4 5 6 7 8  // cssVars.ts function genVarName(id: string, raw: string, isProd: boolean): string { if (isProd) { return hash(id + raw) } else { return `${id}-${raw.replace(/([^\\w-])/g, \u0026#39;_\u0026#39;)}` } }     测试：\n1 2 3 4 5 6 7 8 9 10 11  const { compile, log } = require(process.env.BLOG_JS + \u0026#34;/vue/lib.js\u0026#34;); const { content } = compile( `\u0026lt;script\u0026gt;const a = 1\u0026lt;/script\u0026gt;\\n` + `\u0026lt;style\u0026gt;div{ color: v-bind(color); font-size: v-bind(\u0026#39;font.size\u0026#39;); }\u0026lt;/style\u0026gt;`, { isProd: true } ); console.log(content);    const a = 1 const __default__ = {} import { useCssVars as _useCssVars } from \u0026#39;vue\u0026#39; const __injectCSSVars__ = () =\u0026gt; { _useCssVars(_ctx =\u0026gt; ({ \u0026#34;4003f1a6\u0026#34;: (_ctx.color), \u0026#34;41b6490a\u0026#34;: (_ctx.font.size) }))} const __setup__ = __default__.setup __default__.setup = __setup__ ? (props, ctx) =\u0026gt; { __injectCSSVars__();return __setup__(props, ctx) } : __injectCSSVars__ export default __default__ undefined      TODO 9⃣ eef6fd5 setup() 参数签名   feat(add): sfc-\u0026gt;script, setup() 参数签名 · gcclll/stb-vue-next@eef6fd5\n1 2 3 4 5 6 7 8 9 10  const { compile, log } = require(process.env.BLOG_JS + \u0026#39;/vue/lib.js\u0026#39;) const { content } = compile(` \u0026lt;script setup lang=\u0026#34;ts\u0026#34;\u0026gt; import { defineProps, defineEmit } from \u0026#39;vue\u0026#39; const props = defineProps({ foo: String }) const emit = defineEmit([\u0026#39;a\u0026#39;, \u0026#39;b\u0026#39;]) \u0026lt;/script\u0026gt;`) console.log(content)    import { defineComponent as _defineComponent } from \u0026#39;vue\u0026#39; export default _defineComponent({ expose: [], props: { foo: String }, emits: [\u0026#39;a\u0026#39;, \u0026#39;b\u0026#39;], setup(__props, { emit }) { const props = __props return { props, emit } } }) undefined    🔟 9cedeab 生成 return 语句   feat(add): sfc-\u0026gt;script, process render function return · gcclll/stb-vue-next@9cedeab\n1 2 3 4 5 6 7 8 9 10  const { compile, log } = require(process.env.BLOG_JS + \u0026#34;/vue/lib.js\u0026#34;); const { content } = compile(` \u0026lt;script setup\u0026gt; import { x } from \u0026#39;./x\u0026#39; let a = 1 const b = 2 function c() {} class d {} \u0026lt;/script\u0026gt;`); console.log(content);    import { x } from \u0026#39;./x\u0026#39; let a = 1 const b = 2 function c() {} class d {} return { a, b, c, d, x } } undefined   将所有变量都返回出去了。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19  const { compile, log } = require(process.env.BLOG_JS + \u0026#34;/vue/lib.js\u0026#34;); const { content } = compile( ` \u0026lt;script setup\u0026gt; import { ref } from \u0026#39;vue\u0026#39; const count = ref(0) \u0026lt;/script\u0026gt; \u0026lt;template\u0026gt; \u0026lt;div\u0026gt;{{ count }}\u0026lt;/div\u0026gt; \u0026lt;div\u0026gt;static\u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;style\u0026gt; div { color: v-bind(count) } \u0026lt;/style\u0026gt;`, { inlineTemplate: true, } ); console.log(content);    import { toDisplayString as _toDisplayString, createVNode as _createVNode, Fragment as _Fragment, openBlock as _openBlock, createBlock as _createBlock } from \u0026#34;vue\u0026#34; const _hoisted_1 = /*#__PURE__*/_createVNode(\u0026#34;div\u0026#34;, null, \u0026#34;static\u0026#34;, -1 /* HOISTED */) import { ref } from \u0026#39;vue\u0026#39; _useCssVars(_ctx =\u0026gt; ({ \u0026#34;xxxxxxxx-count\u0026#34;: (count.value) })) const count = ref(0) return (_ctx, _cache) =\u0026gt; { return (_openBlock(), _createBlock(_Fragment, null, [ _createVNode(\u0026#34;div\u0026#34;, null, _toDisplayString(count.value), 1 /* TEXT */), _hoisted_1 ], 64 /* STABLE_FRAGMENT */)) } } undefined   如果要支持：\n1 2 3 4 5 6  { inlineTemplate: true, templateOptions: { ssr: true } }     还需要实现 compiler-ssr 模块：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19  // TODO 10. 生成返回语句(return) let returned; if (options.inlineTemplate) { if (sfc.template \u0026amp;\u0026amp; !sfc.template.src) { // TODO 需要 compiler-ssr 支持  } else { returned = `() =\u0026gt; {}`; } } else { // return bindings from setup  const allBindings: Record\u0026lt;string, any\u0026gt; = { ...setupBindings }; for (const key in userImports) { if (!userImports[key].isType) { allBindings[key] = true; } } returned = `{ ${Object.keys(allBindings).join(\u0026#34;, \u0026#34;)}}`; } s.appendRight(endOffset, `\\nreturn ${returned}\\n}\\n\\n`);      TODO 1⃣1⃣ cfca9de finalize default export   feat(add): sfc-\u0026gt;script, finalize default export · gcclll/stb-vue-next@cfca9de\n1 2 3 4 5 6 7 8 9 10 11 12  const { compile, log } = require(process.env.BLOG_JS + \u0026#39;/vue/lib.js\u0026#39;) const { content, bindings } = compile(` \u0026lt;script setup\u0026gt; import { defineEmit } from \u0026#39;vue\u0026#39; const myEmit = defineEmit([\u0026#39;foo\u0026#39;, \u0026#39;bar\u0026#39;]) const props = defineProps({ foo: String }) \u0026lt;/script\u0026gt; `) console.log(content)    export default { expose: [], props: { foo: String }, emits: [\u0026#39;foo\u0026#39;, \u0026#39;bar\u0026#39;], setup(__props, { emit: myEmit }) { const props = __props return { myEmit, props } } } undefined   emits 哪去了??? -\u0026gt; fix: d631810\n  FIX: fix: sfc-\u0026gt;script, expose indent · gcclll/stb-vue-next@d631810\n  TODO 1⃣2⃣ 5810296 finalize Vue helper imports   feat(add): sfc-\u0026gt;script, finalize vue helper imports · gcclll/stb-vue-next@5810296\n    61c3b7a transform src set   feat(add): sfc-\u0026gt;srcset transform · gcclll/stb-vue-next@61c3b7a\n 转换 \u0026lt;img\u0026gt; 和 \u0026lt;source\u0026gt; 的 srcset 属性。\n img srcset 属性值： \u0026lt;img srcset=\u0026#34;url 1x, url2 2x, ...\u0026#34;\u0026gt; 浏览器会根据实际情况来 选用 srcset 中合适的图片地址来显示。\n 有关 Reponsive Images 说明: Responsive images - Learn web development | MDN。\n  测试：\n1 2 3 4  const { compileWithSrcset: compile, log, src } = require(process.env.BLOG_JS + \u0026#39;/vue/lib.js\u0026#39;) const { code } = compile(src) console.log(code)    import { createVNode as _createVNode, Fragment as _Fragment, openBlock as _openBlock, createBlock as _createBlock } from \u0026#34;vue\u0026#34; import _imports_0 from \u0026#39;./logo.png\u0026#39; const _hoisted_1 = _imports_0 const _hoisted_2 = _imports_0 + \u0026#39;2x\u0026#39; const _hoisted_3 = _imports_0 + \u0026#39;2x\u0026#39; const _hoisted_4 = _imports_0 + \u0026#39;, \u0026#39; + _imports_0 + \u0026#39;2x\u0026#39; const _hoisted_5 = _imports_0 + \u0026#39;2x, \u0026#39; + _imports_0 const _hoisted_6 = _imports_0 + \u0026#39;2x, \u0026#39; + _imports_0 + \u0026#39;3x\u0026#39; const _hoisted_7 = _imports_0 + \u0026#39;, \u0026#39; + _imports_0 + \u0026#39;2x, \u0026#39; + _imports_0 + \u0026#39;3x\u0026#39; const _hoisted_8 = \u0026#34;/logo.png\u0026#34; + \u0026#39;, \u0026#39; + _imports_0 + \u0026#39;2x\u0026#39; export function render(_ctx, _cache) { return (_openBlock(), _createBlock(_Fragment, null, [ _createVNode(\u0026#34;img\u0026#34;, { src: \u0026#34;./logo.png\u0026#34;, srcset: _hoisted_1 }), _createVNode(\u0026#34;img\u0026#34;, { src: \u0026#34;./logo.png\u0026#34;, srcset: _hoisted_2 }), _createVNode(\u0026#34;img\u0026#34;, { src: \u0026#34;./logo.png\u0026#34;, srcset: _hoisted_3 }), _createVNode(\u0026#34;img\u0026#34;, { src: \u0026#34;./logo.png\u0026#34;, srcset: _hoisted_4 }), _createVNode(\u0026#34;img\u0026#34;, { src: \u0026#34;./logo.png\u0026#34;, srcset: _hoisted_5 }), _createVNode(\u0026#34;img\u0026#34;, { src: \u0026#34;./logo.png\u0026#34;, srcset: _hoisted_6 }), _createVNode(\u0026#34;img\u0026#34;, { src: \u0026#34;./logo.png\u0026#34;, srcset: _hoisted_7 }), _createVNode(\u0026#34;img\u0026#34;, { src: \u0026#34;/logo.png\u0026#34;, srcset: \u0026#34;/logo.png, /logo.png 2x\u0026#34; }), _createVNode(\u0026#34;img\u0026#34;, { src: \u0026#34;https://example.com/logo.png\u0026#34;, srcset: \u0026#34;https://example.com/logo.png, https://example.com/logo.png 2x\u0026#34; }), _createVNode(\u0026#34;img\u0026#34;, { src: \u0026#34;/logo.png\u0026#34;, srcset: _hoisted_8 }), _createVNode(\u0026#34;img\u0026#34;, { src: \u0026#34;data:image/png;base64,i\u0026#34;, srcset: \u0026#34;data:image/png;base64,i 1x, data:image/png;base64,i 2x\u0026#34; }) ], 64 /* STABLE_FRAGMENT */)) } undefined   指定 options.base: \u0026#39;/foo\u0026#39; 测试结果：\n1 2 3 4  const { compileWithSrcset: compile, log, src } = require(process.env.BLOG_JS + \u0026#39;/vue/lib.js\u0026#39;) const { code } = compile(src, { base: \u0026#39;/foo\u0026#39; }) console.log(code)    import { createVNode as _createVNode, Fragment as _Fragment, openBlock as _openBlock, createBlock as _createBlock } from \u0026#34;vue\u0026#34; export function render(_ctx, _cache) { return (_openBlock(), _createBlock(_Fragment, null, [ _createVNode(\u0026#34;img\u0026#34;, { src: \u0026#34;./logo.png\u0026#34;, srcset: \u0026#34;/foo/logo.png\u0026#34; }), _createVNode(\u0026#34;img\u0026#34;, { src: \u0026#34;./logo.png\u0026#34;, srcset: \u0026#34;/foo/logo.png 2x\u0026#34; }), _createVNode(\u0026#34;img\u0026#34;, { src: \u0026#34;./logo.png\u0026#34;, srcset: \u0026#34;/foo/logo.png 2x\u0026#34; }), _createVNode(\u0026#34;img\u0026#34;, { src: \u0026#34;./logo.png\u0026#34;, srcset: \u0026#34;/foo/logo.png, /foo/logo.png 2x\u0026#34; }), _createVNode(\u0026#34;img\u0026#34;, { src: \u0026#34;./logo.png\u0026#34;, srcset: \u0026#34;/foo/logo.png 2x, /foo/logo.png\u0026#34; }), _createVNode(\u0026#34;img\u0026#34;, { src: \u0026#34;./logo.png\u0026#34;, srcset: \u0026#34;/foo/logo.png 2x, /foo/logo.png 3x\u0026#34; }), _createVNode(\u0026#34;img\u0026#34;, { src: \u0026#34;./logo.png\u0026#34;, srcset: \u0026#34;/foo/logo.png, /foo/logo.png 2x, /foo/logo.png 3x\u0026#34; }), _createVNode(\u0026#34;img\u0026#34;, { src: \u0026#34;/logo.png\u0026#34;, srcset: \u0026#34;/logo.png, /logo.png 2x\u0026#34; }), _createVNode(\u0026#34;img\u0026#34;, { src: \u0026#34;https://example.com/logo.png\u0026#34;, srcset: \u0026#34;https://example.com/logo.png, https://example.com/logo.png 2x\u0026#34; }), _createVNode(\u0026#34;img\u0026#34;, { src: \u0026#34;/logo.png\u0026#34;, srcset: \u0026#34;/logo.png, /foo/logo.png 2x\u0026#34; }), _createVNode(\u0026#34;img\u0026#34;, { src: \u0026#34;data:image/png;base64,i\u0026#34;, srcset: \u0026#34;data:image/png;base64,i 1x, data:image/png;base64,i 2x\u0026#34; }) ], 64 /* STABLE_FRAGMENT */)) } undefined   options.includeAbsolute: true 选项:\n1 2 3 4  const { compileWithSrcset: compile, log, src } = require(process.env.BLOG_JS + \u0026#39;/vue/lib.js\u0026#39;) const { code } = compile(src, { includeAbsolute: true }) console.log(code)    import { createVNode as _createVNode, Fragment as _Fragment, openBlock as _openBlock, createBlock as _createBlock } from \u0026#34;vue\u0026#34; import _imports_0 from \u0026#39;./logo.png\u0026#39; import _imports_1 from \u0026#39;/logo.png\u0026#39; const _hoisted_1 = _imports_0 const _hoisted_2 = _imports_0 + \u0026#39;2x\u0026#39; const _hoisted_3 = _imports_0 + \u0026#39;2x\u0026#39; const _hoisted_4 = _imports_0 + \u0026#39;, \u0026#39; + _imports_0 + \u0026#39;2x\u0026#39; const _hoisted_5 = _imports_0 + \u0026#39;2x, \u0026#39; + _imports_0 const _hoisted_6 = _imports_0 + \u0026#39;2x, \u0026#39; + _imports_0 + \u0026#39;3x\u0026#39; const _hoisted_7 = _imports_0 + \u0026#39;, \u0026#39; + _imports_0 + \u0026#39;2x, \u0026#39; + _imports_0 + \u0026#39;3x\u0026#39; const _hoisted_8 = _imports_1 + \u0026#39;, \u0026#39; + _imports_1 + \u0026#39;2x\u0026#39; const _hoisted_9 = \u0026#34;https://example.com/logo.png\u0026#34; + \u0026#39;, \u0026#39; + \u0026#34;https://example.com/logo.png\u0026#34; + \u0026#39;2x\u0026#39; const _hoisted_10 = _imports_1 + \u0026#39;, \u0026#39; + _imports_0 + \u0026#39;2x\u0026#39; const _hoisted_11 = \u0026#34;data:image/png;base64,i\u0026#34; + \u0026#39;1x, \u0026#39; + \u0026#34;data:image/png;base64,i\u0026#34; + \u0026#39;2x\u0026#39; export function render(_ctx, _cache) { return (_openBlock(), _createBlock(_Fragment, null, [ _createVNode(\u0026#34;img\u0026#34;, { src: \u0026#34;./logo.png\u0026#34;, srcset: _hoisted_1 }), _createVNode(\u0026#34;img\u0026#34;, { src: \u0026#34;./logo.png\u0026#34;, srcset: _hoisted_2 }), _createVNode(\u0026#34;img\u0026#34;, { src: \u0026#34;./logo.png\u0026#34;, srcset: _hoisted_3 }), _createVNode(\u0026#34;img\u0026#34;, { src: \u0026#34;./logo.png\u0026#34;, srcset: _hoisted_4 }), _createVNode(\u0026#34;img\u0026#34;, { src: \u0026#34;./logo.png\u0026#34;, srcset: _hoisted_5 }), _createVNode(\u0026#34;img\u0026#34;, { src: \u0026#34;./logo.png\u0026#34;, srcset: _hoisted_6 }), _createVNode(\u0026#34;img\u0026#34;, { src: \u0026#34;./logo.png\u0026#34;, srcset: _hoisted_7 }), _createVNode(\u0026#34;img\u0026#34;, { src: \u0026#34;/logo.png\u0026#34;, srcset: _hoisted_8 }), _createVNode(\u0026#34;img\u0026#34;, { src: \u0026#34;https://example.com/logo.png\u0026#34;, srcset: _hoisted_9 }), _createVNode(\u0026#34;img\u0026#34;, { src: \u0026#34;/logo.png\u0026#34;, srcset: _hoisted_10 }), _createVNode(\u0026#34;img\u0026#34;, { src: \u0026#34;data:image/png;base64,i\u0026#34;, srcset: _hoisted_11 }) ], 64 /* STABLE_FRAGMENT */)) } undefined    总结   SFC 模块的作用：\n  解析 Render 函数，替换 ref 变量\n  解析 \u0026lt;script\u0026gt; 标签\n  解析 \u0026lt;script setup\u0026gt;\n  ref: 解析，将 ref: 类型访问转成对 ref.value 的访问\n  将 ref: { … } 解构后的变量进行 ref(…) 化\n  defineProps({ foo: String }) 解析，合并到 export default { props: {…} }\n  defineEmit({ … }) 解析，合并到 export default { emits: {…} }\n  cssVar v-bind 变量使用，转换，包含 ref 变量引用转换\n  asset url 转换(相对路径，绝对路径， ~@path/..., @path/.. 转换)\n  \u0026lt;img\u0026gt;, \u0026lt;source\u0026gt; 的 srcset URL转换\n   综合测试：\nscript[setup] 测试  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69  // 源文件：/js/vue/lib.js const { compileSFCScript, compileStyle, compileWithSrcset, log } = require(process.env.BLOG_JS + \u0026#39;/vue/lib.js\u0026#39;) const { content, bindings, attrs } = compileSFCScript(` \u0026lt;template\u0026gt; \u0026lt;div\u0026gt; \u0026lt;img src=\u0026#34;./logo.png\u0026#34; srcset=\u0026#34;./logo.png, ./logo.png 2x, ./logo.png 3x\u0026#34;/\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div\u0026gt;{{ count }}\u0026lt;/div\u0026gt; \u0026lt;div\u0026gt;static\u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script\u0026gt; const a = 1 export default { props: [\u0026#39;foo\u0026#39;, \u0026#39;bar\u0026#39;], data() { return { foo: null, bar } }, setup() { return { foo: 1, a } }, computed: { fcc() {}, bcc: { get() {}, set() {} } }, inject: [\u0026#39;fjj\u0026#39;, \u0026#39;bjj\u0026#39;], // { fjj: {}, bjj: {} }, methods: { quux() {} }, } \u0026lt;/script\u0026gt; \u0026lt;script setup\u0026gt; import { defineProps, ref } from \u0026#39;vue\u0026#39; let a, b, c, d ref: aa = 1 + (await foa) ref: height = 100 // 对象解构要用括号包裹起来 ref: ({ foo, bar: bar, baz: { bax } } = useFoo()); ref: [ar, br] = useFoo() ref: count = 0 const color = \u0026#39;red\u0026#39; const size = ref(\u0026#39;10px\u0026#39;) defineProps({ foo: String }) defineEmit([\u0026#39;fox\u0026#39;, \u0026#39;foy\u0026#39;]) // ref 在函数中被访问 function test() { const { a } = aa } \u0026lt;/script\u0026gt; \u0026lt;style\u0026gt; div { color: v-bind(color); font-size: v-bind(\u0026#39;font.size\u0026#39;); border: v-bind(foo); height: v-bind(height); } \u0026lt;/style\u0026gt; `) log(`\u0026gt;\u0026gt;\u0026gt; content 输出结果：`) log(content) log(`\u0026gt;\u0026gt;\u0026gt; bindings 输出结果：`) log(bindings)    \u0026gt;\u0026gt;\u0026gt; content 输出结果： import { ref as _ref, useCssVars as _useCssVars, unref as _unref } from \u0026#39;vue\u0026#39; import { ref } from \u0026#39;vue\u0026#39; const a = 1 const __default__ = { props: [\u0026#39;foo\u0026#39;, \u0026#39;bar\u0026#39;], data() { return { foo: null, bar } }, setup() { return { foo: 1, a } }, computed: { fcc() {}, bcc: { get() {}, set() {} } }, inject: [\u0026#39;fjj\u0026#39;, \u0026#39;bjj\u0026#39;], // { fjj: {}, bjj: {} }, methods: { quux() {} }, } async function setup(__props) { _useCssVars(_ctx =\u0026gt; ({ \u0026#34;xxxxxxxx-color\u0026#34;: (color), \u0026#34;xxxxxxxx-font_size\u0026#34;: (_ctx.font.size), \u0026#34;xxxxxxxx-foo\u0026#34;: (foo.value), \u0026#34;xxxxxxxx-height\u0026#34;: (height.value) })) let a, b, c, d const aa = _ref(1 + (await foa)) const height = _ref(100) // 对象解构要用括号包裹起来 const { foo: __foo, bar: __bar, baz: { bax: __bax } } = useFoo(); const foo = _ref(__foo); const bar = _ref(__bar); const bax = _ref(__bax); const [__ar, __br] = useFoo() const ar = _ref(__ar); const br = _ref(__br); const count = _ref(0) const color = \u0026#39;red\u0026#39; const size = ref(\u0026#39;10px\u0026#39;) // ref 在函数中被访问 function test() { const { a } = aa.value } return { a, b, c, d, aa, height, foo, bar, bax, ar, br, count, color, size, test, ref } } export default /*#__PURE__*/ Object.assign(__default__, { expose: [], props: { foo: String }, emits: [\u0026#39;fox\u0026#39;, \u0026#39;foy\u0026#39;], setup }) \u0026gt;\u0026gt;\u0026gt; bindings 输出结果： { foo: \u0026#39;setup-ref\u0026#39;, bar: \u0026#39;setup-ref\u0026#39;, a: \u0026#39;setup-let\u0026#39;, fcc: \u0026#39;options\u0026#39;, bcc: \u0026#39;options\u0026#39;, fjj: \u0026#39;options\u0026#39;, bjj: \u0026#39;options\u0026#39;, quux: \u0026#39;options\u0026#39;, ref: \u0026#39;setup-const\u0026#39;, b: \u0026#39;setup-let\u0026#39;, c: \u0026#39;setup-let\u0026#39;, d: \u0026#39;setup-let\u0026#39;, aa: \u0026#39;setup-ref\u0026#39;, height: \u0026#39;setup-ref\u0026#39;, bax: \u0026#39;setup-ref\u0026#39;, ar: \u0026#39;setup-ref\u0026#39;, br: \u0026#39;setup-ref\u0026#39;, count: \u0026#39;setup-ref\u0026#39;, color: \u0026#39;setup-const\u0026#39;, size: \u0026#39;setup-ref\u0026#39;, test: \u0026#39;setup-const\u0026#39; } undefined   结果简析：\n  \u0026lt;script setup\u0026gt; 标签内的代码都会被解析到 setup() {...} 函数中\n 即它和 \u0026lt;script\u0026gt; 中代码是不冲突的，比如 \u0026lt;script\u0026gt; 里面的变量 a 和 \u0026lt;script setup\u0026gt; 中的同名变量 a 互不影响。\n  在 \u0026lt;style\u0026gt; 中使用的 v-bind 指令会使用 _useCssVars 进行注册替换成实际的样 式值\n  defineProps 中定义的变量对应 export default -\u0026gt; props\n  defineEmits 中定义的变量对应 export default -\u0026gt; emits\n  ref: height = 100 中的 ref: 语法最终会转成对应的 _ref(100) reactive 变 量(语法糖，vue\u0026gt;compile-sfc解析)\n 并且支持多种用法，解构/多个声明组合/解构默认值，对于解构后的变量进行 _ref(...) 然后 setup return 中返回。\n ref: 语句中如果有解构(对象解构)操作，那么后面的解构表达式必须用括号(({ a } = useFoo()))包起来。\n Imp. ref: 解构中的变量名不能以 $ 开头。\n  如果 script 和 script setup 中的 export default 中同时包含同名属性，会被 script setup 中的替换掉。\n 因为生成的代码中是将 script setup 往 script 上合并。\n PS. \u0026lt;script\u0026gt; 和 \u0026lt;script setup\u0026gt; 中 export default 的内容尽量不要重复。\n     typescript 语言  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18  // 源文件：/js/vue/lib.js const { compileSFCScript: compile, compileStyle, log } = require(process.env.BLOG_JS + \u0026#39;/vue/lib.js\u0026#39;) const { scriptAst, content } = compile(` \u0026lt;script lang=\u0026#34;ts\u0026#34;\u0026gt; import { Options, Vue } from \u0026#39;vue-class-component\u0026#39;; @Options({ components: { HelloWorld, }, props: [\u0026#39;foo\u0026#39;, \u0026#39;bar\u0026#39;] }) export default class Home extends Vue {} \u0026lt;/script\u0026gt; `) console.log(content)    import { Options, Vue } from \u0026#39;vue-class-component\u0026#39;; @Options({ components: { HelloWorld, }, props: [\u0026#39;foo\u0026#39;, \u0026#39;bar\u0026#39;] }) export default class Home extends Vue {} undefined      ","permalink":"https://www.cheng92.com/vue/vue-mind-map-compiler-sfc/","tags":["vue,","vue3,","compiler-sfc"],"title":"Vue3 源码头脑风暴之 5 ☞ compiler-sfc"},{"categories":["linux"],"contents":" 👴 Commands(命令)  fasd  fasd [options] [query ...] [f|a|s|d|z] [opions] [query ...] options: -s list paths with scores -l list paths without scores -i interactive mode -e \u0026lt;cmd\u0026gt; set command to execute on the result file -b \u0026lt;name\u0026gt; only use \u0026lt;name\u0026gt; backend -B \u0026lt;name\u0026gt; add additional backend \u0026lt;name\u0026gt; -a match files and directories -d match directories only -f match files only -r match by rank only -t match by recent access only -R reverse listing order -h show a brief help message -[0-9] select the nth entry fasd [-A|-D] [paths ...] -A add paths -D delete paths  1  cd ~/ccc/tmp      grep, egrep, fgrep   grep(1) - Linux manual page\n grep [OPTION…] PATTERNS [FILE…] grep [OPTION…] -e PATTERNS … [FILE…] grep [OPTION…] -f PATTERN_FILE … [FILE…]\n  ripgrep 搜索命令   https://github.com/BurntSushi/ripgrep#installation\n  diff     选项 简介     -i 忽略文件内容大小写   -E 忽略 tab 符号变化   -b 忽略空格变化   -w 忽略所有空格   -B 忽略所有空行   -I RE 忽略匹配的行   -a –text 将所有文件当做文本处理   -c -C NUM 输出拷贝的内容的指定行，默认：3   -u -U NUM -   -p –show-c-function 显示 C 函数变更   -F RE -   -q –brief 仅文件不同是输出   -e –ed -   –normal 输出正常 diff   -n –rcs 输出RCS格式不同   -y –side-by-side 输出成两列   -W NUM -   –left-column -   -D NAME -   -l –paginate -   -t –expand-tabs -   -T –initial-tab -   -r –recursive 递归比较   -N –new-file -   -x PAT 排除匹配文件比较   -X FILE -   -S FILE –starting-file=FILE -      tree 命令使用   install: brew install truee\n   选项 含义     -a 递归列出所有，默认使用   -d 仅列出目录   -l TODO   -f 全路径(相对)显示   -x TODO   -L 指定列出的层级   -R 重新执行命令，当目录层级达到上限时   -P pattern 列出与指定 pattern 匹配的结果   -I pattern 与 -P 相反，匹配的不列出来   --ignore-case -P, -I 忽略大小写   -o filename 结果输出到指定文件     文件选项    -q 将不可打印字符输出成 ?   -N 将不可打印字符输出成 is   -Q 文件名双引号括起来   -p 输出文件权限   -u 输出文件 owner 或 UID   -g 输出文件用户组或 GID   -s 输出每个文件的字节大小   -h 以可读形式输出每个文件字节大小   --si 和 -h 类似，不过是以 SI 单位   -D 输出上次修改的时间   -F 目录最后显示 /   --inodes 输出文件 inode 数字   --device 输出每个文件所属的设备ID     排序选项    -v 根据 version   -t 根据上次修改时间   -c 根据上次状态变更时间   -U 取消排序   -r 逆序   --dirsfirst 目录显示在文件之前   --sort X name, version, size, mtime, ctime     图形化选项    -i 不缩进   -A ANSI lines   -S 示例： ��� package.json   -n 关闭色彩   -C 颜色显示     XML/HTML/JSON 选项    -X XML 格式输出   -J JSON 格式输出   -H baseHREF HTML 格式输出   -T string -   --nolinks -     输入选项    --fromfile 从文件读取     -I,-P 使用的时候多个规则： -I \u0026#39;dist|__tests__\u0026#39; 会同时忽略 dist 和 tests 目录或文件。\n    crontab 定时任务   OS X 添加定时任务 | Coding Pub\n  ","permalink":"https://www.cheng92.com/post/linux-doc/","tags":["linux"],"title":"Linux 知识大全"},{"categories":["shell"],"contents":"  Bash Reference Manual\n Bash - Replace pattern in string | bash Tutorial\n Linux Basis\u0026#xa0;\u0026#xa0;\u0026#xa0;ATTACH   ","permalink":"https://www.cheng92.com/post/shell/","tags":["shell"],"title":"Shell 编程"},{"categories":["vue"],"contents":"  诗号：六道同坠，魔劫万千，引渡如来。  \n   stb-vue-next 完全拷贝于 vue-next ，主要目的用于学习。 \n 声明 ：vue-next compiler-dom 模块 调试 ：所有测试用例可通过 \u0026lt;F12\u0026gt; 控制台查看\n 更新日志\u0026amp;Todos ：\n  [2020-12-16 19:40:21] 创建\n  [2020-12-19 13:01:02] 完成\n  TODO 完善测试用例\n      i = 0, j = 0 const { compile: compile2, parse } = VueCompilerDOM const compile = (tpl, title, logAst = false) = { l2(title) const { code, ast } = compile2(tpl, { onError: (e) = console.warn(e.message), hoistStatic: true, ...( compile.options || {} ) }) log.gray(tpl) log([code]) logAst \u0026\u0026 log(typeof logAst === 'function' ? logAst(ast) : ast) return ast } const c = (tpl, desc, fn) = compile(tpl, desc, fn || (ast = ast.codegenNode))  0062974 compiler-dom模块初始化   feat(init): compiler-dom · gcclll/stb-vue-next@0062974\n 日常操作先 copy：先将 vue-next/packages/compiler-dom/ 下面的内容拷贝过来，删除 src 目录下的所有代 码。\n 了解目录结构：\n╰─$ tree -C -I \u0026#39;dist|__tests__\u0026#39; . ├── LICENSE ├── README.md ├── api-extractor.json ├── index.js ├── package.json └── src ├── decodeHtml.ts ├── decodeHtmlBrowser.ts ├── errors.ts ├── index.ts ├── namedChars.json ├── parserOptions.ts ├── runtimeHelpers.ts └── transforms ├── ignoreSideEffectTags.ts ├── stringifyStatic.ts ├── transformStyle.ts ├── vHtml.ts ├── vModel.ts ├── vOn.ts ├── vShow.ts ├── vText.ts └── warnTransitionChildren.ts 2 directories, 21 files   功能预览：\n  ignoreSideEffectTags.ts 忽略模板中的 style, script 标签\n  stringifyStatic.ts 对静态提升做的一些处理\n  transformStyle.ts 将静态 style 属性转成指令类型属性，且将内容转成对象\n 如： \u0026lt;div style=\u0026#34;color:red\u0026#34; /\u0026gt; 会转成：\n1 2 3  _createBlock(\u0026#39;div\u0026#39;, { style: { color: \u0026#34;red\u0026#34; } }, null, 1 /* TEXT */)      vHtml.ts 将 v-html 表达式转成 innerHTML 内容\n  vModel.ts 处理 \u0026lt;input\u0026gt; 类型，删除 modelValue: value 属性，不允许有参数\n  vOn.ts 事件修饰符处理, 详情请查相关章节 \u0026gt;\u0026gt;\u0026gt;  分为三类：\n  事件选项修饰符 passive, capture, once 会被解析到事件名后面\n 如： \u0026lt;div @click.capture.once=\u0026#34;i++\u0026#34; /\u0026gt; 结果：\n1 2 3  _createBlock(\u0026#39;div\u0026#39;, { \u0026#39;onClickCaptureOnce\u0026#39;: $event =\u0026gt; (i++) }, null, 40 /* PROPS, HYDRATE_EVENTS */, [\u0026#34;onClickCaptureOnce\u0026#34;])      键盘类事件(onkeydown,onkeyup,onkeypress)修饰符 ~~\n  系统按键类型修饰符(ctrl,alt,shift,meta,exact)，捕获冒泡(stop,prevent,self)，鼠 标(middle,left,right)\n    vShow.ts 针对 v-show 指令，这个可能需要在 runtime 期间处理\n  vText.ts v-text 指令的处理，将表达式内容解析成 textContent 属性内容\n  warnTransitionChildren.ts 文件是针对 \u0026lt;transition\u0026gt; 内置标签的检测，它的孩 子节点只能有一个\n  decodeHtml[Browser].ts 是用来处理 html 符号语义化的，分别是 NODE 环境和浏览器环 境的处理逻辑\n  parserOptions.ts 针对 compiler-core 的选项做了进一步扩展(namespace, native tag, decodeEntities 等)\n    4fa13bf init parse + compile function   feat(init): compiler-dom index.ts\u0026gt; compile + parse function · gcclll/stb-vue-next@4fa13bf\n 初始化编译和解析函数，对应着 compile-core 的 baseCompile 和 baseParse 函数。\n 即： compiler-dom 是针对 compiler-core 的进一步封装处理，传递一些 transformXxx 函数，至于这些函数做了什么处理，需要下面一步步来揭开。\n compile :\n1 2 3 4 5 6 7 8 9 10 11 12 13 14  export function compile( template: string, options: CompilerOptions ): CodegenResult { return baseCompile( template, extend({}, parserOptions, { nodeTransforms: [], directiveTransforms: extend({}), // 静态提升 transform  transformHoist: __BROWSER__ ? null : stringifyStatic }) ) }     parse:\n1 2 3  export function parse(template: string, options: ParserOptions = {}): RootNode { return baseParse(template, extend({}, parserOptions, options)) }     其实到这里也是应该可以执行的，来测试下：\n1 2 3 4 5 6 7  const { parse, compile } = require(process.env.PWD + \u0026#39;/../../static/js/vue/compiler-dom.global.js\u0026#39;) const { code, ast } = compile(`\u0026lt;div\u0026gt;{{ test }}\u0026lt;/div\u0026gt;`) console.log(code, \u0026#39;\\n\u0026gt;\u0026gt;\u0026gt; AST: \\n\u0026#39;, ast)    const _Vue = Vue return function render(_ctx, _cache) { with (_ctx) { const { toDisplayString : _toDisplayString, createVNode : _createVNode, openBlock : _openBlock, createBlock : _createBlock } = _Vue return (_openBlock(), _createBlock(\u0026#34;div\u0026#34;, null, _toDisplayString(test), 1 /* TEXT */)) } } \u0026gt;\u0026gt;\u0026gt; AST: { type: 0, children: [ { type: 1, ns: 0, tag: \u0026#39;div\u0026#39;, tagType: 0, props: [], isSelfClosing: false, children: [Array], loc: [Object], codegenNode: [Object] } ], codegenNode: { type: 13, tag: \u0026#39;\u0026#34;div\u0026#34;\u0026#39;, props: undefined, children: { type: 5, content: [Object], loc: [Object] }, patchFlag: \u0026#39;1 /* TEXT */\u0026#39;, dynamicProps: undefined, directives: undefined, isBlock: true, disableTracking: false, loc: { start: [Object], end: [Object], source: \u0026#39;\u0026lt;div\u0026gt;{{ test }}\u0026lt;/div\u0026gt;\u0026#39; } }, }   接下来才是进入正题 ⛳…🚄🚄🚄\n  8c86624 add transformStyle node transform   feat: add transformStyle transform · gcclll/stb-vue-next@8c86624\n 作用是将 node.props 里面的 style 内联属性转成对象类型。\n 根据条件，这里只检测静态属性，然后将其转成 v-bind 型的动态属性，将内联转成对象。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17  export const transformStyle: NodeTransform = node =\u0026gt; { if (node.type === NodeTypes.ELEMENT) { node.props.forEach((p, i) =\u0026gt; { if (p.type === NodeTypes.ATTRIBUTE \u0026amp;\u0026amp; p.name === \u0026#39;style\u0026#39; \u0026amp;\u0026amp; p.value) { // replace p with an expression node  node.props[i] = { type: NodeTypes.DIRECTIVE, name: `bind`, arg: createSimpleExpression(`style`, true, p.loc), exp: parseInlineCSS(p.value.content, p.loc), modifiers: [], loc: p.loc } } }) } }     内联转对象解析函数： parseInlineCSS\n1 2 3 4 5 6 7 8 9 10 11 12  const parseInlineCSS = ( cssText: string, loc: SourceLocation ): SimpleExpressionNode =\u0026gt; { const normalized = parseStringStyle(cssText) return createSimpleExpression( JSON.stringify(normalized), false, loc, ConstantTypes.CAN_STRINGIFY ) }     parseStringStyle 处理其实就是以 ; 为分隔符，将 name:value 分割出来，解析出 name 和 value 组成对象。\n 测试：\n1 2 3 4 5 6 7 8  const { parse, compile } = require(process.env.PWD + \u0026#39;/../../static/js/vue/compiler-dom.global.js\u0026#39;) const { code } = compile(`\u0026lt;div style=\u0026#34;color:red;font-size:30px;\u0026#34;\u0026gt;{{ text }}\u0026lt;/div\u0026gt;`) console.log(code)    const _Vue = Vue return function render(_ctx, _cache) { with (_ctx) { const { toDisplayString : _toDisplayString, createVNode : _createVNode, openBlock : _openBlock, createBlock : _createBlock } = _Vue return (_openBlock(), _createBlock(\u0026#34;div\u0026#34;, { style: {\u0026#34;color\u0026#34;:\u0026#34;red\u0026#34;,\u0026#34;font-size\u0026#34;:\u0026#34;30px\u0026#34;} }, _toDisplayString(text), 1 /* TEXT */)) } } undefined    7ea8dfe add v-html transform   feat: add transform v-html · gcclll/stb-vue-next@7ea8dfe\n v-html 指令转换。\n 代码很简单：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25  export const transformVHtml: DirectiveTransform = (dir, node, context) =\u0026gt; { const { exp, loc } = dir if (!exp) { context.onError( createDOMCompilerError(DOMErrorCodes.X_V_HTML_NO_EXPRESSION, loc) ) } if (node.children.length) { context.onError( createDOMCompilerError(DOMErrorCodes.X_V_HTML_WITH_CHILDREN, loc) ) node.children.length = 0 } return { props: [ createObjectProperty( createSimpleExpression(`innerHTML`, true, loc), exp || createSimpleExpression(\u0026#39;\u0026#39;, true) ) ] } }     其实就是针对 v-html 将其转成 innerHTML 动态属性，检测两个不合法使用情况\n  没有表达式\n  包含孩子节点\n  测试：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14  const { parse, compile } = require(process.env.PWD + \u0026#39;/../../static/js/vue/compiler-dom.global.js\u0026#39;) const _c = tpl =\u0026gt; compile(tpl, { onError: e =\u0026gt; console.log(`错误描述：` + e.message) }).code console.log(_c(`\u0026lt;div v-html=\u0026#34;test\u0026#34;/\u0026gt;`)) console.log(`\u0026gt;\u0026gt;\u0026gt; v-html 下不能有任何孩子节点`) console.log(_c(`\u0026lt;div v-html=\u0026#34;test\u0026#34;\u0026gt;hello\u0026lt;/div\u0026gt;`)) console.log(`\u0026gt;\u0026gt;\u0026gt; v-html 不能没有表达式`) console.log(_c(`\u0026lt;div v-html\u0026gt;\u0026lt;/div\u0026gt;`))    const _Vue = Vue return function render(_ctx, _cache) { with (_ctx) { const { createVNode : _createVNode, openBlock : _openBlock, createBlock : _createBlock } = _Vue return (_openBlock(), _createBlock(\u0026#34;div\u0026#34;, { innerHTML: test }, null, 8 /* PROPS */, [\u0026#34;innerHTML\u0026#34;])) } } \u0026gt;\u0026gt;\u0026gt; v-html 下不能有任何孩子节点 错误描述：v-html will override element children. const _Vue = Vue return function render(_ctx, _cache) { with (_ctx) { const { createVNode : _createVNode, openBlock : _openBlock, createBlock : _createBlock } = _Vue return (_openBlock(), _createBlock(\u0026#34;div\u0026#34;, { innerHTML: test }, null, 8 /* PROPS */, [\u0026#34;innerHTML\u0026#34;])) } } \u0026gt;\u0026gt;\u0026gt; v-html 不能没有表达式 错误描述：v-html is missing expression. const _Vue = Vue return function render(_ctx, _cache) { with (_ctx) { const { createVNode : _createVNode, openBlock : _openBlock, createBlock : _createBlock } = _Vue return (_openBlock(), _createBlock(\u0026#34;div\u0026#34;, { innerHTML: \u0026#34;\u0026#34; })) } } undefined    这里 v-html 属性会被解析成 node.props 里面动态属性，属性名为 innerHTML 。\n  如果有 v-html 指令是该组件下面就不能有任何孩子节点\n    4f3a4ee add v-text transform   feat(add): v-text transform · gcclll/stb-vue-next@4f3a4ee\n v-text 指令转换函数，转成属性为 textContent 。\n 代码:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33  export const transformVText: DirectiveTransform = (dir, node, context) =\u0026gt; { const { exp, loc } = dir if (!exp) { context.onError( createDOMCompilerError(DOMErrorCodes.X_V_TEXT_NO_EXPRESSION, loc) ) } if (node.children.length) { context.onError( createDOMCompilerError(DOMErrorCodes.X_V_TEXT_WITH_CHILDREN, loc) ) node.children.length = 0 } return { props: [ createObjectProperty( createSimpleExpression(`textContent`, true), exp ? createCallExpression( context.helperString(TO_DISPLAY_STRING), [exp], loc ) : createSimpleExpression(\u0026#39;\u0026#39;, true) ) ] } }     测试：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  const { parse, compile } = require(process.env.PWD + \u0026#39;/../../static/js/vue/compiler-dom.global.js\u0026#39;) const c = tpl =\u0026gt; compile(tpl, { onError: e =\u0026gt; console.log(`错误描述: ${e.message}`) }).code console.log(c(`\u0026lt;div v-text=\u0026#34;test\u0026#34;/\u0026gt;`)) console.log(`\u0026gt;\u0026gt;\u0026gt; 包含孩子节点`) console.log(c(`\u0026lt;div v-text=\u0026#34;test\u0026#34;\u0026gt;hello\u0026lt;/div\u0026gt;`)) console.log(`\u0026gt;\u0026gt;\u0026gt; 无表达式`) console.log(c(`\u0026lt;div v-text\u0026gt;\u0026lt;/div\u0026gt;`))    const _Vue = Vue return function render(_ctx, _cache) { with (_ctx) { const { toDisplayString : _toDisplayString, createVNode : _createVNode, openBlock : _openBlock, createBlock : _createBlock } = _Vue return (_openBlock(), _createBlock(\u0026#34;div\u0026#34;, { textContent: _toDisplayString(test) }, null, 8 /* PROPS */, [\u0026#34;textContent\u0026#34;])) } } \u0026gt;\u0026gt;\u0026gt; 包含孩子节点 错误描述: v-text will override element children. const _Vue = Vue return function render(_ctx, _cache) { with (_ctx) { const { toDisplayString : _toDisplayString, createVNode : _createVNode, openBlock : _openBlock, createBlock : _createBlock } = _Vue return (_openBlock(), _createBlock(\u0026#34;div\u0026#34;, { textContent: _toDisplayString(test) }, null, 8 /* PROPS */, [\u0026#34;textContent\u0026#34;])) } } \u0026gt;\u0026gt;\u0026gt; 无表达式 错误描述: v-text is missing expression. const _Vue = Vue return function render(_ctx, _cache) { with (_ctx) { const { createVNode : _createVNode, openBlock : _openBlock, createBlock : _createBlock } = _Vue return (_openBlock(), _createBlock(\u0026#34;div\u0026#34;, { textContent: \u0026#34;\u0026#34; })) } } undefined    588d5f1 add v-model transform   v-model 指令转换。\n 在完成 v-model 指令转换之前，我们看下 compiler-core 里面的 v-model 处理的最后结 果是什么❓\n1 2 3 4 5 6 7 8  const { parse, compile } = require(process.env.PWD + \u0026#39;/../../static/js/vue/compiler-dom.global.js\u0026#39;) const { code } = compile(`\u0026lt;input v-model:value=\u0026#34;result\u0026#34; /\u0026gt;`) console.log(code)    const _Vue = Vue return function render(_ctx, _cache) { with (_ctx) { const { createVNode : _createVNode, openBlock : _openBlock, createBlock : _createBlock } = _Vue return (_openBlock(), _createBlock(\u0026#34;input\u0026#34;, { value: result, \u0026#34;onUpdate:value\u0026#34;: $event =\u0026gt; (result = $event) }, null, 40 /* PROPS, HYDRATE_EVENTS */, [\u0026#34;value\u0026#34;,\u0026#34;onUpdate:value\u0026#34;])) } } undefined   结果显示：v-model 最终转成了两个属性\n { value: result, \u0026#34;onUpdate:value\u0026#34;: $event =\u0026gt; (result = $event)}\n 这个原理应该是这样： 输入框内容绑定 result ，当输入框内容发生变化，触发 onUpdate:value 事件，执行该函数重新复制 result 变更数据。  加上 compiler-dom 阶段的 v-model transform 之后： feat(add): v-model transform · gcclll/stb-vue-next@588d5f1\n1 2 3 4 5 6 7 8  const { parse, compile } = require(process.env.PWD + \u0026#39;/../../static/js/vue/compiler-dom.global.js\u0026#39;) const { code } = compile(`\u0026lt;input v-model=\u0026#34;result\u0026#34; /\u0026gt;`) console.log(code)    const _Vue = Vue return function render(_ctx, _cache) { with (_ctx) { const { vModelText : _vModelText, createVNode : _createVNode, withDirectives : _withDirectives, openBlock : _openBlock, createBlock : _createBlock } = _Vue return _withDirectives((_openBlock(), _createBlock(\u0026#34;input\u0026#34;, { \u0026#34;onUpdate:modelValue\u0026#34;: $event =\u0026gt; (result = $event) }, null, 8 /* PROPS */, [\u0026#34;onUpdate:modelValue\u0026#34;])), [ [_vModelText, result] ]) } } undefined   变化：\n  不支持参数了\n  删除了 value: result 属性(默认是 modelValue)。\n  用 _withDirectives 将 \u0026lt;input\u0026gt; 包起来了\n 这个函数定义是在 runtime-core 里面定义了，作用就是将 第二个参数 [ [_vModelText, result] ] 里面的指令塞到 vnode.dirs 指令集中去。\n   代码:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89  export const transformModel: DirectiveTransform = (dir, node, context) =\u0026gt; { const baseResult = baseTransform(dir, node, context) // base transform has errors OR component v-model (only need props)  // 没有 v-model指令，或应用在用户组件上了  if (!baseResult.props.length || node.tagType === ElementTypes.COMPONENT) { return baseResult } // 不能有参数？  if (dir.arg) { // ... 报错，不能有参数，即必须是 ~v-model=\u0026#34;xxx\u0026#34;~ 来使用  } // 不能有 value 属性，因为 input 绑定的就是 value 属性  function checkDuplicateValue() { // ... 这里既是检测是不是有 \u0026lt;input value=\u0026#34;xx\u0026#34;\u0026gt; value 属性  } const { tag } = node const isCustomElement = context.isCustomElement(tag) if ( tag === \u0026#39;input\u0026#39; || tag === \u0026#39;textarea\u0026#39; || tag === \u0026#39;select\u0026#39; || isCustomElement ) { let directiveToUse = V_MODEL_TEXT let isInvalidType = false if (tag === \u0026#39;input\u0026#39; || isCustomElement) { const type = findProp(node, `type`) if (type) { if (type.type === NodeTypes.DIRECTIVE) { // :type=\u0026#39;foo\u0026#39;  directiveToUse = V_MODEL_DYNAMIC } else if (type.value) { switch (type.value.content) { case \u0026#39;radio\u0026#39;: directiveToUse = V_MODEL_RADIO break case \u0026#39;checkbox\u0026#39;: directiveToUse = V_MODEL_CHECKBOX break case \u0026#39;file\u0026#39;: isInvalidType = true // ERROR 不能用在 \u0026lt;file\u0026gt; 标签上  break default: __DEV__ \u0026amp;\u0026amp; checkDuplicateValue() break } } } else if (hasDynamicKeyVBind(node)) { // element has bindings with dynamic keys, which can possibly contain  // \u0026#34;type\u0026#34;.  directiveToUse = V_MODEL_DYNAMIC } else { // text type  __DEV__ \u0026amp;\u0026amp; checkDuplicateValue() } } else if (tag === \u0026#39;select\u0026#39;) { directiveToUse = V_MODEL_SELECT } else { // textarea  __DEV__ \u0026amp;\u0026amp; checkDuplicateValue() } // inject runtime directive  // by returning the helper symbol via needRuntime  // the import will replaced a resolveDirective call.  if (!isInvalidType) { baseResult.needRuntime = context.helper(directiveToUse) } } else { // v-model 应用到不合法的元素上  } // native vmodel doesn\u0026#39;t need the `modelValue` props since they are also  // passed to the runtime as `binding.value`. removing it reduces code size.  // 最后过滤掉 modelValue: xxx 属性  baseResult.props = baseResult.props.filter( p =\u0026gt; !( p.key.type === NodeTypes.SIMPLE_EXPRESSION \u0026amp;\u0026amp; p.key.content === \u0026#39;modelValue\u0026#39; ) ) return baseResult }     源码分析：\n  只处理 input, textarea, select 文本框标签，或自定义的标签\n  \u0026lt;input\u0026gt; 标签类型分为 radio 和 checkbox 单复选项框处理，不能使用 type=\u0026#39;file\u0026#39; 类型\n  \u0026lt;select\u0026gt; 下拉选项框的处理\n  过滤掉 transform 之后的 {modelValue: value, \u0026#39;onUpdate:value\u0026#39;: $event =\u0026gt; value = $event} 里面的 modelValue：value 属性，因为在 runtime-core 时期的 withDirectives() 处理里面会被绑定到 value 属性上\n    a94aacd add v-on transform   feat(add): v-on transform · gcclll/stb-vue-next@a94aacd\n compiler-core 阶段：\n1 2 3 4 5 6 7 8 9  const { parse, compile } = require(process.env.PWD + \u0026#39;/../../static/js/vue/compiler-dom.global.js\u0026#39;) const { code, ast } = compile(`\u0026lt;div v-on:keyup.enter.prevent=\u0026#34;pressKeyup\u0026#34; /\u0026gt;`) console.log(code) console.log(ast.codegenNode.props.properties)    const _Vue = Vue return function render(_ctx, _cache) { with (_ctx) { const { createVNode : _createVNode, openBlock : _openBlock, createBlock : _createBlock } = _Vue return (_openBlock(), _createBlock(\u0026#34;div\u0026#34;, { onKeyup: pressKeyup }, null, 40 /* PROPS, HYDRATE_EVENTS */, [\u0026#34;onKeyup\u0026#34;])) } } [ { type: 16, loc: { source: \u0026#39;\u0026#39;, start: [Object], end: [Object] }, key: { type: 4, loc: [Object], content: \u0026#39;onKeyup\u0026#39;, isStatic: true, constType: 3 }, value: { type: 4, content: \u0026#39;pressKeyup\u0026#39;, isStatic: false, constType: 0, loc: [Object] } } ] undefined   可以看到 compile-core 阶段是没有处理修饰符的。\n v-on 指令最后解析成 { key, value, type: 16 } 结构。\n compiler-dom v-on 处理逻辑：\n  resolveModifiers(key, modifiers) 解析出三类修饰符\n  keyModifiers 修饰符\n 键盘事件： onkeyup, onkeydown, onkeypress\n  eventOptionModifiers 事件选项修饰符，只有三种 passive, once, capture\n  nonKeyModifiers 非按键类修饰符\n 事件冒泡管理： stop,prevent,self\n 系统修饰符+exact: ctrl,shift,alt,meta,exact , exact 表示精确匹配按键。\n 鼠标按键修饰符： middle\n    经过 1 之后得出三种类型的修饰符，处理其中的 nonKeyModifiers\n 将这种类型的修饰符中的 right, middle 转换成对应的 onContextmenu 和 onMouseup 事件\n 即：\n 如果有 right 点击事件会触发 onContextmenu 事件，弹出右键菜单？\n 如果有 middle 鼠标中间滚轮事件，会触发 onMouseup 鼠标弹起事件\n 最后将 nonKeyModifiers 结合 value 创建成函数表达式。\n1 2 3 4 5 6 7 8 9 10 11 12  const { parse, compile } = require(process.env.PWD + \u0026#39;/../../static/js/vue/compiler-dom.global.js\u0026#39;) const {code} = compile( `\u0026lt;div @click.right=\u0026#34;testRight\u0026#34; @click.middle=\u0026#34;testMiddle\u0026#34; @click.left=\u0026#34;testLeft\u0026#34; /\u0026gt;`) console.log(`\u0026gt;\u0026gt;\u0026gt; right 修饰符被当做 onContextmenu 事件处理, middle -\u0026gt; onMouseup`) console.log(code)    \u0026gt;\u0026gt;\u0026gt; right 修饰符被当做 onContextmenu 事件处理, middle -\u0026gt; onMouseup const _Vue = Vue return function render(_ctx, _cache) { with (_ctx) { const { withModifiers : _withModifiers, createVNode : _createVNode, openBlock : _openBlock, createBlock : _createBlock } = _Vue return (_openBlock(), _createBlock(\u0026#34;div\u0026#34;, { onContextmenu: _withModifiers(testRight, [\u0026#34;right\u0026#34;]), onMouseup: _withModifiers(testMiddle, [\u0026#34;middle\u0026#34;]), onClick: _withModifiers(testLeft, [\u0026#34;left\u0026#34;]) }, null, 40 /* PROPS, HYDRATE_EVENTS */, [\u0026#34;onContextmenu\u0026#34;,\u0026#34;onMouseup\u0026#34;,\u0026#34;onClick\u0026#34;])) } } undefined    处理 keyModifiers ，如：键盘事件修饰符，系统修饰符等等\n 比如：键盘 ctrl-a 组合键\n1 2 3 4 5 6 7 8 9  const { parse, compile } = require(process.env.PWD + \u0026#39;/../../static/js/vue/compiler-dom.global.js\u0026#39;) const { code } = compile(` \u0026lt;div @keydown.stop.capture.ctrl.a=\u0026#34;test\u0026#34; /\u0026gt;`) console.log(code)    const _Vue = Vue return function render(_ctx, _cache) { with (_ctx) { const { withModifiers : _withModifiers, withKeys : _withKeys, createVNode : _createVNode, openBlock : _openBlock, createBlock : _createBlock } = _Vue return (_openBlock(), _createBlock(\u0026#34;div\u0026#34;, { onKeydownCapture: _withKeys(_withModifiers(test, [\u0026#34;stop\u0026#34;,\u0026#34;ctrl\u0026#34;]), [\u0026#34;a\u0026#34;]) }, null, 40 /* PROPS, HYDRATE_EVENTS */, [\u0026#34;onKeydownCapture\u0026#34;])) } } undefined    处理 eventOptionModifiers 结合 key 生成对应的事件名表达式\n 事件选项修饰符只有三个： capture,passive,once\n passive: passive的作用和原理_个人文章 - SegmentFault 思否\n capture: DOM 的事件傳遞機制：捕獲與冒泡\n 解析结果，事件选项修饰符被合并到事件名中：\n1 2 3 4 5 6 7  const { parse, compile } = require(process.env.PWD + \u0026#39;/../../static/js/vue/compiler-dom.global.js\u0026#39;) const { code } = compile(`\u0026lt;div @click.stop.capture.once=\u0026#34;test\u0026#34; /\u0026gt;`) console.log(code)    const _Vue = Vue return function render(_ctx, _cache) { with (_ctx) { const { withModifiers : _withModifiers, createVNode : _createVNode, openBlock : _openBlock, createBlock : _createBlock } = _Vue return (_openBlock(), _createBlock(\u0026#34;div\u0026#34;, { onClickCaptureOnce: _withModifiers(test, [\u0026#34;stop\u0026#34;]) }, null, 40 /* PROPS, HYDRATE_EVENTS */, [\u0026#34;onClickCaptureOnce\u0026#34;])) } } undefined   如：事件名 onClickCaptureOnce\n  如果事件名为动态或是键盘事件，得用 _withKeys() 包一层\n    测试：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17  const { parse, compile } = require(process.env.PWD + \u0026#39;/../../static/js/vue/compiler-dom.global.js\u0026#39;) const log = console.log const c = (tpl, title) =\u0026gt; { const { code, ast } = compile(tpl, { onError: e =\u0026gt; log(`错误描述：${e.message}`) }) log(`\u0026gt;\u0026gt;\u0026gt; ${title}`) log(code) log(ast.codegenNode.props.properties) } c(`\u0026lt;div @click.stop.prevent=\u0026#34;test\u0026#34; /\u0026gt;`, \u0026#39;多个修饰符\u0026#39;)    \u0026gt;\u0026gt;\u0026gt; 多个修饰符 const _Vue = Vue return function render(_ctx, _cache) { with (_ctx) { const { withModifiers : _withModifiers, createVNode : _createVNode, openBlock : _openBlock, createBlock : _createBlock } = _Vue return (_openBlock(), _createBlock(\u0026#34;div\u0026#34;, { onClick: _withModifiers(test, [\u0026#34;stop\u0026#34;,\u0026#34;prevent\u0026#34;]) }, null, 8 /* PROPS */, [\u0026#34;onClick\u0026#34;])) } } [ { type: 16, loc: { source: \u0026#39;\u0026#39;, start: [Object], end: [Object] }, key: { type: 4, loc: [Object], content: \u0026#39;onClick\u0026#39;, isStatic: true, constType: 3 }, value: { type: 14, loc: [Object], callee: Symbol(vOnModifiersGuard), arguments: [Array] } } ] undefined   \u0026lt;f12\u0026gt; 打开控制台查看更多测试用例结果。\n  l1(`v-on`) c(``, '支持多个修饰符') c(``, '多个事件') c(``, '多个修饰符和事件选项') c(``, '键盘事件或动态事件，应该用 keys guard 包一层(runtime-dom: withKeys())') c(``, `没有按键修饰符的时候，不需要 keys guard`) c(``, '静态事件名+left/right 修饰符，需要 keys guard') c(``, '动态事件名+left/right 修饰符，需要 keys guard') c(``, 'should not wrap normal guard if there is only keys guard') // 转成 onContextmenu 事件 c(``, 'should transform click.right') // 如果是 click.right 转成 onContextmenu c(``, '动态事件名 + right 修饰符') // 转成 onMouseup c(``, '鼠标中键按键事件') c(``, '鼠标中键动态按键事件') compile.options = { cacheHandlers: true } const root = c(``, '缓存 handler 修饰符') log(root)   小结 :\n 事件修饰符分为三大类\n  事件选项类型修饰符(passive,capture,once)\n 会和事件名合并： click.capture.once -\u0026gt; onClickCaptureOnce\n  键盘事件(包括键盘按键 a-b-c-…)\n  其他类型事件修饰符(如：stop,prevent,self, ctrl,shift,alt,meta,exact)\n   关于 right, middle 修饰符处理情况\n  right 处理成 onContextmenu 事件\n  middle 处理成 onMouseup 事件   right/middle 是在动态事件名上面，会检测是不是 onClick 如果是进行 1/2 转换，不 是按照原事件名处理。\n 如： @[eventName].middle=\u0026#34;test\u0026#34; -\u0026gt; eventName === \u0026#39;onClick\u0026#39; ? \u0026#39;onMouseup\u0026#39; : eventName\n     e64a1b3 add v-show transform   feat(add): v-show transform · gcclll/stb-vue-next@e64a1b3\n1 2 3 4 5 6 7 8 9 10 11 12 13  export const transformShow: DirectiveTransform = (dir, node, context) =\u0026gt; { const { exp, loc } = dir if (!exp) { context.onError( createDOMCompilerError(DOMErrorCodes.X_V_SHOW_NO_EXPRESSION, loc) ) } return { props: [], needRuntime: context.helper(V_SHOW) } }     测试：\n1 2 3 4 5 6 7 8 9  const { parse, compile } = require(process.env.PWD + \u0026#39;/../../static/js/vue/compiler-dom.global.js\u0026#39;) const { code, ast } = compile(`\u0026lt;div v-show=\u0026#34;test\u0026#34;/\u0026gt;`) console.log(code) console.log(`props: `, ast.codegenNode.props)    const _Vue = Vue return function render(_ctx, _cache) { with (_ctx) { const { vShow : _vShow, createVNode : _createVNode, withDirectives : _withDirectives, openBlock : _openBlock, createBlock : _createBlock } = _Vue return _withDirectives((_openBlock(), _createBlock(\u0026#34;div\u0026#34;, null, null, 512 /* NEED_PATCH */)), [ [_vShow, test] ]) } } props: undefined   这里貌似什么都没干，除了返回一个 needRuntime: context.helper(V_SHOW) ，难道 v-show 必须在 runtime 时期处理？？？\n  436db72 add transition component warn transform   feat(add): transition component transform · gcclll/stb-vue-next@436db72\n 这里只是加了个错误用法处理，对于 \u0026lt;transition\u0026gt; 组件下面只能有一个孩子节点。\n  TODO af56754 add stringifyStatic node 环境静态提升   feat(add): node stringify static -\u0026gt; hoist · gcclll/stb-vue-next@af56754\n  f0cbb25 add ignoreSideEffectTags transform   feat(add): ignore side effect tags \u0026gt; script/style · gcclll/stb-vue-next@f0cbb25\n 这个 transform 作用是检测模板中是不是存在 \u0026lt;script\u0026gt;, \u0026lt;style\u0026gt; 标签。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  const { parse, compile } = require(process.env.PWD + \u0026#39;/../../static/js/vue/compiler-dom.global.js\u0026#39;) const c = (tpl, title) =\u0026gt; { console.log(`\u0026gt;\u0026gt;\u0026gt; ${title}`) const { code } = compile(tpl, { onError: e =\u0026gt; console.log(`\u0026gt; 错误描述：${e.message}`) }) console.log(code) } c(`\u0026lt;script\u0026gt;console.log(1)\u0026lt;/script\u0026gt;`, \u0026#39;忽略 \u0026lt;script\u0026gt; 标签\u0026#39;) c(`\u0026lt;style\u0026gt;h1 { color: red }\u0026lt;/style\u0026gt;`, \u0026#39;忽略 \u0026lt;style\u0026gt; 标签\u0026#39;)    \u0026gt;\u0026gt;\u0026gt; 忽略 \u0026lt;script\u0026gt; 标签 \u0026gt; 错误描述：Tags with side effect (\u0026lt;script\u0026gt; and \u0026lt;style\u0026gt;) are ignored in client component templates. return function render(_ctx, _cache) { with (_ctx) { return null } } \u0026gt;\u0026gt;\u0026gt; 忽略 \u0026lt;style\u0026gt; 标签 \u0026gt; 错误描述：Tags with side effect (\u0026lt;script\u0026gt; and \u0026lt;style\u0026gt;) are ignored in client component templates. return function render(_ctx, _cache) { with (_ctx) { return null } } undefined    fd0f5ae add dom parserOptions and decode html   对 compiler-core 的 ParserOptions 的一种扩展:\n  isNativeTag: tag =\u0026gt; isHTMLTag(tag) || isSVGTag(tag)\n vue-next/packages/shared/src/domTagConfig.ts\n 中制定了一些原生的标签。\n  isPreTag: pre 标签\n  decodeEntities html 实体转换\n 分为浏览器环境和NDOE环境处理\n 浏览器环境处理较为简单(转标签内容取出字符串，利用浏览器自身能力来转换)：\n1 2 3 4 5  export function decodeHtmlBrowser(raw: string): string { ;(decoder || (decoder = document.createElement(\u0026#39;div\u0026#39;))).innerHTML = raw return decoder.textContent as string }     NODE 环境稍微复杂，下面做些简单测试吧：\n https://html.spec.whatwg.org/multipage/named-characters.html\n vue-next/packages/compiler-dom/src/namedChars.json\n 上面链接和路径中包含了所有字符的 16进制 - 符号 - 名字对应表(json)，下面随便找 几个来测试下-\u0026gt; 分析如注释\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  const { decodeHtml } = require(process.env.PWD + \u0026#39;/../../static/js/vue/compiler-dom.global.js\u0026#39;) let rawText = \u0026#39;a \u0026amp;#x20ac b \u0026amp;nbsp; e \u0026amp;FilledVerySmallSquare; d \u0026amp;Gg; f\u0026#39; const res = decodeHtml(rawText) // while 循环里首先是匹配正则：/\u0026amp;(?:#x?)?/ -\u0026gt; \u0026amp;#x...十六进制数 或 `\u0026amp;[name];` // 形式的字符，name 取自 namedChars.json 文件的 key // 如果都没有匹配到直接退出循环， // 即 decodeHtml 目的是将16进制和 named 表示的符号转换语义化的符号 // 如： \u0026amp;#x20ac -\u0026gt; \u0026#34;euro;\u0026#34;: \u0026#34;€\u0026#34; -\u0026gt; € 符号 // 或者 \u0026amp;nbsp; 符号 // 或者使用 namedChars.json 中的名字来作为特殊字符，如： \u0026amp;FilledVerySmallSquare; -\u0026gt; ▪, \u0026amp;Gg; -\u0026gt; ⋙ console.log(res)    a € b e ▪ d ⋙ f undefined    isBuiltInComponent, 两个内置组件： Transition, TransitionGroup\n  getNamespace, 更详细的命名空间检测\n  getTextMode, 文本模式检测\n textarea, title 标签视为 TextModes.RCDATA 类型\n style,iframe,script,noscript 标签视为 TextModes.RAWTEXT 类型\n 其他视为 TextModes.DATA 类型\n    用例测试(\u0026lt;f12\u0026gt; 查看控制台)：     总结   这一模块的完成，零零散散时间大概花了不到一周的时间，也是由于有 compiler-core 包 的完成及分析的基础上，进展才会这么顺利。\n  对于 compiler-dom 这一模块主要内容，快速预览可以查看第一章节的功能预览。\n 这里重点关注的地方，我认为有以下几个：\n  v-model 对 \u0026lt;input\u0026gt; 类型检测和处理\n  v-on 事件修饰符的处理，我感觉是这个模块的 重中之重\n  另外对于 node 环境的 html 符号语义化的处理也值得分析\n    ","permalink":"https://www.cheng92.com/vue/vue-mind-map-compiler-dom/","tags":["vue,","vue3,","compiler-dom"],"title":"Vue3 源码头脑风暴之 4 ☞compiler-dom"},{"categories":["vue"],"contents":"  诗号：六道同坠，魔劫万千，引渡如来。  \n   stb-vue-next 完全拷贝于 vue-next ，主要目的用于学习。 \n 声明 ：该篇为 ts 源码(commit)版本，之前做过一遍完整的 js 版本，更详细，也可参考\n Vue3.0 源码系列（二）编译器核心 - Compiler core 3: compile.ts - 若叶知秋\n 由于 transform 阶段直接测试不太好直观的看出结果，因此这里会结合 codegen 来一起实 现，即该文包含 compiler-core 三大阶段的最后两个阶段(transform + generate)\n 调试 ：所有测试用例可通过 \u0026lt;F12\u0026gt; 控制台查看\n 更新日志\u0026amp;Todos ：\n  DONE [2020-12-12 18:33:33] 阶段性完成，浏览器支持的所有基本功能(浏览器环境所 有用例测试均已通过，可通过控制台查看测试用例及其运行过程结果)\n  TODO ssr 服务端渲染\n  TODO \u0026lt;setup\u0026gt; 标签处理\n  TODO 非浏览器环境支持(prefixIdentifiers, cacheHandlers 选项需要非浏览器环境)\n  TODO ref 类型处理\n      i = 0, j = 0 const { baseCompile } = VueCompilerCore const compile = (tpl, title, logAst = false) = { l2(title) // if (!tpl) return null const { code, ast } = baseCompile(tpl, { onError: (e) = console.warn(e.message), hoistStatic: true, ...( compile.options || {} ) }) log.grey(tpl) log([code]) logAst \u0026\u0026 log(typeof logAst === 'function' ? logAst(ast) : ast) return ast } const c = (tpl, desc, fn) = compile(tpl, desc, fn || (ast = ast.codegenNode\u0026\u0026ast.codegenNode.props))  关键知识点    🔗 root.children.length = 1 且类型是 ELEMENT的时候将 CREATE_VNODE 改成 CREATE_BLOCK   🔗 动态属性为表达式时，中间不能有空格\n 如： \u0026lt;div :[first + second]=\u0026#34;third\u0026#34; ... 是非法的。\n 因为 parseAttribute() 中的正则是不支持中间有空格的：\n 取参数名的正则： /^[^\\t\\r\\n\\f /\u0026gt;][^\\t\\r\\n\\f /\u0026gt;=]*/\n  🔗 v-bind 指令的几种用法 -\u0026gt;\n  🔗 用户组件 -\u0026gt; 插槽处理 -\u0026gt; v-slot 使用方法\n    脑图   e03a03c init transform module   feat(init): transform section · gcclll/stb-vue-next@e03a03c\n 初始化函数。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78  export function createTransformContext( root: RootNode, { prefixIdentifiers = false, hoistStatic = false, cacheHandlers = false, nodeTransforms = [], directiveTransforms = {}, transformHoist = null, isBuiltInComponent = NOOP, isCustomElement = NOOP, expressionPlugins = [], scopeId = null, ssr = false, ssrCssVars = ``, bindingMetadata = {}, onError = defaultOnError }: TransformOptions ): TransformContext { const context: TransformContext = { // ...  // methods  helper(name) { context.helpers.add(name) return name }, helperString(name) { return `` }, replaceNode(node) {}, removeNode(node) {}, onNodeRemoved: () =\u0026gt; {}, addIdentifiers(exp) { // TODO  }, removeIdentifiers(exp) { // TODO  }, hoist(exp) { // TODO  return {} as any }, cache(exp, isVNode = false) { // TODO  return {} as any } } return context } export function transform(root: RootNode, options: TransformOptions) { // TODO } // TODO // createRootCodegen  export function traverseChildren( parent: ParentNode, context: TransformContext ) { // TODO } export function traverseNode( node: RootNode | TemplateChildNode, context: TransformContext ) {} export function createStructuralDirectiveTransform( name: string | RegExp, fn: StructuralDirectiveTransform ): NodeTransform { return {} as any }      fc6f1f1 add transform function   feat: transform function · gcclll/stb-vue-next@fc6f1f1\n  create transform context\n  traverse nodes, 递归遍历所有节点，构造器 codegenNode\n  hoist static, 静态节点提升，复用\n  ssr render, 不需要创建根节点 codegenNode\n  复制 context 属性到 -\u0026gt; root\n    transform 作用就是通过 traverseNode() 递归遍历所有节点，解析，构造对应的节点 codegenNode 。\n  b0d72da add compile.ts\u0026gt;compile()   feat(add): compile function · gcclll/stb-vue-next@b0d72da\n 对外的 compile 函数，执行分为三个阶段：\n  ast(baseParse()) -\u0026gt; 解析出 ast 结构\n  transform(transform()) -\u0026gt; 解析 ast 得到 codegenNode\n  codegen(generate()) -\u0026gt; 将 codegenNode 解析成 Render 函数\n   这是后面测试的基础，所以得提前实现了。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40  export function baseCompile( template: string | RootNode, options: CompilerOptions = {} ): CodegenResult { // const onError = options.onError || defaultOnError  const isModuleMode = options.mode === \u0026#39;module\u0026#39; const prefixIdentifiers = !__BROWSER__ \u0026amp;\u0026amp; (options.prefixIdentifiers === true || isModuleMode) // TODO errors  const ast = isString(template) ? baseParse(template, options) : template const [nodeTransforms, directiveTransforms] = getBaseTransformPreset( prefixIdentifiers ) transform( ast, extend({}, options, { prefixIdentifiers, nodeTransforms: [ ...nodeTransforms, ...(options.nodeTransforms || []) // user transforms  ], directiveTransforms: extend( {}, directiveTransforms, options.directiveTransforms || {} ) }) ) return generate( ast, extend({}, options, { prefixIdentifiers }) ) }      35248ce add exports maybe needs   feat(add): compiler-core exports · gcclll/stb-vue-next@35248ce\n 增加 compiler-core 模块的导出(export)内容\n  05a223b add transform pure text   feat(add): transform pure text · gcclll/stb-vue-next@05a223b\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42  export function traverseNode( node: RootNode | TemplateChildNode, context: TransformContext ) { // 保存当前被处理的 节点  context.currentNode = node // 应用 transform 插件  const { nodeTransforms } = context // 针对每个节点会收集到一个或多个 transformXxx 函数，用来解析它的 ast  // 得到 codegenNode ，这些函数会在当前的节点树被递归遍历完之后调用  const exitFns = [] for (let i = 0; i \u0026lt; nodeTransforms.length; i++) { const onExit = nodeTransforms[i](node, context) if (onExit) { if (isArray(onExit)) { exitFns.push(...onExit) } else { exitFns.push(onExit) } } if (!context.currentNode) { // 节点可能被删除了，比如： v-else-if, v-else 会合并到 v-if 的 branches[] 中  return } else { // 节点可能会替换了，需要更新  node = context.currentNode } } switch ( node.type // TODO  ) { } context.currentNode = node let i = exitFns.length while (i--) { exitFns[i]() } }     transform 阶段代码毕竟的三个阶段\n  收集 transformXxx 函数到 exitFns\n  根据 ast节点类型递归遍历子孙节点\n  按照收集时相反的顺序执行 exitFns，解析出 codegenNode\n   为了方便测试，在 generate() 中直接返回 ast : test: generate return ast for test · gcclll/stb-vue-next@999d8d6\n1 2 3 4 5 6  const { baseCompile } = require(process.env.PWD + \u0026#39;/../../static/js/vue/compiler-core.global.js\u0026#39;) const res = baseCompile(`pure text`) console.log(res.children[0])     +RESULTS:\n{ type: 2, content: \u0026#39;pure text\u0026#39;, loc: { start: { column: 1, line: 1, offset: 0 }, end: { column: 10, line: 1, offset: 9 }, source: \u0026#39;pure text\u0026#39; } }   结果显示并没有 codegenNode 因为在transformText 中满足条件\n children.length === 1 \u0026amp;\u0026amp; node.type === NodeTypes.ROOT 而直接退出了。\n 至于 root.codegenNode = undefined 需要实现 createRootCodegen()\n61ce406 add createRootCodegen() to create root.codegenNode   feat: createRootCodegen() for pure text · gcclll/stb-vue-next@61ce406\n 只增加了针对非 ELEMENT 类型或者孩子节点没有 codegenNode 的情况实现(当前 commit 最简化)。\n 当 root.children 只有一个孩子节点且该节点没有自己的 codegenNode 时候：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21  function createRootCodegen(root: RootNode, context: TransformContext) { // const { helper } = context  const { children } = root if (children.length === 1) { // 只有一个孩子节点，直接取该孩子节点 的 codegenNode  const child = children[0] if (isSingleElementRoot(root, child) \u0026amp;\u0026amp; child.codegenNode) { // 当 root 节点下只有一个 element 元素的孩子节点时，不进行提升  } else { // - single \u0026lt;slot/\u0026gt;, IfNode, ForNode: already blocks.  // - single text node: always patched.  // root codegen falls through via genNode()  root.codegenNode = child } } else if (children.length \u0026gt; 1) { // TODO  } else { // no children = noop, codegen will return null.  } }     测试\n1 2 3 4 5 6  const { baseCompile } = require(process.env.PWD + \u0026#39;/../../static/js/vue/compiler-core.global.js\u0026#39;) const res = baseCompile(`pure text`) console.log(res)    { type: 0, children: [ { type: 2, content: \u0026#39;pure text\u0026#39;, loc: [Object] } ], helpers: [], components: [], directives: [], hoists: [], imports: [], cached: 0, temps: 0, codegenNode: { type: 2, content: \u0026#39;pure text\u0026#39;, loc: { start: [Object], end: [Object], source: \u0026#39;pure text\u0026#39; } }, loc: { start: { column: 1, line: 1, offset: 0 }, end: { column: 10, line: 1, offset: 9 }, source: \u0026#39;pure text\u0026#39; } }   注意 codegenNode 其实就是 root.children[0] 节点本身。\n  b9f3cb7 add transform text   feat: transformText function · gcclll/stb-vue-next@b9f3cb7\n   必须是文本节点或者类型是组合表达式类型(COMPOUND_EXPRESSION)\n  patch flag 处理\n  构造 TEXT_CALL 类型节点\n  codegenNode -\u0026gt; createCallExpression\n    f6d5271 add generate text codegen   codegen 阶段目的是将 codegenNode 解析成 Render 函数的一部分。\n  f6d5271 add createCodegenContext()\n feat(add): codegen context creator · gcclll/stb-vue-next@f6d5271\n 上下文对象创建函数，重点方法有两个(push(code, node) 和 helper(key))。\n FIX1: lint errors, fix: f6d5271 lint errors · gcclll/stb-vue-next@0ac8c2f\n  2ef2699 增加 text codegen generator 实现\n feat: generate text codegen · gcclll/stb-vue-next@2ef2699\n 该部分涉及到一个较为完整的 codegen generator 流程，所以增加内容较多，因此这里 不直接贴代码了，请点击上面 commit 链接查看实际增加的源码。\n 处理流程：\n  preamble 处理，如果是 Node 环境需要通过 import { ...} from \u0026#39;vue\u0026#39; 语法，如 果是浏览器环境使用 const { ... } = Vue 解构语法。\n  是否使用 with() {} 作用域语法，默认是使用的\n  return ... 返回实际 render 函数返回结果，这里将返回最后被渲染的 DOM 结构。\n  genNode() 递归处理 ast 生成 render 函数的对应部分代码\n    6b901f9 增加 node 环境或 module 环境处理(genModulePreamble)\n feat: module preamble · gcclll/stb-vue-next@6b901f9 modue preamble : export { ... } from \u0026#39;vue\u0026#39; function preamble: const { ... } = Vue\n   重点增加的 genXxx 函数 genText(node, context) 专门用来处理文本节点的。\n1 2 3 4 5 6  function genText( node: TextNode | SimpleExpressionNode, context: CodegenContext ) { context.push(JSON.stringify(node.content), node) }      测试   测试将分为两个部分，\nfunction preamble 形式(作为全局 Vue 对象引入)  1 2 3 4 5 6  const { baseCompile } = require(process.env.PWD + \u0026#39;/../../static/js/vue/compiler-core.global.js\u0026#39;) const res = baseCompile(`pure text`) console.log(res.code)    return function render(_ctx, _cache) { with (_ctx) { return \u0026#34;pure text\u0026#34; } } undefined   fix: less the last } paren · gcclll/stb-vue-next@6b3bd2e\n  module preamble 形式(es6 模块化导出导入)  1 2 3 4 5 6 7  const { baseParse, baseCompile } = require(process.env.PWD + \u0026#39;/../../static/js/vue/compiler-core.global.js\u0026#39;) const res = baseCompile(`pure text`, { mode: \u0026#39;module\u0026#39; }) console.log(res.code)    return function render(_ctx, _cache) { return \u0026#34;pure text\u0026#34; } undefined   这里好像看不出啥区别，后面再说吧。\n      2f749b2 add interpolation generator   feat(add): transform -\u0026gt; generate interpolation · gcclll/stb-vue-next@2f749b2\n1 2 3 4 5 6 7 8  const { baseParse, baseCompile } = require(process.env.PWD + \u0026#39;/../../static/js/vue/compiler-core.global.js\u0026#39;) const res = baseCompile(`{{ a \u0026gt; b }}`) console.log(res.code) console.log(res.ast.children[0])     这里实现分几个部分：\n transform: traverseNode() 增加对插值的处理，后面增加了 traverseChildren 处理，因为所有的 ast 都是挂在 root.children 中的，所以最开始解析的是 ROOT 节点，因此这里必须 要增加 ROOT 类型的解析，调用 traverseChildren(node, ctx) 去递归解析 root.children\n transform() -\u0026gt; traverseNode(): ROOT 解析 -\u0026gt; traverseChildren() -\u0026gt; traverseNode(): INTERPOLATION\n  新增核心函数：遍历所有 children[] 调用 traverseNode() 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18  export function traverseChildren( parent: ParentNode, context: TransformContext ) { // TODO\tlet i = 0  const nodeRemoved = () =\u0026gt; { i-- } for (; i \u0026lt; parent.children.length; i++) { const child = parent.children[i] if (isString(child)) continue context.parent = parent context.childIndex = i // 方便在 transformXxx 函数中能快速定位到当前节点  context.onNodeRemoved = nodeRemoved traverseNode(child, context) } }      codegen: genNode() 中新增 INTERPOLATION 和 SIMPLE_EXPRESSION 类型的处理， 因为 INTERPOLATION 的 ast.content(如上面代码执行结果) 类型是 SIMPLE_EXPRESSION。\n1 2 3 4 5 6 7 8 9 10 11 12  function genExpression(node: SimpleExpressionNode, context: CodegenContext) { const { content, isStatic } = node context.push(isStatic ? JSON.stringify(content) : content, node) } function genInterpolation(node: InterpolationNode, context: CodegenContext) { const { push, helper, pure } = context if (pure) push(PURE_ANNOTATION) push(`${helper(TO_DISPLAY_STRING)}(`) genNode(node.content, context) push(\u0026#39;)\u0026#39;) }      feat(add): comment generator · gcclll/stb-vue-next@2d0e2a6\n 拓展：add comment generator\n1 2 3 4 5 6 7 8  const { baseParse, baseCompile } = require(process.env.PWD + \u0026#39;/../../static/js/vue/compiler-core.global.js\u0026#39;) const res = baseCompile(`\u0026lt;!-- i\u0026#39;m a comment --\u0026gt;`) console.log(res.code)    const _Vue = Vue return function render(_ctx, _cache) { with (_ctx) { const { createCommentVNode : _createCommentVNode } = _Vue return _createCommentVNode(\u0026#34; i\u0026#39;m a comment \u0026#34;) } } undefined    add element transfrom and generator  准备工作 compiler-core/src/utils.ts   feat: utils for compiler-core · gcclll/stb-vue-next@9436d8f\n 相关正则： const memberExpRE = /^[A-Za-z_$][\\w$]*(?:\\s*\\.\\s*[A-Za-z_$][\\w$]*|\\[[^\\]]+\\])*$/\n  feat(add): resolveComponentType · gcclll/stb-vue-next@2265e46\n 解析出组件的类型，大体分为四类：\n  动态组件： \u0026lt;component is=\u0026#34;xx\u0026#34;\u0026gt; 或 \u0026lt;component v-is=\u0026#34;xx\u0026#34;\u0026gt;\n  内置组件： Teleport, Transition, KeepAlive, Suspense\n  用户组件： $setup[] 上的组件\n  用户组件： context.components[] 上的组件\n    87339d2 add element transform   feat(add): transformElement function · gcclll/stb-vue-next@87339d2\n 普通标签的 transform codegenNode阶段。\n  add createVNodeCall() 函数，创建基本的 ELEMENT 类型节点 codegenNode\n 根据 isBlock 参数决定使用 BLOCK 函数还是 VNODE 函数。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34  export function createVNodeCall( context: TransformContext | null, tag: VNodeCall[\u0026#39;tag\u0026#39;], props?: VNodeCall[\u0026#39;props\u0026#39;], children?: VNodeCall[\u0026#39;children\u0026#39;], patchFlag?: VNodeCall[\u0026#39;patchFlag\u0026#39;], dynamicProps?: VNodeCall[\u0026#39;dynamicProps\u0026#39;], directives?: VNodeCall[\u0026#39;directives\u0026#39;], isBlock: VNodeCall[\u0026#39;isBlock\u0026#39;] = false, disableTracking: VNodeCall[\u0026#39;disableTracking\u0026#39;] = false, loc = locStub ): VNodeCall { if (context) { if (isBlock) { context.helper(OPEN_BLOCK) context.helper(CREATE_BLOCK) } else { context.helper(CREATE_VNODE) } } return { type: NodeTypes.VNODE_CALL, tag, props, children, patchFlag, dynamicProps, directives, isBlock, disableTracking, loc } }      add createObjectExpression() 函数\n1 2 3 4 5 6 7 8 9 10  export function createObjectExpression( properties: ObjectExpression[\u0026#39;properties\u0026#39;], loc: SourceLocation = locStub ): ObjectExpression { return { type: NodeTypes.JS_OBJECT_EXPRESSION, loc, properties } }      add getStaticType() 判断节点是否需要做静态提升处理\n  add transformElement: postTransformElement() 函数\n  add stringifyDynamicPropNames() 将属性转成数组结构\n   测试：\n1 2 3 4 5 6 7 8  const { baseParse, baseCompile } = require(process.env.PWD + \u0026#39;/../../static/js/vue/compiler-core.global.js\u0026#39;) const res = baseCompile(`\u0026lt;div\u0026gt;\u0026lt;/div\u0026gt;`) console.log(\u0026#39;root codegenNode: \u0026#39;, res.ast.codegenNode) console.log(res.code)    root codegenNode: undefined const _Vue = Vue return function render(_ctx, _cache) { with (_ctx) { const { createVNode : _createVNode } = _Vue return null } } undefined   正确结果：\nƒ render(_ctx, _cache) { with (_ctx) { const { createVNode: _createVNode, openBlock: _openBlock, createBlock: _createBlock } = _Vue return (_openBlock(), _createBlock(\u0026#34;div\u0026#34;)) } }   问题：\n  根节点 codegenNode 为空\n  render 函数内没有 openBlock, createBlock 导出\n  return 后面没内容(这是 generator 范畴，此节不展开)\n   问题1，2都是在同一个地方处理的，因为当 ROOT 节点只有一个孩子节点的时候，不会用 CREATE_VNODE 创建，而是改用 CREATE_BLOCK，所以这两个问题一起处理\n FIX 1,2: fix: no export open/create block function from Vue · gcclll/stb-vue-next@97cf290\n 修改： createRootCodegen(root: RootNode, context: TransformContext)\n  2f58786 add element generator   feat: element generator · gcclll/stb-vue-next@2f58786\n 路径：\n  VNODE_CALL -\u0026gt;\n  genVNodeCall() -\u0026gt;\n  genNodeList([], ctx) -\u0026gt;\n  string: push(node)\n  array: genNodeListAsArray(node, ctx)   other: genNode(node, ctx)\n     测试:\n1 2 3 4 5 6 7 8  const { baseParse, baseCompile } = require(process.env.PWD + \u0026#39;/../../static/js/vue/compiler-core.global.js\u0026#39;) const res = baseCompile(`\u0026lt;div\u0026gt;\u0026lt;/div\u0026gt;`) console.log(\u0026#39;root codegenNode: \u0026#39;, res.ast.codegenNode) console.log(res.code)    root codegenNode: { type: 13, tag: \u0026#39;\u0026#34;div\u0026#34;\u0026#39;, props: undefined, children: undefined, patchFlag: undefined, dynamicProps: undefined, directives: undefined, isBlock: true, disableTracking: false, loc: { start: { column: 1, line: 1, offset: 0 }, end: { column: 12, line: 1, offset: 11 }, source: \u0026#39;\u0026lt;div\u0026gt;\u0026lt;/div\u0026gt;\u0026#39; } } const _Vue = Vue return function render(_ctx, _cache) { with (_ctx) { const { createVNode : _createVNode, openBlock : _openBlock, createBlock : _createBlock } = _Vue return (_openBlock(), _createBlock(\u0026#34;div\u0026#34;)) } }    05ca2f8 root.children 有多个孩子   feat: root.children has multi child · gcclll/stb-vue-next@05ca2f8 · GitHub\n 当有多个孩子节点的时候，会创建一个 fragment 将他们包起来。\n  FIX: 死循环， genNode(node.codegenNode, ctx)\n  测试：\n1 2 3 4 5 6 7 8  const { baseParse, baseCompile } = require(process.env.PWD + \u0026#39;/../../static/js/vue/compiler-core.global.js\u0026#39;) const res = baseCompile(`\u0026lt;div\u0026gt;\u0026lt;/div\u0026gt;\u0026lt;div\u0026gt;\u0026lt;/div\u0026gt;`) console.log(res.code)    const _Vue = Vue return function render(_ctx, _cache) { with (_ctx) { const { createVNode : _createVNode, Fragment : _Fragment, openBlock : _openBlock, createBlock : _createBlock } = _Vue return (_openBlock(), _createBlock(_Fragment,null,[ _createVNode(\u0026#34;div\u0026#34;), _createVNode(\u0026#34;div\u0026#34;) ],64 /* STABLE_FRAGMENT */)) } } undefined   FIX: 参数之间少了空格(feat: root.children has multi child · gcclll/stb-vue-next@05ca2f8)\n 正解：\nconst _Vue = Vue const { createVNode: _createVNode } = _Vue const _hoisted_1 = /*#__PURE__*/_createVNode(\u0026#34;div\u0026#34;, null, null, -1 /* HOISTED */) const _hoisted_2 = /*#__PURE__*/_createVNode(\u0026#34;div\u0026#34;, null, null, -1 /* HOISTED */) return function render(_ctx, _cache) { with (_ctx) { const { createVNode: _createVNode, Fragment: _Fragment, openBlock: _openBlock, createBlock: _createBlock } = _Vue return (_openBlock(), _createBlock(_Fragment, null, [ _hoisted_1, _hoisted_2 ], 64 /* STABLE_FRAGMENT */)) } }   正确答案中做了静态提升处理，代码在 transform() 函数中 hoistStatic(root, context) 的调用，会从 ROOT 节点开始遍历，将需要提升的节点进行提升处理。\n    7cb3dbf add hoist static 静态提升   满足提升的三种情况：\n  tag 和 tagType 都是 ELEMENT 且整棵树都是静态\n  包含动态孩子节点，但是有静态属性的，将属性提升\n  纯文本节点\n   feat(add): hoist static · gcclll/stb-vue-next@7d7dbd4\n transform() 中增加静态提升处理：\n1 2 3  if (options.hoistStatic) { hoistStatic(root, context) }     feat: hoist static · gcclll/stb-vue-next@7cb3dbf\n  修改 genFunctionPreamble(ast: RootNode, context: CodegenContext) 解构出需要用到的函数(_createVNode)\n   增加 genHoists() 函数，生成 ast.hoists 中需要提升的节点\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32  function genHoists(hoists: (JSChildNode | null)[], context: CodegenContext) { if (!hoists.length) { return } context.pure = true const { push, newline, helper, scopeId, mode } = context const genScopeId = !__BROWSER__ \u0026amp;\u0026amp; scopeId != null \u0026amp;\u0026amp; mode !== \u0026#39;function\u0026#39; newline() // push scope Id before initializing hoisted vnodes so that these vnodes // get the proper scopeId as well. if (genScopeId) { push(`${helper(PUSH_SCOPE_ID)}(\u0026#34;${scopeId}\u0026#34;)`) newline() } hoists.forEach((exp, i) =\u0026gt; { if (exp) { push(`const _hoisted_${i + 1}= `) genNode(exp, context) newline() } }) if (genScopeId) { push(`${helper(POP_SCOPE_ID)}()`) newline() } context.pure = false }       测试：\n1 2 3 4 5 6 7  const { baseParse, baseCompile } = require(process.env.PWD + \u0026#39;/../../static/js/vue/compiler-core.global.js\u0026#39;) const res = baseCompile(`\u0026lt;div\u0026gt;\u0026lt;/div\u0026gt;\u0026lt;div\u0026gt;\u0026lt;/div\u0026gt;`, { hoistStatic: true }) console.log(res.code)    const _Vue = Vue const { createVNode: _createVNode } = _Vue const _hoisted_1 = /*#__PURE__*/_createVNode(\u0026#34;div\u0026#34;, null, null, -1 /* HOISTED */) const _hoisted_2 = /*#__PURE__*/_createVNode(\u0026#34;div\u0026#34;, null, null, -1 /* HOISTED */) return function render(_ctx, _cache) { with (_ctx) { const { createVNode : _createVNode, Fragment : _Fragment, openBlock : _openBlock, createBlock : _createBlock } = _Vue return (_openBlock(), _createBlock(_Fragment, null, [ _hoisted_1, _hoisted_2 ], 64 /* STABLE_FRAGMENT */)) } } undefined   PS: 静态属性提升 feat: props hoist static · gcclll/stb-vue-next@1e58eeb\n   prop transform and generator   在这之前我们完成了以下几个基本部分：\n  文本\n  插值\n  普通标签(一个和多个)\n   接下来需要完成属性的解析才能进行下一步，因为 v-if, v-for, v-slot, ... 都需要属 性解析。\n 属性转换这里异常复杂，需要慢慢展开来讲，并且涉及到各种指令，因此对于完整的测试需 要等所有指令 transform 完成之后再进行。\n1792f93 props transform  buildProps   feat(add): transform props · gcclll/stb-vue-next@1792f93\n  将 codegenNode.props 构建成 如下结构：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35  { \u0026#34;type\u0026#34;:15, \u0026#34;properties\u0026#34;:[ { \u0026#34;type\u0026#34;:16, \u0026#34;key\u0026#34;:{ \u0026#34;type\u0026#34;:4, \u0026#34;isConstant\u0026#34;:false, \u0026#34;content\u0026#34;:\u0026#34;class\u0026#34;, \u0026#34;isStatic\u0026#34;:true }, \u0026#34;value\u0026#34;:{ \u0026#34;type\u0026#34;:4, \u0026#34;isConstant\u0026#34;:false, \u0026#34;content\u0026#34;:\u0026#34;second\u0026#34;, \u0026#34;isStatic\u0026#34;:true } }, { \u0026#34;type\u0026#34;:16, \u0026#34;key\u0026#34;:{ \u0026#34;type\u0026#34;:4, \u0026#34;isConstant\u0026#34;:false, \u0026#34;content\u0026#34;:\u0026#34;onClick\u0026#34;, \u0026#34;isStatic\u0026#34;:true }, \u0026#34;value\u0026#34;:{ \u0026#34;type\u0026#34;:4, \u0026#34;content\u0026#34;:\u0026#34;clickHandle\u0026#34;, \u0026#34;isStatic\u0026#34;:false, \u0026#34;isConstant\u0026#34;:false, } } ] }      v-bind,v-on 指令，没有参数，需要将 props 合并\n    transform props   feat: transform props in codgenNode · gcclll/stb-vue-next@20a5fa8\n    e4acc0d props generator   feat: props generator · gcclll/stb-vue-next@e4acc0d\n 修改点：\n  add genExpressionAsPropertyKey() 生成属性 key 函数\n 三种可能的属性名\n  静态属性名: \u0026lt;div class=\u0026#34;value\u0026#34;\u0026gt; -\u0026gt; { class: \u0026#34;value\u0026#34; }\n  动态属性名: \u0026lt;div :[propName]=\u0026#34;value\u0026#34; -\u0026gt; { [propName]: \u0026#34;value\u0026#34;}\n  组合表达式属性名：TODO\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19  // 生成对象的属性 key (可能是静态，动态) function genExpressionAsPropertyKey( node: ExpressionNode, context: CodegenContext ) { const { push } = context if (node.type === NodeTypes.COMPOUND_EXPRESSION) { // TODO 动态属性名或表达式  } else if (node.isStatic) { // only quote key if necessary  const text = isSimpleIdentifier(node.content) ? node.content : JSON.stringify(node.content) push(text, node) } else { push(`[${node.content}]`, node) } }        add genObjectExpression() 将属性列表生成对象\n 遍历节点的 node.properties 先生成 key(genExpressionAsPropertyKey(key)) 再生成 value(genNode(value)) 。\n   测试：\n1 2 3 4 5 6 7 8  const { baseParse, baseCompile } = require(process.env.PWD + \u0026#39;/../../static/js/vue/compiler-core.global.js\u0026#39;) const res = baseCompile(`\u0026lt;div class=\u0026#34;first\u0026#34; name=\u0026#34;div\u0026#34;\u0026gt;\u0026lt;/div\u0026gt;`, { hoistStatic: true }) console.log(res.code)    const _Vue = Vue const { createVNode: _createVNode } = _Vue const _hoisted_1 = { class: \u0026#34;first\u0026#34;, name: \u0026#34;div\u0026#34; } return function render(_ctx, _cache) { with (_ctx) { const { createVNode : _createVNode, openBlock : _openBlock, createBlock : _createBlock } = _Vue return (_openBlock(), _createBlock(\u0026#34;div\u0026#34;, _hoisted_1)) } } undefined   实例中最后是用的 createBlock() 是因为 root.children 只有一个 child 。\n   static props   修改函数： transforms/transformElement\n1 2 3 4 5 6 7 8  const { baseParse, baseCompile } = require(process.env.PWD + \u0026#39;/../../static/js/vue/compiler-core.global.js\u0026#39;) const res = baseCompile(`\u0026lt;div class=\u0026#34;first\u0026#34;\u0026gt;\u0026lt;/div\u0026gt;\u0026lt;div class=\u0026#34;second\u0026#34;\u0026gt;\u0026lt;/div\u0026gt;`, { hoistStatic: true }) console.log(res.ast.codegenNode.children[0].props[0])    { type: 6, name: \u0026#39;class\u0026#39;, value: { type: 2, content: \u0026#39;first\u0026#39;, loc: { start: [Object], end: [Object], source: \u0026#39;\u0026#34;first\u0026#34;\u0026#39; } }, loc: { start: { column: 6, line: 1, offset: 5 }, end: { column: 19, line: 1, offset: 18 }, source: \u0026#39;class=\u0026#34;first\u0026#34;\u0026#39; } } undefined    6951dd1 merge props   feat: merge props · gcclll/stb-vue-next@6951dd1\n 合并属性的条件：存在没有参数的指令，如： \u0026lt;div v-bind=\u0026#34;{...}\u0026#34; v-on=\u0026#34;{...}\u0026#34;\n FIX: fix: merge toHandlers props · gcclll/stb-vue-next@12a66f0\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  const { baseParse, baseCompile } = require(process.env.PWD + \u0026#39;/../../static/js/vue/compiler-core.global.js\u0026#39;) const log = (code, title) =\u0026gt; { console.log(`\u0026gt;\u0026gt;\u0026gt; ${title}`) const res = baseCompile(code) console.log(res.code) } log(` \u0026lt;div class=\u0026#34;first\u0026#34; v-on=\u0026#34;{ click: clickHandle }\u0026#34; v-bind=\u0026#34;{ style: \u0026#39;color:red\u0026#39; }\u0026#34;\u0026gt;\u0026lt;/div\u0026gt;`, \u0026#39;无参数的指令，合并所有属性\u0026#39;) log(`\u0026lt;div class=\u0026#34;second\u0026#34; v-on:click=\u0026#34;clickHandle\u0026#34; v-bind:style=\u0026#34;color:red\u0026#34;\u0026gt;\u0026lt;/div\u0026gt;`, \u0026#39;有参数的指令，不合并\u0026#39;)    \u0026gt;\u0026gt;\u0026gt; 无参数的指令，合并所有属性 const _Vue = Vue return function render(_ctx, _cache) { with (_ctx) { const { toHandlers : _toHandlers, mergeProps : _mergeProps, createVNode : _createVNode, openBlock : _openBlock, createBlock : _createBlock } = _Vue return (_openBlock(), _createBlock(\u0026#34;div\u0026#34;, _mergeProps({ class: \u0026#34;first\u0026#34; }, _toHandlers({ click: clickHandle }), { style: \u0026#39;color:red\u0026#39; }), null, 16 /* FULL_PROPS */)) } } \u0026gt;\u0026gt;\u0026gt; 有参数的指令，不合并 const _Vue = Vue return function render(_ctx, _cache) { with (_ctx) { const { resolveDirective : _resolveDirective, createVNode : _createVNode, openBlock : _openBlock, createBlock : _createBlock } = _Vue return _withDirectives((_openBlock(), _createBlock(\u0026#34;div\u0026#34;, { class: \u0026#34;second\u0026#34; }, null, 512 /* NEED_PATCH */)), ) } } undefined   有参数指令时，需要结合 v-on 指令解析，因此需要先实现了 transform 指令才能得到下面的正确结果。\n 不合并(mergeProps()) 的正解：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  (function anonymous( ) { const _Vue = Vue return function render(_ctx, _cache) { with (_ctx) { const { createVNode: _createVNode, openBlock: _openBlock, createBlock: _createBlock } = _Vue return (_openBlock(), _createBlock(\u0026#34;div\u0026#34;, { class: \u0026#34;second\u0026#34;, onClick: clickHandle, style: { color: \u0026#39;red\u0026#39; } }, null, 12 /* STYLE, PROPS */, [\u0026#34;onClick\u0026#34;])) } } })     下面将继续完成指令相关的 transform\n    6c43451 add v-on transform   init: feat(init): v-on directive · gcclll/stb-vue-next@98dcc96\n 实现：feat: v-on directive transform · gcclll/stb-vue-next@6c43451\n1 2 3 4 5 6 7 8 9  const { baseParse, baseCompile } = require(process.env.PWD + \u0026#39;/../../static/js/vue/compiler-core.global.js\u0026#39;) const res = baseCompile(`\u0026lt;div class=\u0026#34;second\u0026#34; v-on:click=\u0026#34;clickHandle\u0026#34; v-bind:style=\u0026#34;color:red\u0026#34;\u0026gt;\u0026lt;/div\u0026gt;`) console.log(res.code)    const _Vue = Vue return function render(_ctx, _cache) { with (_ctx) { const { resolveDirective : _resolveDirective, createVNode : _createVNode, openBlock : _openBlock, createBlock : _createBlock } = _Vue return _withDirectives((_openBlock(), _createBlock(\u0026#34;div\u0026#34;, { class: \u0026#34;second\u0026#34;, onClick: clickHandle }, null, 8 /* PROPS */, [\u0026#34;onClick\u0026#34;])), ) } } undefined   问题： v-bind 没有被解析出来。\n 如果 v-on的 exp 是个简单的表达式，需要将其转成函数 $event =\u0026gt; (i++)\n feat(add): v-on with simple expression as handler · gcclll/stb-vue-next@1542b41\n 判断是简单表达式的依据：\n const isInlineStatement = !(isMemberExp || fnExpRE.test(exp.content))\n 即不是 member expression 也不是 function expression 。\n member expression: /^[A-Za-z_$][\\w$]*(?:\\s*\\.\\s*[A-Za-z_$][\\w$]*|\\[[^\\]]+\\])*$/  function expresstion: /^\\s*([\\w$_]+|\\([^)]*?\\))\\s*=\u0026gt;|^\\s*function(?:\\s+[\\w$]+)?\\s*\\(/  测试：\n1 2 3 4 5 6 7 8 9 10 11  const { baseParse, baseCompile } = require(process.env.PWD + \u0026#39;/../../static/js/vue/compiler-core.global.js\u0026#39;) const { code, ast } = baseCompile(`\u0026lt;div v-on:click=\u0026#34;i++\u0026#34;\u0026gt;\u0026lt;/div\u0026gt;`) console.log(code) console.log(`\u0026gt;\u0026gt;\u0026gt; event name`) console.log(ast.codegenNode.props.properties[0].key) console.log(`\u0026gt;\u0026gt;\u0026gt; event handler`) console.log(ast.codegenNode.props.properties[0].value)    const _Vue = Vue return function render(_ctx, _cache) { with (_ctx) { const { createVNode : _createVNode, openBlock : _openBlock, createBlock : _createBlock } = _Vue return (_openBlock(), _createBlock(\u0026#34;div\u0026#34;, { onClick: $event =\u0026gt; (i++) }, null, 8 /* PROPS */, [\u0026#34;onClick\u0026#34;])) } } \u0026gt;\u0026gt;\u0026gt; event name { type: 4, loc: { start: { column: 11, line: 1, offset: 10 }, end: { column: 16, line: 1, offset: 15 }, source: \u0026#39;click\u0026#39; }, content: \u0026#39;onClick\u0026#39;, isStatic: true, constType: 3 } \u0026gt;\u0026gt;\u0026gt; event handler { type: 8, loc: { source: \u0026#39;\u0026#39;, start: { line: 1, column: 1, offset: 0 }, end: { line: 1, column: 1, offset: 0 } }, children: [ \u0026#39;$event =\u0026gt; (\u0026#39;, { type: 4, content: \u0026#39;i++\u0026#39;, isStatic: false, constType: 0, loc: [Object] }, \u0026#39;)\u0026#39; ] } undefined  更多测试用例(\u0026lt;f12\u0026gt;)打开控制台查看 -\u0026gt;\u0026gt; 。\n  l1(`v-on 指令`) c(``, `v-on click`) c(``, `v-on动态事件名`) l2(`TODO 'dynamic arg with prefixing'`) l2(`TODO dynamic arg with complex exp prefixing`) c(``, '如果 v-on 的exp 是个简单表达式，要用函数封装起来') c(``, `支持多个表达式`) c(``, `支持多行表达式`) c(``, `函数调用`) c(``, `函数调用加表达式混合`) c(`foo($event)\"/`, `如果本身是函数不用多余处理`) c(`{ foo($event) } \"/`, `= 如果表达式已经是函数原样输出就行`) c(``, `function, 如果表达式已经是函数原样输出就行`) c(``, `如果表达式是对象取值表达式，不用处理`) c(``, `如果没有表达式和修饰符，报错`) c(``, `如果没表达式但是有修饰符，不报错`) c(``, `事件名为 foo-bar 要转成驼峰 onFooBar`) c(``, 'case conversion for vnode hooks') compile.options = { cacheHandlers: true } c(``, `empty handler`) c(``, 'member expression handler') c(``, 'compound member expression handler') c(``, 'bail on component member expression handler') c(`foo()\" /`, 'inline function expression handler') c(``, 'inline statement handler')   options.cacheHandlers 属性要配合 options.prefixIdentifiers 使用。\n 作用是缓存事件处理函数，原理是:\n1 2 3 4 5 6 7 8 9  return function render(_ctx, _cache) { with (_ctx) { const { createVNode : _createVNode, openBlock : _openBlock, createBlock : _createBlock } = _Vue return (_openBlock(), _createBlock(\u0026#34;div\u0026#34;, { onClick: _cache[1] || (_cache[1] = () =\u0026gt; {}) })) } }     缓存的附加条件： let shouldCache: boolean = context.cacheHandlers \u0026amp;\u0026amp; !exp\n 没有表达式值的情况下才缓存，因为此时会创建一个空的函数作为事件 handler，为了避免 创建过多的无意义的空函数，使用缓存是个不错的选择(但，一般绑定了事件应该不至于不 给处理函数吧!!!)。\n  f805858 add v-bind transform   feat(add): v-bind transform · gcclll/stb-vue-next@f805858\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20  const { baseParse, baseCompile } = require(process.env.PWD + \u0026#39;/../../static/js/vue/compiler-core.global.js\u0026#39;) const res = baseCompile(` \u0026lt;div v-bind:name=\u0026#34;test\u0026#34; :age=\u0026#34;100\u0026#34; :[propName]=\u0026#34;myName\u0026#34; :[first+second]=\u0026#34;thrid\u0026#34; :no-need-camel-prop=\u0026#34;noNeedCamelProp\u0026#34; :need-camel-prop.camel=\u0026#34;needCamelProp\u0026#34; :no-exp-prop.camel \u0026gt;\u0026lt;/div\u0026gt;`, { onError(e) { console.log(e.message) } }) console.log(`\u0026gt;\u0026gt;\u0026gt; render function\\n`) console.log(res.code)    v-bind is missing expression. \u0026gt;\u0026gt;\u0026gt; render function const _Vue = Vue return function render(_ctx, _cache) { with (_ctx) { const { createVNode : _createVNode, openBlock : _openBlock, createBlock : _createBlock } = _Vue return (_openBlock(), _createBlock(\u0026#34;div\u0026#34;, { name: test, age: 100, [propName || \u0026#34;\u0026#34;]: myName, [first+second || \u0026#34;\u0026#34;]: thrid, \u0026#34;no-need-camel-prop\u0026#34;: noNeedCamelProp, needCamelProp: needCamelProp, noExpProp: \u0026#34;\u0026#34; }, null, 16 /* FULL_PROPS */, [\u0026#34;name\u0026#34;,\u0026#34;age\u0026#34;,\u0026#34;no-need-camel-prop\u0026#34;,\u0026#34;needCamelProp\u0026#34;,\u0026#34;noExpProp\u0026#34;])) } } undefined   v-bind 属性支持以下几种方式：\n  v-bind:name=\u0026#34;test\u0026#34; 无缩写属性，最普通的一种用法\n  :age=\u0026#34;100\u0026#34; 缩写形式\n  :[propName]=\u0026#34;myName\u0026#34; 普通动态属性名\n  :[first+second]=\u0026#34;third\u0026#34; 表达式动态属性名\n  :no-need-camel-prop=\u0026#34;noNeedCamelProp\u0026#34; 不需要转驼峰的属性名\n  :need-camel-prop.camel=\u0026#34;needCamelProp\u0026#34; 需要转成驼峰的属性名，需要制定 .camel 修饰符\n  no-exp-prop.camel 无属性值的属性，会给默认 \u0026#34;\u0026#34; 值，同时给出警告，不建议使用。\n  更多测试用例(\u0026lt;f12\u0026gt;)打开控制台查看 -\u0026gt;\u0026gt; 。\n  l1(`v-bind 指令 `) c(``, 'basic') c(``, `dynamic arg`) c(``, `should error if no expression`) c(``, '.camel modifier') c(``, '.camel modifier w/ dynamic arg') c(``, '.camel modifier w/ dynamic arg + prefixIdentifiers')    0cc76f0 add v-model transform   feat(add): v-model transform · gcclll/stb-vue-next@0cc76f0\n \u0026lt;input v-model=\u0026#34;model\u0026#34; /\u0026gt;\n 经过 transformModel 之后的 node.props:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39  [ { \u0026#34;type\u0026#34;:16, // JS_PROPERTY \u0026#34;key\u0026#34;:{ \u0026#34;type\u0026#34;:4, // SIMPLE_EXPRESSION \u0026#34;content\u0026#34;:\u0026#34;modelValue\u0026#34;, \u0026#34;isStatic\u0026#34;:true, \u0026#34;constType\u0026#34;:3 }, \u0026#34;value\u0026#34;:{ \u0026#34;type\u0026#34;:4, \u0026#34;content\u0026#34;:\u0026#34;model\u0026#34;, \u0026#34;isStatic\u0026#34;:false, \u0026#34;constType\u0026#34;:0, } }, { \u0026#34;type\u0026#34;:16, \u0026#34;key\u0026#34;:{ \u0026#34;type\u0026#34;:4, \u0026#34;content\u0026#34;:\u0026#34;onUpdate:modelValue\u0026#34;, \u0026#34;isStatic\u0026#34;:true, \u0026#34;constType\u0026#34;:3 }, \u0026#34;value\u0026#34;:{ \u0026#34;type\u0026#34;:8, // COMPOUND_EXPRESSION \u0026#34;children\u0026#34;:[ \u0026#34;$event =\u0026gt; (\u0026#34;, { \u0026#34;type\u0026#34;:4, \u0026#34;content\u0026#34;:\u0026#34;model\u0026#34;, \u0026#34;isStatic\u0026#34;:false, \u0026#34;constType\u0026#34;:0, }, \u0026#34; = $event)\u0026#34; ] } } ]     compiler-core 阶段的解析脑图：  从图中可以看出， v-model 指令的解析也是在 buildProps 中完成的，关于这个函数的脑 图也可以查看 buildProps(node, context) 如何构建 props ?\n vue/baseCompile 解析之后的结果：\n1 2 3 4 5 6 7 8 9 10 11 12  const _Vue = Vue return function render(_ctx, _cache) { with (_ctx) { const { createVNode: _createVNode, openBlock: _openBlock, createBlock: _createBlock } = _Vue return (_openBlock(), _createBlock(\u0026#34;input\u0026#34;, { modelValue: model, \u0026#34;onUpdate:modelValue\u0026#34;: $event =\u0026gt; (model = $event) }, null, 8 /* PROPS */, [\u0026#34;modelValue\u0026#34;, \u0026#34;onUpdate:modelValue\u0026#34;])) } }     vue/compile 经过 compile-dom package(未完成) 的 transformModel 之后的结果：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  (function anonymous( ) { const _Vue = Vue return function render(_ctx, _cache) { with (_ctx) { const { vModelText: _vModelText, createVNode: _createVNode, withDirectives: _withDirectives, openBlock: _openBlock, createBlock: _createBlock } = _Vue return _withDirectives((_openBlock(), _createBlock(\u0026#34;input\u0026#34;, { \u0026#34;onUpdate:modelValue\u0026#34;: $event =\u0026gt; (model = $event) }, null, 8 /* PROPS */, [\u0026#34;onUpdate:modelValue\u0026#34;])), [ [_vModelText, model] ]) } } })     fix: v-model no value · gcclll/stb-vue-next@a537be0\n 修复之后(genNode 没有实现 8,COMPOUND_EXPRESSION 类型)，测试\n  不带参数的 v-model\n1 2 3 4 5 6 7  const { baseParse, baseCompile } = require(process.env.PWD + \u0026#39;/../../static/js/vue/compiler-core.global.js\u0026#39;) const { code } = baseCompile(`\u0026lt;input v-model=\u0026#34;model\u0026#34; /\u0026gt;`) console.log(code)    const _Vue = Vue return function render(_ctx, _cache) { with (_ctx) { const { createVNode : _createVNode, openBlock : _openBlock, createBlock : _createBlock } = _Vue return (_openBlock(), _createBlock(\u0026#34;input\u0026#34;, { modelValue: model, \u0026#34;onUpdate:modelValue\u0026#34;: $event =\u0026gt; (model = $event) }, null, 8 /* PROPS */, [\u0026#34;modelValue\u0026#34;,\u0026#34;onUpdate:modelValue\u0026#34;])) } }    指令 { prefixIdentifiers: true } 选项(需要 node 环境, TODO)\n1 2 3 4 5 6 7 8 9  const { baseParse, baseCompile } = require(process.env.PWD + \u0026#39;/../../static/js/vue/compiler-core.global.js\u0026#39;) const { code } = baseCompile(`\u0026lt;input v-model=\u0026#34;model\u0026#34; /\u0026gt;`, { prefixIdentifiers: true }) console.log(code)    const _Vue = Vue return function render(_ctx, _cache) { with (_ctx) { const { createVNode : _createVNode, openBlock : _openBlock, createBlock : _createBlock } = _Vue return (_openBlock(), _createBlock(\u0026#34;input\u0026#34;, { modelValue: model, \u0026#34;onUpdate:modelValue\u0026#34;: $event =\u0026gt; (model = $event) }, null, 8 /* PROPS */, [\u0026#34;modelValue\u0026#34;,\u0026#34;onUpdate:modelValue\u0026#34;])) } } undefined    组合表达式(8,COMPOUND_EXPRESSION)\n1 2 3 4 5 6 7  const { baseParse, baseCompile } = require(process.env.PWD + \u0026#39;/../../static/js/vue/compiler-core.global.js\u0026#39;) const { code } = baseCompile(`\u0026lt;input v-model=\u0026#34;model[index]\u0026#34; /\u0026gt;`) console.log(code)    const _Vue = Vue return function render(_ctx, _cache) { with (_ctx) { const { createVNode : _createVNode, openBlock : _openBlock, createBlock : _createBlock } = _Vue return (_openBlock(), _createBlock(\u0026#34;input\u0026#34;, { modelValue: model[index], \u0026#34;onUpdate:modelValue\u0026#34;: $event =\u0026gt; (model[index] = $event) }, null, 8 /* PROPS */, [\u0026#34;modelValue\u0026#34;,\u0026#34;onUpdate:modelValue\u0026#34;])) } } undefined    带参数\n1 2 3 4 5 6 7 8  const { baseParse, baseCompile } = require(process.env.PWD + \u0026#39;/../../static/js/vue/compiler-core.global.js\u0026#39;) const { code } = baseCompile(`\u0026lt;input v-model:value=\u0026#34;model\u0026#34; /\u0026gt;`) console.log(code)    const _Vue = Vue return function render(_ctx, _cache) { with (_ctx) { const { createVNode : _createVNode, openBlock : _openBlock, createBlock : _createBlock } = _Vue return (_openBlock(), _createBlock(\u0026#34;input\u0026#34;, { value: model, \u0026#34;onUpdate:value\u0026#34;: $event =\u0026gt; (model = $event) }, null, 40 /* PROPS, HYDRATE_EVENTS */, [\u0026#34;value\u0026#34;,\u0026#34;onUpdate:value\u0026#34;])) } } undefined   不带参数的时候参数名会给一个默认值： modelValue, 如果有自己的参数会直接使 用提供的参数名。\n  动态参数\n1 2 3 4 5 6 7 8  const { baseParse, baseCompile } = require(process.env.PWD + \u0026#39;/../../static/js/vue/compiler-core.global.js\u0026#39;) const { code } = baseCompile(`\u0026lt;input v-model:[value]=\u0026#34;model\u0026#34; /\u0026gt;`) console.log(code)     有问题结果：\nconst _Vue = Vue return function render(_ctx, _cache) { with (_ctx) { const { createVNode : _createVNode, openBlock : _openBlock, createBlock : _createBlock } = _Vue return (_openBlock(), _createBlock(\u0026#34;input\u0026#34;, { [value]: model, : $event =\u0026gt; (model = $event) }, null, 16 /* FULL_PROPS */)) } }   结果显示，动态属性的事件名没有被解析出来 : $event =\u0026gt; (model = $event) 。\n 修复之后结果(fix: v-model dynamic arg generate · gcclll/stb-vue-next@94a7a85)：\nconst _Vue = Vue return function render(_ctx, _cache) { with (_ctx) { const { createVNode : _createVNode, openBlock : _openBlock, createBlock : _createBlock } = _Vue return (_openBlock(), _createBlock(\u0026#34;input\u0026#34;, { [value]: model, [\u0026#34;onUpdate:\u0026#34; + value]: $event =\u0026gt; (model = $event) }, null, 16 /* FULL_PROPS */)) } }    缓存事件回调函数(cacheHandlers: true, TODO)\n 需要结合 prefixIdentifiers: true 使用。\n  针对 v-model 还需要 compile-runtime 阶段的支持，由于这里还没完成，所以这里的结果 和 vue-next 测试结果会有些出入，出入点在于 compiler-runtime 期会将 modelValue: model 删除。\n 更多测试用例(\u0026lt;f12\u0026gt;)打开控制台查看 -\u0026gt;\u0026gt; 。\n  l1(`v-model 指令`) c('', 'simple expression') c('', 'simple expression (with multilines)') c('', 'compound expression') c('', 'with argument') c('', 'with dynamic argument') c('', 'should cache update handler w/ cacheHandlers: true') c('', 'should not cache update handler if it refers v-for scope variables') c('', 'should mark update handler dynamic if it refers slot scope variables') c('', 'should generate modelModifiers for component v-model') c('', 'should generate modelModifiers for component v-model with arguments') c('', 'missing expression') c('', 'empty expression') c('', 'mal-formed expression') c('', 'used on scope variable')    bf18a84 add v-once transform   feat(add): v-once · gcclll/stb-vue-next@bf18a84\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18  const seen = new WeakSet() export const transformOnce: NodeTransform = (node, context) =\u0026gt; { if (node.type === NodeTypes.ELEMENT \u0026amp;\u0026amp; findDir(node, \u0026#39;once\u0026#39;, true)) { // 缓存实现 v-once，就算有数据更新也不会重新生成 render 函数  if (seen.has(node)) { return } seen.add(node) context.helper(SET_BLOCK_TRACKING) return () =\u0026gt; { const cur = context.currentNode as ElementNode | IfNode | ForNode if (cur.codegenNode) { cur.codegenNode = context.cache(cur.codegenNode, true /* isVNode */) } } } }     v-once 指令的实现看似挺简单的，将解析后的 node 节点缓存到 seen: WeakSet 中， 下次使用的时候直接取缓存(context.cache(...))，而不是重新生成 codegenNode\n JS_CACHE_EXPRESSION 结构：\n1 2 3 4 5 6 7 8 9 10 11 12 13  export function createCacheExpression( index: number, value: JSChildNode, isVNode: boolean = false ): CacheExpression { return { type: NodeTypes.JS_CACHE_EXPRESSION, index, // 在 context.cached 中的索引  value, // v-once节点的 ast  isVNode, // block 或 vnode ?  loc: locStub } }     generator 阶段实现：feat(add): v-once generator · gcclll/stb-vue-next@8bacf14\n 在 genNode() 中增加 JS_CACHE_EXPRESSION 类型的分支处理。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20  function genCacheExpression(node: CacheExpression, context: CodegenContext) { const { push, helper, indent, deindent, newline } = context if (node.isVNode) { indent() push(`${helper(SET_BLOCK_TRACKING)}(-1),`) newline() } push(`_cache[${node.index}] = `) genNode(node.value, context) if (node.isVNode) { push(`,`) newline() push(`${helper(SET_BLOCK_TRACKING)}(1),`) newline() push(`_cache[${node.index}]`) deindent() } push(`)`) }     测试：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14  const { baseParse, baseCompile } = require(process.env.PWD + \u0026#39;/../../static/js/vue/compiler-core.global.js\u0026#39;) const c = ( tpl, desc ) =\u0026gt; { console.log(desc) const { code } = baseCompile(tpl) console.log(code) } c(`\u0026lt;div :id=\u0026#34;foo\u0026#34; v-once /\u0026gt;`, `\u0026gt;\u0026gt;\u0026gt; \u0026lt;div :id=\u0026#34;foo\u0026#34; v-once /\u0026gt;`) c(`\u0026lt;div\u0026gt;\u0026lt;div :id=\u0026#34;foo\u0026#34; v-once /\u0026gt;\u0026lt;/div\u0026gt;`, `\u0026gt;\u0026gt;\u0026gt; 标签中嵌套使用`) c(`\u0026lt;div\u0026gt;\u0026lt;Comp :id=\u0026#34;foo\u0026#34; v-once /\u0026gt;\u0026lt;/div\u0026gt;`, `\u0026gt;\u0026gt;\u0026gt; 在自定义组件上`)    \u0026gt;\u0026gt;\u0026gt; \u0026lt;div :id=\u0026#34;foo\u0026#34; v-once /\u0026gt; const _Vue = Vue return function render(_ctx, _cache) { with (_ctx) { const { setBlockTracking : _setBlockTracking, createVNode : _createVNode } = _Vue return _cache[1] || ( _setBlockTracking(-1), _cache[1] = _createVNode(\u0026#34;div\u0026#34;, { id: foo }, null, 8 /* PROPS */, [\u0026#34;id\u0026#34;]), _setBlockTracking(1), _cache[1] ) } } \u0026gt;\u0026gt;\u0026gt; 标签中嵌套使用 const _Vue = Vue return function render(_ctx, _cache) { with (_ctx) { const { setBlockTracking : _setBlockTracking, createVNode : _createVNode, openBlock : _openBlock, createBlock : _createBlock } = _Vue return (_openBlock(), _createBlock(\u0026#34;div\u0026#34;, null, [ _cache[1] || ( _setBlockTracking(-1), _cache[1] = _createVNode(\u0026#34;div\u0026#34;, { id: foo }, null, 8 /* PROPS */, [\u0026#34;id\u0026#34;]), _setBlockTracking(1), _cache[1] ) ])) } } \u0026gt;\u0026gt;\u0026gt; 在自定义组件上 const _Vue = Vue return function render(_ctx, _cache) { with (_ctx) { const { setBlockTracking : _setBlockTracking, resolveComponent : _resolveComponent, createVNode : _createVNode, openBlock : _openBlock, createBlock : _createBlock } = _Vue return (_openBlock(), _createBlock(\u0026#34;div\u0026#34;, null, [ _cache[1] || ( _setBlockTracking(-1), _cache[1] = _createVNode(_component_Comp, { id: foo }, null, 8 /* PROPS */, [\u0026#34;id\u0026#34;]), _setBlockTracking(1), _cache[1] ) ])) } } undefined   TODO 缺少： const _component_Comp = _resolveComponent(\u0026#34;Comp\u0026#34;)\n更多测试用例(\u0026lt;f12\u0026gt;)打开控制台查看 -\u0026gt;\u0026gt; 。\n  l1(`v-once 指令`) c(``, 'as root node', ast = ast.codegenNode) c(``, 'on nested plain element') c(``, 'on component') c(``, 'on slot outlet') c(``, 'with hoistStatic: true') c(``, 'with v-if/else') c(``, 'with v-for')    acdea14 add v-if transform   v-if 指令源码脑图可参考： 05 v-if 指令(git:0a591b6)\n 对于 v-if|else|else-if 指令在 transform 阶段，转换收集 transformXxx 函数过程中， 会先针对指令进行处理，比如： v-else, v-else-if 指令的组件会被解析到 v-if 节 点的 node.branches[] 分支数组里面之后被删除，这些都是在收集 transformXxx 之前需要完成的。\n 包括 v-for 指令都需要经过 createStructuralDirectiveTransform() 函数封装一层 之后，返回对应的 transformXxx 函数。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34  export function createStructuralDirectiveTransform( name: string | RegExp, fn: StructuralDirectiveTransform ): NodeTransform { const matches = isString(name) ? (n: string) =\u0026gt; n === name : (n: string) =\u0026gt; name.test(n) return (node, context) =\u0026gt; { if (node.type === NodeTypes.ELEMENT) { const { props } = node // structural directive transforms are not concerned with slots  // as they are handled separately in vSlot.ts  if (node.tagType === ElementTypes.TEMPLATE \u0026amp;\u0026amp; props.some(isVSlot)) { return } const exitFns = [] for (let i = 0; i \u0026lt; props.length; i++) { const prop = props[i] if (prop.type === NodeTypes.DIRECTIVE \u0026amp;\u0026amp; matches(prop.name)) { // structural directives are removed to avoid infinite recursion  // also we remove them *before* applying so that it can further  // traverse itself in case it moves the node around  props.splice(i, 1) i-- const onExit = fn(node, prop, context) if (onExit) exitFns.push(onExit) } } return exitFns } } }     通过 for (...) 将所有 v-if/v-for 相关指令经过他们自己的处理函数(比如： processIf ) 之后得到最终的 onExit 收集到 exitFns 中，在处理过程中随时会出 现节点的删除操作(比如： v-else 节点会在解析完之后被删除)，在正常的 traverse 过 程中这些节点都不会再存在。\n PS: 正确理解应该属于移动操作，因为原始的 AST 结构并没改变，只不过是在原有的 AST 数结构中移除到新的 AST 节点下面了。\n acdea14 v-if transform init   feat(init): v-if transform · gcclll/stb-vue-next@acdea14\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21  export const transformIf = createStructuralDirectiveTransform( /^(if|else|else-if)$/, (node, dir, context) =\u0026gt; { return processIf(node, dir, context, (ifNode, branch, isRoot) =\u0026gt; { // TODO  console.log(ifNode, branch, isRoot) return () =\u0026gt; {} }) } ) export function processIf( node: ElementNode, dir: DirectiveNode, context: TransformContext, processCodegen?: ( node: IfNode, branch: IfBranchNode, isRoot: boolean ) =\u0026gt; (() =\u0026gt; void) | undefined ) {}     初始化 v-if process 函数， processIf 函数里面会针对 v-if 节点甚至它的兄弟节点做 一系列操作，比如将下一个是 v-else 的兄弟节点删除移到自己的 branches[] 里面。\n  9039a3e v-if transform processIf   feat: v-if processIf · gcclll/stb-vue-next@9039a3e\n 这里增加了两个函数的实现：\n  processIf, 解析 if，创建 IF,9 类型的结构，替换 v-if 原来的 ast\n1 2 3 4 5  const ifNode: IfNode = { type: NodeTypes.IF, loc: node.loc, branches: [branch] }     其中 branches 保存着所有 v-else, v-else-if 分支节点，这里其实是创建了一个默认 的分支节点，因为 v-if 系列指令在 render 函数中是以三元运算符(?:)形式存 在的，所以 if 后面必须要有一个分支，即 condition ? node1 : node2 中的 node2 必须是个有效的值，才能正常使用 ?: 运算符。\n 所以，如果只有 v-if 指令的时候三元符后面的值起始是个空值(好像是 null)\n  createIfBranch, 创建 v-if 的分支节点的\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17  function createIfBranch(node: ElementNode, dir: DirectiveNode): IfBranchNode { return { type: NodeTypes.IF_BRANCH, loc: node.loc, // condition ? v-if node : v-else node  condition: dir.name === \u0026#39;else\u0026#39; ? undefined : dir.exp, // 如果用的是 \u0026lt;template v-if=\u0026#34;condition\u0026#34; ... 就需要 node.children  // 因为 template 本身是不该被渲染的  children: node.tagType === ElementTypes.TEMPLATE \u0026amp;\u0026amp; !findDir(node, \u0026#39;for\u0026#39;) ? node.children : [node], // 对于 v-for, v-if/... 都应该给它个 key, 这里是用户编写是的提供的唯一 key  // 如果没有解析器会默认生成一个全局唯一的 key  userKey: findProp(node, `key`) } }     注意看最后一个属性， v-if 分支也是需要一个 key 属性的。\n    44985b4 v-if transform createIfBranch   feat: v-if createIfBranch · gcclll/stb-vue-next@44985b4\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  export function createConditionalExpression( test: ConditionalExpression[\u0026#39;test\u0026#39;], consequent: ConditionalExpression[\u0026#39;consequent\u0026#39;], alternate: ConditionalExpression[\u0026#39;alternate\u0026#39;], newline = true ) { return { type: NodeTypes.JS_CONDITIONAL_EXPRESSION, test, consequent, alternate, newline, loc: locStub } }     这里的结构(v-if)在 render 函数中的对应关系：\n test ? consequent : alternate\n 如果有 v-else-if 时候， alternate 结构会是个完整的 JS_CONDITIONAL_EXPRESSION ，即： alternate: { test, consequent, alternate, ...} 所以：\n test ? consequent : test1 ? consequent 1 : alternate\n fix: no v-if transform · gcclll/stb-vue-next@1e24eb7\n 到这里 v-if 指令 transform 阶段已经完成，测试结果：\n1 2 3 4 5 6 7 8  const { baseParse, baseCompile } = require(process.env.PWD + \u0026#39;/../../static/js/vue/compiler-core.global.js\u0026#39;) const { code, ast } = baseCompile(`\u0026lt;div v-if=\u0026#34;ok\u0026#34;/\u0026gt;`) console.log(`\u0026gt;\u0026gt;\u0026gt; ast.codegenNode 结果`) console.log(ast.codegenNode)    \u0026gt;\u0026gt;\u0026gt; ast.codegenNode 结果 { type: 9, loc: { start: { column: 1, line: 1, offset: 0 }, end: { column: 17, line: 1, offset: 16 }, source: \u0026#39;\u0026lt;div v-if=\u0026#34;ok\u0026#34;/\u0026gt;\u0026#39; }, branches: [ { type: 10, loc: [Object], condition: [Object], children: [Array], userKey: undefined } ], codegenNode: { type: 19, test: { type: 4, content: \u0026#39;ok\u0026#39;, isStatic: false, isConstant: false, loc: [Object] }, consequent: { type: 13, tag: \u0026#39;\u0026#34;div\u0026#34;\u0026#39;, props: [Object], children: undefined, patchFlag: undefined, dynamicProps: undefined, directives: undefined, isBlock: true, disableTracking: false, loc: [Object] }, alternate: { type: 14, loc: [Object], callee: Symbol(createCommentVNode), arguments: [Array] }, newline: true, loc: { source: \u0026#39;\u0026#39;, start: [Object], end: [Object] } } } undefined   +RESULTS: 错误结果\nconst _Vue = Vue return function render(_ctx, _cache) { with (_ctx) { const { createVNode : _createVNode, openBlock : _openBlock, createBlock : _createBlock, createCommentVNode : _createCommentVNode } = _Vue return (_openBlock(), _createBlock(\u0026#34;div\u0026#34;, { key: 0 })) } } \u0026gt;\u0026gt;\u0026gt; ast.codegenNode 结果 { type: 13, tag: \u0026#39;\u0026#34;div\u0026#34;\u0026#39;, props: { type: 15, loc: { source: \u0026#39;\u0026#39;, start: [Object], end: [Object] }, properties: [ [Object] ] }, children: undefined, patchFlag: undefined, dynamicProps: undefined, directives: undefined, isBlock: true, disableTracking: false, loc: { start: { column: 1, line: 1, offset: 0 }, end: { column: 17, line: 1, offset: 16 }, source: \u0026#39;\u0026lt;div v-if=\u0026#34;ok\u0026#34;/\u0026gt;\u0026#39; } } undefined   结果显示是不对的，因为创建的 IF 结构没有替换 ast 🌲中原来的节点，追踪后发现是 漏掉了 context.replaceNode(node) 的实现。\n fix: v-if codegenNode is incorrect · gcclll/stb-vue-next@47c30d2\n traverseNode 中需要增加 case 9,IF 分支处理，遍历所有的 branches[] 。\n fix: v-if branches no codegenNode · gcclll/stb-vue-next@179f06f\n  742757e v-if generator   feat: v-if generator · gcclll/stb-vue-next@742757e\n genNode 增加 JS_CONDITIONAL_EXPRESSION 分支处理(genConditionalExpression)\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39  function genConditionalExpression( node: ConditionalExpression, context: CodegenContext ) { const { test, consequent, alternate, newline: needNewline } = node const { push, indent, deindent, newline } = context if (test.type === NodeTypes.SIMPLE_EXPRESSION) { // 非简单的标识符需要用括号，可能是表达式，所以需要 (a + b) ? ... : ...  const needsParams = !isSimpleIdentifier(test.content) needsParams \u0026amp;\u0026amp; push(`(`) genExpression(test, context) needsParams \u0026amp;\u0026amp; push(`)`) } else { push(`(`) genNode(test, context) push(`)`) } needNewline \u0026amp;\u0026amp; indent() context.indentLevel++ needNewline || push(` `) push(`? `) genNode(consequent, context) context.indentLevel-- needNewline \u0026amp;\u0026amp; newline() needNewline || push(` `) push(`: `) const isNested = alternate.type === NodeTypes.JS_CONDITIONAL_EXPRESSION if (!isNested) { // 不是嵌套  context.indentLevel++ } genNode(alternate, context) if (!isNested) { context.indentLevel-- } needNewline \u0026amp;\u0026amp; deindent(true /* without newline */) }     genConditionalExpression 处理分为三个部分\n  test 生成条件表达式，这里是: ok ，如果是表达式需要括号： (a + b)\n  consequent 用来生成 ? 后面的表达式，即 ok 结果为 truth 时执行\n  alternate 用来生成 : 后面的表达式，即 ok 结果为 falsy 时执行\n alternate 中的结构可能也是个 JS_CONDITIONAL_EXPRESSION 结构，代表可能有 v-else-if 分支，如： (a + b) ? node1 : (c + d) ? node2 : othernode 。\n   测试：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14  const { baseParse, baseCompile } = require(process.env.PWD + \u0026#39;/../../static/js/vue/compiler-core.global.js\u0026#39;) const c = ( tpl, desc ) =\u0026gt; { console.log(`\u0026gt;\u0026gt;\u0026gt; ` + desc) const { code } = baseCompile(tpl, { hoistStatic: true }) console.log(code) } c(`\u0026lt;div v-if=\u0026#34;ok\u0026#34;/\u0026gt;`, \u0026#39;basic v-if\u0026#39;) c(`\u0026lt;template v-if=\u0026#34;ok\u0026#34;\u0026gt;\u0026lt;div/\u0026gt;hello\u0026lt;p/\u0026gt;\u0026lt;/template\u0026gt;`, \u0026#39;template v-if\u0026#39;)    \u0026gt;\u0026gt;\u0026gt; basic v-if const _Vue = Vue const { createVNode: _createVNode, createCommentVNode: _createCommentVNode } = _Vue const _hoisted_1 = { key: 0 } return function render(_ctx, _cache) { with (_ctx) { const { createVNode : _createVNode, openBlock : _openBlock, createBlock : _createBlock, createCommentVNode : _createCommentVNode } = _Vue return ok ? (_openBlock(), _createBlock(\u0026#34;div\u0026#34;, _hoisted_1)) : _createCommentVNode(\u0026#34;v-if\u0026#34;, true) } } \u0026gt;\u0026gt;\u0026gt; template v-if const _Vue = Vue const { createVNode: _createVNode, createCommentVNode: _createCommentVNode, createTextVNode: _createTextVNode } = _Vue const _hoisted_1 = /*#__PURE__*/_createVNode(\u0026#34;div\u0026#34;, null, null, -1 /* HOISTED */) const _hoisted_2 = /*#__PURE__*/_createTextVNode(\u0026#34;hello\u0026#34;) const _hoisted_3 = /*#__PURE__*/_createVNode(\u0026#34;p\u0026#34;, null, null, -1 /* HOISTED */) return function render(_ctx, _cache) { with (_ctx) { const { createVNode : _createVNode, createTextVNode : _createTextVNode, Fragment : _Fragment, openBlock : _openBlock, createBlock : _createBlock, createCommentVNode : _createCommentVNode } = _Vue return ok ? (_openBlock(), _createBlock(_Fragment, { key: 0 }, [ _hoisted_1, _hoisted_2, _hoisted_3 ], 64 /* STABLE_FRAGMENT */)) : _createCommentVNode(\u0026#34;v-if\u0026#34;, true) } } undefined   BUG: 这里居然少了个 _hoisted_2 ???\n1 2 3 4 5  [ _hoisted_1, , _hoisted_3 ]     答： genNode() 中缺少对 4,TEXT_CALL 纯文本类型处理。\n 解：fix: v-if TEXT_CALL gen node · gcclll/stb-vue-next@2372b5f\n更多测试用例(\u0026lt;f12\u0026gt;)打开控制台查看 -\u0026gt;\u0026gt; 。\n  l1(`v-if 指令`) compile(``, 'basic v-if') compile(`hello`, 'template v-if') compile(``, 'component v-if')    fa77b51 v-else/v-else-if   feat(add): v-else · gcclll/stb-vue-next@fa77b51\n 修改点：\n  processCodegen() 函数里面增加分支处理\n 这里有一个需要注意的点: getParentCondition() 会一直查找 JS_CONDITIONAL_EXPRESSION 类型节点的 alternate ，如果它依旧是个 JS_CONDITIONAL_EXPRESSION 类型，说明是多级的 if/else 条件语句，直到找到最 后一个不是为止。\n 相当于 ： c1 ? cons1 : c2 ? cons2 : c3 ? cons3 : alt 会一直从 c1 节点开始 查找直到找到最后的那个 alt 节点为止，然后将新的分支挂到 alt 后面组织成新 的分支: c1 ? cons1 : c2 ? cons2 : c3 ? cons3 : c4 ? cons4 : newalt\nPS: c1, c2, c3, c4 分别代表分支节点的 test ，最后追加的 c4 ? cons4 : newalt 三个对象都属于新加的节点， {test -\u0026gt; c4, cons4 -\u0026gt; consequent, alternate -\u0026gt; newalt }\n   processIf() 里增加分支处理\n 新增代码里有个 while 循环去从当前的分支节点开始在它的兄弟节点里面往回找，直 到找到第一个 9,IF 节点，这中间不允许出现其他有效节点(除注释，空文本节点外)， 因为 v-if/else 指令节点必须紧靠着。\n 找到之后，要将当前分支节点删除，并且同时要去手动 traverseNode(branch) 一次， 因为他在原来的 ast 树种删除了，所以原来的 traverse 进程不会遍历它，因此需要手 动执行 traverse 去处理它及其孩子节点生成对应的 codegenNode 。\n 然后将其 push 到 9,IF 节点的 node.branches 里面作为分支。\n  isSameKey(a,b) 新增，检测两个 key 属性是不是相同\n 几种判定为不相同的条件：\n  key 类型不同 (a.type !== b.type)\n  key 值不同 (a.value.content !== b.value.content)\n  key 如果是指令类型，检测表达式类型，静态属性异同(isStatic)\n    getParentCondition() 新增，递归 9，IF 节点的 node.alternate.alternate.alternate... 直到找到 alternate 不是 JS_CONDITIONAL_EXPRESSION 的情况\n   FIX: fix: v-else current node dont removed · gcclll/stb-vue-next@464d681\n 测试：\n1 2 3 4 5 6 7 8  const { baseParse, baseCompile } = require(process.env.PWD + \u0026#39;/../../static/js/vue/compiler-core.global.js\u0026#39;) const { code } = baseCompile(`\u0026lt;div v-if=\u0026#34;ok\u0026#34;/\u0026gt;\u0026lt;p v-else/\u0026gt;`) console.log(code)    const _Vue = Vue return function render(_ctx, _cache) { with (_ctx) { const { createVNode : _createVNode, openBlock : _openBlock, createBlock : _createBlock, createCommentVNode : _createCommentVNode } = _Vue return ok ? (_openBlock(), _createBlock(\u0026#34;div\u0026#34;, { key: 0 })) : (_openBlock(), _createBlock(\u0026#34;p\u0026#34;, { key: 1 })) } } undefined  更多测试(\u0026lt;f12\u0026gt;)打开控制台查看 -\u0026gt;\u0026gt; 。\n  compile(``, 'v-if + v-else') compile(`hello`, 'template v-if') compile(``, 'v-if + v-else-if') compile(`fine`, 'v-if + v-else-if + v-else') compile(`   fine `, 'comment between branches') l1(`with prefixIdentifiers ... TODO`) l1(`errors`) compile(``, `没有匹配的 v-if`) compile(``, `, 没有匹配的 v-if`) compile(``, `, 相同的 key` ) log.red(`不允许不同分支使用相似的 key，因为 key 是指令属性，因此会对比它的类型及表达式`) l1(`v-on with v-if`) compile(`w/ v-if`, 'v-if 上使用 v-on 指令') log.blue(`因为这里用的是无参数的 v-on 所以会导致所有属性被合并(_mergeProps(...))。`)   BUG: v-else-if 被解析成了 else 因为 parser 阶段匹配正则不对。 fix: parser v-else-if failed · gcclll/stb-vue-next@5b83d1c\n    6c82066 add v-for transform   feat(init): v-for · gcclll/stb-vue-next@3a1662e\n feat: v-for directive · gcclll/stb-vue-next@6c82066\n v-for 指令实现过程中需要用到的几个函数：\n  transformFor() 最终生成的 tranformXxx 函数\n  createStructuralDirectiveTransform() 同 v-if 指令\n  processFor() 处理 v-for 指令入口\n  processCodegen() 同 v-if 用来生成 codegenNode 的函数\n  parseForExpression() 将 v-for=\u0026#34;item in items\u0026#34; 表达式解析成 ForParseResult{source, value, key, index} 类型 AST 。\n  createAliasExpression() 给 value, key, index 创建 SIMPLE_EXPRESSION 类型 结构。\n  createForLoopParams() 创建 _renderList 函数回调的参数 [value, key, index] ，如果没有使用默认变量： _ 或 __ ，如： (_, __, index)\n   其中 parseForExpression() 函数是解析 v-for 表达式的核心函数，里面使用了三个 正则，用来匹配指令表达式：\n  const forAliasRE = /([\\s\\S]*?)\\s+(?:in|of)\\s+([\\s\\S]*)/\n  匹配 v-for=\u0026#34;item in items\u0026#34; 中的值部分\n1 2 3 4 5 6 7 8  const re = /([\\s\\S]*?)\\s+(?:in|of)\\s+([\\s\\S]*)/ const log = (params) =\u0026gt; console.log(params.map((p, i) =\u0026gt; `${i}, ${p}`).join(`\\n`)) log.title = console.log log.title(`\u0026gt;\u0026gt;\u0026gt; 匹配 item in items`) log(\u0026#34;item in items\u0026#34;.match(re)) log.title(`\u0026gt;\u0026gt;\u0026gt; 匹配 (item, key) in items`) log(\u0026#34;( item, key ) in items\u0026#34;.match(re))    \u0026gt;\u0026gt;\u0026gt; 匹配 item in items 0, item in items 1, item 2, items \u0026gt;\u0026gt;\u0026gt; 匹配 (item, key) in items 0, ( item, key ) in items 1, ( item, key ) 2, items undefined    const forIteratorRE = /,([^,\\}\\]]*)(?:,([^,\\}\\]]*))?$/\n  这个正则表达式用来匹配 (item, key) in items 中的 item 和 key\n1 2 3 4 5 6 7 8  const re = /,([^,\\}\\]]*)(?:,([^,\\}\\]]*))?$/ const log = (params) =\u0026gt; console.log(params.map((p, i) =\u0026gt; `${i}, ${p}`).join(`\\n`)) log.title = console.log log.title(`\u0026gt;\u0026gt;\u0026gt; 匹配 \u0026#39;item, key, index\u0026#39; 中的 key 和 index`) log(\u0026#34;item, key, index\u0026#34;.match(re)) log.title(`\u0026gt;\u0026gt;\u0026gt; 匹配 \u0026#34;item, key\u0026#34; 中的 key`) log(\u0026#34;item, key\u0026#34;.match(re))    \u0026gt;\u0026gt;\u0026gt; 匹配 \u0026#39;item, key, index\u0026#39; 中的 key 和 index 0, , key, index 1, key 2, index \u0026gt;\u0026gt;\u0026gt; 匹配 \u0026#34;item, key\u0026#34; 中的 key 0, , key 1, key 2, undefined undefined    const stripParensRE = /^\\(|\\)$/g 这个用来匹配 (item, key, index) 前后括号\n   parseForExpression() 核心实现：\n  source 数据源， forAliasRE 匹配后的 RHS 值\n1 2 3 4 5 6 7  source: { type: 4, // SIMPLE_EXPRESSION loc: { source: \u0026#39;obj\u0026#39;, start: [Object], end: [Object] }, isConstant: false, content: \u0026#39;obj\u0026#39;, isStatic: false }      value 的取值，在 AST 中对应 valueAlias\n valueContent = valueContent.replace(forIteratorRE, \u0026#39;\u0026#39;).trim()\n 通过匹配 key, index 的正则，反向替换得到 value\n1 2 3 4  const re = /,([^,\\}\\]]*)(?:,([^,\\}\\]]*))?$/ console.log(`item, key, index`.replace(re, \u0026#39;\u0026#39;).trim()) console.log(`\u0026gt;\u0026gt;\u0026gt; 支持解构`) console.log(`[ id, value ], key, index`.replace(re, \u0026#39;\u0026#39;).trim())    item \u0026gt;\u0026gt;\u0026gt; 支持解构 [ id, value ] undefined   解析后的结构：\n1 2 3 4 5 6 7  valueAlias: { type: 4, // SIMPLE_EXPRESSION loc: { source: \u0026#39;value\u0026#39;, start: [Object], end: [Object] }, isConstant: false, content: \u0026#39;value\u0026#39;, isStatic: false }      key 取值处理，在 AST 中对应 keyAlias\n1 2 3 4 5 6 7  keyAlias: { type: 4, loc: { source: \u0026#39;key\u0026#39;, start: [Object], end: [Object] }, isConstant: false, content: \u0026#39;key\u0026#39;, isStatic: false }      index 取值处理，在 AST中对应 objectIndexAlias\n1 2 3 4 5 6 7  objectIndexAlias: { type: 4, loc: { source: \u0026#39;index\u0026#39;, start: [Object], end: [Object] }, isConstant: false, content: \u0026#39;index\u0026#39;, isStatic: false }       测试：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18  const { baseParse, baseCompile } = require(process.env.PWD + \u0026#39;/../../static/js/vue/compiler-core.global.js\u0026#39;) const { ast } = baseCompile(`\u0026lt;span v-for=\u0026#34;(value, key, index) in obj\u0026#34; /\u0026gt;`) const { source, valueAlias, keyAlias, objectIndexAlias, type } = ast.codegenNode console.log(`type: ${type}`) console.log(`\u0026gt;\u0026gt;\u0026gt; 数据源`) console.log(source) console.log(`\u0026gt;\u0026gt;\u0026gt; value`) console.log(valueAlias) console.log(`\u0026gt;\u0026gt;\u0026gt; key`) console.log(keyAlias) console.log(`\u0026gt;\u0026gt;\u0026gt; index`) console.log(objectIndexAlias) console.log(`\u0026gt;\u0026gt;\u0026gt; _renderList(obj, (value, key, index) =\u0026gt; {...}) 第二个参数`) console.log(ast.codegenNode.codegenNode.children.arguments[1])    type: 11 \u0026gt;\u0026gt;\u0026gt; 数据源 { type: 4, loc: { source: \u0026#39;obj\u0026#39;, start: { column: 37, line: 1, offset: 36 }, end: { column: 40, line: 1, offset: 39 } }, isConstant: false, content: \u0026#39;obj\u0026#39;, isStatic: false } \u0026gt;\u0026gt;\u0026gt; value { type: 4, loc: { source: \u0026#39;value\u0026#39;, start: { column: 15, line: 1, offset: 14 }, end: { column: 20, line: 1, offset: 19 } }, isConstant: false, content: \u0026#39;value\u0026#39;, isStatic: false } \u0026gt;\u0026gt;\u0026gt; key { type: 4, loc: { source: \u0026#39;key\u0026#39;, start: { column: 22, line: 1, offset: 21 }, end: { column: 25, line: 1, offset: 24 } }, isConstant: false, content: \u0026#39;key\u0026#39;, isStatic: false } \u0026gt;\u0026gt;\u0026gt; index { type: 4, loc: { source: \u0026#39;index\u0026#39;, start: { column: 27, line: 1, offset: 26 }, end: { column: 32, line: 1, offset: 31 } }, isConstant: false, content: \u0026#39;index\u0026#39;, isStatic: false } \u0026gt;\u0026gt;\u0026gt; _renderList(obj, (value, key, index) =\u0026gt; {...}) 第二个参数 { type: 18, // JS_FUNCTION_EXPRESSION params: [ { type: 4, loc: [Object], isConstant: false, content: \u0026#39;value\u0026#39;, isStatic: false }, { type: 4, loc: [Object], isConstant: false, content: \u0026#39;key\u0026#39;, isStatic: false }, { type: 4, loc: [Object], isConstant: false, content: \u0026#39;index\u0026#39;, isStatic: false } ], returns: { type: 13, tag: \u0026#39;\u0026#34;span\u0026#34;\u0026#39;, props: undefined, children: undefined, patchFlag: undefined, dynamicProps: undefined, directives: undefined, isBlock: true, disableTracking: false, loc: { start: [Object], end: [Object], source: \u0026#39;\u0026lt;span v-for=\u0026#34;(value, key, index) in obj\u0026#34; /\u0026gt;\u0026#39; } }, newline: true, isSlot: false, loc: { source: \u0026#39;\u0026#39;, start: { line: 1, column: 1, offset: 0 }, end: { line: 1, column: 1, offset: 0 } } } undefined    39a20fe add v-for generator   feat(add): v-for generator · gcclll/stb-vue-next@39a20fe\n codegen 阶段新增对应的实现： 18,JS_FUNCTION_EXPRESSION\n 这个主要是用来解析 _renderList(source, (value, key, index) =\u0026gt; { ... }) 函数的 第二个参数的，这是个用来 render 列表项的函数。\n 测试：\n1 2 3 4 5 6 7  const { baseParse, baseCompile } = require(process.env.PWD + \u0026#39;/../../static/js/vue/compiler-core.global.js\u0026#39;) const { code } = baseCompile(\u0026#39;\u0026lt;span v-for=\u0026#34;(item) in items\u0026#34; /\u0026gt;\u0026#39;) console.log(code)    const _Vue = Vue return function render(_ctx, _cache) { with (_ctx) { const { renderList : _renderList, Fragment : _Fragment, openBlock : _openBlock, createBlock : _createBlock, createVNode : _createVNode } = _Vue return (_openBlock(true), _createBlock(_Fragment, null, _renderList(items, (item) =\u0026gt; { return (_openBlock(), _createBlock(\u0026#34;span\u0026#34;)) )), 256 /* UNKEYED_FRAGMENT */)) } } undefined   更多测试用例请 \u0026lt;f12\u0026gt; 打开控制台查看。\n  l1(`v-for directive`) compile(``, `basic v-for`) compile('', 'value + key + index') compile('', `skipped value`) compile('', `skipped key`) compile('', `skipped value \u0026 key`) compile('{{item}}\n', `v-for with constant expression`) compile(`hello`, `template v-for`) compile('', `template v-for w/ `) log.red(`TODO  待完成......`) compile('', `template v-for key injection with single child`) compile('', `v-for on `) log.red(`TODO  待完成......`) compile('', `keyed v-for`) compile('hello', `keyed template v-for`) compile(``, `v-if + v-for`) compile(``, 'v-if + v-for on ') compile('', `v-for on element with custom directive`)    7cb8908 add slot outlet transform   feat(add): v-slot transform · gcclll/stb-vue-next@7cb8908\n transform \u0026lt;slot /\u0026gt; 标签。\n \u0026lt;slot/\u0026gt; 在 render 函数中是以 _renderSlot($slot, name, props, children) 形式存在。\n\u0026lt;slot\u0026gt; 上不允许自定义的指令存在？\n  相关函数/参数：\n  transformSlotOutlet() 该阶段的 tranformXxx 函数\n  SlotOutletProcessResult 类型定义 {slotName, slotProps}\n  processSlotOutlet(), \u0026lt;slot/\u0026gt; 的处理过程\n 首先是解析插槽名称(name 属性)，该属性可以是动态(\u0026lt;slot :name=\u0026#34;myslot\u0026#34;/\u0026gt;)也 可以是静态的(\u0026lt;slot name=\u0026#34;myslot\u0026#34;/\u0026gt;)。\n 然后解析出插槽上定义的一些属性(静态)，除了 :name 之外插槽上 不允许有其他的 指令类型的属性存在 。\n  children 参数\n \u0026lt;slot\u0026gt;\u0026lt;div/\u0026gt;\u0026lt;p/\u0026gt;\u0026lt;/slot\u0026gt;\n 在 \u0026lt;slot\u0026gt; 标签内的所有元素(\u0026lt;div/\u0026gt;\u0026lt;p/\u0026gt;)会被解析成 _renderSlot 的第四个参数。\n  测试：\n1 2 3 4 5 6 7  const { baseParse, baseCompile } = require(process.env.PWD + \u0026#39;/../../static/js/vue/compiler-core.global.js\u0026#39;) const { ast } = baseCompile(`\u0026lt;slot/\u0026gt;`) console.log(ast.codegenNode)    { type: 1, ns: 0, tag: \u0026#39;slot\u0026#39;, tagType: 2, props: [], isSelfClosing: true, children: [], loc: { start: { column: 1, line: 1, offset: 0 }, end: { column: 8, line: 1, offset: 7 }, source: \u0026#39;\u0026lt;slot/\u0026gt;\u0026#39; }, codegenNode: { type: 14, // JS_CALL_EXPRESSION loc: { start: [Object], end: [Object], source: \u0026#39;\u0026lt;slot/\u0026gt;\u0026#39; }, callee: Symbol(renderSlot), arguments: [ \u0026#39;$slots\u0026#39;, \u0026#39;\u0026#34;default\u0026#34;\u0026#39; ] } } undefined   更多 codegenNode 结果请 \u0026lt;f12\u0026gt; 打开控制台查看。\n  l1(` 插槽 transform 阶段`) const _a = ast = [`_renderSlot 参数列表：` , ast.children[0].codegenNode.arguments ] const c1 = (tpl, desc, ast = _a) = compile.call(null, tpl, desc, ast) c1(``, `default slot outlet`) c1(``, `statically named slot outlet，含静态名字`) c1(``, `dynamically named slot outlet, 含动态名字`) c1(``, `TODO dynamically named slot outlet w/ prefixIdentifiers: true`) c1(``, `default slot outlet with props，默认插槽+静动态属性`) c1(``, `statically named slot outlet with props，静态具名插槽+其他静动态属性`) c1(``, `dynamically named slot outlet with props，动态具名插槽+其他静动态属性`) c1(``, `default slot outlet with fallback`) c1(``, `named slot outlet with fallback`) c1(``, `default slot outlet with props \u0026 fallback`) c1(``, `named slot outlet with props \u0026 fallback`) c1(``, `error on unexpected custom directive on ，不允许有自定义指令？`)  ebdb1ed add track slot scopes   feat: add track slot scopes · gcclll/stb-vue-next@ebdb1ed\n 还不知道干吗的❓ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33  // A NodeTransform that: // 1. Tracks scope identifiers for scoped slots so that they don\u0026#39;t get prefixed // by transformExpression. This is only applied in non-browser builds with // { prefixIdentifiers: true }. // 2. Track v-slot depths so that we know a slot is inside another slot. // Note the exit callback is executed before buildSlots() on the same node, // so only nested slots see positive numbers. export const trackSlotScopes: NodeTransform = (node, context) =\u0026gt; { // \u0026lt;component\u0026gt; or \u0026lt;template\u0026gt;  if ( node.type === NodeTypes.ELEMENT \u0026amp;\u0026amp; (node.tagType === ElementTypes.COMPONENT || node.tagType === ElementTypes.TEMPLATE) ) { // We are only checking non-empty v-slot here  // since we only care about slots that introduce scope variables.  const vSlot = findDir(node, \u0026#39;slot\u0026#39;) if (vSlot) { const slotProps = vSlot.exp if (!__BROWSER__ \u0026amp;\u0026amp; context.prefixIdentifiers) { slotProps \u0026amp;\u0026amp; context.addIdentifiers(slotProps) } context.scopes.vSlot++ return () =\u0026gt; { if (!__BROWSER__ \u0026amp;\u0026amp; context.prefixIdentifiers) { slotProps \u0026amp;\u0026amp; context.removeIdentifiers(slotProps) } context.scopes.vSlot-- } } } }        36c1f36 (v-slot)build user component as slots   组件是如何当做 slot 处理的\n feat(add): user component treat as slot to build · gcclll/stb-vue-next@36c1f36\n 完整用户组件当 slot 处理流程图：  \u0026lt;Comp\u0026gt;\u0026lt;div/\u0026gt;\u0026lt;/Comp\u0026gt;\n 这里 Comp 是组件类型(tagType=1,COMPONENT) 会在 transformElement 中被当做 slot 来处理调用 buildSlots() 。\n更多测试用例(\u0026lt;f12\u0026gt;)打开控制台查看 -\u0026gt;\u0026gt; 。\n  l1(`插槽 generator 阶段`) compile(``, 'implicit default slot') compile(`{{ foo }}{{ bar }}`, 'on-component default slot') compile(`{{ foo }}{{ bar }}`, 'on component named slot') compile(` {{ foo }}{{ bar }}  {{ foo }}{{ bar }}  `, 'template named slots') compile(`{{ foo }}{{ bar }}`, 'on component dynamically named slot') compile(` foobar `, 'named slots w/ implicit default slot') compile(` {{ foo }}{{ bar }}  {{ foo }}{{ bar }}  `, 'dynamically named slots') compile(` {{ foo }}{{ bar }}{{ baz }}  {{ foo }}{{ bar }}{{ baz }}  `, 'nested slots scoping') compile(`foo `, 'should force dynamic when inside v-for') l2(` TODO should only force dynamic slots when actually using scope vars w/ prefixIdentifiers: true`) compile(` hello `, 'named slot with v-if') l2(` TODO named slot with v-if + prefixIdentifiers: true`) compile(` foo bar baz `, 'named slot with v-if + v-else-if + v-else') l2(` TODO 'named slot with v-for w/ prefixIdentifiers: true'`) compile(` {{ name }} `, 'named slot with v-for') compile(``, '具名插槽+其他非 template 元素全当做默认插槽处理')  fbed5cf add component with default slot without \u0026lt;template\u0026gt; transform   feat(add): default slot without template · gcclll/stb-vue-next@fbed5cf\n \u0026lt;Comp\u0026gt;\u0026lt;div/\u0026gt;\u0026lt;/Comp\u0026gt;\n 这种情况，用户组件上既没有 v-slot 孩子节点里面也没有 \u0026lt;template v-slot\u0026gt; 最后 的处理是 \u0026lt;Comp\u0026gt;\u0026lt;/Comp\u0026gt; 里面的所有 children 被当做默认插槽处理。\n 该示例符合：\n  组件上没有 v-slot 指令\n  孩子节点里面没有 \u0026lt;template v-slot:name=\u0026#34;slotProps\u0026#34;\u0026gt;\n  因此，这里的处理是将 \u0026lt;div/\u0026gt; 即 comp.children 全部作为默认的 slot:default 来处理。\n 处理流程： \u0026lt;Comp\u0026gt; -\u0026gt; transformElement -\u0026gt; isComponent -\u0026gt; buildSlots() -\u0026gt; {slots, hasDynamicSlots} -\u0026gt; vnodeChildren -\u0026gt; {type: 13,VNODE_CALL, children: vnodeChildren, ... }\n1 2 3 4 5 6 7  const { baseParse, baseCompile } = require(process.env.PWD + \u0026#39;/../../static/js/vue/compiler-core.global.js\u0026#39;) const { ast } = baseCompile(`\u0026lt;Comp\u0026gt;\u0026lt;div/\u0026gt;\u0026lt;/Comp\u0026gt;`) console.log(ast.codegenNode)    { type: 13, tag: \u0026#39;_component_Comp\u0026#39;, props: undefined, children: { type: 15, loc: { start: [Object], end: [Object], source: \u0026#39;\u0026lt;Comp\u0026gt;\u0026lt;div/\u0026gt;\u0026lt;/Comp\u0026gt;\u0026#39; }, properties: [ [Object], [Object] ] }, patchFlag: undefined, dynamicProps: undefined, directives: undefined, isBlock: true, disableTracking: false, loc: { start: { column: 1, line: 1, offset: 0 }, end: { column: 20, line: 1, offset: 19 }, source: \u0026#39;\u0026lt;Comp\u0026gt;\u0026lt;div/\u0026gt;\u0026lt;/Comp\u0026gt;\u0026#39; } } undefined   另外在 transformElement() 函数中通过 isComponent = node.tagType === ElementTypes.COMPONENT 检测是不是用户组件，如果是继续解析该组件类型(resolveComponentType())。\n 这里最终得到的结果是： vnodeTag = _component_Comp 作为标签名，也是该 \u0026lt;Comp/\u0026gt; 组件在 Vue 实例过程中的存在的标签名(组件名称)。\n  8bed175 add component with default slot without \u0026lt;template\u0026gt; generator   feat(add): user component resolver generator · gcclll/stb-vue-next@8bed175\n 因为在 transform 阶段 transformElement 过程中，检测到 \u0026lt;Comp\u0026gt; 是个用户组件，所 以将其增加到了 context.components.add(\u0026#39;Comp\u0026#39;) 中了，在 generator 阶段会去检测 这个 components 用来解析组件得到组件的引用：\n _component_Comp = _resolveComponent(\u0026#34;Comp\u0026#34;)\n 新增的代码主要由两部分：\n  新增 genAssets() 函数处理 context.components\n 处理之后的结果就是增加 _component_Comp = _resolveComponent(\u0026#34;Comp\u0026#34;)\n  在 generate() 中增加 ast.components 检测，如果有内容调用 genAssets() 解 析\n  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28  // generate() 中增加  if (ast.components.length) { genAssets(ast.components, \u0026#39;component\u0026#39;, context) if (ast.directives.length || ast.temps \u0026gt; 0) { newline() } } // 新增 function genAssets( assets: string[], type: \u0026#39;component\u0026#39; | \u0026#39;directive\u0026#39;, { helper, push, newline }: CodegenContext ) { const resolver = helper( type === \u0026#39;component\u0026#39; ? RESOLVE_COMPONENT : RESOLVE_DIRECTIVE ) for (let i = 0; i \u0026lt; assets.length; i++) { const id = assets[i] push( `const ${toValidAssetId(id, type)}= ${resolver}(${JSON.stringify(id)})` ) if (i \u0026lt; assets.length - 1) { newline() } } }     测试：\n1 2 3 4 5 6 7 8  const { baseParse, baseCompile } = require(process.env.PWD + \u0026#39;/../../static/js/vue/compiler-core.global.js\u0026#39;) const { code } = baseCompile(`\u0026lt;Comp\u0026gt;\u0026lt;div/\u0026gt;\u0026lt;/Comp\u0026gt;`, { hoistStatic: true }) console.log(code)    const _Vue = Vue const { createVNode: _createVNode } = _Vue const _hoisted_1 = /*#__PURE__*/_createVNode(\u0026#34;div\u0026#34;, null, null, -1 /* HOISTED */) return function render(_ctx, _cache) { with (_ctx) { const { createVNode : _createVNode, resolveComponent : _resolveComponent, withCtx : _withCtx, openBlock : _openBlock, createBlock : _createBlock } = _Vue const _component_Comp = _resolveComponent(\u0026#34;Comp\u0026#34;) return (_openBlock(), _createBlock(_component_Comp, null, { default: _withCtx(() =\u0026gt; [ _hoisted_1 ]), _: 1 })) } } undefined   缺少 1 /* STABLE */ 注释: fix: slot flag text · gcclll/stb-vue-next@08a6fca\n 注意 _createBlock() 的第三个参数变成了一个对象(children) 对象里面包含了两个 属性: default 和 _ 分别代表了默认插槽下的孩子节点，和该插槽标识(1-STABLE,2-FORWARDED,3-DYNAMIC)\n  9f58154 fix: 文本节点没有合并(transformText)   fix: adjacent text node need merge · gcclll/stb-vue-next@9f58154\n 对于 `\u0026lt;Comp v-slot=\u0026#34;{ foo }\u0026#34;\u0026gt;{{ foo }}{{ bar }}\u0026lt;/Comp\u0026gt;` 用例得到的结果非预期。\n vue-next 正确结果：\n1 2 3 4 5 6 7 8 9 10 11  const { baseCompile } = require(process.env.PWD + \u0026#39;/../../static/vue/vue.js\u0026#39;) const { ast } = baseCompile(`\u0026lt;Comp v-slot=\u0026#34;{ foo }\u0026#34;\u0026gt;{{ foo }}{{ bar }}\u0026lt;/Comp\u0026gt;`) const returns = ast.codegenNode.children.properties[0].value.returns console.log(returns) console.log(`\u0026gt;\u0026gt;\u0026gt; 解析后的 {{ foo }} {{ bar }} 应该合并`) console.log(returns[0].content) console.log(`\u0026gt;\u0026gt;\u0026gt; 下面正是合并之后的两个插值`) console.log(returns[0].content.children)    You are running a development build of Vue. Make sure to use the production build (*.prod.js) when deploying for production. [ { type: 12, content: { type: 8, loc: [Object], children: [Array] }, loc: { start: [Object], end: [Object], source: \u0026#39;{{ foo }}\u0026#39; }, codegenNode: { type: 14, loc: [Object], callee: Symbol(createTextVNode), arguments: [Array] } } ] \u0026gt;\u0026gt;\u0026gt; 解析后的 {{ foo }} {{ bar }} 应该合并 { type: 8, loc: { start: { column: 24, line: 1, offset: 23 }, end: { column: 33, line: 1, offset: 32 }, source: \u0026#39;{{ foo }}\u0026#39; }, children: [ { type: 5, content: [Object], loc: [Object] }, \u0026#39; + \u0026#39;, { type: 5, content: [Object], loc: [Object] } ] } \u0026gt;\u0026gt;\u0026gt; 下面正是合并之后的两个插值 [ { type: 5, content: { type: 4, isStatic: false, constType: 0, content: \u0026#39;foo\u0026#39;, loc: [Object] }, loc: { start: [Object], end: [Object], source: \u0026#39;{{ foo }}\u0026#39; } }, \u0026#39; + \u0026#39;, { type: 5, content: { type: 4, isStatic: false, constType: 0, content: \u0026#39;bar\u0026#39;, loc: [Object] }, loc: { start: [Object], end: [Object], source: \u0026#39;{{ bar }}\u0026#39; } } ] undefined   看下现阶段 stb-vue-next 输出结果：\n1 2 3 4 5 6 7 8 9  const { baseCompile } = require(process.env.PWD + \u0026#39;/../../static/js/vue/compiler-core.global.js\u0026#39;) const { ast } = baseCompile(`\u0026lt;Comp v-slot=\u0026#34;{ foo }\u0026#34;\u0026gt;{{ foo }}{{ bar }}\u0026lt;/Comp\u0026gt;`) const returns = ast.codegenNode.children.properties[0].value.returns console.log(returns[0].content) console.log(returns[1].content)    { type: 5, content: { type: 4, isStatic: false, isConstant: false, content: \u0026#39;foo\u0026#39;, loc: { start: [Object], end: [Object], source: \u0026#39;foo\u0026#39; } }, loc: { start: { column: 24, line: 1, offset: 23 }, end: { column: 33, line: 1, offset: 32 }, source: \u0026#39;{{ foo }}\u0026#39; } } { type: 5, content: { type: 4, isStatic: false, isConstant: false, content: \u0026#39;bar\u0026#39;, loc: { start: [Object], end: [Object], source: \u0026#39;bar\u0026#39; } }, loc: { start: { column: 33, line: 1, offset: 32 }, end: { column: 42, line: 1, offset: 41 }, source: \u0026#39;{{ bar }}\u0026#39; } } undefined   stb-vue-next 明显 returns 里面包含了两个元素分别是： {{ foo }} 和 {{ bar }}\n 这是因为在 transformText 里面没有进行文本(插值也算)合并。\n  0773374 add component nested slots scoping   fix: patchFlag should |= but != · gcclll/stb-vue-next@0773374\n 插槽嵌套使用。\n1 2 3 4 5 6 7 8  `\u0026lt;Comp\u0026gt; \u0026lt;template #default=\u0026#34;{ foo }\u0026#34;\u0026gt; \u0026lt;Inner v-slot=\u0026#34;{ bar }\u0026#34;\u0026gt; {{ foo }}{{ bar }}{{ baz }} \u0026lt;/Inner\u0026gt; {{ foo }}{{ bar }}{{ baz }} \u0026lt;/template\u0026gt; \u0026lt;/Comp\u0026gt;`     插槽嵌套使用时的解析是先里后外，因为在 transform 阶段 ast 阶段转换之后，会进行回 溯，回溯过程是相反的。\n 如：\n ast 结构 transform：\n Comp.children -\u0026gt; [template] -\u0026gt; template.children -\u0026gt; [Inner, foo, bar, baz] -\u0026gt; Inner.children -\u0026gt; [foo, bar, baz]\n ast回溯:\n Inner.children -\u0026gt; Inner -\u0026gt; template.children -\u0026gt; template -\u0026gt; Comp.children -\u0026gt; Comp\n 所以首先执行 transformElement() 的是 Inner 所以它会先进入 buildSlots() 构 建插槽结构，完了之后是 \u0026lt;template\u0026gt; 最后是 \u0026lt;Comp\u0026gt;\n  render 推导过程：\n  \u0026lt;Inner v-slot=\u0026#34;{bar}\u0026#34;\u0026gt;{{foo}}{{bar}}{{baz}}\u0026lt;/Inner\u0026gt;\n 是在用户组件上应用了 v-slot 且是默认插槽，因此它的所有孩子节点都会成为默认 插槽一部分。\n 结果：\n1 2 3 4 5 6  _createVNode(_component_Inner, null, { default: _withCtx(({ bar }) =\u0026gt; [ _createTextVNode(_toDisplayString(foo) + _toDisplayString(bar) + _toDisplayString(baz), 1 /* TEXT */) ]), _: 2, /* DYNAMIC */ }, 1024 /* DYNAMIC_SLOTS */)     这里使用的是 _createVNode 因为 Inner 非唯一的孩子节点。\n  \u0026lt;template #default=\u0026#34;{foo}\u0026#34;\u0026gt;...\u0026lt;/template\u0026gt;\n1 2 3 4 5 6 7 8 9 10 11 12  (_openBlock(), _createBlock(_component_Comp, null { default: _withCtx(({ foo }) =\u0026gt; [ _createVNode(_component_Inner, null, { default: _withCtx(({ bar }) =\u0026gt; [ _createTextVNode(_toDisplayString(foo) + _toDisplayString(bar) + _toDisplayString(baz), 1 /* TEXT */) ]), _: 2 /* DYNAMIC */ }, 1024 /* DYNAMIC_SLOTS */), _createTextVNode(_toDisplayString(foo) + _toDisplayString(bar) + _toDisplayString(baz), 1 /* TEXT */) ]), _: 1 /* STABLE */ }))     这里有个判断 Inner 为动态 slot 的关键点： context.scopes.vSlot \u0026gt; 0 而这个 值是在收集 transformXxx 阶段递增 +1 而后回溯过程中 -1 的。\n 在收集阶段 \u0026lt;template\u0026gt; 收集到 trackSlotScopes() 函数此时 context.scopes.vSlot = 1 然后递归 children执行到 Inner 收集阶段的时候 context.scopes.vSlot = 2 直到递归结束。\n 开始回溯，先是在 Inner 上应用 transformElement 直到 Inner 回溯到执行 trackSlotScopes() 应为它也有 v-slot 指令，所以 Inner 能收集到这个函数， 它回溯结束执行 trackSlotScopes() 随之 context.scopes.vSlot-- 所以此时，在 回溯 Inner 结束之后在开始回溯 \u0026lt;template\u0026gt; 之前 context.scopes.vSlot = 1 。\n 这就是 Inner 为什么没有动态属性名但是依旧会判断为动态插槽的原理。\n 一句话：如果在 \u0026lt;template v-slot\u0026gt; 里面嵌套另一个 v-slot 那个这个不管有没有 动态属性名都会被当做动态插槽来处理。\n     c1ace74 add component with v-slot inside v-for  1 2 3  `\u0026lt;div v-for=\u0026#34;i in list\u0026#34;\u0026gt; \u0026lt;Comp v-slot=\u0026#34;bar\u0026#34;\u0026gt;foo\u0026lt;/Comp\u0026gt; \u0026lt;/div\u0026gt;`     let hasDynamicSlots = context.scopes.vSlot \u0026gt; 0 || context.scopes.vFor \u0026gt; 0;\n 根据这个判断决定 v-for 里面的 v-slot 为动态插槽。\n  cfef20e add named slot with v-if   feat(add): slot with v-if · gcclll/stb-vue-next@cfef20e\n1 2 3  `\u0026lt;Comp\u0026gt; \u0026lt;template #one v-if=\u0026#34;ok\u0026#34;\u0026gt;hello\u0026lt;/template\u0026gt; \u0026lt;/Comp\u0026gt;`     测试：\n1 2 3 4 5 6 7 8 9  const { baseParse, baseCompile } = require(process.env.PWD + \u0026#39;/../../static/js/vue/compiler-core.global.js\u0026#39;) const { code } = baseCompile(`\u0026lt;Comp\u0026gt; \u0026lt;template #one v-if=\u0026#34;ok\u0026#34;\u0026gt;hello\u0026lt;/template\u0026gt; \u0026lt;/Comp\u0026gt;`) console.log(code)    const _Vue = Vue return function render(_ctx, _cache) { with (_ctx) { const { createTextVNode : _createTextVNode, resolveComponent : _resolveComponent, withCtx : _withCtx, createSlots : _createSlots, createVNode : _createVNode, openBlock : _openBlock, createBlock : _createBlock } = _Vue const _component_Comp = _resolveComponent(\u0026#34;Comp\u0026#34;) return (_openBlock(), _createBlock(_component_Comp, null, _createSlots({ _: 2 /* DYNAMIC */ }, [ ok ? { name: \u0026#34;one\u0026#34;, fn: _withCtx(() =\u0026gt; [ _createTextVNode(\u0026#34;hello\u0026#34;) ]) } : undefined ]), 1024 /* DYNAMIC_SLOTS */)) } } undefined   动态 slots 处理之后： _createSlots({ /* 静态 slots */, [ /* 动态 slots 列表 */ ] })\n 看下面的运行时的 createSlots(slots, dynamicSlots) 其实就是讲两者合并在一起了 v-if 是个对象 { fn, name } v-for 是该对象的数组。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21  export function createSlots( slots: Record\u0026lt;string, Slot\u0026gt;, dynamicSlots: ( | CompiledSlotDescriptor | CompiledSlotDescriptor[] | undefined)[] ): Record\u0026lt;string, Slot\u0026gt; { for (let i = 0; i \u0026lt; dynamicSlots.length; i++) { const slot = dynamicSlots[i] // array of dynamic slot generated by \u0026lt;template v-for=\u0026#34;...\u0026#34; #[...]\u0026gt;  if (isArray(slot)) { for (let j = 0; j \u0026lt; slot.length; j++) { slots[slot[j].name] = slot[j].fn } } else if (slot) { // conditional single slot generated by \u0026lt;template v-if=\u0026#34;...\u0026#34; #foo\u0026gt;  slots[slot.name] = slot.fn } } return slots }     拓展： v-else, v-else-if feat(add): v-else/v-else-if with v-slot · gcclll/stb-vue-next@e48d46a\n 与普通的 v-else/v-else-if 处理机制一样，首先是要找到他们兄弟节点前面的 v-if 节点， 然后将该节点挂接到 v-if 节点后面。\n 核心代码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44  // v-else/if on slot let j = i let prev while (j--) { // 找到相邻的 v-if  prev = children[j] // 往回找第一个非注释的节点  if (prev.type !== NodeTypes.COMMENT) { break } } // 如果该节点是 v-if 合法，否则不合法使用情况 if (prev \u0026amp;\u0026amp; isTemplateNode(prev) \u0026amp;\u0026amp; findDir(prev, \u0026#39;if\u0026#39;)) { // remove node  children.splice(i, 1) i-- __TEST__ \u0026amp;\u0026amp; assert(dynamicSlots.length \u0026gt; 0) // attach this slot to previous conditional  let conditional = dynamicSlots[ dynamicSlots.length - 1 ] as ConditionalExpression // 这目的是找到 ?: 表达式最后的那个节点  while ( conditional.alternate.type === NodeTypes.JS_CONDITIONAL_EXPRESSION ) { conditional = conditional.alternate } // 将当前的 v-else/v-else-if 挂到最后那个节点表达式位置  // vElse.exp 检测是 v-else-if 还是 v-else(没有值exp)  conditional.alternate = vElse.exp ? createConditionalExpression( vElse.exp, buildDynamicSlot(slotName, slotFunction), defaultFallback ) : buildDynamicSlot(slotName, slotFunction) } else { context.onError( createCompilerError(ErrorCodes.X_V_ELSE_NO_ADJACENT_IF, vElse.loc) ) }      c1ace74 add v-for on v-slot component   feat(add): v-slot inside v-for · gcclll/stb-vue-next@c1ace74\n v-for 的处理和 v-if 原理是一样的，最后返回的都是 {name, fn} 类型，只不过 v-for 返回的是这个类型的数组。\n v-for _renderList 和 slot 的结合：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29  _renderList(list, (i) =\u0026gt; { return { name: name, fn: _withCtx(() =\u0026gt; [ _createTextVNode(_toDisplayString(name), 1 /* TEXT */) ]) } }) // 等于是： [ { name, fn }, { name1, fn1 }] // 然后 _renderSlots -\u0026gt; _renderSlots({ _: 2 /* DYNAMIC */ }, [ _renderList(list, ...) ]) // -\u0026gt; _createBlock _createBlock(_component_Comp, null, _renderSlots({ /* 静态，最终动态插槽会合并到该对象来 */ }, [ /* ... 动态列表 */ ])) // 对比无动态插槽情况： _createBlock(_component_Comp, null { default: _withCtx(() =\u0026gt; [ _createTextVNode(_toDisplayString(foo), 1 /* TEXT */) ]), _: 1 /* STABLE */ })     测试：\n1 2 3 4 5 6 7 8 9  const { baseParse, baseCompile } = require(process.env.PWD + \u0026#39;/../../static/js/vue/compiler-core.global.js\u0026#39;) const { code } = baseCompile(`\u0026lt;Comp\u0026gt; \u0026lt;template v-for=\u0026#34;name in list\u0026#34; #[name]\u0026gt;{{ name }}\u0026lt;/template\u0026gt; \u0026lt;/Comp\u0026gt;`) console.log(code)    const _Vue = Vue return function render(_ctx, _cache) { with (_ctx) { const { toDisplayString : _toDisplayString, createTextVNode : _createTextVNode, resolveComponent : _resolveComponent, withCtx : _withCtx, renderList : _renderList, createSlots : _createSlots, createVNode : _createVNode, openBlock : _openBlock, createBlock : _createBlock } = _Vue const _component_Comp = _resolveComponent(\u0026#34;Comp\u0026#34;) return (_openBlock(), _createBlock(_component_Comp, null, _createSlots({ _: 2 /* DYNAMIC */ }, [ _renderList(list, (name) =\u0026gt; { return { name: name, fn: _withCtx(() =\u0026gt; [ _createTextVNode(_toDisplayString(name), 1 /* TEXT */) ]) } )) ]), 1024 /* DYNAMIC_SLOTS */)) } } undefined   无非就是不同类型元素、组件 render 方式的组合。\n  小结：v-slot 几种用法    \u0026lt;Comp\u0026gt;\u0026lt;div/\u0026gt;\u0026lt;/Comp\u0026gt; , 用户组件上的默认插槽\n1 2 3 4 5 6 7  const _hoisted_1 = /*# __PURE__ */_createVNode(\u0026#39;div\u0026#39;, null, null, -1 /* HOISTED */) (_openBlock(), _createBlock(_component_Comp, null, { default: _withCtx(() =\u0026gt; [ _hoisted_1 ]), _: 1 /* STABLE */ }))      \u0026lt;Comp v-slot=\u0026#34;slotProps\u0026#34;\u0026gt;\u0026lt;div/\u0026gt;\u0026lt;/Comp\u0026gt;, 用户组件上带 slotProps 的默认插槽\n1 2 3 4 5 6 7  const _hoisted_1 = /*# __PURE__ */_createVNode(\u0026#39;div\u0026#39;, null, null, -1 /* HOISTED */) (_openBlock(), _createBlock(_component_Comp, null, { default: _withCtx((slotProps) =\u0026gt; [ _hoisted_1 ]), _: 1 /* STABLE */ }))      \u0026lt;Comp v-slot:named=\u0026#34;slotProps\u0026#34;\u0026gt;, 用户组件上具名插槽\n1 2 3 4 5 6  const _hoisted_1 = /*# __PURE__ */_createVNode(\u0026#39;div\u0026#39;, null, null, -1 /* HOISTED */) (_openBlock(), _createBlock(_component_Comp, null, { named: _withCtx((slotProps) =\u0026gt; [ _hoisted_1 ]) }))      \u0026lt;Comp v-slot:[named]=\u0026#34;slotProps\u0026#34;\u0026gt;, 用户组件上动态具名插槽\n1 2 3 4 5 6  const _hoisted_1 = /*# __PURE__ */_createVNode(\u0026#39;div\u0026#39;, null, null, -1 /* HOISTED */) (_openBlock(), _createBlock(_component_Comp, null, { [named]: _withCtx((slotProps) =\u0026gt; [ _hoisted_1 ]) }))      \u0026lt;template\u0026gt; 默认插槽\n \u0026lt;Comp\u0026gt;\u0026lt;template v-slot=\u0026#34;slotProps\u0026#34;\u0026gt;\u0026lt;div/\u0026gt;\u0026lt;/template\u0026gt;\u0026lt;/Comp\u0026gt;\n \u0026lt;template\u0026gt; 上的默认插槽，这个时候 \u0026lt;Comp\u0026gt; 不能在使用 v-slot ，下同   \u0026lt;template\u0026gt; 具名插槽\n \u0026lt;Comp\u0026gt;\u0026lt;template v-slot:named=\u0026#34;slotProps\u0026#34;\u0026gt;\u0026lt;/Comp\u0026gt;\n1 2 3 4  return (_openBlock(), _createBlock(_component_Comp, null, { named: _withCtx((slotProps) =\u0026gt; []), _: 1 /* STABLE */ }))      \u0026lt;template\u0026gt; 动态具名插槽\n \u0026lt;Comp\u0026gt;\u0026lt;template v-slot:[named]=\u0026#34;slotProps\u0026#34;\u0026gt;\u0026lt;/Comp\u0026gt;\n1 2 3 4  return (_openBlock(), _createBlock(_component_Comp, null, { [named]: _withCtx((slotProps) =\u0026gt; []), _: 1 /* STABLE */ }))      \u0026lt;template\u0026gt; 具名插槽，其余非 template 元素当做默认插槽处理\n \u0026lt;Comp\u0026gt;\u0026lt;template v-slot:named=\u0026#34;slotProps\u0026#34;\u0026gt;\u0026lt;div/\u0026gt;\u0026lt;/template\u0026gt;\u0026lt;div :id=\u0026#34;defaultSlotId\u0026#34;/\u0026gt;\u0026lt;/Comp\u0026gt;\n \u0026lt;template\u0026gt; 上的具名插槽 + 默认插槽，在组件内的非 \u0026lt;template\u0026gt; 元素(即： \u0026lt;div/\u0026gt;)都会被动作默认插槽来处理\n1 2 3 4 5 6 7 8 9 10 11 12  const _hoisted_1 = /*# __PURE__ */_createVNode(\u0026#34;div\u0026#34;, null, null, -1 /* HOISTED */) _createBlock(_component_Comp, null, { named: _withCtx((slotProps) =\u0026gt; [ _hoisted_1 ]), default: _withCtx(() =\u0026gt; [ _createVNode(\u0026#39;div\u0026#39;, { id: defaultSlotId }, null, 8 /* PROPS */, [\u0026#34;id\u0026#34;]) ]) _: 1 /* STABLE */ })      v-slot + v-if 插槽使用\n \u0026lt;Comp\u0026gt;\u0026lt;template v-if=\u0026#34;ok\u0026#34; #named=\u0026#34;slotProps\u0026#34;\u0026gt;{{ bar }}\u0026lt;/template\u0026gt;\u0026lt;/Comp\u0026gt;\n 配合 v-if 使用的 slot template, 最后解析成 ： ok ? { name: \u0026#39;named\u0026#39;, fn : _withCtx(() =\u0026gt; [ _createTextVNode(_toDisplayString(bar)) ]) } : undefined\n1 2 3 4 5 6 7 8 9 10 11  return (_openBlock(), _createBlock(_component_Comp, null, _renderSlots( { _: 2 /* DYNAMIC */ }, [ ok ? { name: \u0026#39;named\u0026#39;, fn: _withCtx((slotProps) =\u0026gt; [ _createTextVNode(_toDisplayString(bar), 1 /* TEXT */) ]) } : undefined ] )))      v-slot + v-for 插槽上使用\n \u0026lt;Comp\u0026gt;\u0026lt;template v-for=\u0026#34;i in list\u0026#34; #named=\u0026#34;{ prop }\u0026#34;\u0026gt;{{ bar }}\u0026lt;/template\u0026gt;\u0026lt;/Comp\u0026gt;\n1 2 3 4 5 6 7 8 9 10 11  return (_openBlock(), _createBlock(_component_Comp, null, _renderSlots( { _: 2 /* DYNAMIC */ }, _renderList(list, (i) =\u0026gt; { return { name: \u0026#39;named\u0026#39;, fn: _withCtx(({ prop }) =\u0026gt; [ _createTextVNode(_toDisplayString(bar), 1 /* TEXT */) ]) } }) )))       插槽按状态分为：\n  静态插槽，动态插槽除外的插槽\n  动态插槽，有 v-if/v-for/v-else[-if] 指令或 v-slot:[named] 或作为 v-for 节点的孩子节点都视为动态插槽\n       update vue-next merge into stb-vue-next[2020-12-11 16:54:06]   更新 vue-next 合并到 stb-vue-next。\n  ast.ts 更新\n  SimpleExpressionNode : 去掉 isConstant 属性，增加 constType\n  去掉了 StaticType 增加 ConstantType\n1 2 3 4 5 6 7 8 9 10 11  /** * Static types have several levels. * Higher levels implies lower levels. e.g. a node that can be stringified * can always be hoisted and skipped for patch. */ export const enum ConstantTypes { NOT_CONSTANT = 0, CAN_SKIP_PATCH, CAN_HOIST, CAN_STRINGIFY }        codegen.ts 更新\n fix: merge vue-next codegen.ts · gcclll/stb-vue-next@521b879\n  parse.ts 更新\n ast 结构中的 isConstant 改成 ConstantTypes 类型值\n fix: merge vue-next parse.ts isConstant -\u0026gt; constType · gcclll/stb-vue-next@fdbdc4f\n  transform.ts 更新\n fix: merge vue-next transform.ts · gcclll/stb-vue-next@22a8f0b\n  add filename\n  add isTS, inline\n    transformElement.ts\n fix: merge vue-next transformElement.ts · gcclll/stb-vue-next@1d85990\n  transformSlotOutlet.ts\n fix: merge vue-next transformSlotOutlet.ts · gcclll/stb-vue-next@58e87f3 修改 \u0026lt;slot\u0026gt;\u0026lt;/slot\u0026gt; 属性解析逻辑。\n    6efbc86 add expression transform(node-env)   feat: transformExpression -\u0026gt; processExpression · gcclll/stb-vue-next@6efbc86\n transformExpression 处理的是复杂表达式情况，且需要在非浏览器环境，因为它需要依赖 一些 JavaScript 解析器来协助完成。\n 需要处理的两种类型：\n  INTERPOLATION 插值类型\n  ELEMENT 类型且没有 v-for 指令的标签，对于指令需要处理的有 arg, exp 如果 参数是动态的情况\n   两者最终都是调用 processExpression(node, context, asPrarms, asRawStatement) 这 个函数，这个函数有点复杂，需要慢慢消化🐕 🐕 🐕   TODOs(ssr render, node env, setup meta)   在此之前都是基于浏览器去完成和测试的，但是由于后面 compiler-dom 有些测试同样需要 node 环境支持，因此这里必须先完成所有浏览器的支持，这样 prefixIdentifiers 和 cacheHandlers 也将支持。\n add generate imports and module mode: feat: gen imports · gcclll/stb-vue-next@ea7f16b\n TODO ssr template literal: feat(add): gen template literal · gcclll/stb-vue-next@356bc93\n TODO ssr if generate: feat(add): ssr gen if statement · gcclll/stb-vue-next@1c424be  TODO ssr assigment expression generate: 生成赋值表达式 feat(add): ssr gen assignment expression · gcclll/stb-vue-next@1f99a11\n TODO ssr generate sequence exprssion: feat(add): ssr gen sequence expression · gcclll/stb-vue-next@81aa0b0\n TODO ssr generate return statement: feat(add): ssr gen return statement · gcclll/stb-vue-next@c85406c\n TODO ssr v-on transform: feat(add): ssr v-on transform · gcclll/stb-vue-next@adefeec\n TODO setup mode v-model on ref: feat(add): setup mode v-model on ref · gcclll/stb-vue-next@20bb40d\n TODO process expression in vIf.ts feat(add): v-if process expression · gcclll/stb-vue-next@56c49c7\n TODO setup mode ref in transformElement feat(add): transform ref in setup mode in transformElement · gcclll/stb-vue-next@54f467f\n  non-browser testing(非浏览器环境测试)   本章节测试都是基于 node 环境进行测试的，测试代码位于各个 package 目录下的 __nests__ (node tests 缩写)里面。\n 由于测试输出结果较多，因此采用控制台形式输出，请 \u0026lt;f12\u0026gt; 打开控制台查看\n l1(`hoist static testing 静态提升测试`) c(``, 'should NOT hoist root node')     jest 跑🏃用例   fix: jest errors · gcclll/stb-vue-next@2085dd6\n@vue/runtime-dom (guessing \u0026#39;runtimeDom\u0026#39;) created packages/vue/dist/vue.global.js in 5.1s PASS packages/compiler-core/__tests__/transforms/transformElement.spec.ts (9.278 s) PASS packages/compiler-core/__tests__/transforms/vModel.spec.ts PASS packages/compiler-core/__tests__/transforms/vFor.spec.ts PASS packages/compiler-core/__tests__/parse.spec.ts PASS packages/compiler-core/__tests__/transforms/hoistStatic.spec.ts PASS packages/compiler-core/__tests__/codegen.spec.ts PASS packages/compiler-core/__tests__/transforms/vIf.spec.ts PASS packages/compiler-core/__tests__/transforms/vSlot.spec.ts PASS packages/compiler-core/__tests__/transforms/transformExpressions.spec.ts PASS packages/compiler-core/__tests__/transforms/vOn.spec.ts PASS packages/compiler-core/__tests__/transform.spec.ts PASS packages/compiler-core/__tests__/compile.spec.ts PASS packages/compiler-core/__tests__/transforms/transformSlotOutlet.spec.ts PASS packages/compiler-core/__tests__/transforms/transformText.spec.ts PASS packages/compiler-core/__tests__/transforms/vOnce.spec.ts PASS packages/compiler-core/__tests__/scopeId.spec.ts PASS packages/compiler-core/__tests__/transforms/vBind.spec.ts PASS packages/compiler-core/__tests__/transforms/noopDirectiveTransform.spec.ts PASS packages/compiler-core/__tests__/utils.spec.ts Test Suites: 19 passed, 19 total Tests: 480 passed, 480 total Snapshots: 205 passed, 205 total Time: 17.699 s   全部通过测试，期间出现两个小问题：\n  transformElement 里面解析动态属性(vnodeDynamicProps)的时候会将这些属性组成 字符串数组，这里少了个逗号\n   genFunctionExpression() 里面将函数 } 错写成了 )\n     综合测试  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67  const { baseParse, baseCompile } = require(process.env.PWD + \u0026#39;/../../static/js/vue/compiler-core.global.js\u0026#39;) const log = (...args) =\u0026gt; console.log.apply(console, args) const c = tpl =\u0026gt; baseCompile(tpl, { hoistStatic: true }).code let tpl = ``, code = `` tpl = ` \u0026lt;div :id=\u0026#34;status\u0026#34; class=\u0026#34;status\u0026#34; :style=\u0026#34;{ color: \u0026#39;red\u0026#39; }\u0026#34;\u0026gt; \u0026lt;button v-if=\u0026#34;opened\u0026#34; @click=\u0026#34;opened = !opened\u0026#34;\u0026gt;关闭\u0026lt;/button\u0026gt; \u0026lt;button v-else-if=\u0026#34;invalid\u0026#34; v-on.enter=\u0026#34;{ clicked: toggleValid }\u0026#34;\u0026gt;有效\u0026lt;/button\u0026gt; \u0026lt;button v-else @click.prevent=\u0026#34;() =\u0026gt; opened = true\u0026#34;\u0026gt;打开\u0026lt;/button\u0026gt; \u0026lt;p :name=\u0026#34;vbind\u0026#34;\u0026gt;v-bind 缩写\u0026lt;/p\u0026gt; \u0026lt;p class=\u0026#34;vbind-no-arg\u0026#34; v-bind=\u0026#34;{ name: \u0026#39;vbind\u0026#39; }\u0026#34;\u0026gt;无参数的 v-bind\u0026lt;/p\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div id=\u0026#34;list\u0026#34; :class=\u0026#34;list\u0026#34; style=\u0026#34;color:red;\u0026#34;\u0026gt; \u0026lt;ul\u0026gt; \u0026lt;li v-for=\u0026#34;(value, key, index) in list\u0026#34;\u0026gt;{{ value }}\u0026lt;/li\u0026gt; \u0026lt;/ul\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div id=\u0026#34;once\u0026#34; :class=\u0026#34;once\u0026#34;\u0026gt;{{ once }}\u0026lt;/div\u0026gt; \u0026lt;div id=\u0026#34;user-comp\u0026#34; :class=\u0026#34;user-comp\u0026#34;\u0026gt; \u0026lt;!-- 我是注释：用户组件 --\u0026gt; \u0026lt;List\u0026gt;{{ \u0026#34;我是 \u0026lt;List/\u0026gt; 的默认插槽\u0026#34; }}\u0026lt;/List\u0026gt; \u0026lt;List v-slot=\u0026#34;{ prop }\u0026#34;\u0026gt;\u0026lt;p class=\u0026#34;title\u0026#34;\u0026gt;我是带 slotProps({{ prop }}) 的默认插槽\u0026lt;/p\u0026gt;\u0026lt;/List\u0026gt; \u0026lt;List v-slot:title=\u0026#34;{ prop }\u0026#34;\u0026gt;\u0026#34;我是带名字{{ prop }}的插槽\u0026#34;\u0026lt;/List\u0026gt; \u0026lt;List\u0026gt; \u0026lt;template v-slot:one=\u0026#34;slotProps\u0026#34;\u0026gt;\u0026lt;p\u0026gt;{{ slotProps.title }}\u0026lt;/p\u0026gt;\u0026lt;/template\u0026gt; \u0026lt;p\u0026gt;我是默认插槽的一部分\u0026lt;/p\u0026gt; \u0026lt;p\u0026gt;我也是默认插槽的一部分\u0026lt;/p\u0026gt; \u0026lt;p\u0026gt;我也是。。。。。。。\u0026lt;/p\u0026gt; \u0026lt;p\u0026gt;我们都是。。。。。。\u0026lt;/p\u0026gt; \u0026lt;/List\u0026gt; \u0026lt;List\u0026gt; \u0026lt;template\u0026gt; \u0026lt;p\u0026gt;我是默认插槽\u0026lt;/p\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;template v-slot:one=\u0026#34;{ prop }\u0026#34;\u0026gt; \u0026lt;p\u0026gt;我是名字为 one 的具名插槽插槽({{ prop }})\u0026lt;/p\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;/List\u0026gt; \u0026lt;List v-if=\u0026#34;ok\u0026#34; v-slot:one=\u0026#34;slotProps\u0026#34;\u0026gt;\u0026lt;p\u0026gt;我是带 v-if 指令的且 v-slot 引用在组件上的具名 \u0026#34;one\u0026#34; 插槽，标题属性： {{ slotProps.title }}\u0026lt;/p\u0026gt;\u0026lt;/List\u0026gt; \u0026lt;List\u0026gt; \u0026lt;template\u0026gt;\u0026lt;!-- 我是默认插槽，给你们注释用的！！！！！！ --\u0026gt;\u0026lt;/template\u0026gt; \u0026lt;template v-if=\u0026#34;ok\u0026#34; v-slot:one=\u0026#34;{ prop }\u0026#34;\u0026gt; \u0026lt;p\u0026gt;带 v-if + v-slot + template 的动态插槽，我应该要用到 _createSlots(staticSlots, dynamicSLots) 函数\u0026lt;/p\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;template v-for=\u0026#34;(value, key, index) in list\u0026#34; v-slot:two=\u0026#34;slotProps\u0026#34;\u0026gt; \u0026lt;p\u0026gt;带 v-for + v-slot + template 的动态插槽，我应该要用到 _createSlots(staticSlots, dynamicSLots) 函数\u0026lt;/p\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;/List\u0026gt; \u0026lt;/div\u0026gt; ` code = c(tpl) log(`\u0026gt;\u0026gt;\u0026gt; 复杂应用场景`) log(code) log(`\\n\u0026gt; 注释\\n`, `1. v-on 表达式为简单表达式时会被处理成一个箭头函数\\n`, `2. v-on 如果没有参数时，会触发该组件上的所有属性合并(_mergeProps(...))\\n`, `3. v-on 表达式为一个函数式，不需要额外处理\\n`, `4. v-for 调用 _renderList(list, fn) 渲染列表，list 列表数据来源，fn 列表项渲染函数\\n`, `5. v-slot 应用在用户组件上时，里面就不能在使用 v-slot\\n`, `6. 只要在 template 上应用了 v-if/v-for 或者将用户组件放在 v-for 下面这些插槽都会被当做动态插槽处理\\n`)    \u0026gt;\u0026gt;\u0026gt; 复杂应用场景 const _Vue = Vue const { createVNode: _createVNode, createCommentVNode: _createCommentVNode, createTextVNode: _createTextVNode } = _Vue const _hoisted_1 = { class: \u0026#34;title\u0026#34; } const _hoisted_2 = /*#__PURE__*/_createVNode(\u0026#34;p\u0026#34;, null, \u0026#34;我是默认插槽的一部分\u0026#34;, -1 /* HOISTED */) const _hoisted_3 = /*#__PURE__*/_createVNode(\u0026#34;p\u0026#34;, null, \u0026#34;我也是默认插槽的一部分\u0026#34;, -1 /* HOISTED */) const _hoisted_4 = /*#__PURE__*/_createVNode(\u0026#34;p\u0026#34;, null, \u0026#34;我也是。。。。。。。\u0026#34;, -1 /* HOISTED */) const _hoisted_5 = /*#__PURE__*/_createVNode(\u0026#34;p\u0026#34;, null, \u0026#34;我们都是。。。。。。\u0026#34;, -1 /* HOISTED */) const _hoisted_6 = /*#__PURE__*/_createVNode(\u0026#34;template\u0026#34;, null, [ /*#__PURE__*/_createVNode(\u0026#34;p\u0026#34;, null, \u0026#34;我是默认插槽\u0026#34;) ], -1 /* HOISTED */) const _hoisted_7 = /*#__PURE__*/_createVNode(\u0026#34;template\u0026#34;, null, [ /*#__PURE__*/_createCommentVNode(\u0026#34; 我是默认插槽，给你们注释用的！！！！！！ \u0026#34;) ], -1 /* HOISTED */) const _hoisted_8 = /*#__PURE__*/_createVNode(\u0026#34;p\u0026#34;, null, \u0026#34;带 v-if + v-slot + template 的动态插槽，我应该要用到 _createSlots(staticSlots, dynamicSLots) 函数\u0026#34;, -1 /* HOISTED */) const _hoisted_9 = /*#__PURE__*/_createVNode(\u0026#34;p\u0026#34;, null, \u0026#34;带 v-for + v-slot + template 的动态插槽，我应该要用到 _createSlots(staticSlots, dynamicSLots) 函数\u0026#34;, -1 /* HOISTED */) return function render(_ctx, _cache) { with (_ctx) { const { createVNode : _createVNode, openBlock : _openBlock, createBlock : _createBlock, createCommentVNode : _createCommentVNode, toHandlers : _toHandlers, mergeProps : _mergeProps, renderList : _renderList, Fragment : _Fragment, toDisplayString : _toDisplayString, createTextVNode : _createTextVNode, resolveComponent : _resolveComponent, withCtx : _withCtx, createSlots : _createSlots } = _Vue const _component_List = _resolveComponent(\u0026#34;List\u0026#34;) return (_openBlock(), _createBlock(_Fragment, null, [ _createVNode(\u0026#34;div\u0026#34;, { id: status, class: \u0026#34;status\u0026#34;, style: { color: \u0026#39;red\u0026#39; } }, [ opened ? (_openBlock(), _createBlock(\u0026#34;button\u0026#34;, { key: 0, onClick: $event =\u0026gt; (opened = !opened) }, \u0026#34;关闭\u0026#34;, 8 /* PROPS */, [\u0026#34;onClick\u0026#34;])) : invalid ? (_openBlock(), _createBlock(\u0026#34;button\u0026#34;, _mergeProps({ key: 1 }, _toHandlers({ clicked: toggleValid })), \u0026#34;有效\u0026#34;, 16 /* FULL_PROPS */)) : (_openBlock(), _createBlock(\u0026#34;button\u0026#34;, { key: 2, onClick: () =\u0026gt; opened = true }, \u0026#34;打开\u0026#34;, 8 /* PROPS */, [\u0026#34;onClick\u0026#34;])), _createVNode(\u0026#34;p\u0026#34;, { name: vbind }, \u0026#34;v-bind 缩写\u0026#34;, 8 /* PROPS */, [\u0026#34;name\u0026#34;]), _createVNode(\u0026#34;p\u0026#34;, _mergeProps({ class: \u0026#34;vbind-no-arg\u0026#34; }, { name: \u0026#39;vbind\u0026#39; }), \u0026#34;无参数的 v-bind\u0026#34;, 16 /* FULL_PROPS */) ], 12 /* STYLE, PROPS */, [\u0026#34;id\u0026#34;]), _createVNode(\u0026#34;div\u0026#34;, { id: \u0026#34;list\u0026#34;, class: list, style: \u0026#34;color:red;\u0026#34; }, [ _createVNode(\u0026#34;ul\u0026#34;, null, [ (_openBlock(true), _createBlock(_Fragment, null, _renderList(list, (value, key, index) =\u0026gt; { return (_openBlock(), _createBlock(\u0026#34;li\u0026#34;, null, _toDisplayString(value), 1 /* TEXT */)) )), 256 /* UNKEYED_FRAGMENT */)) ]) ], 2 /* CLASS */), _createVNode(\u0026#34;div\u0026#34;, { id: \u0026#34;once\u0026#34;, class: once }, _toDisplayString(once), 3 /* TEXT, CLASS */), _createVNode(\u0026#34;div\u0026#34;, { id: \u0026#34;user-comp\u0026#34;, class: user-comp }, [ _createCommentVNode(\u0026#34; 我是注释：用户组件 \u0026#34;), _createVNode(_component_List, null, { default: _withCtx(() =\u0026gt; [ _createTextVNode(_toDisplayString(\u0026#34;我是 \u0026lt;List/\u0026gt; 的默认插槽\u0026#34;), 1 /* TEXT */) ]), _: 1 /* STABLE */ }), _createVNode(_component_List, null, { default: _withCtx(({ prop }) =\u0026gt; [ _createVNode(\u0026#34;p\u0026#34;, _hoisted_1, \u0026#34;我是带 slotProps(\u0026#34; + _toDisplayString(prop) + \u0026#34;) 的默认插槽\u0026#34;, 1 /* TEXT */) ]), _: 1 /* STABLE */ }), _createVNode(_component_List, null, { title: _withCtx(({ prop }) =\u0026gt; [ _createTextVNode(\u0026#34;\\\u0026#34;我是带名字\u0026#34; + _toDisplayString(prop) + \u0026#34;的插槽\\\u0026#34;\u0026#34;, 1 /* TEXT */) ]), _: 1 /* STABLE */ }), _createVNode(_component_List, null, { one: _withCtx((slotProps) =\u0026gt; [ _createVNode(\u0026#34;p\u0026#34;, null, _toDisplayString(slotProps.title), 1 /* TEXT */) ]), default: _withCtx(() =\u0026gt; [ _hoisted_2, _hoisted_3, _hoisted_4, _hoisted_5 ]), _: 1 /* STABLE */ }), _createVNode(_component_List, null, { one: _withCtx(({ prop }) =\u0026gt; [ _createVNode(\u0026#34;p\u0026#34;, null, \u0026#34;我是名字为 one 的具名插槽插槽(\u0026#34; + _toDisplayString(prop) + \u0026#34;)\u0026#34;, 1 /* TEXT */) ]), default: _withCtx(() =\u0026gt; [ _hoisted_6 ]), _: 1 /* STABLE */ }), ok ? (_openBlock(), _createBlock(_component_List, { key: 0 }, { one: _withCtx((slotProps) =\u0026gt; [ _createVNode(\u0026#34;p\u0026#34;, null, \u0026#34;我是带 v-if 指令的且 v-slot 引用在组件上的具名 \\\u0026#34;one\\\u0026#34; 插槽，标题属性： \u0026#34; + _toDisplayString(slotProps.title), 1 /* TEXT */) ]), _: 1 /* STABLE */ })) : _createCommentVNode(\u0026#34;v-if\u0026#34;, true), _createVNode(_component_List, null, _createSlots({ default: _withCtx(() =\u0026gt; [ _hoisted_7 ]), _: 2 /* DYNAMIC */ }, [ ok ? { name: \u0026#34;one\u0026#34;, fn: _withCtx(({ prop }) =\u0026gt; [ _hoisted_8 ]) } : undefined, _renderList(list, (value, key, index) =\u0026gt; { return { name: \u0026#34;two\u0026#34;, fn: _withCtx((slotProps) =\u0026gt; [ _hoisted_9 ]) } )) ]), 1024 /* DYNAMIC_SLOTS */) ], 2 /* CLASS */) ], 64 /* STABLE_FRAGMENT */)) } } \u0026gt; 注释 1. v-on 表达式为简单表达式时会被处理成一个箭头函数 2. v-on 如果没有参数时，会触发该组件上的所有属性合并(_mergeProps(...)) 3. v-on 表达式为一个函数式，不需要额外处理 4. v-for 调用 _renderList(list, fn) 渲染列表，list 列表数据来源，fn 列表项渲染函数 5. v-slot 应用在用户组件上时，里面就不能在使用 v-slot 6. 只要在 template 上应用了 v-if/v-for 或者将用户组件放在 v-for 下面这些插槽都会被当做动态插槽处理 undefined    ","permalink":"https://www.cheng92.com/vue/vue-mind-map-compiler-core-transform-generate/","tags":["vue,","vue3,","compiler-core,","parser,","compiler,","transform"],"title":"Vue3 源码头脑风暴之 3 ☞compiler-core - transform + codegen"},{"categories":["vue"],"contents":"  诗号：六道同坠，魔劫万千，引渡如来。  \n   stb-vue-next 完全拷贝于 vue-next ，主要目的学习及尝试应用于机顶盒环境。 \n  本文依据 commit 进程进行记录，只要跟着下面的进程走，你将能完整实 现 vue ast parser 哦 💃🏼💃🏼💃🏼 \n 声明：该篇为 ts 源码(commit)版本，之前做过一遍完整的 js 版本，更详细，也可参考\n Vue3.0 源码系列（二）编译器核心 - Compiler core 1: parse.ts - 若叶知秋\n  脑图     compiler-core parser 初始化   Vue3.0 源码系列（二）编译器核心 - Compiler core 1: parse.ts\n c0a03af add baseParse declaration\n feat(add): baseParse declaration · gcclll/stb-vue-next@c0a03af\n 添加 baseParse() 函数声明：\n1 2 3  export function baseParse(content: string, options: ParserOptions): RootNode { return {} as RootNode }     cb2d452 init baseParse function\n feat: baseParse function · gcclll/stb-vue-next@cb2d452\n 增加 baseParse 函数实现，和涉及到的一些函数和类型声明。\n1 2 3 4 5 6 7 8  export function baseParse(content: string, options: ParserOptions): RootNode { const context = createParserContext(content, options) const start = getCursor(context) return createRoot( parseChildren(context, TextModes.DATA, []), getSelection(context, start) ) }        870343c add parseChildren function   feat(init): parseChildren function · gcclll/stb-vue-next@870343c\n  4c6009d add pure text parser(parseText, parseTextData)   feat(add): parseText, parseTextData · gcclll/stb-vue-next@4c6009d\n fix lint errors: 005c261\n fix: lint errors · gcclll/stb-vue-next@005c261\n 新增了三个函数：\n  pushNode(nodes: TemplateChildNode[], node: TemplateChildNode): void\n 遍历 while 解析后的 ast ，合并相邻的文本节点。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21  function pushNode(nodes: TemplateChildNode[], node: TemplateChildNode): void { if (node.type === NodeTypes.TEXT) { // 合并两个相邻的文本内容  const prev = last(nodes) // Merge if both this and the previous node are text and those are  // consecutive. This happens for cases like \u0026#34;a \u0026lt; b\u0026#34;.  if ( prev \u0026amp;\u0026amp; prev.type === NodeTypes.TEXT \u0026amp;\u0026amp; prev.loc.end.offset === node.loc.start.offset ) { prev.content += node.content prev.loc.end = node.loc.end prev.loc.source += node.loc.source return } } nodes.push(node) }      parseText(context: ParserContext, mode: TextModes): TextNode\n 解析文本节点，文本节点结束标识： \u0026lt; 和 {{ ，分别代表标签和插值开始符号。\n 如： some text\u0026lt;div\u0026gt;...., some text{{ ... }}\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28  function parseText(context: ParserContext, mode: TextModes): TextNode { __TEST__ \u0026amp;\u0026amp; assert(context.source.length \u0026gt; 0) const endTokens = [\u0026#39;\u0026lt;\u0026#39;, context.options.delimiters[0]] if (mode === TextModes.CDATA) { endTokens.push(\u0026#39;]]\u0026gt;\u0026#39;) } let endIndex = context.source.length // 找到遇到的第一个结束符 }}, \u0026lt;  for (let i = 0; i \u0026lt; endTokens.length; i++) { const index = context.source.indexOf(endTokens[i], 1) if (index !== -1 \u0026amp;\u0026amp; endIndex \u0026gt; index) { endIndex = index } } __TEST__ \u0026amp;\u0026amp; assert(endIndex \u0026gt; 0) const start = getCursor(context) const content = parseTextData(context, endIndex, mode) return { type: NodeTypes.TEXT, content, loc: getSelection(context, start) } }      function parseTextData(context: ParserContext, length: number, mode: TextModes): string\n 处理 HTML 一些特殊符号，比如： a \u0026gt; b =\u0026gt; a \u0026amp;lt; b\n1 2 3 4 5 6 7 8  const decodeRE = /\u0026amp;(gt|lt|amp|apos|quot);/g const decodeMap: Record\u0026lt;string, string\u0026gt; = { gt: \u0026#39;\u0026gt;\u0026#39;, lt: \u0026#39;\u0026lt;\u0026#39;, amp: \u0026#39;\u0026amp;\u0026#39;, apos: \u0026#34;\u0026#39;\u0026#34;, quot: \u0026#39;\u0026#34;\u0026#39; }       测试：\n1 2 3 4 5 6 7 8 9 10  const { baseParse } = require(process.env.PWD + \u0026#39;/../../static/js/vue/compiler-core.global.js\u0026#39;) let ast = baseParse(`some text`) console.log(`\u0026gt;\u0026gt;\u0026gt; 普通文本 \u0026#34;some text\u0026#34;`) console.log(ast) console.log(`\u0026gt;\u0026gt;\u0026gt; 带 html 语义符号的文本 \u0026#34;a \u0026amp;lt; b\u0026#34;`) ast = baseParse(`a \u0026amp;lt; b`) console.log(ast)     +RESULTS: 如结果显示 \u0026amp;lt;, \u0026amp;gt; 等符号会被转成语义化符号。\n\u0026gt;\u0026gt;\u0026gt; 普通文本 \u0026#34;some text\u0026#34; { type: 0, children: [ { type: 2, content: \u0026#39;some text\u0026#39;, loc: [Object] } ], } \u0026gt;\u0026gt;\u0026gt; 带 html 语义符号的文本 \u0026#34;a \u0026amp;lt; b\u0026#34; { type: 0, children: [ { type: 2, content: \u0026#39;a \u0026lt; b\u0026#39;, loc: [Object] } ], } undefined    d7dbc28 add comment parser(parseComment)   feat(add): comment parser · gcclll/stb-vue-next@d7dbc28\n 修改 parseChildren():\n else if s[0] === \u0026#39;\u0026lt;\u0026#39; 作为开始，可能是标签、html 注释等等。\n  代码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49  function parseComment(context: ParserContext): CommentNode { __TEST__ \u0026amp;\u0026amp; assert(startsWith(context.source, \u0026#39;\u0026lt;!--\u0026#39;)) const start = getCursor(context) let content: string const match = /--(\\!)?\u0026gt;/.exec(context.source) if (!match) { // 非法注释  content = context.source.slice(4) advanceBy(context, context.source.length) emitError(context, ErrorCodes.EOF_IN_COMMENT) } else { if (match.index \u0026lt;= 3) { // 不满足 \u0026lt;!-- --\u0026gt;  emitError(context, ErrorCodes.ABRUPT_CLOSING_OF_EMPTY_COMMENT) } if (match[1]) { // 非法结束 \u0026lt;!-- --!\u0026gt;  emitError(context, ErrorCodes.INCORRECTLY_CLOSED_COMMENT) } // 注释内容  content = context.source.slice(4, match.index) // 嵌套注释  const s = context.source.slice(0, match.index) let prevIndex = 1, nestedIndex = 0 while ((nestedIndex = s.indexOf(\u0026#39;\u0026lt;!--\u0026#39;, prevIndex)) !== -1) { advanceBy(context, nestedIndex - prevIndex + 1) if (nestedIndex + 4 \u0026lt; s.length) { emitError(context, ErrorCodes.NESTED_COMMENT) } prevIndex = nestedIndex + 1 } advanceBy(context, match.index + match[0].length - prevIndex + 1) } return { type: NodeTypes.COMMENT, content, loc: getSelection(context, start) } }      通过 /--(\\!)?\u0026gt;/ 匹配注释的结束\n  如果无法匹配到，说明是非法注释，如： \u0026lt;!-- xxx -\u0026gt;\n  匹配到之后的非法情况(match.index \u0026lt;= 3)： \u0026lt;!--\u0026gt; 或 \u0026lt;!---\u0026gt;\n  捕获组((\\!))也匹配到了，非法结束： \u0026lt;!-- --!\u0026gt;\n  嵌套注释也视为非法\n  测试：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19  const { baseParse } = require(process.env.PWD + \u0026#39;/../../static/js/vue/compiler-core.global.js\u0026#39;) const catchError = fn =\u0026gt; { try { fn() } catch (e) { console.log(e.message) } } let ast = baseParse(`\u0026lt;!-- xx --\u0026gt;`) console.log(`\u0026gt;\u0026gt;\u0026gt; 非法注释：\u0026#34;\u0026lt;!-- xxx -\u0026gt;\u0026#34;`) catchError( () =\u0026gt; baseParse(`\u0026lt;!-- xxx -\u0026gt;`)) console.log(`\u0026gt;\u0026gt;\u0026gt; 非法注释：\u0026#34;\u0026lt;!---\u0026gt;\u0026#34;`) catchError( () =\u0026gt; baseParse(`\u0026lt;!---\u0026gt;`)) console.log(`\u0026gt;\u0026gt;\u0026gt; 非法注释：\u0026#34;\u0026lt;!-- xx --!\u0026gt;\u0026#34;`) catchError( () =\u0026gt; baseParse(`\u0026lt;!-- xx --!\u0026gt;`)) console.log(`\u0026gt;\u0026gt;\u0026gt; 嵌套注释：\u0026#34;\u0026lt;!-- \u0026lt;!-- --\u0026gt;\u0026#34;`) catchError( () =\u0026gt; baseParse(`\u0026lt;!-- \u0026lt;!-- --\u0026gt;`)) console.log(\u0026#39;\u0026gt;\u0026gt;\u0026gt; 有效注释\u0026#39;) console.log(ast)     +RESULTS:\n\u0026gt;\u0026gt;\u0026gt; 非法注释：\u0026#34;\u0026lt;!-- xxx -\u0026gt;\u0026#34; Unexpected EOF in comment. \u0026gt;\u0026gt;\u0026gt; 非法注释：\u0026#34;\u0026lt;!---\u0026gt;\u0026#34; Illegal comment. \u0026gt;\u0026gt;\u0026gt; 非法注释：\u0026#34;\u0026lt;!-- xx --!\u0026gt;\u0026#34; Incorrectly closed comment. \u0026gt;\u0026gt;\u0026gt; 嵌套注释：\u0026#34;\u0026lt;!-- \u0026lt;!-- --\u0026gt;\u0026#34; Unexpected \u0026#39;\u0026lt;!--\u0026#39; in comment. \u0026gt;\u0026gt;\u0026gt; 有效注释 { type: 0, children: [ { type: 3, content: \u0026#39; xx \u0026#39;, loc: [Object] } ], // ... }    7d5f9c4 add bogus comment parser(parseBogusComment)   feat(add): bogus comment parser · gcclll/stb-vue-next@7d5f9c4\n 匹配正则： /^\u0026lt;(?:[\\!\\?]|\\/[^a-z\u0026gt;])/i\n   \u0026lt;!DOCTYPE 注释\n  \u0026lt;![[CDATA\u0026gt; 类型\n  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24  function parseBogusComment(context: ParserContext): CommentNode | undefined { // \u0026lt;?... or \u0026lt;!... or \u0026lt;/.... 形式注释 ???  __TEST__ \u0026amp;\u0026amp; assert(/^\u0026lt;(?:[\\!\\?]|\\/[^a-z\u0026gt;])/i.test(context.source)) const start = getCursor(context) const contentStart = context.source[1] === \u0026#39;?\u0026#39; ? 1 : 2 let content: string // 结束  const closeIndex = context.source.indexOf(\u0026#39;\u0026gt;\u0026#39;) if (closeIndex === -1) { content = context.source.slice(contentStart) advanceBy(context, context.source.length) } else { content = context.source.slice(contentStart, closeIndex) advanceBy(context, closeIndex + 1) } return { type: NodeTypes.COMMENT, content, loc: getSelection(context, start) } }     测试：\n1 2 3 4 5 6 7 8 9 10 11 12 13  const { baseParse } = require(process.env.PWD + \u0026#39;/../../static/js/vue/compiler-core.global.js\u0026#39;) const catchError = fn =\u0026gt; { let res try { res = fn() } catch (e) { console.log(e.message) } res \u0026amp;\u0026amp; console.log(res) } // html 中使用 \u0026lt;![CDATA[ 注释 catchError(() =\u0026gt; baseParse(`\u0026lt;![CDATA[ xxx ]]`)) catchError(() =\u0026gt; baseParse(`\u0026lt;!DOCTYPE xxx \u0026gt;`))     +RESULTS:\nCDATA section is allowed only in XML context. { type: 0, children: [ { type: 3, content: \u0026#39;DOCTYPE xxx \u0026#39;, loc: [Object] } ], }    cef8485 add more error element situations   feat(add): more error element situations · gcclll/stb-vue-next@cef8485\n 更多错误标签情况，以 \u0026lt;/ 开头的情况处理。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  const { baseParse } = require(process.env.PWD + \u0026#39;/../../static/js/vue/compiler-core.global.js\u0026#39;) const catchError = fn =\u0026gt; { let res try { res = fn() } catch (e) { console.log(e.message) } res \u0026amp;\u0026amp; console.log(res) } catchError(() =\u0026gt; baseParse(`\u0026lt;/`)) catchError(() =\u0026gt; baseParse(`\u0026lt;/\u0026gt;`)) catchError(() =\u0026gt; baseParse(`\u0026lt;/xx\u0026gt;`)) catchError(() =\u0026gt; baseParse(`\u0026lt;?`)) catchError(() =\u0026gt; baseParse(`\u0026lt;*`))     +RESULTS:\nUnexpected EOF in tag. End tag name was expected. Invalid end tag. \u0026#39;\u0026lt;?\u0026#39; is allowed only in XML context. Illegal tag name. Use \u0026#39;\u0026amp;lt;\u0026#39; to print \u0026#39;\u0026lt;\u0026#39;.    b8cb825 add interpolation parser   feat(add): interpolation parser · gcclll/stb-vue-next@b8cb825\n 插值解析。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47  function parseInterpolation( context: ParserContext, mode: TextModes ): InterpolationNode | undefined { const [open, close] = context.options.delimiters __TEST__ \u0026amp;\u0026amp; assert(startsWith(context.source, open)) const closeIndex = context.source.indexOf(close, open.length) if (closeIndex === -1) { emitError(context, ErrorCodes.X_MISSING_INTERPOLATION_END) return undefined } const start = getCursor(context) advanceBy(context, open.length) const innerStart = getCursor(context) const innerEnd = getCursor(context) // 插值内容长度  const rawContentLength = closeIndex - open.length const rawContent = context.source.slice(0, rawContentLength) // html 语义化符号替换  const preTrimContent = parseTextData(context, rawContentLength, mode) // 去掉前后空格  const content = preTrimContent.trim() // 去掉空格后的内容所在的索引位置  const startOffset = preTrimContent.indexOf(content) if (startOffset \u0026gt; 0) { advancePositionWithMutation(innerStart, rawContent, startOffset) } const endOffset = rawContentLength - (preTrimContent.length - content.length - startOffset) advancePositionWithMutation(innerEnd, rawContent, endOffset) advanceBy(context, close.length) return { type: NodeTypes.INTERPOLATION, content: { type: NodeTypes.SIMPLE_EXPRESSION, isStatic: false, isConstant: false, content, loc: getSelection(context, innerStart, innerEnd) }, loc: getSelection(context, start) } }     执行操作：\n  根据 {{, }} 取出插值起始索引\n  截取插值内容，替换 html 语义字符，且去掉前后空格\n  组装插值结构\n  1 2 3 4 5 6 7 8  const { baseParse } = require(process.env.PWD + \u0026#39;/../../static/js/vue/compiler-core.global.js\u0026#39;) const ast = baseParse(`{{ foo.value }}`) console.log(ast) console.log(`\u0026gt;\u0026gt;\u0026gt; 插值节点`) console.log(ast.children[0])     +RESULTS:\n{ type: 0, children: [ { type: 5, content: [Object], loc: [Object] } ], } \u0026gt;\u0026gt;\u0026gt; 插值节点 { type: 5, content: { type: 4, isStatic: false, isConstant: false, content: \u0026#39;foo.value\u0026#39;, loc: { start: [Object], end: [Object], source: \u0026#39;foo.value\u0026#39; } }, loc: { start: { column: 1, line: 1, offset: 0 }, end: { column: 16, line: 1, offset: 15 }, source: \u0026#39;{{ foo.value }}\u0026#39; } } undefined    397da38 add element parser   feat(add): parse element function · gcclll/stb-vue-next@397da38\n 解析元素标签的入口函数，实际详细解析在 parseTag() 函数中，所以这里需要结合 parseTag 的实现才能测试。\n 代码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50  function parseElement( context: ParserContext, ancestors: ElementNode[] ): ElementNode | undefined { __TEST__ \u0026amp;\u0026amp; assert(/^\u0026lt;[a-z]/i.test(context.source)) const wasInPre = context.inPre const wasInVPre = context.inVPre const parent = last(ancestors) // 解析出开始标签  const element = {} as any // parseTag(context, TagType.Start, parent)  const isPreBoundray = context.inPre \u0026amp;\u0026amp; !wasInPre const isVPreBoundray = context.inVPre \u0026amp;\u0026amp; !wasInVPre if (element.isSelfClosing || context.options.isVoidTag(elment.tag)) { return element } ancestors.push(element) const mode = context.options.getTextMode(element, parent) const children = parseChildren(context, mode, ancestors) // 要将孩子节点解析完成的 parent element pop 掉，待处理下一个 parent 的 children  ancestors.pop() if (startsWithEndTagOpen(context.source, element.tag)) { // 结束标签  // parseTag(context, TagType.End, parent)  } else { emitError(context, ErrorCodes.X_MISSING_END_TAG, 0, element.loc.start) if (context.source.length === 0 \u0026amp;\u0026amp; element.tag.toLowerCase() === \u0026#39;script\u0026#39;) { const first = children[0] if (first \u0026amp;\u0026amp; startsWith(first.loc.source, \u0026#39;\u0026lt;!--\u0026#39;)) { emitError(context, ErrorCodes.EOF_IN_SCRIPT_HTML_COMMENT_LIKE_TEXT) } } } element.loc = getSelection(context, element.loc.start) if (isPreBoundray) { context.inPre = false } if (isVPreBoundray) { context.inVPre = false } return element }     源码分析：\n  通过调用 parseTag() 解析出标签元素结构\n  判断是不是自闭合标签(\u0026lt;div/\u0026gt;)，或者外部定义的空标签(不需要结束标签的，如： \u0026lt;my-tag\u0026gt; ，为合法标签)\n  调用 parseChildren() 递归解析该节点下子孙节点\n  结束标签解析\n  \u0026lt;pre\u0026gt; 和 v-pre 检测\n    3b96a74 add tag parser   feat(add): tag parser · gcclll/stb-vue-next@3b96a74\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63  function parseTag( context: ParserContext, type: TagType, parent: ElementNode | undefined ): ElementNode { // 匹配 \u0026lt;div\u0026gt; 或 \u0026lt;/div\u0026gt;  __TEST__ \u0026amp;\u0026amp; assert(/^\u0026lt;\\/?[a-z]/i.test(context.source)) __TEST__ \u0026amp;\u0026amp; assert( type === (startsWith(context.source, \u0026#39;\u0026lt;/\u0026#39;) ? TagType.End : TagType.Start) ) // 开始标签  const start = getCursor(context) const match = /^\u0026lt;\\/?([a-z][^\\t\\r\\n\\f /\u0026gt;]*)/i.exec(context.source)! const tag = match[1] const ns = context.options.getNamespace(tag, parent) advanceBy(context, match[0].length) advanceSpaces(context) // 保存当前状态，待会需要回过头来解析属性  // const cursor = getCursor(context)  // const currentSource = context.source  // 解析属性  let props = [] as any[] // TODO parseAttributes(context, type)  // TODO \u0026lt;pre\u0026gt; 标签  // TODO v-pre 指令  // 结束标签  let isSelfClosing = false if (context.source.length === 0) { emitError(context, ErrorCodes.EOF_IN_TAG) } else { // \u0026lt;div ... /\u0026gt;  isSelfClosing = startsWith(context.source, \u0026#39;/\u0026gt;\u0026#39;) // 到这里不应该是 End 标签  if (type === TagType.End \u0026amp;\u0026amp; isSelfClosing) { emitError(context, ErrorCodes.END_TAG_WITH_TRAILING_SOLIDUS) } advanceBy(context, isSelfClosing ? 2 : 1) } let tagType = ElementTypes.ELEMENT // TODO 标签类型解析  return { type: NodeTypes.ELEMENT, ns, tag, tagType, props, isSelfClosing, children: [], loc: getSelection(context, start), codegenNode: undefined } }      开始标签匹配正则： /^\u0026lt;\\/?([a-z][^\\t\\r\\n\\f /\u0026gt;]*)/i\n   \u0026lt;pre\u0026gt; 标签处理\n  v-pre 指令处理\n  自闭合标签处理\n  组装元素结构 NodeTypes.ELEMENT\n   测试：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  const { baseParse } = require(process.env.PWD + \u0026#39;/../../static/js/vue/compiler-core.global.js\u0026#39;) let ast = baseParse(`\u0026lt;div\u0026gt;\u0026lt;/div\u0026gt;`) console.log(`\u0026gt;\u0026gt;\u0026gt; 普通标签`) console.log(ast.children[0]) ast = baseParse(`\u0026lt;img/\u0026gt;`) console.log(`\u0026gt;\u0026gt;\u0026gt; 自闭合标签`) console.log(ast.children[0]) console.log(`\u0026gt;\u0026gt;\u0026gt; 自定义空标签 \u0026lt;mydiv\u0026gt;`) ast = baseParse(`\u0026lt;mydiv\u0026gt;`, { isVoidTag: () =\u0026gt; `mydiv` }) console.log(ast.children[0])     +RESULTS: 省略部分输出\n\u0026gt;\u0026gt;\u0026gt; 普通标签 { type: 1, ns: 0, tag: \u0026#39;div\u0026#39;, tagType: 0, props: [], isSelfClosing: false, children: [], } \u0026gt;\u0026gt;\u0026gt; 自闭合标签 { type: 1, ns: 0, tag: \u0026#39;img\u0026#39;, tagType: 0, props: [], isSelfClosing: true, children: [], } \u0026gt;\u0026gt;\u0026gt; 自定义空标签 \u0026lt;mydiv\u0026gt; { type: 1, ns: 0, tag: \u0026#39;mydiv\u0026#39;, tagType: 0, props: [], isSelfClosing: false, children: [], }    bf28a36 add tag parser of tag type   feat(add): parse tag for tag type · gcclll/stb-vue-next@bf28a36\n 解析出标签的标签名(component ? template ? slot ? …)。\n  if (options.isNativeTag \u0026amp;\u0026amp; !hasVIs)\n !options.isNativeTag(tag) 如果不是原生标签，则视为 COMPONENT\n  第二种为 COMPONENT 情况\n1 2 3 4 5 6 7  else if ( hasVIs || isCoreComponent(tag) || (options.isBuiltInComponent \u0026amp;\u0026amp; options.isBuiltInComponent(tag)) || /^[A-Z].test(tag)/ || tag === \u0026#39;component\u0026#39; )      有 v-is 指令\n  isCoreComponent() vue 内置标签(Teleport, Suspense, KeepAlive, BaseTransition)\n  选项中自定义的\n  标签名首字母大写的也视为 component\n  标签名直接是 component 的\n    if (tag === \u0026#39;slot\u0026#39;) 插槽标签\n  \u0026lt;template\u0026gt; 标签，且带有指令\n1 2 3 4 5 6  tag === \u0026#39;template\u0026#39; \u0026amp;\u0026amp; props.some(p =\u0026gt; { return ( p.type === NodeTypes.DIRECTIVE \u0026amp;\u0026amp; isSpecialTemplateDirective(p.name) ) })     特殊的模板指令：\n1 2 3  const isSpecialTemplateDirective = /*#__PURE__*/ makeMap( `if,else,else-if,for,slot` )      这个由于需要用到属性，所以需要结合 parseAttributes 实现才能进行测试。\n  73fd01f add attribute name and value parser   feat(add): attribute name and value parser · gcclll/stb-vue-next@73fd01f\n 这里新增了三个函数(代码较多，需要查看源码直接点击上面 commit 链接)\n  parseAttributes(context, type) 属性解析入口，通过 while 循环解析出所有属性\n  parseAttribute(context, nameSet) 解析单个属性，属性名用 nameSet 集合存储避 免重复\n  parseAttributeValue(context) 解析属性值\n  测试：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  const { baseParse } = require(process.env.PWD + \u0026#39;/../../static/js/vue/compiler-core.global.js\u0026#39;) const ast = baseParse(`\u0026lt;div class=\u0026#34;app\u0026#34; :staticPropName=\u0026#34;bar\u0026#34; @press.enter=\u0026#34;pressKey\u0026#34; :[dynamicPropName]=\u0026#34;foo\u0026#34;\u0026gt;\u0026lt;/div\u0026gt;`) const ele = ast.children[0] console.log(ele) console.log(`\u0026gt;\u0026gt;\u0026gt; 静态属性：class`) console.log(ele.props[0]) console.log(`\u0026gt;\u0026gt;\u0026gt; 动态属性静态属性名：staticPropName`) console.log(ele.props[1]) console.log(`\u0026gt;\u0026gt;\u0026gt; 带修饰符的属性：press.enter`) console.log(ele.props[2]) console.log(`\u0026gt;\u0026gt;\u0026gt; 动态属性名：dynamicPropName`) console.log(ele.props[3])     +RESULTS: 元素结构\n{ type: 1, ns: 0, tag: \u0026#39;div\u0026#39;, tagType: 1, props: [...], // 如下 isSelfClosing: false, children: [], }   +RESULTS: 属性列表， 省略 loc 位置数据\n\u0026gt;\u0026gt;\u0026gt; 静态属性：class { type: 6, name: \u0026#39;class\u0026#39;, value: { type: 2, content: \u0026#39;app\u0026#39;, } } \u0026gt;\u0026gt;\u0026gt; 动态属性静态属性名：staticPropName { type: 7, name: \u0026#39;bind\u0026#39;, exp: { type: 4, content: \u0026#39;bar\u0026#39;, isStatic: false, isConstant: false, }, arg: { type: 4, content: \u0026#39;staticPropName\u0026#39;, isStatic: true, isConstant: true, }, modifiers: [], } \u0026gt;\u0026gt;\u0026gt; 带修饰符的属性：press.enter { type: 7, name: \u0026#39;on\u0026#39;, exp: { type: 4, content: \u0026#39;pressKey\u0026#39;, isStatic: false, isConstant: false, }, arg: { type: 4, content: \u0026#39;press\u0026#39;, isStatic: true, isConstant: true, }, modifiers: [ \u0026#39;enter\u0026#39; ], } \u0026gt;\u0026gt;\u0026gt; 动态属性名：dynamicPropName { type: 7, name: \u0026#39;bind\u0026#39;, exp: { type: 4, content: \u0026#39;foo\u0026#39;, isStatic: false, isConstant: false, }, arg: { type: 4, content: \u0026#39;dynamicPropName\u0026#39;, isStatic: false, isConstant: false, }, modifiers: [], }    e32401e add combine whitespace nodes   feat(add): combine whitespace node · gcclll/stb-vue-next@e32401e\n 合并删除空行或空字符串节点。\n1 2 3 4 5 6 7 8 9 10  const { baseParse } = require(process.env.PWD + \u0026#39;/../../static/js/vue/compiler-core.global.js\u0026#39;) const ast = baseParse(` \u0026lt;div\u0026gt; some text other text \u0026lt;/div\u0026gt;`) console.log(ast.children[0].children[0])     +RESULTS: 正确结果\n{ type: 2, content: \u0026#39; some text other text \u0026#39;, loc: { start: { column: 6, line: 2, offset: 6 }, end: { column: 1, line: 5, offset: 28 }, source: \u0026#39;\\nsome text\\nother text\\n\u0026#39; } }   +RESULTS: \u0026#39;sometextothertext\u0026#39; 空格都被删了？ fix: all whitespce removed · gcclll/stb-vue-next@bb31509\n{ type: 1, ns: 0, tag: \u0026#39;div\u0026#39;, tagType: 1, props: [], isSelfClosing: false, children: [ { type: 2, content: \u0026#39;sometextothertext\u0026#39;, loc: [Object] } ], loc: { start: { column: 1, line: 2, offset: 1 }, end: { column: 7, line: 5, offset: 34 }, source: \u0026#39;\u0026lt;div\u0026gt;\\nsome text\\nother text\\n\u0026lt;/div\u0026gt;\u0026#39; }, codegenNode: undefined } undefined   +RESULTS: children = [] ? fix: no children · gcclll/stb-vue-next@66936f3\n{ type: 1, ns: 0, tag: \u0026#39;div\u0026#39;, tagType: 1, props: [], isSelfClosing: false, children: [], loc: { start: { column: 1, line: 2, offset: 1 }, end: { column: 7, line: 5, offset: 34 }, source: \u0026#39;\u0026lt;div\u0026gt;\\nsome text\\nother text\\n\u0026lt;/div\u0026gt;\u0026#39; }, codegenNode: undefined } undefined    用例测试   \u0026lt;f12\u0026gt; 打开控制台有惊喜哦╰(°▽°)╯ 👀👀👀👀👀👀👀👀。\n 下面章节所有测试都是根据官方测试用例进行的：parse.spec.ts\n try { let i = 0, j = 0 const { baseParse } = VueCompilerCore const l1 = x = console.log(`%c  ${++i} ${x}`, 'background: #222; color: #bada55') const l2 = x = console.log(`%c  ${i}.${j++} ${x}`, 'background: #222; color: #bada55') const log = (args) = console.log.apply(console, args) const parse = (content, option = {}) = log(baseParse(content, { onError: (e) = console.warn(e.message), ...option }).children) l1('Text, 文本测试') l2(`无效的结束标签(\"some text\")。`) parse(`some text`) l2(`插值解析(\"some {{ foo + bar }} text\")`) parse(`some {{ foo + bar }} text`) l2(`表达式包含 符号的差值(\"some {{ ad }} text\")`) log(['插值内的内容都会以 {{ 开始 }} 结束直接截取作为 content，所以这里面的 都是合法的存在']) parse(`some {{ ad }} text`) l2(`标签 + 插值混合(\"some {{ foo \")`) parse(`some {{ foo `) l2(`单个 d }}`) parse(`{{ ad }}`) l2(`插值内部允许存在一些符合法标签('{{ \"\" }}')`) parse(`{{ \"\" }}`) l2(`可以自定义插值分隔符，如：\"{\" 和 \"}\"`) parse(`{msg}\n`, { delimiters: ['{', '}'] }) j = 0 l1(`Comment, 注释`) l2(`空注释(\"\")`) parse(``) l2(`简单注释(\"\")`) parse(``) l2(`两个注释(\"\")`) parse(``) l2(`生成模式下  中的注释应该被删除(\"\")`) parse(``) j = 0 l1(`Element, 普通标签`) l2(`simple div(\"hello\")`) parse(`hello`) l2(`empty div(\"\")`) parse(``) l2(`自闭合标签(\"after\")`) parse(`after`) l2(`空标签(\"after\")`) parse(`after`, { isVoidTag: tag = tag === 'img' }) l2(`带指令的 (\"\")`) parse(``) l2(`不带指令的 (\"\")`) parse(``) l2(`原生标签(\"\")`) parse(``, { isNativeTag: tag = tag === 'div' }) l2(`v-is with \"isNativeTag\"(\"\")`) parse(``, { isNativeTag: tag = tag === 'div' }) l2(`v-is without \"isNativeTag\"(\"\")`) parse(``) l2(`自定义元素(\"\")`) log([`自定义元素的类型为 0,ELEMENT`]) parse(``, { isNativeTag: tag = tag === 'div', isCustomElement: tag = tag === 'comp' }) l2(`内置组件(\"\")`) parse(``, { isBuiltInComponent: tag = (tag === 'comp' ? Symbol() : void 0) }) l2(`插槽元素(\"\")`) parse(``) l2(`没有值的属性(\"\")`) parse(``) l2(`空值属性，双引号(\"\")`) parse(``) l2(`空值属性，单引号(\"\")`) parse(``) l2(`有值属性，双引号(\"\\'\"\")`) parse(`\\'\"`) l2(`有值属性，单引号(\"\\\"'\")`) parse(`\\\"'`) l2(`有值属性，没有引号(\"\")`) log([`没有引号的情况，属性值会解析到 \"\" 符号结束`]) parse(``) l2(`多个属性(\"\")`) parse(``) l2(`无值指令(\"\")`) parse(``) l2(`有值指令(\"\")`) log([`有值指令，值会解析到属性表达式上 prop.exp = {...}`]) parse(``) l2(`有参数指令(\"\")`) log([`参数会被解析到 prop.arg 上，isStatic = isConstant = true`]) parse(``) l2(`有动态参数指令(\"\")`) log([`参数会被解析到 prop.arg 上， isStatic = isConstant = false`]) parse(``) l2(`带修饰符的指令(\"\")`) log([`修饰符会被解析到 prop.modifiers = [ 'enter' ] 中`]) parse(``) l2(`两个修饰符的指令(\"\")`) log([`修饰符会被解析到 prop.modifiers = [ 'enter', 'exact' ] 中`]) parse(``) l2(`带参数和修饰符的指令(\"\")`) parse(``) l2(`带动态参数和修饰符的指令(\"\")`) parse(``) l2(`v-bind 缩写 \":\"(\"\")`) parse(``) l2(`v-bind 缩写，带修饰符(\"\")`) parse(``) l2(`v-on 缩写(\"\")`) parse(``) l2(`v-on 缩写，带修饰符(\"\")`) parse(``) l2(`v-slot 缩写(\"\")`) parse(``) l2(`v-slot 包含点语法的(\"\")`) parse(``) l2(`v-pre 指令`) log([ `{{ bar }}\\n` + `{{ bar }}` ]) parse( `{{ bar }}\\n` + `{{ bar }}` ) l2(`结束标签大小写不敏感(\"helloafter\")`) parse(`helloafter`) j = 0 l1(`其他情况`) l2(`自闭合标签(\"\")`) parse(``) l2(`多个自闭合标签`) log([ `\\n` + `` ]) parse( `\\n` + `` ) l2(`复合类型标签组合`) log([ `\\n` + ` \\n` + ` inside it --\\n` + `` ]) parse( `\\n` + ` \\n` + ` inside it --\\n` + `` ) l2(`无效的复合类型标签组合(\"\\n\\n\\n\")`) parse(`\\n\\n\\n`) l2(`正确的位置信息`) log([ ` foo is {{ bar }} but {{ baz }}` ]) parse(` foo is {{ bar }} but {{ baz }}` ) j = 0 l1(\"HTML Entities 解码\") l2(`使用默认映射关系(\"\u0026gt;\u0026lt;\u0026amp;\u0026apos;\u0026quot;\u0026foo;\")`) parse(`\u0026gt;\u0026lt;\u0026amp;\u0026apos;\u0026quot;\u0026foo;`) l2(`使用自定义映射关系(\"\u0026amp;\u0026cups;\")`) parse(`\u0026amp;\u0026cups;`, { decodeEntities: text = text.replace('\u0026cups;', '\\u222A\\uFE00') }) j = 0 l1(\"空格管理\") l2(`在标签内的空格应该删除(\"  \")`) parse(`  `) l2(`标签之间的空格和换行符应该删除(\" \\n  \\n \")`) parse(` \\n  \\n `) l2(`与注释相邻的空格应该删除(\" \\n  \")`) parse(` \\n  `) l2(`注释与元素之间的空格应该删除(\" \\n  \\n \")`) parse(` \\n  \\n `) l2(`插值之间的注释不应该删除(\"{{ foo }} \\n {{ bar }}\")`) parse(`{{ foo }} \\n {{ bar }}`) l2(`元素之间的空格不应该删除(\"  \")`) parse(`  `) l2(`文本之间的空格应该合并成一个(\" foo \\n bar baz \")`) parse(' foo \\n bar baz ') l2(` 标签中的首行空格应该删除(\"\\n foo bar \")`) parse(`\\n foo bar `) l2(` 在子元素后面的换行符不该删除(\"\\n foo bar \")`) parse(`\\n foo bar `) j = 0 const err = ( content, info ) = (l2(info ? `${info} (\"${content}\")` : content), parse(content)) l1(`Errors, 错误`) err(``) err(``) err(``) err(``) err(``, \"不能在 HTML 中使用 CDATA\") err(``, \"重复属性\") err(``, \"结束标签上不能有属性\") err(``, \"结束标签最后多了个斜杠'/'\") err(`标签中不能使用 html 注释\") err(`console.log('hello')`, \" 缺少结束标签\") err(``, \"错误注释结束\") err(``, \"错误注释开始 1\") err(``, \"错误注释开始 2\") err(``, \"错误注释开始 3\") err(``, \"忽略 doctype\") err(`a `, \"标签名第一个字符非法 1\") err(``, \"标签名第一个字符非法 2\") err(`a `, \"标签名第一个字符非法 3\") err(``, \"标签名第一个字符非法 4\") err(`{{a `, \"插值里面 `, \"无效的属性名 1\") err(``, \"无效的属性名 2\") err(``, \"无效的属性名 3\") err(``, \"缺少结束标签\") err(``, \"属性之间必须要有空格\") err(``, \"但是可以有 \\r\\n 换行符\") err(``, \"嵌套注释 1\") err(``, \"嵌套注释 2\") err(``, \"嵌套注释 3\") err(``, \"非法注释\") err(``, \"属性名中包含非法字符(\\\") 1\") err(``, \"属性名中包含非法字符(') 2\") err(``, \"属性名中包含非法字符(`, \"没引号属性中的非法字符(\\\")\") err(``, \"没引号属性中的非法字符(\\')\") err(``, \"没引号属性中的非法字符(`, \"没引号属性中的非法字符(=)\") err(``, \"没引号属性中的非法字符(`)\") err(``, \"属性名中的非法字符(=)\") err(``) err(``) err(``, \"无效结束标签\") err(``, \"无效结束标签\") err(`{{''}}`, \"插值中有效\") err(``, \"多行文本中有效\") err(`]]`, \"svg CDATA 中有效\") err(`--`, \"注释中有效\") err(``, \"没有结束标签\") err(``, \"没有结束标签\") err(`{{ foo`, \"非法插值\") err(`{{`, \"非法插值\") err(`{{}}`, \"空插值\") err(``, \"无效指令参数\") } catch (e) { console.log(e.message) console.log('您的浏览器可能不支持 es6+ 新语法，请使用 chrome 浏览。') }  1 2 3 4 5 6 7 8 9 10 11  const { baseParse } = require(process.env.PWD + \u0026#39;/../../static/js/vue/compiler-core.global.js\u0026#39;) const _ = x =\u0026gt; console.log(`\u0026gt;\u0026gt;\u0026gt; ${x}`) const __ = x =\u0026gt; console.log(x) const parse = content =\u0026gt; baseParse(content, { onError: (e) =\u0026gt; console.log(e.message) }) __(parse(`some text`).children[0])     更多测试内容和输出(由于篇幅问题)请查看 \u0026lt;F12\u0026gt; 打开控制台查看。 +RESULTS:\n{ type: 2, content: \u0026#39;some text\u0026#39;, loc: { start: { column: 1, line: 1, offset: 0 }, end: { column: 10, line: 1, offset: 9 }, source: \u0026#39;some text\u0026#39; } } undefined    ","permalink":"https://www.cheng92.com/vue/vue-mind-map-compiler-core-parser/","tags":["vue,","vue3,","compiler-core,","parser,","compiler"],"title":"Vue3 源码头脑风暴之 2 ☞compiler-core - ast parser"},{"categories":["vue"],"contents":"  更新日志\u0026amp;Todos ：\n  DONE [2021-01-20 15:16:45] ref\n    诗号：六道同坠，魔劫万千，引渡如来。  \n  function _log(el, content) { $(el).children('.result').append('' + content + '\n') }     stb-vue-next 完全拷贝于 vue-next ，主要目的学习及尝试应用于机顶盒环境。 \n  本文依据 commit 进程进行记录 \n 所有用例请按 \u0026lt;f12\u0026gt; 打开控制台查看 \u0026gt;\n  let i = 0, j = 0 const l1 = x = (j = 0, console.log(`%c  ${++i} ${x}`, 'background: #222; color: #bada55')) const l2 = x = console.log(`%c  ${i}.${j++} ${x}`, 'background: #222; color: #bada55') const log = (args) = console.log.apply(console, Array.isArray(args) ? args : [args]) log.blue = x = log([`%c ${x}`, `color: blue`]) log.red = x = log([`%c ${x}`, `color: red`]) log.gray = x = log([`%c ${x}`, `color: gray`]) log.blues = xx = xx.forEach(x = log.blue(x)) log.gray.fn = (fn) = (log.gray(fn), fn())   const { reactive, isReactive, expect } = VueReactivity l1(`reactivity/reacitve`) l2(`Object`) log.gray.fn(() = { let original = { foo: 1 } let observed = reactive(original) log.blues([ `observed !== original, ` + (original !== observed), `observed is reactive, ` + isReactive(observed), `original is reactive, ` + isReactive(original), `observed.foo === ` + observed.foo, `\"foo\" in observed, ` + ('foo' in observed), `own keys: ` + Object.keys(observed) ]) }) l2(`proto, 原型响应式`) log.gray.fn(() = { const obj = {} const reactiveObj = reactive(obj) // 属性读取，会导致该属性也变成 reactive const prototype = reactiveObj['__proto__'] const otherObj = { data: ['a'] } log.blues([ `\"reactiveObj\" is reactive, ` + isReactive(reactiveObj), `otherObj is reactive, ` + isReactive(otherObj) , ]) const reactiveOther = reactive(otherObj) log.blues([ `reactiveOther is reactive, ` + isReactive(otherObj), `reactiveOther.data[0] = ` + reactiveOther.data[0] ]) })  关键知识点   计算属性是如何实现结果缓存的？\n    init project   初始化项目：feat: reactive-fn · gcclll/stb-vue-next@cb3470d\n 由于完整脑图会比较全而大所以放到文字最后去。。。\n 也可以点击该链接直接新窗口打开，效果更佳。\n  add: createReactiveObject   feat: reactive-fn · gcclll/stb-vue-next@cb3470d\n  仅增加函数声明:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21  export function reactive(target: object) { // 如果试图 observe 一个只读 proxy，返回只读版本  if (target \u0026amp;\u0026amp; (target as Target)[ReactiveFlags.IS_READONLY]) { return target } return createReactiveObject( target, false, mutableHandlers, {} // mutableCollectionHandlers  ) } function createReactiveObject( target: Target, isReadonly: boolean, baseHandlers: ProxyHandler\u0026lt;any\u0026gt;, collectionHandlers: ProxyHandler\u0026lt;any\u0026gt; ) {}     mutableHandlers: 普通对象类型的 proxy handlers\n mutableCollectionHandlers: 集合类型的 proxy handlers，因为 Reflect 并没有对集 合类型做底层映射，所以需要特殊处理。\n  feat: reactive(target)   feat: createReactiveObject · gcclll/stb-vue-next@443a0b5\n   重点： new Proxy(target, collection)\n  被代理类型必须是对象(引用类型)\n  target 本身已经是 proxy 了\n  target 代理有缓存不用重复创建\n  必须是合法的类型(Object|Array|[Weak]Map|[Weak]Set)才能被代理\n  记得缓存新创建的代理关系(proxyMap 全局变量)\n  用例一：普通对象  1 2 3 4 5 6 7 8 9 10 11  const { effect, reactive, targetMap, isReactive } = require(process.env.PWD + \u0026#39;/../../static/js/vue/reactivity.global.js\u0026#39;) const original = { foo: 1 } const observed = reactive(original) console.log(\u0026#39;observed is not orignial,\u0026#39; + original !== observed) console.log(\u0026#39;observed is reactive, \u0026#39; + isReactive(observed)) console.log(\u0026#39;original is reactive, \u0026#39; + isReactive(original)) console.log(\u0026#39;observed.foo === 1, \u0026#39; + observed.foo === 1) console.log(\u0026#39;`foo` in observed, \u0026#39; + (`foo` in observed)) console.log(`Object.keys(observed) == [\u0026#39;foo\u0026#39;], ` + (Object.keys(observed).toString() === \u0026#39;foo\u0026#39;))     +RESULTS:\ntrue observed is reactive, true original is reactive, false false `foo` in observed, true Object.keys(observed) == [\u0026#39;foo\u0026#39;], true undefined   b2143f9 FIX: isReactive(observed): false\n fix: get object\u0026#39;s __v_isReactive prop · gcclll/stb-vue-next@1005ef3\n 在 createGetter 中增加判断，如果来取的属性为 __v_isReactive 则直接返回 !isReadonly 。\n  用例二：原型  1 2 3 4 5 6 7 8 9 10 11  const { isReactive, effect, reactive, targetMap } = require(process.env.PWD + \u0026#39;/../../static/js/vue/reactivity.global.js\u0026#39;) const obj = {} const reactiveObj = reactive(obj) console.log(\u0026#39;reactiveObj is reactive, \u0026#39; + isReactive(reactiveObj)) const prototype = reactiveObj[\u0026#39;__proto__\u0026#39;] const otherObj = { data: [\u0026#39;a\u0026#39;] } console.log(\u0026#39;otherObj is reactive, \u0026#39; + isReactive(otherObj)) const reactiveOther = reactive(otherObj) console.log(\u0026#39;reactiveOther is reactive, \u0026#39; + isReactive(reactiveOther)) console.log(\u0026#39;reactiveOther.data[0] is `a`, \u0026#39; + ( reactiveOther.data[0] === \u0026#39;a\u0026#39; )) console.log(`__proto__, ` + prototype)     +RESULTS:\nreactiveObj is reactive, true otherObj is reactive, false reactiveOther is reactive, true reactiveOther.data[0] is `a`, true __proto__, [object Object] undefined   FIX: 1005ef3 当取值时属性名为 __proto__ 时：直接返回取值结果。\n feat: get key is symbol or proto or __v_isRef · gcclll/stb-vue-next@1e2a3fe\n  用例三：嵌套对象  1 2 3 4 5 6 7 8 9 10 11 12  const {isReactive, effect, reactive, targetMap } = require(process.env.PWD + \u0026#39;/../../static/js/vue/reactivity.global.js\u0026#39;) const original = { nested: { foo: 1 }, array: [{ bar: 2 }] } const observed = reactive(original) console.log(`observed.nested is reactive ${isReactive(observed.nested)}`) console.log(`observed.array is reactive ${isReactive(observed.array)}`) console.log(`observed.array[0] is reactive ${isReactive(observed.array[0])}`)     +RESULTS:\nobserved.nested is reactive true observed.array is reactive true observed.array[0] is reactive true    用例四：代理后的对象操作也会体现在原对象上  1 2 3 4 5 6 7 8 9  const { isReactive, effect, reactive, targetMap } = require(process.env.PWD + \u0026#39;/../../static/js/vue/reactivity.global.js\u0026#39;) const or = { foo: 1 } const ob = reactive(or) ob.bar = 1 console.log(`ob.bar = ${ob.bar}, or.bar = ${or.bar}`) delete ob.foo console.log(`\u0026#39;foo\u0026#39; in ob: ${\u0026#39;foo\u0026#39; in ob}, \u0026#39;foo\u0026#39; in or: ${\u0026#39;foo\u0026#39; in or}`)     +RESULTS:\nob.bar = 1, or.bar = 1 \u0026#39;foo\u0026#39; in ob: false, \u0026#39;foo\u0026#39; in or: false   结果删除后，依旧在，需要实现 delete proxy handler。\n  用例五：原始对象上的操作也要能在代理后对象有所体现  1 2 3 4 5 6 7 8 9  const { isReactive, effect, reactive, targetMap } = require(process.env.PWD + \u0026#39;/../../static/js/vue/reactivity.global.js\u0026#39;) const original = { foo: 1 } const observed = reactive(original) original.bar = 1 console.log(`observed.bar = ${observed.bar}, original.bar = ${original.bar}`) delete original.foo console.log(`\u0026#39;foo\u0026#39; in original: ${\u0026#39;foo\u0026#39; in original}, \u0026#39;foo\u0026#39; in observed: ${\u0026#39;foo\u0026#39; in observed}`)     +RESULTS:\nobserved.bar = 1, original.bar = 1 \u0026#39;foo\u0026#39; in original: false, \u0026#39;foo\u0026#39; in observed: false    用例六：被设置的值如果是对象，该对象也会被 Reactive  1 2 3 4 5 6 7  const { isReactive, effect, reactive, targetMap } = require(process.env.PWD + \u0026#39;/../../static/js/vue/reactivity.global.js\u0026#39;) const observed = reactive({}) const raw = {} observed.foo = raw // #0 console.log(`observed.foo === faw, ${observed.foo === raw}`) // #1 console.log(`observed.foo is reactive, ${isReactive(observed.foo)}`)     +RESULTS:\nobserved.foo === faw, false observed.foo is reactive, true   访问 raw 之前(#1 之前)它还不是 reactive，因为递归 reactive 发生在 track() 中，即取值阶段。\n 如：控制台测试输出\nvar ob = reactive({}) var raw = {} ob.foo = raw ob Proxy {foo: {…}} [[Handler]]: Object deleteProperty: ƒ deleteProperty(target, key) get: ƒ (target, key, receiver) set: ƒ (target, key, value, receiver) [[Target]]: Object foo: {} // 注意这里 [[IsRevoked]]: false   进行一次取值：\nob.foo Proxy {} [[Handler]]: Object [[Target]]: Object [[IsRevoked]]: false    用例七：不该重复 proxy，返回第一个 proxy 结果  1 2 3 4 5 6  const { isReactive, effect, reactive, targetMap } = require(process.env.PWD + \u0026#39;/../../static/js/vue/reactivity.global.js\u0026#39;) const original = { foo: 1 } // #1 const observed1 = reactive(original) // #2 const observed2 = reactive(observed1) // #3 console.log(`observed2 === observed1, ${observed2 === observed1}`)    observed2 === observed1, true undefined   因为 reactive() 实现中组了检测，如果自身是个 proxy 就直接返回，所以 #3 中实 际直接将 observed1 返回了。\n  TODO 用例八：不应该用 proxies 污染原始对象？  1 2 3 4 5 6 7 8 9  const { isReactive, effect, reactive, targetMap } = require(process.env.PWD + \u0026#39;/../../static/js/vue/reactivity.global.js\u0026#39;) const original = { foo: 1 } const original2 = { bar: 2 } const observed = reactive(original) const observed2 = reactive(original2) observed.bar = observed2 console.log(`observed.bar === observed2, ${observed.bar === observed2}`) console.log(`original.bar === original2, ${original.bar === original2}`)     +RESULTS:\nobserved.bar === observed2, true original.bar === original2, false      basic proxy get handler(createGetter)   feat: reactive proxy get handler · gcclll/stb-vue-next@598e047\n commit: 只实现对象的 get proxy handler ，对象属性被访问的时候会触发代理，比如下面 实例中，当访问 observed.count 时候会触发 console.log({ res }, \u0026#34;get\u0026#34;) 执行。\n 最简单 proxy get handler 脑图：   调用 Reflect.get(target, key, receiver) 执行原子操作\n  返回执行结果\n  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  function createGetter(isReadonly = false, shallow = false) { // target: 被取值的对象，key: 取值的属性，receiver: this 的值  return function get(target: Target, key: string | symbol, receiver: object) { const res = Reflect.get(target, key, receiver) // 是否只需要 reactive 一级属性(不递归 reactive)  if (shallow) { return res } return res } } export const mutableHandlers: ProxyHandler\u0026lt;object\u0026gt; = { get }     测试：\n1 2 3 4 5 6 7  const { effect, reactive, targetMap } = require(process.env.PWD + \u0026#39;/../../static/js/vue/reactivity.global.js\u0026#39;) const target = { count: 0 } const ob = reactive(target) effect(() =\u0026gt; ob.count) // ob.count 属性 收集 effect fn  console.log(targetMap.get(target))     +RESULTS: effect 会立即执行 fn， ob.count 取值触发 get proxy 收集 fn -\u0026gt; count =\u0026gt; deps\u0026lt;Set\u0026gt;\nMap(1) { \u0026#39;count\u0026#39; =\u0026gt; Set(1) { [Function: reactiveEffect] { id: 0, allowRecurse: false, _isEffect: true, active: true, raw: [Function (anonymous)], deps: [Array], options: {} } } }    add track() and effect()   feat: track+effect · gcclll/stb-vue-next@3fc9634\n 为了完成观察属性，通过属性的取值操作来收集依赖过程，这里同时实现了 track() 和 effect() 函数。\ntrack(target, type, key) 监听取值收集依赖：   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32  export function track(target: object, type: TrackOpTypes, key: unknown) { if (!shouldTrack || activeEffect === undefined) { return; } // Map\u0026lt; obj -\u0026gt; Map\u0026lt;key, Set[...deps]\u0026gt; \u0026gt;  let depsMap = targetMap.get(target); if (!depsMap) { // 初始化  targetMap.set(target, (depsMap = new Map())); } let dep = depsMap.get(key); if (!dep) { depsMap.set(key, (dep = new Set())); } // 正在请求收集的 effect ，是初次出现  if (!dep.has(activeEffect)) { dep.add(activeEffect); // 自身保存一份被依赖者名单  activeEffect.deps.push(dep); if (__DEV__ \u0026amp;\u0026amp; activeEffect.options.onTrack) { activeEffect.options.onTrack({ effect: activeEffect, target, type, key, }); } } }      effect(fn, options)     参数列表 ：\n fn - 被封装的函数，里面可对对象执行 get/set 操作。\n  主要功能 ：将 fn 封装成 ReactiveEffect 函数\n1 2 3 4 5 6 7 8 9 10  export interface ReactiveEffect\u0026lt;T = any\u0026gt; { (): T // effect函数主题  _isEffect: true // 标记自身是不是一个 ReactiveEffect 类型  id: number // uid++ 而来，全局的一个相对唯一的 id  active: boolean // 记录当前的 effect 是不是激活状态  raw: () =\u0026gt; T // 封装之前的那个 fn  deps: Array\u0026lt;Dep\u0026gt; // fn 的被依赖者列表  options: ReactiveEffectOptions // 额外选项，如：lazy  allowRecurse: boolean // ??? }      解决问题 :\n  fn 封装之后，执行 fn 过程中使用 try…finally ，防止 fn 执行异常导致 effect 进程中断\n  结合 shouldTrack, activeEffect 和 track() 函数，有效的避免了在 fn 中执行 obj.value++ 导致 effect 死循环问题，因为 try…finally 确保了只有 fn 函数 完成之后才会进入 finally 恢复 effect 状态(shouldTrack = true, activeEffect = last || null)。\n     相关函数及变量列表\n   name type desc     activeEffect ReactiveEffect 当前正在处理的 Effect，fn 还未执行完成，finally 还没结束   effectStack Array, [] 缓存所有状态还没完成的 Effect   shouldTrack boolean, true track() 中用来检测当前 effect 是否结束，从而判定是否可以继续执行 track() 收集依赖   trackStack Array, [] 保存着所有 Effect 的 shouldTrack 值   effect() function 封装 fn成 ReactiveEffect 结构   track(target, type, key) function 收集依赖，并且响应式递归   trigger(...) function 当值更新时触发所有依赖更新   createReactiveEffect(fn, options) function effect() 函数主题功能分离出来   cleanup(effect: ReactiveEffect) function 清空所有 fn 的依赖 effect.deps[]   enableTracking() function 使能 Effect ，shouldTrack = true, 并将其加入 trackStack   resetTracking() function 重置 Effect, shouldTrack = 上一个 Effect 的 shouldTrack 值或 true    1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69  export function effect\u0026lt;T = any\u0026gt;( fn: () =\u0026gt; T, options: ReactiveEffectOptions = EMPTY_OBJ ): ReactiveEffect\u0026lt;T\u0026gt; { if (isEffect(fn)) { fn = fn.raw // 取出原始的函数，封装之前的  } // 封装成 ReactiveEffect  const effect = createReactiveEffect(fn, options) if (!options.lazy) { // 如果并没指定 lazy: true 选项，则立即执行 effect 收集依赖  // 因为 effect 一般都会有取值操作，此时会触发 proxy get handler  // 然后执行 track() 结合当前的 activeEffect 即 effect() 执行时候的这个  // effect，这样取值操作就和当前取值作用域下的依赖函数建立的依赖关系  effect() } return effect } let uid = 0 function createReactiveEffect\u0026lt;T = any\u0026gt;( fn: () =\u0026gt; T, options: ReactiveEffectOptions ): ReactiveEffect\u0026lt;T\u0026gt; { // 将 fn 执行封装成 ReactiveEffect 类型的函数  const effect = function reactiveEffect(): unknown { if (!effect.active) { // 非激活状态，可能是手动调用了 stop  // 那么执行的时候就需要考虑调用 stop 者是否提供了手动调度该 effect  // 的函数 scheduler ? 也就是说你停止你可以重新启动  return options.scheduler ? undefined : fn() } if (!effectStack.includes(effect)) { // 1. cleanup, 保持纯净  cleanup(effect) try { // 2. 使其 tracking 状态有效，track() 中有用  enableTracking() // track() 可以执行收集操作  effectStack.push(effect) // effect 入栈  // 3. 保存为当前的 activeEffect, track() 中有用  activeEffect = effect // 记录当前的 effect -\u0026gt; track/trigger  // 4. 执行 fn 并返回结果  return fn() // 返回执行结果  } finally { // 始终都会执行，避免出现异常将 effect 进程卡死  // 5. 如果执行异常，丢弃当前的 effect ，并将状态重置为上一个 effect  // 由一个 effect 栈来维护。  effectStack.pop() resetTracking() activeEffect = effectStack[effectStack.length - 1] } } } as ReactiveEffect effect.id = uid++ effect.allowRecurse = !!options.allowRecurse effect._isEffect = true effect.active = true effect.raw = fn // 这里保存原始函数引用  effect.deps = [] effect.options = options return effect }     依赖和属性变更发生联系的桥梁模块。\n  effect(fn, options) 封装执行 fn，触发取值操作 -\u0026gt;\n  track(target, type, key) 收集对象及属性所有依赖 -\u0026gt;\n  fn 中设值操作触发 trigger(...) 执行所有 deps，更新 DOM。\n      add trigger() proxy set handler   feat: proxy set and trigger operation · gcclll/stb-vue-next@20afde9\nproxy set handler(createSetter)  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29  function createSetter(shallow = false) { return function set( target: object, key: string | symbol, value: unknown, receiver: object ): boolean { const oldValue = (target as any)[key] // TODO shallow or not, or ref ?  //  const hadKey = isArray(target) \u0026amp;\u0026amp; isIntegerKey(key) ? Number(key) \u0026lt; target.length : hasOwn(target, key) const result = Reflect.set(target, key, value, receiver) if (target === toRaw(receiver)) { if (!hadKey) { // TODO ADD  } else if (hasChanged(value, oldValue)) { trigger(target, TriggerOpTypes.SET, key, value, oldValue) } } return result }      trigger()  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59  export function trigger( target: object, type: TriggerOpTypes, key?: unknown, newValue?: unknown, oldValue?: unknown, oldTarget?: Map\u0026lt;unknown, unknown\u0026gt; | Set\u0026lt;unknown\u0026gt; ) { const depsMap = targetMap.get(target) if (!depsMap) { return } const effects = new Set\u0026lt;ReactiveEffect\u0026gt;() const add = (effectsToAdd: Set\u0026lt;ReactiveEffect\u0026gt; | undefined) =\u0026gt; { if (effectsToAdd) { effectsToAdd.forEach(effect =\u0026gt; { if (effect !== activeEffect || effect.allowRecurse) { effects.add(effect) } }) } } if (type === TriggerOpTypes.CLEAR) { // TODO collection clear operation  } else if (key === \u0026#39;length\u0026#39; \u0026amp;\u0026amp; isArray(target)) { // TODO array change operation  } else { // SET | ADD | DELETE operation  if (key !== void 0) { add(depsMap.get(key)) } // TODO 迭代器 key，for...of, 使用迭代器是对数据的监听变化  } const run = (effect: ReactiveEffect) =\u0026gt; { if (__DEV__ \u0026amp;\u0026amp; effect.options.onTrigger) { effect.options.onTrigger({ effect, target, key, type, newValue, oldValue, oldTarget }) } if (effect.options.scheduler) { effect.options.scheduler(effect) } else { effect() } } effects.forEach(run) }        observe object recursively   feat: observe object recursively · gcclll/stb-vue-next@b2143f9\n 针对嵌套对象进行递归 Reactive 。\n   effect -\u0026gt; track -\u0026gt; trigger 关系图   到此 effect + track + trigger 完成了最简单的响应式代码。\n   effect 封装注册函数\n  track 取值触发收集依赖函数\n  trigger 设值触发所有依赖函数执行\n    add delete(deleteProperty) proxy handler   feat: delete proxy handler · gcclll/stb-vue-next@05b98c5\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  function deleteProperty(target: object, key: string | symbol): boolean { const hadKey = hasOwn(target, key) const oldValue = (target as any)[key] const result = Reflect.deleteProperty(target, key) if (result \u0026amp;\u0026amp; hadKey) { // 删除成功，触发 DELETE  trigger(target, TriggerOpTypes.DELETE, key, undefined, oldValue) } return result } export const mutableHandlers: ProxyHandler\u0026lt;object\u0026gt; = { get,\tget, set\tset, deleteProperty }     删除成功调用 trigger() 触发 DELETE 。\n  add has, ownKeys proxy handlers   feat: has + ownKeys proxy handler · gcclll/stb-vue-next@ab69fe9\n 增加 has, ownKeys proxy handlers.\n1 2 3 4 5 6 7 8 9 10 11 12  function has(target: object, key: string | symbol): boolean { const result = Reflect.has(target, key) if (!isSymbol(key) || !builtInSymbols.has(key)) { track(target, TrackOpTypes.HAS, key) } return result } function ownKeys(target: object): (string | num | symbol)[] { track(target, TrackOpTypes.ITERATE, isArray(target) ? \u0026#39;length\u0026#39; : ITERATE_KEY) return Reflect.ownKeys(target) }     测试：\n1 2 3 4 5 6 7 8 9  const { isReactive, effect, reactive, targetMap } = require(process.env.PWD + \u0026#39;/../../static/js/vue/reactivity.global.js\u0026#39;) const obj = reactive({ n: 0 }) let dummy = false const runner = effect(() =\u0026gt; (dummy = \u0026#39;n\u0026#39; in obj), { lazy: true }) console.log(`before run effect, dummy = ${dummy}`) runner() console.log(`after run effect, dummy = ${dummy}`)     +RESULTS:\nbefore run effect, dummy = false after run effect, dummy = true    TODO add array support   feat: array support · gcclll/stb-vue-next@9aeb678\n 修改点：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38  // 数组内置方法处理 const arrayInstrumentations: Record\u0026lt;string, Function\u0026gt; = {} ;([\u0026#39;includes\u0026#39;, \u0026#39;indexOf\u0026#39;, \u0026#39;lastIndexOf\u0026#39;] as const).forEach(key =\u0026gt; { const method = Array.prototype[key] as any arrayInstrumentations[key] = function(this: unknown[], ...args: unknown[]) { const arr = toRaw(this) for (let i = 0, l = this.length; i \u0026lt; l; i++) { track(arr, TrackOpTypes.GET, i + \u0026#39;\u0026#39;) } const res = method.apply(arr, args) if (res === -1 || res === false) { return method.apply(arr, args.map(toRaw)) } else { return res } } }) ;([\u0026#39;push\u0026#39;, \u0026#39;pop\u0026#39;, \u0026#39;shift\u0026#39;, \u0026#39;unshift\u0026#39;, \u0026#39;splice\u0026#39;] as const).forEach(key =\u0026gt; { const method = Array.prototype[key] as any arrayInstrumentations[key] = function(this: unknown[], ...args: unknown[]) { pauseTracking() const res = method.apply(this, args) resetTracking() return res } }) // createGetter function createGetter(isReadonly = false, shallow = false) { // ...  // 4. target is array  const targetIsArray = isArray(target) if (targetIsArray \u0026amp;\u0026amp; hasOwn(arrayInstrumentations, key)) { return Reflect.get(arrayInstrumentations, key, receiver) } // ... }      索引操作(includes, lastIndexOf, indexOf)处理\n 确保索引取值的时候，能使用 track() 正确收集对应索引的依赖列表。\n  可改变原数组长度操作(push, pop, shift, unshift, splice)\n 因为这些函数内部实现都需要访问及改变原数组的长度，因此这里需要做一层保护，它 们执行之前 shouldTrack = false ，执行完成之后 shouldTrack = true ，避免 track() 死循环。\n   下面均为 vue-next 源码中用例分析。\n T1: 读写操作\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25  const { isReactive, effect, reactive, targetMap } = require(process.env.PWD + \u0026#39;/../../static/js/vue/reactivity.global.js\u0026#39;) const original = [{ foo: 1 }, { bar: 2 }] const observed = reactive(original) console.log(`#01 original !== observed, ${original !== observed}`) console.log(`#02 original is reactive, ${isReactive(original)}`) console.log(`#03 observed is reactive, ${isReactive(observed)}`) console.log(`#04 observed[0] is reactive, ${isReactive(observed[0])}`) const clone = observed.slice() console.log(`#05 clone[0] is reactive, ${isReactive(clone[0])}`) console.log(`#06 clone[0] !== original[0], ${clone[0] !== original[0]}`) console.log(`#07 clone[0] === observed[0], ${clone[0] === observed[0]}`) const value = { baz: 3 } const reactiveValue = reactive(value) observed[0] = value console.log(`#08 observed[0] === reactiveValue, ${observed[0] === reactiveValue}`) console.log(`#09 original[0] === value, ${original[0] === value}`) delete observed[0] console.log(`#10 observed[0] === undefined, ${observed[0] === undefined}`) console.log(`#11 original[0] === undefined, ${original[0] === undefined}`) observed.push(value) console.log(`#12 observed[2] === reactiveValue, ${observed[2] === reactiveValue}`) console.log(`#13 original[2] === value, ${original[2] === value}`)     +RESULTS:\n#01 original !== observed, true #02 original is reactive, false #03 observed is reactive, true #04 observed[0] is reactive, true #05 clone[0] is reactive, true #06 clone[0] !== original[0], true #07 clone[0] === observed[0], true #08 observed[0] === reactiveValue, true #09 original[0] === value, true #10 observed[0] === undefined, true #11 original[0] === undefined, true #12 observed[2] === reactiveValue, true #13 original[2] === value, true   分析：\n  #01 因为 Proxy 内部实现实际会创建新对象\n  #02 读取 __v_isReactive 在 createGetter() 里面会直接返回 !isReadonly\n  #03 同上\n  #04 取值的时候返回结果之前会检测当前是不是对象如果是会执行递归 reactive\n  #05 slice 实现过程并非深拷贝\n  #06 和 observed[0] !== original[0] 一个原因\n  #07 浅拷贝问题\n  #08 先 observed[0] 对 value 取值操作，此时 Reactive value 对象时，发现该对\n  象已经有映射了(proxyMap 中已存在 value -\u0026gt; reactiveValue 关系。)\n  #09 proxy 的改变也会体现在 original 对象上。\n1 2 3 4  const target = { } const ob = new Proxy(target, {}) ob.value = { test: 1 } console.log(target)     +RESULTS:\n{ value: { test: 1 } }    #10 同上\n  #11 同上\n  #12 同 #08 proxyMap 中有缓存了\n  #13 同上\n   T2：索引方法(includes, lastIndexOf, indexOf)\n1 2 3 4 5 6 7 8 9 10 11  const { isReactive, effect, reactive, targetMap } = require(process.env.PWD + \u0026#39;/../../static/js/vue/reactivity.global.js\u0026#39;) const raw = {} const arr = reactive([{}, {}]) arr.push(raw) console.log(`arr.indexOf(raw), ${arr.indexOf(raw)}`) console.log(`arr.indexOf(raw, 3), ${arr.indexOf(raw, 3)}`) console.log(`arr.includes(raw), ${arr.includes(raw)}`) console.log(`arr.includes(raw, 3), ${arr.includes(raw, 3)}`) console.log(`arr.lastIndexOf(raw), ${arr.lastIndexOf(raw)}`) console.log(`arr.lastIndexOf(raw, 1), ${arr.lastIndexOf(raw, 1)}`)     +RESULTS:\narr.indexOf(raw), 2 arr.indexOf(raw, 3), -1 arr.includes(raw), true arr.includes(raw, 3), false arr.lastIndexOf(raw), 2 arr.lastIndexOf(raw, 1), -1   T3：数组元素本身已经是 Proxy\n1 2 3 4 5 6  const { isReactive, effect, reactive, targetMap } = require(process.env.PWD + \u0026#39;/../../static/js/vue/reactivity.global.js\u0026#39;) const raw = [] const obj = reactive({}) raw.push(obj) const arr = reactive(raw) console.log(`arr.includes(obj), ${arr.includes(obj)}`)     +RESULTS: 这个应该很好理解，对象已经是 proxy 之后不会再继续代理，而是返回 proxyMap 中缓存过的代理结果。\narr.includes(obj), true   T4: reverse 方法也应该是 reactive 的\n TODO: reverse 之后找不到(indexOf)原始对象了？\n 根据 reverse() 的实现原理，本质上是元素之间的替换操作，因此并不会改变数组或元 素本身是 proxy 性质，且属于索引赋值操作，因此会触发索引的 reactive 相关操作。\n1 2 3 4 5 6 7 8 9 10 11  const { isReactive, effect, reactive, targetMap, toRaw } = require(process.env.PWD + \u0026#39;/../../static/js/vue/reactivity.global.js\u0026#39;) const obj = { a: 1 } const arr = reactive([obj, { b: 2 }]) let index = -1 console.log(`#1 obj === arr[0], ${obj === toRaw(arr[0])}`) effect(() =\u0026gt; (index = arr.indexOf(obj))) // index = 0 console.log(`#2 before reverse, index = ${index}`) arr.reverse() // #3 console.log(`#4 after reverse, index = ${index}`) console.log(`#5 obj === arr[1], ${obj === toRaw(arr[1])}`)    #1 obj === arr[0], true #2 before reverse, index = 0 #4 after reverse, index = -1 #5 obj === arr[1], true undefined   +RESULTS: 失败\nbefore reverse, index = 0 after reverse, index = -1 [ { b: 2 }, { a: 1 } ]   T5: 使用 delete 删除数组元素时不应该触发 length 依赖\n1 2 3 4 5 6 7 8 9 10  const { isReactive, effect, reactive, targetMap } = require(process.env.PWD + \u0026#39;/../../static/js/vue/reactivity.global.js\u0026#39;) const arr = reactive([1,2,3]) let dummy = 0 effect(() =\u0026gt; { dummy = arr.length + 1 }) console.log(`before delete, dummy = ${dummy}, arr = ${arr}, len = ${arr.length}`) delete arr[1] console.log(`after delete, dummy = ${dummy}, arr = ${arr}, len = ${arr.length}`)     +RESULTS: 删除操作并不会改变数组长度\nbefore delete, dummy = 4, arr = 1,2,3, len = 3 after delete, dummy = 4, arr = 1,,3, len = 3 undefined   PS: 赋值已有的下标元素值、添加非正整数类型的属性到数组上都不会触发 length 依 赖，本质上并没有改变数组长度。\n  T6: 在 effect fn 中使用 for ... in 迭代语句应该 track length\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  const { isReactive, effect, reactive, targetMap } = require(process.env.PWD + \u0026#39;/../../static/js/vue/reactivity.global.js\u0026#39;) const nums = [1] const array = reactive(nums) let len = \u0026#39;\u0026#39; effect(() =\u0026gt; { len = \u0026#39;\u0026#39; for (const key in array) { len += key } }) console.log(`before push, len = ${len}`) array.push(1) console.log(`after push, len = ${len}`)    before push, len = 0 after push, len = 01 undefined   +RESULTS: 输出显示，length 依赖已经 track 到了，只是 Length 变化并没有触发\nMap(1) { \u0026#39;length\u0026#39; =\u0026gt; Set(1) { [Function: reactiveEffect] { id: 0, allowRecurse: false, _isEffect: true, active: true, raw: [Function (anonymous)], deps: [Array], options: {} } } } before push, len = 0 after push, len = 0   FIX: feat(add): array add element support · gcclll/stb-vue-next@21b4881\n     array add element support   feat(add): array add element support · gcclll/stb-vue-next@21b4881\n 增加添加数组元素支持。\n       createGetter -\u0026gt; get proxy handler 中增加属性添加 trigger 操作\n trigger(target, TriggerOpTypes.ADD, key, value)\n  effect.ts -\u0026gt; trigger() 中增加数组长度变更依赖收集和 ADD 操作依赖收集\n     add shallow reactive   feat(add): shallowReactive api · gcclll/stb-vue-next@e85dfc6\n 正常 track 过程中会检测嵌套内的是不是对象，如果是对象会进行递归 reactive 让内部嵌套的对象也 reactive 化。\n shallow reactive 意思是当对象存在嵌套的时候，不进行递归 reactive 。\n 这个通过在 track() 函数中做一次拦截处理。\n 测试：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45  const { isReactive, effect, reactive, targetMap, shallowReactive } = require(process.env.PWD + \u0026#39;/../../static/js/vue/reactivity.global.js\u0026#39;) const props = shallowReactive({ n: { foo: 1} }) console.log(`props.n is reactive, ${isReactive(props.n)}`) const props2 = shallowReactive({ n: reactive({ foo: 1 }) }) props2.n = reactive({ foo: 2 }) console.log(`props2.n is reactive, ${isReactive(props2.n)}`) // array test const shallowArray = shallowReactive([]) const a = {} let size effect(() =\u0026gt; { size = shallowArray.length }) console.log(`\u0026gt;\u0026gt; array`) console.log(`before push a, size = ${size}`) shallowArray.push(a) console.log(`after push a, size = ${size}`) shallowArray.pop() console.log(`after pop, size = ${size}`) console.log(`\u0026gt;\u0026gt; 迭代时不应观察`) shallowArray.push(a) const spreadA = [...shallowArray][0] // 迭代也有取值过程，shallow = true 不会递归 reactive console.log(`spreadA is reactive, ${isReactive(spreadA)}`) console.log(`\u0026gt;\u0026gt; onTrack`) const onTrackFn = () =\u0026gt; console.log(\u0026#39;on tracking...\u0026#39;) let b effect(() =\u0026gt; { b = Array.from(shallowArray) }, { onTrack: onTrackFn })     +RESULTS: Array.from 本质是迭代器操作，所以会触发迭代器 tracking 。\nprops.n is reactive, false props2.n is reactive, true \u0026gt;\u0026gt; array before push a, size = 0 after push a, size = 1 after pop, size = 0 \u0026gt;\u0026gt; 迭代时不应观察 spreadA is reactive, false \u0026gt;\u0026gt; onTrack on tracking... on tracking... undefined    add readonly reactive   feat(add): readonly reactive · gcclll/stb-vue-next@66e7903\n测试(for Object)：  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55  const { isReactive, effect, reactive, targetMap, shallowReactive, readonly, isProxy, isReadonly } = require(process.env.PWD + \u0026#39;/../../static/js/vue/reactivity.global.js\u0026#39;) console.log(`\u0026gt;\u0026gt;\u0026gt; should make nested values readonly`) const original = { foo: 1, bar: { baz: 2 } } const wrapped = readonly(original) console.log(`wrapped !== original, ${wrapped !== original}`) console.log(`wrapped is proxy, ${isProxy(wrapped)}`) console.log(`wrapped is reactive, ${isReactive(wrapped)}`) console.log(`wrapped is readonly, ${isReadonly(wrapped)}`) console.log(`original is reactive, ${isReactive(original)}`) console.log(`original is readonly, ${isReadonly(original)}`) console.log(`wrapped.bar is reactive, ${isReactive(wrapped.bar)}`) console.log(`wrapped.bar is readonly, ${isReadonly(wrapped.bar)}`) console.log(`original.bar is reactive, ${isReactive(original.bar)}`) console.log(`original.bar is readonly, ${isReadonly(original.bar)}`) console.log(`\u0026gt;\u0026gt; get`) console.log(`wrapped.foo = ${wrapped.foo}`) console.log(`\u0026gt;\u0026gt; has`) console.log(`\u0026#39;foo\u0026#39; in wrapped, ${\u0026#39;foo\u0026#39; in wrapped}`) console.log(`\u0026gt;\u0026gt; ownKeys`) console.log(`Object.keys(wrapped), [${Object.keys(wrapped)}]`) console.log(`\u0026gt;\u0026gt; set or delete, should fail`) const qux = Symbol(\u0026#39;qux\u0026#39;) const original2 = { foo: 1, bar: { baz: 2 }, [qux]: 3 } const wrapped2 = readonly(original2) wrapped2.foo = 2 // fail console.log(`after \u0026#39;wrapped2.foo = 2\u0026#39;, wrapped2.foo = ${wrapped2.foo}`) wrapped2.bar.baz = 3 console.log(`after \u0026#39;wrapped2.bar.baz = 3\u0026#39;, wrapped2.bar.baz = ${wrapped2.bar.baz}`) wrapped2[qux] = 4 console.log(`after \u0026#39;wrapped2[qux] = 4\u0026#39;, wrapped2[qux] = ${wrapped2[qux]}`) delete wrapped2.foo console.log(`after \u0026#39;delete wrapped2.foo\u0026#39;, wrapped2.foo = ${wrapped2.foo}`) delete wrapped2.bar.baz console.log(`after \u0026#39;delete wrapped2.bar.baz\u0026#39;, wrapped2.bar.baz = ${wrapped2.bar.baz}`) delete wrapped2[qux] console.log(`after \u0026#39;delete wrapped2[qux]\u0026#39;, wrapped2[qux] = ${wrapped2[qux]}`)     +RESULTS: readonly 会递归嵌套对象，所以它内部的对象都会是 readonly。\n\u0026gt;\u0026gt;\u0026gt; should make nested values readonly wrapped !== original, true wrapped is proxy, true wrapped is reactive, false wrapped is readonly, true original is reactive, false original is readonly, false wrapped.bar is reactive, false wrapped.bar is readonly, true original.bar is reactive, false original.bar is readonly, false \u0026gt;\u0026gt; get wrapped.foo = 1 \u0026gt;\u0026gt; has \u0026#39;foo\u0026#39; in wrapped, true \u0026gt;\u0026gt; ownKeys Object.keys(wrapped), [foo,bar] \u0026gt;\u0026gt; set or delete, should fail after \u0026#39;wrapped2.foo = 2\u0026#39;, wrapped2.foo = 1 after \u0026#39;wrapped2.bar.baz = 3\u0026#39;, wrapped2.bar.baz = 2 after \u0026#39;wrapped2[qux] = 4\u0026#39;, wrapped2[qux] = 3 after \u0026#39;delete wrapped2.foo\u0026#39;, wrapped2.foo = 1 after \u0026#39;delete wrapped2.bar.baz\u0026#39;, wrapped2.bar.baz = 2 after \u0026#39;delete wrapped2[qux]\u0026#39;, wrapped2[qux] = 3    测试(for Array):  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41  const { isReactive, effect, readonly, isReadonly, reactive, targetMap, isProxy, shallowReactive } = require(process.env.PWD + \u0026#39;/../../static/js/vue/reactivity.global.js\u0026#39;) console.log(`\u0026gt;\u0026gt;\u0026gt; should make nested values readonly`) const original = [{ foo: 1 }] const wrapped = readonly(original) console.log(`wrapped !== original`) console.log(`wrapped is proxy, ${isProxy(wrapped)}`) console.log(`wrapped is reactive, ${isReactive(wrapped)}`) console.log(`wrapped is readonly, ${isReadonly(wrapped)}`) console.log(`original is reactive, ${isReactive(original)}`) console.log(`original is readonly, ${isReadonly(original)}`) console.log(`wrapped[0] is reactive, ${isReactive(wrapped[0])}`) console.log(`wrapped[0] is readonly, ${isReadonly(wrapped[0])}`) console.log(`original[0] is reactive, ${isReactive(original[0])}`) console.log(`original[0] is readonly, ${isReadonly(original[0])}`) console.log(`\u0026gt; get`) console.log(`wrapped[0].foo = ${wrapped[0].foo}`) console.log(`\u0026gt; has`) console.log(`0 in wrapped, ${0 in wrapped}`) console.log(`\u0026gt; ownKeys`) console.log(`Object.keys(wrapped) = [${Object.keys(wrapped)}]`) const wrapped2 = readonly([{ foo: 1 }]) wrapped2[0] = 1 console.log(`after \u0026#39;wrapped2[0] = 1\u0026#39;, wrapped2[0] = ${wrapped2[0]}`) wrapped2[0].foo = 2 console.log(`after \u0026#39;wrapped2[0].foo = 2\u0026#39;, wrapped2[0].foo = ${wrapped2[0].foo}`) wrapped2.length = 0 console.log(`after \u0026#39;wrapped2.length = 0\u0026#39;, wrapped2.length = ${wrapped.length}`) console.log(`after \u0026#39;wrapped2.length = 0\u0026#39;, wrapped2[0].foo = ${wrapped2[0].foo}`) wrapped2.push(2) console.log(`after \u0026#39;wrapped2.push(2)\u0026#39;, wrapped2.length = ${wrapped2.length}`)     +RESULTS:\n\u0026gt;\u0026gt;\u0026gt; should make nested values readonly wrapped !== original wrapped is proxy, true wrapped is reactive, false wrapped is readonly, true original is reactive, false original is readonly, false wrapped[0] is reactive, false wrapped[0] is readonly, true original[0] is reactive, false original[0] is readonly, false \u0026gt; get wrapped[0].foo = 1 \u0026gt; has 0 in wrapped, true \u0026gt; ownKeys Object.keys(wrapped) = [0] after \u0026#39;wrapped2[0] = 1\u0026#39;, wrapped2[0] = [object Object] after \u0026#39;wrapped2[0].foo = 2\u0026#39;, wrapped2[0].foo = 1 after \u0026#39;wrapped2.length = 0\u0026#39;, wrapped2.length = 1 after \u0026#39;wrapped2.length = 0\u0026#39;, wrapped2[0].foo = 1 after \u0026#39;wrapped2.push(2)\u0026#39;, wrapped2.length = 1 undefined    测试(reactive, readonly 互撩)  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  const { isReactive, effect, reactive, readonly, isReadonly, targetMap, toRaw, shallowReactive } = require(process.env.PWD + \u0026#39;/../../static/js/vue/reactivity.global.js\u0026#39;) const a = readonly({}) const b = reactive(a) console.log(`*#1* isReadonly(b), ${isReadonly(b)}`) console.log(`*#2* toRaw(a) === toRaw(b), ${toRaw(a) === toRaw(b)}`) console.log(`*#3* a === b, ${ a === b }`)     +RESULTS:\n*#1* isReadonly(b), true *#2* toRaw(a) === toRaw(b), true *#3* a === b, true undefined    #1 b is readonly: createReactive 中的处理\n1 2 3  if (target[ReactiveFlags.Raw] \u0026amp;\u0026amp; !(isReadonly \u0026amp;\u0026amp; target[ReactiveFlags.IS_REACTIVE])) { return target }     上面的处理针对 b = reactive(a) 有：\n a 满足 target[ReactiveFlags.Raw] 因为它是 readonly 的.\n isReadonly = false\n target[ReactiveFlags.IS_REACTIVE] 不满足\n 因此上面的判断满足 target[ReactiveFlags.RAW] \u0026amp;\u0026amp; !target[ReactiveFlags.IS_REACTIVE] 直接返回 target 。\n  #2 toRaw(a) === toRaw(b) 这个结果为 true，因为 #1 中的原因，直接返回了 target， 所以 b 实际上就是 a(如结果 #3)\n      add shallow readonly reactive   feat(add): shallow readonly reactive · gcclll/stb-vue-next@aaaf911\n  测试:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24  const { isReactive, effect, reactive, targetMap, shallowReactive, shallowReadonly } = require(process.env.PWD + \u0026#39;/../../static/js/vue/reactivity.global.js\u0026#39;) // 嵌套对象不应该 reactive console.log(`\u0026gt;\u0026gt;\u0026gt; should not make non-reactive properties reactive`) let props = shallowReadonly({ n: {foo: 1} }) console.log(`isReactive(props.n), ${isReactive(props.n)}`) // 根属性应该是 readonly console.log(`\u0026gt;\u0026gt;\u0026gt; should make root level properties readonly`) props = shallowReadonly({n : 1}) props.n = 2 console.log(`after \u0026#39;props.n = 2\u0026#39;, props.n = ${props.n}`) // 嵌套的属性不应该是 readonly ，因为是 shallow console.log(`\u0026gt;\u0026gt;\u0026gt; should NOT make nested properties readonly`) props = shallowReadonly({ n: { foo: 1 } }) props.n.foo = 2 console.log(`after \u0026#39;props.n.foo = 2\u0026#39;, props.n.foo = ${props.n.foo}`)     +RESULTS:\n\u0026gt;\u0026gt;\u0026gt; should not make non-reactive properties reactive isReactive(props.n), false \u0026gt;\u0026gt;\u0026gt; should make root level properties readonly after \u0026#39;props.n = 2\u0026#39;, props.n = 1 \u0026gt;\u0026gt;\u0026gt; should NOT make nested properties readonly after \u0026#39;props.n.foo = 2\u0026#39;, props.n.foo = 2 undefined   这里的结果不难理解\n  shallow 不会递归 reactive\n  readonly 让属性只读，但是由于是 shallow 所以只有对象根属性才是只读\n    add effect stop   feat(add): effect stop · gcclll/stb-vue-next@f1e5b3a\n  stop() 函数操作：\n  清空所有 effect 上的 deps，同时将当前的 effect 从所有依赖它的 dep 中删除\n effect.deps[i].delete(effect) , 这一步是将 targetMap \u0026gt; depsMap \u0026gt; deps 中 的 effect 删除。\n effect.deps.length = 0\n  将 effect.active 置为 false\n   执行 stop() 之后，只能手动调用 runner() 来触发 effect fn(前提是没有提供 options.scheduler ，否则永远不会被执行) 。\n 被 stopped 的 effect 可以当做另一个正常的 effect 的 fn。\n  集合类型代理(proxy handlers)脑图    add collection handlers   feat(add): mutable collection handlers · gcclll/stb-vue-next@521f755\n collection proxy handlers 脑图链接\n 因为 Reflect 没有集合操作的对应接口，所以针对集合类型需要通过 get proxy 来中转 做特殊处理。\n1 2 3 4 5 6  function createInstrumentationGetter(isReadonly: boolean, shallow: boolean) { // TODO } export const mutableCollectionHandlers: ProxyHandler\u0026lt;CollectionTypes\u0026gt; = { // get: createInstrumentationGetter(false, false) }     添加集合类型的 handlers。\n  add collection get proxy handler   feat(add): collection get proxy · gcclll/stb-vue-next@a5e8e06\n 针对集合的所有操作代理都是通过 get proxy 变相完成的，所以搞懂这里是至关重要的。\n collection proxy handler:\n1 2 3  export const mutableCollectionHandlers: ProxyHandler\u0026lt;CollectionTypes\u0026gt; = { get: createInstrumentationGetter(false, false) }     简单吧，别被假🐘给迷惑了！！！\n 这里的原理如果想通了也简单。\n 试想下，我们调用集合类型的方法是怎么调用的？？？\n map.get(), map.set(), map.delete(), ...\n 都是通过点语法使用的，点语法前提也必须是先取出值来进行操作，即要调用方法之前，先 将方法取出来，因此这里就是取值操作。\n 从这一个层级上去理解去实现，就可以通过集合的 proxy get 来变相实现所有集合的方 法和属性代理。\n 注意 Reflect.get(target, key, receiver) 第一个传的是什么？\n boolean ? instrumentations : target 即封装后的 instrumentations 啊 !\n 如： map.get() -\u0026gt; target: map, key: get -\u0026gt; target: instumentations, key: get -\u0026gt; get(target, key, isReadonly, isShallow)\n 集合的操作最终 —–\u0026gt; 转变成 instrumentations 对象上的操作。\n 去掉暂时不需要的代码(65ea709)：\n feat: add get proxy handler · gcclll/stb-vue-next@65ea709\n 实现顺序(原理)  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55  // 1. 对外的 handlers export const mutableCollectionHandlers: ProxyHandler\u0026lt;CollectionTypes\u0026gt; = { get: createInstrumentationGetter(false, false) } // 2. 封装 get proxy 所有 collection 操作的入口 function createInstrumentationGetter(isReadonly: boolean, shallow: boolean) { const instrumentations = mutableInstrumentations return ( target: CollectionTypes, key: string | symbol, receiver: CollectionTypes ) =\u0026gt; { if (key === ReactiveFlags.IS_REACTIVE) { return !isReadonly } else if (key === ReactiveFlags.IS_READONLY) { return isReadonly } else if (key === ReactiveFlags.RAW) { return target } // 将集合操作代理到 instrumentations 对象上  return Reflect.get( hasOwn(instrumentations, key) \u0026amp;\u0026amp; key in target ? instrumentations : target, key, receiver ) } } // 3. map -\u0026gt; instrumentations -\u0026gt; proxy 中间对象 const mutableInstrumentations: Record\u0026lt;string, Function\u0026gt; = { // get proxy handler, this -\u0026gt; target  get(this: MapTypes, key: unknown) { return get(this, key) } } // 4. 最终执行操作得到结果的函数 function get( target: MapTypes, key: unknown, isReadonly = false, isShallow = false ) { // TODO  console.log({ target, key }) return target.get(key) }     理解过程：\n 首先要理解执行这一句 map.get(\u0026#39;foo\u0026#39;) 发生了什么\n  首先是 map.get 取值操作，即 createInstrumentationGetter() 最后 return 的 那一句\n 其实是针对 map.get 操作的代理，将 \u0026#34;get\u0026#34; 方法从 map 对象中取出来的代理。\n 所以 Reflect.get(target, key, receiver) 这里的 key = \u0026#34;foo\u0026#34;\n  经过 #1 之后，需要立即执行 \u0026#34;get\u0026#34; 方法即 () 操作\n 此时执行的是 mutableInstrumentations.get(this, key) 方法\n 所以这里的 key = \u0026#39;foo\u0026#39; , this 就是调用 get() 方法的对象 map 。   最后 get 操作会被模块全局函数 get(target, key, isReadonly, isShallow) 代替， 做了许多特殊处理，收集依赖。\n     12bc4da add get handler   feat(add): get function for collection proxy · gcclll/stb-vue-next@12bc4da\n FIX: edc1d3f 死循环问题(直接放回 target.get(key) 又会触发 get -\u0026gt; …) fix: infinite loop · gcclll/stb-vue-next@edc1d3f\n1 2 3 4 5 6 7 8 9 10 11 12 13  const { isReactive, effect, reactive, targetMap, shallowReactive } = require(process.env.PWD + \u0026#39;/../../static/js/vue/reactivity.global.js\u0026#39;) const map = new Map([[\u0026#39;foo\u0026#39;, 1]]) const observed = reactive(map) const res = observed.get(\u0026#39;foo\u0026#39;) console.log({ res })     +RESULTS:\n{ key: \u0026#39;get\u0026#39;, target: Map(1) { \u0026#39;foo\u0026#39; =\u0026gt; 1 }, x: \u0026#39;in createInstrumentationsGetter\u0026#39; } { key: \u0026#39;foo\u0026#39;, target: Map(1) { \u0026#39;foo\u0026#39; =\u0026gt; 1 }, x: \u0026#39;in get\u0026#39; } { res: 100 }   结果如上(参见.原理详细分析)\n  reactive(map) -\u0026gt; 将 map 代理给 instrumentations{ get }\n  observed.get -\u0026gt; 得到 instrumentations 里面的 \u0026#34;get\u0026#34; 方法\n  (\u0026#39;foo\u0026#39;) -\u0026gt; 执行 instrumentations.get(this, key), key = \u0026#39;foo\u0026#39;\n  返回结果\n   至此，完成 collection get proxy handler 的完整流程。\n   0b3fd71 add get handler track   feat(add): collection proxy get -\u0026gt; global get · gcclll/stb-vue-next@0b3fd71\n 新增get 操作，track 添加依赖。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17  const { isReactive, effect, reactive, targetMap, shallowReactive } = require(process.env.PWD + \u0026#39;/../../static/js/vue/reactivity.global.js\u0026#39;) const map = new Map([[\u0026#39;foo\u0026#39;, 1]]) const observed = reactive(map) let dummy effect(() =\u0026gt; { dummy = observed.get(\u0026#39;foo\u0026#39;) }) console.log(`dummy = ${dummy}`)     +RESULTS:\n{ key: \u0026#39;get\u0026#39;, target: Map(1) { \u0026#39;foo\u0026#39; =\u0026gt; 1 }, x: \u0026#39;in createInstrumentationGetter\u0026#39; } { key: \u0026#39;foo\u0026#39;, type: \u0026#39;get\u0026#39;, dep: Set(1) { [Function: reactiveEffect] { id: 0, allowRecurse: false, _isEffect: true, active: true, raw: [Function (anonymous)], deps: [Array], options: {} } }, x: \u0026#39;in track\u0026#39; } { key: \u0026#39;foo\u0026#39;, target: Map(1) { \u0026#39;foo\u0026#39; =\u0026gt; 1 }, x: \u0026#39;in global get\u0026#39; } dummy = 100   分为三个阶段\n  collection proxy handler 取 map.get 方法, key = \u0026#39;get\u0026#39;\n  (\u0026#39;prop\u0026#39;) 执行期触发 instrumentations.get(this, key), key = \u0026#39;foo\u0026#39;\n  执行 global get 触发 track 收集依赖，返回结果值\n   假设 map.get(key) 的 key 也是个 proxy :\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18  const { isReactive, effect, reactive, targetMap, shallowReactive } = require(process.env.PWD + \u0026#39;/../../static/js/vue/reactivity.global.js\u0026#39;) let dummy const key = reactive({ k: 1 }) const value = reactive({ v: 2 }) const map = reactive(new Map([[key, value]])) effect( () =\u0026gt; { dummy = map.get(key) } ) console.log(`dummy = ${dummy}`)     +RESULTS:\n{ #1 key: \u0026#39;get\u0026#39;, target: Map(1) { { k: 1 } =\u0026gt; { v: 2 } }, x: \u0026#39;in createInstrumentationGetter\u0026#39; } #2 { key: { k: 1 }, rawKey: { k: 1 }, eq: false } { #3 key: { k: 1 }, type: \u0026#39;get\u0026#39;, dep: Set(1) { [Function: reactiveEffect] { id: 0, allowRecurse: false, _isEffect: true, active: true, raw: [Function (anonymous)], deps: [Array], options: {} } }, x: \u0026#39;in track\u0026#39; } { #4 key: { k: 1 }, type: \u0026#39;get\u0026#39;, dep: Set(1) { [Function: reactiveEffect] { id: 0, allowRecurse: false, _isEffect: true, active: true, raw: [Function (anonymous)], deps: [Array], options: {} } }, x: \u0026#39;in track\u0026#39; } { #5 key: { k: 1 }, target: Map(1) { { k: 1 } =\u0026gt; { v: 2 } }, x: \u0026#39;in global get\u0026#39; } dummy = 100    #1 proxy collection get handler\n  #2 global get 函数里调用 track 之前输出，显示 key 和 rawKey 是不同的 (eq = false)，因为前者是个 proxy 后者是 key proxy 的 rawValue 。\n  #3 track() 调用时的输出，显示的是需要收集依赖的是 proxy key{k: 1}   #4 track() 调用时的输出，显示的是需要收集依赖的是 raw key{k: 1}\n   从 #3, #4 可知如果 key 本身已经是 proxy 那么它及其对应的 rawKey 同时也会收集 当前的 effect 。\n  77b14ef add get handler return value   feat(add): collection proxy get with value return · gcclll/stb-vue-next@77b14ef\n  这里处理分为两部分：\n  取出 has 方法检测存在性\n  根据 isReadonly 和 isShallow 决定对返回值做什么处理，如：递归 reactive/readonly\n  使用 target.get(key) 取出结果值返回\n      add collection set proxy handler   feat(add): collection set proxy handler · gcclll/stb-vue-next@7b680df\n set proxy handler 处理\n  设值的时候可能有两种情况 a) set, b) add\n  需要考虑 proxy key 和 raw key 问题\n  最后 trigger 触发依赖\n  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29  function set(this: MapTypes, key: unknown, value: unknown) { value = toRaw(value) const target = toRaw(this) const { has, get } = getProto(target) let hadKey = has.call(target, key) // 考虑 key 可能是 proxy  if (!hadKey) { // to add  key = toRaw(key) hadKey = has.call(target, key) } else if (__DEV__) { checkIdentityKeys(target, has, key) } const oldValue = get.call(target, key) // 设值结果  const result = target.set(key, value) if (!hadKey) { // 添加操作  trigger(target, TriggerOpTypes.ADD, key, value) } else { // 设值操作  trigger(target, TriggerOpTypes.SET, key, value, oldValue) } return result }     测试\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25  const { isReactive, effect, reactive, targetMap, shallowReactive } = require(process.env.PWD + \u0026#39;/../../static/js/vue/reactivity.global.js\u0026#39;) const map = new Map() const observed = reactive(map) console.log(`\u0026gt; before get, deps`) console.log(targetMap.get(map)) let dummy effect(() =\u0026gt; { dummy = observed.get(\u0026#39;foo\u0026#39;) }) console.log(`\u0026gt; after get, deps`) console.log(targetMap.get(map).get(\u0026#39;foo\u0026#39;)) console.log(`#1 before set, dummy = ${dummy}`) observed.set(\u0026#39;foo\u0026#39;, 1) console.log(`#2 after set, dummy = ${dummy}`)     +RESULTS:\n\u0026gt; before get, deps undefined \u0026gt; after get, deps \u0026lt;ref *1\u0026gt; Set(1) { [Function: reactiveEffect] { id: 0, allowRecurse: false, _isEffect: true, active: true, raw: [Function (anonymous)], deps: [ [Circular *1] ], options: {} } } #1 before set, dummy = undefined #2 after set, dummy = 1    add collection size,has,add proxy handler   feat(add): size, has, add collection proxy handlers · gcclll/stb-vue-next@73fa5eb\n has: proxy key, raw key 都需要 track has 操作依赖\n1 2 3 4 5 6 7 8 9 10 11 12 13  function has(this: CollectionTypes, key: unknown, isReadonly = false): boolean { const target = (this as any)[ReactiveFlags.RAW] const rawTarget = toRaw(target) const rawKey = toRaw(key) if (key !== rawKey) { !isReadonly \u0026amp;\u0026amp; track(rawTarget, TrackOpTypes.HAS, key) } !isReadonly \u0026amp;\u0026amp; track(rawTarget, TrackOpTypes.HAS, rawKey) return key === rawKey ? target.has(key) : target.has(key) || target.has(rawKey) }     size: 取size 内部实现过程中是需要对 collection 进行迭代操作的，所以 track 用的是 ITERATE_KEY\n1 2 3 4 5  function size(target: IterableCollections, isReadonly = false) { target = (target as any)[ReactiveFlags.RAW] !isReadonly \u0026amp;\u0026amp; track(toRaw(target), TrackOpTypes.ITERATE, ITERATE_KEY) return Reflect.get(target, \u0026#39;size\u0026#39;, target) }     add: set.add 操作，根据 set 特性，key,value 都是同一个且元素是不重复的，所以只需 要检测是不是新增，新增就需要 trigger ADD 。\n1 2 3 4 5 6 7 8 9 10 11 12 13  function add(this: SetTypes, value: unknown) { value = toRaw(value) const target = toRaw(this) const proto = getProto(target) const hadKey = proto.has.call(target, value) const result = target.add(value) // 因为 set 是不会存在重复元素的，所以只会在没有当前 key 的情况下才会执行  // 添加操作  if (!hadKey) { trigger(target, TriggerOpTypes.ADD, value, value) } return result }     trigger 处理：838b402\n feat(add): collection trigger cases · gcclll/stb-vue-next@838b402\n 测试：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32  const { isReactive, effect, reactive, targetMap, shallowReactive } = require(process.env.PWD + \u0026#39;/../../static/js/vue/reactivity.global.js\u0026#39;) const map = new Map() const observed = reactive(map) let dummy effect(() =\u0026gt; { dummy = observed.size }) console.log(`before set, get map size -\u0026gt; dummy = ${dummy}`) observed.set(\u0026#39;foo\u0026#39;, 1) console.log(`after set, get map size -\u0026gt; dummy = ${dummy}`) effect(() =\u0026gt; { dummy = observed.has(\u0026#39;foo\u0026#39;) }) console.log(`observed has \u0026#39;foo\u0026#39; -\u0026gt; dummy = ${dummy}`) const set = new Set() const observedSet = reactive(set) effect(() =\u0026gt; { dummy = observedSet.size }) console.log(`before add, get set size -\u0026gt; dummy = ${dummy}`) observedSet.add(1) console.log(`after add, get set size -\u0026gt; dummy = ${dummy}`)     +RESULTS:\nbefore set, get map size -\u0026gt; dummy = 0 after set, get map size -\u0026gt; dummy = 1 observed has \u0026#39;foo\u0026#39; -\u0026gt; dummy = true before add, get set size -\u0026gt; dummy = 0 after add, get set size -\u0026gt; dummy = 1    add collection delete,clear proxy handler   feat(add): collection delete and clear · gcclll/stb-vue-next@b3c5087\n delete:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18  function deleteEntry(this: CollectionTypes, key: unknown) { const target = toRaw(this) const { has, get } = getProto(target) let hadKey = has.call(target, key) if (!hadKey) { key = toRaw(key) hadKey = has.call(target, key) } else if (__DEV__) { checkIdentityKeys(target, has, key) } const oldValue = get ? get.call(target, key) : undefined const result = target.delete(key) if (hadKey) { trigger(target, TriggerOpTypes.DELETE, key, undefined, oldValue) } return result }     clear:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  function clear(this: IterableCollections) { const target = toRaw(this) const hadItems = target.size !== 0 const oldTarget = __DEV__ ? isMap(target) ? new Map(target) : new Set(target) : undefined const result = target.clear() if (hadItems) { trigger(target, TriggerOpTypes.CLEAR, undefined, undefined, oldTarget) } return result }     测试：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42  const { isReactive, effect, reactive, targetMap, shallowReactive } = require(process.env.PWD + \u0026#39;/../../static/js/vue/reactivity.global.js\u0026#39;) const map = new Map() const observedMap = reactive(map) let dummy effect(() =\u0026gt; { dummy = observedMap.size }) console.log(`\u0026gt;\u0026gt;\u0026gt; map`) observedMap.set(\u0026#39;foo\u0026#39;, 1) console.log(`before delete, dummy = ${dummy}`) observedMap.delete(\u0026#39;foo\u0026#39;) console.log(`after delete, dummy = ${dummy}`) observedMap.set(\u0026#39;foo\u0026#39;, 1) observedMap.set(\u0026#39;bar\u0026#39;, 1) console.log(`before clear, dummy = ${dummy}`) observedMap.clear() console.log(`after clear, dummy = ${dummy}`) console.log(`\u0026gt;\u0026gt;\u0026gt; set`) const set = new Set() const observedSet = reactive(set) effect(() =\u0026gt; { dummy = observedSet.size }) observedSet.add(1) console.log(`before delete, dummy = ${dummy}`) observedSet.delete(1) console.log(`after delete, dummy = ${dummy}`) observedSet.add(1) observedSet.add(2) observedSet.add(3) console.log(`before clear, dummy = ${dummy}`) observedSet.clear() console.log(`after clear, dummy = ${dummy}`)     +RESULTS:\n\u0026gt;\u0026gt;\u0026gt; map before delete, dummy = 1 after delete, dummy = 0 before clear, dummy = 2 after clear, dummy = 0 \u0026gt;\u0026gt;\u0026gt; set before delete, dummy = 1 after delete, dummy = 0 before clear, dummy = 3 after clear, dummy = 0    add collection forEach proxy handler   feat(add): collection forEach proxy handler · gcclll/stb-vue-next@77a0222\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19  function createForEach(isReadonly: boolean, isShallow: boolean) { return function forEach( this: IterableCollections, callback: Function, thisArg?: unknown ) { const observed = this as any const target = observed[ReactiveFlags.RAW] const rawTarget = toRaw(target) const wrap = isReadonly ? toReadonly : isShallow ? toShallow : toReactive !isReadonly \u0026amp;\u0026amp; track(rawTarget, TrackOpTypes.ITERATE, ITERATE_KEY) return target.forEach((value: unknown, key: unknown) =\u0026gt; { // 重要：确保回调  // 1. 在 reactive map 作用域下被执行(this, 和第三个参数)  // 2. 接受的 value 值应该是个 reactive/readonly 类型  return callback.call(thisArg, wrap(value), wrap(key), observed) }) } }     将 forEach 封装了一层，对传递给回调的值 reactive 化，使用 ITERATE_KEY 收集调用 该方法的依赖。\n 测试：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20  const { isReactive, effect, reactive, targetMap, shallowReactive } = require(process.env.PWD + \u0026#39;/../../static/js/vue/reactivity.global.js\u0026#39;) const map = new Map() const ob = reactive(map) let dummy = 0 effect(() =\u0026gt; { ob.forEach((value) =\u0026gt; (dummy += value || 0)) }) console.log(`#1 before set 1, dummy = ${dummy}`) ob.set(\u0026#39;foo\u0026#39;, 1) console.log(`#2 before set 2, dummy = ${dummy}`) ob.set(\u0026#39;bar\u0026#39;, 2) console.log(`#3 after set, dummy = ${dummy}`)     +RESULTS:\n#1 before set 1, dummy = 0 #2 before set 2, dummy = 1 #3 after set, dummy = 4    #1 effect 会立即执行一次，但是此时 map 没数据\n  #1 添加 foo =\u0026gt; 1 之后执行 effect fn forEach 迭代器进行累加操作的结果\n  #2 添加 bar =\u0026gt; 2 结果是 4，原因是到这一步的时候 dummy = 1 的，所以再累加之\n  后就是 4\n  add collection iterators methods proxy handler   feat(add): collection iterable methods · gcclll/stb-vue-next@e5497be\n add code:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54  interface Iterable { [Symbol.iterator](): Iterator } interface Iterator { next(value?: any): IterationResult } interface IterationResult { value: any done: boolean } function createIterableMethod( method: string | symbol, isReadonly: boolean, isShallow: boolean ) { return function( this: IterableCollections, ...args: unknown[] ): Iterable \u0026amp; Iterator { const target = (this as any)[ReactiveFlags.RAW] const rawTarget = toRaw(target) const targetIsMap = isMap(rawTarget) const isPair = method === \u0026#39;entries\u0026#39; || (method === Symbol.iterator \u0026amp;\u0026amp; targetIsMap) const isKeyOnly = method === \u0026#39;keys\u0026#39; \u0026amp;\u0026amp; targetIsMap const innerIterator = target[method](...args) const wrap = isReadonly ? toReadonly : isShallow ? toShallow : toReactive !isReadonly \u0026amp;\u0026amp; track( rawTarget, TrackOpTypes.ITERATE, isKeyOnly ? MAP_KEY_ITERATE_KEY : ITERATE_KEY ) // 重写迭代器，让其返回的对象也是 reactive/readonly 类型  return { next() { const { value, done } = innerIterator.next() return done ? { value, done } : { value: isPair ? [wrap(value[0]), wrap(value[1])] : wrap(value), done } }, [Symbol.iterator]() { return this } } } }     test:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47  const { isReactive, effect, reactive, targetMap, shallowReactive, toRaw } = require(process.env.PWD + \u0026#39;/../../static/js/vue/reactivity.global.js\u0026#39;) const map = new Map() const obj = { name: \u0026#39;dax\u0026#39; } map.set(\u0026#34;foo\u0026#34;, 1) map.set(\u0026#34;bar\u0026#34;, 2) map.set(\u0026#39;dax\u0026#39;, obj) const observed = reactive(map) let dummy = [] effect(() =\u0026gt; { for (let key of observed.entries()) { dummy.push(key) } }) console.log(`\u0026gt;\u0026gt;\u0026gt; #1 set`) console.log(`before set, dummy = ${dummy}`) observed.set(\u0026#39;baz\u0026#39;, 3) console.log(`after set, dummy = ${dummy}`) console.log(`obj in map is reactive ${isReactive(observed.get(\u0026#34;dax\u0026#34;))}`) effect(() =\u0026gt; { dummy = observed.size }) console.log(`\u0026gt;\u0026gt;\u0026gt; #2 clear`) console.log(`before clear, dummy = ${dummy}`) observed.clear() console.log(`after clear, dummy = ${dummy}`) console.log(`\u0026gt;\u0026gt;\u0026gt; #3 should not observe custom property`) effect(() =\u0026gt; (dummy = observed.customProp)) console.log(`before set cumstom prop, dummy = ${dummy}`) observed.customProp = \u0026#39;Hello World\u0026#39; console.log(`after set cumstom prop, dummy = ${dummy}`) console.log(`\u0026gt;\u0026gt;\u0026gt; #4 不应该使 Proxies 污染原来的 Map 对象`) const map2 = new Map() const observed2 = reactive(map2) const value = reactive({}) observed2.set(\u0026#39;key\u0026#39;, value) console.log(`map2.get(\u0026#39;key\u0026#39;) !== value, ${map2.get(\u0026#39;key\u0026#39;) !== value}`) console.log(`map2.get(\u0026#39;key\u0026#39;) === toRaw(value), ${map2.get(\u0026#39;key\u0026#39;) === toRaw(value)}`)     +RESULTS:\n\u0026gt;\u0026gt;\u0026gt; #1 set before set, dummy = foo,1,bar,2,dax,[object Object] after set, dummy = foo,1,bar,2,dax,[object Object],foo,1,bar,2,dax,[object Object],baz,3 obj in map is reactive true \u0026gt;\u0026gt;\u0026gt; #2 clear before clear, dummy = 4 after clear, dummy = 0 \u0026gt;\u0026gt;\u0026gt; #3 should not observe custom property before set cumstom prop, dummy = undefined after set cumstom prop, dummy = undefined \u0026gt;\u0026gt;\u0026gt; #4 不应该使 Proxies 污染原来的 Map 对象 map2.get(\u0026#39;key\u0026#39;) !== value, true map2.get(\u0026#39;key\u0026#39;) === toRaw(value), true    #1 在遍历过程中 get -\u0026gt; track -\u0026gt; 递归 reactive，所以 obj 是 obsreved.get(\u0026#39;dax\u0026#39;) 结果是 reactive 。\n  #2 clear 内部实现会取迭代器进行迭代删除，并且改变最终 size 值。\n  #3 collectionHandlers.ts 中的方法都是针对集合本身元素进行操作的，对于自定义 属性是不在响应式 Map/Set 之列的。\n  #4 set proxy handler 里面的实现会先取 toRaw(value) 再进行设置操作。\n    add collection readonly proxy handlers   feat(add): readonly collection handlers · gcclll/stb-vue-next@fa2636d\n 创建几个设置型的方法(add,set,delete,clear) create readonly method for settable handlers(add,set,delete,clear)\n1 2 3 4 5 6 7 8 9 10 11 12  function createReadonlyMethod(type: TriggerOpTypes): Function { return function(this: CollectionTypes, ...args: unknown[]) { if (__DEV__) { const key = args[0] ? `on key \u0026#34;${args[0]}\u0026#34;` : `` console.warn( `${capitalize(type)}operation ${key}failed: target is readonly.`, toRaw(this) ) } return type === TriggerOpTypes.DELETE ? false : this } }     readonly instrumentations:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  const readonlyInstrumentations: Recor\u0026lt;string, Function\u0026gt; = { get(this: MapTypes, key: unknown) { return get(this, key, true) }, get size() { return size((this as unknown) as IterableCollections, true) }, has(this: MapTypes, key: unknown) { return has.call(this, key, true) }, add: createReadonlyMethod(TriggerOpTypes.ADD), set: createReadonlyMethod(TriggerOpTypes.SET), delete: createReadonlyMethod(TriggerOpTypes.DELETE), clear: createReadonlyMethod(TriggerOpTypes.CLEAR), forEach: createForEach(true, false) }     测试：\n  add collection shallow proxy handlers   feat(add): shallow collection handlers · gcclll/stb-vue-next@676bc70\n 不会递归 reactive 版本。\n  computed  types definitions   feat(add): computed type definitions · gcclll/stb-vue-next@e9e53a1\n computed 计算属性的一些类型定义。\n1 2 3 4 5 6 7 8 9 10 11  import { Ref } from \u0026#39;./ref\u0026#39; export interface ComputedRef\u0026lt;T = any\u0026gt; extends WritableComputedRef\u0026lt;T\u0026gt; {} export interface WritableComputedRef\u0026lt;T\u0026gt; extends Ref\u0026lt;T\u0026gt; {} export type ComputedGetter\u0026lt;T\u0026gt; = (ctx?: any) =\u0026gt; T export type ComputedSetter\u0026lt;T\u0026gt; = (v: T) =\u0026gt; void export interface WritableComputedOptions\u0026lt;T\u0026gt; {}     computed 函数重载(315e0d9)： feat(add): computed function reloads · gcclll/stb-vue-next@315e0d9\n1 2 3 4 5 6 7  export function computed\u0026lt;T\u0026gt;(getter: ComputedGetter\u0026lt;T\u0026gt;): ComputedRef\u0026lt;T\u0026gt; export function computed\u0026lt;T\u0026gt;( options: WritableComputedOptions\u0026lt;T\u0026gt; ): WritableComputedRef\u0026lt;T\u0026gt; export function computed\u0026lt;T\u0026gt;( getterOrOptions: ComputedGetter\u0026lt;T\u0026gt; | WritableComputedOptions\u0026lt;T\u0026gt; ) {}      implementation   feat(add): computed tpl and computed function · gcclll/stb-vue-next@64d380d\n 计算属性实现全在 ComputedRefImpl\u0026lt;T\u0026gt; 类的实现中，实现关键点\n  使用 effect 封装 getter 函数，收集所有依赖，在特定时候执行 effect\n  _dirty 标记，一旦 _dirty = true 表示数据有更新，下次取值的时候就要立即执行 effect 取最新值\n   class ComputedRefImpl\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41  // 计算属性模板 class ComputedRefImpl\u0026lt;T\u0026gt; { private _value!: T private _dirty = true public readonly effect: ReactiveEffect\u0026lt;T\u0026gt; public readonly __v_isRef = true; public readonly [ReactiveFlags.IS_READONLY]: boolean constructor( getter: ComputedGetter\u0026lt;T\u0026gt;, private readonly _setter: ComputedSetter\u0026lt;T\u0026gt;, isReadonly: boolean ) { this.effect = effect(getter, { lazy: true, scheduler: () =\u0026gt; { if (!this._dirty) { this._dirty = true trigger(toRaw(this), TriggerOpTypes.SET, \u0026#39;value\u0026#39;) } } }) this[ReactiveFlags.IS_READONLY] = isReadonly } get value() { if (this._dirty) { this._value = this.effect() this._dirty = false } track(toRaw(this), TrackOpTypes.GET, \u0026#39;value\u0026#39;) return this._value } set value(newValue: T) { this._setter(newValue) } }     computed 函数:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29  export function computed\u0026lt;T\u0026gt;(getter: ComputedGetter\u0026lt;T\u0026gt;): ComputedRef\u0026lt;T\u0026gt; export function computed\u0026lt;T\u0026gt;( options: WritableComputedOptions\u0026lt;T\u0026gt; ): WritableComputedRef\u0026lt;T\u0026gt; export function computed\u0026lt;T\u0026gt;( getterOrOptions: ComputedGetter\u0026lt;T\u0026gt; | WritableComputedOptions\u0026lt;T\u0026gt; ) { let getter: ComputedGetter\u0026lt;T\u0026gt; let setter: ComputedSetter\u0026lt;T\u0026gt; if (isFunction(getterOrOptions)) { getter = getterOrOptions setter = __DEV__ ? () =\u0026gt; { console.warn(\u0026#39;Write operation failed: computed value is readonly\u0026#39;) } : NOOP } else { getter = getterOrOptions.get setter = getterOrOptions.set } return new ComputedRefImpl( getter, setter, isFunction(getterOrOptions) || !getterOrOptions.set ) as any }     computed 函数的 options 可以是函数或一个对象，可以用外部自定义 setter 函数，比如 在更新之前记录当前状态，就可以在 options.set 中去实现。\n 测试请移步“计算属性测试用例”\n 脑图请直接查看“完整脑图 computed 部分”\n    add ref    这部分因为之前没有单独拎出来一步步实现，而是直接拷贝过来了为了先测试 computed 属 性。\n 所以这里直接根据源码以及使用方式来进行逐步分析。\n APIs:\n   api function     isRef(r:any) 检测函数   ref(value) 将 value 转成 Ref 类型   shallowRef(value) 不进行递归 reactive   createRef(rawValue, shallow = false) create ref, for ref/shallowRef   triggerRef(ref: Ref) 触发 ref 变量上的所有依赖   unref(ref) 取消 ref 化，返回 ref.value 原始值   proxyRefs(objectWithRefs) refs 代理   RefImpl Ref 变量模板   CustomRefImpl 自定义 Ref 变量模板    ref \u0026amp; shallow ref   ref() 和 shallowRef() 函数都是调用的同一个函数 createRef(val, shallow) 来 创建ref 变量，而 createRef 本身也很简单，就是 new 了一个 RefImpl 实例出来。\n 另外针对已经是 ref 的值不需要重复 new 操作，直接返回原 ref。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17  // ref  export function ref(value?: unknown) { return createRef(value); } // shallow ref export function shallowRef(value?: unknown) { return createRef(value, true) } // createRef(rawValue, shallow = false) function createRef(rawValue: unknown, shallow = false) { if (isRef(rawValue)) { return rawValue } return new RefImpl(rawValue, shallow) }     参数：\n  val 需要进行 ref 化的变量\n  shallow 如果 val 是对象的时候决定是否需要对该对象进行递归 reactive 化\n   看下 ref 结构模板类： RefImpl\u0026lt;T\u0026gt;\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23  class RefImpl\u0026lt;T\u0026gt; { private _value: T public readonly __v_isRef = true constructor(private _rawValue: T, public readonly _shallow = false) { this._value = _shallow ? _rawValue : convert(_rawValue) } get value() { track(toRaw(this), TrackOpTypes.GET, \u0026#39;value\u0026#39;) return this._value } set value(newVal) { if (hasChanged(toRaw(newVal), this._rawValue)) { this._rawValue = newVal this._value = this._shallow ? newVal : convert(newVal) trigger(toRaw(this), TriggerOpTypes.SET, \u0026#39;value\u0026#39;, newVal) } } }     代码是相当简单的，四个属性(_value/__v_isRef/_rawValue/_shallow)+两个访问器方法 (value getter/setter)。\n 根据 es6 class 语法，构造参数如果使用了权限修饰符会自动转成成员属性，所以 _rawValue 和 _shallow 也是 RefImpl 成员属性和 _value 是一样的，区别在于这 两个值可以通过外部控制。\n  开始测试吧：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64  // 源文件：/js/vue/lib.js const { rt: { ref, shallowRef, effect, reactive }, f, log, } = require(process.env.BLOG_JS + \u0026#34;/vue/lib.js\u0026#34;); const a = ref(1); log(\u0026#34;1. base usage \u0026gt;\u0026gt;\u0026gt;\u0026#34;); log([\u0026#34;before, a.value = \u0026#34;, a.value]); a.value = 2; log([\u0026#34;after, a.value = \u0026#34;, a.value]); log(\u0026#34;\\n2. should be reactive \u0026gt;\u0026gt;\u0026gt;\u0026#34;); log(\u0026#34;ge/set value 里面使用的是 track/trigger\u0026#34;); let dummy, calls = 0; effect(() =\u0026gt; { calls++; dummy = a.value; }); log(`before set a.value, dummy=${dummy}, calls=${calls}`); a.value = 3; log(`after set a.value, dummy=${dummy}, calls=${calls}`); log(\u0026#34;\\n3. 默认情况下对嵌套对象属性进行 reactive \u0026gt;\u0026gt;\u0026gt;\u0026#34;); const b = ref({ count: 1 }); effect(() =\u0026gt; (dummy = b.value.count)); log(\u0026#34;before set, dummy = ${dummy}\u0026#34;); log(\u0026#34;after set, dummy = ${dummy}\u0026#34;); log(\u0026#34;\\n4. ref() 不传值的时候也应该可以工作\u0026#34;); const c = ref(); // 简单的赋值操作，给什么值都可以 effect(() =\u0026gt; (dummy = c.value)); log(`before set, dummy = ${dummy}`); c.value = 100; log(`after set, dummy = ${dummy}`); // 当嵌套在一个多层级的对象里的时候 // 因为 ref() 返回的是个对象，所以放在对象里面本质上操作的还是 // ref 本身 log(\u0026#34;\\n5. ref 作为多级对象的值时\u0026#34;); const d = ref(1); const obj = reactive({ d, b: { c: d }, }); let dummy1, dummy2; effect(() =\u0026gt; { dummy1 = obj.d; dummy2 = obj.b.c; }); log(`before set, dummy1=${dummy1}, dummy2=${dummy2}`); d.value++; log(`d.value++, dummy1=${dummy1}, dummy2=${dummy2}`); // 注意这里直接针对 ref 进行赋值操作而不是obj.d.value++ // 这样也是可以的，因为 set proxy 里面有检测该属性是不是 ref // 如果是 Ref 会转变成对 obj.d.value++ 也就是说 vue 内部帮 // 我们这么做了，下面对 obj.b.c++ 同 obj.d++; log(`obj.d++, dummy1=${dummy1}, dummy2=${dummy2}`); obj.b.c++; log(`obj.b.c++, dummy1=${dummy1}, dummy2=${dummy2}`);    1. base usage \u0026gt;\u0026gt;\u0026gt; before, a.value = 1 after, a.value = 2 2. should be reactive \u0026gt;\u0026gt;\u0026gt; ge/set value 里面使用的是 track/trigger before set a.value, dummy=2, calls=1 after set a.value, dummy=3, calls=2 3. 默认情况下对嵌套对象属性进行 reactive \u0026gt;\u0026gt;\u0026gt; before set, dummy = ${dummy} after set, dummy = ${dummy} 4. ref() 不传值的时候也应该可以工作 before set, dummy = undefined after set, dummy = 100 5. ref 作为多级对象的值时 before set, dummy1=1, dummy2=1 d.value++, dummy1=2, dummy2=2 obj.d++, dummy1=3, dummy2=3 obj.b.c++, dummy1=4, dummy2=4 undefined   测试分析：\n  基本使用\n ref 实现基于 effect 的 track 和 trigger\n get value 实现\n1 2 3 4 5 6 7 8  class RefImpl { // ...  get value() { track(toRaw(this), TrackOpTypes.GET, \u0026#34;value\u0026#34;); return this._value; } // ... }     set value 实现\n1 2 3 4 5 6 7 8 9 10 11 12 13  class RefImpl { set value(newVal) { if (hasChanged(toRaw(newVal), this._rawValue)) { this._rawValue = newVal; // convert() 检测 newVal 是对象就调用 reactive  // 注意这里只是简单的赋值操作，所以 ref 可以接受任意类型的值  this._value = this._shallow ? newVal : convert(newVal); // trigger 触发 value 属性上的依赖进行  // 因为 track 也是在这个属性上进行收集的  trigger(toRaw(this), TriggerOpTypes.SET, \u0026#34;value\u0026#34;, newVal); } } }      should be reactive\n 这个在 1 列出了 get value 源码，结合 track/trigger 达到 reactive 目的。\n  这一点直接看源码 set value(newVal)\n this._value = this._shallow ? newVal : convert(newVal)\n convert() 针对对象 reactive\n  因为 new RefImpl(rawValue, shallow) 是简单的赋值操作，给啥值都行\n  因为 new RefImpl(rawValue, shallow) 返回的是个 RefImpl 实例对象，属于引用类 型，不管对象层级多深，最终引用的都是这个对象。\n    object ref   对对象的所有属性进行 ref 化，在进行 proxy ref 之前需要先完成这部分，因为它依赖 object ref。\n   function 描述     toRefs(object) ref对象的所有属性   ObjectRefImpl 对象 ref 模板   toRef(object, key) 针对 object[key] 进行 ref     相关源码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35  class ObjectRefImpl\u0026lt;T extends object, K extends keyof T\u0026gt; { public readonly __v_isRef = true constructor(private readonly _object: T, private readonly _key: K) {} get value() { return this._object[this._key] } set value(newVal) { this._object[this._key] = newVal } } // ref object 属性的 export function toRef\u0026lt;T extends object, K extends keyof T\u0026gt;( object: T, key: K ): ToRef\u0026lt;T[K]\u0026gt; { return isRef(object[key]) ? object[key] : (new ObjectRefImpl(object, key) as any) } // ref object 所有属性 export function toRefs\u0026lt;T extends object\u0026gt;(object: T): ToRefs\u0026lt;T\u0026gt; { if (__DEV__ \u0026amp;\u0026amp; !isProxy(object)) { console.warn(`toRefs() expects a reactive object but received a plain one.`) } const ret: any = isArray(object) ? new Array(object.length) : {} for (const key in object) { ret[key] = toRef(object, key) } return ret }     源码分析 ： ObjectRefImpl 中针对每个 object[key] 持有了一份 object 引 用 _object, 且在最开始 new 实例的时候将属性名保存到了 _key，后续取值设值用的都 是这个值，然后重写了 getter/setter 函数，在取值设值的时候操作 _object + _key 。\n 打个比方：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31  // 原始对象 const rawObj = { count: 0 }; // toRef(rawObj, \u0026#39;count\u0026#39;) 之后 const reffed = { _key: \u0026#34;count\u0026#34;, _object: rawObj, get value() { return this._object[this._key]; }, set value(newVal) { this._object[this._key] = newVal; }, }; // 然后当你改变 reffed.value 值时实际上是在改变 rawObj.count 的值 console.log(`before set, rawObj.count = ${rawObj.count}`) reffed.value = 100 console.log(`after set, rawObj.count = ${rawObj.count}`) // toRefs(rawObj) 就是对所有属性进行 toRef()，然后将返回的值用 // 同样的 key 组成新的对象返回 // 如: 沿用上面的测试 // toRefs(rawObj) 等于是返回了一个全新的对象这个对象内容为： const reffedObj = { count: reffed } // 随后我们直接通过修改 reffedObj.count 来间接操作 rawObj 对象里属性的值 console.log(\u0026#39;before set on obj, rawObj.count = \u0026#39; + rawObj.count) reffedObj.count.value = 200 console.log(\u0026#39;after set on obj, rawObj.count = \u0026#39; + rawObj.count)    before set, rawObj.count = 0 after set, rawObj.count = 100 before set on obj, rawObj.count = 100 after set on obj, rawObj.count = 200 undefined   看到没，实际都是改变了 rawObj.count\n 所以, object ref 等于是创建了一个全新的对象里面包含的属性和 raw object 属性名一 致，但是值是 ObjectRefImpl 创建的实例，用来间接操作 raw object 。\n  测试：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19  // 源文件：/js/vue/lib.js const { rc: { effect, reactive, ref, toRef, proxyRefs, toRefs }, f, log } = require(process.env.BLOG_JS + \u0026#39;/vue/lib.js\u0026#39;) const objRef = ref({ count: 0 }) let dummy effect(() =\u0026gt; { dummy = objRef.value.count }) // proxyRefs(objRef)  log(\u0026#39;\u0026gt;\u0026gt;\u0026gt; ref 基本用法\u0026#39;) log(`1. dummy = ${dummy}`) objRef.value.count++ log(`2. dummy = ${dummy}`) log(\u0026#39;\u0026gt;\u0026gt;\u0026gt; toRef 用法，ref 对象属性\u0026#39;) const a = reactive({ x: 1 }) const x = toRef(a, \u0026#39;x\u0026#39;)      ref proxy   作用：代理 ref 遍历的 get/set 操作，让 get 在返回之前先 unref(result) 得到原始 的值返回，让 set 在 set 之前确保设值的值是在 ref.value 上。\n 和 ref proxy 有关的函数和属性:\n   function 描述     shallowUnwrapHandlers { get, set } 代理的 handler   proxyRefs(objectWithRefs) 代理 ref 对象     源码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21  // proxy handler const shallowUnwrapHandlers: ProxyHandler\u0026lt;any\u0026gt; = { get: (target, key, receiver) =\u0026gt; unref(Reflect.get(target, key, receiver)), set: (target, key, value, receiver) =\u0026gt; { const oldValue = target[key]; if (isRef(oldValue) \u0026amp;\u0026amp; !isRef(value)) { oldValue.value = value; return true; } else { return Reflect.set(target, key, value, receiver); } }, }; export function proxyRefs\u0026lt;T extends object\u0026gt;( objectWithRefs: T ): ShallowUnwrapRef\u0026lt;T\u0026gt; { return isReactive(objectWithRefs) ? objectWithRefs : new Proxy(objectWithRefs, shallowUnwrapHandlers); }     ref proxy 作用：针对被 ref 的 object 对象，进行 get 和 set 操作代理。\n get 操作， Reflect.get(...) 拿到的是个 unref，通过 proxy get handler 去 ref 化， 返回其原始值。\n set 操作， Reflect.set(...) 新值是 ref 直接覆盖之前的 target[key] 值，如果不是 ref，将其设置到 oldValue.value 上。\n 测试：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19  // 源文件：/js/vue/lib.js const { rc: { effect, reactive, ref, toRef, proxyRefs, toRefs }, f, log } = require(process.env.BLOG_JS + \u0026#39;/vue/lib.js\u0026#39;) const objRef = ref({ count: 0 }) let dummy effect(() =\u0026gt; { dummy = objRef.value.count }) // proxyRefs(objRef)  log(\u0026#39;\u0026gt;\u0026gt;\u0026gt; ref 基本用法\u0026#39;) log(`1. dummy = ${dummy}`) objRef.value.count++ log(`2. dummy = ${dummy}`) log(\u0026#39;\u0026gt;\u0026gt;\u0026gt; toRef 用法，ref 对象属性\u0026#39;) const a = reactive({ x: 1 }) const x = toRef(a, \u0026#39;x\u0026#39;)    \u0026gt;\u0026gt;\u0026gt; before proxy 1. dummy = 0 2. dummy = 1 undefined    custom ref   相关函数和类：\n   function 描述     CustomRefImpl 自定义的 ref 模板   customRef(factory) 自定义 ref，即由外部决定如何实现 getter \u0026amp; settter value     让使用者自定义以什么方式在 get 的时候 track 或 set 的时候 trigger\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31  export type CustomRefFactory\u0026lt;T\u0026gt; = ( track: () =\u0026gt; void, trigger: () =\u0026gt; void ) =\u0026gt; { get: () =\u0026gt; T; set: (value: T) =\u0026gt; void; }; class CustomRefImpl\u0026lt;T\u0026gt; { private readonly _get: ReturnType\u0026lt;CustomRefFactory\u0026lt;T\u0026gt;\u0026gt;[\u0026#34;get\u0026#34;]; private readonly _set: ReturnType\u0026lt;CustomRefFactory\u0026lt;T\u0026gt;\u0026gt;[\u0026#34;set\u0026#34;]; public readonly __v_isRef = true; constructor(factory: CustomRefFactory\u0026lt;T\u0026gt;) { const { get, set } = factory( () =\u0026gt; track(this, TrackOpTypes.GET, \u0026#34;value\u0026#34;), () =\u0026gt; trigger(this, TriggerOpTypes.SET, \u0026#34;value\u0026#34;) ); this._get = get; this._set = set; } get value() { return this._get(); } set value(newVal) { this._set(newVal); } }     就是我只负责给你构造一个 Ref 结构的对象，至于什么 get 和 set 怎么实现全权交给使 用者，get/set 默认 track/trigger value 属性。\n 测试:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32  // 源文件：/js/vue/lib.js const { rc: { reactive, toRefs, customRef, effect, isRef }, f, log, } = require(process.env.BLOG_JS + \u0026#34;/vue/lib.js\u0026#34;); let value = 1; let _trigger; const custom = customRef((track, trigger) =\u0026gt; ({ get() { track(); return value; }, set(newValue) { value = newValue; _trigger = trigger; }, })); log(\u0026#39;custom is ref, \u0026#39; + isRef(custom)) let dummy effect(() =\u0026gt; { dummy = custom.value }) log(\u0026#39;dummy = \u0026#39; + dummy) custom.value = 2 // 这个时候还不会触发依赖更新，因为 trigger 并没有执行 // 只是缓存到了 _trigger 上 _trigger() // 手动触发 effects log(\u0026#39;dummy = \u0026#39; + dummy)    custom is ref, true dummy = 1 dummy = 2 undefined    辅助函数     function desc     isRef(value) 检测 value.__v_isRef 值   triggerRef(ref) 手动触发 ref value 上的依赖   unref(ref) 返回 ref.value 值        jest 🏃跑🏃用例  除了 runtime-dom 没实现的部分，都通过了测试。\n@vue/runtime-dom (guessing \u0026#39;runtimeDom\u0026#39;) created packages/vue/dist/vue.global.js in 1.4s FAIL packages/reactivity/__tests__/effect.spec.ts ● Test suite failed to run packages/reactivity/__tests__/ref.spec.ts:11:26 - error TS2307: Cannot find module \u0026#39;@vue/runtime-dom\u0026#39; or its corresponding type declarations. 11 import { computed } from \u0026#39;@vue/runtime-dom\u0026#39; ~~~~~~~~~~~~~~~~~~ PASS packages/reactivity/__tests__/reactive.spec.ts PASS packages/reactivity/__tests__/collections/Set.spec.ts PASS packages/reactivity/__tests__/collections/Map.spec.ts PASS packages/reactivity/__tests__/reactiveArray.spec.ts PASS packages/reactivity/__tests__/collections/WeakMap.spec.ts PASS packages/reactivity/__tests__/collections/WeakSet.spec.ts PASS packages/reactivity/__tests__/shallowReactive.spec.ts PASS packages/reactivity/__tests__/readonly.spec.ts FAIL packages/reactivity/__tests__/ref.spec.ts ● Test suite failed to run Configuration error: Could not locate module @vue/runtime-dom mapped as: /Users/simon/github/vue/stb-vue-next/packages/$1/src. Please check your configuration for these entries: { \u0026#34;moduleNameMapper\u0026#34;: { \u0026#34;/^@vue\\/(.*?)$/\u0026#34;: \u0026#34;/Users/simon/github/vue/stb-vue-next/packages/$1/src\u0026#34; }, \u0026#34;resolver\u0026#34;: undefined } 2 | ref, 3 | effect, \u0026gt; 4 | reactive, | ^ 5 | isRef, 6 | toRef, 7 | toRefs, at createNoMappedModuleFoundError (node_modules/jest-resolve/build/index.js:551:17) at Object.\u0026lt;anonymous\u0026gt; (packages/reactivity/__tests__/ref.spec.ts:4:23) PASS packages/reactivity/__tests__/computed.spec.ts Test Suites: 2 failed, 9 passed, 11 total Tests: 169 passed, 169 total Snapshots: 0 total Time: 15.568 s    用例分析  Map.spec.ts   instanceof\n1 2 3 4 5 6 7  test(\u0026#39;instanceof\u0026#39;, () =\u0026gt; { const original = new Map() const observed = reactive(original) expect(isReactive(observed)).toBe(true) expect(original instanceof Map).toBe(true) expect(observed instanceof Map).toBe(true) })     测试：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14  const { isReactive, effect, reactive, targetMap, shallowReactive } = require(process.env.PWD + \u0026#39;/../../static/js/vue/reactivity.global.js\u0026#39;) const map = new Map() const ob = reactive(map) console.log(`#1 ob is reactive, ${isReactive(ob)}`) console.log(`#2 ${map instanceof Map}`) console.log(`#3 ${ob instanceof Map}`) console.log(map, ob)     +RESULTS:\n#1 ob is reactive, true #2 true #3 true Map(0) {} Map(0) {}   should observe mutations(应该观察变化)\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  it(\u0026#39;should observe mutations\u0026#39;, () =\u0026gt; { let dummy const map = reactive(new Map()) effect(() =\u0026gt; { dummy = map.get(\u0026#39;key\u0026#39;) }) expect(dummy).toBe(undefined) map.set(\u0026#39;key\u0026#39;, \u0026#39;value\u0026#39;) expect(dummy).toBe(\u0026#39;value\u0026#39;) map.set(\u0026#39;key\u0026#39;, \u0026#39;value2\u0026#39;) expect(dummy).toBe(\u0026#39;value2\u0026#39;) map.delete(\u0026#39;key\u0026#39;) expect(dummy).toBe(undefined) })     测试:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21  const { isReactive, effect, reactive, targetMap, shallowReactive } = require(process.env.PWD + \u0026#39;/../../static/js/vue/reactivity.global.js\u0026#39;) let dummy const map = reactive(new Map()) effect(() =\u0026gt; { dummy = map.get(\u0026#39;key\u0026#39;) }) console.log(`#1 dummy = ${dummy}`) map.set(\u0026#39;key\u0026#39;, \u0026#39;value\u0026#39;) console.log(`#2 dummy = ${dummy}`) map.set(\u0026#39;key\u0026#39;, \u0026#39;value2\u0026#39;) console.log(`#3 dummy = ${dummy}`) map.delete(\u0026#39;key\u0026#39;) console.log(`#4 dummy = ${dummy}`)     +RESULTS:\n#1 dummy = undefined #2 dummy = value // set 触发 trigger effect fn #3 dummy = value2 // 同上 #4 dummy = undefined // 删除触发 DELETE trigger 与该   #4 属性的 ADD | DELETE | SET 操作首先会将所有与该 key 有关的依赖添加到将执行序列。\n1 2 3 4  // SET | ADD | DELETE operation  if (key !== void 0) { add(depsMap.get(key)) }     should observe mutations with observed value as key\n 将 reactive 类型的值作为 key 的时候也应该能被观察变化。\n    computed.spec.ts   下面所有的用例都可以参考 用例 01 的脑图(原理图)\nshould return updated value  1 2 3 4 5 6 7  it(\u0026#39;should return updated value\u0026#39;, () =\u0026gt; { const value = reactive\u0026lt;{ foo?: number }\u0026gt;({}) const cValue = computed(() =\u0026gt; value.foo) expect(cValue.value).toBe(undefined) value.foo = 1 expect(cValue.value).toBe(1) })     测试：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14  const { isReactive, effect, reactive, targetMap, shallowReactive, computed } = require(process.env.PWD + \u0026#39;/../../static/js/vue/reactivity.global.js\u0026#39;) const value = reactive({}) const cValue = computed(() =\u0026gt; value.foo) console.log(`#1 before set value.foo, cValue.value = ${cValue.value}`) value.foo = 1 console.log(`#2 after set value.foo, cValue.value = ${cValue.value}`)     +RESULTS:\n#1 before set value.foo, cValue.value = undefined #2 after set value.foo, cValue.value = 1   分析结果\n #1 : 因为 computed 默认是 effect lazy 的，所以不会立即执行 effect，所以 cValue 也就不会有值\n #2 : 此时值为 1，并不是因为 value.foo = 1 触发的 effect 执行，\n 而是因为 _dirty 默认是 true 的，所以在 #1 处取值的时候触发了 effect() 执行， _dirty = false 了，值结果已出。\n1 2 3 4 5 6 7 8  get value() { if (this._dirty) { this._value = this.effect() this._dirty = false } track(toRaw(this), TrackOpTypes.GET, \u0026#39;value\u0026#39;) return this._value }     也正是由于 effect 的执行，让 value.foo 收集到了这个依赖。\n 随后设置 value.foo 也会将 computed effect 执行，由于 options 中提供了 scheduler，所以会执行置 _dirty = true ，但是此时计算属性值并不会立即计算得出 结果(因为它的计算操作始终是在 get value() 里面发生的)，所有当下次取值操作(即 #2 行执行时)，检测到 _dirty = true 了才会重新计算返回最新结果。\n 用例脑图：\n   should compute lazily  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28  it(\u0026#39;should compute lazily\u0026#39;, () =\u0026gt; { const value = reactive\u0026lt;{ foo?: number }\u0026gt;({}) const getter = jest.fn(() =\u0026gt; value.foo) const cValue = computed(getter) // lazy  expect(getter).not.toHaveBeenCalled() expect(cValue.value).toBe(undefined) expect(getter).toHaveBeenCalledTimes(1) // should not compute again  cValue.value expect(getter).toHaveBeenCalledTimes(1) // should not compute until needed  value.foo = 1 expect(getter).toHaveBeenCalledTimes(1) // now it should compute  expect(cValue.value).toBe(1) expect(getter).toHaveBeenCalledTimes(2) // should not compute again  cValue.value expect(getter).toHaveBeenCalledTimes(2) })     测试：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37  const { isReactive, effect, reactive, targetMap, shallowReactive, computed } = require(process.env.PWD + \u0026#39;/../../static/js/vue/reactivity.global.js\u0026#39;) const value = reactive({}) let n = 0 const getter = () =\u0026gt; { ++n return value.foo } const cValue = computed(getter) // lazy console.log(`#1 before get value, getter called ${n}times.`) console.log(`#2 get value(), cValue.value = ${cValue.value}`) console.log(`#3 after get value, getter called ${n}times`) // 不该重复计算，因为 _dirty 在 #3 之后值为 false cValue.value console.log(`#4 after get value 2, getter called ${n}times`) // 触发 cValue 的 effect 执行 scheduler，使得 _dirty = true value.foo = 1 // trigger effect // 因为上面赋值操作只是让 _dirty = true 了，并没有立即重新计算 // 因为计算属性的结果总是在 get value() 操作中完成的 console.log(`#5 after set \u0026#39;value.foo = 1\u0026#39;, getter called ${n}times`) // 这里进行取值操作，正式发起重新计算 console.log(`#6 should re-compute value, getter called ${n}times, cValue.value = ${cValue.value}`) // #6 重新计算后 _dirty 又变成了 false，所以现在取值不会再重新计算 cValue.value console.log(`#7 should not re-compute value, getter called ${n}times, cValue.value = ${cValue.value}`)     +RESULTS: 分析如代码注释\n#1 before get value, getter called 0 times. #2 get value(), cValue.value = undefined #3 after get value, getter called 1 times #4 after get value 2, getter called 1 times #5 after set \u0026#39;value.foo = 1\u0026#39;, getter called 1 times #6 should re-compute value, getter called 1 times, cValue.value = 1 #7 should not re-compute value, getter called 2 times, cValue.value = 1   Tips: 总是记着计算属性重新计算的关键点：“_dirty = true 且随后的取值操作”。\n   should no longer update when stopped  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  it(\u0026#39;should no longer update when stopped\u0026#39;, () =\u0026gt; { const value = reactive\u0026lt;{ foo?: number }\u0026gt;({}) const cValue = computed(() =\u0026gt; value.foo) let dummy effect(() =\u0026gt; { dummy = cValue.value }) expect(dummy).toBe(undefined) value.foo = 1 expect(dummy).toBe(1) stop(cValue.effect) value.foo = 2 expect(dummy).toBe(1) })     测试：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28  const { isReactive, effect, reactive, targetMap, shallowReactive, computed, stop } = require(process.env.PWD + \u0026#39;/../../static/js/vue/reactivity.global.js\u0026#39;) const value = reactive({}) const cValue = computed(() =\u0026gt; value.foo) let dummy effect(() =\u0026gt; { dummy = cValue.value }) console.log(`before set value, dummy = ${dummy}`) value.foo = 1 console.log(`after set value, dummy = ${dummy}`) // 停止了 effect.active = false，在执行 effect fn 的时候 // 会检测 active 如果是 false 会直接执行： // options.scheduler ? undefined : fn() // 而由于计算属性是默认提供了 scheduler 的，所以在 stop 之后 // effect 就不会被执行 stop(cValue.effect) value.foo = 2 console.log(`after stop and set value, dummy = ${dummy}`)     +RESULTS:\nbefore set value, dummy = undefined after set value, dummy = 1 after stop and set value, dummy = 1    TODO should support setter  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17  it(\u0026#39;should support setter\u0026#39;, () =\u0026gt; { const n = ref(1) const plusOne = computed({ get: () =\u0026gt; n.value + 1, set: val =\u0026gt; { n.value = val - 1 } }) expect(plusOne.value).toBe(2) n.value++ expect(plusOne.value).toBe(3) plusOne.value = 0 expect(n.value).toBe(-1) })      should be readonly   只读版本，是有 computed 使用的时候传入的参数(option)决定的。\n  如果 option 是函数(getter) 那就是只读的\n  如果 option 是对象且提供了 option.set 那么是非只读\n  如果 option 是对象但是没有提供 option.set 那么也是只读的\n  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18  it(\u0026#39;should be readonly\u0026#39;, () =\u0026gt; { let a = { a: 1 } const x = computed(() =\u0026gt; a) expect(isReadonly(x)).toBe(true) expect(isReadonly(x.value)).toBe(false) expect(isReadonly(x.value.a)).toBe(false) const z = computed\u0026lt;typeof a\u0026gt;({ get() { return a }, set(v) { a = v } }) expect(isReadonly(z)).toBe(false) expect(isReadonly(z.value.a)).toBe(false) })     测试：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26  const { isReactive, isReadonly, effect, reactive, targetMap, shallowReactive, computed } = require(process.env.PWD + \u0026#39;/../../static/js/vue/reactivity.global.js\u0026#39;) const a = { a: 1 } const x = computed(() =\u0026gt; a) console.log(`#1 x is readonly, ${isReadonly(x)}`) // true console.log(`#2 x.value is readonly, ${isReadonly(x.value)}`) console.log(`#3 x.value.a is readonly, ${isReadonly(x.value.a)}`) const z = computed({ get() { return a }, set(v) { a = v } }) console.log(`#4 z is readonly, ${isReadonly(z)}`) console.log(`#5 z.value.a is readonly, ${isReadonly(z.value.a)}`)     +RESULTS:\n#1 x is readonly, true #2 x.value is readonly, false #3 x.value.a is readonly, false #4 z is readonly, false #5 z.value.a is readonly, false      effect.ts  effect + track + trigger   commit: feat: effect-trigger · gcclll/stb-vue-next@b5f97b4\n  lazy: true 标识 effect fn 不会立即执行\n  点击 set 操作，此时并没有依赖，所以只会触发 count++\n  当点击 get 操作，触发 track() 收集依赖 fn -\u0026gt; deps\n  再点击 set 操作，此时已经有依赖，所以会 trigger() 所有依赖更新\n  options.scheduler 选项作用\n 如果 options 有 scheduler 选项， trigger() 的时候不会立即执行 effects 而是 调用 scheduler 并将当前需要被执行的 effect 当做参数给 scheduler，由使用者决定 何时去执行 effect，比如需要在 dummy 更新之前做点什么。\n   #_effect_test_02.box { display: flex; justify-content: space-around; } #_effect_test_02.boxbutton{ border: none; width: 250px; }  点我触发 get操作！ 点我触发 set操作！  手动调用 scheduler 之前 手动调用 scheduler 之后  点击查看测试源码 重置     setTimeout(function test() { if (typeof $ === 'undefined') return var ins = VueReactivity var effect = ins.effect var reactive = ins.reactive var target = { count: 0 } var counter = reactive(target) var $el = $(\"#_effect_test_02\") var LOG = function (msg) { _log($el, msg) } var lazyEffect = effect( function fn() { var c = counter.count LOG('正在执行 effect fn..., counter.count = ' + counter.count) }, { lazy: true } ) var effected = false var getDeps = function () { if (!ins.targetMap) return new Set() const depsMap = ins.targetMap.get(target) || new Map() return depsMap.get('count') || new Set() } $el.find(\".setval\").click(function() { counter.count++ var size = getDeps().size if (size === 0) { LOG('target 此时无任何依赖，deps.size = ' + size + ', counter.count = ' + counter.count) } }) $el.find(\".reset\").click(function() { ins.cleanup(lazyEffect) $el.children(\".result\").html('') effected = false counter.count = 0 dummy = 0 runner = undefined times = 0 LOG('target.count deps.size = ' + getDeps().size) }) $el.find(\".getval\").click(function() { if (!effected) { effected = true lazyEffect() // 手动执行 effect LOG('手动执行 effect()，开始收集依赖 fn - deps, size: ' + getDeps().size) } LOG('取值操作(target.count 的 deps 数)：' + ins.targetMap.get(target).get('count').size + ', counter.count = ' + counter.count) }) $el.find('.code').click(function() { console.log($(\"#GW0MDx\").html()) LOG('源码已输出到控制台(F12-console)....') }) var dummy = 0, runner var counter1 = reactive({ count: 0 }) var times = 0 var schedulerEffect = effect(function fn() { dummy = counter1.count }, { scheduler: function(_effect) { LOG('scheduler 执行次数 ' + ++times + ', dummy = ' + dummy) runner = function() { _effect() } } }) LOG('scheduler effect fn 第一次会被执行， dummy = ' + dummy) $el.find('.before-scheduler').click(function() { LOG('scheduler 不会被执行, dummy = ' + dummy) }) $el.find('.after-scheduler').click(function() { counter1.count++ runner() }) }, 1000)        effect 测试  测试1(base, prototype)   测试内容：\n  effect 基本使用\n  effect 作用域原型链\n  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47  // 只执行一次 effect fn const { isReactive, effect, reactive, targetMap, shallowReactive } = require(process.env.PWD + \u0026#39;/../../static/js/vue/reactivity.global.js\u0026#39;) // 基本的测试用例就不列出来了，这里只列出有疑问的 // 1. effect fn 只执行一次 // 2. observe 基本属性 // 3. observe 多个属性(n1,n2...) -\u0026gt; effect(() =\u0026gt; (dummy = obj.n1 + obj.n2)) // 4. 同一个属性多个 effect，会将这多个 effects 收集到 prop 的 deps 中 // 5. observe 属性删除 let dummy, dummy1, dummy2 const ob = reactive({ foo: { bar: 0 } }) effect(() =\u0026gt; (dummy = ob.foo.bar)) // effect -\u0026gt; ob, ob.foo, ob.foo.bar deps effect(() =\u0026gt; (dummy1 = ob.foo.bar)) console.log(`before set, dummy = ${dummy}, dummy1 = ${dummy1}`) ob.foo.bar = 8 console.log(`after set, dummy = ${dummy}, dummy1 = ${dummy1}`) delete ob.foo.bar console.log(`after delete, dummy = ${dummy}, dummy1 = ${dummy1}`) console.log(`\u0026gt;\u0026gt;\u0026gt; 原型链`) const obj1 = { num: 0 }, obj2 = { num: 2 } const counter = reactive(obj1) const parentCounter = reactive(obj2) // 取值原理： 先自身再往上找原型链，所有只要 Object.setPrototypeOf(counter, parentCounter) effect(() =\u0026gt; (dummy = counter.num)) console.log(`dummy = ${dummy}`) console.log(`\u0026gt; #1 obj1.num 的依赖`) console.log(targetMap.get(obj1).get(\u0026#39;num\u0026#39;)) console.log(`\u0026gt; #2 obj2.num 的依赖, delete 之前`) console.log(targetMap.get(obj2)) delete counter.num // 这里删除了属性，触发 effect fn 里面取值操作发现没有属性了 // 往原型链找，找到 parentCounter.num ，此时 parentCounter.num 收集 effect fn 进自己的 deps // 所以后面的 parentCounter.num 上的操作同样会触发 effect fn console.log(`after delete, dummy = ${dummy}`) console.log(`\u0026gt; #3 obj2.num 的依赖, delete 之后`) console.log(targetMap.get(obj2).get(\u0026#39;num\u0026#39;)) parentCounter.num = 4 console.log(`#4 after \u0026#39;parentCounter.num = 4\u0026#39;, dummy = ${dummy}`) counter.num = 3 console.log(`#5 after counter.num = 3\u0026#39;, dummy = ${dummy}`)     结果分析：\n  #1 obj1.num 依赖是在 effect 第一次执行的时候收集的\n  #2 obj2.num 在执行 delete counter.num 之前是没有任何依赖\n 因为此时并没有任何 parentCounter 上的操作\n  #3 obj2.num 有了自己的依赖\n 此时，执行了 delete counter.num 逻辑如下：\n 对 counter.num 执行删除会触发 num 上的所有依赖 deps，即执行 effect fn，\n 在 effect fn 里面有 counter.num 的取值操作，但是发现属性被删除，根据取值查找 原理，会在对象的原型链上逐级往上查找(parentCounter)，找到 parentCounter.num 随机进行取值操作，所以删除操作之后的 dummy = 2 ，且取值 操作触发 tracking 因此此时 parentCounter.num 就有了自己的依赖 effect fn。\n  #4 给 parentCounter 设值触发 effect fn，查找原型链 , 所以 dummy = 4\n  #5 给 counter 设值触发 effect fn，不查找原型链(自身属性)，所以 dummy = 3\n  +RESULTS:\nbefore set, dummy = 0, dummy1 = 0 after set, dummy = 8, dummy1 = 8 after delete, dummy = undefined, dummy1 = undefined \u0026gt;\u0026gt;\u0026gt; 原型链 dummy = 0 \u0026gt; #1 obj1.num 的依赖 \u0026lt;ref *1\u0026gt; Set(1) { [Function: reactiveEffect] { id: 2, allowRecurse: false, _isEffect: true, active: true, raw: [Function (anonymous)], deps: [ [Circular *1] ], options: {} } } \u0026gt; #2 obj2.num 的依赖, delete 之前 undefined after delete, dummy = 2 \u0026gt; #3 obj2.num 的依赖, delete 之后 \u0026lt;ref *1\u0026gt; Set(1) { [Function: reactiveEffect] { id: 2, allowRecurse: false, _isEffect: true, active: true, raw: [Function (anonymous)], deps: [ [Circular *1], [Set] ], options: {} } } #4 after \u0026#39;parentCounter.num = 4\u0026#39;, dummy = 4 #5 after counter.num = 3\u0026#39;, dummy = 3 undefined    测试2(stop, …)    stop :\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29  const { isReactive, effect, reactive, targetMap, shallowReactive, stop } = require(process.env.PWD + \u0026#39;/../../static/js/vue/reactivity.global.js\u0026#39;) console.log(`\u0026gt;\u0026gt;\u0026gt; stop effect`) let dummy const obj = reactive({ prop: 1 }) const runner = effect(() =\u0026gt; { dummy = obj.prop }) obj.prop = 2 console.log(`#1, after \u0026#39;obj.prop = 2\u0026#39;, dummy = ${dummy}`) console.log(`\u0026gt; prop deps, before stop`) console.log(targetMap.get(obj.__v_raw).get(\u0026#39;prop\u0026#39;)) // 清空了所有依赖  stop(runner) // stop the effect, set effect.active = false  console.log(`\u0026gt; prop deps, after stop`) console.log(targetMap.get(obj.__v_raw).get(\u0026#39;prop\u0026#39;)) obj.prop = 3 console.log(`#2, after stop, \u0026#39;obj.prop = 3\u0026#39;, dummy = ${dummy}`) obj.prop = 4 console.log(`#3, after stop, \u0026#39;obj.prop = 4\u0026#39;, dummy = ${dummy}`) runner() console.log(`#4, after run runner, dummy = ${dummy}, runner.active = ${runner.active}`)     +RESULTS:\n\u0026gt;\u0026gt;\u0026gt; stop effect #1, after \u0026#39;obj.prop = 2\u0026#39;, dummy = 2 \u0026gt; prop deps, before stop \u0026lt;ref *1\u0026gt; Set(1) { [Function: reactiveEffect] { id: 0, allowRecurse: false, _isEffect: true, active: true, raw: [Function (anonymous)], deps: [ [Circular *1] ], options: {} } } \u0026gt; prop deps, after stop Set(0) {} #2, after stop, \u0026#39;obj.prop = 3\u0026#39;, dummy = 2 #3, after stop, \u0026#39;obj.prop = 4\u0026#39;, dummy = 2 #4, after run runner, dummy = 4, runner.active = false undefined    stop 干了两件事(a. 清空所有 effect.deps, b. 将 effect.active 置为 false)\n  stop 之后 trigger 时没有 deps 可执行，所以无论如何 effect fn 不会被执行\n  手动执行 runner() 之后执行effect fn 重新收集依赖(此时 active 依旧为 false)\n    stop + scheduler :\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20  const { isReactive, effect, reactive, targetMap, stop, shallowReactive } = require(process.env.PWD + \u0026#39;/../../static/js/vue/reactivity.global.js\u0026#39;) let dummy const obj = reactive({ prop : 1 }) const queue = [] const runner = effect(() =\u0026gt; (dummy = obj.prop), { scheduler: e =\u0026gt; queue.push(e) }) obj.prop = 2 console.log(`#1 after \u0026#39;obj.prop = 2\u0026#39;, dummy = ${dummy}`) console.log(`#2 after \u0026#39;obj.prop = 2\u0026#39;, queue.length = ${queue.length}`) stop(runner) queue.forEach(e =\u0026gt; e()) console.log(`#3 after stop, queue forEach, dummy = ${dummy}`)     +RESULTS:\n#1 after \u0026#39;obj.prop = 2\u0026#39;, dummy = 1 #2 after \u0026#39;obj.prop = 2\u0026#39;, queue.length = 1 #3 after stop, queue forEach, dummy = 1   提供了 scheduler 选项的 effect 永远不会被执行，源码：\n1 2 3  if (!effect.active) { return options.scheduler ? undefined : fn() }      onStop :\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19  const { isReactive, effect, reactive, targetMap, stop, shallowReactive } = require(process.env.PWD + \u0026#39;/../../static/js/vue/reactivity.global.js\u0026#39;) let n = 0 const runner = effect(() =\u0026gt; {}, { onStop() { console.log(`stopped ${++n}times`) } }) stop(runner) stop(runner) stop(runner)     +RESULTS:\nstopped 1 times   只会被执行一次，因为 effect.active = true 时才可以被 stop 。\n  stop: 一个 stopped 的 effect 在一个正常的 effect 中调用\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26  const { isReactive, effect, reactive, targetMap, stop, shallowReactive } = require(process.env.PWD + \u0026#39;/../../static/js/vue/reactivity.global.js\u0026#39;) let dummy const obj = reactive({ prop: 1 }) const runner = effect(() =\u0026gt; { dummy = obj.prop }) stop(runner) obj.prop = 2 console.log(`#1 after stop runner, dummy = ${dummy}`) // 这里等于是手动执行了 runner effect `dummy = obj.prop` // 所以下面的 effect 被 obj.prop 收集进 deps\u0026lt;Set\u0026gt; effect(() =\u0026gt; { runner() }) obj.prop = 3 console.log(`#2 after runner in effect, dummy = ${dummy}`)     +RESULTS:\n#1 after stop runner, dummy = 1 #2 after runner in effect, dummy = 3    #1 值依旧是 1 ，是因为 stop 了\n  #2 值为 3，是因为 effect 执行 runner() 使得 obj.prop 收集到第二个 effect fn 。\n        完整脑图   collection proxy handlers 脑图     effect 脑图       ","permalink":"https://www.cheng92.com/vue/vue-mind-map-reactivity/","tags":["vue,","vue3,","compiler-core,","parser,","compiler"],"title":"Vue3 源码头脑风暴之 1 ☞reactivity"},{"categories":["vue"],"contents":"  诗号：六道同坠，魔劫万千，引渡如来。  \n 🌧 序  ⭐ ⭐ 由于图片是使用 github 做的图床，没有 CDN 加速，且有些图片比较大(可能\n ⭐ ⭐ 快 1M) 加载挺慢的，每张图片都有对应的七牛(但不一定是最新的)链接，可能会快一点。\n ⭐ ⭐ 图片已全部更新到 https://www.cheng92.com/img/... 下\n 😄 更新日志\n  \u0026lt;2020-09-07 Mon\u0026gt; 所有图片修改为 github 地址，后续修改图片可以直接使用，而不 需要上传到七牛。\n  \u0026lt;2020-09-10 Thu\u0026gt; 图床切换到 码云 gitee 自动同步自 github。\n  \u0026lt;2020-09-11 Fri\u0026gt; 更新图片到博客目录 /static/imgs/... ，文内访问路径： /img/vue3/... ，单独访问加上域名就行： https://www.cheng92.com/img/vue3/...\n  \u0026lt;2020-09-28 Mon\u0026gt; 所有脑图修改为 svg 格式，建议通过新 tab 打开，有些节点可能包含链 接。\n    🌩 功能特性分析(parser-\u0026gt;transform-\u0026gt;codegen)   从 compiler-01 开始都是针对某个示例做的分析，但是随时示例的模板复杂度增加，脑图 的大小将越来越大，不堪重负，阅读回顾起来也很费劲，在完成了 compiler-01 - compiler-05 之后对整个分析过程也有了大概的了解，另起这一章节的目的就是为了能单纯 的针对某一特定功能绘制对应的流程图，比如：\n 属性是如何解析的，最后在 render 函数中又是什么？\n 插值？ v-if, v-else, v-for, v-once 等指令又是如何处理的？\n 这一章节的所有脑图，绘制分为以下阶段，如果流程简单多个阶段可能会在同一张脑图上\n  parser 阶段得到完整的 ast\n  compiler 阶段解析 ast 生成节点 codegenNode\n  generate 阶段利用 codegenNode 组装成 render 函数\n  待续……\n    章节预览：\n   功能 简述     div \u0026lt;div\u0026gt;\u0026lt;/div\u0026gt;   attributes,静态属性 \u0026lt;div id=\u0026#34;foo\u0026#34;\u0026gt;\u0026lt;/div\u0026gt;   v-bind \u0026lt;div :class=\u0026#34;bar.baz\u0026#34;\u0026gt;\u0026lt;/div\u0026gt;   interpolation \u0026lt;div\u0026gt;{{ world.burn() }}\u0026lt;/div\u0026gt;   v-if \u0026lt;div\u0026gt;\u0026lt;div v-if=\u0026#34;ok\u0026#34;\u0026gt;yes\u0026lt;/div\u0026gt;\u0026lt;/div\u0026gt;   v-once \u0026lt;div\u0026gt;\u0026lt;p v-once\u0026gt;test v-once\u0026lt;/p\u0026gt;\u0026lt;/div\u0026gt;    DONE 01 div, 纯标签   \u0026lt;div\u0026gt;\u0026lt;/div\u0026gt;\n 结果：\n1 2 3 4 5 6 7 8 9 10 11 12  (function anonymous( ) { const _Vue = Vue return function render(_ctx, _cache) { with (_ctx) { const { createVNode: _createVNode, openBlock: _openBlock, createBlock: _createBlock } = _Vue return (_openBlock(), _createBlock(\u0026#34;div\u0026#34;)) } } })       parser 阶段， parseElement -\u0026gt; parseTag\n   compiler 阶段， transform -\u0026gt; traverseNode -\u0026gt; traverseChildren ，只有 0,ROOT 和 1,ELEMENT 两个类型分支处理。\n   codegen 阶段，只有 div 的 block 处理(_openBlock(), _createBlock(\u0026#34;div\u0026#34;))\n     DONE 02 attributes, 静态属性   \u0026lt;div id=\u0026#34;foo\u0026#34;\u0026gt;\u0026lt;/div\u0026gt;\n  parser 阶段 ：\n 与 pcg-01 相比较，多了左边 parseTag -\u0026gt; parseAttributes -\u0026gt; parseAttribute 解析属 性 id=\u0026#34;foo\u0026#34; 的处理。\n   compiler 阶段：\n 与 pcg-01 相比较，多了 transformElement 中 props 属性的处理，因为这个时候 props.length = 1 里面有一个 id=\u0026#34;foo\u0026#34; 属性，需要去调用 buildProps 解析，成下面 的解构:\n1 2 3 4 5 6 7 8 9 10  { properties: [ { key: { type:4, content: \u0026#34;id\u0026#34;, ...}, // SIMPLE_EXPRESSION  value: {type: 4, content: \u0026#34;foo\u0026#34;, ...}, type: 16 // JS_PROPERTY  } ] type: 15, // JS_OBJECT_EXPRESSION  }       codegen 阶段：\n 在 genNodeList([tag, props, children, …], ctx) 解析的时候，这里 props 不再是 null，因此会进入 Props 解析过程：\n genNode(props, ctx) -\u0026gt; 15,JS_OBJECT_EXPRESSION -\u0026gt; genObjectExpression(node, ctx) -\u0026gt; 遍历 node.properties -\u0026gt; genExpressionPropertyKey(key,ctx) 生成属性 名 { id: ~ -\u0026gt; ~genNode(value, ctx) 生成属性值 -\u0026gt; 4, SIMPLE_EXPRESSION -\u0026gt; genExpression(value, ctx) 生成属性值 { id: \u0026#34;foo\u0026#34;\n     DONE 03 v-bind 指令   \u0026lt;div :class=\u0026#34;bar.baz\u0026#34;\u0026gt;\u0026lt;/div\u0026gt;\n 结果预览：\n1 2 3 4 5 6 7 8 9 10 11 12  (function anonymous( ) { const _Vue = Vue return function render(_ctx, _cache) { with (_ctx) { const { createVNode : _createVNode, openBlock : _openBlock, createBlock : _createBlock } = _Vue return (_openBlock(), _createBlock(\u0026#34;div\u0026#34;, { class: bar.baz }, null, 2 /* CLASS */)) } } })      parser 阶段：\n   compiler 阶段：\n   codegen 阶段：\n     DONE 04 interpolation, 插值   \u0026lt;div\u0026gt;{{ world.burn() }}\u0026lt;/div\u0026gt;\n1 2 3 4 5 6 7 8 9 10 11 12  (function anonymous( ) { const _Vue = Vue return function render(_ctx, _cache) { with (_ctx) { const { toDisplayString : _toDisplayString, createVNode : _createVNode, openBlock : _openBlock, createBlock : _createBlock } = _Vue return (_openBlock(), _createBlock(\u0026#34;div\u0026#34;, null, _toDisplayString(world.burn()), 1 /* TEXT */)) } } })      parser 阶段\n   compiler 阶段\n   codegen 阶段\n     DONE 05 v-if 指令(git:0a591b6)   \u0026lt;div\u0026gt;\u0026lt;div v-if=\u0026#34;ok\u0026#34;\u0026gt;yes\u0026lt;/div\u0026gt;\u0026lt;/div\u0026gt;\n git commit: 0a591b62d6961526b333afeb5f77c532b3992e31\n vue.global:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19  (function anonymous( ) { const _Vue = Vue const { createVNode: _createVNode, createCommentVNode: _createCommentVNode } = _Vue const _hoisted_1 = { key: 0 } return function render(_ctx, _cache) { with (_ctx) { const { createVNode: _createVNode, openBlock: _openBlock, createBlock: _createBlock, createCommentVNode: _createCommentVNode } = _Vue return (_openBlock(), _createBlock(\u0026#34;div\u0026#34;, null, [ ok ? (_openBlock(), _createBlock(\u0026#34;div\u0026#34;, _hoisted_1, \u0026#34;yes\u0026#34;)) : _createCommentVNode(\u0026#34;v-if\u0026#34;, true) ])) } } })     差异点：\n  少了全局作用域下的 _Vue 解构\n  key 没有 hoisted\n  脑图列表：\n  parser 阶段\n   compiler 阶段\n   codegen 阶段\n   拓展 1：v-if-else 指令   \u0026lt;div\u0026gt;\u0026lt;div v-if=\u0026#34;ok\u0026#34;\u0026gt;yes\u0026lt;/div\u0026gt;\u0026lt;div v-else\u0026gt;no\u0026lt;/div\u0026gt;\u0026lt;/div\u0026gt;\n vue.global:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20  (function anonymous( ) { const _Vue = Vue const { createVNode: _createVNode, createCommentVNode: _createCommentVNode } = _Vue const _hoisted_1 = { key: 0 } const _hoisted_2 = { key: 1 } return function render(_ctx, _cache) { with (_ctx) { const { createVNode: _createVNode, openBlock: _openBlock, createBlock: _createBlock, createCommentVNode: _createCommentVNode } = _Vue return (_openBlock(), _createBlock(\u0026#34;div\u0026#34;, null, [ ok ? (_openBlock(), _createBlock(\u0026#34;div\u0026#34;, _hoisted_1, \u0026#34;yes\u0026#34;)) : (_openBlock(), _createBlock(\u0026#34;div\u0026#34;, _hoisted_2, \u0026#34;no\u0026#34;)) ])) } } })     与 pcg-05 差异：\n1 2 3  ok ? (_openBlock(), _createBlock(\u0026#34;div\u0026#34;, _hoisted_1, \u0026#34;yes\u0026#34;)) : _createCommentVNode(\u0026#34;v-if\u0026#34;, true) // 这里没有 elseif, else 分支会创建一个注释节点      和\n1 2 3  ok ? (_openBlock(), _createBlock(\u0026#34;div\u0026#34;, _hoisted_1, \u0026#34;yes\u0026#34;)) : (_openBlock(), _createBlock(\u0026#34;div\u0026#34;, _hoisted_2, \u0026#34;no\u0026#34;)) // 分支节点      造成这差一点是在哪处理的呢？？？\n v-if 指令的 codegen 过程有三个重要因素：\n  test 生成条件表达式\n  consequent 生成成立条件(ok=true)表达式的\n  alternate 生成失败条件(ok=false)表达式的\n  因此该扩展重点在 alternate 处理 🛬…\n 在 transform 阶段针对 v-else 的处理逻辑：\n traverseNode 中的 exitFns 收集阶段，调用 transformIf 取 transform 函数过程中，有 以下几个重要步骤：\n  遍历当前 v-else 节点的所有兄弟节点(siblings=parent.children)\n  找到当前节点 node 在 siblings 中的位置 i\n  while i-- 依次往前找兄弟节点(如果是 COMMENT 节点，删除保存待恢复，如果是 9,IF 节点即找到的目标节点 sibling)\n  删除当前的 node 同时调用 createIfBranch 创建 10,IF_BRANCH 类型的分支节点结 构，合并到 sibling.branches 中\n  调用 processCodegen 函数即 transformIf 时候执行会得到生成 codegenNode 的那个函数，执行它获取 tranform 函数 exitFn 。\n  手动执行 traverseNode(node, …) 进行递归遍历该 v-else 节点树(因为在 4 中节点 被删除了，因此主递归线上不会出现这个节点，需要手动执行一次 traverse)\n  最后执行 exitFn 生成该 v-else 节点树的 codegenNode 。\n 注意点 ：这一步 v-else 替换 alternate 过程中有个 while 循环用来递归查找非 19,JS_CONDITIONAL_EXPRESSION 类型的节点的 alternate 再进行替换，这么做的原 因是 v-if-else 指令的在 render 函数中是通过三目运算符(?:)实现的，一般情况下 : 后面的是一个 comment vnode 类型占位用，当实际有 else 分支的时候会进行替换， 此时替换需要考虑到表达式嵌套的情况，所以需要找到最后那个 comment vnode ，详细 步骤直接看脑图吧。\n     parser 阶段\n   transform 阶段\n   codegen 阶段\n     拓展 2：v-if-elseif-else 指令    parser 阶段\n 相比较 拓展1：v-if-else 这里只是多了一个 v-else-if 这在 parser 阶段没什么区别， 直接参考拓展 1 的脑图。\n   transform 阶段\n  对比前后结果发现： v-if/v-else-if/v-else 指令体系的实现关键在于 codegenNode 中 三个字段：\n  test ?: 表达式的条件\n  consequent ?: 表达式条件为 true 的时候渲染的节点\n  alternate ?: 表达式条件为 false 的时候渲染的节点\n  如果有多级嵌套的情况，会在 alternate 中体现出来，这里面要么是一个节点结构， 要么是一个完整的包含({ test, consequent, alternate }) 嵌套的表达式结构。\n v-else-if 渲染流程查看特定的功能脑图。\n  codegen 阶段\n       DONE 06 含 v-once 指令模板(git:2d0bab4)   \u0026lt;div\u0026gt;\u0026lt;p v-once\u0026gt;test v-once\u0026lt;/p\u0026gt;\u0026lt;/div\u0026gt;\n 流程图：  git commit: 2d0bab4cfbf3408afe93270d7e9dc8ecd511dbe0\n  parser 阶段没什么不同，最终都是生成指令类型的 ast 树\n  重点在 transform 阶段，先 transformText -\u0026gt; transformElement -\u0026gt; transformOnce 处理\n 经过 transformOnce 之后 codegenNode结果变化，从 13,VNODE_CALL 类型变成了 20,JS_CACHE_EXPRESSION 类型。\n  更新 getBaseTransformPreset\n  实现 transforms/vOnce-\u0026gt;transformOnce\n  buildProps(node, ctx props = node.props, ssr=false) 中忽略属性 v-once 处理， 交给 transformOnce() 处理\n    codegen 阶段的处理，生成 Render 函数，对于 v-once 处理原理是利用缓存机制，第 一次创建节点存储到对应的 context.cache[] 中，后面更新节点时候直接取对应缓存。\n 实现关键函数:\n  genNode\n  genCacheExpression\n      TODO 07 v-for 指令   脑图：  这里将三个阶段合并在一起了， transform 阶段的解析单独放在了 9. transform 阶段如 何转换 v-for 指令？ 这部分和 v-if 解析一样比较复杂，且属于特定的指令解析作为关键 功能进行分析。\n 所以对于 transform 阶段详细实现和脑图请点击上面链接查看内容。\n    ☀ 关键功能   这一章节是针对整个 vue3 源码解构过程中遇到的问题或一些重要或关键的一些功能，进 行提取解读。\nDONE 1. buildProps(node, context) 如何构建 props ?   CLOSED: [2020-09-18 Fri 16:07]\n  State \u0026#34;DONE\u0026#34; from \u0026#34;TODO\u0026#34; [2020-09-18 Fri 16:07]\n   props 在 compile 阶段是如何处理的，是如何从(示例04)\n  变成下面这样的：\n  完整流程：   DONE 2. transformIf() 是如何返回 v-if 指令的 transform 的？   参考用例 05\n v-if 指令是如何转换的？？？\n 这个转换函数又是怎么来的？？？\n 得到这个转换函数过程中做了什么 ？？？\n 通过在 traverseNode 中， switch node 阶段之前，收集 transform 函数到 exitFns[] 中的时候，如果遇到了 v-if 指令的元素，会执行 transformIf ，这个时候会遍历解析 node.props 拿到这个 v-if 指令属性，调用 processIf 将该节点转换成\n1 2 3 4  { branches: [branch], type: 9 // IF  }     并且用这个新生成的节点结构去替换原来的 div v-if 节点结构。\n 即：在拿到 transform if 函数之前 div v-if 节点结构已经发生了变化，成为了\n type = 9 的结构，最后原来的节点成为了 branches 的元素。\n 并且原节点的 props 会被清空(避免回溯的时候重复处理)。\n  transformIf:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28  const transformIf = createStructuralDirectiveTransform( /^(if|else|else-if)$/, (node, dir, context) =\u0026gt; { return processIf(node, dir, context, (ifNode, branch, isRoot) =\u0026gt; { // Exit callback. Complete the codegenNode when all children have been  // transformed.  return () =\u0026gt; { // 这个才是真正在回溯过程中调用的 transform if 函数  if (isRoot) { ifNode.codegenNode = createCodegenNodeForBranch(branch, 0, context); } else { // attach this branch\u0026#39;s codegen node to the v-if root.  let parentCondition = ifNode.codegenNode; while ( parentCondition.alternate.type === 19 /* JS_CONDITIONAL_EXPRESSION */ ) { parentCondition = parentCondition.alternate; } parentCondition.alternate = createCodegenNodeForBranch( branch, ifNode.branches.length - 1, context ); } }; }); } );     流程图：   TODO 3. codegen 如何生成属性(_createBLock(tag, props, …))第二个参数？   如：\n1 2 3 4 5 6  // ...  return (_openBlock(), _createBlock(\u0026#39;div\u0026#39;, { id: \u0026#34;foo\u0026#34;, class: bar.baz }))     id 和 class 是如何生成对象的。\n  DONE 4. transform 阶段如何对属性静态提升？  CLOSED: [2020-09-28 Mon 10:55]\n  State \u0026#34;DONE\u0026#34; from \u0026#34;TODO\u0026#34; [2020-09-28 Mon 10:55]\n  没有 hoist 之前：\n1 2 3 4 5  return (_openBlock(), _createBlock(\u0026#34;div\u0026#34;, null, [ ok ? (_openBlock(), _createBlock(\u0026#34;div\u0026#34;, { key: 0 }, \u0026#34;yes\u0026#34;)) : _createCommentVNode(\u0026#34;v-if\u0026#34;, true) ]))     有 hoist 之后：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19  (function anonymous( ) { const _Vue = Vue // ... 省略  // 提升到 render 函数之后  const _hoisted_1 = { key: 0 } return function render(_ctx, _cache) { with (_ctx) { // ... 省略  return (_openBlock(), _createBlock(\u0026#34;div\u0026#34;, null, [ ok ? (_openBlock(), _createBlock(\u0026#34;div\u0026#34;, _hoisted_1, \u0026#34;yes\u0026#34;)) : _createCommentVNode(\u0026#34;v-if\u0026#34;, true) ])) } } })      transform 阶段是在 执行完 traverseNode() 之后调用 hoistStatic(root,context) 通过 walk() 递归遍历 所有的孩子节点来检测满足条件的 hoist 属性或节点。\n 即：静态提升动作发生在所有节点的 codegenNode 解析完毕之后(且满足： options.hoistStatic = true)。\n  codegen 阶段是在 genFunctionPreamable(ast, context) 检测 ast.hoists 数组将需要用 到的函数提升到 render 之外，然后调用 genHoists(ast.hoists) 生成需要提升的属性。\n 最后根据：\n1 2 3 4 5  node: content: \u0026#34;_hoisted_1\u0026#34; isConstant: true isStatic: false type: 4 // SIMPLE_EXPRESSION      最后用 _hoisted_1 来替代 { key: 0 } 这个惊天属性。\n  DONE 5. codegen 如何生成 if-elseif-else 分支节点 ?  CLOSED: [2020-10-04 Sun 12:47]\n  State \u0026#34;DONE\u0026#34; from \u0026#34;TODO\u0026#34; [2020-10-04 Sun 12:47]\n  生成分支入口函数产生过程：traverseNode 中收集 exitFns 过程中执行 transformIf 经过一些列操作之后得到一个函数，该函数会在当前节点树递归结束后调用，生成 codegenNode\n 返回的分支节点 codegenNode 结构：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61  { \u0026#34;type\u0026#34;:19, \u0026#34;test\u0026#34;:{ // ok ? ... : ...  \u0026#34;type\u0026#34;:4, \u0026#34;content\u0026#34;:\u0026#34;ok\u0026#34;, \u0026#34;isStatic\u0026#34;:false, \u0026#34;isConstant\u0026#34;:false, \u0026#34;loc\u0026#34;:{ // ...  \u0026#34;source\u0026#34;:\u0026#34;ok\u0026#34; } }, \u0026#34;consequent\u0026#34;:{ // cond ? 这里的代码 : ...  \u0026#34;type\u0026#34;:13, \u0026#34;tag\u0026#34;:\u0026#34;\u0026#34;div\u0026#34;\u0026#34;, \u0026#34;props\u0026#34;:{ \u0026#34;type\u0026#34;:15, \u0026#34;loc\u0026#34;:{ /* ... */ }, \u0026#34;properties\u0026#34;:[ { \u0026#34;type\u0026#34;:16, \u0026#34;key\u0026#34;:{ \u0026#34;type\u0026#34;:4, \u0026#34;isConstant\u0026#34;:false, \u0026#34;content\u0026#34;:\u0026#34;key\u0026#34;, \u0026#34;isStatic\u0026#34;:true }, \u0026#34;value\u0026#34;:{ \u0026#34;type\u0026#34;:4, \u0026#34;isConstant\u0026#34;:false, \u0026#34;content\u0026#34;:\u0026#34;0\u0026#34;, \u0026#34;isStatic\u0026#34;:false } } ] }, \u0026#34;children\u0026#34;:{ \u0026#34;type\u0026#34;:2, \u0026#34;content\u0026#34;:\u0026#34;yes\u0026#34;, \u0026#34;loc\u0026#34;:{ \u0026#34;source\u0026#34;:\u0026#34;yes\u0026#34; } }, \u0026#34;isBlock\u0026#34;:true, \u0026#34;isForBlock\u0026#34;:false, \u0026#34;loc\u0026#34;:{ \u0026#34;source\u0026#34;:\u0026#34;\u0026lt;div v-if=\u0026#34;ok\u0026#34;\u0026gt;yes\u0026lt;/div\u0026gt;\u0026#34; } }, \u0026#34;alternate\u0026#34;:{ // cond ? ... : 这里的代码  \u0026#34;type\u0026#34;:14, \u0026#34;loc\u0026#34;:{ \u0026#34;source\u0026#34;:\u0026#34;\u0026#34;, }, \u0026#34;arguments\u0026#34;:[ \u0026#34;\u0026#34;v-if\u0026#34;\u0026#34;, \u0026#34;true\u0026#34; ] }, \u0026#34;newline\u0026#34;:true, }     处理流程图：\n   DONE 6. transform 阶段如何转换 v-else-if 指令？   示例代码：\n1 2 3 4 5  \u0026lt;div\u0026gt; \u0026lt;div v-if=\u0026#34;ok\u0026#34;\u0026gt;yes\u0026lt;/div\u0026gt; \u0026lt;div v-else-if=\u0026#34;nok\u0026#34;\u0026gt;nok\u0026lt;/div\u0026gt; \u0026lt;div v-else\u0026gt;no\u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt;       DONE 7. 什么时候用 createVNode 什么时候用 createBlock ？   到目前为止大部分的实例都是通过 block 解析的，因为孩子节点只有一个。\n 孩子节点有多个的时候会进入 VNode 流程，这里相当于创建了一个虚拟节点来将多个孩子 包起来去生成 render 函数。\n 虚拟节点创建有这么几个函数： createVNode, createCommentVNode, createTextVNode 这些函数什么时候使用？和 openBlock, createBlock 区别在哪？\n 对比两个示例：\n vnode 版 v1:\n1 2 3 4  \u0026lt;div id=\u0026#34;foo\u0026#34; :class=\u0026#34;bar.baz\u0026#34;\u0026gt; {{ world.burn() }} \u0026lt;div v-if=\u0026#34;ok\u0026#34;\u0026gt;yes\u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt;     非 vnode 版 v2:\n1 2 3  \u0026lt;div id=\u0026#34;foo\u0026#34; :class=\u0026#34;bar.baz\u0026#34;\u0026gt; {{ world.burn() }} \u0026lt;/div\u0026gt;     区别：插值 {{world.burn()}} 有一个兄弟节点 \u0026lt;div v-if=\u0026#34;ok\u0026#34;\u0026gt;yes\u0026lt;/div\u0026gt; 此时插值 节点的处理会不一样，先看结果：\n  v1 结果(这个结果是有问题的，这也是我们要解决的问题)：\n 问题： _createTextVNode(, 1 /* TEXT */) 这里少了个参数，应该是那个插值表达式。\n 解决方法：加上 genNode: COMPOUND_EXPRESSION 分支处理。\n 处理之后： _createTextVNode(_toDisplayString(world.burn()) + \u0026#34; \u0026#34;, 1 /* TEXT */)\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39  const _Vue = Vue; const { createVNode: _createVNode, createCommentVNode: _createCommentVNode, createTextVNode: _createTextVNode, } = _Vue; const _hoisted_1 = { key: 0 }; return function render(_ctx, _cache) { with (_ctx) { const { toDisplayString: _toDisplayString, createVNode: _createVNode, openBlock: _openBlock, createBlock: _createBlock, createCommentVNode: _createCommentVNode, createTextVNode: _createTextVNode, } = _Vue; return ( _openBlock(), _createBlock( \u0026#34;div\u0026#34;, { id: \u0026#34;foo\u0026#34;, class: bar.baz, }, [ _createTextVNode(, 1 /* TEXT */), ok ? (_openBlock(), _createBlock(\u0026#34;div\u0026#34;, _hoisted_1, \u0026#34;yes\u0026#34;)) : _createCommentVNode(\u0026#34;v-if\u0026#34;, true), ], 2 /* CLASS */ ) ); } };      v2 结果：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27  (function anonymous() { const _Vue = Vue; return function render(_ctx, _cache) { with (_ctx) { const { toDisplayString: _toDisplayString, createVNode: _createVNode, openBlock: _openBlock, createBlock: _createBlock, } = _Vue; return ( _openBlock(), _createBlock( \u0026#34;div\u0026#34;, { id: \u0026#34;foo\u0026#34;, class: bar.baz, }, _toDisplayString(world.burn()), 3 /* TEXT, CLASS */ ) ); } }; });       脑图：\n   DONE 8. transform 阶段如何做静态提升？   静态提升检测在 transform 阶段， traverseNode 遍历完 ast 树之后，会调用 hoistStatic(root, context) 对所有 codegenNode 进行递归，将需要静态提升的节点提取 到 root.hoists 中。\n1 2 3 4 5 6 7 8  function transform(root, options) { const context = createTransformContext(root, options); traverseNode(root, context); if (options.hoistStatic) { hoistStatic(root, context); } // ... }     静态提升条件：\n  根节点必须有一个孩子以上节点，且所有子孙节点都必须是静态节点(isStatic(child, resultCache))\n  如果节点是动态节点，则检测其所有属性，提取出静态属性将其提升\n  提升之后的属性或节点会保存到 context.hoists 里面\n  源码脑图：   DONE 9. transform 阶段如何转换 v-for 指令？   这里和 transform 如何转换 v-else-if 一样复杂，这里将单独进行分析绘出对应脑图，示 例来源于 v-for 指令 且保持同步。\n  测试用例：\n1 2 3  \u0026lt;ul class=\u0026#34;list\u0026#34;\u0026gt; \u0026lt;li v-for=\u0026#34;user in users\u0026#34;\u0026gt;{{user.name}}\u0026lt;/li\u0026gt; \u0026lt;/ul\u0026gt;`     transform 阶段前后 ast 对比：\n  transform 之前的 \u0026lt;li\u0026gt; ast:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30  // ast.children[0]/*\u0026lt;ul\u0026gt;*/.children[0]/*\u0026lt;li\u0026gt;*/ var before = { type: 1, tag: \u0026#39;li\u0026#39;, props: [ { type: 7, name: \u0026#39;for\u0026#39;, exp: { type: 4, content: \u0026#39;user in users\u0026#39;, isStatic: false, isConstant: false, }, loc: { source: \u0026#34;v-for=\u0026#39;user in users\u0026#39;\u0026#34; }, }, ], isSelfClosing: false, children: [ { type: 5, content: { type: 4, isStatic: false, isConstant: false, content: \u0026#39;user.name\u0026#39;, }, loc: { source: \u0026#39;{{user.name}}\u0026#39; }, }, ]      tranform 之后的 \u0026lt;li\u0026gt; ast:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43  // ast.children[0]/*\u0026lt;ul\u0026gt;*/.children[0]/*\u0026lt;li\u0026gt;*/ var after = { type: 11, // FOR source: { // 源数据  type: 4, isConstant: false, content: \u0026#39;users\u0026#39;, isStatic: false, }, valueAlias: { // 迭代过程中的值  type: 4, isConstant: false, content: \u0026#39;user\u0026#39;, isStatic: false, }, parseResult: { source: \u0026#39;...\u0026#39; /*对应外面的source*/, value: \u0026#39;...\u0026#39; /*对应外面的 valueAlias*/, }, children: [ { type: 1, tag: \u0026#39;li\u0026#39;, props: [], children: [ { // {{user.name}}  type: 5, content: { type: 4, isStatic: false, isConstant: false, content: \u0026#39;user.name\u0026#39;, }, }, ], codegenNode: {/*...见 li 的 codegenNode */}, }, ], codegenNode: {/*...*/}, }      type: 11, FOR 类型\n  source: 渲染列表的数据来源，这里是 users\n  valueAlias: 渲染列表项需要的数据 user\n    transform 之后生成的 \u0026lt;li\u0026gt; codegenNode:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48  node.codegenNode = { type: 11, // FOR codegenNode: { type: 13, // VNODE_CALL  children: { type: 14, // JS_CALL_EXPRESSION  arguments: [ // 将作为 callee: _renderList 的参数  { type: 4, isConstant: false, content: \u0026#39;users\u0026#39;, isStatic: false, }, { // 用来生成函数的 (user) =\u0026gt; { retrun `解析后的returns` }  type: 18, // JS_FUNCTION_EXPRESSION  params: [ // 这个作为 _renderList 第二个函数的参数  { type: 4, isConstant: false, content: \u0026#39;user\u0026#39;, isStatic: false, }, ], returns: { // _renderList 第二个参数函数的返回值  type: 13, tag: \u0026#39;\u0026#34;li\u0026#34;\u0026#39;, children: { type: 5, // INTERPOLATION  content: { type: 4, isStatic: false, isConstant: false, content: \u0026#39;user.name\u0026#39;, }, }, patchFlag: \u0026#39;1 /* TEXT */\u0026#39;, isBlock: true, disableTracking: false, }, newline: true, // 这个结合 body 决定是否是 (user) =\u0026gt; xx 还是 (user) =\u0026gt; { return xxx }  isSlot: false, }, ], }, patchFlag: \u0026#39;256 /* UNKEYED_FRAGMENT */\u0026#39;, isBlock: true, disableTracking: true, },     const children = codegenNode.children\n  children: 生成 _renderList( 函数\n _renderList(\n  children.arguments: 生成 _renderList(users, fn) 函数的 两个参数 users 和 fn\n  children.arguments[0]: 将生成第一个参数 users\n _renderList(users,\n  children.arguments[1]: 将生成 fn 函数\n _renderList(users, fn\n  children.arguments[1].type: 18，表示是 JS_FUNCTION_EXPRESSION 类型，用 来生成函数的\n  children.arguments[1].params: 作为 fn 函数的参数\n _renderList(users, (user) =\u0026gt;\n  children.arguments[1].returns: 作为 fn函数的返回值\n _renderList(users, (user) =\u0026gt; { return (_openBlock(), _createBlock(\u0026#34;li\u0026#34;, null, _toDisplayString(user.name), 1 /*TEXT*/)) })\n    从结构可以看出， v-for 指令最后会被替换成下面的结构：\n { type:11, valueAlias:/*这里是迭代当前的数据 user */, source: /* 这里是数据源，如：users*/}\n 生成的 li codegenNode 结构：\n {type: 13, children: {/*...*/}}\n renderList(users, (user)=\u0026gt; {return xx}) 最终由 children 内数据呈现：\n {type: 14, arguments: [{...}, {...}]}\n arguments:  [{ type: 4, content: \u0026#34;users\u0026#34; }, { type: 18, params: {...} returns: {...} }}]\n 第二个参数成员表(生成： _renderList(users, fn))\n   memeber type value description     type 18,JS_FUNCTION_EXPRESSION 18 生成函数 fn 的类型   params 4,SIMPLE_EXPRESSION {type:4, content: \u0026#34;user\u0026#34;} fn 第一个参数 user, (user) =\u0026gt; xxx   returns 13,VNODECALL {type:13, tag: \u0026#34;\\\u0026#34;li\\\u0026#34;\u0026#34;, ...} fn 函数的返回值   body - - fn 的函数体， () =\u0026gt; body, 和 returns 相冲突，二选一，且 returns 优先        ☁ compiler-core: parser   vue3.0 的解析器模块，将 html 模板解析成 AST 对象。\n带指令的标签解析全过程(v-bind)   代码： baseParse(`\u0026lt;div v-bind:keyup.enter.prevent=\u0026#34;ok\u0026#34;\u0026gt;\u0026lt;/div\u0026gt;`)\n  parseChildren ➡️ while\n  parseElement ⬅️ \u0026lt;div ....\u0026gt;\u0026lt;/div\u0026gt;\n  parseTag ➡️ node: div ➡️ parseAttributes 解析属性 ⬅️ v-bind:keyup...\u0026gt;\u0026lt;/div\u0026gt;\n  parseAttribute ➡️\n  先解析 =\u0026#34;ok\u0026#34; 出值\n  后解析 v-bind:keyup.enter.prevent\n    最后得到 props[0] -\u0026gt; { name: \u0026#39;bind\u0026#39;, arg: { content: \u0026#39;keyup\u0026#39;, ... }, exp: { content: \u0026#39;ok\u0026#39;, ... }, modifiers: [\u0026#39;enter\u0026#39;, \u0026#39;prevent\u0026#39; ]}\n  name: 指令的名称， v-bind, @ 都会转成 bind 名称\n  arg: 表示指令绑定的参数名称，这里可以是动态变量，如： v-bind:[dynamicVarName] ，由 arg.isConstant 标识。\n  exp: 表示表达式的值\n     流程图：   标签解析(\u0026lt;div\u0026gt;hello world\u0026lt;/div\u0026gt;)   代码： baseParse(`\u0026lt;div\u0026gt;hello world\u0026lt;/div\u0026gt;`)\n  parseChildren while 开始解析\n  遇到 \u0026lt;d 满足 /^[z-a]/i 进入 parseElement 解析标签\n  parseElement -\u0026gt; parseTag 解析出名为 div 的标签节点， content = `hello world\u0026lt;/div\u0026gt;`\n  parseElement -\u0026gt; parseChildren 解析出 hello world 文本节点作为 div 节点的 children[0]， content = `\u0026lt;/div\u0026gt;`\n  返回到 parseChildren 解析 \u0026lt;/div\u0026gt; 发现 ancestors 有内容且找到了 \u0026lt;/div\u0026gt; 匹配的 \u0026lt;div\u0026gt; 节点，最后完成匹配。\n   流程图：\n 自闭合标签(\u0026lt;img/\u0026gt;)的解析，也在 parseTag 里面，有一个针对这个的处理：  1 2 3 4 5 6 7 8 9 10  // 解析到这里的时候 content 应该是这样的：`/\u0026gt;xxx`  isSelfClosing = startsWith(context.source, \u0026#39;/\u0026gt;\u0026#39;) if (type === TagType.End \u0026amp;\u0026amp; isSelfClosing) { // 如果自闭合没有开始标签，是非法的  emitError(context, ErrorCodes.END_TAG_WITH_TRAILING_SOLIDUS) } // 这里判断如果是自闭合的，那么该标签的解析就已经结束了  advanceBy(context, isSelfClosing ? 2 : 1)      空标签的处理，需要在调用解析函数 baseParse 的时候明确告知它哪些是空标签(如： \u0026lt;img\u0026gt;)：  1 2 3  const ast = baseParse(\u0026#39;\u0026lt;img\u0026gt;after\u0026#39;, { isVoidTag: (tag) =\u0026gt; tag === \u0026#39;img\u0026#39; })     isVoidTag 会在 parseElement 的时候被调用，在调用 parseTag 解析完 TagType.Start 之后检测，如果是空标签类型，会直接退出解析即完成该标签的解析 过程(因为是空标签，所以后面的内容就不再属于它了，可以结束了)：\n1 2 3 4  // 自闭合的到这里就可以结束了  if (element.isSelfClosing || context.options.isVoidTag?.(element.tag)) { return element; }      模板标签的解析(\u0026lt;template\u0026gt;\u0026lt;/template\u0026gt;)   这个解析和普通标签基本一样，只是在 parseTag 里面解析的时候更新下类型就可以了，很 简单的操作：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43  function parseTag( context: ParserContext, type: TagType, parent: ElementNode | undefined ): ElementNode { // ...省略，这些都可以省略了，和普通标签处理一模一样  let tagType = ElementTypes.ELEMENT const options = context.options if (!context.inVPre \u0026amp;\u0026amp; !options.isCustomElement(tag)) { // ...省略，vue 内置组件类型  if (tag === \u0026#39;slot\u0026#39;) { tagType = ElementTypes.SLOT } else if ( // 所以这里才是重点，作为模板标签必须满足一定的条件  // 1. 必须包含至少一个属性，且类型是指令  // 2. 并且满足 const isSpecialTemplateDirective = /*#__PURE__*/ makeMap(`if,else,else-if,for,slot`)  // 即该指令必须是 if, else, else-if, for, slot，也就是说模板必须用作循环或插槽时使用  tag === \u0026#39;template\u0026#39; \u0026amp;\u0026amp; props.some(p =\u0026gt; { return ( p.type === NodeTypes.DIRECTIVE \u0026amp;\u0026amp; isSpecialTemplateDirective(p.name) ) }) ) { tagType = ElementTypes.TEMPLATE } } return { type: NodeTypes.ELEMENT, ns, tag, tagType, props, isSelfClosing, children: [], loc: getSelection(context, start), codegenNode: undefined // to be created during transform phase  } }     所以下面这两个用例就能很好的得到解释了：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17  test(\u0026#34;template element with directives\u0026#34;, () =\u0026gt; { const ast = baseParse(\u0026#39;\u0026lt;template v-if=\u0026#34;ok\u0026#34;\u0026gt;\u0026lt;/template\u0026gt;\u0026#39;); const element = ast.children[0]; expect(element).toMatchObject({ type: NodeTypes.ELEMENT, tagType: ElementTypes.TEMPLATE, // 这里是模板类型，因为有 `v-if\u0026#39; 指令  }); }); // template element with directives  test(\u0026#34;template element without directives\u0026#34;, () =\u0026gt; { const ast = baseParse(\u0026#34;\u0026lt;template\u0026gt;\u0026lt;/template\u0026gt;\u0026#34;); const element = ast.children[0]; expect(element).toMatchObject({ type: NodeTypes.ELEMENT, tagType: ElementTypes.ELEMENT, // 而这里依旧是元素类型，因为没有任何指令  }); });        解析无效的 \u0026lt;/div\u0026gt;   代码： baseParse(`\u0026lt;/div\u0026gt;`)\n 经过的函数：\n  parseChildren 进入解析 while\n  parseText 解析出有效文本\n  回到 parseChildren while 循环解析 \u0026lt;/div\u0026gt; 报错\n   流程图：   插值解析 some {{ foo + bar }} text   代码： baseParse(`some {{ foo + bar }} text`)\n  parseChildren ➡️ while: some {{ foo + bar }} text\n  parseText ➡️ node[0]: `some`\n  {{ foo + bar }} text ➡️ parseInterpolation ➡️ node[1]: foor + bar\n  ` text` ➡️ parseText ➡️ node[2]: `text`\n  nodes -\u0026gt; root.children\n  解析过程中需要注意的几点：\n  插值解析，首先是匹配 `{{` 然后去的 }} 的索引，最后通过 slice(startIdx, endIdx) 取到要解析的表达式。\n  `some` 和 `text` 不会合并到一个 node 中，因为不是相邻的，请注意合并文 本 ndoe 的前提条件：前一个节点也必须是文本节点类型。\n  流程图：   解析 simple text   解析纯文本，只会进入 while 循环中的 !node 检测然后进入 parseText 纯文本解 析，会匹配 \u0026lt;, {{, ]]\u0026gt; 作为纯文本的结束标志。\n 得到纯文本内容后传递给 parseTextData 替换 /\u0026amp;(gt|lt|amp|apos|quot);/g html 语义符号之后返回给 parseText:content 组织文本节点结构返回。\n 退出 while 循环，将 node 塞到 root.children[] 里面，作为根节点的孩子节点。\n 代码： baseParse(`simple text`)\n 流程图：     🌙 compiler-core: compiler   vu3.0 编译器模块，将 parser 解析得到的 AST 对象编译成对应的 render 函数。\n 该模块主要实现的三大块，因为这三个关联性很强，因此放到一块了。\n  compile.ts 编译器主模块\n  transform.ts 即 transforms/ 目录，语法转换模块，入口函数： transform()，比如： v-if 指令，函数，变量等\n  codegen.ts 入口函数： generate() ，生成代码字符串，用来调用 new Function(code) 生成 render 函数。\n   流程图： 01-simple text 编译过程   代码：\n1 2 3  compile(`simple text`, { filename: `foo.vue` })     01-simple-text 测试用例地址\n 流程图：  详细过程分析请点击链接。\n  02-pure interpolation 编译过程   代码：\n1 2 3  compile(`{{ world.burn() }}`, { filename: `foo.vue`, })     02-pure-interpolation 测试用例地址\n 流程图：\n  详细过程分析请点击链接。\n  03-inerpolation in pure div   代码：\n1 2 3  compile(`\u0026lt;div\u0026gt;{{ world.burn() }}\u0026lt;/div\u0026gt;`, { filename: `foo.vue`, })     用例地址\n 流程图：\n  详细过程分析请点击链接。\n  04-interpolation in div with props   代码：\n1 2 3  compile(`\u0026lt;div id=\u0026#34;foo\u0026#34; :class=\u0026#34;bar.baz\u0026#34;\u0026gt;{{ world.burn() }}\u0026lt;/div\u0026gt;`, { filename: `foo.vue`, })     用例地址\n 流程图：   05-interpolation, v-if, props  1 2 3 4 5  code = ` \u0026lt;div id=\u0026#34;foo\u0026#34; :class=\u0026#34;bar.baz\u0026#34;\u0026gt; {{ world.burn() }} \u0026lt;div v-if=\u0026#34;ok\u0026#34;\u0026gt;yes\u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt;`     如果放到一张图里面，实在太繁琐了，简化，拆分如下：\n   整体流程及导致结果\n  parse ast 流程\n  transform ast 流程，这部分会比较繁琐\n  codegen generate 流程\n  transform 阶段流程图：  generate 阶段流程图：     ","permalink":"https://www.cheng92.com/vue/vue-mind-map-house-cc/","tags":["vue,","vue3,","compiler-core,","parser,","compiler"],"title":"Vue3 源码头脑风暴之☞compiler-core"},{"categories":["algorithm,","array"],"contents":" 0001_two-sum   ","permalink":"https://www.cheng92.com/algo/algo-leetcode-easy/","tags":["algorithm,","leetcode,","programming,","javascript"],"title":"Algorithm On Leetcode - Easy Level"},{"categories":["vue"],"contents":" reactivity   compiler-core  compile.ts  baseCompile   baseCompile(template, options)\n 将 template 解析成 render 函数，重点步骤:\n  baseParse(template, options) 将字符串模板解析成 AST 对象。\n  transform(ast, …) 将 AST 进一步转换处理\n  将转换后的 ast 调用 codegen 的 generate 方法生成 render 。\n  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37  export function baseCompile(template, options) { const isModuleMode = options.mode === \u0026#34;module\u0026#34;; // ... 略去错误❎处理  const prefixIdentifiers = !__BROWSER__ \u0026amp;\u0026amp; (options.prefixIdentifiers === true || isModuleMode); // 1. baseParse 得到 AST 对象，两种情况：1. 未解析的模板，2. 以解析之后的 ast 对象  const ast = typeof template === \u0026#34;string\u0026#34; ? baseParse(template, options) : template; // 2. 取出所有 node 和 directive 的 transforms  const [nodeTransforms, directiveTransforms] = getBaseTransformPreset( prefixIdentifiers ); // 3. 进行转换，调用 transform  transform(ast, { // 合并选项  ...options, // 调用 baseCompile 时候的第二个参数  prefixIdentifiers, // 还不知道是干啥的???  // 节点转换器合并，外部转换器优先，即使用者可自定义自己的转换器  nodeTransforms: [...nodeTransforms, ...(options.nodeTransforms || {})], // 指令转换器，同上。  directiveTransforms: [ ...directiveTransforms, ...(options.directiveTransforms || {}), ], }); // 4. 调用 generate 生成 render 函数的 codegen 并返回，这就是我们需要的组件渲  // 染函数  return generate(ast, { ...options, prefixIdentifiers, }); }     这也是除了错误处理之后的完整的 baseCompile 函数实现。\n  getBaseTransformPreset   getBaseTransformPreset(prefixIdentifiers: boolean)\n 合并所有 transform，返回一个 TransformPreset 类型的数组\nstage-2:   增加 transformBind 指令处理，处理 :class = \u0026#34;bar.baz\u0026#34; 的时候需要用到\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  export function getBaseTransformPreset(prefixIdentifiers) { return [ [ // ... 省略其他，第一阶段我们应该只需要文本转换  transformText, ...(!__BROWSER__ \u0026amp;\u0026amp; prefixIdentifiers ? [transformExpression] : []), transformElement, ], { // ...省略指令  bind: transformBind, }, ]; }      stage-1: 01-simple text   第一阶段我们只需要文本转换，通过 用例一 即可，所以这里就只保留 transformText 就可以了，剩下的就是去实现它。\n1 2 3 4 5 6 7 8 9 10 11  export function getBaseTransformPreset(prefixIdentifiers) { return [ [ // ... 省略其他，第一阶段我们应该只需要文本转换  transformText, ], { // ...省略指令  }, ]; }          tranform.ts  transformExpression   transformExpression(node, context)\n  transformText   transformText(node, context)\n 该函数会返回一个用来转换文本节点类型(NodeTransform)的函数。\n 返回函数分析(return () =\u0026gt; { ... })，主要由三个 for 构成：\n  第一个 for 嵌套第二个 for 构成双重循环，用来合并 node.children 里面相邻的文本 节点\n 第一个 For 里面使用的是 children.length 动态获取当前数组的长度，结合代码中的 splice 和 j–。从而完成合并操作。\n1 2 3 4 5 6  // 1. 原来的 child 被重写  // 2. child, ` + `, next 合并到了新 child.children 里面  currentContainer.children.push(` + `, next); // 删除被合并的文本节点  children.splice(j, 1); j--; // -1 是因为上面删除了当前元素，for 循环过程中长度是动态获取的       第三个 for 遍历第一步之后的 children，对每个 child 进行重定义，类型改变成 NodeTyeps.TEXT_CALL 类型，增加 codegenNode 属性。\n   代码完整版：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111  export const transformText = (node, context) =\u0026gt; { // 文本转换只能是下面四种类型  const validTypes = [ NodeTypes.ROOT, NodeTypes.ELEMENT, NodeTypes.FOR, NodeTypes.IF_BRANCH, ]; // 合法类型检测  if (validTypes.indexOf(node.type)) { // 返回一个可执行函数，记得在 transformNode 吗，这个返回的函数  // 将会被它在 while 中 执行 掉。  return () =\u0026gt; { const children = node.children; let currentContainer = undefined; let hasText = false; // 双重循环，合并所有相邻的文本节点  // 如：[text1, text2, element, text3, ele, text4, text5]  // text1 和 text2 会合并到text1  // text3 不会合并  // text4 和 text5 会被合并  for (let i = 0; i \u0026lt; children.length; i++) { const child = children[i]; if (isText(child)) { // TODO 文本节点才进行解析  hasText = true; // 合并相邻的文本节点， text1 + text2  for (let j = i + 1; j \u0026lt; children.length; j++) { const next = children[j]; // 下一个也是文本节点的时候，要将两者合并  if (isText(next)) { if (!currentContainer) { // 这里等于重写了 child 的引用，将自身 push 到了  // 新结构中的 children  currentContainer = children[i] = { type: NodeTypes.COMPOUND_EXPRESSION, loc: child.loc, children: [child], }; } // 1. 原来的 child 被重写  // 2. child, ` + `, next 合并到了新 child.children 里面  currentContainer.children.push(` + `, next); // 删除被合并的文本节点  children.splice(j, 1); j--; // -1 是因为上面删除了当前元素，for 循环过程中长度是动态获取的  } else { currentContainer = undefined; break; } } } } // 集中不满足转换条件的情况  if ( // 1. 没有文本内容  // 2. 只有一个孩子节点  // 2.1 组件根节点  // 2.2 \u0026lt;element\u0026gt; 元素节点  !hasText || (children.length === 1 \u0026amp;\u0026amp; (node.type === NodeTypes.ROOT || (node.type === NodeTypes.ELEMENT \u0026amp;\u0026amp; node.tagType === ElementTypes.ELEMENT))) ) { return; } // 开始转换  for (let i = 0; i \u0026lt; children.length; i++) { const chld = children[i]; if (isText(child) || child.type === NodeTypes.COMPOUND_EXPRESSION) { const callArgs = []; // 非文本节点，直接 push 掉，这里 child.content !== \u0026#39; \u0026#39; 的原因在于  // parseChildren 里面 while 循环最后有个remove whitespace 操作  // 会将有效的空节点转成一个空格的字符串。  // createTextVNode 默认是一个单空格  if (child.type !== NodeTypes.TEXT || child.content !== \u0026#34; \u0026#34;) { callArgs.push(child); } // 非服务端渲染，且非文本节点  if (!context.ssr \u0026amp;\u0026amp; child.type !== NodeTypes.TEXT) { callArgs.push( // TODO 这个是干嘛的？？？  `${PatchFlags.TEXT}/* ${PatchFlagNames[PatchFlags.TEXT]}*/` ); } children[i] = { type: NodeTypes.TEXT_CALL, // 文本函数  content: child, loc: child.loc, codegenNode: createCallExpression( context.helper(CREATE_TEXT), callArgs ), }; } } }; } }     使用到的外面函数和属性：\n  CREATE_TEXT： 一个符号属性 export const CREATE_TEXT = Symbol(__DEV__ ? `createTextVNode` : ``);\n  createCallExpression(callee, args, loc) 返回 JS_CALL_EXPRESSION 类型对象。\n  PatchFlags 和 PatchFlagNames 一个名字映射\n  isText 文本节点类型(插值和 text)\n1 2 3 4  export function isText(node) { // 插值或 text 均视为文本  return node.type === NodeTypes.INTERPOLATION || node.type === NodeTypes.TEXT; }       对应的虚拟节点创建函数： createTextVNode\n  transform   transform(root, options)\n 调用的函数：\n  createTransformContext(root, options) 创建 transform 转换器类型的上下文对象\n  traverseNode(root, context) 遍历所有节点\n  ssr 服务端渲染处理\n  初始化 root 根节点上的一些属性\n  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21  export function transform(root, options) { const context = createTransformContext(root, options); traverseNode(root, context); if (options.hoistStatic) { hoistStatic(root, context); } // ... ssr 处理  // root 属性合并，初始化  root.helpers = [...context.helpers]; root.components = [...context.components]; root.directives = [...context.directives]; root.imports = [...context.imports]; root.hoists = context.hoists; root.temps = context.temps; root.cached = context.cached; }      transformElement   transformElement(node, context)\nstage-2   stage-1 03-inerpolation in pure div  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99  export const transformElement = (node, context) =\u0026gt; { if ( !( // 首先必须是 ELEMENT 类型  ( node.type === NodeTypes.ELEMENT \u0026amp;\u0026amp; // 然后是标签类型为 element 或者是 component 组件  (node.tagType === ElementTypes.ELEMENT || node.tagType === ElementTypes.COMPONENT) ) ) ) { return; } return function postTransformElement() { const { tag, props } = node; const isComponent = node.tagType === ElementTypes.COMPONENT; // 虚拟节点的 tag 类型，test-03 直接返回 `div`  const vnodeTag = isComponent ? resolveComponentType(node, context) : `\u0026#34;${tag}\u0026#34;`; // 是不是动态组件  const isDynamicComponent = typeof vnodeTag === \u0026#34;object\u0026#34; \u0026amp;\u0026amp; vnodeTag.callee === RESOLVE_DYNAMIC_COMPONENT; // TODO ... 声明一些变量  let vnodeProps; let vnodeChildren; let vnodePatchFlag; let patchFlag = 0; let vnodeDynamicProps; let dynamicPropNames; let vnodeDirectives; // TODO shouldUseBlock  let shouldUseBlock = false; if (props.length \u0026gt; 0) { // TODO  } if (node.children.length \u0026gt; 0) { if (vnodeTag === KEEP_ALIVE) { // TODO KeepAlive  } const shouldBuildAsSlots = isComponent \u0026amp;\u0026amp; // Teleport 并非真实的组件，且专用于运行时处理  vnodeTag !== TELEPORT \u0026amp;\u0026amp; vnodeTag !== KEEP_ALIVE; // 这段 if...else if ...else 目的是得到 vnodeChildren  if (shouldBuildAsSlots) { // TODO  } else if (node.children.length === 1 \u0026amp;\u0026amp; vnodeTag !== TELEPORT) { const child = node.children[0]; const type = child.type; // 动态文本孩子节点检测  const hasDynamicTextChild = type === NodeTypes.INTERPOLATION || type === NodeTypes.COMPOUND_EXPRESSION; if (hasDynamicTextChild \u0026amp;\u0026amp; !getStaticType(child)) { patchFlag |= PatchFlags.TEXT; } if (hasDynamicTextChild || type === NodeTypes.TEXT) { vnodeChildren = child; } else { vnodeChildren = node.children; } } else { vnodeChildren = node.children; } } // TODO patchFlag \u0026amp; dynamicPropNames  node.codegenNode = createVNodeCall( context, vnodeTag, vnodeProps, vnodeChildren, vnodePatchFlag, vnodeDynamicProps, vnodeDirectives, !!shouldUseBlock, false /* isForBlack */, node.loc ); }; }     进入 createVNodeCall 时的参数值：\n  这里会将一些需要用到的函数添加到 context.helpers:Set 中等待解构：\n 该用例中会有 CREATE_VNODE 被解构出来。\n    transformBind   transformBind(prop, node, context)\n 指令也属于属性一种，所以它的处理源头是在 transformElement 里面。\n 这里只不过是提供了 v-bind 处理方式。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27  export const transformBind = (dir, node, context) =\u0026gt; { const { exp, modifiers, loc } = dir; const arg = dir.arg; // TODO 错误处理  if (modifiers.includes(\u0026#34;camel\u0026#34;)) { if (arg.type === NodeTypes.SIMPLE_EXPRESSION) { if (arg.isStatic) { // 横线 转驼峰式  arg.content = camelize(arg.content); } else { arg.content = `${context.helperString(CAMELIZE)}(${arg.content})`; } } else { arg.children.unshift(`${context.helperString(CAMELIZE)}(`); arg.children.push(`)`); } } return { props: [ createObjectProperty(arg, exp || createSimpleExpression(\u0026#34;\u0026#34;, true, loc)), ], }; };      transformIf()   这个函数是由一系列的操作之后才返回的一个函数，用来处理 /^(if|else|else-if)$/ 指令，生成对应分支节点的 codegenNode 。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37  export const transformIf = createStructuralDirectiveTransform( /^(if|else|else-if)$/, (node, dir, context) =\u0026gt; { return processIf(node, dir, context, (ifNode, branch, isRoot) =\u0026gt; { // 能到这里说明 v-if 下所有的 child 都已经处理完毕，可以返回处理  // codegenNode 的函数了  return () =\u0026gt; { console.log({ dir, isRoot }); if (isRoot) { ifNode.codegenNode = createCodegenNodeForBranch(branch, 0, context); } else { // 将当前分支的codegenNode挂载到 v-if 根节点上  let parentCondition = ifNode.codegenNode; while ( parentCondition.alternate.type === NodeTypes.JS_CONDITIONAL_EXPRESSION ) { // 这个循环的目的是为了找到最后那个需要被替换的 alternate 节点  // 因为有可能会有 `?:` 嵌套的可能  // 如： ok ? expr1 : expr2 情况找到的是 expr2 需要被替换  // 如： ok ? expr1 : (ok2 ? expr2 : expr3) 那么找到的就是 expr3  // ...  // 因为最后一个 `:` 后面的表达式如果没有 else 应该会是个  // comment vnode类型的占位节点  parentCondition = parentCondition.alternate; } parentCondition.alternate = createCodegenNodeForBranch( branch, ifNode.branches.length - 1, context ); } }; }); } )      createCodegenNodeForBranch   createCodegenNodeForBranch(branch, index, context)\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  function createCodegenNodeForBranch(branch, index, context) { if (branch.condition) { return createConditionalExpression( branch.condition, createChildrenCodegenNode(branch, index, context), createCallExpression(context.helper(CREATE_COMMENT), [ __DEV__ ? \u0026#39;\u0026#34;v-if\u0026#34;\u0026#39; : \u0026#39;\u0026#34;\u0026#34;\u0026#39;, \u0026#34;true\u0026#34;, ]) ); } else { return createChildrenCodegenNode(branch, index, context); } }      createChildrenCodegenNode   createChildrenCodegenNode(branch, index, context)\nstage-1 05-interpolation, v-if, props   该阶段只完成一个孩子节点且是 ELEMENT 类型的时候处理，如果不是这种情况是需要用 fragment 将这些 children 包起来的。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38  // 创建 v-if 分支的孩子节点，同时加上 key 属性  function createChildrenCodegenNode(branch, index, context) { const { helper } = context; const keyProperty = createObjectProperty( `key`, createSimpleExpression(index + ``, false) ); const { children } = branch; const firstChild = children[0]; // 多个节点的情况下用 fragment 包起来  const needFragmentWrapper = children.length !== 1 || firstChild.type !== NodeTypes.ELEMENT; if (needFragmentWrapper) { // TODO  } else { // 只有一个孩子节点且是 ELEMENT  const vnodeCall = firstChild.codegenNode; if ( vnodeCall.type === NodeTypes.VNODE_CALL \u0026amp;\u0026amp; // 组件的 vnodes 总是被追踪且它的孩子们会被编译进  // slots 因此没必要将它变成一个 block  (firstChild.tagType !== ElementTypes.COMPONENT || vnodeCall.tag === TELEPORT) ) { // TODO  vnodeCall.isBlock = true; helper(OPEN_BLOCK); helper(CREATE_BLOCK); } injectProp(vnodeCall, keyProperty, context); return vnodeCall; } }        createTransformContext   createTransformContext(root, options)\n 单纯的构建和初始化 transform 转换器上下文对象。\nstage-1: 01 simple text   一些初始化的工作，并不需要具体实现什么，纯文本并没有用到。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68  export function createTransformContext( root, { prefixIdentifiers = false, hoistStatic = false, cacheHandlers = false, nodeTransforms = [], directiveTransforms = {}, transformHoist = null, isBuiltInComponent = NOOP, expressionPlugins = [], scopeId = null, ssr = false, onError = defaultOnError, } ) { const context = { // options  prefixIdentifiers, hoistStatic, cacheHandlers, nodeTransforms, directiveTransforms, transformHoist, isBuiltInComponent, expressionPlugins, scopeId, ssr, onError, // state  root, helpers: new Set(), components: new Set(), directives: new Set(), hoists: [], imports: new Set(), temps: 0, cached: 0, identifiers: {}, scopes: { vFor: 0, vSlot: 0, vPre: 0, vOnce: 0, }, parent: null, currentNode: root, childIndex: 0, // methods  helper(name) {}, helperString(name) {}, replaceNode(node) {}, removeNode(node) {}, onNodeRemoved: () =\u0026gt; {}, addIdentifiers(exp) {}, removeIdentifiers(exp) {}, hoist(exp) {}, cache(exp, isVNode = false) {}, }; function addId(id) {} function removeId(id) {} return context; }      stage-2: 02 pure interpolation 插值节点的编译  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26  export function createTransformContext( root, { ... } ) { const context = { // ...  helpers: new Set(), // ...  // 新增 helper 实现  helper(name) { context.helpers.add(name); return name; }, // ...  }; function addId(id) {} function removeId(id) {} return context; }        createRootCodegen   createRootCodegen(root, context)\n 创建 root 节点上的 codegenNode 值，这也是将来用来编译成 render 函数的源码字符串。\nstage-1: 01 simple text  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22  function createRootCodegen(root, context) { // TODO helper  const { children } = root; const child = children[0]; if (children.length === 1) { // 只有一个孩子节点  // 且孩子节点是一个元素 element 类型，将它放在一个代码块钟返回  // 如： { code }  if (isSingleElementRoot(root, child) \u0026amp;\u0026amp; child.codegenNode) { // TODO  } else { root.codegenNode = child; } } else if (children.length \u0026gt; 1) { } else { // 没有孩子节点， codegen 返回 null，看到没  // 01 simple text 返回 null 问题找到根源了  } }     实现完这个之后发现，generate 里面的 genNode 还没实现，真实丢三落四~~~~。\n    createStructuralDirectiveTransform   createStructuralDirectiveTransform(name, fn)\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27  function createStructuralDirectiveTransform(name, fn) { const matches = isString(name) ? (n) =\u0026gt; n === name : (n) =\u0026gt; name.test(n); return (node, context) =\u0026gt; { if (node.type === 1 /* ELEMENT */) { const { props } = node; // structural directive transforms are not concerned with slots  // as they are handled separately in vSlot.ts  if (node.tagType === 3 /* TEMPLATE */ \u0026amp;\u0026amp; props.some(isVSlot)) { return; } const exitFns = []; for (let i = 0; i \u0026lt; props.length; i++) { const prop = props[i]; if (prop.type === 7 /* DIRECTIVE */ \u0026amp;\u0026amp; matches(prop.name)) { // structural directives are removed to avoid infinite recursion  // also we remove them *before* applying so that it can further  // traverse itself in case it moves the node around  props.splice(i, 1); i--; const onExit = fn(node, prop, context); if (onExit) exitFns.push(onExit); } } return exitFns; } }; }      traverseNode   traverseNode(node, context)\nstage-1: 01 simple text 省略 switch 里面的上线，因为这里只是纯文本不再 case 范围。  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37  export function traverseNode(node, context) { context.currentNode = node; const { nodeTransforms } = context; const exitFns = []; for (let i = 0; i \u0026lt; nodeTransforms.length; i++) { // 调用诸如 transformText 的函数  const onExit = nodeTransforms[i](node, context); if (onExit) { const fns = Array.isArray(onExit) ? onExit : [onExit]; exitFns.push(...fns); } if (!context.currentNode) { // 可能被移除了  return; } else { // 节点可能被替换过，重新建立引用  node = context.currentNode; } } switch (node.type) { // ... 省略  case NodeTypes.ROOT: traverseChildren(node, context); break; } let i = exitFns.length; // 执行所有转换  while (i--) { exitFns[i](); } }      stage-2: 02 pure interpolation 插值节点的编译   增加 INTERPOLATION 类型节点分支处理。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20  export function traverseNode(node, context) { // ...  switch (node.type) { // ...  // 新增：对插值类型节点处理  case NodeTypes.INTERPOLATION: if (!context.ssr) { // 这个函数来自上下文处理中的 helper(name)  context.helper(TO_DISPLAY_STRING); } break // ...  } // ...  }     修改之后代码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43  export function traverseNode(node, context) { context.currentNode = node; const { nodeTransforms } = context; const exitFns = []; for (let i = 0; i \u0026lt; nodeTransforms.length; i++) { // 调用诸如 transformText 的函数  const onExit = nodeTransforms[i](node, context); if (onExit) { const fns = Array.isArray(onExit) ? onExit : [onExit]; exitFns.push(...fns); } if (!context.currentNode) { // 可能被移除了  return; } else { // 节点可能被替换过，重新建立引用  node = context.currentNode; } } switch (node.type) { // ... 省略  case NodeTypes.INTERPOLATION: if (!context.ssr) { // 这个函数来自上下文处理中的 helper(name)  context.helper(TO_DISPLAY_STRING); } break; case NodeTypes.ROOT: traverseChildren(node, context); break; } let i = exitFns.length; // 执行所有转换  while (i--) { exitFns[i](); } }      stage-3: 05-interpolation, v-if, props   增加 IF 和 IF_BRANCH 分支处理：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50  export function traverseNode(node, context) { context.currentNode = node; const { nodeTransforms } = context; const exitFns = []; for (let i = 0; i \u0026lt; nodeTransforms.length; i++) { // 调用诸如 transformText 的函数  const onExit = nodeTransforms[i](node, context); if (onExit) { const fns = Array.isArray(onExit) ? onExit : [onExit]; exitFns.push(...fns); } if (!context.currentNode) { // 可能被移除了  return; } else { // 节点可能被替换过，重新建立引用  node = context.currentNode; } } switch (node.type) { // ... 省略  case NodeTypes.INTERPOLATION: if (!context.ssr) { // 这个函数来自上下文处理中的 helper(name)  context.helper(TO_DISPLAY_STRING); } break; case NodeTypes.IF: for (let i = 0; i \u0026lt; node.branches.length; i++) { traverseNode(node.branches[i], context); } break; case NodeTypes.IF_BRANCH: case NodeTypes.ELEMENT: case NodeTypes.ROOT: traverseChildren(node, context); break; } let i = exitFns.length; // 执行所有转换  while (i--) { exitFns[i](); } }        TODO createIfBranch(…)   traverseChildren   traverseChildren(parent, context)\n 处理 node.children 孩子节点。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18  export function traverseChildren(parent, context) { let i = 0; const nodeRemoved = () =\u0026gt; { i--; }; for (; i \u0026lt; parent.children.length; i++) { const child = parent.children[i]; // 过略掉字符串，只处理 ast child  if (typeof child === \u0026#34;string\u0026#34;) continue; context.parent = parent; context.childIndex = i; context.onNodeRemoved = nodeRemoved; traverseNode(child, context); } }      遍历所有 ast ，让每个节点持有自父级引用。\n  遍历所有节点，进行 traverseNode，解析出 codegenNode 值\n    buildProps   buildProps(node, context, props = node.props, ssr = false)\nstage-1 05-interpolation, v-if, props  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135  export function buildProps(node, context, props = node.props, ssr = false) { const { tag, loc: elementLoc } = node; const isComponent = node.tagType === ElementTypes.COMPONENT; let properties = []; // 保存合并之后的属性，前提是有重复属性，比如：  // class,style 会合并成一个  // v-on 的 handlers 会合并成数组  const mergeArgs = []; const runtimeDirectives = []; let patchFlag = 0; let hasRef = false; let hasClassBinding = false; let hasStyleBinding = false; let hasHydrationEventBinding = false; let hasDynamicKeys = false; const dynamicPropNames = []; const analyzePatchFlag = ({ key, value }) =\u0026gt; { if (key.type === NodeTypes.SIMPLE_EXPRESSION \u0026amp;\u0026amp; key.isStatic) { const name = key.content; // TODO v-on  if ( value.type === NodeTypes.JS_CACHE_EXPRESSION || ((value.type === NodeTypes.SIMPLE_EXPRESSION || value.type === NodeTypes.COMPOUND_EXPRESSION) \u0026amp;\u0026amp; getStaticType(value) \u0026gt; 0) ) { // 如果 prop 是一个 cached handler 或者有一个常量值，就忽略  return; } if (name === \u0026#34;ref\u0026#34;) { hasRef = true; } else if (name === \u0026#34;class\u0026#34; \u0026amp;\u0026amp; !isComponent) { hasClassBinding = true; } // TODO style, 动态属性名  } else { hasDynamicKeys = true; } }; for (let i = 0; i \u0026lt; props.length; i++) { // 静态属性  const prop = props[i]; if (prop.type === NodeTypes.ATTRIBUTE) { const { loc, name, value } = prop; // TODO hasRef  // TODO skip \u0026lt;component :is=\u0026#34;...\u0026#34;\u0026gt;  // 处理静态属性  properties.push( createObjectProperty( createSimpleExpression( name, true, getInnerRange(loc, 0, name.length) ), createSimpleExpression( value ? value.content : \u0026#34;\u0026#34;, true, value ? value.loc : loc ) ) ); } else { // DIRECTIVE 指令处理  // name 指令名, arg 指令参数，exp 指令表达式  const { name, arg, exp, loc } = prop; const isBind = name === \u0026#34;bind\u0026#34;; // TODO v-slot  // TODO v-once  // TODO v-is 或 :is + \u0026lt;component\u0026gt;  // TODO isOn \u0026amp;\u0026amp; ssr  // TODO v-bind 和 v-on 没有参数情况  // 取出对应的 transform 函数处理，比如：v-bind 对应 transformBind  const directiveTransform = context.directiveTransforms[name]; if (directiveTransform) { const { props, needRuntime } = directiveTransform(prop, node, context); !ssr \u0026amp;\u0026amp; props.forEach(analyzePatchFlag); properties.push(...props); // TODO needRuntime  } else { // TODO 没有内置 transform，表示该指令是用户自定义的  // runtimeDirectives.push(prop)  } } } let propsExpression = undefined; // TODO v-bind=\u0026#34;object\u0026#34; 或 v-on=\u0026#34;object\u0026#34;  // 合并属性  if (mergeArgs.length) { // TODO merge args  } else if (properties.length) { propsExpression = createObjectExpression( dedupeProperties(properties), elementLoc ); } // patchFlag 分析  if (hasDynamicKeys) { // TODO  } else { if (hasClassBinding) { patchFlag |= PatchFlags.CLASS; } // TODO 其他, style, 动态属性，hydration  } // TODO need_patch  return { props: propsExpression, directives: runtimeDirectives, patchFlag, dynamicPropNames, }; }        hoistStatic   hoistStatic(root, context)\n1 2 3 4 5 6 7 8 9  // 静态提升，将静态文本节点提升吗？？？  export function hoistStatic(root, context) { walk( root.children, context, new Map(), isSingleElementRoot(root, root.children[0]) ); }      walk   walk(children, context, resultCache, doNotHoistNode = false)\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80  function walk(children, context, resultCache, doNotHoistNode = false) { let hasHoistedNode = false; let hasRuntimeConstant = false; for (let i = 0; i \u0026lt; children.length; i++) { const child = children[i]; if ( child.type === NodeTypes.ELEMENT \u0026amp;\u0026amp; child.tagType === ElementTypes.ELEMENT ) { let staticType; if ( !doNotHoistNode \u0026amp;\u0026amp; (staticType === getStaticType(child, resultCache)) \u0026gt; 0 ) { if (staticType === StaticType.HAS_RUNTIME_CONSTANT) { hasRuntimeConstant = true; } // 整个树都是静态的  child.codegenNode.patchFlag = PatchFlags.HOISTED + (__DEV__ ? ` /* HOISTED */` : ``); child.codegenNode = context.hoist(child.codegenNode); hasHoistedNode = true; continue; } else { // 节点包含动态孩子节点，但是它的属性可能符合 hoisting 条件  const codegenNode = child.codegenNode; if (codegenNode.type === NodeTypes.VNODE_CALL) { const flag = getPatchFlag(codegenNode); if ( (!flag || flag === PatchFlags.NEED_PATCH || flag === PatchFlags.TEXT) \u0026amp;\u0026amp; !hasDynamicKeyOrRef(child) \u0026amp;\u0026amp; !hasCachedProps(child) ) { const props = getNodeProps(child); if (props) { codegenNode.props = context.hoist(props); } } } } } else if (child.type === NodeTypes.TEXT_CALL) { const staticType = getStaticType(child.content, resultCache); if (staticType \u0026gt; 0) { if (staticType === StaticType.HAS_RUNTIME_CONSTANT) { hasRuntimeConstant = true; } child.codegenNode = context.hoist(child.codegenNode); hasHoistedNode = true; } } // 递归孩子节点  if (child.type === NodeTypes.ELEMENT) { walk(child.children, context, resultCache); } else if (child.type === NodeTypes.FOR) { // 不提升 v-for 单孩子节点因为它会变成一个 block  walk(child.children, context, resultCache, child.children.length === 1); } else if (child.type === NodeTypes.IF) { for (let i = 0; i \u0026lt; child.branches.length; i++) { const branchChildren = child.branches[i].children; // 不提升 v-if 单孩子节点因为它会变成一个 block  walk(branchChildren, context, resultCache, branchChildren.length === 1); } } } if (!hasRuntimeConstant \u0026amp;\u0026amp; hasHoistedNode \u0026amp;\u0026amp; context.transformHoist) { context.transformHoist(children, context); } }      processIf   processIf(node, dir, context, processCodegen)\n 处理 v-if/v-else/v-else-if 指令的函数。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65  export function processIf(node, dir, context, processCodegen) { // TODO no exp error handle  // TODO prefixIdentifiers \u0026amp;\u0026amp; dir.exp  if (dir.name === \u0026#34;if\u0026#34;) { const branch = createIfBranch(node, dir); const ifNode = { type: NodeTypes.IF, loc: node.loc, branches: [branch], }; context.replaceNode(ifNode); if (processCodegen) { return processCodegen(ifNode, branch, true); } } else { // 找到对应的兄弟节点(v-if)  const siblings = context.parent.children; const comments = []; // 当前分支节点在其父节点的 children 中的位置  // 方便后面找到前面最近的那个兄弟  let i = siblings.indexOf(node); while (i-- \u0026gt;= -1) { const sibling = siblings[i]; if (__DEV__ \u0026amp;\u0026amp; sibling \u0026amp;\u0026amp; sibling.type === NodeTypes.COMMENT) { context.removeNode(sibling); // 将来要合并回去的  comments.unshift(sibling); continue; } if (sibling \u0026amp;\u0026amp; sibling.type === NodeTypes.IF) { // 1. 将当前节点删除同时将移动到 if 分支的 branches[] 中去  context.removeNode(); if (__DEV__ \u0026amp;\u0026amp; comments.length) { branch.children = [...comments, ...branch.children]; } sibling.branches.push(branch); // 这个 onExit 就是用来 transform 分支得到codegenNode的那个函数  const onExit = processCodegen \u0026amp;\u0026amp; processCodegen(sibling, branch, false); // 2. 因为 1 中已经将节点从主干递归树种删除了，因此这里需要手动执行一次  // traverse 确保该分支节点的树能正确解析出 codgenNode  traverseNode(branch, context); // 3. 执行 transform 函数，解析当前节点的 codegenNode  if (onExit) onExit(); // 4. 重置 currentNode，表明该节点已经被删除了  // 还记得 traverseNode 里面收集 exitFns 循环找那个有个检测吧  context.currentNode = null; } else { // 非法的使用，v-if/v-else/v-else-if 必须紧靠着  context.onError( createCompilerError(ErrorCodes.X_V_ELSE_NO_ADJACENT_IF, node.loc) ); break; } } } }        codegen.ts  createCodgenContext(ast, context)  stage-1: 01 simple text  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63  // 构建 condegen 上下文对象  function createCodegenContext( ast, { mode = \u0026#34;function\u0026#34;, prefixIdentifiers = mode === \u0026#34;module\u0026#34;, sourceMap = false, filename = `template.vue.html`, scopeId = null, optimizeBindings = false, runtimeGlobalName = `Vue`, runtimeModuleName = `vue`, ssr = false, } ) { const context = { mode, prefixIdentifiers, sourceMap, filename, scopeId, optimizeBindings, runtimeGlobalName, runtimeModuleName, ssr, source: ast.loc.source, code: ``, column: 1, line: 1, offset: 0, indentLevel: 0, pure: false, map: undefined, helper(key) {}, push(code, node) { context.code += code; // TODO 非浏览器环境处理，node 环境  }, indent() { // 新行缩进  newline(++context.indentLevel); }, deindent(withoutNewLine = false) { if (withoutNewLine) { --context.indentLevel; } else { newline(--context.indentLevel); } }, newline() { newline(context.indentLevel); }, }; function newline(n) { context.push(\u0026#34;\\n\u0026#34; + ` `.repeat(n)); } function addMapping(loc, name) {} return context; }        generate()   generate 函数雏形：\n1 2 3 4 5 6 7  export function generate(ast, options) { return { ast, code: \u0026#34;\u0026#34;, map: \u0026#34;\u0026#34;, }; }     函数的目的是：通过 ast 来生成 code，这个 code 将来会被 compileToFunction 调用 new Function(code) 生成 render 函数的。\nstage-1: 01 simple text  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83  export function generate(ast, options = {}) { const context = createCodegenContext(ast, options); const { mode, push, prefixIdentifiers, indent, deindent, newline, scopeId, ssr, } = context; const hasHelpers = ast.helpers.length \u0026gt; 0; const useWithBlock = !prefixIdentifiers \u0026amp;\u0026amp; mode !== \u0026#34;module\u0026#34;; const genScopeId = !__BROWSER__ \u0026amp;\u0026amp; scopeId != null \u0026amp;\u0026amp; mode === \u0026#34;module\u0026#34;; // TODO preambles  if (!__BROWSER__ \u0026amp;\u0026amp; mode === \u0026#34;module\u0026#34;) { // TODO genModulePreamble(ast, context, genScopeId)  } else { genFunctionPreamble(ast, context); } if (genScopeId \u0026amp;\u0026amp; !ssr) { push(`const render = ${PURE_ANNOTATION}_withId(`); } if (!ssr) { // 函数声明  push(`function render(_ctx, _cache) {`); } else { // TODO ssr render  } indent(); if (useWithBlock) { // use with(_ctx) { ...}  push(`with (_ctx) {`); indent(); // TODO hasHelpers  } // TODO ast.components 组件处理  // TODO ast.directives 指令处理  // TODO ast.temps 临时变量处理  // TODO 换行  if (!ssr) { push(`return `); } // 生成代码片段  if (ast.codegenNode) { genNode(ast.codegenNode, context); } else { push(`null`); } if (useWithBlock) { deindent(); push(`}`); } deindent(); push(`}`); if (genScopeId \u0026amp;\u0026amp; !ssr) { push(`)`); } return { ast, code: context.code, map: \u0026#34;\u0026#34;, }; }     代码中只包含文本解析需要的内容。但是结果显示：\nast: {type: 0, children: Array(1), loc: {…}, helpers: Array(0), components: Array(0), …} code: \u0026#34;function render(_ctx, _cache) {↵ with (_ctx) {↵ return null}}\u0026#34; map: \u0026#34;\u0026#34;   即： ast.codegenNode 是空值，最后并没有 执行 genNode(ast.codgenNode, context) 。\n 因此问题还在 transformText 里面，但是纯文本会直接在第一个 for 后的 if 判断中直接 return 了，那么问题出在哪？？？\n 进过往上追溯，发现在 traverseNode 实现中有一部分 switch 代码被我们省略，而里面就 有个 case 是文本节点会走到的，即： NodeTypes.ROOT 因为这个用例文本是直接挂在根 节点下面的，那么就得实现 traverseChildren 了。\n 然后，实现完 traverseChildren 之后并没解决问题，因为这里面根本没有处理赋值 codgenNode 的操作。\n 那么只能用最笨拙的方法了，直接搜索 codegen* 然后又发现新大陆(transform 里面有 个 createRootCodgen(…) 并没有实现)， 🏃‍♂️ go -\u0026gt;\n  stage-2: 02 pure interpolation   这里新增了 push ast.helpers.map(...) 处理，比如 traverseNode stage-2 中新增的 INTERPOLATION 分支中的处理是 context.helper(TO_DISPLAY_STRING) 就是给上下文的 helpers 增加了 Symbol(\u0026#39;toDisplayString\u0026#39;) 。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31  export function generate(ast, options = {}) { // ...  const hasHelpers = ast.helpers.length \u0026gt; 0; // ...  if (useWithBlock) { // use with(_ctx) { ...}  push(`with (_ctx) {`); indent(); // 新增： hasHelpers  if (hasHelpers) { // 比如：插值处理时用到 TO_DISPLAY_STRING helper  // 为了避免命名冲突，这里都需要将他们重命名  push( `const { ${ast.helpers .map((s) =\u0026gt; `${helperNameMap[s]}: _${helperNameMap[s]}`) .join(\u0026#34;, \u0026#34;)}} = _Vue` ); push(\u0026#34;\\n\u0026#34;); newline(); } } // ...  }     正好在这里会检测 context.helpers 进行相应的处理。\n traverseNode 的 switch 中插值 INTERPOLATION 分支处理中增加了一个 TO_DISPLAY_STRING 符号类型值到 context.helpers: Set 中，这其实就是个 _Vue 实例中的一个函数名称，在这里会遍历 context.helpers 将需要用到的函数从实例中解 构出来。\n    genNode(node, context)  stage-3: 04-interpolation in div with props   这个用例中需要解析 props[{ id }, { class }] 这两个属性经过 buildProps 处理之后 会变成一个对象结构：\n { type: 15 /* JS_OBJECT_EXPRESSION */, properties: [{id}, {class}], ...}\n1 2 3 4 5 6 7 8  0: key: {type: 4 /*SIMPLE_EXPRESSION*/, loc: {…}, isConstant: false, content: \u0026#34;id\u0026#34;, isStatic: true} type: 16 // JS_PROPERTY  value: {type: 4, loc: {…}, isConstant: false, content: \u0026#34;foo\u0026#34;, isStatic: true} 1: key: {type: 4, content: \u0026#34;class\u0026#34;, isStatic: true, isConstant: true, loc: {…}} type: 16 // JS_PROPERTY  value: {type: 4, content: \u0026#34;bar.baz\u0026#34;, isStatic: false, isConstant: false, loc: {…}}     所以这里首先需要增加一个 JS_OBJECT_EXPRESSION 分支处理这两个属性，解析成属性对 象传递给 _createBlock(\u0026#39;div\u0026#39;, props, ...)\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32  function genNode(node, context) { if (typeof node === \u0026#34;string\u0026#34;) { context.push(node); return; } // TODO is symbol  switch (node.type) { // ... 省略  case NodeTypes.ELEMENT: genNode(node.codegenNode, context); break; case NodeTypes.TEXT: genText(node, context); break; case NodeTypes.SIMPLE_EXPRESSION: // 如：插值内容，属性值  genExpression(node, context); break; case NodeTypes.INTERPOLATION: console.log(node, \u0026#34;interpolation\u0026#34;); genInterpolation(node, context); break; case NodeTypes.VNODE_CALL: genVNodeCall(node, context); break; case NodeTypes.JS_OBJECT_EXPRESSION: // 新增属性 properties处理  genObjectExpression(node, context); break; }      stage-2: 02 pure interpolation   这个阶段需要支持插值的解析，而插值在 ast 中数据结构为：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17  { \u0026#34;type\u0026#34;:5, // INTERPOLATION \u0026#34;content\u0026#34;:{ \u0026#34;type\u0026#34;:4, // SIMPLE_EXPRESSION \u0026#34;isStatic\u0026#34;:false, \u0026#34;isConstant\u0026#34;:false, \u0026#34;content\u0026#34;:\u0026#34;world.burn()\u0026#34;, \u0026#34;loc\u0026#34;:{ // ... , \u0026#34;source\u0026#34;:\u0026#34;world.burn()\u0026#34; } }, \u0026#34;loc\u0026#34;:{ // ..., \u0026#34;source\u0026#34;:\u0026#34;{{ world.burn() }}\u0026#34; } }     这里需要经过两次递归调用 genNode 分别去解析 type=5 // INTERPOLATION 和 type=4 // SIMPLE_EXPRESSION 两种类型，且前后形同父子关系。\n 那么就有：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23  function genNode(node, context) { if (typeof node === \u0026#34;string\u0026#34;) { context.push(node); return; } // TODO is symbol  switch (node.type) { // ... 省略  case NodeTypes.TEXT: genText(node, context); break; case NodeTypes.SIMPLE_EXPRESSION: // 如：插值内容，属性值  genExpression(node, context); break; case NodeTypes.INTERPOLATION: console.log(node, \u0026#34;interpolation\u0026#34;); genInterpolation(node, context); break; } }      先经过 INTERPOLATION 分支调用 genInterpolation(node, context) 去解析插值节点\n    stage-1: 01 simple text   这里我们只处理文本节点的情况：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  function genNode(node, context) { if (typeof node === \u0026#34;string\u0026#34;) { context.push(node); return; } // TODO is symbol  switch (node.type) { // ... 省略  case NodeTypes.TEXT: genText(node, context); break; } }     然后就是实现 case 的 genText(node, context)\n    genNodeList(nodes, context, multilines=false, comma=true)   生成 _createBlock(tag, props, children, …) 函数的参数列表。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24  function genNodeList(nodes, context, multilines = false, comma = true) { const { push, newline } = context; for (let i = 0; i \u0026lt; nodes.length; i++) { const node = nodes[i]; if (typeof node === \u0026#34;string\u0026#34;) { push(node); } else if (Array.isArray(node)) { genNodeListAsArray(node, context); } else { // nodes[1], props 进入这里处理  genNode(node, context); } if (i \u0026lt; nodes.length - 1) { if (multilines) { comma \u0026amp;\u0026amp; push(\u0026#34;,\u0026#34;); newline(); } else { comma \u0026amp;\u0026amp; push(\u0026#34;, \u0026#34;); } } } }      genNodeListAsArray(nodes, context)   将参数列表转成数组， nodes: [tag, props, chldren, ...] -\u0026gt; [\u0026#39;div\u0026#39;, {}, ...}]\n1 2 3 4 5 6 7 8 9 10 11 12 13 14  // 将参数们变成数组  function genNodeListAsArray(nodes, context) { const multilines = nodes.length \u0026gt; 3 || ((!__BROWSER__ || __DEV__) \u0026amp;\u0026amp; nodes.some((n) =\u0026gt; Array.isArray(n) || !isText(n))); context.push(`[`); multilines \u0026amp;\u0026amp; context.indent(); genNodeList(nodes, context, multilines); multilines \u0026amp;\u0026amp; context.deindent(); context.push(`]`); }      genNullableArgs(args)   过滤掉参数列表尾部值为 假值 的参数。\n1 2 3 4 5 6 7 8 9 10 11  // 过滤尾部 nullable 的值  function genNullableArgs(args) { let i = args.length; while (i--) { if (args[i] != null) break; } // 中间的 nullable 值 转成 null  return args.slice(0, i + 1).map((arg) =\u0026gt; arg || `null`); }      genObjectExpression(node, context)    空属性列表，返回 {}\n  先 genExpressionAsPropertyKey(node, context) 解析属性名\n  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34  // 生成对象表达式，用来处理 properties  function genObjectExpression(node, context) { const { push, indent, deindent, newline } = context; const { properties } = node; if (!properties.length) { push(`{}`, node); return; } const multilines = properties.length \u0026gt; 1 || ((!__BROWSER__ || __DEV__) \u0026amp;\u0026amp; properties.some((p) =\u0026gt; p.value.type !== NodeTypes.SIMPLE_EXPRESSION)); push(multilines ? `{` : `{ `); multilines \u0026amp;\u0026amp; indent(); for (let i = 0; i \u0026lt; properties.length; i++) { const { key, value } = properties[i]; // key 处理，属性名  genExpressionAsPropertyKey(key, context); push(`: `); // value 处理，属性值，如果是静态的字符串化，如果是动态的直接变量方式  // 如： id=\u0026#34;foo\u0026#34; -\u0026gt; id: \u0026#34;foo\u0026#34;  // 如： :class=\u0026#34;bar.baz\u0026#34; -\u0026gt; class: bar.baz  // 这里 bar 是对象，baz 是 bar对象的属性  genNode(value, context); if (i \u0026lt; properties.length - 1) { push(`,`); newline(); } } multilines \u0026amp;\u0026amp; deindent(); push(multilines ? `}` : ` }`); }      genExpressionAsPropertyKey(node, context)   生成对象属性名：\n  属性名由组合表达式动态生成，如： { [prefix + \u0026#39;_\u0026#39; + name]: \u0026#39;value\u0026#39; }\n  静态属性，又分标准标识符和非标准的(需要用引号包起来的)，如： { foo: \u0026#39;value\u0026#39; } 或 { \u0026#39;23adf34\u0026#39;: \u0026#39;value\u0026#39; }\n  简单的动态属性，如： { [foo]: \u0026#39;value\u0026#39; }\n  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19  function genExpressionAsPropertyKey(node, context) { const { push } = context; if (node.type === NodeTypes.COMPOUND_EXPRESSION) { push(`[`); genCompoundExpression(node, context); push(`]`); } else if (node.isStatic) { // 静态属性  const text = isSimpleIdentifier(node.content) ? node.content : JSON.stringify(node.content); push(text, node); } else { // 动态属性  push(`[${node.content}]`, node); } }      genCompoundExpression(node, context)  1 2 3 4 5 6 7 8 9 10  function genCompoundExpression(node, context) { for (let i = 0; i \u0026lt; node.children.length; i++) { const child = node.children[i]; if (typeof child === \u0026#34;string\u0026#34;) { context.push(child); } else { genNode(child, context); } } }      genText(node, context)   这里没什么阶段性的，就是一句很简单的字符串化文本节点内容。\n1 2 3 4  function genText(node, context) { // 文本直接字符串化  context.push(JSON.stringify(node.content), node); }      genFunctionPreamble(ast, context)    生成 const _Vue = Vue\n  一些函数的全局提升解构，如： const { createVNode: _createVnode } = _Vue\n  一些静态属性提升，如： const _hoisted_1 = {key: 0}\n  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49  function genFunctionPreamble(ast, context) { const { push, newline, ssr, runtimeGlobalName, runtimeModuleName, prefixIdentifiers, } = context; // TODO ...  const VueBinding = !__BROWSER__ \u0026amp;\u0026amp; ssr ? `require(${JSON.striingify(runtimeModuleName)})` : runtimeGlobalName; const aliasHelper = (s) =\u0026gt; `${helperNameMap[s]}: _${helperNameMap[s]}`; if (ast.helpers.length \u0026gt; 0) { if (!__BROWSER__ \u0026amp;\u0026amp; prefixIdentifiers) { push( `const { ${ast.helpers.map(aliasHelper).join(\u0026#34;, \u0026#34;)}} = ${VueBinding}\\n` ); } else { // with 模式，重命名 Vue 避免冲突  push(`const _Vue = ${VueBinding}\\n`); if (ast.hoists.length) { const staticHelpers = [ CREATE_VNODE, CREATE_COMMENT, CREATE_TEXT, CREATE_STATIC, ] .filter((helper) =\u0026gt; ast.helpers.includes(helper)) .map(aliasHelper) .join(\u0026#34;, \u0026#34;); push(`const { ${staticHelpers}} = _Vue\\n`); } } } // TODO 生成 ssr helpers 变量  genHoists(ast.hoists, context); newline(); push(`return `); }      genInterpolation(node, context)  1 2 3 4 5 6 7 8 9 10  function genInterpolation(node, context) { const { push, helper, pure } = context; if (pure) push(PURE_ANNOTATION); push(`${helper(TO_DISPLAY_STRING)}(`); // 调用 genNode 解析插值的内容，表达式节点类型，NodeTypes.SIMPLE_EXPRESSION  genNode(node.content, context); push(`)`); }     context.helper(TO_DISPLAY_STRING) 是从 helpersMap 中取出 TO_DISPLAY_STRING 对 应的函数名称(下划线重命名之后的名称)，看 context.helper 实现:\n1 2 3  helper(key) { return `_${helperNameMap[key]}`; }     别名操作在 generate 的 useWithBlock 判断中生成。\n  genExpression(node, context)  1 2 3 4  function genExpression(node, context) { const { content, isStatic } = node; context.push(isStatic ? JSON.stringify(content) : content, node); }     表达式的值可以是静态的，也可以是动态的，\n  TODO 如果是静态直接字符串化？？？\n  DONE 如果是动态的直接 push content 变成变量直接从上下文去取变量值\n 如 02 pure interpolation 中的 world.burn() 会直接被塞到 context.code 结合 成 return _toDisplayString(world.burn()); 生成函数之后相当于这样调 用： _ctx.world.burn() 。\n    genVNodeCall(node, context)  stage-1 03-inerpolation in pure div   增加 createVNode helper\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33  function genVNodeCall(node, context) { const { push, helper, pure } = context; const { tag, props, children, patchFlag, dynamicProps, directives, isBlock, isForBlock, } = node; // TODO directives start  // TODO isblock start  if (pure) { push(PURE_ANNOTATION); } push(helper(isBlock ? CREATE_BLOCK : CREATE_VNODE) + `(`, node); // TODO genNodeList  push(`)`); // TODO isblock end  // TODO directives end  }        genCallExpression(node, context)  1 2 3 4 5 6 7 8 9 10 11  function genCallExpression(node, context) { const { push, helper, pure } = context; const callee = typeof node.callee === \u0026#34;string\u0026#34; ? node.callee : helper(node.callee); if (pure) { push(PURE_ANNOTATION); } push(callee + `(`, node); genNodeList(node.arguments, context); push(`)`); }      genConditionalExpression(node, context)   genHoists(ast.hoists, context)    scope id 处理\n  静态提升 const _hoisted_i = xxx\n  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30  function genHoists(hoists, context) { if (!hoists.length) { return; } context.pure = true; const { push, newline, helper, scopeId, mode } = context; const genScopeId = !__BROWSER__ \u0026amp;\u0026amp; scopeId != null \u0026amp;\u0026amp; mode !== \u0026#34;function\u0026#34;; newline(); // 先 push scope id 在初始化 hoisted vnodes 之前，从而这些节点能获取到适当的 scopeId  if (genScopeId) { push(`${helper(PUSH_SCOPE_ID)}(\u0026#34;${scopeId}\u0026#34;)`); newline(); } hoists.forEach((exp, i) =\u0026gt; { if (exp) { push(`const _hoisted_${i + 1}= `); genNode(exp, context); newline(); } }); if (genScopeId) { push(`${helper(POP_SCOPE_ID)}()`); newline(); } context.pure = false; }        虚拟节点创建函数     name transform desc     createTextVNode transformText 创建文本虚拟节点        ","permalink":"https://www.cheng92.com/vue/vue3-source-code-function-list/","tags":["vue,","vue3,","vuenext,","compiler"],"title":"Vue3 所有函数源码即简要说明"},{"categories":["javascript"],"contents":"  window.g_fold_chapter = 1   本文默认处于折叠状态，可点击标题后方的 … 展开或闭合。 \n 参考链接：\n  https://muyiy.cn/question/js/33.html\n   JavaScript  节流和防抖    防抖：动作发生后，延时多久后执行动作回调\n 比如：点击事件，点击之后在一定时间后触发回调，在该时间内如果再发生点击事件 不会立即触发回调，而是重置延时触发时间。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17  function debounce(fn, time) { let timer = null return function() { clearTimeout(timer) timer = setTimeout(() =\u0026gt; fn.apply(this, arguments), time) } } function log(time) { setTimeout(() =\u0026gt; console.log(\u0026#39;x: \u0026#39; + time), time || 10) } const dlog = debounce(log, 100) dlog(10) dlog(50) dlog(100) dlog(120)    x: 120   10, 50, 100 都没触发，因为执行间隔都不超过 100 所以被 clearTimeout 取消了， 知道第四个 dlog(120) 调用，后面没有了，得到执行输出结果。\n  节流：两个动作触发有一定的时间间隔\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30  function throttle(fn, duration) { let last = 0 return function() { let current = Date.now() if (current - last \u0026lt; duration) return fn.apply(this, arguments) last = Date.now() } } function log(time) { console.log(\u0026#39;x: \u0026#39; + time) } function delay(time) { setTimeout(() =\u0026gt; dlog(time), time) } // 100ms 间隔  const dlog = throttle(log, 100) delay(10) delay(50) delay(150) delay(160) delay(270)    x: 10 // now - 0 \u0026gt;= 100 x: 150 // 150 - 50 \u0026gt;= 100 x: 270 // 270 - 160 \u0026gt;= 100    防抖和节流区别\n 防抖 是指同一种类型的动作无论发生多少次，只要间隔时间不够长，就永远只会触发 最后那一个动作回调 。\n 节流 是指两个动作中间必须间隔特定的时间，否则后面的动作不会触发，即在这固 定的时间间隔之内的动作会被忽略， 只会执行第一个动作回调 。\n  测试：\n移动鼠标到我上面移动，离开时重置，移动时观察蓝条变化，停止时观察红条变化 debounce throttle         下面的代码打印什么？  IIFE 函数名是个常量？   函数定义实现原理： http://ecma-international.org/ecma-262/5.1/#sec-13\n 博客内伪码链接 -\u0026gt;\u0026gt;\n  非严格模式\n1 2 3 4 5 6  var b = 10 ;(function b() { b = 20 console.log(b) })()    [Function: b]   输出结果分析：非严格模式下 IIFE 的函数名不能进行赋值，如果赋值了的话静默是失 败的，所以说 b = 20 这一句没其任何作用，函数内部的 b 还是 IIFE 的那个函数 名，所以最后输出依旧是 [Function: b] 。\n   严格模式\n1 2 3 4 5 6 7 8 9 10 11  var b = 10 try { ;(function b() { \u0026#34;use strict\u0026#34;; b = 20 console.log(b) })() } catch(e) { console.log(e) }    TypeError Assignment to constant variable.   结果分析：将 IIFE 内部换成严格模式就能很明显的说明问题了，上面结果报错“不能给 常量赋值”，立即函数名是不可变的常量。\n   window.b/this.b\n1 2 3 4 5 6 7 8  var b = 10; (function b() { b = 20 console.log(b) console.log(this.b) // 10  })()    [Function: b] 10   因为这里是以 node module 环境运行的，所以不能直接使用 window.b/this.b/global.b 去取到外面的 var b = 10 的值，结果是根据浏览器环境 运行结果。\n 第二个 log 结果是 10 ，原因是在全局作用域下用 var 声明的变量是全局变 量，会挂到 window 对象下面，所以可以直接通过 window.b 取到它的值，用 this.b 也能取到是因为 IIFE 函数调用上下文是在全局，所以 this 指向 window 。\n   函数提升(声明+赋值)\n1 2 3 4 5 6 7 8 9 10 11 12 13  var b = 10 function b() { b = 20 console.log(b) } console.log({ b }) try { b() } catch(e) { console.log(e.message) }    { b: 10 } b is not a function   结果分析：提升对于命名式函数表达式来说，它的声明和赋值都会被提升，对于 var 声明的变量只会提升声明，所以就有   function b 声明和赋值提升， var b 声明提升，由于声明只会发生一次， 所以这里相当于只有一次声明和赋值，即此时有变量 b 它的值是 function b() {} 。\n  但是 var b = 10 的赋值不会提升，所以当执行到这一句的时候， b 的值 会被这里的赋值操作给替换成 10 。\n     只有 b = 10\n1 2 3 4 5 6 7 8  function b() { console.log(b) // [Function b]  b = 1 console.log(window.b) // 1  console.log(b) // 1  } b()    [Function b] 1 1          CSS(3)  transition 动画   CSS Transition Examples – How to Use Hover Animation, Change Opacity, and More\n    ","permalink":"https://www.cheng92.com/web/web-fe-zero/","tags":["javascript,","web"],"title":"前端，一点都不好玩"},{"categories":[],"contents":"","permalink":"https://www.cheng92.com/web/javascript-native-dev-with-rollupjs/","tags":[],"title":"用 Rollupjs 打包原生项目"},{"categories":["javascript"],"contents":"   源码参考链接：https://github.com/stefanpenner/es6-promise\n   完整的 promise.js 链接  构造函数 Promise    三个状态: PENDING, FULFILL, REJECT 。\n  PID 记录 promise id 属性\n  _state 当前 promise 的状态(pending/fulfill/reject)\n  _result 当前 promise 任务执行的结果值\n  _subs 当前 promise 的订阅者(then 时注册的 resolver/rejection)\n  构造函数中立即执行 resolver 根据任务执行情况由使用者决定是调用 resolvePromise 还是 rejectPromise\n  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38  var PID = Math.random().toString(36).substring(2); var PENDING = 0; var FULFILL = 1; var REJECT = 2; var i = 0; var proto = MyPromise.prototype; var noop = function () {}; function MyPromise(resolver) { this[PID] = i++; this._state = PENDING; this._result = undefined; this._subs = []; if (!this instanceof Promise) { throw new TypeError(\u0026#34;只能通过new 构造 Promise 实例。\u0026#34;); } var _this = this; try { resolver( function resolvePromise(value) { resolve(_this, value); }, function rejectPromise(reason) { reject(_this, reason); } ); } catch (e) { reject(this, e); } } MyPromise.prototype.then = then; function resolve(val) { console.log(val, \u0026#39;resolve\u0026#39;) } function reject() {}     测试：\n1 2 3 4  const { MyPromise, Util} = require(`${process.env.PWD}/../../static/js/promise.js`) const p = new MyPromise(function (resolve, reject) { Util.delay(() =\u0026gt; resolve(100), 1000) })    100 resolve    resolve 和 reject 函数   这两个函数至关重要，他们负责改变 promise 的状态值，也是整个 Promise 实现过程中唯 一能改变状态值的地方。\n 他们的执行会触发所有回调的执行(promise._subs)。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22  function resolve(promise, value) { if (promise === value) { reject(promise, Util.error.returnSelfPromise()); } else if (Util.isObjectOrFunction(value)) { // TODO  } else { fulfill(promise, value); } } function reject(promise, reason) { if (promise._state !== PENDING) { return; } promise._state = REJECT; promise._result = reason; asap(function () { publish(promise); }); }      asap 函数  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29  // 将所有任务添加到一个队列，根据平台决定调用那个异步函数  var queue = new Array(1000); var qlen = 0; function asap(callback) { queue[qlen] = callback; qlen++; if (qlen === 1) { // 这里是通过第一次入列操作来触发 flush 队列操作  // 因为 flush 是异步执行，所以在它还没之前之前有可能有新的任务入列  // 这个时候 qlen \u0026gt; 1 ，直到 flush 执行，通过 qlen 遍 queue 确保在执行的时刻  // 可以将这之前的所有入列的任务都得到执行  setTimeout(flush()); } } function flush() { for (var i = 0; i \u0026lt; qlen; i++) { var callback = queue[i]; if (callback) callback(); // 清空已执行的任务  queue[i] = undefined; } // 在此刻至 Flush之前入列的任务都得到了执行，重置重新接受新的任务  qlen = 0; }     按照 Promise 的定义，被 Promise 定义的任务不论代码是异步的还是同步的，都会被当做 异步任务来执行，比如：\n1 2 3 4  new Promise((resolve)=\u0026gt; { resolve(100) }).then(val =\u0026gt; console.log(100)) console.log(200)    200 100   结果显示 200 先输出，后输出 100，但是其实我们在 new Promise() 的时候传入的函数 里面其实都是同步代码，经过 Promise 封装置后都成了异步的了。\n 因此这里的 asap 就是这个作用，当任务就算是同步代码的时候，依然将其变成异步任务去 执行。\n 并且这里使用了一个队列 queue 来管理这些任务，针对原作者的代码做了一些改动，去 掉了平台有关的代码，并将任务直接二次封装成了一个函数，所以这里是 qlen++ 而不是 qlen +=2 。\n 这里如果不仔细思考可能还不太好理解原作者为什么这么做？？？\n  为什么 qlen === 1 的时候触发 flush ?\n 答 ：其实想明白了也简单，就是为了只要队列是空的时候一旦有新的任务进来就立即触发任务 出列 flush 掉队列中所有的任务，并且是顺序执行，顺序执行，顺序执行，重要的事 情说三遍嘛，想象下如果没有这个机制，一旦有 promise settled 了，就调用一个 setTimeout ?  有了这个机制之后，在 当前的 setTimeout flush 之前，会尽可能的让当前队列承载 更多的 promise 任务，直到 flush 结束，重启另一个 setTimeout。\n   为什么不直接使用 queue 数组的长度来控制 ?\n TODO\n    情景测试：在 flush 之前 qlen 值发生变化了，需要做点修改让效果更直观。\n1 2 3 4 5 6 7 8 9 10 11  function asap(callback) { queue[qlen] = callback; qlen++; if (qlen === 1) { // 这里加大 flush 的时间点，让 asap 有足够的时间来响应更多的异步任务  setTimeout(flush, 3000); } }     测试代码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25  const { MyPromise, Util} = require(`${process.env.PWD}/../../static/js/promise.js`) const p1 = new MyPromise((resolve) =\u0026gt; { Util.delay(() =\u0026gt; resolve(100)) }).then(val =\u0026gt; { console.log(val, \u0026#39;p1 then 1\u0026#39;) }) new MyPromise((resolve) =\u0026gt; { Util.delay(() =\u0026gt; resolve(100)) }).then(val =\u0026gt; { console.log(val, \u0026#39;p2 then 1\u0026#39;) }) new MyPromise((resolve) =\u0026gt; { Util.delay(() =\u0026gt; resolve(100)) }).then(val =\u0026gt; { console.log(val, \u0026#39;p3 then 1\u0026#39;) }) new MyPromise((resolve) =\u0026gt; { Util.delay(() =\u0026gt; resolve(100)) }).then(val =\u0026gt; { console.log(val, \u0026#39;p4 then 1\u0026#39;) })    { qlen: 1 } { qlen: 2 } { qlen: 3 } { qlen: 4 } 100 p1 then 1 100 p2 then 1 100 p3 then 1 100 p4 then 1   看到没， qlen=4 了，因为我们在 asap 中调用 flush 的时候加了 3 秒的延时，所以能 很直观的看得到在一个 settimeout 回调之前会接受到多个 promise 任务。\n  then 函数实现  then 功能说明：    收集 pending 状态 promise 的 callback(存放到 _subs 中)\n 因为 promise 任务如果异步的，调用 then(resolve,reject) 的时候，resolve 和 reject 是不应该立即执行的，必须等异步任务结束之后再执行，否则就不符合了 promise 原则(异步任务同步化)。\n 所以当 promise 任务是异步情况下，then 函数的功能应该是用来收集 resolve/reject 的，等待任务结束后调用。\n  作为 then 链式调用的桥梁，即这个桥梁必须是在这个函数里面去完成的。\n   既然有了收集，那必然就有触发动作，触发也必须等待任务执行完成才会触发，也就是说这 个动作必须是在 resolve() 里面完成，因为 Promise 使用者会根据自己任务情况去在适 当的位置调用 resolve 和 reject。\n  需要完成的函数：   fulfill(promise, value) ，任务成功完成\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  function fulfill(promise, result) { if (promise._state !== PENDING) { // 状态已经完成不能再改变状态  return; } promise._state = FULFILL; promise._result = result; if (promise._subs.length \u0026gt; 0) { asap(function () { publish(promise); }); } }     publish(promise)  任务完成之后 flush 掉所有回调(then pending 阶段收集的 _subs[])\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20  function publish(promise) { var subs = promise._subs; var child, callback, result = promise.result; for (var i = 0; i \u0026lt; subs.length; i += 3) { child = subs[i]; callback = subs[i + promise._state]; if (child) { // TODO 异步任务  } else { callback(result); } } subs.length = 0; }     subscribe(parent, child, onFulfillment, onRejection)\n 如果任务是个异步任务就不会立即执行，要等到任务结束才能执行回调，所以就必须要有 个地方能将这些回调收集到当前的 promise 实例中，等待调用。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17  function subscribe(parent, child, onFulfillment, onRejection) { var subs = parent._subs; var len = subs.length; // PENDING  subs[len] = child; subs[len + FULFILL] = onFulfillment; subs[len + REJECT] = onRejection; // parent promise 状态如果完成了，立即触发当前 child 的 promise  // 可能执行到这里的时候任务刚好完成了???  if (len === 0 \u0026amp;\u0026amp; parent._state) { asap(function () { publish(parent); }); } }     then(onFulfillment, onRejection)  这里要区分两种情况，一种是 pending 状态和非 pending 状态的处理，pending 说明可 能是异步任务还没结束，不能立即 settled，调用 subscribe() 去收集回调。\n 一种是非 pending 状态，在调用 then 之后只有一种情况会使得 promise 状态改变了， 那就是任务立即执行，调用了 resolve 或 reject 设置了 promise._state 改变 了状态，因为只有这两个函数才会改变 promise 状态值。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19  function then(onFulfillment, onRejection) { var parent = this; // 创建一个新的 promise，用来衔接后面的 then  var child = new this.constructor(noop); var _state = this._state; // 根据状态决定执行哪个回调  var callback = arguments[_state - 1]; if (_state) { // 状态已经改变，任务已经完成了，直接执行回调  invokeCallback(_state, child, callback, parent._result); } else { // 订阅所有回调  subscribe(parent, child, onFulfillment, onRejection); } return child; }     invokeCallback(settled, promise, callback, detail)\n 这个函数承载了当前 then promise1 的回调执行并解析结果(异常处理)，然后将值传递 给下一个 then promise2(then 里面 new this.constructor(noop) 出来的)，调用 resolve(child)~或 ~reject(child) 去触发 promise2 的回调。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44  function invokeCallback(settled, promise, callback, detail) { var value; // 记录 callback 执行的结果  var hasCallback = typeof callback === \u0026#34;function\u0026#34;; var succeeded = true; // callback 可能执行失败  var error; if (hasCallback) { // 开始执行 callback, 即 then(resolve, reject) 的 Resolve/Reject  try { // 将上一个 promise 结果作为参数传递到 then 回调  value = callback(detail); } catch (e) { // 回调执行失败，有错误或者异常  error = e; succeeded = false; } if (promise === value) { reject(promise, Util.error.returnSelfPromise()); return; } } else { // 没有回调的时候 then() ???  value = detail; } // 这里要检测下一个新 new 的 promise 状态  // 下面的动作都是为了下一个 then 做准备的，这里的promise  // 是在上一个 then 里面的new 出来的 promise 衔接下一个 then 用  if (promise._state !== PENDING) { // noop 状态完成了的 promise  } else if (hasCallback \u0026amp;\u0026amp; succeeded) { // 执行成功， resolve  resolve(promise, value); } else if (succeeded === false) { // then 中的回调执行失败了  reject(promise, error); } else if (settled === FULFILL) { fulfill(promise, value); } else if (settled === REJECT) { reject(promise, value); } }      测试：\n1 2 3 4 5 6 7  const { MyPromise, Util} = require(`${process.env.PWD}/../../static/js/promise.js`) const p = new MyPromise((resolve, reject) =\u0026gt; { Util.delay(() =\u0026gt; resolve(100)) }).then(val =\u0026gt; { Util.log(val, \u0026#39;then 1 resolve\u0026#39;) })     +RESULTS 实现 invokeCallback 之前:\nundefined   这里没任何输出，因为还没实现 invokeCallback(settled, promise, callback, detail) 这里面会针对 then 的 resolve 或 reject 执行结果做出相应的处理。\n 实现关键点：   callback 实际上是 then(resolve, reject) 中的 resolve/reject ，根据上一个 promise 状态 settled 决定的。\n  使用 try…catch 捕获 callback 执行异常，确保 then 回调也能受 Promise 规则约 束。\n  几种情况决定调用 resolve 还是 reject 进入下一个链式回调(then)。\n  +RESULTS 实现 invokeCallback 之后:\n100 then 1 resolve   此时的 promise._subs 如下：\n[ MyPromise { \u0026#39;8st4da5md17\u0026#39;: 1, _state: 0, _result: undefined, _subs: [] // 这是那个 child promise }, [Function (anonymous)], // 这里是 then resolver undefined // 这里是 then rejection 因为没传所以是 undefined ]    then 链式调用：  1 2 3 4 5 6 7 8 9 10 11  const { MyPromise, Util} = require(`${process.env.PWD}/../../static/js/promise.js`) const p = new MyPromise((resolve, reject) =\u0026gt; { Util.delay(() =\u0026gt; resolve(100)) }).then(val =\u0026gt; { /* p1 */ Util.log(val, \u0026#39;then 1 resolve\u0026#39;) return 200 }, /* p2 */).then(val =\u0026gt; {/* p3 */ Util.log(val, \u0026#39;then 2 resolve\u0026#39;) return 300 }, /* p4 */)    100 then 1 resolve 200 then 2 resolve      then callback 返回对象或函数   针对返回对象的情况，其实也可以跟普通类型处理一样：\n 首先要把 Resolve 里面对对象和函数的检测去掉，或者也让它执行 fulfill(promise, value) :\n1 2 3 4 5 6 7 8 9 10  function resolve(promise, value) { if (promise === value) { reject(promise, Util.error.returnSelfPromise()); } else if (Util.isObjectOrFunction(value)) { // TODO  fulfill(promise, value); } else { fulfill(promise, value); } }     实例：\n1 2 3 4 5 6 7 8 9 10  const { MyPromise, Util} = require(`${process.env.PWD}/../../static/js/promise.js`) const p = new MyPromise((resolve) =\u0026gt; { Util.delay(() =\u0026gt; resolve(100)) }).then(val =\u0026gt; { console.log(val, \u0026#39;, then 1\u0026#39;) return { name: \u0026#39;then 1 return\u0026#39; } }).then(val =\u0026gt; { console.log(val, \u0026#39;, then 2\u0026#39;) })    100 , then 1 { name: \u0026#39;then 1 return\u0026#39; } , then 2   但是如果有多个 then 链式调用的情况，一般都会返回一个对象，并且常见情况会是一个异 步的 promise ，这样统一当成普通类型处理就显得不太合理了，这也是为何原作者将返回 值是 函数或对象 的时候分开处理了。\n 因为在实际使用中，有以下几种场景：\n  返回纯对象类型(非 promise 或 带有 then 的对象)\n  返回一个新的 promise 实例\n  返回一个带有 then 的对象或函数\n  所以需要做一些特殊处理。\nvalue 可能是 null   捕获这种情况异常执行 reject。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19  function resolve(promise, value) { if (promise === value) { reject(promise, Util.error.returnSelfPromise()); } else if (Util.isObjectOrFunction(value)) { let then; try { then = value.then; } catch (e) { // value 可能是 undefined 或 null，或其他非法类型(如：数字)  reject(promise, e); return; } // handleMaybeThenable(promise, value, then);  } else { fulfill(promise, value); } }     测试：\n1 2 3 4 5 6 7 8 9  const { MyPromise, Util} = require(`${process.env.PWD}/../../static/js/promise.js`) const p = new MyPromise(resolve =\u0026gt; { Util.delay(resolve(null)) }).then(val =\u0026gt; { console.log(val, \u0026#39;p then resolve 1\u0026#39;) }, reason =\u0026gt; { console.log(reason.message, \u0026#39;, p then reject 1\u0026#39;) })    Cannot read property \u0026#39;then\u0026#39; of null , p then reject 1    value 返回的是一个 Promise 实例   即使用者在 then 回调里面 new 了一个 Promise 实例返回出来，这也是常见的使用场 景之一，经常会有多个有依赖前后结果的异步请求的时候，通过 promise then 来链 式同步执行。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19  function resolve(promise, value) { if (promise === value) { reject(promise, Util.error.returnSelfPromise()); } else if (Util.isObjectOrFunction(value)) { let then; try { then = value.then; } catch (e) { // value 可能是 undefined 或 null，或其他非法类型(如：数字)  reject(promise, e); return; } handleMaybeThenable(promise, value, then); } else { fulfill(promise, value); } }     增加 handleMaybeThenable(promise, value, then); 函数处理其他情况。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18  function handleMaybeThenable(promise, thenable, then) { // originalThen 实现的 then 函数，即 MyPromise.prototype.then  // 这能确保 thenable 的确是我们的 MyPromise 实例  if (thenable.constructor === promise.constructor \u0026amp;\u0026amp; thenable.resolve === originalResolve \u0026amp;\u0026amp; thenable.then === originalThen) { // 这里要做的处理是直接针对 thenable 状态做出判断  if (thenable._state === FULFILL) { fulfill(promise, thenable._result) } else if (thenable._state === REJECT) { reject(promise, thenable._result) } else { // 直接构造 resolver 和 rejection  subscribe(thenable, undefined, val =\u0026gt; resolve(promise, val), reason =\u0026gt; reject(promise, reason)) } } else { // TODO  } }     这样，我们就可以处理 then 回调中返回一个 Promise 实例的情况了。\n 测试：\n1 2 3 4 5 6 7 8 9 10 11 12  const { MyPromise, Util} = require(`${process.env.PWD}/../../static/js/promise.js`) const p = new MyPromise(resolve =\u0026gt; { Util.delay(resolve(100)) }).then(val =\u0026gt; { console.log(val, \u0026#39;, p then 1 resolve\u0026#39;) return new MyPromise(resolve =\u0026gt; { Util.delay(resolve(200)) }) }).then(val =\u0026gt; { console.log(val, \u0026#39;, p then 2 resolve\u0026#39;) })    100 , p then 1 resolve 200 , p then 2 resolve undefined   所以很顺利的就看到了正确的结果，因为返回的本身就是 MyPromise ，所以只需要根据 其状态做相应的处理即可(fulfill / reject / subscribe)。\n  value 有可能有自己的 then 函数呢？  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29  function handleForeignThenable(promise, thenable, then) { asap(() =\u0026gt; () =\u0026gt; { let sealed = false; // 保证只会执行一次  try { then.call( thenable, (value) =\u0026gt; { if (sealed) return; sealed = true; if (value !== thenable) { resolve(promise, value); } else { fulfill(promise, value); } }, (reason) =\u0026gt; { if (sealed) return; sealed = true; reject(promise, reason); } ); } catch (e) { sealed = true; reject(promise, e); } }); }     测试：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17  const { MyPromise, Util} = require(`${process.env.PWD}/../../static/js/promise.js`) const p = new MyPromise(resolve =\u0026gt; { Util.delay(resolve(100)) }).then(val =\u0026gt; { console.log(val, \u0026#39;, p then 1 resolve\u0026#39;) return { name: 1, then(resolve, reject) { console.log(resolve, reject, \u0026#39;object then\u0026#39;) resolve(200) } } }).then(val =\u0026gt; { console.log(val, \u0026#39;, p then 2 resolve\u0026#39;) })    100 , p then 1 resolve [Function (anonymous)] [Function (anonymous)] object then 200 , p then 2 resolve   如果返回的对象类型属性有一个 then 函数的话，则 MyPromise 的处理是将 resolve 和 reject 封装一层传递给外部的 then ，由它决定何时使用？。\n 注释 resolve(200) 之后：\n100 , p then 1 resolve [Function (anonymous)] [Function (anonymous)] object then   对比下原生的 Promise 呢，将 MyPromise 换成 Promise 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17  const { MyPromise, Util} = require(`${process.env.PWD}/../../static/js/promise.js`) const p = new Promise(resolve =\u0026gt; { Util.delay(resolve(100)) }).then(val =\u0026gt; { console.log(val, \u0026#39;, p then 1 resolve\u0026#39;) return { name: 1, then(resolve, reject) { console.log(resolve, reject, \u0026#39;object then\u0026#39;) resolve(200) } } }).then(val =\u0026gt; { console.log(val, \u0026#39;, p then 2 resolve\u0026#39;) })    100 , p then 1 resolve [Function (anonymous)] [Function (anonymous)] object then 200 , p then 2 resolve   结果和 MyPromise 一样，如果在 object then 中不调用 resolve 或 reject 结果， 那么 then 链也会断开：\n100 , p then 1 resolve [Function (anonymous)] [Function (anonymous)] object then    疑问 1： foreign then 的 resolve 为什么要判断返回值是不是等于该对象自身？\n1 2 3 4 5  if (value !== thenable) { resolve(promise, value); } else { fulfill(promise, value); }     答 ：如果 value === thenable ，直接调用 resolve(promise, value) 会造成死循 环 resolve -\u0026gt; value.then is function -\u0026gt; handleMaybeThenable -\u0026gt; handleForeignThenable -\u0026gt; resolve -\u0026gt; …\n 验证方法，将 asap 延迟时间加大，并且给 asap 套一层，加上延时时间，如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  function asap(callback) { queue[qlen] = callback; qlen++; if (qlen === 1) { // 这里是通过第一次入列操作来触发 flush 队列操作  // 因为 flush 是异步执行，所以在它还没之前之前有可能有新的任务入列  // 这个时候 qlen \u0026gt; 1 ，直到 flush 执行，通过 qlen 遍 queue 确保在执行的时刻  // 可以将这之前的所有入列的任务都得到执行  setTimeout(flush, 3000); } } let bakAsap = asap asap = cb =\u0026gt; setTimeout(bakAsap(cb), 500)     这样可以避免卡死，每隔 500ms 会执行一次 asap，3000ms 之后 flush queue。\n 修改如下，直接 resolve：\n1 2 3 4 5 6 7 8 9 10 11 12  (value) =\u0026gt; { if (sealed) return; sealed = true; resolve(promise, value); // if (value !== thenable) {  // resolve(promise, value);  // } else {  // fulfill(promise, value);  // }  }     修改用例：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17  let i = 0 new MyPromise(resolve =\u0026gt; { Util.delay(resolve(100)) }).then(val =\u0026gt; { console.log(val, \u0026#39;, p then 1 resolve\u0026#39;) const obj = { name: 1, then(resolve, reject) { console.log(i++, \u0026#39;, object then\u0026#39;) resolve(obj) } } return obj }).then(val =\u0026gt; { console.log(val, \u0026#39;, p then 2 resolve\u0026#39;) })     执行结果：\n➜ js git:(master) ✗ node promise.js 100 , p then 1 resolve 0 , object then 1 , object then 2 , object then 3 , object then 4 , object then 5 , object then 6 , object then // 如果不停止会一直执行下去，因为死循环了      Promise Api 实现   在 ecma262 文档中我们知道 Promise 有如下 APIs：\n    名称 简介     Promise all(iterable) 满足条件：所有 promises 都 fulfilled    allSettled(iterable) 不在乎结果是 FULFILL 还是 REJECT，只要所有的任务状态都改变了就 FULFILL 否则 REJECT    any(iterable) 只要有一个任务 FULFILL 结果就是 FULFILL 否则 REJECT    race(iterable) 竞争关系，第一个状态改变发生改变 race 状态就跟着改变，是啥就是啥，FULFILL -\u0026gt; FULFILL, REJECT -\u0026gt; REJECT    reject(rejectHandler) 返回一个必定 REJECT 的 promise    resolve(fulfillHandler) 返回一个必定 FULFILL 的 promise     Promise.prototype catch(onRejected)     finally(onFinally)     then(onFulfilled, onRejected)      当目前表中的函数只实现了 then 和 resolve 下面将一一实现它们。\nPromise.reject(rejectHandler)  1 2 3 4 5  const { MyPromise, Util} = require(`${process.env.PWD}/../../static/js/promise.js`) Promise.reject(\u0026#39;test reject result\u0026#39;).then(null, reason =\u0026gt; { console.log(reason, \u0026#39;, p reject then\u0026#39;) })    test reject result , p reject then   这个跟 Promise.resolve 一样，直接创建一个 Promise 实例 ins，调用 reject(ins, reason) 1 2 3 4 5 6 7 8 9 10 11 12  function originalReject(reason) { const ctor = this; if (typeof value === \u0026#34;object\u0026#34; \u0026amp;\u0026amp; value.constructor === ctor) { return value; } const ins = new ctor(noop); reject(promise, reason); return ins; }      Promise.race(entries)   race 竞争机制，只要有一个 fulfilled 了就立即结束。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14  const { MyPromise, Util} = require(`${process.env.PWD}/../../static/js/promise.js`) const p1 = new MyPromise(resolve =\u0026gt; { Util.delay(() =\u0026gt; resolve(100), 100) }) const p2 = new MyPromise((resolve, reject) =\u0026gt; { Util.delay(() =\u0026gt; reject(200), 80) }) MyPromise.race([p1, p2]).then(val =\u0026gt; { console.log(val, \u0026#39;, race then resolve\u0026#39;) }, reason =\u0026gt; { console.log(reason, \u0026#39;, race then reject\u0026#39;) })    200 , race then reject   只要有一个状态改变了就里面结束 race ，它不在乎结束的时候那个 promise 是 fulfilled 还是 rejected 。\n 实现：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21  MyPromise.race = function (entries) { const ctor = this; if (!Array.isArray(entries)) { return new ctor((_, reject) =\u0026gt; reject(new TypeError(\u0026#34;race 参数必须是一个数组\u0026#34;)) ); } else { return new ctor((resolve, reject) =\u0026gt; { // 遍历所有任务  const len = entries.length; for (let i = 0; i \u0026lt; len; i++) { // 直接调用 resolve 去执行任务，然后挂一个 then  // 因为 resolve 和 reject 只会被执行一次，所以一旦只要有个 entry  // 结束了就会执行后面的 then 去调用 resolve 或 reject，  // 后面的就算执行到了也 settled 了，也不会重复执行 resolve 和 reject  ctor.resolve(entries[i]).then(resolve, reject); } }); } }      Promise.any(entries)  只要有个 promise fulfilled 了，返回的 promise 状态就会变成 fulfilled，否则是 rejected，并且 rejected then 的回调接受的参数 reason 会是 entries 中所有 rejected promise 结果值数组.\n 修改点：将应该 fulfill() 地方换成 reject() 。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91  function Enumerator(entries, option) { var p = (this.promise = new Ctor(noop)); this.option = option || {}; // 保存结束的函数，所有任务都 settled 之后调用的函数  // Promise.any 所有的 REJECT 会调用 reject  // Promise.all 所有的都 FULFILL 会调用 fulfill  // 所以要区分开  this.$settle = opt.isPromiseAnyFlag ? reject : fulfill; if (Array.isArray(entries)) { // ... 省略  if (this._length === 0) { // 结束了  this.$settle(p, this._result); } else { this._enumerate(entries); if (this._remaining === 0) { // 所有任务状态改变了  this.$settle(p, this._result); } } } else { // 必须是数组类型  reject(p, new TypeError(\u0026#34;必须提供数组类型\u0026#34;)); } } Enumerator.prototype._enumerate = function (entries) { var p = this.promise; // 当前 promise 状态处于 PENDING 状态下进行遍历  for (var i = 0; p._state === PENDING \u0026amp;\u0026amp; i \u0026lt; entries.length; i++) { var entry = entries[i]; var then, error; try { then = entry.then; } catch (e) { error = e; } if (then === originalThen \u0026amp;\u0026amp; entry._state !== PENDING) { // ... 省略  } else if (typeof then !== \u0026#34;function\u0026#34;) { // ... 省略  } else if (p.constructor === Ctor) { var promise = new Ctor(noop); if (error) { // 这里如果执行错误要区分下是 Promise.any 还是 Promise.all  if (this.option.isPromiseAnyFlag) { this._result[i] = error; this._remaining--; } else { reject(entry, error); } } else { } // ...  } else { // ...  } } }; Enumerator.prototype._settle = function (state, i, result) { var p = this.promise; var opt = this.option; if (p._state === PENDING) { this._remaining--; // 修改点  // for Promise.any  if (opt.isPromiseAnyFlag) { if (state === REJECT) { this._result[i] = result; } else { resolve(p, result); } } else { // ...  } } if (this._remaining === 0) { // Promise.any 应该 reject  // 修改点  this.$settle(p, this._result); } };     测试：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24  const { MyPromise, Util} = require(`${process.env.PWD}/../../static/js/promise.js`) const p1 = new MyPromise(resolve =\u0026gt; { Util.delay(() =\u0026gt; resolve(100), 100) }) const p2 = new MyPromise((resolve, reject) =\u0026gt; { Util.delay(() =\u0026gt; reject(200), 80) }) const p3 = new MyPromise((resolve, reject) =\u0026gt; { Util.delay(() =\u0026gt; reject(300), 80) }) MyPromise.any([p1, p2]).then(val =\u0026gt; { console.log(val, \u0026#39;, any then resolve 1\u0026#39;) }, reason =\u0026gt; { console.log(reason, \u0026#39;, any then reject 1\u0026#39;) }) MyPromise.any([p2, p3]).then(val =\u0026gt; { console.log(val, \u0026#39;, any then resolve 2\u0026#39;) }, reason =\u0026gt; { console.log(reason, \u0026#39;, any then reject 2\u0026#39;) })    [ 200, 300 ] , any then reject 2 100 , any then resolve 1   第一行输出：p2, p3 都是 REJECT ，所以最后结果是 REJECT 第二行输出：p1, p2 中 p1 是 FULFILL ，所以最后结果是 FULFILL\n  Promise.all(entries)   all 函数的实现关键：要等到所有的 promise 状态都 settled 了，才能 fulfill。\n 然后任务有异步也可能有同步任务(即 promise 状态是否立即改变)，不管如何都要等到他 们状态发生改变了之后才能让 all 结束，所以两种处理情况\n  状态立即发生改变了的，直接记录\n  状态是 PENDING 的注册记录回调直到所有任务都完成\n  如果遇到有一个 rejected 的立即结束，否则等待所有都 fulfilled 才结束，并且将所 有 fulfilled 结果组成数组传递给下一个 promise。\n  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89  // 简化版本，只处理：  // 1. entry 是 promise 类型，  // 2. entry 是普通类型(非 promise，then 不是函数)  Enumerator.prototype._enumerateSimple = function (entries) { var p = this.promise; for (var i = 0; p._state === PENDING \u0026amp;\u0026amp; i \u0026lt; entries.length; i++) { var entry = entries[i]; if (entry.constructor === Ctor) { // 是个 promise 任务  if (entry._state !== PENDING) { this._settle(entry._state, i, entry._result); } else { this._willSettle(entry, i); } } else { // 非 promise 类型处理  this._remaining--; this._result[i] = entry; } } }; Enumerator.prototype._enumerate = function (entries) { var p = this.promise; // 当前 promise 状态处于 PENDING 状态下进行遍历  for (var i = 0; p._state === PENDING \u0026amp;\u0026amp; i \u0026lt; entries.length; i++) { var entry = entries[i]; var then, error; try { then = entry.then; } catch (e) { error = e; } if (then === originalThen \u0026amp;\u0026amp; entry._state !== PENDING) { // entry 不一定是 Promise 但有 then 函数，且状态改变了的  this._settle(entry._state, i, entry._result); } else if (typeof then !== \u0026#34;function\u0026#34;) { // 普通类型值  this._remaining--; this._result[i] = entry; } else if (p.constructor === Ctor) { // 到这里前提条件：  // 1. then 不是 originalThen 或 entry._state = PENDING  // 2. then 是个函数  // 3. this.promise 是我们定义的 MyPromise  // 那么将 entry 用 MyPromise 封装  var promise = new Ctor(noop); if (error) { reject(entry, error); } else { handleMaybeThenable(promise, entry, then); } this._willSettle(promise, i); } else { this._willSettle(new Ctor((resolve) =\u0026gt; resolve(entry)), i); } } }; Enumerator.prototype._settle = function (state, i, result) { var p = this.promise; if (p._state !== PENDING) { this._remaining--; if (state === REJECT) { reject(p, result); } else { this._result[i] = result; } } if (this._remaining === 0) { fulfill(p, this._result); } }; Enumerator.prototype._willSettle = function (promise, i) { // 订阅结果  subscribe( promise, undefined, (value) =\u0026gt; this._settle(FULFILL, i, value), (reason) =\u0026gt; this._settle(REJECT, i, reason) ); };     原作者的实现通过封装了一个 Enumerator 来实现 Promise.all 其中有一个构造函数 (Enumerator)和三个原型函数(_settle, _willSettle, _enumrate)。\n  Enumerator 接受一个 entries 是一个数组\n 构造函数初始化了几个变量：\n  _length 即 entries 任务的个数\n  _remaining 任务状态是 PENDING 的个数，通过检测这个是不是为零来判断是不是 所有任务都结束了。\n  _result 一个结果数组，保存所有任务执行的结果。\n    _settle 检测当前 entry 的状态，如果是 REJECT 就让 this.promise REJECT ，结束循环，否则保存结果，最后检测 this._remaining 。\n  _willSettle 因为 entry 的状态可能是 PENDING 所以要执行订阅，等待它结束再进 入 _settle 回到第 2 步。\n   所以这个函数的实现关键取决于 entry 状态是否是立即改变了，如果是直接检测结果，否 则构造该 entry 的 onFulfillment 和 onRejection 并执行订阅，等待它结束再检测 结果。最后根据结果决定 this.promise 状态，因为 Promise.all FULFILL 的条件 是所有任务都 FULFILL 才行，所以只要遇到一个 entry rejected 了那么 this.promise 就应该结束且状态是 REJECT 。\n 测试\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21  const { MyPromise, Util} = require(`${process.env.PWD}/../../static/js/promise.js`) const p1 = new MyPromise(resolve =\u0026gt;{ Util.delay(() =\u0026gt; resolve(100), 100) }) const p2 = new MyPromise(resolve =\u0026gt;{ Util.delay(() =\u0026gt; resolve(200), 80) }) const p3 = new MyPromise((_, reject) =\u0026gt;{ Util.delay(() =\u0026gt; reject(300), 80) }) MyPromise.all([p1, p2]).then(result =\u0026gt; { console.log(result, \u0026#39;, promise all 1\u0026#39;) }) MyPromise.all([p1, p3]).then(null, reason =\u0026gt; { console.log(reason, \u0026#39;, promise all 2\u0026#39;) })    300 , promise all 2 [ 100, 200 ] , promise all 1   改成原生 Promise 结果：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21  const { MyPromise, Util} = require(`${process.env.PWD}/../../static/js/promise.js`) const p1 = new Promise(resolve =\u0026gt;{ Util.delay(() =\u0026gt; resolve(100), 100) }) const p2 = new Promise(resolve =\u0026gt;{ Util.delay(() =\u0026gt; resolve(200), 80) }) const p3 = new Promise((_, reject) =\u0026gt;{ Util.delay(() =\u0026gt; reject(300), 80) }) Promise.all([p1, p2]).then(result =\u0026gt; { console.log(result, \u0026#39;, promise all 1\u0026#39;) }) Promise.all([p1, p3]).then(null, reason =\u0026gt; { console.log(reason, \u0026#39;, promise all 2\u0026#39;) })    300 , promise all 2 [ 100, 200 ] , promise all 1   结果 OK。\n  Promise.allSettled(entries)es2020  这个和 Promise.all 区别在于，它不在乎 entries 中任务的状态是 FULFILL 还是 REJECT ， 只要它状态 settled 即可，且会等到所有任务都 settled 了才会 FULFILL 。\n 所以这里的实现和 Promise.all 会有所差别，但依然可以通过对 Enumerator 做细微 改动来实现。\n 修改点：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31  function Enumerator(entries, option) { var p = (this.promise = new Ctor(noop)); // 修改点1：增加 Promise.allSettled flag  this.isAllSettledFlag = false; if (typeof option === \u0026#34;object\u0026#34;) { this.isAllSettledFlag = !!option.isAllSettledFlag; } // ... 省略  } Enumerator.prototype._settle = function (state, i, result) { var p = this.promise; if (p._state === PENDING) { this._remaining--; // api 不是 Promise.allSettled  // 修改点2：增加判断是不是 Promise.allSettled 调用  if (state === REJECT \u0026amp;\u0026amp; !this.isAllSettledFlag) { reject(p, result); } else { this._result[i] = result; } } if (this._remaining === 0) { fulfill(p, this._result); } }     测试：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21  const { MyPromise, Util} = require(`${process.env.PWD}/../../static/js/promise.js`) const p1 = new MyPromise(resolve =\u0026gt;{ Util.delay(() =\u0026gt; resolve(100), 100) }) const p2 = new MyPromise(resolve =\u0026gt;{ Util.delay(() =\u0026gt; resolve(200), 80) }) const p3 = new MyPromise((_, reject) =\u0026gt;{ Util.delay(() =\u0026gt; reject(300), 80) }) MyPromise.allSettled([p1, p2]).then(result =\u0026gt; { console.log(result, \u0026#39;, promise allSettled 1 resolve\u0026#39;) }) MyPromise.allSettled([p1, p3]).then(value =\u0026gt; { console.log(value, \u0026#39;, promise allSettled 2 resolve\u0026#39;) })    [ 100, 200 ] , promise allSettled 1 resolve [ 100, 300 ] , promise allSettled 2 resolve    Promise.prototype.finally(onFinally)   这个函数目的就是不管 promise 任务最重是 fulfilled 还是 rejected 都会被执行。\n 实现如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20  function originalFinally(callback) { var promise = this; var ctor = promise.constructor; // 1. 保证 callback 总是执行，即相当于在最后又挂了个 then，  // 这样就能保证之前有多少 then 且这些 then 结果是 fulfilled 还是 rejected  // 这个都会被执行  // 2. 回调 callback 要被执行且要保证 callback 的执行结果  // 也能符合 promise then 链规则  if (typeof callback === \u0026#34;function\u0026#34;) { return promise.then( (value) =\u0026gt; ctor.resolve(callback(value)).then(() =\u0026gt; value), (reason) =\u0026gt; ctor.resolve(callback(reason)).then(() =\u0026gt; { throw reason; }) ); } return promise.then(callback, callback); }     测试：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21  const { MyPromise, Util} = require(`${process.env.PWD}/../../static/js/promise.js`) new Promise(resolve =\u0026gt; { Util.delay(resolve(100)) }).then(val =\u0026gt; { console.log(val, \u0026#39;then 1\u0026#39;) }).finally(() =\u0026gt; { console.log(\u0026#39;finally 1\u0026#39;) }).then((val) =\u0026gt; { console.log(val, \u0026#39;then 2\u0026#39;) // 这里引用未声明类型，会报错  return a + b }, reason =\u0026gt; { console.log(reason.message, \u0026#39;reject 2\u0026#39;) }).finally(() =\u0026gt; { console.log(\u0026#39;finally 2\u0026#39;) }).finally(100).then(val =\u0026gt; { console.log(val, \u0026#39;then 3\u0026#39;) }, reason =\u0026gt; { console.log(reason.message, \u0026#39;reject 3\u0026#39;) })     原生 Promise 执行结果\n100 then 1 finally 1 undefined then 2 finally 2 a is not defined reject 3   注意这里有几点功能需要完成：\n  finally 总是要被执行\n  finally 的参数可以是普通类型的值\n  finally 调用之后后面还可以继续链式调用，即它执行完也要返回一个 Promise 实例\n  换成 MyPromise:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21  const { MyPromise, Util} = require(`${process.env.PWD}/../../static/js/promise.js`) new MyPromise(resolve =\u0026gt; { Util.delay(resolve(100)) }).then(val =\u0026gt; { console.log(val, \u0026#39;then 1\u0026#39;) }).finally(() =\u0026gt; { console.log(\u0026#39;finally 1\u0026#39;) }).then((val) =\u0026gt; { console.log(val, \u0026#39;then 2\u0026#39;) // 这里引用未声明类型，会报错  return a + b }, reason =\u0026gt; { console.log(reason.message, \u0026#39;reject 2\u0026#39;) }).finally(() =\u0026gt; { console.log(\u0026#39;finally 2\u0026#39;) }).finally(100).then(val =\u0026gt; { console.log(val, \u0026#39;then 3\u0026#39;) }, reason =\u0026gt; { console.log(reason.message, \u0026#39;reject 3\u0026#39;) })    100 then 1 finally 1 undefined then 2 finally 2 a is not defined reject 3   使用 MyPromise 之后又两个异常，被后面两个 then rejection 捕获到了： promise is not defined ，这说明 finally\n 增加返回值传递给 finally 回调，测试：\n1 2 3 4 5 6 7 8 9 10  const { MyPromise, Util} = require(`${process.env.PWD}/../../static/js/promise.js`) new MyPromise(resolve =\u0026gt; { Util.delay(resolve(100)) }).then(val =\u0026gt; { console.log(val, \u0026#39;then 1\u0026#39;) return 200 }).finally((val) =\u0026gt; { console.log(val, \u0026#39;, finally 1\u0026#39;) })    100 then 1 200 , finally 1 undefined    Promise.prototype.catch(onRejection)   ECMA262标准流程：\n26.6.5.1 Promise.prototype.catch ( onRejected ) When the catch method is called with argument onRejected, the following steps are taken: 1. Let promise be the this value. 2. Return ? Invoke(promise, \u0026#34;then\u0026#34;, « undefined, onRejected »).   实现：\n1 2 3 4 5  MyPromise.prototype.catch = function (onRejection) { // 因为如果有异常，异常会随着链式调用链中一直往后流，知道被处理掉  // 所以这里只要挂一个 then 去接受错误并处理就可以了  return this.then(null, onRejection); }     测试：\n1 2 3 4 5 6 7 8 9 10 11 12 13  const { MyPromise, Util} = require(`${process.env.PWD}/../../static/js/promise.js`) new MyPromise(resolve =\u0026gt; { Util.delay(resolve(100)) }).then(val =\u0026gt; { console.log(val, \u0026#39;, then 1\u0026#39;) return a + b }).catch(err =\u0026gt; { console.log(err.message) return 200 }).then(val =\u0026gt; { console.log(val, \u0026#39;, then 2\u0026#39;) })    100 , then 1 a is not defined 200 , then 2   then 2 能够输出是因为 then 1 的错误被 catch 处理掉了，所以 then 2 可以正常 resolve。\n    完整脑图     Jest 测试  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93  const Promise = require(\u0026#34;./promise.js\u0026#34;).MyPromise; const delay = (fn, t) =\u0026gt; setTimeout(fn, t); const log = (...args) =\u0026gt; console.log.apply(console, args); describe(\u0026#34;Promise\u0026#34;, () =\u0026gt; { test(\u0026#34;Promise then resolve\u0026#34;, () =\u0026gt; { return new Promise((resolve) =\u0026gt; delay(() =\u0026gt; resolve(100))).then((value) =\u0026gt; expect(value).toBe(100) ); }); test(\u0026#34;Promise then reject\u0026#34;, () =\u0026gt; { return new Promise((_, reject) =\u0026gt; delay(() =\u0026gt; reject(\u0026#34;test reject\u0026#34;)) ).then(null, (reason) =\u0026gt; expect(reason).toBe(\u0026#34;test reject\u0026#34;)); }); test(\u0026#34;Promise catch\u0026#34;, () =\u0026gt; { return new Promise((resolve) =\u0026gt; delay(() =\u0026gt; resolve(100))) .then(() =\u0026gt; a /* a is not defined */) .catch((err) =\u0026gt; expect(err.message).toBe(\u0026#34;a is not defined\u0026#34;)); }); test(\u0026#34;Promise finally\u0026#34;, () =\u0026gt; { return new Promise((resolve) =\u0026gt; delay(() =\u0026gt; resolve(100))) .then((value) =\u0026gt; 200) .finally((result) =\u0026gt; expect(result).toBe(200)); }); test(\u0026#34;Promise finally with catch\u0026#34;, () =\u0026gt; { return new Promise((resolve) =\u0026gt; delay(() =\u0026gt; resolve(100))) .then((value) =\u0026gt; a) .catch((err) =\u0026gt; err.message) .finally((result) =\u0026gt; expect(result).toBe(\u0026#34;a is not defined\u0026#34;)); }); test(\u0026#34;Promise all\u0026#34;, () =\u0026gt; { const p1 = new Promise((resolve) =\u0026gt; delay(() =\u0026gt; resolve(100), 100)); const p2 = new Promise((_, reject) =\u0026gt; delay(() =\u0026gt; reject(200), 200)); const p3 = new Promise((_, reject) =\u0026gt; delay(() =\u0026gt; reject(300), 80)); const p4 = new Promise((resolve) =\u0026gt; delay(() =\u0026gt; resolve(400), 120)); let pa1 = Promise.all([p1, p4]).then((value) =\u0026gt; value); let pa2 = Promise.all([p1, p2]).then(null, (reason) =\u0026gt; reason); let pa3 = Promise.all([p2, p3]).then(null, (reason) =\u0026gt; reason); return Promise.allSettled([pa1, pa2, pa3]).then((value) =\u0026gt; expect(value).toStrictEqual([[100, 400], 200, 300]) ); }); test(\u0026#34;Promise allSettled\u0026#34;, () =\u0026gt; { const p1 = new Promise((resolve) =\u0026gt; delay(() =\u0026gt; resolve(100), 100)); const p2 = new Promise((_, reject) =\u0026gt; delay(() =\u0026gt; reject(\u0026#34;p2 reject\u0026#34;), 200) ); const p3 = new Promise((resolve) =\u0026gt; delay(() =\u0026gt; resolve(300), 120)); return Promise.allSettled([p1, p2, p3]).then((value) =\u0026gt; expect(value).toStrictEqual([100, \u0026#34;p2 reject\u0026#34;, 300]) ); }); test(\u0026#34;Promise race resolve\u0026#34;, () =\u0026gt; { const p1 = new Promise((resolve) =\u0026gt; delay(() =\u0026gt; resolve(100), 100)); const p2 = new Promise((_, reject) =\u0026gt; delay(() =\u0026gt; reject(\u0026#34;p2 reject\u0026#34;), 200) ); return Promise.race([p2, p1]).then((value) =\u0026gt; expect(value).toBe(100)); }); test(\u0026#34;Promise race reject\u0026#34;, () =\u0026gt; { const p1 = new Promise((resolve) =\u0026gt; delay(() =\u0026gt; resolve(100), 100)); const p2 = new Promise((_, reject) =\u0026gt; delay(() =\u0026gt; reject(\u0026#34;p2 reject\u0026#34;), 80)); return Promise.race([p2, p1]).then(null, (reason) =\u0026gt; expect(reason).toBe(\u0026#34;p2 reject\u0026#34;) ); }); test(\u0026#34;Promise any resolve\u0026#34;, () =\u0026gt; { const p1 = new Promise((resolve) =\u0026gt; delay(() =\u0026gt; resolve(100), 100)); const p2 = new Promise((_, reject) =\u0026gt; delay(() =\u0026gt; reject(\u0026#34;p2 reject\u0026#34;), 80)); const p3 = new Promise((_, reject) =\u0026gt; delay(() =\u0026gt; reject(\u0026#34;p3 reject\u0026#34;), 80)); return Promise.any([p2, p1, p3]).then((value) =\u0026gt; expect(value).toBe(100)); }); test(\u0026#34;Promise any reject\u0026#34;, () =\u0026gt; { const p1 = new Promise((resolve) =\u0026gt; delay(() =\u0026gt; resolve(100), 100)); const p2 = new Promise((_, reject) =\u0026gt; delay(() =\u0026gt; reject(\u0026#34;p2 reject\u0026#34;), 80)); const p3 = new Promise((_, reject) =\u0026gt; delay(() =\u0026gt; reject(\u0026#34;p3 reject\u0026#34;), 80)); return Promise.any([p2, p3]).then(null, (value) =\u0026gt; expect(value).toStrictEqual([\u0026#34;p2 reject\u0026#34;, \u0026#34;p3 reject\u0026#34;]) ); }); });     结果：\n➜ js git:(master) ✗ jest jest PASS ./promise.spec.js (5.19s) Promise ✓ Promise then resolve (11ms) ✓ Promise then reject (3ms) ✓ Promise catch (5ms) ✓ Promise finally (4ms) ✓ Promise finally with catch (6ms) ✓ Promise all (205ms) ✓ Promise allSettled (204ms) ✓ Promise race resolve (101ms) ✓ Promise race reject (85ms) ✓ Promise any resolve (102ms) ✓ Promise any reject (85ms) Test Suites: 1 passed, 1 total Tests: 11 passed, 11 total Snapshots: 0 total Time: 9.801s Ran all test suites.    总结   Promise 实现关键点：\n  resolver 立即执行， resolve/reject 封装之后暴露给 resolver 的使用者调用，比 如：请求成功调用 resolve(value), 请求失败调用 reject(reason) 。\n  resolve 函数实现需要判断各种情况，主要包含：\n  不能处理自身，会造成死循环，即 then 的 callback 里面不能返回当前 promise 实 例自身\n  如果是对象或函数，要考虑到提供了 then(resolve, reject) 函数情况\n  是一个新的 Promise 实例。\n    任务分立即完成和延时完成情况，立即完成的代表状态立即改变了直接在 then 函数中 fulfill 或 reject 即可，如果是异步的，需要通过订阅(subscribe)来实现。\n  then 函数中为了链式调用，需要新建一个 child promise 作为返回值。\n  Promise.all, allSettled, any 这几个 api 的实现通过 Enumerator 封装。\n  Promise.all 实现原理，遍历所有任务，同步的直接记录结果，异步的订阅结果，异 步完成之后检测最终的值，整个过程中只要中间有任一个 REJECT 了, Promise.all() 状态立即改变为 REJECT 结束，返回结果是： FULFILL-结果数组， REJECT-失败原因。\n  Promise.allSettled 实现原理与 Promise.all 大相径庭，只要将 Promise.all 里面 遇到 REJECT 的处理改成记录结果就行，最后所有的完成之后就 FULFILL ，返回结果 是所有任务 FULFILL 结果或所有 REJECT 原因组成的数组。\n  Promise.any 的实现与 Promise.all 刚好相反，它只要遇到有一个 FULFILL 就结束， 返回 FULFILL 状态，除非所有的都 REJECT 了才会 REJECT ，返回结果值为： FULFILL-成功结果值， REJECT-返回所有失败任务的原因组成的数组。\n    ","permalink":"https://www.cheng92.com/web/javascript-ecma-promise/","tags":["javascript,","es6,","promise"],"title":"JavaScript - Promise 实现(0-1)"},{"categories":["life"],"contents":" 古陵逝烟   烟都众人崇仰的大宗师，乃创立烟都基业与传统之人。为人高深莫测，冷峻绝艳，武学造诣有“一式留神”之美称，天地人三剑更是震慑当世。性格冷言疏淡，看似退居幕后，却凡事尽在其眼中，素以商人重利施恩卖义自居，游走各方坐收渔利，运筹帷幄掌控烟都行事方针。心机深沉难以臆测，关系着冰楼血案与巨魔神失落之谜 [1] 。\n  诗号：冷灯看剑，剑上几番功名？炉香无须计苍生，纵一川烟逝，万丈云埋，孤阳还照古陵。  \n    视频收集     ","permalink":"https://www.cheng92.com/post/life-bdx-persons/","tags":["life,","interesting,","funny"],"title":"si道友免si贫道"},{"categories":["vue"],"contents":"   诗号：冷灯看剑，剑上几番功名？炉香无须计苍生，纵一川烟逝，万丈云埋，孤阳还照古陵。  \n vue-next methods need polyfills   String.fromCodePoint, startsWith, some, filter, Array.from\n  万能的 Counter  1 2 3 4 5 6 7 8 9 10 11  { // test  const Counter = { data() { return { counter: 0, }; }, }; Vue.createApp(Counter).mount(\u0026#34;#v-test-counter\u0026#34;); }    Counter: {{ counter }} + \u0026nbsp;-    0001_0002-new-slot-syntax   新 slot 语法。\n  新 v-slot 指令将 slot 和 slot-scope 语法合并到一起了\n  v-slot 的缩写(#) 合并了 scoped 和 normal slots\n  slot-scope 3.0 中会被移除\n   result:\n{{ msg }} 2. 我是没有属性的具名插槽 {{ msg }} -- {{ msg }}   # -- {{ msg }}   5. 插槽嵌套：{{ foo }} {{ bar }} {{ baz }}    6. 插槽别名：  Loading...\n {{ user.name }}  Error: {{ error.message }}\n     template:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47  \u0026lt;div id=\u0026#34;v-test-slot\u0026#34;\u0026gt; \u0026lt;!-- 1. 默认 slot --\u0026gt; \u0026lt;Foo v-slot=\u0026#34;{ msg }\u0026#34; :style=\u0026#34;{color: \u0026#39;red\u0026#39;}\u0026#34;\u0026gt; {{ msg }}\u0026lt;/Foo\u0026gt; \u0026lt;!-- 2. 无属性的具名插槽 --\u0026gt; \u0026lt;Foo v-slot:zero :style=\u0026#34;{color: \u0026#39;purple\u0026#39;}\u0026#34;\u0026gt;2. 我是没有属性的具名插槽\u0026lt;/Foo\u0026gt; \u0026lt;!-- 也可以使用缩写 \u0026lt;Foo #=\u0026#34;{ msg }\u0026#34;\u0026gt;{{ msg }}\u0026lt;/Foo\u0026gt; --\u0026gt; \u0026lt;!-- 3. 具名插槽 --\u0026gt; \u0026lt;Foo :style=\u0026#34;{color: \u0026#39;blue\u0026#39;}\u0026#34;\u0026gt; \u0026lt;!-- 具名 slot --\u0026gt; \u0026lt;template v-slot:one=\u0026#34;{ msg }\u0026#34;\u0026gt; {{ msg }} \u0026lt;/template\u0026gt; \u0026lt;/Foo\u0026gt; \u0026lt;!-- 4. 具名插槽，指令缩写： v-bind -\u0026gt; # --\u0026gt; \u0026lt;Foo :style=\u0026#34;{color: \u0026#39;green\u0026#39;}\u0026#34;\u0026gt; \u0026lt;template #two=\u0026#34;{ msg }\u0026#34;\u0026gt; {{ msg }} \u0026lt;/template\u0026gt; \u0026lt;/Foo\u0026gt; \u0026lt;!-- 5. 嵌套插槽 --\u0026gt; \u0026lt;Foo2 v-slot=\u0026#34;foo\u0026#34; :style=\u0026#34;{ color: \u0026#39;darkorchid\u0026#39; }\u0026#34;\u0026gt; \u0026lt;bar v-slot=\u0026#34;bar\u0026#34;\u0026gt; \u0026lt;baz v-slot=\u0026#34;baz\u0026#34;\u0026gt; 5. 插槽嵌套：{{ foo }} {{ bar }} {{ baz }} \u0026lt;/baz\u0026gt; \u0026lt;/bar\u0026gt; \u0026lt;/Foo2\u0026gt; \u0026lt;!-- 6. 插槽别名 --\u0026gt; \u0026lt;Bax style=\u0026#34;color:slateblue;\u0026#34;\u0026gt; \u0026lt;template #default\u0026gt; 6. 插槽别名： \u0026lt;/template\u0026gt; \u0026lt;template #pending\u0026gt; \u0026lt;p\u0026gt;Loading...\u0026lt;/p\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;template #resolved=\u0026#34;{ users }\u0026#34;\u0026gt; \u0026lt;ul\u0026gt;\u0026lt;li v-for=\u0026#34;user in users\u0026#34;\u0026gt;{{ user.name }}\u0026lt;/li\u0026gt;\u0026lt;/ul\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;template #rejected=\u0026#34;{ error }\u0026#34;\u0026gt; \u0026lt;p\u0026gt;Error: {{ error.message }}\u0026lt;/p\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;/Bax\u0026gt; \u0026lt;/div\u0026gt;     javascript:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71  { // slot 语法  const app = Vue.createApp({ data() { return { msg: \u0026#34;hello slot !\u0026#34;, }; }, }); app.component(\u0026#34;foo\u0026#34;, { data() { return { defaultSlotMsg: \u0026#34;1. 我是默认插槽 default，直接应用在 Foo 上 \u0026lt;Foo v-slot\u0026gt;\u0026#34;, namedSlotMsg: \u0026#34;3. 我是具名插槽\u0026#34;, shortSlotMsg: \u0026#34;4. 我是插槽指令缩写 shorthand\u0026#34;, }; }, template: ` \u0026lt;div\u0026gt; \u0026lt;slot :msg=\u0026#34;defaultSlotMsg\u0026#34;\u0026gt;\u0026lt;/slot\u0026gt; \u0026lt;slot name=\u0026#34;zero\u0026#34;\u0026gt;\u0026lt;/slot\u0026gt; \u0026lt;slot name=\u0026#34;one\u0026#34; :msg=\u0026#34;namedSlotMsg\u0026#34;\u0026gt;\u0026lt;/slot\u0026gt; \u0026lt;slot name=\u0026#34;two\u0026#34; :msg=\u0026#34;shortSlotMsg\u0026#34;\u0026gt;\u0026lt;/slot\u0026gt; \u0026lt;/div\u0026gt;`, }); app.component(\u0026#34;foo2\u0026#34;, { data() { return { foo: \u0026#34;foo\u0026#34; }; }, template: `\u0026lt;div\u0026gt;\u0026lt;slot :foo=\u0026#34;foo\u0026#34;\u0026gt;\u0026lt;/slot\u0026gt;\u0026lt;/div\u0026gt;`, }); app.component(\u0026#34;bar\u0026#34;, { data() { return { bar: \u0026#34;bar\u0026#34; }; }, template: `\u0026lt;div\u0026gt;\u0026lt;slot :bar=\u0026#34;bar\u0026#34;\u0026gt;\u0026lt;/slot\u0026gt;\u0026lt;/div\u0026gt;`, }); app.component(\u0026#34;baz\u0026#34;, { data() { return { baz: \u0026#34;baz\u0026#34; }; }, template: `\u0026lt;div\u0026gt;\u0026lt;slot :baz=\u0026#34;baz\u0026#34;\u0026gt;\u0026lt;/slot\u0026gt;\u0026lt;/div\u0026gt;`, }); app.component(\u0026#34;bax\u0026#34;, { data() { return { users: [{ name: \u0026#34;foo\u0026#34; }, { name: \u0026#34;bar\u0026#34; }, { name: \u0026#34;baz\u0026#34; }], error: { message: \u0026#34;接口返回 500, 后端接锅。\u0026#34;, }, }; }, template: ` \u0026lt;div\u0026gt; \u0026lt;slot\u0026gt;\u0026lt;/slot\u0026gt; \u0026lt;div :style=\u0026#34;{ \u0026#39;text-indent\u0026#39;: \u0026#39;1rem\u0026#39; }\u0026#34;\u0026gt; \u0026lt;slot name=\u0026#34;pending\u0026#34;\u0026gt;\u0026lt;/slot\u0026gt; \u0026lt;slot name=\u0026#34;resolved\u0026#34; :users=\u0026#34;users\u0026#34;\u0026gt;\u0026lt;/slot\u0026gt; \u0026lt;slot name=\u0026#34;rejected\u0026#34; :error=\u0026#34;error\u0026#34;\u0026gt;\u0026lt;/slot\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt;`, }); app.mount(\u0026#34;#v-test-slot\u0026#34;); }     注意点 ：\n This is why I now believe allowing using slot-scope without a template was a mistake.\n 言外之意：请结合 \u0026lt;template\u0026gt; 去使用 slot\n   TODO 0003-dynamic-directive-arguments   import js     ","permalink":"https://www.cheng92.com/vue/vue-next-rfcs/","tags":["vue,","vue3,","vuenext"],"title":"Vue3.0 RFCs 过眼云烟(古陵逝烟)"},{"categories":["css3"],"contents":" 测试   选择器  :not + :last-child   可以通过\n1 2 3  element:not(:last-child) { // 作用于非最后一个元素上 }        ","permalink":"https://www.cheng92.com/post/css/css3/","tags":["css3"],"title":"CSS3 黑森林"},{"categories":["javascript"],"contents":"    regenerator: npm install -g renerator 将 es6+ 语法编译成 es5 语法\n   社区链接     name link     esdiscuss.org es 标准讨论社区   ecma262 官方标准文档   ecma262 官方标准文档      事件   w3事件接口：Document Object Model Events\n w3 事件流UI Events\n  事件修饰符(capture,passive,once)\n  捕获(capture)+冒泡(bubble)   白话解释 Javascript事件preventDefault,stopPropagation及return false的区别 - SegmentFault 思否\n    操作符   operator.\ndelete   ReturnIfAbrupt\n IsPropertyReference ( V ): Type(V.[[Base]]) 是 Boolean,String,Symbol,BigInt, Number, Object 返回 true, 否则 false.\n IsSuperReference ( V ): V.[[ThisValue]] 非空返回 true，否则 false 。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29  let ref = UnaryExpression ReturnIfAbrupt(ref) if (ref is not ReferenceRecord) { return true } if (IsUnresolvableReference(ref)) { assert(ref.[[Strict]] === false) return true } if (IsPropertyReference(ref)) { if (IsSuperReference(ref)) { throw new ReferenceError() } let baseObj = ToObject(ref.[[Base]]) let deleteStatus = baseObj.[[Delete]](ref.[[ReferencedName]]) if (deleteStatus === false \u0026amp;\u0026amp; ref.[[Strict]]) { throw new TypeError() } return deleteStatus } else { let base = ref.[[Base]] assert(base is EnvironmentRecord) return base.DeleteBinding(ref.[[ReferencedName]]) }      in  RelationalExpression : RelationalExpression in ShiftExpression 1. Let lref be the result of evaluating RelationalExpression. 2. Let lval be ? GetValue(lref). 3. Let rref be the result of evaluating ShiftExpression. 4. Let rval be ? GetValue(rref). 5. If Type(rval) is not Object, throw a TypeError exception. 6. Return ? HasProperty(rval, ? ToPropertyKey(lval)).   code:\n1 2 3 4 5 6 7 8 9 10  function in(lRelationalExp, rShiftExp) { let lref = lRelationalExp() let lval = GetValue(lref) let rref = rShiftExp() let rval = GetValue(rref) if (!isObject(rval)) { throw new TypeError(\u0026#39;right shift expression is not object.\u0026#39;) } return HasProperty(rval, ToProperty(lval)) }     -\u0026gt; HasProperty(O, P)\n    Document  Document.execCommand()     Array  Array.from(items[, mapfn[, thisArg]])  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93  let C = this let mapping if (mapfn === undefined) { mapping = false } else { if (!IsCallable(mapfn)) { throw new TypeError() } mapping = true } let usingIterator = GetMthod(items, @@iterator) let A if (usingIterator) { if (IsConstructor(C)) { A = Construct(C) } else { // 可能是被借用了，如：Array.from.call(...)  A = ArrayCreate(0) } let iteratorRecord = GetIterator(items, sync, usingIterator) let k = 0, error while (true) { if (k \u0026gt;= Math.pow(2, 53) - 1) { // 溢出了  error = ThrowCompletion(new TypeError()) return IteratorClose(iteratorRecord, error) } let Pk = ToString(k) let next = IteratorStep(iteratorRecord) // 知道迭代器迭代结束，没有下一个元素了作为终止条件  if (!next) { // 只有一个元素  Set(A, \u0026#39;length\u0026#39;, k, true) return A } let nextValue = IteratorValue(next) let mappedValue if (mapping) { mappedValue = Call(mapfn, thisArg, \u0026lt;\u0026lt;nextValue, k\u0026gt;\u0026gt;) if (mappedValue is AbruptCompletion) { // 终止迭代  return IteatorClose(iteratorRecord, mappedValue) } mappedValue = mappedValue.[[Value]] } else { mappedValue = nextValue } let defineStatus = CreateDataPropertyOrThrow(A, Pk, mappedValue) if (defineStatus is AbruptCompletion) { return IteratorClose(iteratorRecord, defineStatus) } k++ } // NOTE: items 不是个 iterable 对象，可能是类数组对象  let arrayLike = ToObject(items) let len = LengthOfArrayLike(arrayLike) if (IsConstructor(C)) { A = Construct(C, len) } else { A = ArrayCreate(len) } let k = 0 // 类数组对象，首先由自己的 length 属性  while (k \u0026lt; len) { let Pk = ToString(k) let kValue = Get(arrayLike, Pk) if (mapping) { mappedValue = Call(mapfn, thisArg, \u0026lt;\u0026lt;kValue, k\u0026gt;\u0026gt;) } else { mappedValue = kValue } CreateDataPropertyOrThrow(A, Pk, mappedValue) k++ } Set(A, \u0026#39;length\u0026#39;, len, true) return A }     实现分两种情况：\n  数组类型，直接 while 循环取迭代器 next 下一个值\n  类数组类型，取 len while 循环对象取值设值操作\n  两种情况设值操作都死调用的 CreateDataPropertyOrThrow 最终使用的是 O.[[DefineOwnProperty]](P, newDesc) 给对象追加属性。\n newDesc: {[[Value]]: V, [[Writable]]: true, [[Enumerable]]: true, [[Configurable]]: true}\n  Array.prototype.includes   Array.prototype.slice(start, end)  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54  function slice(start, end) { let O = ToObject(this) let len = LengthOfArrayLike(O) let relativeStart = ToIntegerOrInfinity(start) let k // 最终目的是取 start 索引  if (relativeStart === -Infinity) { k = 0 } else if (relativeStart \u0026lt; 0) { k = max(len + relativeStart, 0) } else { k = min(relativeStart, len) } let relativeEnd // 取结束索引  if (end === undefined) { relativeEnd = len } else { relativeEnd = ToIntegerOrInfinity(end) } // 和 relativeStart 一样做一遍索引处理  let final if (relativeEnd === -Infinity) { final = 0 } else if (relativeEnd \u0026lt; 0) { final = max(len + relativeEnd, 0) } else { final = min(relativeEnd, len) } let count = max(final - k, 0) // 创建个空数组  let A = ArraySpeciesCreate(O, count) let n = 0 // 数组长度  while (k \u0026lt; final) { let Pk = ToString((k)) let kPresent = HasProperty(O, count) if (kPresent) { // 已经存在  let kValue = Get(O, Pk) // 创建新属性  CreateDataPropertyOrThrow(A, ToString(n), kValue) } k++ n++ } Set(A, \u0026#39;length\u0026#39;, n, true) return A }      Array.prototype.reverse()  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40  function revers() { const O = ToObject(this) let len = LengthOfArrayLike(O) let middle = floor(len / 2) let lower = 0 while (lower !== middle) { let upper = len - lower - 1 // 对称的最后面那个  let upperP = ToString(upper) let lowerP = ToString(lower) let lowerExists = HasProperty(O, lowerP) let lowerValue, upperValue if (lowerExists) { lowerValue = Get(O, lowerP) } let upperExists = HasProperty(O, upperP) if (upperExists) { upperValue = Get(O, upperP) } if (lowerExists \u0026amp;\u0026amp; upperExists) { // 值互换  set(O, lowerP, upperValue, true) set(O, upperP, lowerValue, true) } else if (!lowerExists \u0026amp;\u0026amp; upperExists) { set(O, lowerP, upperValue, true) DeletePropertyOrThrow(O, upperP) // 因为左侧没值，所以将右侧位置删除  } else if (lowerExists \u0026amp;\u0026amp; !upperExists) { DeletePropertyOrThrow(O, lowerP) // 因为右侧没值，所以将左侧位置删除  set(O, upperP, lowerValue, true) } else { assert(!lowerExists \u0026amp;\u0026amp; !upperExists) } lower++ } return O }        Map  Map([iterable])   Map.prototype.clear()   Map.prototype.constructor   Map.prototype.delete(key)   Map.prototype.entries()   Map.prototype.forEach(callback)   Map.prototype.get(key)  1 2 3 4 5 6 7 8 9 10 11 12 13  function get(key) { let M = this RequireInternalSlot(M, [[MapData]]) let entries = M.[[MapData]] // list  for (let { [[Key]], [[Value]] }p of entries) { if (p.[[Key]] \u0026amp;\u0026amp; SameValueZero(p.[[Key]], key)) return p.[[Value]] } return undefined }     取出Map 数据列表，遍历找到满足条件的值。\n  Map.prototype.has(key)   Map.prototype.keys()   Map.prototype.set(key,value)   Map.prototype.size   Map.prototype.values()     Proxy \u0026amp; Reflect   可被代理的接口列表:\n   内部方法 代理handler方法 原子操作 Reflect 方法     [[GetProtoypeOf]] getPrototypeOf Object.getPrototypeOf(target) Reflect.getPrototypeOf(obj)   [[SetPrototypeOf]] setPrototypeOf Object.setPrototypeOf(target, proto) Reflect.setPrototypeOf(obj, protoObj)   [[IsExtensible]] isExtensible Object.isExtensible(proxy) Reflect.isExtensible(obj)   [[PreventExtensions]] preventExtensions Object.preventExtensions(obj) Reflect.preventExtensions(obj)   [[GetOwnProperty]](P) getOwnPropertyDescriptor Object.getOwnPropertyDescriptor Reflect.getOwnPropertyDescriptor(obj, \u0026#39;prop\u0026#39;)   [[DefineOwnProperty]](P, desc) defineProperty 属性定义函数: Object.defineProperty(obj, key, value) Reflect.defineProperty(obj, \u0026#39;prop\u0026#39;, descriptors)   [[HasProperty]](P) has 属性检测操作符： name in obj Reflect.has(obj, \u0026#39;prop\u0026#39;)   [[Get]](P, Receiver) get 取值操作，如： obj.name Reflect.get(obj, prop)   [[Set]](P, V, Receiver) set 赋值操作，如： obj.name = 1 Reflect.set(obj, prop, value)   [[Delete]](P) deleteProperty 属性删除操作，如： delete obj.name Reflect.deleteProperty(obj.prop)   [[OwnPropertyKeys]]() ownKeys Object.getOwnPropertyNames 和 Object.getOwnPropertySymbols Reflect.ownKeys(obj)   [[Call(thisArgument, argumentsList)]] apply 函数调用 proxy1(1, 2) 操作触发 Reflect.apply(target, thisArg, argumentsList)   [[Construct]](argumentsList, newTarget) construct new Func() 操作 Reflect.construct(fn, args)    ProxyCreate(target, handler)abstract    创建基本对象 P\n  设置内部函数 -\u0026gt; handler 函数映射\n  Callable(target) 单独处理\n  Construct(target) 单独处理\n  设置 P.[[ProxyHandler]] = handler\n  设置 P.[[ProxyTarget]] = target\n  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40  function ProxyCreate(target, handler) { if (Type(target) !== \u0026#39;object\u0026#39;) { throw new TypeError(\u0026#39;target required object.\u0026#39;) } if (Type(handler) !== \u0026#39;object\u0026#39;) { throw new TypeError(\u0026#39;handler required object.\u0026#39;) } let P = MakeBasicObject(\u0026lt;\u0026lt;[[ProxyHandler]], [[ProxyTarget]]\u0026gt;\u0026gt;) // 设置 P 除了 [[Call]] 和 [[Construct]] 之外的主要内部方法  // Internal Method -\u0026gt; Handler Method  // [[GetPrototypeOf]] -\u0026gt; getPrototypeOf  // [[SetPrototypeOf]] -\u0026gt; setPrototypeOf  // [[IsExtensible]] -\u0026gt; isExtensible  // [[PreventExtensions]] -\u0026gt; preventExtensions  // [[GetOwnProperty]] -\u0026gt; getOwnPropertyDescriptor  // [[DefineOwnProperty]] -\u0026gt; defineProperty  // [[HasProperty]] -\u0026gt; has  // [[Get]] -\u0026gt; get  // [[Set]] -\u0026gt; set  // [[Delete]] -\u0026gt; deleteProperty  // [[OwnPropertyKeys]] -\u0026gt; ownKeys  // [[Call]] -\u0026gt; apply  // [[Construct]] -\u0026gt; construct  if (IsCallable(target)) { // set P.[[Call]]  if (IsConstructor(target)) { // set P.[[Construct]]  } } P.[[ProxyTarget]] = target P.[[ProxyHandler]] = handler return P }      [[Construct(argumentsList, newTarget)]] abstract  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27  function [[Construct]](argumentsList, newTarget) { let handler = O.[[ProxyHandler]] if (!handler) { throw new TypeError(\u0026#39;handler is null\u0026#39;) } assert(Type(handler) === \u0026#39;object\u0026#39;) let target = O.[[ProxyTarget]] assert(IsConstructor(target) === true) let trap = GetMethod(handler, \u0026#39;construct\u0026#39;) if (trap === undefined) { return Construct(target, argumentsList, newTarget) } let argArray = CreateArrayFromList(argumentsList) let newObj = Call(trap, handler, \u0026lt;\u0026lt;target, argArray, newTarget\u0026gt;\u0026gt;) if (Type(newObj) !== \u0026#39;object\u0026#39;) { throw new TypeError(\u0026#39;create new object error\u0026#39;) } return newObj }      [[Call]](thisArgument, arugmentList) abstract  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20  function [[Call]](thisArgument, argumentsList) { let handler = O.[[ProxyHandler]] if (!handler) { throw new TypeError(\u0026#39;no handler.\u0026#39;) } assert(Type(handler) === \u0026#39;object\u0026#39;) let target = O.[[ProxyTarget]] let trap = GetMethod(handler, \u0026#39;apply\u0026#39;) if (!trap) { return Call(target, thisArgument, argumentsList) } let argArray = CreateArrayFromList(argumentsList) return Call(trap, handler, \u0026lt;\u0026lt;target, thisArgument, argArray\u0026gt;\u0026gt;) }        TODO ES2017     Proposal Stage -     Object.values/Object.entries 3 对象操作    Object.keys ( O )   EnumerableOwnPropertyNames, CreateArrayFromList\n1 2 3 4 5 6 7 8 9  function keys(O) { let obj = Object(O) // 遍历对象的键  let nameList = EnumerableOwnPropertyNames(obj, key) // 创建数组  return CreateArrayFromList(nameList) }      Object.values ( O )   EnumerableOwnPropertyNames, CreateArrayFromList\n1 2 3 4 5 6 7 8 9  function keys(O) { let obj = Object(O) // 遍历对象的键  let nameList = EnumerableOwnPropertyNames(obj, value) // 创建数组  return CreateArrayFromList(nameList) }      Object.entries( O )  1 2 3 4 5 6 7 8 9  function keys(O) { let obj = Object(O) // 遍历对象的键  let nameList = EnumerableOwnPropertyNames(obj, key+value) // 创建数组  return CreateArrayFromList(nameList) }        TODO ES2016     Proposal Stage -     Array.prototype.includes 4 原定用 contains 但是不兼容。   Exponentiation Operator 4    SIMD.JS - SIMD APIs + polyfill 3 一种类似向量的数据类型   Async Functions 3 async...await 语法，实现规范   String padding 3    Trailing commas in function parameter lists and calls 3    Object.getOwnPropertyDescriptors 3    function.sent metaproperty 2    Rest/Spread Properties 2    Shared memory and atomics 2    Function.prototype.toString revision 2    ArrayBuffer.transfer 1    Additional export-from Statements 1    Class and Property Decorators 1    Observable 1    String.prototype.{trimLeft,trimRight} 1    Class Property Declarations 1    String#matchAll 1    Callable class constructors 1    System.global 1    Asynchronous Iterators 1      接口相关：\n  Array.prototype.includes\n  Object.getOwnPropertyDescriptors\n  Function.prototype.toString\n  String.prototype.{trimLeft,trimRight}\n  String#matchAll\n  System.global\n  Array.prototype.includes ( searchElement [ , fromIndex ] )s4   与 indexOf 比较：\n  语义明确。\n  支持 NaN 检测，因为 indexOf 是使用恒等(Strict Equality Comparison)进行比较 的， includes 使用的是 SameValueZero 进行比较。\n  遍历的时候不会忽略 missing array 元素(俗称：hole 元素，比如 map 的时候就会跳 过这些元素)，而是将他们视为 undefined 。\n  1 2  console.log(\u0026#39;[1, NaN 2] index of `NaN`: \u0026#39; + [1, NaN, 2].indexOf(NaN)) // -1  console.log(\u0026#39;[1, NaN 2] includes `NaN`: \u0026#39; + [1, NaN, 2].includes(NaN)) // true      result:\n[1, NaN 2] index of `NaN`: -1 [1, NaN 2] includes `NaN`: true   伪码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32  function includes(searchElement[, fromIndex]) { let O = Object(this) let len = LengthOfArrayLike(O) if (len === 0) { return false } // 默认是 0  let n = int(fromIndex) || 0 let k if (n \u0026gt;= 0) { k = n } else { // 小于零从右开始数  k = len + n if (k \u0026lt; 0) k = 0 } while (k \u0026lt; len) { let elementK = get(O, String(k)) // 这里使用的是类 0 值，而非恒等比较  if (SameValueZero(searchElement, elementK)) { return true } k++ } return false }     ⚠️ includes 并不强烈要求调用者是个数组对象，如上伪码实现中使用的是 LengthOfArrayLike(O) 即类数组的对象都可以使用它。\n1 2 3 4 5 6 7 8 9  var obj = { length: 2, 0: \u0026#39;foo\u0026#39;, 1: \u0026#39;bar\u0026#39; } // 这里借用一下数组的函数  console.log([].includes.call(obj, \u0026#39;foo\u0026#39;))     +RESULTS:\ntrue   为什么不用 has ？\n has 常用来检测键 \u0026#34;keys\u0026#34;， includes 用来检测值 \u0026#34;values\u0026#34;，如：\n  Map 类型\n Map.prototype.has(key) Reflect.has(target, propertyKey)\n  Set 集合类型(集合类型 value 既是 key 也是 value)\n Set.prototype.has(value)\n  String 类型，索引 + 字符\n String.prototype.includes(searchString, position)\n    官方实例：\n1 2 3 4 5 6 7 8 9 10  assert([1, 2, 3].includes(2) === true); assert([1, 2, 3].includes(4) === false); assert([1, 2, NaN].includes(NaN) === true); assert([1, 2, -0].includes(+0) === true); assert([1, 2, +0].includes(-0) === true); assert([\u0026#34;a\u0026#34;, \u0026#34;b\u0026#34;, \u0026#34;c\u0026#34;].includes(\u0026#34;a\u0026#34;) === true); assert([\u0026#34;a\u0026#34;, \u0026#34;b\u0026#34;, \u0026#34;c\u0026#34;].includes(\u0026#34;a\u0026#34;, 1) === false);     more…\n  Exponentiation Operator(幂运算符)s3  1 2 3 4 5 6 7 8 9 10  let squared = 2 ** 2 let cubed = 2 ** 3 let a = 2 a **= 2 let b = 3 b **= 3 console.log({ squared, cubed, a, b })    { squared: 4, cubed: 8, a: 4, b: 27 }   more…\n    纯概念  Environment Records(link)   英文原版 -\u0026gt;\u0026gt;\u0026gt;\n 中文译版 -\u0026gt;\u0026gt;\u0026gt;\n    伪码  C  CreateImmutableBinding(N, S)   CreateImmutableBinding(N, S), 在当前的 Environment Record 中为未初始化的 N 创建一个新的不可变(Immutable)的绑定，前提是该绑定关系之前没有发生过，如果 S 值为 true 则该关系会被视为严格绑定(即严格模式和非严格模式)。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18  function CreateImmutableBinding(N, S) { // 1. 取当前环境  let envRec = DeclarativeEnvirnomentRecord // 2. 断言：envRec 中没有 N 的绑定关系  assert(envRec..notBinding(N)) // 3. 创建绑定，且 record 是未初始化状态  envRec.ImmutableBinding(N) // 4. 严格模式  if (S === true) { envRec..Strict = True } // 正常结束  return NormalCompletion(empty) }      CreateArrayFromList ( elements )   CreateDataPropertyOrThrow\n 用 List 创建数组类型。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  function CreateArrayFromList( elements ) { assert(elements is List) // 创建一个空数组  let array = ArrayCreate(0) let n = 0 for (let e of elements) { CreateDataPropertyOrThrow(array, ToString(n), e) n++ } return array }      CreateDataPropertyOrThrow ( O, P, V )   CreateDataProperty, IsPropertyKey\n 抽象操作：为对象创建一个新的属性和对应的值，如果失败抛出异常。\n1 2 3 4 5 6 7 8 9 10 11 12  function CreateDataPropertyOrThrow ( O, P, V ) { assert(Types(O) is Object) // 是不是合法的对象属性名  assert(IsPropertyKey(P) === true) let success = CreateDataProperty(O, P, V) if (!success) throw new TypeError() return success }      CreateDataProperty ( O, P, V )   抽象操作：创建对象属性。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  function CreateDataProperty ( O, P, V ) { assert(Type(O) === Object) assert(IsPropertyKey(P) === true) // 对象属性描述符对象  let newDesc = PropertyDescriptor{ [[Value]]: V, [[Writable]]: true, [[Enumerable]]: true, [[Configurable]]: true } return O.[[DefineOwnProperty]](P, newDesc) }     失败情况(返回 false)：\n  属性不可配置(Configurable: false)\n  O 是不可扩展类型\n      E  EnumerableOwnPropertyNames ( O, kind )   CreateArrayFromList\n 抽象操作：取出对象 O 的属性或值(key, value, 或 key+value)。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39  function EnumerableOwnPropertyNames(O, kind) { // kind -\u0026gt; key, value or key+value  // 必须是个引用类型  assert(Type(O) === Object) // 自身的所有属性  let ownKeys = O.[[OwnPropertyKeys]]() let properties = new List() for (let key of ownKeys) { let desc if (Type(key) === String) { // 取出值来  desc = O.[[GetOwnProperty]](key) // 有效值且是可枚举的  if (desc !== undefined \u0026amp;\u0026amp; desc.[[Enumerable]]) { if (kind === \u0026#39;key\u0026#39;) { // 保存属性名  properties.append(key) } else { let value = Get(O, key) if (kind === \u0026#39;value\u0026#39;) { // 保存属性值  properties.append(value) } else { assert(kind === \u0026#39;key+value\u0026#39;) let entry = CreateArrayFromList(\u0026lt;key, value\u0026gt;) properties.append(entry) } } } } } return properties }        F  Function Definition(函数定义)   参考链接\n 有几种函数声明方式：\n  FunctionDeclaration : function Identifier ( FormalParameterListopt ) { FunctionBody }\n TODO\n  FunctionExpression : function ( FormalParameterListopt ) { FunctionBody }\n TODO\n  FunctionExpression : function Identifier ( FormalParameterListopt ) { FunctionBody }\n 关联函数： CreateImmutableBinding(N, S)\n 实例，函数表达式： (function b() {})()\n 伪码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25  // 1. env 是当前可执行上下文环境变量  let funcEnv = NewDeclarativeEnvironment(env) // 2. 保存 funcEnv 的环境记录  let envRec = funcEnv.env_record // 3. 不可变绑定？  envRec.CreateImmutableBinding(Identifier) // 4. 创建函数 new Function(\u0026#39;a\u0026#39;, \u0026#39;b\u0026#39;, \u0026#39;return a + b\u0026#39;)  let closure = new Function(FormalParameterList, FunctionBody) // 5. 绑定 closure 执行环境  closure.bind(funcEnv) // 6. 严格模式处理  let Strict if (\u0026#39;use strict;\u0026#39;) { Strict = true } // 7. 初始化 immutable binding ?  envRec.InitializeImmutableBinding(Identifier, closure) return closure      FunctionBody : SourceElementsopt\n TODO\n      H  HasProperty(O, p)   Link -\u0026gt;\n -\u0026gt; 7.3.11 HasProperty ( O, P )\n The abstract operation HasProperty takes arguments O (an Object) and P (a property key). It returns a completion record which, if its Type is normal, has a Value which is a Boolean. It is used to determine whether an object has a property with the specified property key. The property may be either an own or inherited(属性可以是自己的也可以是继承来的，即查找整个原型链). It performs the following steps when called:\n  Assert: Type(O) is Object.\n  Assert: IsPropertyKey(P) is true.\n  Return ? O.HasProperty(P).\n      I  IsPropertyKey ( argument )  1 2 3 4 5 6 7  function IsPropertyKey ( argument ) { // 只有字符串和符号是合法属性名  if (Type(argument) === String || Type(argument) === Symbol) return true return false }        L  LengthOfArrayLike ( obj )  1 2 3 4 5 6 7  function LengthOfArrayLike ( obj ) { // 必须是个对象类型  assert(Type(obj) === \u0026#39;object\u0026#39;) // 获取对象的 length 属性，如： { 0: \u0026#39;foo\u0026#39;, 1: \u0026#39;bar\u0026#39;, length: 2 }  return ToLength(Get(obj, \u0026#39;length\u0026#39;)) }        S  SameValueZero(x, y)  1 2 3 4 5 6 7 8 9 10 11 12 13  function SameValueZero(x, y) { // 不同类型  if (Type(x) !== Type(y)) return false if (Type(x) === \u0026#39;number\u0026#39; || Type(x) === \u0026#39;bigint\u0026#39;) { // 数字处理  return Type(x)::sameValueZero(x, y) } // 非数字处理  return SameValueNonNumeric(x, y) }      SameValueNonNumeric ( x, y )  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26  function SameValueNonNumeric ( x, y ) { // 因为这里只处理非数字情况  assert(x, !Number \u0026amp;\u0026amp; !BigInt) assert(Type(x) === Type(y)) if (Type(x) === \u0026#39;undefined\u0026#39;) return true if (Type(x) === \u0026#39;null\u0026#39;) return true if (Type(x) === \u0026#39;string\u0026#39;) { // 这里比较程度，逐个字符比较，相同返回 true，否则 false  return x === y } if (Type(x) === \u0026#39;boolean\u0026#39;) { if (x === true \u0026amp;\u0026amp; y === true) return true return false } if (Type(x) === \u0026#39;symbol\u0026#39;) { // 比较两个符号类型的值  return x.value === y.value } return x === y }      StrictEqualityComparison 严格比较  1 2 3 4 5 6 7 8 9 10 11 12  function StrictEqualityComparison() { if(Type(x) !== Type(y)) return false if (Type(x) === \u0026#39;number\u0026#39; || Type(x) === \u0026#39;bigint\u0026#39;) { // 直接 equal 比较  return Type(x)::equal(x, y) } // 非数字和 SameValueZero 处理一样  return SameValueNonNumeric(x,y) }          ","permalink":"https://www.cheng92.com/web/javascript-docs/","tags":["javascript,","api"],"title":"JavaScript Api \u0026 文档"},{"categories":[],"contents":"  window.g_need_fold = 1   Org-mode 简明手册 - open source - 博客园\nembrace  embrace-add(,ea)   Documentation Two Emacs manuals, the GNU Emacs manual and An Introduction to Programming in Emacs Lisp, can be purchased in printed form from the FSF store.\n These manuals, along with the Emacs Lisp Reference Manual and several other manuals documenting major modes and other optional features, can also be read online. They are also distributed with Emacs in Info format; type C-h i in Emacs to view them.\n GNU Emacs manual: Read Online or Purchase An Introduction to Programming in Emacs Lisp: Read Online or Purchase Emacs Lisp Reference Manual: Read Online Other Emacs manuals: Read Onlin_e The Emacs distribution includes the full source code for the manuals, as well as several Emacs Reference Cards in various languages.\n  Asking for help To ask for \\{ help\\ } with GNU Emacs, use the mailing list help-gnu-emacs@gnu.org or the newsgroup gnu.emacs.help. The mailing list and newsgroup are linked: messages posted on one appear on the other as well.\n Reporting bugs To report bugs, or to \u0026lt;button\u0026gt;contribute\u0026lt;/button\u0026gt; fixes and improvements, use the built-in Emacs bug reporter (M-x report-emacs-bug) or send email to bug-gnu-emacs@gnu.org. You can browse our bug database at debbugs.gnu.org. For more information on contributing, see the CONTRIBUTE file (also distributed with Emacs). To report bugs, or to \u0026lt;button\u0026gt;contribute\u0026lt;/button\u0026gt; fixes and improvements, use the built-in Emacs bug reporter (M-x report-emacs-bug) or send email to bug-gnu-emacs@gnu.org. You can browse our bug database at debbugs.gnu.org. For more information on contributing, see the CONTRIBUTE file (also distributed with Emacs). To report bugs, or to \u0026lt;button\u0026gt;contribute\u0026lt;/button\u0026gt; fixes and improvements, use the built-in Emacs bug reporter (M-x report-emacs-bug) or send email to bug-gnu-emacs@gnu.org. You can browse our bug database at debbugs.gnu.org. For more information on contributing, see the CONTRIBUTE file (also distributed with Emacs). TodoTo report bugs, or to \u0026lt;button\u0026gt;contribute\u0026lt;/button\u0026gt; fixes and improvements, use the built-in Emacs bug reporter (M-x report-emacs-bug) or send email to bug-gnu-emacs@gnu.org. You can browse our bug database at debbugs.gnu.org. For more information on contributing, see the CONTRIBUTE file (also distributed with Emacs).\n For all other queries, consult the list of Emacs-related mailing lists on savannah.gnu.org and the complete list of GNU mailing lists on lists.gnu.org. See Get Help with GNU Software for help with GNU software in general.@@html:\u0026lt;/kbd\u0026gt;@@__\n1 2 3 4 5 6 7  function test(a, b, c, d, e) { console.log(\u0026#39;aaaaa = \u0026#39; + a) console.log(\u0026#39;aaaaa = \u0026#39; + b) console.log(\u0026#39;aaaaa = \u0026#39; + c) console.log(\u0026#39;aaaaa = \u0026#39; + d) console.log(\u0026#39;aaaaa = \u0026#39; + e) `}`      embrace-change(,ec)   embrace-delete(,ed)     emoji   🐱 🌵\n  ein, emacs-ipython-notebook   https://www.cheng92.com gccll/test\n1 2 3 4  import numpy, math, matplotlib.pyplot as plt %matplotlib inline x = numpy.linspace(0, 2*math.pi) plt.plot(x, numpy.sin(x))      latex   $f(x) = x^{2}$ (@1(@1j)j)\n  org  test\n  xxxxxxxxf\n xxxxxx\n aaa\n aaa\n 删除线\n $x^{2}$\n xxx\n   名字 性别        colorful text   red...xxx\nred text...\n   blocks  comment..\n TIP\n tip….\n Note\n danger… danger… danger… danger… danger…\n WARNING\n warning…\n xxx – demo xxx – demo xxx – demo xxx – demo xxx – demo xxx – demo xxx – demo\n  #+begin_𝒳 I love Emacs! #+end_𝒳\n~example~  1  warn    center content\n  quote ….\n octoicon:report Note that kbd:C-x_C-e evaluates a Lisp form!\n  show:GLOSSARY\n badge:Thanks|for_reading tweet:https://github.com/alhassy/org-special-block-extras badge:|buy_me_a coffee|gray|https://www.buymeacoffee.com/alhassy|buy-me-a-coffee\nlink-here:solution Syntactically, (apply f \u0026#39;(x0 ... xN)) = (f x0 ... xN).\n Ain\u0026#39;t that cool?\nThat is, we can ((apply)) a function to a list of arguments!\n  demo block…\n Are you excited to learn some Lisp? blue:Yes!\n Pop-quiz: How does doc:apply work?\n test example test ~example~ test example test example    restclient  1 2  GET https://api.github.com User-Agent: Emacs Restclient      valign test   head 1  head 2  head 3  head 4  head 5           use bootstrap   buttons:\nPrimary Secondary Success Danger Warning Info Light Dark  icons:\n    hugo-test  使用教程\n增加搜索功能    方案一\n  这个是增加了一个页面，在这个页面里面进行搜索，不是很友好，我希望的是在当前页面组 好是弹框+下拉列表形式进行搜索。\n 搜索结果：   方案二\n 这个貌似还不错，值得一试。\n  https://www.algolia.com/\n      网易云音乐     增加代码区复制按钮    修改 themes/even/assets/js/main.js 增加 addCopyButton 原理就是，将 pre.chroma\u0026gt;code 里面的文本全拷贝到一个临时创建的 textarea 标签里面，然后 调用 document.execCommand(\u0026#39;copy\u0026#39;) 将内容拷贝到剪切板。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50  function addCopyButton() { //用 div 包裹 figure 便于定位  $(\u0026#34;.src .highlight\u0026#34;).wrap(\u0026#39;\u0026lt;div class=\u0026#34;highlight-wrapper\u0026#34;\u0026gt;\u0026lt;/div\u0026gt;\u0026#39;); //添加复制按钮  $(\u0026#34;.highlight\u0026#34;).before( \u0026#39;\u0026lt;div class=\u0026#34;copy-code btn btn-outline-secondary\u0026#34;\u0026gt;复制\u0026lt;/div\u0026gt;\u0026#39; ); //为复制按钮添加click事件  $(\u0026#34;.copy-code\u0026#34;).on(\u0026#34;click\u0026#34;, function () { //初始化  $(\u0026#34;textarea\u0026#34;).remove(\u0026#34;#targetId\u0026#34;); //获取对应的代码  var codeText = \u0026#34;\u0026#34;; $(this) .next(\u0026#34;div.highlight\u0026#34;) .find(\u0026#34;pre.chroma\u0026gt;code\u0026#34;) .each(function (i) { // 过滤掉行号的那个 pre  if (i \u0026gt; 0) { codeText += $(this).text() + \u0026#34;\\n\u0026#34;; } }); //添加 \u0026lt;textarea\u0026gt; DOM节点，将获取的代码写入  var target = document.createElement(\u0026#34;textarea\u0026#34;); target.style.opacity = 0; target.style.left = \u0026#34;-9999px\u0026#34;; target.id = \u0026#34;targetId\u0026#34;; $(this).append(target); target.textContent = codeText; //选中textarea内的代码  target.focus(); target.setSelectionRange(0, target.value.length); // 复制选中的内容  document.execCommand(\u0026#34;copy\u0026#34;); //删除添加的节点  $(\u0026#34;textarea\u0026#34;).remove(\u0026#34;#targetId\u0026#34;); $(this).html(\u0026#34;成功\u0026#34;); var thisCopied = $(this); setTimeout(function () { thisCopied.html(\u0026#34;复制\u0026#34;); }, 1200); }); }      修改 themes/even/assets/sass/_partial/_post/_code.scss 增加按钮样式\n  1 2 3  function test() { console.log(\u0026#39;请复制我，好吗？\u0026#39;) }    test使用的 begin_example  1 2 3  function main(int argc, int* argv[]) { printf(\u0026#34;%d, %s\u0026#34;, 100, \u0026#34;hello world\u0026#34;) }      header2  header3  header4         hugo themes   https://learn.netlify.app/en/\n   ","permalink":"https://www.cheng92.com/post/my-first-post/","tags":["demo"],"title":"My First Post"},{"categories":["vue"],"contents":"  window.g_need_fold = 1   该系列文章，均以测试用例通过为基准一步步实现一个 vue3 源码副本(学习)。\n  文字比较长，如果不想看文字可直接转到这里看脑图\n可能感兴趣列表：   源码相关的疑问/问题列表及其解答 🛳 🛳 🛳 🛳 🛳\n  阶段性的代码备份(比如能 pass 某个用例) 🚘 🚘 🚘 🚘 🚘\n  所有脑图列表及简要解析\n  小结   小结之所以放在最前面，主要原因有二：\n  文章都是根据测试用例逐步由少到多，简到全的进度去实现和测试的。\n  文字内容太多，小结放前面能提前大概有个全局观，全局的概念。\n  上图：几个重要函数和几个简单的用例\n  每个函数的重要实现解说：\n  parseChildren 所有模板解析的入口，重点是 while 循环检测规则进入对应的 parse* 函数解析，合并相邻文本节点，过滤空行节点，返回 root.children。\n  parseComment 这里的注释是指 \u0026lt;!--xx--\u0026gt; html 注释，区分几种非法情况，可通过用 例来熟悉(a. 正常注释，b. 非法注释)\n  parseElememt 解析标签，得到整个标签的 ast 结构，包含：标签名 tag，属性列表 props，孩子节点 children，等等。\n  检测自闭合(\u0026lt;div/\u0026gt;)和空标签(\u0026lt;img\u0026gt;)检测，它们没有孩子节点。\n  关键的 ancestors 数组，在递归解析孩子节点的时候通过出入栈操作保存当前解析的 节点对象(如：疑问3)。\n    parseText 文本解析，非标签，非插值类型的节点会被当做文本类型去解析。文本结束 根据是 (\u0026lt;, {{, ]]\u0026gt;)。\n  parseTextData 解析文本，替换 html 标记(匹配： /\u0026amp;(gt|lt|amp|apos|quot);/g)\n  parseTag 解析元素标签，属性 props，v-pre 等指令都是在这里面发起解析的，注意自闭 合标签的处理 isSelfClosing 标志结束 parseElement 中解析进程。\n  parseAttributes whle 循环调用 parseAttribute 解析属性存到 props 中。\n  parseAttribute 解析单个属性，集合保存属性名防止重复，先解析属性值，然后解析属 性名，指令，修饰符，参数等。\n  parseAttributeValue 解析属性值，区分有引号或没引号(即属性值可以没引号哦😯)。\n  parseInterpolation 插值解析，取 {{ 和 }} 之间的文本作为表达式。\n  parseCDATA 解析 xml 注释，当做文本处理\n  parseBogusComment 解析 \u0026lt;? 的注释\n    parse.spec.ts   测试用例结构：compiler: parse 截止：2020-09-02 22:53:14\n 所有用例全部通过：parse.ts 的解析功能几乎全部实现(可能会有遗漏)\nErrorCodes 各种错误情况用例  不通过用例：\n  \u0026lt;textarea\u0026gt;\u0026lt;/div\u0026gt;\u0026lt;/textarea\u0026gt;\n  \u0026lt;template\u0026gt;\u0026lt;svg\u0026gt;\u0026lt;![CDATA[cdata]]\u0026gt;\u0026lt;/svg\u0026gt;\u0026lt;/template\u0026gt;\n  用例代码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29  const ast = baseParse(code, { getNamespace: (tag, parent) =\u0026gt; { // 这里作用是改变命名空间，从而在 parseChildren while 循环里面  // 能进入到 parseCDATA 解析 svg  const ns = parent ? parent.ns : Namespaces.HTML; if (ns === Namespaces.HTML) { if (tag === \u0026#34;svg\u0026#34;) { return Namespaces.HTML + 1; } } return ns; }, getTextMode: ({ tag }) =\u0026gt; { // 这里作用改变 textarea 标签的 mode = RCDATA，从而在 parseChildren while  // 里面将 textarea 内部的都当做文本交给 parseText 去解析，parseText 里面会从  // \u0026lt;/div\u0026gt;\u0026lt;/textarea\u0026gt; 第二个字符开始匹配 `\u0026lt;` 或 `{{` 以示结束标签的开始位置  // 最后解析出 `\u0026lt;/div\u0026gt;` 这个纯文本，剩下的 \u0026lt;/textarea\u0026gt; 进入 isEnd  // 在实现 isEnd 里面的 case RCDATA 分支后顺利推出循环  if (tag === \u0026#34;textarea\u0026#34;) { return TextModes.RCDATA; } if (tag === \u0026#34;script\u0026#34;) { return TextModes.RAWTEXT; } return TextModes.DATA; }, ...options, onError: spy, });     大部分都能通过，只有少部分不能通过的分为几种：\n  CDATA 类型处理，需要实现 parseBogusComment 和 parseCDATA 两个函数\n  RCDATA 类型几个用例不能通过，原因在于在 isEnd 函数中没有实现除 DATA 类型外的 情况，实现之后就能正常检测 RCDATA 的结束标签。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39  function isEnd( context /*ParserContext*/, mode /*TextModes*/, ancestors /*ElementNode[]*/ ) /*boolean*/ { const s = context.source; // mode 为 TextModes 各种情况  // ...省略  switch (mode) { case TextModes.DATA: if (s.startsWith(\u0026#34;\u0026lt;/\u0026#34;)) { // 标签  for (let i = ancestors.length - 1; i \u0026gt;= 0; --i) { if (startsWithEndTagOpen(s, ancestors[i].tag)) { return true; } } } // 新增 - start  case TextModes.RCDATA: case TextModes.RAWTEXT: { const parent = last(ancestors); if (parent \u0026amp;\u0026amp; startsWithEndTagOpen(s, parent.tag)) { return true; } break; } case TextModes.CDATA: if (s.startsWith(\u0026#34;]]\u0026gt;\u0026#34;)) { return true; } break; // 新增 - end  } // 是 TextModes.TEXT 直接返回 source 的内容是否为空了  return !s; }      注释反例(嵌套注释)：    \u0026lt;template\u0026gt;\u0026lt;!--a\u0026lt;!--b--\u0026gt;\u0026lt;/template\u0026gt;\n  \u0026lt;template\u0026gt;\u0026lt;!--a\u0026lt;!--b\u0026lt;!--c--\u0026gt;\u0026lt;/template\u0026gt;\n  \u0026lt;template\u0026gt;\u0026lt;!--a\u0026lt;!--\u0026gt;\u0026lt;/template\u0026gt;\n  \u0026lt;template\u0026gt;\u0026lt;!--a\u0026lt;!--\n      其他用例  02-valid/invalid html  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63  test(\u0026#34;valid html\u0026#34;, () =\u0026gt; { const ast = baseParse( `\u0026lt;div :class=\u0026#34;{ some: condition }\u0026#34;\u0026gt;\\n` + ` \u0026lt;p v-bind:style=\u0026#34;{ color: \u0026#39;red\u0026#39; }\u0026#34;/\u0026gt;\\n` + ` \u0026lt;!-- a comment with \u0026lt;html\u0026gt; inside it --\u0026gt;\\n` + `\u0026lt;/div\u0026gt;` ); expect(ast).toMatchSnapshot(); expect(ast.children).toHaveLength(1); const el = ast.children[0]; expect(el).toMatchObject({ tag: \u0026#34;div\u0026#34;, }); expect(el.children).toHaveLength(2); expect(el.children[0]).toMatchObject({ tag: \u0026#34;p\u0026#34;, }); expect(el.children[1]).toMatchObject({ type: NodeTypes.COMMENT, }); }); test(\u0026#34;invalid html\u0026#34;, () =\u0026gt; { expect(() =\u0026gt; { baseParse(`\u0026lt;div\u0026gt;\\n\u0026lt;span\u0026gt;\\n\u0026lt;/div\u0026gt;\\n\u0026lt;/span\u0026gt;`); }).toThrow(\u0026#34;Element is missing end tag.\u0026#34;); const spy = jest.fn(); const ast = baseParse(`\u0026lt;div\u0026gt;\\n\u0026lt;span\u0026gt;\\n\u0026lt;/div\u0026gt;\\n\u0026lt;/span\u0026gt;`, { onError: spy, }); expect(spy.mock.calls).toMatchObject([ [ { code: ErrorCodes.X_MISSING_END_TAG, loc: { start: { offset: 6, line: 2, column: 1, }, }, }, ], [ { code: ErrorCodes.X_INVALID_END_TAG, loc: { start: { offset: 20, line: 4, column: 1, }, }, }, ], ]); expect(ast).toMatchSnapshot(); });     这里要分析的是 invalid html, 这个用例拿出来说主要原因是它能帮助我们更好的理解标 签嵌套时候的解析过程。\n \u0026lt;div\u0026gt;\\n\u0026lt;span\u0026gt;\\n\u0026lt;/div\u0026gt;\\n\u0026lt;/span\u0026gt;\n 大致解析流程是： parseChildren -\u0026gt; parseElement -\u0026gt; parseTag -\u0026gt; parseChildren -\u0026gt; parseElement -\u0026gt; parseTag -\u0026gt; 报错\n debugger local 数据(解析完 \u0026lt;span\u0026gt; 之后):\n1 2 3 4 5 6 7 8 9 10 11 12 13 14  Local ancestors: Array(1) 0: {type: 1, ns: 0, tag: \u0026#34;div\u0026#34;, tagType: 0, props: Array(0), …} length: 1 children: [] context: column: 1 inPref: false inVPref: false line: 3 offset: 13 options: {delimiters: Array(2), getNamespace: ƒ, getTextMode: ƒ, isVoidTag: ƒ, isPreTag: ƒ, …} originalSource: \u0026#34;\u0026lt;div\u0026gt;↵\u0026lt;span\u0026gt;↵\u0026lt;/div\u0026gt;↵\u0026lt;/span\u0026gt;\u0026#34; source: \u0026#34;\u0026lt;/div\u0026gt;↵\u0026lt;/span\u0026gt;\u0026#34;      解析出 div 标签，所以 ancestors.length === 1\n  解析出 span 标签，ancestors.length 应该是 2，但是上面我们只保留了 span 解析之 后的数据，所以 ancestors.span 被 pop() 掉了，因为它不是重点\n  解析完 span 之后会去解析 \\n ，但是会被 removedWhitespace 那段逻辑过滤掉(满足 在 pre 和 next 之间条件)\n  那么重点在这，到这一步也是上面代码 source = `\u0026lt;/div\u0026gt;\\n\u0026lt;/span\u0026gt;` 的时候\n  检测到 \u0026lt;/ 开始结束标签解析，注意看 parseElement 中有这么一段\n1 2 3  if (startsWithEndTagOpen(context.source, element.tag)) { parseTag(context, TagType.End, parent); }     经过 4 之后的 source 刚好能满足这个 if ，因此携带 TagType.End 进入 parseTag， 此时有个变量 parent 保存了 pop() 之前的那个 ancestors[1] 即 span 那个标签 ，但是这里的结束标签是 div 最后会匹配失败，抛出异常。\n    01-self closing single/multiple tag  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25  /* 不管是单标签还是多标签也好，自闭合标签的处理都一样，在 parseTag 里面解析都需要经过这么 一段：advanceBy(context, isSelfClosing ? 2 : 1); 然后结合 parseElement 中的检测 isSelfClosing 直接退出返回元素节点，即不需要再继续 解析子节点了(它没有) ,*/ test(\u0026#39;self closing single tag\u0026#39;, () =\u0026gt; { const ast = baseParse(\u0026#39;\u0026lt;div :class=\u0026#34;{ some: condition }\u0026#34; /\u0026gt;\u0026#39;) expect(ast.children).toHaveLength(1) expect(ast.children[0]).toMatchObject({ tag: \u0026#39;div\u0026#39; }) }) test(\u0026#39;self closing multiple tag\u0026#39;, () =\u0026gt; { const ast = baseParse( `\u0026lt;div :class=\u0026#34;{ some: condition }\u0026#34; /\u0026gt;\\n` + `\u0026lt;p v-bind:style=\u0026#34;{ color: \u0026#39;red\u0026#39; }\u0026#34;/\u0026gt;` ) expect(ast).toMatchSnapshot() expect(ast.children).toHaveLength(2) expect(ast.children[0]).toMatchObject({ tag: \u0026#39;div\u0026#39; }) expect(ast.children[1]).toMatchObject({ tag: \u0026#39;p\u0026#39; }) })        Element 元素标签解析  13-结束标签忽略大小写   \u0026lt;div\u0026gt;hello\u0026lt;/DIV\u0026gt;after\n 因为解析到结束标签的时候匹配结束标签名称的时候会调用 startsWithEndTagOpen 检测， 且里面是忽略大小写的，统一转成小写去比较。\n1 2 3 4 5 6 7 8  // 匹配：\u0026lt;/tag\u0026gt; 或\u0026lt;/tag 没有 `\u0026gt;` 的情况???  function startsWithEndTagOpen(source, tag) { return ( source.startsWith(\u0026#34;\u0026lt;/\u0026#34;) \u0026amp;\u0026amp; source.substr(2, tag.length).toLowerCase() === tag.toLowerCase() \u0026amp;\u0026amp; /[\\t\\n\\f /\u0026gt;]/.test(source[2 + tag.length] || \u0026#34;\u0026gt;\u0026#34;) ); }      12-v-pre 用例测试   `\u0026lt;div v-pre :id=\u0026#34;foo\u0026#34;\u0026gt;\u0026lt;Comp/\u0026gt;{{ bar }}\u0026lt;/div\u0026gt;\\n` + `\u0026lt;div :id=\u0026#34;foo\u0026#34;\u0026gt;\u0026lt;Comp/\u0026gt;{{ bar }}\u0026lt;/div\u0026gt;`\n 现阶段代码暂时是不支持的 v-pre 的。所以解析之后会出现下面的结果：\n root.children[3] 有三个孩子节点\n  first: div v-pre(还没实现所以当做普通标签处理)，first.children[2] 有两个孩子\n  component 类型的 \u0026lt;Comp/\u0026gt; 因为首字母大写所以当做组件类型处理\n  bar 插值节点\n    second: \\n 文本节点\n  third: div :id，third.children[2] 也有两个孩子和 first 一样\n  1 2 3 4  (3) [{…}, {…}, {…}] 0: {type: 1, ns: 0, tag: \u0026#34;div\u0026#34;, tagType: 0, props: Array(1), …} 1: {type: 2, content: \u0026#34;↵\u0026#34;, loc: {…}} 2: {type: 1, ns: 0, tag: \u0026#34;div\u0026#34;, tagType: 0, props: Array(1), …}length: 3__proto__: Array(0)     实现之后：\n0: {type: 1, ns: 0, tag: \u0026#34;div\u0026#34;, tagType: 0, props: Array(1), …} 1: null 2: {type: 1, ns: 0, tag: \u0026#34;div\u0026#34;, tagType: 0, props: Array(1), …} length: 3 __proto__: Array(0)   要通过该用例需要修改的点：\n  parseChildren 里要添加删除空字符换行符操作\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63  function parseChildren( context /* ParserContext*/, mode /*TextModes*/, ancestors /*ElementNode[]*/ ) { // ...  const parent = last(ancestors); const ns = parent ? parent.ns : Namespaces.HTML; const nodes /*TemplateChildNode[]*/ = []; // ... 省略 while  // 新增-start  let removedWhitespace = false; // TODO 空格管理，为了更高效的输出  // `\\n\u0026lt;div\u0026gt;...` 删除开头的空格字符，之前解析 v-pre 用例是卡在这里了  // 这里忘记实现了，所以用例 http://www.cheng92.com/vue/vue3-source-code-compiler-core-parse_ts/#headline-3  // 得到了三个 child，第二个是 \\n，就是因为这里没实现过滤  if (mode !== TextModes.RAWTEXT) { if (!context.inPre) { for (let i = 0; i \u0026lt; nodes.length; i++) { const node = nodes[i]; if (node.type === NodeTypes.TEXT) { if (!/[^\\t\\r\\n\\f ]/.test(node.content)) { const prev = nodes[i - 1]; const next = nodes[i + 1]; // 1. 空格是第一个或者最后一个节点，或者  // 2. 空格与注释节点相邻  // 3. 空格在两个元素之间，就我们遇到的 \u0026lt;div\u0026gt;\u0026lt;/div\u0026gt;\\n\u0026lt;div\u0026gt;...  // 上面三种情况的空格会被忽略  if ( !prev || !next || prev.type === NodeTypes.COMMENT || next.type === NodeTypes.COMMENT || (prev.type === NodeTypes.ELEMENT \u0026amp;\u0026amp; next.type === NodeTypes.ELEMENT \u0026amp;\u0026amp; /[\\r\\n]/.test(node.content)) ) { removedWhitespace = true; nodes[i] = null; } else { // 否则替换成空格  node.content = \u0026#34; \u0026#34;; } } else { // 替换成空格  node.content = node.content.replace(/[\\t\\r\\n\\f ]+/g, \u0026#34; \u0026#34;); } } } } else if (parent \u0026amp;\u0026amp; context.options.isPreTag(parent.tag)) { //如果是 \u0026lt;pre\u0026gt; 删掉第一行的空行  const first = nodes[0]; if (first \u0026amp;\u0026amp; first.type === NodeTypes.TEXT) { first.content = first.content.replace(/^\\r?\\n/, \u0026#34;\u0026#34;); } } } // \u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt; 新增-end  return removedWhitespace ? nodes.filter(Boolean) : nodes; }      修改 parseTag 增加 v-pre, \u0026lt;pre\u0026gt; 代码处理\n 这里会有个值得注意的地方就是它检测到是 pre 会回头重新解析属性，然后过滤掉 v-pre 指令，并且在 parseAttribute 里面会检测到 inVPre 从来不会进 行指令解析，只会解析普通的 props。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42  function parseTag(context, type, parent) { // ...  // 新增-start  if (context.options.isPreTag(tag)) { context.inPre = true; } // 1. inVPre = false 因为初始化默认不会是 v-pre 的  // 2. 只要属性列表中有一个满足：v-pre 指令类型  if ( !context.inVPre \u0026amp;\u0026amp; props.some((p) =\u0026gt; p.type === NodeTypes.DIRECTIVE \u0026amp;\u0026amp; p.name === \u0026#34;pre\u0026#34;) ) { context.inVPre = true; // 这里恢复之前的解析，因为 \u0026lt;div v-pre\u0026gt;...\u0026lt;/div\u0026gt; 走到这里的时候已经解析完了  // 所以要恢复属性字符串？  extend(context, cursor); context.source = currentSource; // 为什么要重新解析，直接过滤不好吗？  // 因为 parseAttribute 中在 inVPre = true 情况下是不会去解析其他指令属性的  // 其他指令照样会解析，直接过滤掉所有指令属性不就好了？  props = parseAttributes(context, type).filter((p) =\u0026gt; p.name !== \u0026#34;v-pre\u0026#34;); } // 新增-end  // ...  const val = { type: NodeTypes.ELEMENT, ns, tag, tagType, props, isSelfClosing, children: [], loc: getSelection(context, start), codegenNode: undefined, }; return val; }        11-\u0026lt;div\u0026gt; id=a/\u0026gt;\u0026lt;/div\u0026gt; 属性值中没有引号时   没有引号的时候有一些非法字符： const unexpectedChars = /[\u0026#34;\u0026#39;\u0026lt;=`]/g; ，遇到这些 值的时候会报错。\n 在这之前有一个匹配使用来匹配出值的：\n const match = /^[^\\t\\r\\n\\f \u0026gt;]+/.exec(context.source);\n 这个会将 \u0026gt; 之前的 = 之后的属性值匹配出来，然后交给 parseTextData 进行解析。\n  10-\u0026lt;div\u0026gt; id=\u0026#34;\u0026gt;\\\u0026#39;\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; 属性值中有引号时   这种情况是合法的，属性值里面的内容会被当做纯文本处理。\nprops: Array(1) 0: name: \u0026#34;id\u0026#34; type: 6 value: content: \u0026#34;\u0026gt;\u0026#39;\u0026#34; // 属性值 type: 2   这个处理跟 用例09 是一样的逻辑\n 多个属性的情况，在 parseAttributes 中有个 while 循环处理。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19  function parseAttributes( context: ParserContext, type: TagType ): (AttributeNode | DirectiveNode)[] { const props = [] const attributeNames = new Set\u0026lt;string\u0026gt;() while ( context.source.length \u0026gt; 0 \u0026amp;\u0026amp; !startsWith(context.source, \u0026#39;\u0026gt;\u0026#39;) \u0026amp;\u0026amp; !startsWith(context.source, \u0026#39;/\u0026gt;\u0026#39;) ) { // ...  const attr = parseAttribute(context, attributeNames) // ...  } return props }      09-\u0026lt;div id=\u0026#34;\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; 属性值为空的情况  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41  test(\u0026#39;attribute with empty value, double quote\u0026#39;, () =\u0026gt; { const ast = baseParse(\u0026#39;\u0026lt;div id=\u0026#34;\u0026#34;\u0026gt;\u0026lt;/div\u0026gt;\u0026#39;) const element = ast.children[0] as ElementNode expect(element).toStrictEqual({ type: NodeTypes.ELEMENT, ns: Namespaces.HTML, tag: \u0026#39;div\u0026#39;, tagType: ElementTypes.ELEMENT, codegenNode: undefined, props: [ { type: NodeTypes.ATTRIBUTE, name: \u0026#39;id\u0026#39;, value: { type: NodeTypes.TEXT, content: \u0026#39;\u0026#39;, loc: { start: { offset: 8, line: 1, column: 9 }, end: { offset: 10, line: 1, column: 11 }, source: \u0026#39;\u0026#34;\u0026#34;\u0026#39; } }, loc: { start: { offset: 5, line: 1, column: 6 }, end: { offset: 10, line: 1, column: 11 }, source: \u0026#39;id=\u0026#34;\u0026#34;\u0026#39; } } ], isSelfClosing: false, children: [], loc: { start: { offset: 0, line: 1, column: 1 }, end: { offset: 17, line: 1, column: 18 }, source: \u0026#39;\u0026lt;div id=\u0026#34;\u0026#34;\u0026gt;\u0026lt;/div\u0026gt;\u0026#39; } }) })     解析： parseTag -\u0026gt; parseAttributes -\u0026gt; parseAttribute -\u0026gt; parseAttributeValue -\u0026gt; parseTextData 直接返回空字符串，组织： { type, content: \u0026#39;\u0026#39;, ... } 返回\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30  function parseAttributeValue( context: ParserContext ) { // ...省略  const quote = context.source[0] const isQuoted = quote === `\u0026#34;` || quote === `\u0026#39;` if (isQuoted) { // id=\u0026#34;\u0026#34;，有引号  // Quoted value.  advanceBy(context, 1) const endIndex = context.source.indexOf(quote) if (endIndex === -1) { content = parseTextData( context, context.source.length, TextModes.ATTRIBUTE_VALUE ) } else { // 到这里  content = parseTextData(context, endIndex, TextModes.ATTRIBUTE_VALUE) advanceBy(context, 1) } } else { // 不会到这里  } return { content, isQuoted, loc: getSelection(context, start) } }      08-\u0026lt;div id\u0026gt;\u0026lt;/div\u0026gt; 无属性值的属性  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32  test(\u0026#34;attribute with no value\u0026#34;, () =\u0026gt; { const ast = baseParse(\u0026#34;\u0026lt;div id\u0026gt;\u0026lt;/div\u0026gt;\u0026#34;); const element = ast.children[0]; expect(element).toStrictEqual({ type: NodeTypes.ELEMENT, ns: Namespaces.HTML, tag: \u0026#34;div\u0026#34;, tagType: ElementTypes.ELEMENT, codegenNode: undefined, props: [ { type: NodeTypes.ATTRIBUTE, name: \u0026#34;id\u0026#34;, value: undefined, loc: { start: { offset: 5, line: 1, column: 6 }, end: { offset: 7, line: 1, column: 8 }, source: \u0026#34;id\u0026#34;, }, }, ], isSelfClosing: false, children: [], loc: { start: { offset: 0, line: 1, column: 1 }, end: { offset: 14, line: 1, column: 15 }, source: \u0026#34;\u0026lt;div id\u0026gt;\u0026lt;/div\u0026gt;\u0026#34;, }, }); }); // attribute with no value      解析： parseTag -\u0026gt; parseAttributes -\u0026gt; parseAttribute 里面有一段针对属性值处理\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33  function parseAttribute( context: ParserContext, nameSet: Set\u0026lt;string\u0026gt; ): AttributeNode | DirectiveNode { // ... 省略  // 这里检测是不是有 name= 或 name=value 情况  if (/^[\\t\\r\\n\\f ]*=/.test(context.source)) { advanceSpaces(context) advanceBy(context, 1) advanceSpaces(context) value = parseAttributeValue(context) // 这里是防止 name= 后面没有值得情况报错  if (!value) { emitError(context, ErrorCodes.MISSING_ATTRIBUTE_VALUE) } } // ... 因为 id 没有 id=? 所以直接回到这里，不会进入  // parseAttributeValue 解析属性值  // ... id 非指令属性，所以直接到最后以普通属性类型退出  return { type: NodeTypes.ATTRIBUTE, name, value: value \u0026amp;\u0026amp; { type: NodeTypes.TEXT, content: value.content, loc: value.loc }, loc } }      07-isCustomElement 自定义元素  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18  test(\u0026#34;custom element\u0026#34;, () =\u0026gt; { const ast = baseParse(\u0026#34;\u0026lt;div\u0026gt;\u0026lt;/div\u0026gt;\u0026lt;comp\u0026gt;\u0026lt;/comp\u0026gt;\u0026#34;, { isNativeTag: (tag) =\u0026gt; tag === \u0026#34;div\u0026#34;, isCustomElement: (tag) =\u0026gt; tag === \u0026#34;comp\u0026#34;, }); expect(ast.children[0]).toMatchObject({ type: NodeTypes.ELEMENT, tag: \u0026#34;div\u0026#34;, tagType: ElementTypes.ELEMENT, // 由于是 isNativeTag() 使用了默认 ELEMENT  }); expect(ast.children[1]).toMatchObject({ type: NodeTypes.ELEMENT, tag: \u0026#34;comp\u0026#34;, tagType: ElementTypes.ELEMENT, // 由于是 isCustomElement() 所以压根不会进入到 if ... 中检测类型  }); })     自定义类型判断：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57  function parseTag( context: ParserContext, type: TagType, parent: ElementNode | undefined ): ElementNode { // ... 省略  let tagType = ElementTypes.ELEMENT const options = context.options // \u0026lt;comp\u0026gt; 由于是 isCustomElement 因此压根不会进入下面的 if (false) ...  if (!context.inVPre \u0026amp;\u0026amp; !options.isCustomElement(tag)) { const hasVIs = props.some( p =\u0026gt; p.type === NodeTypes.DIRECTIVE \u0026amp;\u0026amp; p.name === \u0026#39;is\u0026#39; ) if (options.isNativeTag \u0026amp;\u0026amp; !hasVIs) { // div 会进入到这里，但是检测失败 if (!true) ...  if (!options.isNativeTag(tag)) tagType = ElementTypes.COMPONENT } else if ( // div 这里都不满足，if (false) ...  hasVIs || isCoreComponent(tag) || (options.isBuiltInComponent \u0026amp;\u0026amp; options.isBuiltInComponent(tag)) || /^[A-Z]/.test(tag) || tag === \u0026#39;component\u0026#39; ) { tagType = ElementTypes.COMPONENT } if (tag === \u0026#39;slot\u0026#39;) { tagType = ElementTypes.SLOT } else if ( tag === \u0026#39;template\u0026#39; \u0026amp;\u0026amp; props.some(p =\u0026gt; { return ( p.type === NodeTypes.DIRECTIVE \u0026amp;\u0026amp; isSpecialTemplateDirective(p.name) ) }) ) { tagType = ElementTypes.TEMPLATE } } // 所以 \u0026lt;div\u0026gt; 最终使用了默认值：ELEMENT  // 所以 \u0026lt;comp\u0026gt; 直接到了这里，是：ELEMENT 类型  return { type: NodeTypes.ELEMENT, ns, tag, tagType, props, isSelfClosing, children: [], loc: getSelection(context, start), codegenNode: undefined // to be created during transform phase  } }      06-isNativeTag 原生标签类型   这个用例(\u0026lt;div\u0026gt;\u0026lt;/div\u0026gt;\u0026lt;comp\u0026gt;\u0026lt;/comp\u0026gt;\u0026lt;Comp\u0026gt;\u0026lt;/Comp\u0026gt;)里面有三个标签：\n  div\n  comp\n  Comp\n   同时传递一个 options: { isNativeTag: tag =\u0026gt; tag === \u0026#39;div\u0026#39; }\n 意思告诉编译器这里面只有 div 属于原生标签，其他的都属于组件类型，这个在 parseTag 实现中体现出来。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23  test(\u0026#34;native element with `isNativeTag`\u0026#34;, () =\u0026gt; { const ast = baseParse(\u0026#34;\u0026lt;div\u0026gt;\u0026lt;/div\u0026gt;\u0026lt;comp\u0026gt;\u0026lt;/comp\u0026gt;\u0026lt;Comp\u0026gt;\u0026lt;/Comp\u0026gt;\u0026#34;, { isNativeTag: (tag) =\u0026gt; tag === \u0026#34;div\u0026#34;, }); expect(ast.children[0]).toMatchObject({ type: NodeTypes.ELEMENT, tag: \u0026#34;div\u0026#34;, tagType: ElementTypes.ELEMENT, }); expect(ast.children[1]).toMatchObject({ type: NodeTypes.ELEMENT, tag: \u0026#34;comp\u0026#34;, tagType: ElementTypes.COMPONENT, }); expect(ast.children[2]).toMatchObject({ type: NodeTypes.ELEMENT, tag: \u0026#34;Comp\u0026#34;, tagType: ElementTypes.COMPONENT, }); }); // native element with `isNativeTag`      通过该用例的代码实现片段(在用例 05 中就已经实现过了，因此该用例顺利通过)：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38  function parseTag( context: ParserContext, type: TagType, parent: ElementNode | undefined ): ElementNode { // ... 省略  let tagType = ElementTypes.ELEMENT const options = context.options // 前提，非 v-pre 指令，且非自定义标签(默认：NO)  if (!context.inVPre \u0026amp;\u0026amp; !options.isCustomElement(tag)) { // 是否有 v-is 指令  const hasVIs = props.some( p =\u0026gt; p.type === NodeTypes.DIRECTIVE \u0026amp;\u0026amp; p.name === \u0026#39;is\u0026#39; ) // 首先由提供原生标签检测函数，且没有 v-is 情况下进入组件判断  if (options.isNativeTag \u0026amp;\u0026amp; !hasVIs) { // 类型为 COMPONENT 组件类型  if (!options.isNativeTag(tag)) tagType = ElementTypes.COMPONENT } // ... 省略  } return { type: NodeTypes.ELEMENT, ns, tag, tagType, props, isSelfClosing, children: [], loc: getSelection(context, start), codegenNode: undefined // to be created during transform phase  } }     而在没有提供 isNativeTag() 的情况下，三种标签的解析结果中的 tagType 又是不一 样的，延续上面的带继续分析：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48  function parseTag( context: ParserContext, type: TagType, parent: ElementNode | undefined ): ElementNode { // ... 省略  let tagType = ElementTypes.ELEMENT const options = context.options // 前提，非 v-pre 指令，且非自定义标签(默认：NO)  if (!context.inVPre \u0026amp;\u0026amp; !options.isCustomElement(tag)) { // 是否有 v-is 指令  const hasVIs = props.some( p =\u0026gt; p.type === NodeTypes.DIRECTIVE \u0026amp;\u0026amp; p.name === \u0026#39;is\u0026#39; ) // 首先由提供原生标签检测函数，且没有 v-is 情况下进入组件判断  if (options.isNativeTag \u0026amp;\u0026amp; !hasVIs) { // 类型为 COMPONENT 组件类型  if (!options.isNativeTag(tag)) tagType = ElementTypes.COMPONENT } else if ( // 把这里省略的部分加上...  hasVIs || isCoreComponent(tag) || (options.isBuiltInComponent \u0026amp;\u0026amp; options.isBuiltInComponent(tag)) || // 重点在这里，检测到如果标签名开头是大写的就会被视为组件类型  /^[A-Z]/.test(tag) || tag === \u0026#39;component\u0026#39; ) { tagType = ElementTypes.COMPONENT } // ... 省略  } return { type: NodeTypes.ELEMENT, ns, tag, tagType, props, isSelfClosing, children: [], loc: getSelection(context, start), codegenNode: undefined // to be created during transform phase  } }     那么接下来的用例也不是什么问题了：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32  test(\u0026#39;v-is without `isNativeTag`\u0026#39;, () =\u0026gt; { const ast = baseParse( `\u0026lt;div\u0026gt;\u0026lt;/div\u0026gt;\u0026lt;div v-is=\u0026#34;\u0026#39;foo\u0026#39;\u0026#34;\u0026gt;\u0026lt;/div\u0026gt;\u0026lt;Comp\u0026gt;\u0026lt;/Comp\u0026gt;`, { isNativeTag: tag =\u0026gt; tag === \u0026#39;div\u0026#39; } ) expect(ast.children[0]).toMatchObject({ type: NodeTypes.ELEMENT, tag: \u0026#39;div\u0026#39;, tagType: ElementTypes.ELEMENT // 这里毋庸置疑是默认原生元素类型  }) expect(ast.children[1]).toMatchObject({ type: NodeTypes.ELEMENT, tag: \u0026#39;div\u0026#39;, // 容易产生疑问的是这个，这里为什么是 COMPONENT，而不是 element 呢  // 这里关键在于 v-is，记得：isNativeTag() 检测的优先级最高前提是 !hasVIs 成立情况  // 然而这里显然 hasVIs === true  // 因此进入了 else if (... || hasVIs || ...) { tagType = ElementTypes.COMPONENT }  tagType: ElementTypes.COMPONENT }) expect(ast.children[2]).toMatchObject({ type: NodeTypes.ELEMENT, tag: \u0026#39;Comp\u0026#39;, // 这里没啥疑问，大写开头所以是组件类型  tagType: ElementTypes.COMPONENT }) })     自定义组件：\n  05-template element with directives   这个用例开始模板的解析。\n1 2 3 4 5 6 7 8  test(\u0026#39;template element with directives\u0026#39;, () =\u0026gt; { const ast = baseParse(\u0026#39;\u0026lt;template v-if=\u0026#34;ok\u0026#34;\u0026gt;\u0026lt;/template\u0026gt;\u0026#39;) const element = ast.children[0] expect(element).toMatchObject({ type: NodeTypes.ELEMENT, tagType: ElementTypes.TEMPLATE }) }     baseParse(\u0026#39;\u0026lt;template v-if=\u0026#34;ok\u0026#34;\u0026gt;\u0026lt;/template\u0026gt;\u0026#39;) 解析之后的结构：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35  { \u0026#34;type\u0026#34;:0, \u0026#34;children\u0026#34;:[ { // \u0026lt;template\u0026gt; 节点 \u0026#34;type\u0026#34;:1, \u0026#34;ns\u0026#34;:0, \u0026#34;tag\u0026#34;:\u0026#34;template\u0026#34;, \u0026#34;tagType\u0026#34;:3, \u0026#34;props\u0026#34;:[ { \u0026#34;type\u0026#34;:7, // DIRECTIVE \u0026#34;name\u0026#34;:\u0026#34;if\u0026#34;, \u0026#34;exp\u0026#34;:{ \u0026#34;type\u0026#34;:4, // SIMPLE_EXPRESSION \u0026#34;content\u0026#34;:\u0026#34;ok\u0026#34;, \u0026#34;isStatic\u0026#34;:false, \u0026#34;isConstant\u0026#34;:false, \u0026#34;loc\u0026#34;:{ // ... 省略 } }, \u0026#34;modifiers\u0026#34;:[ // 修饰符 ], \u0026#34;loc\u0026#34;:{ // 省略 \u0026#34;source\u0026#34;:\u0026#34;v-if=\u0026#34;ok\u0026#34;\u0026#34; } } ], // ... 省略 } ], // ... 省去 }     为了能解析出 v-if=\u0026#34;ok\u0026#34; 我们需要去实现 parseAttributes(context, type) -\u0026gt; parseAttribute -\u0026gt; parseAttributeValue\n 该用例考察的其实并不是 \u0026lt;template\u0026gt; 模板标签解析，而是标签上的属性解析，对普通的 \u0026lt;div\u0026gt; 标签依然可以解析出属性 props[]。\n 针对模板 \u0026lt;template\u0026gt; 标签的处理详情可以查看此处(含脑图)，更直观。\n   04-void element   空标签解析，如：~\u0026lt;img\u0026gt;~\n 前提是提供了 isVoidTag() 选项。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23  test(\u0026#39;void element\u0026#39;, () =\u0026gt; { const ast = baseParse(\u0026#39;\u0026lt;img\u0026gt;after\u0026#39;, { isVoidTag: (tag) =\u0026gt; tag === \u0026#39;img\u0026#39; }) const element = ast.children[0] expect(element).toStrictEqual({ type: NodeTypes.ELEMENT, ns: Namespaces.HTML, tag: \u0026#39;img\u0026#39;, tagType: ElementTypes.ELEMENT, codegenNode: undefined, props: [], isSelfClosing: false, children: [], loc: { start: { offset: 0, line: 1, column: 1 }, end: { offset: 5, line: 1, column: 6 }, source: \u0026#39;\u0026lt;img\u0026gt;\u0026#39; } }) }     该用例和自闭标签类似都是在 parseTag 解析完之后在 parseElement 中结束解析，不同点 在于调用 baseParse 的时候需要传递一个包含 isVoidTag() 的选项 {isVoidTag: tag =\u0026gt; tag === \u0026#39;img\u0026#39;} 用来告诉解析器什么样的标签属于空标签，即不是 \u0026lt;img/\u0026gt; 也不是 \u0026lt;div\u0026gt;\u0026lt;/div\u0026gt; 类型。\n parseElement 中解析条件：\n1 2 3 4 5 6 7 8  parseElement(context, ancestors) { // ... parseTag 中解析 \u0026lt;img ...\u0026gt;  // 自闭合的到这里就可以结束了  if (element.isSelfClosing || context.options.isVoidTag?.(element.tag)) { return element } // ...  }      03-self closing  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21  test(\u0026#39;self closing\u0026#39;, () =\u0026gt; { const ast = baseParse(\u0026#39;\u0026lt;div/\u0026gt;after\u0026#39;) const element = ast.children[0] expect(element).toStrictEqual({ type: NodeTypes.ELEMENT, ns: Namespaces.HTML, tag: \u0026#39;div\u0026#39;, tagType: ElementTypes.ELEMENT, codegenNode: undefined, props: [], isSelfClosing: true, children: [], loc: { start: { offset: 0, line: 1, column: 1 }, end: { offset: 6, line: 1, column: 7 }, source: \u0026#39;\u0026lt;div/\u0026gt;\u0026#39; } }) }      02-empty div   和 01-simple div 一样，无非就是没有 children[] 子节点了。在 parseElement -\u0026gt; parseTag 解析就结束了。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20  test(\u0026#39;empty div\u0026#39;, () =\u0026gt; { const ast = baseParse(\u0026#39;\u0026lt;div\u0026gt;\u0026lt;/div\u0026gt;\u0026#39;) const element = ast.children[0] expect(element).toStrictEqual({ type: NodeTypes.ELEMENT, ns: Namespaces.HTML, tag: \u0026#39;div\u0026#39;, tagType: ElementTypes.ELEMENT, codegenNode: undefined, props: [], isSelfClosing: false, children: [], loc: { start: { offset: 0, line: 1, column: 1 }, end: { offset: 11, line: 1, column: 12 }, source: \u0026#39;\u0026lt;div\u0026gt;\u0026lt;/div\u0026gt;\u0026#39; } }) }      01-simple div   流程图：  因为 parseElement 已经实现，因此这个顺利通过，~parseElement~ 解析先检测 \u0026lt;/div\u0026gt; 结束标签位置，如果没有则为非法无结束标签触发 ErrorCodes.EOF_IN_TAG 异常。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31  test(\u0026#39;simple div\u0026#39;, () =\u0026gt; { const ast = baseParse(\u0026#39;\u0026lt;div\u0026gt;hello\u0026lt;/div\u0026gt;\u0026#39;) const element = ast.children[0] expect(element).toStrictEqual({ type: NodeTypes.ELEMENT, ns: Namespaces.HTML, tag: \u0026#39;div\u0026#39;, tagType: ElementTypes.ELEMENT, codegenNode: undefined, props: [], isSelfClosing: false, // \u0026lt;div 后为 \u0026gt; 为非自闭合标签  children: [ { type: NodeTypes.TEXT, content: \u0026#39;hello\u0026#39;, loc: { start: { offset: 5, line: 1, column: 6 }, // h 位置索引  end: { offset: 10, line: 1, column: 11 }, // o 位置索引  source: \u0026#39;hello\u0026#39; } } ], loc: { start: { offset: 0, line: 1, column: 1 }, end: { offset: 16, line: 1, column: 17 }, // 遇到\u0026lt;div\u0026gt; 会直接判断是否有 \u0026lt;/div\u0026gt; 然后截取`\u0026lt;div\u0026gt;...\u0026lt;/div\u0026gt;  source: \u0026#39;\u0026lt;div\u0026gt;hello\u0026lt;/div\u0026gt;\u0026#39; } }) })     标签的解析在 parseTag 中完成， 如果是自闭合标签，会置标志位 isSelfClosing = true 。\n 并且解析标签只会解析到 \u0026lt;div\u0026gt; 中的 \u0026lt;div 部分就结束，是因为需要检测后面是 \u0026gt; 还是 /\u0026gt; 如果是 /\u0026gt; 则为自闭合标签需要区分处理，因此这里会有个判断来决定 advanceBy 1 或 2 个指针位置。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  // parseTag  let isSelfClosing = false if (context.source.length === 0) { emitError(context, ErrorCodes.EOF_IN_TAG) } else { // some \u0026lt;div\u0026gt; ... \u0026lt;/div\u0026gt; 到这里的 source = \u0026gt; ... \u0026lt;/div\u0026gt;  // 所以可以检测是不是以 /\u0026gt; 开头的  isSelfClosing = context.source.startsWith(\u0026#39;/\u0026gt;\u0026#39;) if (type === TagType.End \u0026amp;\u0026amp; isSelfClosing) { emitError(context, ErrorCodes.END_TAG_WITH_TRAILING_SOLIDUS) } // 如果是自闭合指针移动两位(/\u0026gt;)，否则只移动一位(\u0026gt;)  // 到这里 source = ... \u0026lt;/div\u0026gt;  advanceBy(context, isSelfClosing ? 2 : 1) }        Comment 注释解析   注释风格： \u0026lt;!-- ... --\u0026gt; ，阶段 5 及之前还不支持注释解析，因为还没实现 parseComment。\n 注释测试用例不存在阶段性的实现，只要实现了 parseComment 就饿都可以通过了，因此这里放在一起通过记录。\n  empty comment 空注释节点\n  simple comment 正常注释节点\n  two comments 多个注释节点\n  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56  describe(\u0026#39;Comment\u0026#39;, () =\u0026gt; { test(\u0026#39;empty comment\u0026#39;, () =\u0026gt; { const ast = baseParse(\u0026#39;\u0026lt;!----\u0026gt;\u0026#39;) const comment = ast.children[0] expect(comment).toStrictEqual({ type: NodeTypes.COMMENT, content: \u0026#39;\u0026#39;, loc: { start: { offset: 0, line: 1, column: 1 }, end: { offset: 7, line: 1, column: 8 }, source: \u0026#39;\u0026lt;!----\u0026gt;\u0026#39; } }) }) // empty comment  test(\u0026#39;simple comment\u0026#39;, () =\u0026gt; { const ast = baseParse(\u0026#39;\u0026lt;!--abc--\u0026gt;\u0026#39;) const comment = ast.children[0] expect(comment).toStrictEqual({ type: NodeTypes.COMMENT, content: \u0026#39;abc\u0026#39;, loc: { start: { offset: 0, line: 1, column: 1 }, end: { offset: 10, line: 1, column: 11 }, source: \u0026#39;\u0026lt;!--abc--\u0026gt;\u0026#39; } }) }) // simple comment  test(\u0026#39;two comments\u0026#39;, () =\u0026gt; { const ast = baseParse(\u0026#39;\u0026lt;!--abc--\u0026gt;\u0026lt;!--def--\u0026gt;\u0026#39;) const comment1 = ast.children[0] const comment2 = ast.children[1] expect(comment1).toStrictEqual({ type: NodeTypes.COMMENT, content: \u0026#39;abc\u0026#39;, loc: { start: { offset: 0, line: 1, column: 1 }, end: { offset: 10, line: 1, column: 11 }, source: \u0026#39;\u0026lt;!--abc--\u0026gt;\u0026#39; } }) expect(comment2).toStrictEqual({ type: NodeTypes.COMMENT, content: \u0026#39;def\u0026#39;, loc: { start: { offset: 10, line: 1, column: 11 }, end: { offset: 20, line: 1, column: 21 }, source: \u0026#39;\u0026lt;!--def--\u0026gt;\u0026#39; } }) }) // two comments  })     这里总共有三个用例，一开始测试并不能通过，是因为实现 pushNode 的时候忘记加上 __DEV__ 环境检测了，因为生产环境是不需要保存注释节点的，开发环境为了测试需要有 这个信息。\n1 2 3 4 5 6 7 8 9 10 11 12  function pushNode(nodes, node) { // 这里加上 __DEV__ 检测，开发的时候还是需要的  // 不然用例会通不过，因为这里直接返回 Undefined 了，导致  // parent.children[] 里面并不存在这个注释节点  // 加上就好了  if (!__DEV__ \u0026amp;\u0026amp; node.type === NodeTypes.COMMENT) { // 注释节点不处理  return } // ... 省略  }      Interpolation 插值解析  05-custom delimiters   自定义插值分隔符，其实处理流程和插值处理一样，所以没啥好讲的，阶段代码 4 就支持该用例通过。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27  test(\u0026#39;custom delimiters\u0026#39;, () =\u0026gt; { const ast = baseParse(\u0026#39;\u0026lt;p\u0026gt;{msg}\u0026lt;/p\u0026gt;\u0026#39;, { delimiters: [\u0026#39;{\u0026#39;, \u0026#39;}\u0026#39;] }) const element = ast.children[0] const interpolation = element.children[0] expect(interpolation).toStrictEqual({ type: NodeTypes.INTERPOLATION, content: { type: NodeTypes.SIMPLE_EXPRESSION, content: `msg`, isStatic: false, isConstant: false, loc: { start: { offset: 4, line: 1, column: 5 }, end: { offset: 7, line: 1, column: 8 }, source: \u0026#39;msg\u0026#39; } }, loc: { start: { offset: 3, line: 1, column: 4 }, end: { offset: 8, line: 1, column: 9 }, source: \u0026#39;{msg}\u0026#39; } }) })      04-it can have tag-like notation (3)   前面的两个用例已经解释过了，插值里面的内容会在 parseInterpolation 中直接处理成插 值的模板(source)，不会进入到 while 循环触发异常。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29  test(\u0026#39;it can have tag-like notation (3)\u0026#39;, () =\u0026gt; { const ast = baseParse(\u0026#39;\u0026lt;div\u0026gt;{{ \u0026#34;\u0026lt;/div\u0026gt;\u0026#34; }}\u0026lt;/div\u0026gt;\u0026#39;) // 这里解析出来的是 \u0026lt;div\u0026gt;\u0026lt;/div\u0026gt; 这个元素节点  const element = ast.children[0] as ElementNode // 标签内部的所有内容在解析之后会被当做子节点存放到 children[] 数组中  // 因此这里第一个子节点是个插值模板  const interpolation = element.children[0] as InterpolationNode expect(interpolation).toStrictEqual({ type: NodeTypes.INTERPOLATION, content: { type: NodeTypes.SIMPLE_EXPRESSION, isStatic: false, // The `isConstant` is the default value and will be determined in `transformExpression`.  isConstant: false, content: \u0026#39;\u0026#34;\u0026lt;/div\u0026gt;\u0026#34;\u0026#39;, loc: { start: { offset: 8, line: 1, column: 9 }, end: { offset: 16, line: 1, column: 17 }, source: \u0026#39;\u0026#34;\u0026lt;/div\u0026gt;\u0026#34;\u0026#39; } }, loc: { start: { offset: 5, line: 1, column: 6 }, end: { offset: 19, line: 1, column: 20 }, source: \u0026#39;{{ \u0026#34;\u0026lt;/div\u0026gt;\u0026#34; }}\u0026#39; } }) })      03-it can have tag-like notation(2)   这个用例其实和 用例 2 是一样的，只不过是解析了两个插值而已，先解析 {{ a\u0026lt;b }} ，最后剩下的 {{ c\u0026gt;d }} 会在退出 parseInterpolation 之后剩余的 context.source 为 {{ c\u0026gt;d }} 在 parseChildren 里面继续进行 while 循环处 理，随又检测到是插值再次调用 parseInterpolation 进行处理得到第二个插值节点。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45  test(\u0026#39;it can have tag-like notation (2)\u0026#39;, () =\u0026gt; { const ast = baseParse(\u0026#39;{{ a\u0026lt;b }}{{ c\u0026gt;d }}\u0026#39;) const interpolation1 = ast.children[0] as InterpolationNode const interpolation2 = ast.children[1] as InterpolationNode expect(interpolation1).toStrictEqual({ type: NodeTypes.INTERPOLATION, content: { type: NodeTypes.SIMPLE_EXPRESSION, content: `a\u0026lt;b`, isStatic: false, isConstant: false, loc: { start: { offset: 3, line: 1, column: 4 }, end: { offset: 6, line: 1, column: 7 }, source: \u0026#39;a\u0026lt;b\u0026#39; } }, loc: { start: { offset: 0, line: 1, column: 1 }, end: { offset: 9, line: 1, column: 10 }, source: \u0026#39;{{ a\u0026lt;b }}\u0026#39; } }) expect(interpolation2).toStrictEqual({ type: NodeTypes.INTERPOLATION, content: { type: NodeTypes.SIMPLE_EXPRESSION, isStatic: false, isConstant: false, content: \u0026#39;c\u0026gt;d\u0026#39;, loc: { start: { offset: 12, line: 1, column: 13 }, end: { offset: 15, line: 1, column: 16 }, source: \u0026#39;c\u0026gt;d\u0026#39; } }, loc: { start: { offset: 9, line: 1, column: 10 }, end: { offset: 18, line: 1, column: 19 }, source: \u0026#39;{{ c\u0026gt;d }}\u0026#39; } }) }     支持该用例代码链接🛬\n  02-it can have tag-like notation(1)   该用例里面虽然有 \u0026lt; 符号，但是由于是在插值内部，会进入 parseInterpolation 之后 就被解析成插值的 source，并不会进入 while 里面的作为标签的开始 \u0026lt; 来解析。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24  test(\u0026#39;it can have tag-like notation\u0026#39;, () =\u0026gt; { const ast = baseParse(\u0026#39;{{ a\u0026lt;b }}\u0026#39;) const interpolation = ast.children[0] expect(interpolation).toStrictEqual({ type: NodeTypes.INTERPOLATION, content: { type: NodeTypes.SIMPLE_EXPRESSION, content: `a\u0026lt;b`, // content = preTrimContent.trim() 去掉前后空格  isStatic: false, isConstant: false, loc: { start: { offset: 3, line: 1, column: 4 }, end: { offset: 6, line: 1, column: 7 }, source: \u0026#39;a\u0026lt;b\u0026#39; } }, loc: { start: { offset: 0, line: 1, column: 1 }, end: { offset: 9, line: 1, column: 10 }, source: \u0026#39;{{ a\u0026lt;b }}\u0026#39; } }) })     通过该用例代码链接🛬\n  01- simple interpolation  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24  test(\u0026#39;simple interpolation\u0026#39;, () =\u0026gt; { const ast = baseParse(\u0026#39;{{message}}\u0026#39;) const interpolation = ast.children[0] expect(interpolation).toStrictEqual({ type: NodeTypes.INTERPOLATION, content: { type: NodeTypes.SIMPLE_EXPRESSION, content: `message`, isStatic: false, isConstant: false, loc: { start: { offset: 2, line: 1, column: 3 }, // m 位置  end: { offset: 9, line: 1, column: 10 }, // 最后一个 e 位置  source: `message` } }, loc: { start: { offset: 0, line: 1, column: 1 }, // 第一个 { 位置  end: { offset: 11, line: 1, column: 12 }, // 最后一个 } 位置  source: \u0026#39;{{message}}\u0026#39; } }) }        Text 文本解析  07-only \u0026#34;{{\u0026#34; don\\\u0026#39;t separate nodes   这个用例是用来检测插值不完整的情况，正常会爆出 X_MISSING_INTERPOLATION_END 异 常，在该用例中重写了该异常处理，因此不会报错，用例会很顺利通过，因为没有异常， parseInterpolation 会退出，最后 {{ 会被当做普通文本内容处理。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20  test(\u0026#39;lonly \u0026#34;{{\u0026#34; don\\\u0026#39;t separate nodes\u0026#39;, () =\u0026gt; { const ast = baseParse(\u0026#39;a {{ b\u0026#39;, { onError: (error) =\u0026gt; { if (error.code !== ErrorCodes.X_MISSING_INTERPOLATION_END) { throw error } } }) const text = ast.children[0] expect(text).toStrictEqual({ type: NodeTypes.TEXT, content: \u0026#39;a {{ b\u0026#39;, loc: { start: { offset: 0, line: 1, column: 1 }, end: { offset: 6, line: 1, column: 7 }, source: \u0026#39;a {{ b\u0026#39; } }) }) // lonly \u0026#34;{{\u0026#34; don\\\u0026#39;t separate nodes      parseInterpolation 该用例处理代码：\n1 2 3 4 5 6 7 8 9 10 11 12 13  function parseInterpolation(context, mode) { // 找出插值模板的开始和结束符号，默认是 {{ 和 }}  const [open, close] = context.options.delimiters const closeIndex = context.source.indexOf(close, open.length) if (closeIndex === -1) { // 这里检测到没有 }} 退出，并且到这里 context 指针信息并没有改变  // 因此退出之后，重新 while 最后进入文本解析 parseText  emitError(context, ErrorCodes.X_MISSING_INTERPOLATION_END) return undefined } // ... 省略  }     test:\n➜ packages git:(master) ✗ jest compiler-core PASS compiler-core/__tests__/parse.spec.js (19.233 s) compiler: parse Text ✓ simple text (5 ms) ✓ simple text with invalid end tag (2 ms) ✓ text with interpolation (1 ms) ✓ text with interpolation which has `\u0026lt;` (1 ms) ✓ text with mix of tags and interpolations (1 ms) ✓ lonly \u0026#34;\u0026lt;\u0026#34; don\u0026#39;t separate nodes (7 ms) ✓ lonly \u0026#34;{{\u0026#34; don\u0026#39;t separate nodes Test Suites: 1 passed, 1 total Tests: 7 passed, 7 total Snapshots: 0 total Time: 23.277 s Ran all test suites matching /compiler-core/i    06-only \u0026#34;\u0026lt;\u0026#34; don\\\u0026#39;t separate nodes  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20  test(\u0026#39;lonly \u0026#34;\u0026lt;\u0026#34; don\\\u0026#39;t separate nodes\u0026#39;, () =\u0026gt; { const ast = baseParse(\u0026#39;a \u0026lt; b\u0026#39;, { onError: (err) =\u0026gt; { if (err.code !== ErrorCodes.INVALID_FIRST_CHARACTER_OF_TAG_NAME) { throw err } } }) const text = ast.children[0] expect(text).toStrictEqual({ type: NodeTypes.TEXT, content: \u0026#39;a \u0026lt; b\u0026#39;, loc: { start: { offset: 0, line: 1, column: 1 }, end: { offset: 5, line: 1, column: 6 }, source: \u0026#39;a \u0026lt; b\u0026#39; } }) // lonly \u0026#34;\u0026lt;\u0026#34; don\\\u0026#39;t separate nodes  }     这个用例在实现的 test-05 之后就可以通过，因为 a \u0026lt; b 并不是插值一部分，会被当做 纯文本处理，而为了避免报错用例中重写了 onError=，因为 while 循环里在检测到 =\u0026lt; 开头的 if 条件分支中，第二个字符为空格的情况会进入最后的 else 分支处理，即触发 INVALID_FIRST_CHARACTER_OF_TAG_NAME 异常。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18  else if (mode === TextModes.DATA \u0026amp;\u0026amp; s[0] === \u0026#39;\u0026lt;\u0026#39;) { // ... 标签开头 \u0026lt;...  if (s.length === 1) { emitError(context, ErrorCodes.EOF_BEFORE_TAG_NAME, 1) } else if (s[1] === \u0026#39;!\u0026#39;) { // TODO 注释处理，\u0026lt;!-- ...  } else if (s[1] === \u0026#39;/\u0026#39;) { // ...  } else if (/[a-z]/i.test(s[1])) { // ...  } else if (s[1] === \u0026#39;?\u0026#39;) { // ...  } else { // 会进入到这里，触发异常，但是由于 options 里提供了 onError 重写了它  // 因此这里不会触发异常，而是退出该分支进入 纯文本处理，合并文本 pushnode 操作  emitError(context, ErrorCodes.INVALID_FIRST_CHARACTER_OF_TAG_NAME, 1) } }      05-text with mix of tags and interpolations  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24  test(\u0026#39;text with mix of tags and interpolations\u0026#39;, () =\u0026gt; { const ast = baseParse(\u0026#39;some \u0026lt;span\u0026gt;{{ foo \u0026lt; bar + foo }} text\u0026lt;/span\u0026gt;\u0026#39;) const text1 = ast.children[0] as TextNode const text2 = (ast.children[1] as ElementNode).children![1] as TextNode expect(text1).toStrictEqual({ type: NodeTypes.TEXT, content: \u0026#39;some \u0026#39;, loc: { start: { offset: 0, line: 1, column: 1 }, end: { offset: 5, line: 1, column: 6 }, source: \u0026#39;some \u0026#39; } }) expect(text2).toStrictEqual({ type: NodeTypes.TEXT, content: \u0026#39; text\u0026#39;, loc: { start: { offset: 32, line: 1, column: 33 }, end: { offset: 37, line: 1, column: 38 }, source: \u0026#39; text\u0026#39; } }) }     这是个标签+插值混合模板，现阶段的代码是通不过该测试的，因为它会进入到下面这个分支：\n1 2 3 4 5 6 7  else if (/[a-z]/i.test(s[2])) { // 这里都出错了，为啥后面还有个 parseTag ???  // 到这里就会报错  emitError(context, ErrorCodes.X_INVALID_END_TAG) parseTag(context, TagType.End, parent) continue } else {     如控制台输出：\n  错误上面的输出其实是 }} 和 {{ 的解析位置信息，并且 \u0026lt;div\u0026gt; 并没有解析是因为我们 还没实现 parseElement 分支逻辑，所以直接过滤掉当成文本处理了。\n  右边： offset=14 刚好是 `some \u0026lt;span\u0026gt;{{ ` 字符串长度 + 1 即插值内第一个空格的位置\n  左边：offset=29 刚好是 14 + `foo \u0026lt; bar + foo` 长度位置(slice 不包含 endIdx)， 即插值内最后一个空格的位置\n  接下来我们得看下怎么不报错能解析 \u0026lt;/div\u0026gt; 。\n 大概的猜想是在解析 \u0026lt;div\u0026gt; 的时候发现是标签，可能会重写 onError ，避免在解析 \u0026lt;/div\u0026gt; 触发异常，而是进入 parseTag 解析结束标签。但很可惜不是这样，而是在 parseElement 中递归 调用 parseChildren 解析标签内部的模板，解析完成之后检测 结束标签，无结束标签，非法异常，具体实现请看 parseElement 源码实 现。 \n 在实现了 parseElement 和部分 parseTag 之后用例通过：\n➜ packages git:(master) ✗ jest compiler-core PASS compiler-core/__tests__/parse.spec.js (14.492 s) compiler: parse Text ✓ simple text (5 ms) ✓ simple text with invalid end tag (2 ms) ✓ text with interpolation (2 ms) ✓ text with interpolation which has `\u0026lt;` (1 ms) ✓ text with mix of tags and interpolations (2 ms) Test Suites: 1 passed, 1 total Tests: 5 passed, 5 total Snapshots: 0 total Time: 15.743 s Ran all test suites matching /compiler-core/i.   期间碰到个问题：\n \u0026gt; Cannot find module \u0026#39;core-js/modules/es6.string.iterator\u0026#39; from \u0026#39;packages/compiler-core/parse.js\u0026#39;\n 解决方案：是 core-js 降级到 2\n  04-text with interpolation which has `\u0026lt;`  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24  test(\u0026#39;text with interpolation which has `\u0026lt;`\u0026#39;, () =\u0026gt; { const ast = baseParse(\u0026#39;some {{ a\u0026lt;b \u0026amp;\u0026amp; c\u0026gt;d }} text\u0026#39;) const text1 = ast.children[0] as TextNode const text2 = ast.children[2] as TextNode expect(text1).toStrictEqual({ type: NodeTypes.TEXT, content: \u0026#39;some \u0026#39;, loc: { start: { offset: 0, line: 1, column: 1 }, end: { offset: 5, line: 1, column: 6 }, source: \u0026#39;some \u0026#39; } }) expect(text2).toStrictEqual({ type: NodeTypes.TEXT, content: \u0026#39; text\u0026#39;, loc: { start: { offset: 21, line: 1, column: 22 }, end: { offset: 26, line: 1, column: 27 }, source: \u0026#39; text\u0026#39; } }) })     这个用例其实和 03-text with interpolation 用例原理一样，虽然插值里面有特殊字符 \u0026lt; ，但是由于在 parseInterpolation 函数解析过程中是通过截取 {{ 到 }} 直接的全部 字符串去解析的。\n1 2 3 4 5 6 7 8 9 10 11 12 13  function parseInterpolation( context: ParserContext, mode: TextModes ): InterpolationNode | undefined { // ... 省略  // 也就是这两行，将 {{ ... }} 内的所有内容一次性取出来解析了，因此并不会  // 进入到 parseChildren 的 while 循环中处理，也就不会出现异常情况  const rawContentLength = closeIndex - open.length const rawContent = context.source.slice(0, rawContentLength) // ... 省略  }     所以这个用例会很顺利的通过(在 03 用例通过的前提下)。\nPASS packages/compiler-core/__tests__/parse.spec.js (5.375 s) compiler: parse Text ✓ simple text (5 ms) ✓ simple text with invalid end tag (3 ms) ✓ text with interpolation (41 ms) ✓ text with interpolation which has `\u0026lt;` (3 ms)    03-text with interpolation   该用例代码链接 -\u0026gt;\n 该用例检验的差值的处理。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25  test(\u0026#34;text with interpolation\u0026#34;, () =\u0026gt; { const ast = baseParse(\u0026#34;some {{ foo + bar }} text\u0026#34;); const text1 = ast.children[0], text2 = ast.children[2]; expect(text1).toStrictEqual({ type: NodeTypes.TEXT, content: \u0026#34;some \u0026#34;, loc: { start: { offset: 0, line: 1, column: 1 }, source: \u0026#34;some \u0026#34;, end: { offset: 5, line: 1, column: 6 }, }, }); expect(text2).toStrictEqual({ type: NodeTypes.TEXT, content: \u0026#34; text\u0026#34;, loc: { start: { offset: 20, line: 1, column: 21 }, source: \u0026#34; text\u0026#34;, end: { offset: 25, line: 1, column: 26 }, }, }); }     差值的处理分支在 parseChildren 的\n1 2 3 4  if (!context.inVPre \u0026amp;\u0026amp; startsWith(s, context.options.delimiters[0])) { // \u0026#39;{{\u0026#39;  node = parseInterpolation(context, mode) }     完成，因为需要 parseInterpolation() 的支持。\n 用例结果(OK )：\n➜ vue-next-code-read git:(master) ✗ jest parse.spec PASS packages/compiler-core/__tests__/parse.spec.js compiler: parse Text ✓ simple text (4 ms) ✓ simple text with invalid end tag (2 ms) ✓ text with interpolation (47 ms) console.log { column: 18, line: 1, offset: 17 } { column: 9, line: 1, offset: 8 } 1 at parseInterpolation (packages/compiler-core/parse.js:262:11) Test Suites: 1 passed, 1 total Tests: 3 passed, 3 total Snapshots: 0 total Time: 8.776 s Ran all test suites matching /parse.spec/i. ➜ vue-next-code-read git:(master) ✗    02-simple text\\\u0026lt;div\u0026gt;   该用例代码链接-\u0026gt;\n 在跑这个用例的时候出现内存溢出了，查了下原因是因为只是增加了 while 里面的各种 if 分支，但是实际并没有实现，这个用例会走到\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23  else if (mode === TextModes.DATA \u0026amp;\u0026amp; s[0] === \u0026#34;\u0026lt;\u0026#34;) { // ... 标签开头 \u0026lt;...  if (s.length === 1) { emitError(context, ErrorCodes.EOF_BEFORE_TAG_NAME, 1); } else if (s[1] === \u0026#34;!\u0026#34;) { // TODO 注释处理，\u0026lt;!-- ...  } else if (s[1] === \u0026#34;/\u0026#34;) { // \u0026lt;/...  if (s.length === 2) { emitError(context, ErrorCodes.EOF_BEFORE_TAG_NAME, 2); } else if (s[2] === \u0026#34;\u0026gt;\u0026#34;) { // ...  } else if (/[a-z]/i.test(s[2])) { // 会走到这个分支里面，但是由于下面的 parseTag 未实现，因此一直在这个分支里面循环  // 加上用例里面重写了 onError 不会 throw err 终止，因此会出现死循环  emitError(context, ErrorCodes.X_INVALID_END_TAG); // 但是上面都报错了，为什么这里还要加个 parseTag??? 正常理解应该是走不到这里啊  // 除非有重写 onError 报错机制???  // parseTag(context, TagType.End, parent);  continue; } else { // ...  }     因此要通过这个用例，就必须得实现 parseTag(context, TagType.End, parent) 函数解析标签。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18  test(\u0026#34;simple text with invalid end tag\u0026#34;, () =\u0026gt; { const onError = jest.fn(); const ast = baseParse(\u0026#34;some text\u0026lt;/div\u0026gt;\u0026#34;, { onError, }); const text = ast.children[0]; expect(onError).toBeCalled(); expect(text).toStrictEqual({ type: NodeTypes.TEXT, content: \u0026#34;some text\u0026#34;, loc: { start: { offset: 0, line: 1, column: 1 }, end: { offset: 9, line: 1, column: 10 }, source: \u0026#34;some text\u0026#34;, }, }); }     因为 baseparse 调用的时候有传递 onError 覆盖报错代码，会进入到 parseTag 进行解析 标签，如果不实现会导致死循环。因此这里要通过这个用例就必须实现 parseTag():\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17  function parseTag(context, type, parent) { // 获取当前解析的起始位置，此时值应该是 some text 的长度  const start = getCursor(context); // 匹配 \u0026lt;/div 过滤掉空格字符，但是为什么要把 \u0026gt; 给忽略掉???  const match = /^\u0026lt;\\/?([a-z][^\\t\\r\\n\\f /\u0026gt;]*)/i.exec(context.source); const tag = match[1]; const ns = context.options.getNamespace(tag, parent); // log1: 改变位移，将 offset 定位到 \u0026lt;/div\u0026gt; 的最有一个 \u0026gt; 上  // 在这里 context.offset = 10, context.line = 1  advanceBy(context, match[0].length); // 过滤掉空格  advanceSpaces(context); // log2: 经过 advance 之后 context.offset = 15, context.line = 1  // 正好过滤 \u0026lt;/div 5 个字符  const cursor = getCursor(context); const currSource = context.source; }     parseTag 实现到这里就可以满足通过测试用例的条件了，这里面会去匹配 \u0026lt;/div 然后将 其过滤掉(通过 advanceBy 和 advanceSpaces 来改变 context 里面的 offset 和 line 值)， 输出结果(log1 和 log2 位置 context 的输出)：\n   01-simple text   这里用到的就一个 baseParse 函数，需要我们来实现其基本的功能以通过该用例。\n 用例源码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14  test(\u0026#39;simple text\u0026#39;, () =\u0026gt; { const ast = baseParse(\u0026#39;some text\u0026#39;) const text = ast.children[0] as TextNode expect(text).toStrictEqual({ type: NodeTypes.TEXT, content: \u0026#39;some text\u0026#39;, loc: { start: { offset: 0, line: 1, column: 1 }, end: { offset: 9, line: 1, column: 10 }, source: \u0026#39;some text\u0026#39; } }) })     用例的基本功能，验证 baseParse 解析出来的文本节点对象是否满足基本要求。\n 支持该用例的重要部分代码：\n  createParseContext 构建被解析的内容的对象结构\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  function createParserContext(context, options) /*ParserContext*/ { return { options: { ...defaultParserOptions, ...options, }, // 初始化以下内容  column: 1, line: 1, offset: 0, originalSource: context, source: context, inPref: false, inVPref: false, }; }      parseChildren\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48  function parseChildren( context /* ParserContext*/, mode /*TextModes*/, ancesotrs /*ElementNode[]*/ ) { // ...  const nodes /*TemplateChildNode[]*/ = []; while (!isEnd(context, mode, ancesotrs)) { // do sth  const s = context.source; let node = undefined; // 由于 baseparse 里面传过来的是个 DATA 类型，因此会走到这个 if 里  // 面去解析  if (mode === TextModes.DATA || mode === TextModes.RCDATA) { // 过略掉非文本的  if (!context.inVPre \u0026amp;\u0026amp; s.startsWith(context.options.delimiters[0])) { // ... 插值处理{{}}  } else if (mode === TextModes.DATA \u0026amp;\u0026amp; s[0] === \u0026#34;\u0026lt;\u0026#34;) { // ... 标签开头 \u0026lt;...  } // ... 到这里也就是说文本节点不会被这个 if 处理，而是直接到  // !node 给 parseText 解析  } if (!node) { // 纯文本重点在这里面处理，截取字符直到遇到 \u0026lt;, {{, ]]\u0026gt; 标志结束  // 然后传入到 parseTextData() 判断是否是数据绑定的变量，在  // context.options.decodeEntities() 中处理  node = parseText(context, mode); } if (Array.isArray(node)) { for (let i = 0; i \u0026lt; node.length; i++) { pushNode(nodes, node[i]); } } else { pushNode(nodes, node); } } let removedWhitespace = false; return removedWhitespace ? nodes.filter(Boolean) : nodes; }      parseText\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26  function parseText(context, mode) { // 字符串解析直到遇到 \u0026lt;, {{, ]]\u0026gt; 为止  const endTokens = [\u0026#34;\u0026lt;\u0026#34;, context.options.delimiters[0]]; if (mode === TextModes.CDATA) { endTokens.push(\u0026#34;]]\u0026gt;\u0026#34;); } let endIndex = context.source.length; for (let i = 0; i \u0026lt; endTokens.length; i++) { const index = context.source.indexOf(endTokens[i], 1); if (index !== -1 \u0026amp;\u0026amp; endIndex \u0026gt; index) { endIndex = index; } } const start = getCursor(context); // 解析 \u0026amp; 开头的 html 语义的符号(\u0026gt;,\u0026lt;,\u0026amp;,\u0026#39;,\u0026#34;)  const content = parseTextData(context, endIndex, mode); return { type: NodeTypes.TEXT, content, // loc:{ start, end, source}  // start,end: { line, column, offset }  loc: getSelection(context, start), }; }      parseTextData\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18  // 解析文本数据，纯文本内容  function parseTextData(context, length, mode) { const rawText = context.source.slice(0, length); // 解析换行，更新 line, column, offset，返回换行之后的的 source  advanceBy(context, length); if ( mode === TextModes.RAWTEXT || mode === TextModes.CDATA || rawText.indexOf(\u0026#34;\u0026amp;\u0026#34;) === -1 ) { return rawText; } return context.options.decodeEntities( rawText, mode === TextModes.ATTRIBUTE_VALUE ); }      advancedBy 解析多个字符之后更新 start,end(line,column,offset) ，尤其是换行符的特殊处理。\n1 2 3 4 5  function advanceBy(context, numberOfCharacters) { const { source } = context; advancePositionWithMutation(context, source, numberOfCharacters); context.source = source.slice(numberOfCharacters); }      advancePositionWithMutation\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23  export function advancePositionWithMutation( pos, source, numberOfCharacters = source.length ) { let linesCount = 0; let lastNewLinePos = -1; for (let i = 0; i \u0026lt; numberOfCharacters; i++) { if (source.charCodeAt(i) === 10 /* newline char code */) { linesCount++; lastNewLinePos = i; } } pos.offset += numberOfCharacters; pos.line += linesCount; pos.column = lastNewLinePos === -1 ? pos.column + numberOfCharacters : numberOfCharacters - lastNewLinePos; return pos; }            函数列表  baseParse(context, options)  1 2 3 4 5 6 7 8  function baseParse(content, options /* ParserOptions */) /*RootNode*/ { const context = createParserContext(content, options); const start = getCursor(context); return createRoot( parseChildren(context, TextModes.DATA, []), getSelection(context, start) ); }     baseParse 内部实现基本就是调用其他方法，所以接下来我们得针对它使用的几个方法去逐一实现：\n  createParserContext，创建节点解析对象，包含解析过程中需要或需要保存的数据\n  getCursor，获取 context 中的 offset, line, column, start, end 等信息\n  createRoot，创建根节点\n  parseChildren，解析子节点\n  getSelection，获取选中的未解析的内容\n  baseParse 函数大体结构和代码调用图示：\n   createParseContext(context, options)   函数作用：*创建解析器上下文对象(包含解析过程中的一些记录信息)*\n 函数声明：\n function createParserContext(context, options) /*ParserContext*/ {}\n 参数没什么好讲的了，从 baseParse 继承而来，返回的是一个 ParserContext 类型。具体 实现其实就是返回一个 ParserContext 类型的对象，里面包含了源码字符串被解析是的一 些信息存储，比如：解析时指针的位置 offset，当前行列(line, column)，及其他信息。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19  function createParserContext( content: string, options: ParserOptions ): ParserContext { return { options: { // 解析器的默认选项给了些默认值，比如：isVoidTag: No, isPreTag: NO， 等等  ...defaultParserOptions, ...options }, column: 1, line: 1, offset: 0, originalSource: content, source: content, inPre: false, inVPre: false } }      parseChildren(context, mode, ancestors)  1 2 3 4 5  function parseChildren( context /* ParserContext*/, mode /*TextModes*/, ancesotrs /*ElementNode[]*/ ) /* TemplateChildNode[] */{}     参数列表：\n  context，待解析的模板对象(ParserContext)\n  mode，文本模式(TextModes)\n  ancestors，祖先元素(ElementNode[]​)\n  返回结果： TemplateChildNode[]​\n阶段一(test01 some text)   实现 parseText() 之后的 parseChildren() 代码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46  function parseChildren( context /* ParserContext*/, mode /*TextModes*/, ancesotrs /*ElementNode[]*/ ) { // ...  const nodes /*TemplateChildNode[]*/ = []; while (!isEnd(context, mode, ancesotrs)) { // do sth  const s = context.source; let node = undefined; // 由于 baseparse里面传过来的是个 DATA 类型，因此会走到这个 if 里  // 面去解析  if (mode === TextModes.DATA || mode === TextModes.RCDATA) { // 过略掉非文本的  if (!context.inVPre \u0026amp;\u0026amp; s.startsWith(context.options.delimiters[0])) { // ... 插值处理{{}}  } else if (mode === TextModes.DATA \u0026amp;\u0026amp; s[0] === \u0026#34;\u0026lt;\u0026#34;) { // ... 标签开头 \u0026lt;...  } // ... 到这里也就是说文本节点不会被这个 if 处理，而是直接到  // !node 给 parseText 解析  } if (!node) { node = parseText(context, mode); } if (Array.isArray(node)) { for (let i = 0; i \u0026lt; node.length; i++) { pushNode(nodes, node[i]); } } else { pushNode(nodes, node); } console.log(context, \u0026#34;parse children\u0026#34;); } let removedWhitespace = false; return removedWhitespace ? nodes.filter(Boolean) : nodes; }     最后处理完之后文本节点对象内容如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25  { options: { delimiters: [ \u0026#39;{{\u0026#39;, \u0026#39;}}\u0026#39; ], getNamespace: [Function: getNamespace], getTextMode: [Function: getTextMode], isVoidTag: false, isPreTag: false, isCustomElement: false, decodeEntities: [Function: decodeEntities], onError: null }, // 这里发生了变换  // column: 定位到了字符串最后即 \u0026#39;simple text\u0026#39; 的长度 + 1，即结束位置  // line: 因为只有一行，所以 line 并未发生改变，如果发生了改变会在 advancedBy 里面进行处理更新  // offset: 类似文件处理时的指针偏移量，即字符串长度  column: 12, line: 1, offset: 11, // 会发现处理完成之后，originalSource 维持原样  originalSource: \u0026#39;simple text\u0026#39;, // source 变成了空字符串，因为处理完了  source: \u0026#39;\u0026#39;, inPref: false, inVPref: false } // parse children      baseParse 之后的 ast 结构：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36  // 这个结构的形成是经过 createRoot 处理之后的结果  // 经过 parseChildren 之后的结果会被存放到 root 的children 中，如下  { type: 0, children: [ { type: 2, content: \u0026#39;\\nsimple text 1\\n simple text 2\\n\u0026#39;, loc: [Object] } ], loc: { start: { column: 1, line: 1, offset: 0 }, end: { column: 1, line: 4, offset: 30 }, source: \u0026#39;\\nsimple text 1\\n simple text 2\\n\u0026#39; }, helpers: [], components: [], directives: [], hoists: [], imports: [], cached: 0, temps: 0, codegenNode: undefined } //// ast  // 第一个 children 结构：  { type: 2, content: \u0026#39;\\nsimple text 1\\n simple text 2\\n\u0026#39;, loc: { start: { column: 1, line: 1, offset: 0 }, end: { column: 1, line: 4, offset: 30 }, source: \u0026#39;\\nsimple text 1\\n simple text 2\\n\u0026#39; } } //// ast      阶段代码：test-01-some-text 测试用例通过\n 图示：文本解析\n   阶段二(\u0026lt;div …\u0026gt;\u0026lt;/div\u0026gt;\\n\u0026lt;div …\u0026gt;\u0026lt;/div\u0026gt;)   增加空行节点过滤。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142  function parseChildren( context /* ParserContext*/, mode /*TextModes*/, ancestors /*ElementNode[]*/ ) { // ...  const parent = last(ancestors); const ns = parent ? parent.ns : Namespaces.HTML; const nodes /*TemplateChildNode[]*/ = []; let i = 0; while (!isEnd(context, mode, ancestors)) { // do sth  const s = context.source; let node = undefined; // 由于 baseparse里面传过来的是个 DATA 类型，因此会走到这个 if 里  // 面去解析  if (mode === TextModes.DATA || mode === TextModes.RCDATA) { // 过略掉非文本的  if (!context.inVPre \u0026amp;\u0026amp; s.startsWith(context.options.delimiters[0])) { // ... 插值处理{{}}  node = parseInterpolation(context, mode); } else if (mode === TextModes.DATA \u0026amp;\u0026amp; s[0] === \u0026#34;\u0026lt;\u0026#34;) { // ... 标签开头 \u0026lt;...  if (s.length === 1) { emitError(context, ErrorCodes.EOF_BEFORE_TAG_NAME, 1); } else if (s[1] === \u0026#34;!\u0026#34;) { // TODO 注释处理，\u0026lt;!-- ...  if (s.startsWith(\u0026#34;\u0026lt;!--\u0026#34;)) { // 普通的 html 注释  node = parseComment(context); } } else if (s[1] === \u0026#34;/\u0026#34;) { // \u0026lt;/...  if (s.length === 2) { emitError(context, ErrorCodes.EOF_BEFORE_TAG_NAME, 2); } else if (s[2] === \u0026#34;\u0026gt;\u0026#34;) { // \u0026lt;/\u0026gt; 不带标签名的无效标签  emitError(context, ErrorCodes.MISSING_END_TAG_NAME, 2); // 过滤掉 \u0026lt;/\u0026gt; 这三个字符串，offset\u0026gt;\u0026gt;3 退出本次循环继续解析  advanceBy(context, 3); continue; } else if (/[a-z]/i.test(s[2])) { // 这里都出错了，为啥后面还有个 parseTag ???  emitError(context, ErrorCodes.X_INVALID_END_TAG); parseTag(context, TagType.End, parent); continue; } else { emitError( context, ErrorCodes.INVALID_FIRST_CHARACTER_OF_TAG_NAME, 2 ); // node = parseBogusComment(context)  } } else if (/[a-z]/i.test(s[1])) { // 解析起始标签，即这里才是标签最开始的位置。  node = parseElement(context, ancestors); } else if (s[1] === \u0026#34;?\u0026#34;) { // \u0026lt;? 开始的  emitError( context, ErrorCodes.UNEXPECTED_QUESTION_MARK_INSTEAD_OF_TAG_NAME, 1 ); // node = parseBogusComment(context)  } else { // 其他情况都视为非法  emitError(context, ErrorCodes.INVALID_FIRST_CHARACTER_OF_TAG_NAME, 1); } } // ... 到这里也就是说文本节点不会被这个 if 处理，而是直接到  // !node 给 parseText 解析  } if (!node) { node = parseText(context, mode); } if (Array.isArray(node)) { for (let i = 0; i \u0026lt; node.length; i++) { pushNode(nodes, node[i]); } } else { pushNode(nodes, node); } } console.log(nodes); let removedWhitespace = false; // TODO 空格管理，为了更高效的输出  // `\\n\u0026lt;div\u0026gt;...` 删除开头的空格字符，之前解析 v-pre 用例是卡在这里了  // 这里忘记实现了，所以用例 http://www.cheng92.com/vue/vue3-source-code-compiler-core-parse_ts/#headline-3  // 得到了三个 child，第二个是 \\n，就是因为这里没实现过滤  if (mode !== TextModes.RAWTEXT) { if (!context.inPre) { for (let i = 0; i \u0026lt; nodes.length; i++) { const node = nodes[i]; if (node.type === NodeTypes.TEXT) { if (!/[^\\t\\r\\n\\f ]/.test(node.content)) { const prev = nodes[i - 1]; const next = nodes[i + 1]; // 1. 空格是第一个或者最后一个节点，或者  // 2. 空格与注释节点相邻  // 3. 空格在两个元素之间，就我们遇到的 \u0026lt;div\u0026gt;\u0026lt;/div\u0026gt;\\n\u0026lt;div\u0026gt;...  // 上面三种情况的空格会被忽略  if ( !prev || !next || prev.type === NodeTypes.COMMENT || next.type === NodeTypes.COMMENT || (prev.type === NodeTypes.ELEMENT \u0026amp;\u0026amp; next.type === NodeTypes.ELEMENT \u0026amp;\u0026amp; /[\\r\\n]/.test(node.content)) ) { removedWhitespace = true; nodes[i] = null; } else { // 否则替换成空格  node.content = \u0026#34; \u0026#34;; } } else { // 替换成空格  node.content = node.content.replace(/[\\t\\r\\n\\f ]+/g, \u0026#34; \u0026#34;); } } } } else if (parent \u0026amp;\u0026amp; context.options.isPreTag(parent.tag)) { //如果是 \u0026lt;pre\u0026gt; 删掉第一行的空行  const first = nodes[0]; if (first \u0026amp;\u0026amp; first.type === NodeTypes.TEXT) { first.content = first.content.replace(/^\\r?\\n/, \u0026#34;\u0026#34;); } } } return removedWhitespace ? nodes.filter(Boolean) : nodes; }        parseComment(context)   注释处理函数，解析原则是匹配 \u0026lt;!-- 开头和 --\u0026gt; 结尾，中间部分统统视为注释，中 间需要考虑嵌套注释问题。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59  function parseComment(context) /* CommentNode */ { const start = getCursor(context) let content const match = /--(\\!)?\u0026gt;/.exec(context.source) if (!match) { // 没有闭合注释，后面的所有都会被当做注释处理  content = context.source.slice(4) advanceBy(context, context.source.length) // 后面所有的都成为注释  emitError(context, ErrorCodes.EOF_IN_COMMENT) } else { console.log(match) if (match.index \u0026lt;= 3) { // 空注释也报错  emitError(context, ErrorCodes.ABRUPT_CLOSING_OF_EMPTY_COMMENT) } // 非法结束，比如： \u0026lt;!-xx--!\u0026gt;，正则里面有个 (\\!)? 捕获组  // match[1] 就是指这个匹配  if (match[1]) { emitError(context, ErrorCodes.INCORRECTLY_CLOSED_COMMENT) } // 取注释内容，match.index 即 /--(\\!)?\u0026gt;/ 正则匹配的开始索引位置  content = context.source.slice(4, match.index) // 嵌套注释??? 这里slice 之后的 s 不包含结束 --\u0026gt;  const s = context.source.slice(0, match.index) let prevIndex = 1, nestedIndex = 0 console.log({ s }) // 首先能进入 parseComment，说明 source 是以 \u0026lt;!-- 开头的，且是包含 --\u0026gt; 的  // 否则前面就会出现异常，因此如果嵌套那可能情况只有\u0026lt;!--x\u0026lt;!--y--\u0026gt;注释中间  // 出现过 \u0026lt;!--  while ((nestedIndex = s.indexOf(\u0026#39;\u0026lt;!--\u0026#39;, prevIndex)) !== -1) { console.log({ nestedIndex, prevIndex, s, len: s.length }) advanceBy(context, nestedIndex - prevIndex + 1) // + 4 值是 `\u0026lt;!--`.length，如果小于 s.length，说明嵌套了注释  if (nestedIndex + 4 \u0026lt; s.length) { // 非法嵌套, 如：\u0026lt;!--\u0026lt;!--x--\u0026gt;  emitError(context, ErrorCodes.NESTED_COMMENT) } /// 然后定位到嵌套的第一个 \u0026lt;!-- 的 ! 索引上，进入下一轮处理，直  // 到找到最后一个合法的 \u0026lt;!--  prevIndex = nestedIndex + 1 } // 这里应该是没嵌套的情况？？？  advanceBy(context, match.index + match[0].length - prevIndex + 1) } return { type: NodeTypes.COMMENT, content, loc: getSelection(context, start) } }      parseElement(context, mode)   这个解析函数，用来解析 \u0026lt;div\u0026gt; 标签。\n阶段一(test-05)   some \\\u0026lt;span\u0026gt;{{ foo \u0026lt; bar + foo }} text\\\u0026lt;/span\u0026gt;\n 此阶段只实现对 \u0026lt;div\u0026gt;...\u0026lt;/div\u0026gt; 的解析，不包含属性等等其他复杂情况，因为只需要能 通过用例 5 就行。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60  function parseElement(context, ancestors) { // assert context.source 是以 \u0026lt;[a-z] 开头的  const wasInPre = context.inPre const wasInVPre = context.inVPre // 取 ancestors 最后一个节点 node  const parent = last(ancestors) const element = parseTag(context, TagType.Start, parent) // pre or v-pre  const isPreBoundary = context.inPre \u0026amp;\u0026amp; !wasInVPre const isVPreBoundary = context.inVPre \u0026amp;\u0026amp; !wasInVPre // 自闭合的到这里就可以结束了  if (element.isSelfClosing || context.options.isVoidTag?.(element.tag)) { return element } // 子元素 children，被漏掉的代码，会进入递归调用 parseChildren 去解析  // \u0026lt;span\u0026gt;...\u0026lt;/span\u0026gt; 标签内的模板  ancestors.push(element) const mode = context.options.getTextMode(element, parent) const children = parseChildren(context, mode, ancestors) ancestors.pop() element.children = children // P1.... 解析之后 children 里面应该包含两个 node  // node1: 插值内容 `foo \u0026lt; bar + foo`  // node2: 文本节点 ` text`  console.log(element) // 结束标签？ \u0026lt;span\u0026gt;\u0026lt;/span\u0026gt; 这种类型？  // 上面会解析标签内的模板，解析完之后 source 正常应该会是 `\u0026lt;/span\u0026gt; ....`  // 进入 if 解析结束标签  if (startsWithEndTagOpen(context.source, element.tag)) { parseTag(context, TagType.End, parent) } else { // 会进入到这里出现报错  emitError(context, ErrorCodes.X_MISSING_END_TAG, 0, element.loc.start) if (context.source.length === 0 \u0026amp;\u0026amp; element.tag.toLowerCase() === \u0026#39;script\u0026#39;) { const first = children[0] if (first \u0026amp;\u0026amp; first.loc.source.startsWith(\u0026#39;\u0026lt;!--\u0026#39;)) { emitError(context, ErrorCodes.EOF_IN_SCRIPT_HTML_COMMENT_LIKE_TEXT) } } } element.loc = getSelection(context, element.loc.start) console.log(element, \u0026#39;after\u0026#39;) if (isPreBoundary) { context.inPre = false } if (isVPreBoundary) { context.inVPre = false } return element }     实现到这里是为了想看下经过 parseTag 之后的 element 是什么？parseTag 里面有个正则 是用来匹配开始或结束标签的，即： /^\u0026lt;\\/?([a-z][^\\t\\r\\n\\f /\u0026gt;]*)/i 这个既可以匹配 开始标签，也可以匹配结束标签，并且考虑了 \u0026lt;div \u0026gt; 有空格的情况，忽略大小写。\n 正则匹配测试结果：\n/^\u0026lt;\\/?([a-z][^\\t\\r\\n\\f /\u0026gt;]*)/i.exec(\u0026#39;\u0026lt;span\u0026gt;\u0026#39;) (2) [\u0026#34;\u0026lt;span\u0026#34;, \u0026#34;span\u0026#34;, index: 0, input: \u0026#34;\u0026lt;span\u0026gt;\u0026#34;, groups: undefined]   所以这里首先匹配解析的是开始标签 \u0026lt;div\u0026gt; 。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30  // some \u0026lt;span\u0026gt;{{ foo \u0026lt; bar + foo }} text\u0026lt;/span\u0026gt; // parseTag 之后的 element { \u0026#34;type\u0026#34;:1, // 节点类型是 NodeTypes.ELEMENT \u0026#34;ns\u0026#34;:0, // 命名空间就是 HTML \u0026#34;tag\u0026#34;:\u0026#34;span\u0026#34;, \u0026#34;tagType\u0026#34;:0, // 标签类型 ElementTypes.ELEMENT \u0026#34;props\u0026#34;:[ // 标签属性，这里没有 ], \u0026#34;isSelfClosing\u0026#34;:false, // 是不是自闭合标签，如：\u0026lt;img/\u0026gt; \u0026#34;children\u0026#34;:[], \u0026#34;loc\u0026#34;:{ \u0026#34;start\u0026#34;:{ \u0026#34;column\u0026#34;:6, // column 不换行的情况下为 offset + 1，从 1 开始计数 \u0026#34;line\u0026#34;:1, // 没换行符 \u0026#34;offset\u0026#34;:5 // \u0026lt;span\u0026gt; 的 \u0026lt; 开始位置索引 `some `.length = 5 }, \u0026#34;end\u0026#34;:{ \u0026#34;column\u0026#34;:12, \u0026#34;line\u0026#34;:1, // 这里值的变化分两步 // parseTag:start 的时候 // 1. 解析出 \u0026lt;span ，这个时候 offset 其实是 10 // 2. 检测是不是自闭合标签，决定 advancedBy // 移动指针位置数(自闭合：2，非自闭合：1)，到这里 offset = 11 \u0026#34;offset\u0026#34;:11 }, \u0026#34;source\u0026#34;:\u0026#34;\u0026lt;span\u0026gt;\u0026#34; // 为什么不是 `\u0026lt;span\u0026gt;` ??? 漏了自闭合标签检测指针移位 } }     解析之后 context 内容变化：\n1 2 3 4 5 6 7 8 9 10 11 12 13  { \u0026#34;options\u0026#34;:{ // 忽略选项，目前对我们没啥用 }, \u0026#34;column\u0026#34;:12, \u0026#34;line\u0026#34;:1, \u0026#34;offset\u0026#34;:11, // \u0026lt;span\u0026gt; 后面的 \u0026gt; 索引 \u0026#34;originalSource\u0026#34;:\u0026#34;some \u0026lt;span\u0026gt;{{ foo \u0026lt; bar + foo }} text\u0026lt;/span\u0026gt;\u0026#34;, // 解析之后的模板，为何 \u0026gt; 没被去掉???，见 问题1 \u0026#34;source\u0026#34;:\u0026#34;{{ foo \u0026lt; bar + foo }} text\u0026lt;/span\u0026gt;\u0026#34;, \u0026#34;inPref\u0026#34;:false, \u0026#34;inVPref\u0026#34;:false }     到此我们已经解析除了 \u0026lt;span\u0026gt; 开始标签，这个时候的 =node.childrens = []=，下一步 解析标签里面的内容。\n 在实现完整的 parseElement 之后发现执行会报错，因为这个用例并不是 \u0026lt;span\u0026gt;\u0026lt;/span\u0026gt; 标签内没东西，所以会进入 else 触发 emitError() ，那不是没法往下走了？？？\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20  // 子元素 children，被漏掉的代码，会进入递归调用 parseChildren 去解析  // \u0026lt;span\u0026gt;...\u0026lt;/span\u0026gt; 标签内的模板  ancestors.push(element) const mode = context.options.getTextMode(element, parent) const children = parseChildren(context, mode, ancestors) ancestors.pop() element.children = children // ...........☝🏻.☝🏻.☝🏻.☝🏻.☝🏻，加回去  if (startsWithEndTagOpen(context.source, element.tag)) { parseTag(context, TagType.End, parent) } else { emitError(context, ErrorCodes.X_MISSING_END_TAG, 0, element.loc.start) if (context.source.length === 0 \u0026amp;\u0026amp; element.tag.toLowerCase() === \u0026#39;script\u0026#39;) { const first = children[0] if (first \u0026amp;\u0026amp; first.loc.source.startsWith(\u0026#39;\u0026lt;!--\u0026#39;)) { emitError(context, ErrorCodes.EOF_IN_SCRIPT_HTML_COMMENT_LIKE_TEXT) } } }     那是因为前面漏了一段代码。\n 代码加上之后最后代码 P1 出的输出 ancestors 里面会有一个子节点(element)：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62  // ancestors[{...}]，ancestors 第一个节点是 \u0026lt;span\u0026gt; 这个节点 // 重点我们要看的是这个节点的 children 因为其内部有 `{{ foo \u0026lt; bar + foo }} text` // 所以它 的 element 应该有两个节点：`foo \u0026lt; bar + foo` 和 ` text` { // \u0026lt;span\u0026gt; 节点本身的属性，我们重点需要关注的是 children \u0026#34;children\u0026#34;:[ { // 第一个 child 是 {{ ... }} 检测到插值进入 parseInterpolation 分支 // 处理，得到下面的节点结构，插值解析在 parseInterpolation 一章有分析过了 \u0026#34;type\u0026#34;:5, \u0026#34;content\u0026#34;:{ \u0026#34;type\u0026#34;:4, \u0026#34;isStatic\u0026#34;:false, \u0026#34;isConstant\u0026#34;:false, \u0026#34;content\u0026#34;:\u0026#34;foo \u0026lt; bar + foo\u0026#34;, \u0026#34;loc\u0026#34;:{ \u0026#34;start\u0026#34;:{ \u0026#34;column\u0026#34;:15, \u0026#34;line\u0026#34;:1, \u0026#34;offset\u0026#34;:14 }, \u0026#34;end\u0026#34;:{ \u0026#34;column\u0026#34;:30, \u0026#34;line\u0026#34;:1, \u0026#34;offset\u0026#34;:29 }, \u0026#34;source\u0026#34;:\u0026#34;foo \u0026lt; bar + foo\u0026#34; } }, \u0026#34;loc\u0026#34;:{ \u0026#34;start\u0026#34;:{ \u0026#34;column\u0026#34;:12, \u0026#34;line\u0026#34;:1, \u0026#34;offset\u0026#34;:11 }, \u0026#34;end\u0026#34;:{ \u0026#34;column\u0026#34;:33, \u0026#34;line\u0026#34;:1, \u0026#34;offset\u0026#34;:32 }, \u0026#34;source\u0026#34;:\u0026#34;{{ foo \u0026lt; bar + foo }}\u0026#34; } }, { \u0026#34;type\u0026#34;:2, \u0026#34;content\u0026#34;:\u0026#34; text\u0026#34;, \u0026#34;loc\u0026#34;:{ \u0026#34;start\u0026#34;:{ \u0026#34;column\u0026#34;:33, \u0026#34;line\u0026#34;:1, \u0026#34;offset\u0026#34;:32 }, \u0026#34;end\u0026#34;:{ \u0026#34;column\u0026#34;:38, \u0026#34;line\u0026#34;:1, \u0026#34;offset\u0026#34;:37 }, \u0026#34;source\u0026#34;:\u0026#34; text\u0026#34; } } ], // \u0026lt;span\u0026gt; 本身节点的 loc }     这里也没什么好解释的，插值在 parseInterpolation 处分析过了，文本解析在 parseText 处分析了。\n    parseInterpolation(context, mode)   函数声明：\n1 2 3 4  function parseInterpolation( context: ParserContext, mode: TextModes ): InterpolationNode | undefined {}     context: 将被解析的上下文，此时这里的 source 应该是以差值 ({{)开始的字符串。\n mode: 文本模式。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49  function parseInterpolation(context, mode) { // 找出插值模板的开始和结束符号，默认是 {{ 和 }}  const [open, close] = context.options.delimiters; const closeIndex = context.source.indexOf(close, open.length); if (closeIndex === -1) { emitError(context, ErrorCodes.X_MISSING_INTERPOLATION_END); return undefined; } const start = getCursor(context); advanceBy(context, open.length); // 下面是从 {{ 之后的字符串开始解析  const innerStart = getCursor(context), innerEnd = getCursor(context), // 插值里面的字符串长度  rawContentLength = closeIndex - open.length, // 插值里面的字符串内容  rawContent = context.source.slice(0, rawContentLength), preTrimContent = parseTextData(context, rawContentLength, mode), content = preTrimContent.trim(), startOffset = preTrimContent.indexOf(content); if (startOffset \u0026gt; 0) { advancePositionWithMutation(innerStart, rawContent, startOffset); } // {{ foo + bar }} -\u0026gt;  // res = (\u0026#39; foo + bar \u0026#39;.length - \u0026#39;foo + bar\u0026#39;.length - \u0026#39; \u0026#39;.length)  // 插值里面字符串的长度 - 去掉空格后的长度 - 起始空格的长度，得到的  // 就是结束位置的 offset  const endOffset = rawContentLength - (preTrimContent.length - content.length - startOffset); advancePositionWithMutation(innerEnd, rawContent, endOffset); // 定位到 }} 位置  advanceBy(context, close.length); console.log(innerEnd, innerStart, \u0026#34;1\u0026#34;); return { type: NodeTypes.INTERPOLATION, content: { type: NodeTypes.SIMPLE_EXPRESSION, isStatic: false, isConstant: false, content, loc: getSelection(context, innerStart, innerEnd), }, loc: getSelection(context, start), }; }      图中我们看到在经过解析之后 innerStart 和 innerEnd 都数据都正确定位到了相应位置， innerStart 是解析后插值字符串的开始位置(第一个 { offset = 8(or=\u0026#39;red\u0026#39;\u0026gt;��度\u0026lt;/font\u0026gt;))，innerEnd 是解析后插值字符串的结束位置 (最后一个 } offset = 17(\u0026lt;font color=\u0026#34;purple\u0026#34;\u0026gt;\u0026#39;some {{ foo + bar \u0026#39;的长 度))。\n  解析之后得到的 ast.children 将会有三个节点：\n1 2 3 4 5 6  (3) [{…}, {…}, {…}] 0: {type: 2, content: \u0026#34;some \u0026#34;, loc: {…}} // 左侧文本 1: {type: 5, content: {…}, loc: {…}} // 插值部分 2: {type: 2, content: \u0026#34; text\u0026#34;, loc: {…}} // 右侧文本 length: 3 __proto__: Array(0)     解析回顾(分别解析出了三个节点对象)：\n  0: {type: 2, content: \u0026#34;some \u0026#34;, loc: {…}}\n详细结构：\n1 2 3 4 5 6 7 8 9  0: content: \u0026#34;some \u0026#34; // 解析出的文本内容 loc: // 位置信息 end: {column: 6, line: 1, offset: 5} // 该节点在模板中的位置信息 source: \u0026#34;some \u0026#34; // 文本源内容 start: {column: 1, line: 1, offset: 0} // 该节点在模板中的结束信息 __proto__: Object type: 2 // 节点类型 __proto__: Object     那么是如何得到上面的结果的呢？？？那得从 parseChildren 说起了，模板：\n  —\u0026gt;\u0026gt; \u0026#34;some {{ foo + bar }} text\u0026#34; \n (!context.inVPre \u0026amp;\u0026amp; s.startsWith(context.options.delimiters[0])) 检测失败\n mode === TextModes.DATA \u0026amp;\u0026amp; s[0] === \u0026#34;\u0026lt;\u0026#34; 检测失败\n 即一开始并不会进入插值和标签解析代码，而是直接进入 parseText(context, mode) 中解析文本，解析时候直到遇到 {{ 之前都一直会当做文本解析，而之前的文本中又 不包含 decodeMap 中的字符，因此知道遇到 { 之前会一直执行 while 里面的：\n1 2 3 4 5 6 7 8 9 10 11  if (!node) { node = parseText(context, mode); } if (Array.isArray(node)) { for (let i = 0; i \u0026lt; node.length; i++) { pushNode(nodes, node[i]); } } else { pushNode(nodes, node); }     这段代码，而由于 \u0026#34;some \u0026#34; 都是普通字符，每个字符串会对应一个 node ，然后又都是 普通文本节点，会经过 pushNode(nodes, node[i]) 处理掉，进行合并最后成为上面的 一个完整的 \u0026#34;some \u0026#34; 对应文本节点结构。\n  1: {type: 5, content: {…}, loc: {…}}\n节点结构：\n1: content: // 这里的数据是经过插值解析之后的模板对象 content: \u0026#34;foo + bar\u0026#34; // trim 之后的插值字符串，没有 }} ??? isConstant: false // 非常量类型 isStatic: false // 非静态节点 loc: // 解析之后的该节点在整个模板中的位置信息 // 17 -\u0026gt; r 所在的位置 end: {column: 18, line: 1, offset: 17} source: \u0026#34;foo + bar\u0026#34; // 8 -\u0026gt; f 所在的位置，即 start -\u0026gt; end =\u0026gt; \u0026#39;f \u0026lt;-\u0026gt; r\u0026#39; start: {column: 9, line: 1, offset: 8} __proto__: Object type: 4 // 插值表达式类型 __proto__: Object loc: // 这里是没经过去尾部空格的位置信息 // 20 -\u0026gt; \u0026#39;some {{ foo + bar \u0026#39; 最后一个空格位置 end: {column: 21, line: 1, offset: 20} source: \u0026#34;{{ foo + bar }}\u0026#34; // 5 -\u0026gt; \u0026#39;some \u0026#39; 第一个 { 位置 start: {column: 6, line: 1, offset: 5} __proto__: Object type: 5 // 插值类型 __proto__: Object   如上所注释的，第一级的 loc 是通过解析 \u0026#34;{{ foo + bar}}\u0026#34; 在整个模板中的位置 信息，content 里面包含的是插值内部的信息，即真正的表达式结构信息。\n  {type: 2, content: \u0026#34; text\u0026#34;, loc: {…}}\n 和第一步中一样，只会经过 parseText(context, mode) 解析出纯文本内容：\u0026#34; text\u0026#34;，最后的结构：\n1 2 3 4 5 6 7 8 9 10  { type: 2, content: \u0026#34; text\u0026#34;, loc: { // 从 text 前面的空格开始记录，\u0026#34;some {{ foo + bar }}\u0026#34; 长度为 20 start: { column: 21, line: 1, offset: 20 }, source: \u0026#34; text\u0026#34;, end: { column: 26, line: 1, offset: 25} } }      三步分析完之后，到现在我们应该具备脱离代码就可以直接根据模板得到解析后对应的 children 结构。分析的重点是要得到一个 { type, content, loc: { start, source, end }} 结构的对象。\n1 2 3 4 5 6  // start/end: { column/*该节点起始结束的列，从 1 开始计数的值*/, line/*该节点模板所在的行，从 1 开始计数的值*/, offset/*该节点起始结束的索引，从 0 开始计数的值*/ }    PS: 对于 foo 和 bar 变量数据解析执行结果这块暂时不讨论，也不知道如何做到的，现阶段只关心模板的解析。   parseTag(context, type, parent)  阶段一(simple text\u0026lt;\\/div\u0026gt;)    为什么只匹配 \u0026lt;/div 而忽略掉最后一个 \u0026gt;??? 参数:\n1 2 3 4 5  function parseTag( context: ParserContext, // 要继续解析的模板对象 simple text\u0026lt;/div\u0026gt; 里面的 \u0026lt;/div\u0026gt;  type: TagType, // Start(\u0026lt;div\u0026gt;), End(\u0026lt;/div\u0026gt;)开始结束标签  parent: ElementNode | undefined // 该标签的父级  ): ElementNode     具体实现：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  function parseTag(context, type, parent) { // 获取当前解析的起始位置，此时值应该是 simple text 的长度  const start = getCursor(context); // 匹配 \u0026lt;/div 过滤掉空格字符，但是为什么要把 \u0026gt; 给忽略掉???  const match = /^\u0026lt;\\/?([a-z][^\\t\\r\\n\\f /\u0026gt;]*)/i.exec(context.source); const tag = match[1]; const ns = context.options.getNamespace(tag, parent); // 改变位移，将 offset 定位到 \u0026lt;/div\u0026gt; 的最有一个 \u0026gt; 上  advanceBy(context, match[0].length); // 过滤掉空格  advanceSpaces(context); const cursor = getCursor(context); const currSource = context.source; }        阶段二(test-text-05)   满足用例 5(some \u0026lt;span\u0026gt;{{ foo \u0026lt; bar + foo }} text\u0026lt;/span\u0026gt;) 的代码实现，这里只需 要能解析 \u0026lt;span\u0026gt; ... \u0026lt;/span\u0026gt; 标签就可以，没有 pre, v-pre, \u0026lt;span/\u0026gt;自闭合标 签 ，因此下面省略这几部分检测代码。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61  function parseTag(context, type, parent) { // 获取当前解析的起始位置，此时值应该是 some text 的长度  const start = getCursor(context) // 匹配 \u0026lt;/div 过滤掉空格字符，但是为什么要把 \u0026gt; 给忽略掉???  const match = /^\u0026lt;\\/?([a-z][^\\t\\r\\n\\f /\u0026gt;]*)/i.exec(context.source) const tag = match[1] const ns = context.options.getNamespace(tag, parent) // log1: 改变位移，将 offset 定位到 \u0026lt;/div\u0026gt; 的最有一个 \u0026gt; 上  // 在这里 context.offset = 10, context.line = 1  advanceBy(context, match[0].length) // 过滤掉空格  advanceSpaces(context) // log2: 经过 advance之后 context.offset = 15, context.line = 1  // 正好过滤 \u0026lt;/div 5个字符  const cursor = getCursor(context) const currSource = context.source // TODO-1 解析标签元素的属性  // TODO-2 in pre ...  // TODO-3 v-pre 指令  // TODO-3 \u0026lt;div/\u0026gt; 自闭标签  // 这里要实现，不然最后解析完成之后 source 会是：\u0026gt;...\u0026lt;/span\u0026gt;  // 需要检测下是不是自闭合标签来移动指针位置  let isSelfClosing = false if (context.source.length === 0) { emitError(context, ErrorCodes.EOF_IN_TAG) } else { // some \u0026lt;div\u0026gt; ... \u0026lt;/div\u0026gt; 到这里的 source = \u0026gt; ... \u0026lt;/div\u0026gt;  // 所以可以检测是不是以 /\u0026gt; 开头的  isSelfClosing = context.source.startsWith(\u0026#39;/\u0026gt;\u0026#39;) if (type === TagType.End \u0026amp;\u0026amp; isSelfClosing) { emitError(context, ErrorCodes.END_TAG_WITH_TRAILING_SOLIDUS) } // 如果是自闭合指针移动两位(/\u0026gt;)，否则只移动一位(\u0026gt;)  // 到这里 source = ... \u0026lt;/div\u0026gt;  advanceBy(context, isSelfClosing ? 2 : 1) } let tagType = ElementTypes.ELEMENT const options = context.options // 不是 v-pre，且不是自定义组件，这个 if 目的是为了检测并改变  // tagType 标签类型  if (!context.inVPre \u0026amp;\u0026amp; !options.isCustomElement(tag)) { // TODO-4 检测 tagType  } return { type: NodeTypes.ELEMENT, ns, tag, tagType, props, isSelfClosing: false, // TODO  children: [], loc: getSelection(context, start), codegenNode: undefined } }     要能通过用例5必须搭配 parseElement(context, ancestors) 才行，并且重点在 parseElement 中，因为有了开始标签才会有结束标签的解析，不然会触发结束标签解析分 支里面的 error:\n1 2 3 4 5 6  else if (/[a-z]/i.test(s[2])) { // 这里都出错了，为啥后面还有个 parseTag ???  emitError(context, ErrorCodes.X_INVALID_END_TAG) parseTag(context, TagType.End, parent) continue }     因此如果这里不会触发 X_INVALID_END_TAG 那必定是 parseElement 里面做了什么处理， 这个实现了 parseElement 才得以知晓(目前只是猜测~~~)，传送门🚪\u0026gt;\u0026gt;\u0026gt;\n  阶段三(test-element-03)   支持自闭标签解析，实现了阶段二之后，这里其实很简单，在上一阶段中的实现在 parseTag 中返回的时候 isSelfClosing 写死成了 false ，要支持这个用例，只要将 它的值赋值为实际的 isSelfClosing 就可以了。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18  parseTag() { // ...  let isSelfClosing = false if (context.source.length === 0) { emitError(context, ErrorCodes.EOF_IN_TAG) } else { // some \u0026lt;div\u0026gt; ... \u0026lt;/div\u0026gt; 到这里的 source = \u0026gt; ... \u0026lt;/div\u0026gt;  // 所以可以检测是不是以 /\u0026gt; 开头的  isSelfClosing = context.source.startsWith(\u0026#39;/\u0026gt;\u0026#39;) if (type === TagType.End \u0026amp;\u0026amp; isSelfClosing) { emitError(context, ErrorCodes.END_TAG_WITH_TRAILING_SOLIDUS) } // 如果是自闭合指针移动两位(/\u0026gt;)，否则只移动一位(\u0026gt;)  // 到这里 source = ... \u0026lt;/div\u0026gt;  advanceBy(context, isSelfClosing ? 2 : 1) } // ...  }      阶段四(支持 template + v-if)  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81  function parseTag(context, type, parent) { // 获取当前解析的起始位置，此时值应该是 some text 的长度  const start = getCursor(context) // 匹配 \u0026lt;div 或 \u0026lt;/div 过滤掉空格字符，但是为什么要把 \u0026gt; 给忽略掉???  // 其实不是忽略掉 \u0026gt; 而是因为如果是 \u0026lt;div 开头，那么后面有可能是 \u0026lt; 或  // /\u0026gt; 后面需要处理闭合和非闭合问题  const match = /^\u0026lt;\\/?([a-z][^\\t\\r\\n\\f /\u0026gt;]*)/i.exec(context.source) const tag = match[1] const ns = context.options.getNamespace(tag, parent) // log1: 改变位移，将 offset 定位到 \u0026lt;/div\u0026gt; 的最有一个 \u0026gt; 上  // 在这里 context.offset = 10, context.line = 1  advanceBy(context, match[0].length) // 过滤掉空格  advanceSpaces(context) // log2: 经过 advance 之后 context.offset = 15, context.line = 1  // 正好过滤 \u0026lt;/div 5 个字符  const cursor = getCursor(context) const currSource = context.source // 解析标签元素的属性  let props = parseAttributes(context, type) // TODO-2 in pre ...  // TODO-3 v-pre 指令  // ....  let tagType = ElementTypes.ELEMENT const options = context.options // 不是 v-pre，且不是自定义组件，这个 if 目的是为了检测并改变  // tagType 标签类型  // TODO-4 检测 tagType  if (!context.inVPre \u0026amp;\u0026amp; !options.isCustomElement(tag)) { // 是否有 is 指令？  const hasVIs = props.some( (p) =\u0026gt; p.type === NodeTypes.DIRECTIVE \u0026amp;\u0026amp; p.name === \u0026#39;is\u0026#39; ) if (options.isNativeTag \u0026amp;\u0026amp; !hasVIs) { // 没有 is 指令，且不是原生标签，那就是自定义的组件了  if (!options.isNativeTag(tag)) tagType = ElementTypes.COMPONENT } else if ( hasVIs || isCoreComponent(tag) || options.isBuiltInComponent?.(tag) || /^[A-Z]/.test(tag) || tag === \u0026#39;component\u0026#39; ) { // 有 is 指令 || vue 核心组件(keep-alive...) || 内置组件  // || 标签名大写开头  tagType === ElementTypes.COMPONENT } if (tag === \u0026#39;slot\u0026#39;) { tagType === ElementTypes.SLOT } else if ( tag === \u0026#39;template\u0026#39; \u0026amp;\u0026amp; props.some( (p) =\u0026gt; p.type === NodeTypes.DIRECTIVE \u0026amp;\u0026amp; isSpecialTemplateDirective(p.name) ) ) { // 是模板的前提是有指令，并且是特殊的模板指令  tagType = ElementTypes.TEMPLATE } } const val = { type: NodeTypes.ELEMENT, ns, tag, tagType, props: [], // TODO  isSelfClosing, children: [], loc: getSelection(context, start), codegenNode: undefined } return val }     这里的实现涉及到几个新的函数：\n  options.isCustomElement(tag) 默认在 options 里面是 NO\n  options.isNativeTag(tag) 作为可选 OptionalOptions 选项类型，并没默认值\n  isCoreComponent(tag) vue 内部作为核心组件的标签\n1 2 3 4 5 6  { // 主要就这四个 Teleport: TELEPORT, Suspense: SUSPENSE, KeepAlive: KEEP_ALIVE, BaseTransition: BASE_TRANSITION }      options.isBuiltInComponent?.(tag) 和 isNativeTag 一样作为可选选项，无默认值\n  isSpecialTemplateDirective(p.name) 特殊的模板指令\n1 2 3  const isSpecialTemplateDirective = /*#__PURE__*/ makeMap( `if,else,else-if,for,slot` )     从上面的代码可以看出，如果要被定义为是 \u0026lt;template\u0026gt; 类型必须包含 if,else,else-if,for,slot 这其中的任一个指令属性，判断条件：\n1 2 3 4 5 6 7 8 9 10 11 12  if ( tag === \u0026#39;template\u0026#39; \u0026amp;\u0026amp; props.some( (p) =\u0026gt; // isSpecialTemplateDirective 是使用 makeMap 创建的函数  // 即 key =\u0026gt; true/false 的一些函数  p.type === NodeTypes.DIRECTIVE \u0026amp;\u0026amp; isSpecialTemplateDirective(p.name) ) ) { // 是模板的前提是有指令，并且是特殊的模板指令(if, else, else-if, slot, for)  tagType = ElementTypes.TEMPLATE }        阶段五(\u0026lt;div …\u0026gt;\u0026lt;/div\u0026gt;\\n\u0026lt;div …\u0026gt;\u0026lt;/div\u0026gt;)     parseText(context, mode)   解析文本节点，直到遇到结束标记(\u0026lt;, {{, ]]\u0026gt;)。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29  function parseText(context: ParserContext, mode: TextModes): TextNode { __TEST__ \u0026amp;\u0026amp; assert(context.source.length \u0026gt; 0) const endTokens = [\u0026#39;\u0026lt;\u0026#39;, context.options.delimiters[0]] if (mode === TextModes.CDATA) { endTokens.push(\u0026#39;]]\u0026gt;\u0026#39;) } let endIndex = context.source.length for (let i = 0; i \u0026lt; endTokens.length; i++) { const index = context.source.indexOf(endTokens[i], 1) if (index !== -1 \u0026amp;\u0026amp; endIndex \u0026gt; index) { endIndex = index } } __TEST__ \u0026amp;\u0026amp; assert(endIndex \u0026gt; 0) const start = getCursor(context) // 文本内容可能包含 \u0026amp;gt; \u0026amp;lt; \u0026amp;amp; \u0026amp;apos; \u0026amp;quot; 等html符号，需要  // 将他们替换成对应 \u0026gt; \u0026lt; \u0026amp; \u0026#39; \u0026#34;  const content = parseTextData(context, endIndex, mode) return { type: NodeTypes.TEXT, content, loc: getSelection(context, start) } }     导图：\n   parseTextData(context, length, mode)   文本节点可能包含数据，通过 context.options.decodeEntities(???) 来解析。\n 一些字符的 html 书写格式，有 /\u0026amp;(gt|lt|amp|apos|quot);/ ，最终会被对应的字符替换掉。\n decodeEntities: (rawText: string): string =\u0026gt; rawText.replace(decodeRE, (_, p1) =\u0026gt; decodeMap[p1])\n 字符集：\n1 2 3 4 5 6 7  const decodeMap: Record\u0026lt;string, string\u0026gt; = { gt: \u0026#39;\u0026gt;\u0026#39;, lt: \u0026#39;\u0026lt;\u0026#39;, amp: \u0026#39;\u0026amp;\u0026#39;, apos: \u0026#34;\u0026#39;\u0026#34;, quot: \u0026#39;\u0026#34;\u0026#39; }     代码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26  /** ,* Get text data with a given length from the current location. ,* This translates HTML entities in the text data. ,*/ function parseTextData( context: ParserContext, length: number, mode: TextModes ): string { const rawText = context.source.slice(0, length) advanceBy(context, length) if ( mode === TextModes.RAWTEXT || mode === TextModes.CDATA || rawText.indexOf(\u0026#39;\u0026amp;\u0026#39;) === -1 ) { return rawText // 如果不包含 \u0026amp;gt; \u0026amp;lt; 等html标记  } else { // DATA or RCDATA containing \u0026#34;\u0026amp;\u0026#34;\u0026#34;. Entity decoding required.  // 如果字符串中包含这些字符，得去将他们替换成对应的明文字符。  return context.options.decodeEntities( rawText, mode === TextModes.ATTRIBUTE_VALUE ) } }     导图：   parseAttributes(context, type)   这里定义 props[] 数组，真正解析单个属性的在 parseAttribute 中，解析之后的单个 属性解构保存到数组中，返回给当前组件作为 props 属性字段存在：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38  // 解析标签所有属性  function parseAttributes(context, type) { const props = []; const attributeNames = new Set(); while ( context.source.length \u0026gt; 0 \u0026amp;\u0026amp; !context.source.startsWith(\u0026#34;\u0026gt;\u0026#34;) \u0026amp;\u0026amp; !context.source.startsWith(\u0026#34;/\u0026gt;\u0026#34;) ) { // 非法属性， \u0026lt;div /v-if=\u0026#34;ok\u0026#34;\u0026gt;\u0026lt;/div\u0026gt;??  if (context.source.startsWith(\u0026#34;/\u0026#34;)) { emitError(context, ErrorCodes.UNEXPECTED_SOLIDUS_IN_TAG); advanceBy(context, 1); advanceSpaces(context); continue; } // \u0026lt;/div\u0026gt; 结束标签，以属性结束的标签?  if (type === TagType.End) { emitError(context, ErrorCodes.END_TAG_WITH_ATTRIBUTES); } // 逐个解析属性  const attr = parseAttribute(context, attributeNames); if (type === TagType.Start) { props.push(attr); } if (/^[^\\t\\r\\n\\f /\u0026gt;]/.test(context.source)) { emitError(context, ErrorCodes.MISSING_WHITESPACE_BETWEEN_ATTRIBUTES); } advanceSpaces(context); } return props; }      parseAttribute(context, nameSet)   解析标签属性或指令：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140  function parseAttribute(context, nameSet) { const start = getCursor(context) const match = /^[^\\t\\r\\n\\f /\u0026gt;][^\\t\\r\\n\\f /\u0026gt;=]*/.exec(context.source) const name = match[0] if (nameSet.has(name)) { // 重复属性名  emitError(context, ErrorCodes.DUPLICATE_ATTRIBUTE) } nameSet.add(name) if (name[0] === \u0026#39;=\u0026#39;) { // =name=value ?  emitError(context, ErrorCodes.UNEXPECTED_EQUALS_SIGN_BEFORE_ATTRIBUTE_NAME) } { const pattern = /[\u0026#34;\u0026#39;\u0026lt;]/g let m while ((m = pater.exec(name))) { // 不合法的属性名  emitError( context, ErrorCodes.UNEXPECTED_CHARACTER_IN_ATTRIBUTE_NAME, m.index ) } } // 移动指针  advanceBy(context, name.length) // type: { content, isQuoted, loc }  let value // 去空格解析属性值  if (/^[\\t\\r\\n\\f ]*=/.test(context.source)) { // 属性名与 = 之间存在空格的情况，去掉空格  advanceSpaces(context) advanceBy(context, 1) advanceSpaces(context) // 去掉空格之后解析属性值  value = parseAttributeValue(context) if (!value) { emitError(context, ErrorCodes.MISSING_ATTRIBUTE_VALUE) } } const loc = getSelection(context, start) // v-dir 或 缩写  if (!context.inVPre \u0026amp;\u0026amp; /^(v-|:|@|#)/.test(name)) { // ?: 非捕获组  // 1. (?:^v-([a-z0-9]+))? -\u0026gt; 匹配 v-dir 指令，非贪婪匹配，捕获指令名  // 称([a-z0=9]+)  // 2. (?:(?::|^@|^#)([^\\.]+))? -\u0026gt; 匹配 :,@,#  // 3. (.+)?$ 匹配任意字符  const match = /(?:^v-([a-z0-9]+))?(?:(?::|^@|^#)([^\\.]+))?(.+)?$/i.exec( name ) let arg // ([a-z0-9]+), ([^\\.]+)  if (match[2]) { const startOffset = name.indexOf(match[2]) const loc = getSelection( context, getNewPosition(context, start, startOffset), getNewPosition(context, start, startOffset + match[2].length) ) let content = match[2] let isStatic = true // 静态属性名  // 动态属性名解析  if (content.startsWith(\u0026#39;[\u0026#39;)) { isStatic = false if (!content.endsWith(\u0026#39;]\u0026#39;)) { // 如果是动态属性名，必须是 [varName] 形式  emitError( context, ErrorCodes.X_MISSING_DYNAMIC_DIRECTIVE_ARGUMENT_END ) } content = content.substr(1, content.length - 2) } arg = { type: NodeTypes.SIMPLE_EXPRESSION, content, isStatic, isConstant: isStatic, loc } } // 属性是否被引号包起来  if (value \u0026amp;\u0026amp; value.isQuoted) { const valueLoc = value.loc valueLoc.start.offset++ valueLoc.start.column++ valueLoc.end = advancePositionWithClone(valueLoc.start, value.content) // 取引号内的所有内容  valueLoc.source = valueLoc.source.slice(1, -1) } return { type: NodeTypes.DIRECTIVE, // : -\u0026gt; v-bind, @ -\u0026gt; v-on, # -\u0026gt; v-slot 的缩写  name: match[1] || (name.startsWith(\u0026#39;:\u0026#39;) ? \u0026#39;bind\u0026#39; : name.startsWith(\u0026#39;@\u0026#39;) ? \u0026#39;on\u0026#39; : \u0026#39;slot\u0026#39;), exp: value \u0026amp;\u0026amp; { type: NodeTypes.SIMPLE_EXPRESSION, content: value.content, isStatic: false, isConstant: false, loc: value.loc }, arg, // 修饰符处理, v-bind.m1.m2 -\u0026gt; .m1.m2 -\u0026gt; [\u0026#39;m1\u0026#39;, \u0026#39;m2\u0026#39;]  modifiers: match[3] ? match[3].substr[1].split(\u0026#39;.\u0026#39;) : [], loc } } return { type: NodeTypes.ATTRIBUTE, name, value: value \u0026amp;\u0026amp; { type: NodeTypes.TEXT, content: value.content, loc: value.loc }, loc } }     该函数实现主要有几部分(以 \u0026lt;div v-bind:keyup.enter.prevent=\u0026#34;ok\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; 为例)：\n  匹配属性名，关键正则： /^[^\\t\\r\\n\\f /\u0026gt;][^\\t\\r\\n\\f /\u0026gt;=]*/ 会将 v-if=\u0026#34;varname\u0026#34; 中等号前面的 v-bind:keyup.enter.prevent 都匹配出来。\n  将匹配到的属性名收集到 nameSet[] 中，检测重复性。\n 这里需要注意的是，属性名匹配的结果会将变量名， 修饰符都匹配到，如： \u0026lt;div v-bind:keyup.enter.prevent=\u0026#34;ok\u0026#34;\u0026gt; ，最后 add 到 nameSet 中的完整属性名为： v-bind:keyup.enter.prevent 。 \n  非法属性名检测(如： =name=value ，或属性名中包含 [\u0026#34;\u0026#39;\u0026lt;] 字符)，异常\n  移动指针 advanceBy(context, name.length) 定位到属性名后的位置，目的是为了取 属性值，剩下： =\u0026#34;ok\u0026#34; 。\n  正则： /^[\\t\\r\\n\\f ]*=/ ，解析属性值，调用 parseAttributeValue 解析出属性值来\n  指针归位至开始位置，如： v-bind:keyup.enter.prevent=\u0026#34;ok\u0026#34; 的开始位置为 v 位置，解析修饰符，得到 modifiers: [] ，这里的关键在于正 则： /(?:^v-([a-z0-9]+))?(?:(?::|^@|^#)([^\\.]+))?(.+)?$/i ，会匹配 v-if, :, @, #... 指令和指令缩写以及修饰符。\n  解析指令后面的变量名称，如： keyup ，有可能是动态值 v-bind:[varname] 。\n  检测属性值有没被引号包起来，如果有，要更新 value.loc ，只取引号内的内容 content.source = valueLoc.source.slice(1, -1)\n  返回指令节点类型对象\n    否则返回普通属性类型节点\n    parseAttributeValue(context)   解析属性值。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47  function parseAttributeValue(context) { // 保存模板字符串指针起点位置  const start = getCursor(context) let content const quote = context.source[0] const isQuoted = quote === `\u0026#34;` || quote === `\u0026#39;` if (isQuoted) { // 有引号  advanceBy(context, 1) const endIndex = context.source.indexOf(quote) // 没有结束引号??? 整个 source 当做文本数据处理???  if ((endIndex = -1)) { content = parseTextData( context, context.source.length, TextModes.ATTRIBUTE_VALUE ) } else { content = parseTextData(context, endIndex, TextModes.ATTRIBUTE_VALUE) advanceBy(context, 1) } } else { // 没有引号  const match = /^[^\\t\\r\\n\\f \u0026gt;]+/.exec(context.source) if (!match) { // 无属性值  return undefined } const unexpectedChars = /[\u0026#34;\u0026#39;\u0026lt;=`]/g let m while ((m = unexpectedChars.exec(match[0]))) { // 无引号值中非法字符检测  emitError( context, ErrorCodes.UNEXPECTED_CHARACTER_IN_UNQUOTED_ATTRIBUTE_VALUE ) } // 解析文本数据  content = parseTextData(context, match[0].length, TextModes.ATTRIBUTE_VALUE) } return { content, isQuoted, loc: getSelection(context, start) } }      DONE parseCDATA(context, ancestors)  CLOSED: [2020-09-02 Wed 23:14]\n  State \u0026#34;DONE\u0026#34; from \u0026#34;TODO\u0026#34; [2020-09-02 Wed 23:14]\n  解析 \u0026lt;![CDATA[....]] xml 类型注释。\n1 2 3 4 5 6 7 8 9 10 11 12  // \u0026lt;![CDATA[...  function parseCDATA(context, ancestors) { advanceBy(context, 9); // `\u0026lt;![CDATA[`.length = 9  const nodes = parseChildren(context, TextModes.CDATA, ancestors); if (context.source.length === 0) { emitError(context, ErrorCodes.EOF_IN_CDATA); } else { advanceBy(context, 3); } return nodes; }      DONE parseBogusComment(context)  CLOSED: [2020-09-02 Wed 23:11]\n  State \u0026#34;DONE\u0026#34; from \u0026#34;TODO\u0026#34; [2020-09-02 Wed 23:11]\n  解析一些注释性的结构，如： \u0026lt;!DOCTYPE 。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25  function parseBogusComment(context) { const start = getCursor(context); const contentStart = context.source[1] === \u0026#34;?\u0026#34; ? 1 : 2; let content; const closeIndex = context.source.indexOf(\u0026#34;\u0026gt;\u0026#34;); if (closeIndex === -1) { // 没有结束索引，后面所有的都将成为注释  content = context.source.slice(contentStart); advanceBy(context, context.source.length); } else { content = context.source.slice(contentStart, closeIndex); // 定位到注释后面的字符  advanceBy(context, closeIndex + 1); } return { type: NodeTypes.COMMENT, content, loc: getSelection(context, start), }; }      pushNode(nodes, node)    注释节点不处理\n  合并文本节点(前提是 prev, node 两个节点是紧挨着的，由 loc.end.offset 和 loc.start.offset 判断)\n  返回新增 node 的 nodes 节点数组\n  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25  function pushNode(nodes: TemplateChildNode[], node: TemplateChildNode): void { // ignore comments in production  /* istanbul ignore next */ if (!__DEV__ \u0026amp;\u0026amp; node.type === NodeTypes.COMMENT) { return } if (node.type === NodeTypes.TEXT) { // 两个连着的文本节点，拼凑到一起去  const prev = last(nodes) // Merge if both this and the previous node are text and those are  // consecutive. This happens for cases like \u0026#34;a \u0026lt; b\u0026#34;.  if ( prev \u0026amp;\u0026amp; prev.type === NodeTypes.TEXT \u0026amp;\u0026amp; prev.loc.end.offset === node.loc.start.offset ) { prev.content += node.content prev.loc.end = node.loc.end prev.loc.source += node.loc.source return } } nodes.push(node) }      isEnd(context, mode, ancestors)  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37  function isEnd( context: ParserContext, mode: TextModes, ancestors: ElementNode[] ): boolean { const s = context.source switch (mode) { case TextModes.DATA: if (startsWith(s, \u0026#39;\u0026lt;/\u0026#39;)) { //TODO: probably bad performance  for (let i = ancestors.length - 1; i \u0026gt;= 0; --i) { if (startsWithEndTagOpen(s, ancestors[i].tag)) { return true } } } break case TextModes.RCDATA: case TextModes.RAWTEXT: { const parent = last(ancestors) if (parent \u0026amp;\u0026amp; startsWithEndTagOpen(s, parent.tag)) { return true } break } case TextModes.CDATA: if (startsWith(s, \u0026#39;]]\u0026gt;\u0026#39;)) { return true } break } return !s }      getCursor(context)  1 2 3 4  function getCursor(context: ParserContext): Position { const { column, line, offset } = context return { column, line, offset } }      getSelection(context, start, end?: Postion)   取实时解析后的 source，start，end 的值。\n1 2 3 4 5 6 7 8 9 10 11 12  function getSelection( context: ParserContext, start: Position, end?: Position ): SourceLocation { end = end || getCursor(context) return { start, end, source: context.originalSource.slice(start.offset, end.offset) } }        重要类型声明   该模块所有类型声明统一归类到此，顺序按照用例解析遇到的顺序为主。\ndefaultParserOptions  1 2 3 4 5 6 7 8 9 10 11 12 13  // 默认的解析器选项  export const defaultParserOptions: MergedParserOptions = { delimiters: [`{{`, `}}`], getNamespace: () =\u0026gt; Namespaces.HTML, // 命名空间  getTextMode: () =\u0026gt; TextModes.DATA, // 文本类型  isVoidTag: NO, // 自关闭标签???，如：\u0026lt;img\u0026gt;, \u0026lt;hr\u0026gt; ...  isPreTag: NO, // \u0026lt;pre\u0026gt; 代码标签???，需要保留空格保证缩进的  isCustomElement: NO, // 自定义标签，如：Transition  decodeEntities: (rawText: string): string =\u0026gt; // 解码实例，一些特殊符号表示，如：\u0026amp;gt;, \u0026amp;lt;, \u0026amp;amp;, \u0026amp;apos; \u0026amp;quot;  rawText.replace(decodeRE, (_, p1) =\u0026gt; decodeMap[p1]), onError: defaultOnError }      TextModes  1 2 3 4 5 6 7 8  export const enum TextModes { // | Elements | Entities | End sign | Inside of  DATA, // | ✔ | ✔ | End tags of ancestors |  RCDATA, // | ✘ | ✔ | End tag of the parent | \u0026lt;textarea\u0026gt;  RAWTEXT, // | ✘ | ✘ | End tag of the parent | \u0026lt;style\u0026gt;,\u0026lt;script\u0026gt;  CDATA, ATTRIBUTE_VALUE }      ParserOptions   定义位置：\nsrc/options.ts  接口内容：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42  export interface ParserOptions { /** ,* e.g. platform native elements, e.g. \u0026lt;div\u0026gt; for browsers ,*/ isNativeTag?: (tag: string) =\u0026gt; boolean /** ,* e.g. native elements that can self-close, e.g. \u0026lt;img\u0026gt;, \u0026lt;br\u0026gt;, \u0026lt;hr\u0026gt; ,*/ isVoidTag?: (tag: string) =\u0026gt; boolean /** ,* e.g. elements that should preserve whitespace inside, e.g. \u0026lt;pre\u0026gt; ,*/ isPreTag?: (tag: string) =\u0026gt; boolean /** ,* Platform-specific built-in components e.g. \u0026lt;Transition\u0026gt; ,*/ isBuiltInComponent?: (tag: string) =\u0026gt; symbol | void /** ,* Separate option for end users to extend the native elements list ,*/ isCustomElement?: (tag: string) =\u0026gt; boolean /** ,* Get tag namespace ,*/ getNamespace?: (tag: string, parent: ElementNode | undefined) =\u0026gt; Namespace /** ,* Get text parsing mode for this element ,*/ getTextMode?: ( node: ElementNode, parent: ElementNode | undefined ) =\u0026gt; TextModes /** ,* @default [\u0026#39;{{\u0026#39;, \u0026#39;}}\u0026#39;] ,*/ delimiters?: [string, string] /** ,* Only needed for DOM compilers ,*/ decodeEntities?: (rawText: string, asAttr: boolean) =\u0026gt; string onError?: (error: CompilerError) =\u0026gt; void }     字段说明：\n  isNativeTag?: (tag: string) =\u0026gt; boolean 一个函数，判断标签是否是原生标签(如：li, div)\n  isVoidTag?: (tag: string) =\u0026gt; boolean,自关闭标签，如：img, br, hr\n  isPreTag?: (tag: string) =\u0026gt; boolean ，代码标签，需要空格缩进的，如：pre\n  isBuiltInComponent?: (tag: string) =\u0026gt; symbol | void ，平台相关的内置组件，如：Transition\n  isCoustomElement?: (tag: string) =\u0026gt; boolean ，用户自定的标签\n  getNamespace?: (tag: string, parent: ElementNode | undefined) =\u0026gt; N⁄amespace ，获取标签命名空间\n  getTextMode?: (node: ElementNode, parent: ElementNode|undefined) =\u0026gt; TextModes 获取文本解析模式\n  delimiters?: [string, string] ，插值分隔符，默认： [\u0026#39;{{\u0026#39;, \u0026#39;}}\u0026#39;]\n  decodeEntities?: (rawText: string, asAttr: boolean) =\u0026gt; string ，仅用于 DOM compilers\n  onError?: (error: CompilerError) =\u0026gt; void\n    ParserContext   定义位置：\nsrc/parse.ts  接口内容：\n1 2 3 4 5 6 7 8 9 10  export interface ParserContext { options: MergedParserOptions // 解析器选项，即合并之后的参数对象  readonly originalSource: string // 最初的源码，即解析之前的最原始的字符串，只读版本  source: string // 解析中的源码字符串，会发生变化的字符串  offset: number // 解析的指针位置，类似文件读取是的指针偏移量  line: number // 解析位置在源码中的当前行  column: number // 解析位置在源码中的当前列  inPre: boolean // 标识是不是 \u0026lt;pre\u0026gt; 标签，如果是需要保留空格保证缩进  inVPre: boolean // v-pre 指令，不处理指令和插值(v-xxx, {{...}})  }        utils.ts  advancePositionWithMutation(pos,source, numberOfCharacters)   更新 context 的 line，column，offset 的值\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25  // advance by mutation without cloning (for performance reasons), since this  // gets called a lot in the parser  export function advancePositionWithMutation( pos: Position, source: string, numberOfCharacters: number = source.length ): Position { let linesCount = 0 let lastNewLinePos = -1 for (let i = 0; i \u0026lt; numberOfCharacters; i++) { if (source.charCodeAt(i) === 10 /* newline char code */) { linesCount++ lastNewLinePos = i } } pos.offset += numberOfCharacters pos.line += linesCount pos.column = lastNewLinePos === -1 ? pos.column + numberOfCharacters : numberOfCharacters - lastNewLinePos return pos }        阶段代码记录    text01: some text 的代码备份\n  text02: some text \\\u0026lt;div\u0026gt; 01 代码备份\n  text02: some text \\\u0026lt;div\u0026gt; 02 代码备份\n  text03: some {{ foo + bar }} text 代码备份\n  text04: some {{ a\u0026lt;b \u0026amp;\u0026amp; c\u0026gt;d }} text 代码备份\n  comment: \u0026lt;!–x–\u0026gt;注释解析代码备份\n  test-element-v-pre 代码备份, 支持 v-pre 和 \u0026lt;pre\u0026gt; 标签，以及换行\n   所有用例全部通过：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178  ➜ packages git:(master) ✗ jest compiler-core -u PASS compiler-core/__tests__/parse.spec.js (5.287 s) compiler: parse Text ✓ simple text (8 ms) ✓ simple text with invalid end tag (3 ms) ✓ text with interpolation (2 ms) ✓ text with interpolation which has `\u0026lt;` (1 ms) ✓ text with mix of tags and interpolations (2 ms) ✓ lonly \u0026#34;\u0026lt;\u0026#34; don\u0026#39;t separate nodes ✓ lonly \u0026#34;{{\u0026#34; don\u0026#39;t separate nodes Interpolation ✓ simple interpolation (1 ms) ✓ it can have tag-like notation (1 ms) ✓ it can have tag-like notation (2) (1 ms) ✓ it can have tag-like notation (3) (1 ms) ✓ custom delimiters Comment ✓ empty comment (1 ms) ✓ simple comment (1 ms) ✓ two comments Element ✓ simple div ✓ empty div (1 ms) ✓ self closing (1 ms) ✓ void element ✓ template element with directives (2 ms) ✓ template element without directives (1 ms) ✓ native element with `isNativeTag` (1 ms) ✓ native element without `isNativeTag` (1 ms) ✓ v-is with `isNativeTag` (2 ms) ✓ v-is without `isNativeTag` (5 ms) ✓ custom element (1 ms) ✓ attribute with no value (2 ms) ✓ attribute with empty value, double quote (1 ms) ✓ attribute with empty value, single quote (1 ms) ✓ attribute with value, double quote (1 ms) ✓ attribute with value, single quote (1 ms) ✓ attribute with value, unquoted ✓ multiple attributes (2 ms) ✓ directive with no value (1 ms) ✓ directive with value ✓ directive with argument (1 ms) ✓ directive with a modifier (1 ms) ✓ directive with two modifiers ✓ directive with argument and modifiers (1 ms) ✓ v-bind shorthand (1 ms) ✓ v-bind shorthand with modifier (1 ms) ✓ v-on shorthand ✓ v-on shorthand with modifier (1 ms) ✓ v-slot shorthand (1 ms) ✓ v-pre (1 ms) ✓ end tags are case-insensitive. (1 ms) Others ✓ self closing single tag (1 ms) ✓ self closing multiple tag (5 ms) ✓ valid html (5 ms) ✓ invalid html (54 ms) ✓ parse with correct location info (2 ms) decodeEntities option ✓ use the given map (1 ms) whitespace management ✓ should remove whitespaces at start/end inside an element ✓ should remove whitespaces w/ newline between elements ✓ should remove whitespaces adjacent to comments (3 ms) ✓ should remove whitespaces w/ newline between comments and elements (1 ms) ✓ should NOT remove whitespaces w/ newline between interpolations (1 ms) ✓ should NOT remove whitespaces w/o newline between elements (1 ms) ✓ should condense consecutive whitespaces in text (1 ms) Errors ABRUPT_CLOSING_OF_EMPTY_COMMENT ✓ \u0026lt;template\u0026gt;\u0026lt;!--\u0026gt;\u0026lt;/template\u0026gt; (3 ms) ✓ \u0026lt;template\u0026gt;\u0026lt;!---\u0026gt;\u0026lt;/template\u0026gt; (2 ms) ✓ \u0026lt;template\u0026gt;\u0026lt;!----\u0026gt;\u0026lt;/template\u0026gt; (1 ms) CDATA_IN_HTML_CONTENT ✓ \u0026lt;template\u0026gt;\u0026lt;![CDATA[cdata]]\u0026gt;\u0026lt;/template\u0026gt; (2 ms) ✓ \u0026lt;template\u0026gt;\u0026lt;svg\u0026gt;\u0026lt;![CDATA[cdata]]\u0026gt;\u0026lt;/svg\u0026gt;\u0026lt;/template\u0026gt; (1 ms) DUPLICATE_ATTRIBUTE ✓ \u0026lt;template\u0026gt;\u0026lt;div id=\u0026#34;\u0026#34; id=\u0026#34;\u0026#34;\u0026gt;\u0026lt;/div\u0026gt;\u0026lt;/template\u0026gt; (3 ms) END_TAG_WITH_ATTRIBUTES ✓ \u0026lt;template\u0026gt;\u0026lt;div\u0026gt;\u0026lt;/div id=\u0026#34;\u0026#34;\u0026gt;\u0026lt;/template\u0026gt; (1 ms) END_TAG_WITH_TRAILING_SOLIDUS ✓ \u0026lt;template\u0026gt;\u0026lt;div\u0026gt;\u0026lt;/div/\u0026gt;\u0026lt;/template\u0026gt; (2 ms) EOF_BEFORE_TAG_NAME ✓ \u0026lt;template\u0026gt;\u0026lt; (1 ms) ✓ \u0026lt;template\u0026gt;\u0026lt;/ (2 ms) EOF_IN_CDATA ✓ \u0026lt;template\u0026gt;\u0026lt;svg\u0026gt;\u0026lt;![CDATA[cdata (2 ms) ✓ \u0026lt;template\u0026gt;\u0026lt;svg\u0026gt;\u0026lt;![CDATA[ (2 ms) EOF_IN_COMMENT ✓ \u0026lt;template\u0026gt;\u0026lt;!--comment (1 ms) ✓ \u0026lt;template\u0026gt;\u0026lt;!-- (1 ms) ✓ \u0026lt;template\u0026gt;\u0026lt;! (1 ms) ✓ \u0026lt;template\u0026gt;\u0026lt;!- (2 ms) ✓ \u0026lt;template\u0026gt;\u0026lt;!abc (1 ms) EOF_IN_SCRIPT_HTML_COMMENT_LIKE_TEXT ✓ \u0026lt;script\u0026gt;\u0026lt;!--console.log(\u0026#39;hello\u0026#39;) (2 ms) ✓ \u0026lt;script\u0026gt;console.log(\u0026#39;hello\u0026#39;) (3 ms) EOF_IN_TAG ✓ \u0026lt;template\u0026gt;\u0026lt;div (2 ms) ✓ \u0026lt;template\u0026gt;\u0026lt;div (2 ms) ✓ \u0026lt;template\u0026gt;\u0026lt;div id (2 ms) ✓ \u0026lt;template\u0026gt;\u0026lt;div id (1 ms) ✓ \u0026lt;template\u0026gt;\u0026lt;div id = (2 ms) ✓ \u0026lt;template\u0026gt;\u0026lt;div id=\u0026#39;abc (1 ms) ✓ \u0026lt;template\u0026gt;\u0026lt;div id=\u0026#34;abc (2 ms) ✓ \u0026lt;template\u0026gt;\u0026lt;div id=\u0026#39;abc\u0026#39; (2 ms) ✓ \u0026lt;template\u0026gt;\u0026lt;div id=\u0026#34;abc\u0026#34; (4 ms) ✓ \u0026lt;template\u0026gt;\u0026lt;div id=abc (2 ms) ✓ \u0026lt;template\u0026gt;\u0026lt;div id=\u0026#39;abc\u0026#39;/ (3 ms) ✓ \u0026lt;template\u0026gt;\u0026lt;div id=\u0026#34;abc\u0026#34;/ (2 ms) ✓ \u0026lt;template\u0026gt;\u0026lt;div id=abc / (1 ms) INCORRECTLY_CLOSED_COMMENT ✓ \u0026lt;template\u0026gt;\u0026lt;!--comment--!\u0026gt;\u0026lt;/template\u0026gt; (1 ms) INCORRECTLY_OPENED_COMMENT ✓ \u0026lt;template\u0026gt;\u0026lt;!\u0026gt;\u0026lt;/template\u0026gt; (1 ms) ✓ \u0026lt;template\u0026gt;\u0026lt;!-\u0026gt;\u0026lt;/template\u0026gt; (2 ms) ✓ \u0026lt;template\u0026gt;\u0026lt;!ELEMENT br EMPTY\u0026gt;\u0026lt;/template\u0026gt; (3 ms) ✓ \u0026lt;!DOCTYPE html\u0026gt; (2 ms) INVALID_FIRST_CHARACTER_OF_TAG_NAME ✓ \u0026lt;template\u0026gt;a \u0026lt; b\u0026lt;/template\u0026gt; (2 ms) ✓ \u0026lt;template\u0026gt;\u0026lt;�\u0026gt;\u0026lt;/template\u0026gt; (2 ms) ✓ \u0026lt;template\u0026gt;a \u0026lt;/ b\u0026lt;/template\u0026gt; (1 ms) ✓ \u0026lt;template\u0026gt;\u0026lt;/�\u0026gt;\u0026lt;/template\u0026gt; (1 ms) ✓ \u0026lt;template\u0026gt;{{a \u0026lt; b}}\u0026lt;/template\u0026gt; (1 ms) MISSING_ATTRIBUTE_VALUE ✓ \u0026lt;template\u0026gt;\u0026lt;div id=\u0026gt;\u0026lt;/div\u0026gt;\u0026lt;/template\u0026gt; (3 ms) ✓ \u0026lt;template\u0026gt;\u0026lt;div id= \u0026gt;\u0026lt;/div\u0026gt;\u0026lt;/template\u0026gt; (2 ms) ✓ \u0026lt;template\u0026gt;\u0026lt;div id= /\u0026gt;\u0026lt;/div\u0026gt;\u0026lt;/template\u0026gt; (5 ms) MISSING_END_TAG_NAME ✓ \u0026lt;template\u0026gt;\u0026lt;/\u0026gt;\u0026lt;/template\u0026gt; (1 ms) MISSING_WHITESPACE_BETWEEN_ATTRIBUTES ✓ \u0026lt;template\u0026gt;\u0026lt;div id=\u0026#34;foo\u0026#34;class=\u0026#34;bar\u0026#34;\u0026gt;\u0026lt;/div\u0026gt;\u0026lt;/template\u0026gt; (2 ms) ✓ \u0026lt;template\u0026gt;\u0026lt;div id=\u0026#34;foo\u0026#34;\\x0d;\\x0a;class=\u0026#34;bar\u0026#34;\u0026gt;\u0026lt;/div\u0026gt;\u0026lt;/template\u0026gt; (1 ms) NESTED_COMMENT ✓ \u0026lt;template\u0026gt;\u0026lt;!--a\u0026lt;!--b--\u0026gt;\u0026lt;/template\u0026gt; (2 ms) ✓ \u0026lt;template\u0026gt;\u0026lt;!--a\u0026lt;!--b\u0026lt;!--c--\u0026gt;\u0026lt;/template\u0026gt; (1 ms) ✓ \u0026lt;template\u0026gt;\u0026lt;!--a\u0026lt;!--\u0026gt;\u0026lt;/template\u0026gt; (1 ms) ✓ \u0026lt;template\u0026gt;\u0026lt;!--a\u0026lt;!-- (4 ms) UNEXPECTED_CHARACTER_IN_ATTRIBUTE_NAME ✓ \u0026lt;template\u0026gt;\u0026lt;div a\u0026#34;bc=\u0026#39;\u0026#39;\u0026gt;\u0026lt;/div\u0026gt;\u0026lt;/template\u0026gt; (1 ms) ✓ \u0026lt;template\u0026gt;\u0026lt;div a\u0026#39;bc=\u0026#39;\u0026#39;\u0026gt;\u0026lt;/div\u0026gt;\u0026lt;/template\u0026gt; (3 ms) ✓ \u0026lt;template\u0026gt;\u0026lt;div a\u0026lt;bc=\u0026#39;\u0026#39;\u0026gt;\u0026lt;/div\u0026gt;\u0026lt;/template\u0026gt; (3 ms) UNEXPECTED_CHARACTER_IN_UNQUOTED_ATTRIBUTE_VALUE ✓ \u0026lt;template\u0026gt;\u0026lt;div foo=bar\u0026#34;\u0026gt;\u0026lt;/div\u0026gt;\u0026lt;/template\u0026gt; (2 ms) ✓ \u0026lt;template\u0026gt;\u0026lt;div foo=bar\u0026#39;\u0026gt;\u0026lt;/div\u0026gt;\u0026lt;/template\u0026gt; (3 ms) ✓ \u0026lt;template\u0026gt;\u0026lt;div foo=bar\u0026lt;div\u0026gt;\u0026lt;/div\u0026gt;\u0026lt;/template\u0026gt; (2 ms) ✓ \u0026lt;template\u0026gt;\u0026lt;div foo=bar=baz\u0026gt;\u0026lt;/div\u0026gt;\u0026lt;/template\u0026gt; (2 ms) ✓ \u0026lt;template\u0026gt;\u0026lt;div foo=bar`\u0026gt;\u0026lt;/div\u0026gt;\u0026lt;/template\u0026gt; (2 ms) UNEXPECTED_EQUALS_SIGN_BEFORE_ATTRIBUTE_NAME ✓ \u0026lt;template\u0026gt;\u0026lt;div =foo=bar\u0026gt;\u0026lt;/div\u0026gt;\u0026lt;/template\u0026gt; (2 ms) ✓ \u0026lt;template\u0026gt;\u0026lt;div =\u0026gt;\u0026lt;/div\u0026gt;\u0026lt;/template\u0026gt; (1 ms) UNEXPECTED_QUESTION_MARK_INSTEAD_OF_TAG_NAME ✓ \u0026lt;template\u0026gt;\u0026lt;?xml?\u0026gt;\u0026lt;/template\u0026gt; (1 ms) UNEXPECTED_SOLIDUS_IN_TAG ✓ \u0026lt;template\u0026gt;\u0026lt;div a/b\u0026gt;\u0026lt;/div\u0026gt;\u0026lt;/template\u0026gt; (2 ms) X_INVALID_END_TAG ✓ \u0026lt;template\u0026gt;\u0026lt;/div\u0026gt;\u0026lt;/template\u0026gt; ✓ \u0026lt;template\u0026gt;\u0026lt;/div\u0026gt;\u0026lt;/div\u0026gt;\u0026lt;/template\u0026gt; ✓ \u0026lt;template\u0026gt;{{\u0026#39;\u0026lt;/div\u0026gt;\u0026#39;}}\u0026lt;/template\u0026gt; (1 ms) ✓ \u0026lt;textarea\u0026gt;\u0026lt;/div\u0026gt;\u0026lt;/textarea\u0026gt; (1 ms) ✓ \u0026lt;svg\u0026gt;\u0026lt;![CDATA[\u0026lt;/div\u0026gt;]]\u0026gt;\u0026lt;/svg\u0026gt; ✓ \u0026lt;svg\u0026gt;\u0026lt;!--\u0026lt;/div\u0026gt;--\u0026gt;\u0026lt;/svg\u0026gt; X_MISSING_END_TAG ✓ \u0026lt;template\u0026gt;\u0026lt;div\u0026gt;\u0026lt;/template\u0026gt; (1 ms) ✓ \u0026lt;template\u0026gt;\u0026lt;div\u0026gt; (1 ms) X_MISSING_INTERPOLATION_END ✓ {{ foo (1 ms) ✓ {{ (2 ms) ✓ {{}} X_MISSING_DYNAMIC_DIRECTIVE_ARGUMENT_END ✓ \u0026lt;div v-foo:[sef fsef] /\u0026gt; (1 ms) Test Suites: 1 passed, 1 total Tests: 135 passed, 135 total Snapshots: 79 passed, 79 total Time: 6.398 s, estimated 20 s Ran all test suites matching /compiler-core/i.      问题/疑问列表    如何区分内置标签|内置组件|核心组件|自定义组件？🛫\n  为什么 parseTag 解析 \u0026lt;div\u0026gt; 之后只会得 到 \u0026lt;div 而不会将 \u0026gt; 解析进去？🛫 \n答：是因为漏掉实现了一部分代码，自闭合标签的检测，移动指针(2/1位)   如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24  function parseTag(context, type) { // .... 省略  // TODO-3 \u0026lt;div/\u0026gt; 自闭标签  // 这里要实现，不然最后解析完成之后 source 会是：\u0026gt;...\u0026lt;/span\u0026gt;  // 需要检测下是不是自闭合标签来移动指针位置  let isSelfClosing = false if (context.source.length === 0) { emitError(context, ErrorCodes.EOF_IN_TAG) } else { // some \u0026lt;div\u0026gt; ... \u0026lt;/div\u0026gt; 到这里的 source = \u0026gt; ... \u0026lt;/div\u0026gt;  // 所以可以检测是不是以 /\u0026gt; 开头的  isSelfClosing = context.source.startsWith(\u0026#39;/\u0026gt;\u0026#39;) if (type === TagType.End \u0026amp;\u0026amp; isSelfClosing) { emitError(context, ErrorCodes.END_TAG_WITH_TRAILING_SOLIDUS) } // 如果是自闭合指针移动两位(/\u0026gt;)，否则只移动一位(\u0026gt;)  // 到这里 source = ... \u0026lt;/div\u0026gt;  advanceBy(context, isSelfClosing ? 2 : 1) } // ... 省略  }      为什么 parseElement 解析 children 的时候先 ancestors.push(element) 解析之后又 pop() 掉？\n答：要回到这个问题要从 parseChildren 和 parseElement 两个函数结合来看，如下代码分析  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  // 解析流程(用例5)：  // 1. 先 parseChildren(context, mode, ancestors)  // 解析 `some \u0026lt;span\u0026gt;{{ foo \u0026lt; bar + foo }} text\u0026lt;/span\u0026gt;`  // 1) 首先得到的是 `some ` 文本节点  // 2) 检测到 \u0026lt;span\u0026gt; 进入标签解析 parseElement(context, ancestors) 注意这里的 //\tancestors，是由 parseChildren 继承过来的  // 2. 进入 parseElement 解析进程  // 1) 遇到 \u0026lt;span\u0026gt; 解析出标签节点 span  // 2) 在自身函数内检测到标签内还有内容，重新调用 parseChildren(..., ancestors)  // 3) 所以重点来了  // ...  // ...  // ancestors 是 parseChildren 传递过来的，parseElement 里面将  // push 的目的：让子节点有所依赖，知道自己的父级是谁，但好像 parseChildren 里面用到  // parent 也是为了获取命名空间去用了  // pop 的目的：难道是为了不污染 ancestors ???      好像还不是很明确为何要 push-\u0026gt;pop(DONE)。\n 更新：2020-09-02 16:57:35\n 在测试用例 parse-test-other-01 时，嵌套标签解析的时候 ancestors 中保存着多级 嵌套标签的父级(当前被解析的节点的父级)。\n 比如： \u0026lt;div\u0026gt;\u0026lt;span\u0026gt;\\n\u0026lt;/div\u0026gt;\u0026lt;/span\u0026gt; 这个是反例哈，这里只是举例。\nancestors: Array(2) 0: {type: 1, ns: 0, tag: \u0026#34;div\u0026#34;, tagType: 0, props: Array(0), …} 1: {type: 1, ns: 0, tag: \u0026#34;span\u0026#34;, tagType: 0, props: Array(0), …} length: 2   解析顺序： div -\u0026gt; push:ancestors[0] -\u0026gt; span -\u0026gt; push:ancestors[1] -\u0026gt; \\n 解 析完成之后，发现 parent 有内容，那么这个节点解析完之后会被 push 到 span.children~里面去，到这里 span 解析完了，所以要退出当前递归回到 div 的解 析，因此需要将~ancestors.pop() 掉最后一个，这样才能保证 div 的 child 能正确 push 到~div.ancestors~ 中去。\n    ","permalink":"https://www.cheng92.com/vue/vue3-source-code-compiler-core-parse_ts/","tags":["vue,","vue3,","vuenext,","compiler"],"title":"Vue3.0 源码系列（二）编译器核心 - Compiler core 1: parse.ts"},{"categories":["vue"],"contents":"  抽象语法树代码源文件。\n createVNodeCall  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38  export function createVNodeCall( context: TransformContext | null, tag: VNodeCall[\u0026#39;tag\u0026#39;], props?: VNodeCall[\u0026#39;props\u0026#39;], children?: VNodeCall[\u0026#39;children\u0026#39;], patchFlag?: VNodeCall[\u0026#39;patchFlag\u0026#39;], dynamicProps?: VNodeCall[\u0026#39;dynamicProps\u0026#39;], directives?: VNodeCall[\u0026#39;directives\u0026#39;], isBlock: VNodeCall[\u0026#39;isBlock\u0026#39;] = false, isForBlock: VNodeCall[\u0026#39;isForBlock\u0026#39;] = false, loc = locStub ): VNodeCall { if (context) { if (isBlock) { context.helper(OPEN_BLOCK) context.helper(CREATE_BLOCK) } else { context.helper(CREATE_VNODE) } if (directives) { context.helper(WITH_DIRECTIVES) } } return { type: NodeTypes.VNODE_CALL, tag, props, children, patchFlag, dynamicProps, directives, isBlock, isForBlock, loc } }      createRoot(children, loc = locStub)   创建根节点对象，返回一个 RootNode 类型对象。\n 参数：\n  children 节点子孙节点，类型：TemplateChildNode[]​\n1 2 3 4 5 6 7 8 9 10  export type TemplateChildNode = | ElementNode // 节元素点类型  | InterpolationNode // 插值节点  | CompoundExpressionNode // 混合表达式节点  | TextNode // 文本节点  | CommentNode // 注释节点  | IfNode // v-if 节点  | IfBranchNode // v-else, v-else-if 分支节点  | ForNode // v-ofr 节点  | TextCallNode // ???       loc 一个 SourceLoation 类型的结构，默认值为 locStub\n1 2 3 4 5  export const locStub: SourceLocation = { source: \u0026#39;\u0026#39;, start: { line: 1, column: 1, offset: 0 }, end: { line: 1, column: 1, offset: 0 } }      代码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18  export function createRoot( children: TemplateChildNode[], loc = locStub ): RootNode { return { type: NodeTypes.ROOT, children, helpers: [], components: [], directives: [], hoists: [], imports: [], cached: 0, temps: 0, codegenNode: undefined, loc } }      ","permalink":"https://www.cheng92.com/vue/vue3-source-code-compiler-core-ast_ts/","tags":["vue,","vue3,","vuenext,","compiler"],"title":"Vue3.0 源码系列（二）编译器核心 - Compiler core 2: ast.ts"},{"categories":["vue"],"contents":"  window.g_need_fold = 1   该系列文章，均以测试用例通过为基准一步步实现一个 vue3 源码副本(学习)。\n  文字比较长，如果不想看文字可直接转到这里看脑图\n  由于 compile 和 transform 关联性比较强这里将放在一起去完成。 \n准备工作  要完成这一部分，首先要了解它的作用是什么？\n 在 parse.ts 文中我们完成了解析器的部分，作用是将模板解析成 AST 对象。\n 在这里 compile.ts 作用就是将这些 AST 如何翻译成 render 函数。\n 为了更直观的体验 compile 的作用，在 vue 源码里面有一个打包之后的目录：\n /vue-next/packages/vue/dist/vue.global.js\n 然后我们使用第一个测试用例的模板，去编译下看看结果：\n1 2 3 4 5 6 7 8  const source = ` \u0026lt;div id=\u0026#34;foo\u0026#34; :class=\u0026#34;bar.baz\u0026#34;\u0026gt; {{ world.burn() }} \u0026lt;div v-if=\u0026#34;ok\u0026#34;\u0026gt;yes\u0026lt;/div\u0026gt; \u0026lt;template v-else\u0026gt;no\u0026lt;/template\u0026gt; \u0026lt;div v-for=\u0026#34;(value, index) in list\u0026#34;\u0026gt;\u0026lt;span\u0026gt;{{ value + index }}\u0026lt;/span\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; `.trim(),     进行编译(完整示例)：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17  \u0026lt;script src=\u0026#34;./vue.global.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;script\u0026gt; console.log(Vue, \u0026#34;00\u0026#34;); const { compile } = Vue; const result = compile( ` \u0026lt;div id=\u0026#34;foo\u0026#34; :class=\u0026#34;bar.baz\u0026#34;\u0026gt; {{ world.burn() }} \u0026lt;div v-if=\u0026#34;ok\u0026#34;\u0026gt;yes\u0026lt;/div\u0026gt; \u0026lt;template v-else\u0026gt;no\u0026lt;/template\u0026gt; \u0026lt;div v-for=\u0026#34;(value, index) in list\u0026#34;\u0026gt;\u0026lt;span\u0026gt;{{ value + index }}\u0026lt;/span\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; `.trim(), { sourceMap: true, filename: \u0026#34;foo.vue\u0026#34; } ); console.log(result, \u0026#34;xx\u0026#34;); \u0026lt;/script\u0026gt;     运行之后 result 结果：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95  (function anonymous() { const _Vue = Vue; const { createVNode: _createVNode, createCommentVNode: _createCommentVNode, createTextVNode: _createTextVNode, } = _Vue; const _hoisted_1 = { key: 0 }; // 这里 v-if ... else 里面的 \u0026lt;template\u0026gt;no\u0026lt;/template\u0026gt; ？  // 创建文本虚拟节点，这里为什么直接在 render 外就执行了？？？  // 又是怎么做到的？？？  const _hoisted_2 = _createTextVNode(\u0026#34;no\u0026#34;); // 神级函数 \u0026gt;\u0026gt;\u0026gt; render  return function render(_ctx, _cache) { with (_ctx) { const { toDisplayString: _toDisplayString, createVNode: _createVNode, openBlock: _openBlock, createBlock: _createBlock, createCommentVNode: _createCommentVNode, createTextVNode: _createTextVNode, Fragment: _Fragment, renderList: _renderList, } = _Vue; return ( _openBlock(), _createBlock( \u0026#34;div\u0026#34;, { // 解析出来的 div 属性， id 和 class  // parseAttribute 的结果  id: \u0026#34;foo\u0026#34;, // 注意这里是字符串  class: bar.baz, // 这里是变量形式存在，因为用到了 :class 属于指令解析  }, [ // 这里是孩子节点们  // 1. 第一个孩子节点，插值  _createTextVNode( // 插值里面的内容调用转换成文本  _toDisplayString(world.burn()) + \u0026#34; \u0026#34;, 1 /* TEXT */ ), // 2. 第二个孩子节点 v-if...v-else  // v-if 指令，参数是 ok  // 然后这里又是怎么做到 ok ? ... : ...  // 指令解析的时候 v-if 的处理又是怎么做的，transform/vIf ???  // 相邻的下一个节点检测是否是 v-if 指令簇？？？  // 到底真相如何 ???  ok // 创建 div  ? (_openBlock(), _createBlock(\u0026#34;div\u0026#34;, _hoisted_1, \u0026#34;yes\u0026#34;)) // 创建 template  : (_openBlock(), _createBlock( _Fragment, { key: 1 }, // 提前被解析出来的 template -\u0026gt; no 文本节点  // 难道是提前遍历？？？将所有的 template 如果是  // 静态的就先全部创建出来？？？  [_hoisted_2], 64 /* STABLE_FRAGMENT */ )), // 3. 第三个孩子节点，div v-for  (_openBlock(true), _createBlock( _Fragment, null, // 渲染列表  _renderList(list, (value, index) =\u0026gt; { return ( _openBlock(), _createBlock(\u0026#34;div\u0026#34;, null, [ _createVNode( \u0026#34;span\u0026#34;, null, _toDisplayString(value + index), 1 /* TEXT */ ), ]) ); }), 256 /* UNKEYED_FRAGMENT */ )), ], 2 /* CLASS */ ) ); } }; });     诸多的疑问等着去解答！！！\n 但至少有一点很清晰的知道，compile 就是将 AST 编译成 render 函数用的。\n 知道了最终目的，接下来就是漫长的探索之路了 🏃 🏃 🏃\n 构造数据，观察最终生成的 VNode 结构(上面代码执行之后结果返回给 result，其实就 是 render 函数):\n1 2 3 4 5 6 7 8 9 10  result({ list: [1,2,3], ok: true, bar: { baz: \u0026#39;xx\u0026#39; }, world: { burn() {} } })     传递一些参数调用之后结果：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34  {_isVNode: true, type: \u0026#34;div\u0026#34;, props: {…}, key: null, ref: null, …} anchor: null appContext: null // 三个孩子节点  children: Array(3) 0: {_isVNode: true, type: Symbol(Text), props: null, key: null, ref: null, …} 1: {_isVNode: true, type: \u0026#34;div\u0026#34;, props: {…}, key: 0, ref: null, …} 2: {_isVNode: true, type: Symbol(Fragment), props: null, key: null, ref: null, …} length: 3 component: null dirs: null // 三个动态孩子节点  dynamicChildren: Array(3) 0: {_isVNode: true, type: Symbol(Text), props: null, key: null, ref: null, …} 1: {_isVNode: true, type: \u0026#34;div\u0026#34;, props: {…}, key: 0, ref: null, …} 2: {_isVNode: true, type: Symbol(Fragment), props: null, key: null, ref: null, …} length: 3 dynamicProps: null el: null key: null patchFlag: 2 // 属性  props: {id: \u0026#34;foo\u0026#34;, class: \u0026#34;xx\u0026#34;} ref: null scopeId: null shapeFlag: 17 suspense: null target: null targetAnchor: null transition: null // 标签  type: \u0026#34;div\u0026#34; // 标识为虚拟节点  _isVNode: true      compile.spec.ts  由于 compile.spec.ts 原来只有一个用例，相对是比较复杂的，不利于学习。\n 这里将根据 parse.spec.ts 循序渐进的去实现 compile + transform 的功能。\n 下面所有的测试用例均以 vue.global.js 打包之后的文件，运行结果为前提：\n1 2 3 4 5 6 7  const test = `simple text`; const result = compile(test.trim(), { sourceMap: true, filename: \u0026#34;foo.vue\u0026#34;, }); console.log(result, \u0026#34;xx\u0026#34;);     通过修改 test 值来得到真实的 render 函数。\n 完成了 01-simple text 用例之后发现按照 parse.spec.ts 可能不太理想，毕竟 parse 部 分的用例有点多，如果按照那个来这部分也将会很漫长，思考良久应该还是按照 compile.spec.ts 中的用例进行拆分之后右简入难式去通过该用例。\n 完整用例：\n1 2 3 4 5 6 7 8  const source = ` \u0026lt;div id=\u0026#34;foo\u0026#34; :class=\u0026#34;bar.baz\u0026#34;\u0026gt; {{ world.burn() }} \u0026lt;div v-if=\u0026#34;ok\u0026#34;\u0026gt;yes\u0026lt;/div\u0026gt; \u0026lt;template v-else\u0026gt;no\u0026lt;/template\u0026gt; \u0026lt;div v-for=\u0026#34;(value, index) in list\u0026#34;\u0026gt;\u0026lt;span\u0026gt;{{ value + index }}\u0026lt;/span\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; `.trim()    01-simple text   compiled：\n1 2 3 4 5 6 7 8 9  (function anonymous( ) { return function render(_ctx, _cache) { with (_ctx) { return \u0026#34;simple text\u0026#34; } } })     也就是说 \u0026#34;simple text\u0026#34; 最后转变成的 render 函数如上所示。\n 我们的第一步就是如何来实现 compile 和 transform 能得到这样的结果，这将是该模块完 成第一步 🆙 🆙 🆙 🆙 🆙 🆙 🆙 🆙 🆙 🆙\n parse 之后的 ast:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17  {type: 0, children: Array(1), loc: {…}, helpers: Array(0), components: Array(0), …} cached: 0 children: Array(1) 0: content: \u0026#34;simple text\u0026#34; loc: {start: {…}, end: {…}, source: \u0026#34;simple text\u0026#34;} type: 2 length: 1 codegenNode: undefined components: [] directives: [] helpers: [] hoists: [] imports: [] loc: {start: {…}, end: {…}, source: \u0026#34;simple text\u0026#34;} temps: 0 type: 0     在完成 transformText 之后，发现 result.code 是空的，还以为是这里面实现问题的，其 实是 generate 函数还没实现的原因。\n 所有需要支持的函数都完成之后：\n{ast: {…}, code: \u0026#34;function render(_ctx, _cache) {↵ with (_ctx) {↵ return \u0026#34;simple text\u0026#34;}}\u0026#34;, map: \u0026#34;\u0026#34;} ast: {type: 0, children: Array(1), loc: {…}, helpers: Array(0), components: Array(0), …} code: \u0026#34;function render(_ctx, _cache) {↵ with (_ctx) {↵ return \u0026#34;simple text\u0026#34;}}\u0026#34; map: \u0026#34;\u0026#34;   会发现最终的 code 即我们想要的 render 函数，和用 vue.global.js 生成的一致。\n 如果需要将转成函数，这个需要用到 compileToFunction 这个不在我们这个讨论范围，其 实里面也很简单，直接调用 new Function(code) 就行了，来看下：\n1 2 3 4 5 6 7 8 9 10  import { baseCompile as compile } from \u0026#34;../compile.js\u0026#34;; const source = `simple text`.trim(); const result = compile(source, { sourceMap: true, filename: `foo.vue`, }); const render = new Function(result.code); console.log(render, \u0026#34;compiled\u0026#34;);     输出：\nƒ anonymous( ) { function render(_ctx, _cache) { with (_ctx) { return \u0026#34;simple text\u0026#34;}} } \u0026#34;compiled\u0026#34;   然后会发现结果好像不太对，首先 render 会被一个匿名函数包起来，这个是没问题的，但 是貌似匿名函数没有结束的 } 这个我想问题肯定处在了 generate 里面。\n 其实是因为 createCodgenContext 里面的 函数没有实现，另外这样是不对的，因为 new Function(code) 会将 code 用一个匿名函数来包裹起来，因此想要得到 render 函数，必 须是以 return 形式返回，因此这里还有个遗漏的地方: genFunctionPreamble 需要去实 现，这里面最后会 push 一个 return 到 code 开头。\n 更新后输出：\n1 2 3 4 5 6 7 8 9  ƒ anonymous( ) { return function render(_ctx, _cache) { with (_ctx) { return \u0026#34;simple text\u0026#34; } } }     在实现 genFunctionPreamble 之后，至此完成了一个得到 render 函数的完整过程。\n 下面将使用流程图方式进行回顾，分析整个过程。\n   02-pure interpolation 第一个孩子节点   {{ world.burn() }}\n 测试：\n1 2 3 4 5 6 7  const test01 = `{{ world.burn() }}`; const result = compile(test01.trim(), { sourceMap: true, filename: \u0026#34;foo.vue\u0026#34;, }); console.log(result, \u0026#34;xx\u0026#34;);     vue.global 结果：\n1 2 3 4 5 6 7  ƒ render(_ctx, _cache) { with (_ctx) { const { toDisplayString: _toDisplayString } = _Vue return _toDisplayString(world.burn()) } }     01-simple text 阶段代码返回的结果:\n1 2 3 4 5  ƒ render(_ctx, _cache) { with (_ctx) { return // 这里没任何东西  } }     通过用例 01 大概的完成了一个比较完整的编译过程，要通过该用例应该只需要在这过程中增 加对插值的处理即可。\n 处理步骤(通过用例 01 总结出的步骤)：\n baseCompile -\u0026gt; baseParse -\u0026gt; getBaseTransformPreset 得到 transform 函数 -\u0026gt; transform -\u0026gt; generate\n  baseParse -\u0026gt; ast\n  getBaseTransformPreset -\u0026gt; 这里并没有什么 transformInterpolation，插值并没有 对应的 transform 函数，而是直接在 generate 中结合 ast.helpers 处理。\n  transform -\u0026gt; createTransformContext -\u0026gt; traverseNode -\u0026gt; createRootCodegen -\u0026gt; …\n 这一步需要处理的应该只有 traverseNode 需要修改，在 switch 里增加 INTERPOLATION 分支，因为 createRootCodegen 里面 root 如果只有一个孩子的情况 下会和用例 01 一样直接赋值 context.codegenNode = root.children[0]\n  generate -\u0026gt; createCodegenContext -\u0026gt; genFunctionPreamble 默认是 function 模 式 -\u0026gt; push function render(_ctx, _cache) { -\u0026gt; push with (_ctx) -\u0026gt; … -\u0026gt; genNode(ast.codegenNode, context)\n 这里需要修改的点应该只有 genNode 里面，也是增加 INTERPOLATION switch 分支， 处理插值部分的代码。\n   有了上面的初步分析，这里可以比较明确的知道需要修改的点：\n  DONE traverseNode 中增加 INTERPOLATION 分支\n  DONE genNode 中增加 INTERPOLATION 分支\n  DONE genNode 中增加 SIMPLE_EXPRESSION 分支处理插值内的表达式\n   修正：事实上并没有 transformInterpolation 🤦🤦🤦🤦\n 修改完之后报错：\ntransform.js:184 Uncaught TypeError: Cannot read property \u0026#39;length\u0026#39; of undefined at traverseChildren (transform.js:184) at traverseNode (transform.js:119) at traverseChildren (transform.js:192) at traverseNode (transform.js:119) at transform (transform.js:133) at baseCompile (compile.js:37) at compile.html:12   根据报错定位到，在解析 root.children[0] 的时候经过 traverseChildren 里面时候的 parent.children 值为 undefined。\n 原因是 traverseNode 里面的 NodeTypes.INTERPOLATION 分支没有加 break 导致的，加上 之后：\n1 2 3 4 5 6 7  ƒ render(_ctx, _cache) { with (_ctx) { const { toDisplayString : _toDisplayString } = _Vue return } } \u0026#34;compiled\u0026#34;     和正确结果相比少了点东西 return _toDisplayString(world.burn())\n  with 内的解构来源：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18  function generate() { // ...  if (hasHelpers) { // 比如：插值处理时用到 TO_DISPLAY_STRING helper  // 为了避免命名冲突，这里都需要将他们重命名  // traverseNode 里面 context.help(helper)  push( `const { ${ast.helpers .map((s) =\u0026gt; `${helperNameMap[s]}: _${helperNameMap[s]}`) .join(\u0026#34;, \u0026#34;)}} = _Vue` ); push(\u0026#34;\\n\u0026#34;); newline(); } // ...  }      缺少的 return _toDisplayString(world.burn())\n  generate 中最后 push `return `\n  执行 genNode(ast.codgenNode, context) 处理缺少的部分\n1 2 3 4 5 6 7 8 9  {type: 5, content: {…}, loc: {…}} content: content: \u0026#34;world.burn()\u0026#34; isConstant: false isStatic: false loc: {start: {…}, end: {…}, source: \u0026#34;world.burn()\u0026#34;} type: 4 // SIMPLE_EXPRESSION，第二步  loc: {start: {…}, end: {…}, source: \u0026#34;{{ world.burn() }}\u0026#34;} type: 5 // INTERPOLATION，第一步       node 类型首先是 INTERPOLATION ，进入 genInterpolation(node, context)\n1 2 3 4 5 6 7 8 9 10 11 12  function genInterpolation(node, context) { const { push, helper, pure } = context; if (pure) push(PURE_ANNOTATION); // 这里从 helpers 里面取出 toDisplayString  push(`${helper(TO_DISPLAY_STRING)}(`); // 这里生成 `world.burn()` SIMPLE_EXPRESSION 类型  genNode(node.content, context); push(`)`); }      取 node.content 调用 genNode(node.content, context) 生成 `world.burn()` 表达式。\n 进入 switch node.type === NodeTypes.SIMPLE_EXPRESSION 分支，调用 genExpression(node, context)\n      🌻 Perfect: 最后结果：\n1 2 3 4 5 6 7  ƒ render(_ctx, _cache) { // generate  with (_ctx) { // useWithBlock  const { toDisplayString : _toDisplayString } = _Vue // ast.helpers  return _toDisplayString(world.burn()) // genNode -\u0026gt; genInterpolation -\u0026gt; genExpression  } } // \u0026#34;compiled\u0026#34;      完整流程图：\n   03-inerpolation in pure div   test:\n1 2 3 4 5 6  const source = `\u0026lt;div\u0026gt;{{ world.burn() }}\u0026lt;/div\u0026gt;`.trim(); const result = compile(source, { sourceMap: true, filename: `foo.vue`, });     vue.global:\n1 2 3 4 5 6 7 8 9 10 11 12  (function anonymous( ) { const _Vue = Vue return function render(_ctx, _cache) { with (_ctx) { const { toDisplayString: _toDisplayString, createVNode: _createVNode, openBlock: _openBlock, createBlock: _createBlock } = _Vue return (_openBlock(), _createBlock(\u0026#34;div\u0026#34;, null, _toDisplayString(world.burn()), 1 /* TEXT */)) } } })     先阶段的结果：\n1 2 3 4 5  ƒ render(_ctx, _cache) { with (_ctx) { return } } \u0026#34;compiled\u0026#34;     流程图：  流程分析：\n  baseParse(template, options) 解析出 ast\n  transform(ast, …) 递归遍历处理 root.children 生成各节点的 codegenNode\n  traverseNode(root, context) 核心函数，结合 traverseChildren 通过遍历+递归 处理所有节点，收集对应的 transform* 函数，在结束递归之后回溯过程中执行这些 transform* 来收集节点对应的 codegenNode\n  遍历所有的 nodeTrasforms[] 来收集当前节点满足条件的 transform* 函数 到 exitFns[] 中，比如： 这里的 ELEMENT 类型(\u0026lt;div\u0026gt;\u0026lt;/div\u0026gt;)会收集到 transformElement 和 transformText 。\n  NodeTypes.ROOT 进入 traverseChildren(node, context) 继续处理 root.children ，这里同时会记录每个节点的 parent 值，ROOT 类型收集 transformText 。\n  NodeTypes.ELEMENT 也会进入到 traverseChildren(node, context) 处理 node.children ，赋值 parent, 收集 transformText 和 transformElement 。\n  NodeTypes.INTERPOLATION 对于插值节点，不会进入 traverseChildren 而是在 switch 分支中调用 context.helper() 去更新 context.helpers 用来从 Vue 中 解构出需要的函数。\n    TODO hoistStatic(root, context) 静态提升用的，针对静态节点提升到函数外面(这里暂 时未深入，没用到)\n  createRootCodegen(root, context) 生成 root.codegenNode ，有可能是来自第一 个且唯一一个孩子节点，分为两个分支具体细节点击函数链接。\n  经过 transform 处理之后的 ast 对象\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58  { // 去掉不重要的部分  \u0026#34;type\u0026#34;:0, // ROOT 类型  \u0026#34;children\u0026#34;:[ { \u0026#34;type\u0026#34;:1, // ELEMENT 类型  \u0026#34;tag\u0026#34;:\u0026#34;div\u0026#34;, \u0026#34;tagType\u0026#34;:0, // Start  \u0026#34;children\u0026#34;:[ { \u0026#34;type\u0026#34;:5, // INTERPOLATION  \u0026#34;content\u0026#34;:{ \u0026#34;type\u0026#34;:4, // SIMPLE_EXPRESSION  \u0026#34;isStatic\u0026#34;:false, \u0026#34;isConstant\u0026#34;:false, \u0026#34;content\u0026#34;:\u0026#34;world.burn()\u0026#34;, }, } ], \u0026#34;codegenNode\u0026#34;:{ // 这里实际上是 root.children[0] 经过 transformElement 之后的结果  // 变成了VNODE_CALL 在 codegen-generate 处理部分会用到  \u0026#34;type\u0026#34;:13, // VNODE_CALL  \u0026#34;tag\u0026#34;:\u0026#34;\u0026#34;div\u0026#34;\u0026#34;, \u0026#34;children\u0026#34;:{ \u0026#34;type\u0026#34;:5, // INTERPOLATION  \u0026#34;content\u0026#34;:{ \u0026#34;type\u0026#34;:4, // SIMPLE_EXPRESSION  \u0026#34;isStatic\u0026#34;:false, \u0026#34;isConstant\u0026#34;:false, \u0026#34;content\u0026#34;:\u0026#34;world.burn()\u0026#34;, }, }, \u0026#34;patchFlag\u0026#34;:\u0026#34;1 /* TEXT */\u0026#34;, // 这个目前不知道干啥的  \u0026#34;isBlock\u0026#34;:true, // 决定使用 openBlock/createBlock, 还是 createVNode  \u0026#34;isForBlock\u0026#34;:false, } } ], \u0026#34;codegenNode\u0026#34;:{ // root 根节点的  // 在 createRootCodegen 中有个处理是，如果root.children 有且只有一个  // ELEMENT 类型的节点的时候，root.codegenNode 会被这个节点的 codegenNode  // 覆盖，即root 使用它唯一的孩子节点的 codegenNode  \u0026#34;type\u0026#34;:13, // VNODE_CALL  \u0026#34;tag\u0026#34;:\u0026#34;\u0026#34;div\u0026#34;\u0026#34;, \u0026#34;children\u0026#34;:{ \u0026#34;type\u0026#34;:5, \u0026#34;content\u0026#34;:{ \u0026#34;type\u0026#34;:4, \u0026#34;isStatic\u0026#34;:false, \u0026#34;isConstant\u0026#34;:false, \u0026#34;content\u0026#34;:\u0026#34;world.burn()\u0026#34;, }, }, \u0026#34;patchFlag\u0026#34;:\u0026#34;1 /* TEXT */\u0026#34;, \u0026#34;isBlock\u0026#34;:true, \u0026#34;isForBlock\u0026#34;:false, }, }      generate(ast, …) 生成代码片段 -\u0026gt; new Function(context.code)\n  genFunctionPreamble(ast, context) 主要使用来检测环境从而导入 Vue 实例 (如：~const _Vue = Vue~)，最后 render 函数的 `return ` 也是这里生成的。\n  genNode(ast.codegenNode, context) 对每个 ast 节点结构进行处理，生成对应的 Render 函数相关部件。\n  genVNodeCall(node, context) 生成节点的参数，调用函数之类的，如： openBlock() , createBlock(...) 及参数列表 createBlock(tag, props, children, patchFlag, ...) ，指令等部件。\n  patchFlag 是在 transformElement 里面处理值的。\n 经过 generate 之后生成的 render 函数：\n1 2 3 4 5 6 7 8 9 10 11 12  (function anonymous( ) { const _Vue = Vue return function render(_ctx, _cache) { with (_ctx) { const { toDisplayString: _toDisplayString, createVNode: _createVNode, openBlock: _openBlock, createBlock: _createBlock } = _Vue return (_openBlock(), _createBlock(\u0026#34;div\u0026#34;, null, _toDisplayString(world.burn()), 1 /* TEXT */)) } } })     render({ world: { burn() { return `burn the world !` }}}) 执行之后得到的 VNode 节点：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24  { \u0026#34;_isVNode\u0026#34;:true, \u0026#34;type\u0026#34;:\u0026#34;div\u0026#34;, \u0026#34;props\u0026#34;:null, \u0026#34;key\u0026#34;:null, \u0026#34;ref\u0026#34;:null, \u0026#34;scopeId\u0026#34;:null, \u0026#34;children\u0026#34;:\u0026#34;burn the world !\u0026#34;, \u0026#34;component\u0026#34;:null, \u0026#34;suspense\u0026#34;:null, \u0026#34;dirs\u0026#34;:null, \u0026#34;transition\u0026#34;:null, \u0026#34;el\u0026#34;:null, \u0026#34;anchor\u0026#34;:null, \u0026#34;target\u0026#34;:null, \u0026#34;targetAnchor\u0026#34;:null, \u0026#34;shapeFlag\u0026#34;:9, \u0026#34;patchFlag\u0026#34;:1, \u0026#34;dynamicProps\u0026#34;:null, \u0026#34;dynamicChildren\u0026#34;:[ ], \u0026#34;appContext\u0026#34;:null }          04-interpolation in div with props   code: `\u0026lt;div id=\u0026#34;foo\u0026#34; :class=\u0026#34;bar.baz\u0026#34;\u0026gt;{{ world.burn() }}\u0026lt;/div\u0026gt;`\n 这个用例和 用例3 只有一个属性的差别，所以这里只要参考 test 03 来实现 div 属性的 解析和编译即可，所有流程和流程图可参考 03 来实现。\n 还是老方法，根据跟踪 vue.global debugger 过程来分析整个过程。 期待结果：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  (function anonymous( ) { const _Vue = Vue return function render(_ctx, _cache) { with (_ctx) { const { toDisplayString: _toDisplayString, createVNode: _createVNode, openBlock: _openBlock, createBlock: _createBlock } = _Vue return (_openBlock(), _createBlock(\u0026#34;div\u0026#34;, { id: \u0026#34;foo\u0026#34;, class: bar.baz }, _toDisplayString(world.burn()), 3 /* TEXT, CLASS */)) } } })     createStructuralDirectiveTransform(name, fn) 如果存在属性，都会经过这个函数是因 为 if,else-if,else,for 的 transform 都是通过这个创建的，所以在经过 traverseNode 中的 exitFns 收集过程中会执行到这里。\n 然后这个用例中并没有 v-if, v-for 类似的分支指令，所以这些 transform* 不会被收集 到。\n root.children[0]: div 收集 transformElement ，ELEMENT 类型需要收集来解析出 codegenNode。\n  流程图分析：这里和 03 对比多了两部分处理\n  transform 阶段的 props 解析\n 这一阶段的处理发生在 transformElement 中对 props 属性的检测，一旦检测到有属性 列表，需要经过 buildProps 解析出新的属性对象:\n buildProps 之前的 props\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26  props: Array(2) 0: // 属性 id  loc: {..., source: \u0026#34;id=\u0026#34;foo\u0026#34;\u0026#34;} name: \u0026#34;id\u0026#34; type: 6 // ATTRIBUTE  value: content: \u0026#34;foo\u0026#34; loc: {..., source: \u0026#34;\u0026#34;foo\u0026#34;\u0026#34;} type: 2 // TEXT  1: // 属性 :class  arg: content: \u0026#34;class\u0026#34; isConstant: true isStatic: true loc: {..., source: \u0026#34;class\u0026#34;} type: 4 // SIMPLE_EXPRESSION  exp: content: \u0026#34;bar.baz\u0026#34; isConstant: false isStatic: false loc: {..., source: \u0026#34;bar.baz\u0026#34;} type: 4 // SIMPLE_EXPRESSION  loc: {..., source: \u0026#34;:class=\u0026#34;bar.baz\u0026#34;\u0026#34;} modifiers: [] name: \u0026#34;bind\u0026#34; type: 7 // DIRECTIVE      buildProps 解析之后：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  Return value: Object directives: [] dynamicPropNames: [] patchFlag: 2 // CLASS  props: properties: Array(2) 0: key: {type: 4, isConstant: false, content: \u0026#34;id\u0026#34;, isStatic: true} type: 16 // JS_ARRAY_EXPRESSION  value: {type: 4, isConstant: false, content: \u0026#34;foo\u0026#34;, isStatic: true} 1: key: {type: 4, content: \u0026#34;class\u0026#34;, isStatic: true, isConstant: true}} type: 16 value: {type: 4, content: \u0026#34;bar.baz\u0026#34;, isStatic: false, isConstant: false, type: 15 // JS_PROPERTY      这里面的处理分为两种类型： 1. ATTRIBUTE\u0026lt;6\u0026gt; 类型， 2. DIRECTIVE\u0026lt;7\u0026gt; 指令类型是 分开处理的，普通属性调用 createObjectProperty(key, value) 构建新的对象，指 令属性通过指令名称从 context.directiveTransforms 对象中取出对应的函数进行处 理，比如 v-bind 对应函数 transformBind(prop, node, context) 处理。\n 比如： id=\u0026#34;foo\u0026#34; 处理之后的\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  Return value: Object key: // 属性名  content: \u0026#34;id\u0026#34; isConstant: false isStatic: true loc: {source: \u0026#34;id\u0026#34;} type: 4 // SIMPLE_EXPRESSION  type: 16 // JS_PROPERTY  value: // 属性值  content: \u0026#34;foo\u0026#34; isConstant: false isStatic: true loc: {source: \u0026#34;\u0026#34;foo\u0026#34;\u0026#34;} type: 4 // SIMPLE_EXPRESSION  // 包含 key, type, value 三个属性值      比如： :class=\u0026#34;bar.baz\u0026#34; 处理之后的\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17  Return value: Object props: Array(1) 0: key: content: \u0026#34;class\u0026#34; isConstant: true isStatic: true type: 4 // SIMPLE_EXPRESSION  type: 16 // JS_ARRAY_EXPRESSION  value: content: \u0026#34;bar.baz\u0026#34; isConstant: false isStatic: false type: 4 // 包含 key, type, value，和普通属性类型不一样  // 这里是 JS_ARRAY_EXPRESSION       generate 阶段的 props 解析\n render 函数生成阶段， genVNodeCall 解析 codegenNode, 其中有一个 genNodeList(nodes, …) 这里的 nodes 是 [tag, props, children, patchFlag, ...] 该用例中相比用例03 这里的 props 不是 null ，所以在 genNodeList 中 i = 1 的时候会进入到 genNode(props, context) 去解析属性列表。\n 进入之前 props 值：\n1 2 3  loc: {source: \u0026#34;\u0026lt;div id=\u0026#34;foo\u0026#34; :class=\u0026#34;bar.baz\u0026#34;\u0026gt;{{ world.burn() }}\u0026lt;/div\u0026gt;\u0026#34;} properties: (2) [{…}, {…}] // 这里是 id, class 两个属性  type: 15 // JS_OBJECT_EXPRESSION      类型为 JS_OBJECT_EXPRESSION\u0026lt;15\u0026gt; 在 genNode 里面会进入 genObjectExpression(node, context) 分支将属性解析成对象，如： {id: \u0026#34;foo\u0026#34;, class: bar.baz} 。\n genObjectExpression 里面对属性的处理主要分两步，先调用 genExpressionAsPropertyKey(node, context) 去处理属性名 key node，完成之后，再调 用 genNode(value, context) 去处理值 value node(最后进入 genExpression(node, context), 因为类型为 SIMPLE_EXPRESSION\u0026lt;4\u0026gt;)。\n 最后得到 {id: \u0026#34;foo\u0026#34;, class: bar.baz} 作为 createBlock(\u0026#39;div\u0026#39;, ...) 的第二个参数。\n  修改完之后运行结果：\n1 2 3 4 5 6 7 8 9 10 11  (function anonymous( ) { return function render(_ctx, _cache) { with (_ctx) { const { toDisplayString : _toDisplayString, createVNode : _createVNode, openBlock : _openBlock, createBlock : _createBlock } = _Vue return (_openBlock(), _createBlock(\u0026#34;div\u0026#34;, { id: \u0026#34;foo\u0026#34; }, _toDisplayString(world.burn()), 1 /* TEXT */)) } } })     结果与正确结果又两点缺陷：\n  属性漏掉了 class\n  patchFlag 那里不对，正确应该是 3 /* TEXT, CLASS */\n  没有报错能走通说明至少逻辑是通的出现上面两个问题原因，溯源起来也很清晰，因为我们 知道 props 在 transform 阶段是 transformElement 里面，generate 阶段是在 genObjectExpression() 中, 而 patchFlag 也是在 transformElement 处理的。\n 通过在 genObjectExpression() for 循环中增加打印，显示 properties 中只有一个 id 属性，那么属性解析最后是在 buildProps 里面的， bingo!!! 没有实现 transformBind 。\n 那么修改点有二：\n  在 compile.ts 的 getBaseTransformPreset 增加指令 transform 函数 transformBind\n  实现 transformBind\n  修改之后：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14  (function anonymous( ) { return function render(_ctx, _cache) { with (_ctx) { const { toDisplayString : _toDisplayString, createVNode : _createVNode, openBlock : _openBlock, createBlock : _createBlock } = _Vue return (_openBlock(), _createBlock(\u0026#34;div\u0026#34;, { id: \u0026#34;foo\u0026#34;, class: bar.baz }, _toDisplayString(world.burn()), 3 /* TEXT, CLASS */)) } } })    扩展 1：增加 camel 修饰符   code: `\u0026lt;div id=\u0026#34;foo\u0026#34; :class=\u0026#34;bar.baz\u0026#34; :test-prop.camel=\u0026#34;bar.bax\u0026#34;\u0026gt;{{ world.burn() }}\u0026lt;/div\u0026gt;`\n 结果：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  (function anonymous( ) { return function render(_ctx, _cache) { with (_ctx) { const { toDisplayString : _toDisplayString, createVNode : _createVNode, openBlock : _openBlock, createBlock : _createBlock } = _Vue return (_openBlock(), _createBlock(\u0026#34;div\u0026#34;, { id: \u0026#34;foo\u0026#34;, class: bar.baz, testName: bar.bax }, _toDisplayString(world.burn()), 3 /* TEXT, CLASS */)) } } })     因为 transformBind 中有检测修饰符中是否包含 camel ，如果有则会进行驼峰转换，否 则不会转而是将 test-prop 用引号包起来： \u0026#34;test-prop\u0026#34; 。\n  扩展 2：动态属性且有 camel 修饰符   code: `\u0026lt;div id=\u0026#34;foo\u0026#34; :class=\u0026#34;bar.baz\u0026#34; :[prop_name].camel=\u0026#34;bar.bax\u0026#34;\u0026gt;{{ world.burn() }}\u0026lt;/div\u0026gt;`\n 这个时候需要实现 transform.js 中 createTransformContext 中 context.helperString\n1 2 3  helperString(name) { return `_${helperNameMap[context.helper(name)]}`; }     结果：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  (function anonymous( ) { return function render(_ctx, _cache) { with (_ctx) { const { toDisplayString : _toDisplayString, camelize : _camelize, createVNode : _createVNode, openBlock : _openBlock, createBlock : _createBlock } = _Vue return (_openBlock(), _createBlock(\u0026#34;div\u0026#34;, { id: \u0026#34;foo\u0026#34;, class: bar.baz, [_camelize(prop_name)]: bar.bax }, _toDisplayString(world.burn()), 1 /* TEXT */)) } } })     会发现这里多解构了个 _camelize 函数出来，通过函数调用方式去处理动态属性名。\n    05-interpolation, v-if, props  1 2 3 4 5  code = ` \u0026lt;div id=\u0026#34;foo\u0026#34; :class=\u0026#34;bar.baz\u0026#34;\u0026gt; {{ world.burn() }} \u0026lt;div v-if=\u0026#34;ok\u0026#34;\u0026gt;yes\u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt;`     增加了 \u0026lt;div v-if=\u0026#34;ok\u0026#34;\u0026gt;\u0026lt;/div\u0026gt;\n ast: 在经过 parse.ts 之后应该具备看到模板能够分析出 ast 结构能力。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77  { type: 0, // ROOT  children: [ { // div#foo  type: 1, // ELEMENT  tag: \u0026#39;div\u0026#39;, tagType: 0, // Start  props: [ { // id  type: 6, // ATTRIBUTE  name: \u0026#39;id\u0026#39;, value: { type: 2, // TEXT  content: \u0026#39;foo\u0026#39; } }, { // :class  type: 7, // DIRECTIVE  name: \u0026#39;bind\u0026#39;, arg: { type: 4, // SIMPLE_EXPRESSION  content: \u0026#39;class\u0026#39;, isStatic: true, // 静态参数名  isConstant: true }, // 参数名 class  exp: { type: 4, // SIMPLE_EXPRESSION  content: \u0026#34;bar.baz\u0026#34;, isStatic: false, isConstant: false }, // 表达式 bar.baz  modifiers: [], // 修饰符  } ], children: [ { // world.burn  type: 5, // INTERPOLATION  content: { content: \u0026#34;world.burn()\u0026#34;, isStatic: false, isConstant: false, type: 4, // SIMPLE_EXPRESSION  }, }, { // \u0026#34; \u0026#34; 空  type: 2, // TEXT  content: \u0026#39; \u0026#39; }, { // div v-if  type: 1, // ELEMENT  tag: \u0026#39;div\u0026#39;, tagType: 0, // Start  children: [ { // yes  type: 2, // TEXT  content: \u0026#34;yes\u0026#34; } ], props: [ { type: 7, // DIRECTIVE  name: \u0026#39;if\u0026#39;, exp: { type: 4, content: \u0026#34;ok\u0026#34;, isStatic: false, isConstant: false }, modifiers: [] } ] } ] }, // div#foo  ], codegenNode: undefined }     vue.global 结果：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44  (function anonymous() { const _Vue = Vue; const { createVNode: _createVNode, createCommentVNode: _createCommentVNode, createTextVNode: _createTextVNode, } = _Vue; const _hoisted_1 = { key: 0 }; return function render(_ctx, _cache) { with (_ctx) { const { toDisplayString: _toDisplayString, createVNode: _createVNode, openBlock: _openBlock, createBlock: _createBlock, createCommentVNode: _createCommentVNode, createTextVNode: _createTextVNode, } = _Vue; return ( _openBlock(), _createBlock( \u0026#34;div\u0026#34;, { id: \u0026#34;foo\u0026#34;, class: bar.baz, }, [ _createTextVNode( _toDisplayString(world.burn()) + \u0026#34; \u0026#34;, 1 /* TEXT */ ), ok ? (_openBlock(), _createBlock(\u0026#34;div\u0026#34;, _hoisted_1, \u0026#34;yes\u0026#34;)) : _createCommentVNode(\u0026#34;v-if\u0026#34;, true), ], 2 /* CLASS */ ) ); } }; });     这里有几个不同点：\n  _createBlock 第三个参数 children 变成了数组，且使用了 _createTextVNode() 创建 虚拟节点\n  就是多了个新增的那个 div v-if 节点\n  patchFlag 的变化\n   先看下修改之前的结果：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27  (function anonymous() { return function render(_ctx, _cache) { with (_ctx) { const { toDisplayString: _toDisplayString, createVNode: _createVNode, camelize: _camelize, createTextVNode: _createTextVNode, openBlock: _openBlock, createBlock: _createBlock, } = _Vue; return ( _openBlock(), _createBlock( \u0026#34;div\u0026#34;, { id: \u0026#34;foo\u0026#34;, class: bar.baz, [_camelize(prop_name)]: bar.bax, }, [, _createVNode(\u0026#34;div\u0026#34;, null, \u0026#34;yes\u0026#34;)] ) ); } }; });     差异点：\n  没有 render 函数外的解构\n  没有 render 函数外的 const _hoisted_1 = { key: 0 };\n  没有 _createCommentVNode\n  children 里面的差值节点丢失了\n  div v-if 节点处理错误\n  先解决差值问题(第 4 点)，这里插值节点为什么会丢失？\n 补漏：\n  实现 transformIf\n createStructuralDirectiveTransform 创建指令(如：v-if, v-else 等)相关的 transform 函数，注意这里的正则： /^(if|else|else-if)$/\n 由于指令是存在 node.props 属性里面的，这里会直接遍历所有的属性，找出满足条件 type:DIRECTIVE 且 prop.name 匹配上面的正则的指令。\n 因为这里要将所有的指令转成分支类型的结构。\n1 2 3 4 5 6 7 8 9 10 11 12 13  { type: 9, // IF  branches: [{ children: [{ /* 这里保存了转换之前的 v-if 节点 */}] condition: { content: \u0026#39;ok\u0026#39;, // ...  type: 4, // SIMPLE_EXPRESSION  } // branch  type: 10, // IF_BRANCH  }] }     最后处理之后得到的 ifNode 包含所有分支 ifNode.branches ， branch 即当前要处 理的分支交给返回的那个 transform 函数待递归完成之后取处理得到该分支节点的 codegenNode\n 然后经过递归之后，回溯过程中会执行返回的那个函数(transform if) 进入 createCodegenNodeForBranch -\u0026gt; createChildrenCodegenNode -\u0026gt; createCallExpression 创建分支节点 codegen。\n  实现 traverseNode 中的 IF(9) 和 IF_BRANCH(10) 分支\n  实现 generate 阶段的 if 节点处理\n 修改 genNode 增加 IF, IF_BRANCH, JS_CALL_EXPRESSION, JS_CONDITIONAL_EXPRESSION 分支。\n 增加 genCallExpression 函数生成参数。\n 增加 genConditionalExpression 函数生成 if 分支(如： ok ? ... : ...)\n   在完成上述三个步骤之后输出结果：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20  (function anonymous( ) { return function render(_ctx, _cache) { with (_ctx) { const { toDisplayString : _toDisplayString, createVNode : _createVNode, openBlock : _openBlock, createBlock : _createBlock, createCommentVNode : _createCommentVNode, createTextVNode : _createTextVNode } = _Vue return (_openBlock(), _createBlock(\u0026#34;div\u0026#34;, { id: \u0026#34;foo\u0026#34;, class: bar.baz }, [ _createTextVNode(_toDisplayString(world.burn()), 1 /* TEXT */), ok ? (_openBlock(), _createBlock(\u0026#34;div\u0026#34;, { key: 0 }, \u0026#34;yes\u0026#34;)) : _createCommentVNode(\u0026#34;v-if\u0026#34;, true) ], 2 /* CLASS */)) } } })    扩展一：hoisted 支持    genFunctionPreamble(ast, context) 中增加 genHoists(ast.hoists, context)\n  transform 阶段对 hoisted 处理(transforms/hoistStatic.ts 的 walk() 函数，遍 历所有孩子节点，找出节点 props 中所有属性名为 key 或 ref 的属性)\n  transform.js 的 context.hoist() 实现，修改 props 属性\n 这里 vue.global.js 和 实际 vue transform.ts 中的代码有细微差别，但不影响整体 流程，不知道为何？\n   实现之后会发现在返回 render 函数之前多了 const _hoisted_1 = { key: 0 } 和一些 函数的解构。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19  (function anonymous( ) { const _Vue = Vue const { createVNode: _createVNode, createCommentVNode: _createCommentVNode } = _Vue const _hoisted_1 = { key: 0 } return function render(_ctx, _cache) { with (_ctx) { const { createVNode : _createVNode, openBlock : _openBlock, createBlock : _createBlock, createCommentVNode : _createCommentVNode } = _Vue return (_openBlock(), _createBlock(\u0026#34;div\u0026#34;, null, [ ok ? (_openBlock(), _createBlock(\u0026#34;div\u0026#34;, _hoisted_1, \u0026#34;yes\u0026#34;)) : _createCommentVNode(\u0026#34;v-if\u0026#34;, true) ])) } } })      扩展二：v-else 支持   相关脑图链接 –\u0026gt;\n1 2 3 4 5 6  code = ` \u0026lt;div id=\u0026#34;foo\u0026#34; :class=\u0026#34;bar.baz\u0026#34;\u0026gt; {{ world.burn() }} \u0026lt;div v-if=\u0026#34;ok\u0026#34;\u0026gt;yes\u0026lt;/div\u0026gt; \u0026lt;div v-else\u0026gt;no\u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt;`     v-if 和 v-else 的 ast:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34  [ { // v-if  \u0026#34;type\u0026#34;:1, // ELEMENT  \u0026#34;ns\u0026#34;:0, \u0026#34;tag\u0026#34;:\u0026#34;div\u0026#34;, \u0026#34;tagType\u0026#34;:0, \u0026#34;props\u0026#34;:[ { \u0026#34;type\u0026#34;:7, // DIRECTIVE  \u0026#34;name\u0026#34;:\u0026#34;if\u0026#34;, \u0026#34;exp\u0026#34;:{ \u0026#34;type\u0026#34;:4, \u0026#34;content\u0026#34;:\u0026#34;ok\u0026#34;, \u0026#34;isStatic\u0026#34;:false, \u0026#34;isConstant\u0026#34;:false, }, } ], \u0026#34;children\u0026#34;:[{...}], }, { // v-else  \u0026#34;type\u0026#34;:1, // ELEMENT  \u0026#34;ns\u0026#34;:0, \u0026#34;tag\u0026#34;:\u0026#34;div\u0026#34;, \u0026#34;tagType\u0026#34;:0, \u0026#34;props\u0026#34;:[ { \u0026#34;type\u0026#34;:7, // else, DIRECTIVE  \u0026#34;name\u0026#34;:\u0026#34;else\u0026#34;, } ], \u0026#34;children\u0026#34;:[{...}], } ]     从之前的实现结果可知， 单个 v-if 的处理是在后面追加一个注释节点，因为在 Render 函数中这些节点是以三目运算符(?:)链接起来组成表达式的，如：\n1 2 3  ok ? (_openBlock(), _createBlock(\u0026#34;div\u0026#34;, { key: 0 }, \u0026#34;yes\u0026#34;)) : _createCommentVNode(\u0026#34;v-if\u0026#34;, true)     按照理解，如果增加了 v-else 分支，那么应该需要将 : 后的注释节点替换成真正的 节点？\n 猜想 ：\n 从代码语法角度思考， if/else/else-if 肯定必须是连续的，那么这里的 else 如果想要正 确解析那前提必须要有 if 才行。这一步是如何实现呢？\n 根据上面 ast 解析结果显示，在 parser 阶段，无论是 if 还是 else 都是同等对待的，即它 们都是个指令(9,DIRECTIVE)，然后根据之前 v-if 的 transform 可知，v-else 也是在 这个阶段并且是在同一个 transformIf 中处理的，即下面 else TODO 部分。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17  export const transformIf = createStructuralDirectiveTransform( /^(if|else|else-if)$/, (node, dir, context) =\u0026gt; { return processIf(node, dir, context, (ifNode, branch, isRoot) =\u0026gt; { // 能到这里说明 v-if 下所有的 child 都已经处理完毕，可以返回处理  // codegenNode 的函数了  return () =\u0026gt; { console.log({ dir, isRoot }); if (isRoot) { ifNode.codegenNode = createCodegenNodeForBranch(branch, 0, context); } else { // TODO  } }; }); } )      所以实现步骤如下\n  实现 transformIf 返回的 transform 函数的 else 部分，这部分承担 了 v-else/v-else-if 指令节点的 codegenNode 生成工作。\n  实现 processIf() 的分支部分\n  createCodegenNodeForBranch(branch, index, context) 返回新的 alternate 替换掉 占位的注释分支。\n  因为都是在 v-if 的 branches 里面，在 codegen 阶段和 v-if 的处理是一样的，不需 要修改什么。\n  修改完之后：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20  (function anonymous( ) { const _Vue = Vue const { createVNode: _createVNode, createCommentVNode: _createCommentVNode } = _Vue const _hoisted_1 = { key: 0 } const _hoisted_2 = { key: 1 } return function render(_ctx, _cache) { with (_ctx) { const { createVNode : _createVNode, openBlock : _openBlock, createBlock : _createBlock, createCommentVNode : _createCommentVNode } = _Vue return (_openBlock(), _createBlock(\u0026#34;div\u0026#34;, null, [ ok ? (_openBlock(), _createBlock(\u0026#34;div\u0026#34;, _hoisted_1, \u0026#34;yes\u0026#34;)) : (_openBlock(), _createBlock(\u0026#34;div\u0026#34;, _hoisted_2, \u0026#34;no\u0026#34;)) ])) } } })          问题列表    compile.js:37 Uncaught TypeError: object is not iterable (cannot read property Symbol(Symbol.iterator))\n 原因是：在数组里面使用展开符的时候 [], {} 混用了\n1 2 3 4 5 6 7 8 9 10 11 12 13  transform(ast, { // 合并选项  ...options, // 调用 baseCompile 时候的第二个参数  prefixIdentifiers, // 还不知道是干啥的???  // 节点转换器合并，外部转换器优先，即使用者可自定义自己的转换器  // nodeTransforms: [...nodeTransforms, ...(options.nodeTransforms || {})], // FIX: 这里用法有问题修改前  nodeTransforms: [...nodeTransforms, ...(options.nodeTransforms || [])], // FIX: 修改后  // 指令转换器，同上。  directiveTransforms: { ...directiveTransforms, ...(options.directiveTransforms || {}), }, });        ","permalink":"https://www.cheng92.com/vue/vue3-source-code-compiler-core-compile_ts/","tags":["vue,","vue3,","vuenext,","compiler"],"title":"Vue3.0 源码系列（二）编译器核心 - Compiler core 3: compile.ts"},{"categories":["vue"],"contents":" 该系列文章，均以测试用例通过为基准一步步实现一个 vue3 源码副本(学习)。\n 文字比较长，如果不想看文字可直接转到这里看脑图\n简介 reactivity 是 vue next 里面通过 proxy + reflect 实现的响应式模块。\n源码路径： packages/reactivity\n入口文件：packages/reactivity/src/index.ts\n疑问点解答：\n  shallowReactive 相当于浅复制，只针对对象的一级 reactive，嵌套的对象不会 reactive\n参考：测试代码 reactive.spec.ts\n1 2 3 4 5  test(\u0026#39;should keep reactive properties reactive\u0026#39;, () =\u0026gt; { const props: any = shallowReactive({ n: reactive({ foo: 1 }) }) props.n = reactive({ foo: 2 }) expect(isReactive(props.n)).toBe(true) })     完整的 reactivity 模块代码链接。\n阶段代码链接  测试用例 reactive.spec.ts 通过后的代码链接 测试用例 effect.spec.ts通过后的代码链接 05-21号 git pull 后的更新合 并之后的 reactive.js 将 reactive.js 拆分成 effect.js + baseHandlers.js 完成 collection handlers(set + get) 完成 collection Map, Set 支持 支持 Ref 类型 支持 computed 属性  文中重点链接  vue 中是如何防止在 effect(fn) 的 fn 中防止 ob.prop++ 导致栈溢出的？ vue 中为何能对 JSON.parse(JSON.stringify({})) 起作用的？ 集合 handlers 的 get 函数实现 this 问题 Key 和 rawKey 的问题(get 中)，为什么要两次 track:get？ 为什么 key1 和 toReactive(key1) 后的 key11 前后 set 会改变 key1 对应的值？？？ 如果 Ref 类型放在一个对象中 reactive 化会有什么结果？？？ 计算属性的链式嵌套使用输出结果详细分析过程(想要透彻computed请看这里！！！)  遗留问题  DONE ownKeys 代理收集的依赖不能被触发。 TODO Ref:a 类型在对象中执行 obj.a++ 之后依旧是 Ref 类型的 a ???  更新 2020-05-21 21:19:07 git pull 模块结构  __tests__/ 测试代码目录 src/ 主要代码目录  src 目录下的文件：\n baseHandler.ts 传入给代理的对象，代理 Object/Array 时使用的 Handlers。 collectionHandlers.ts 传入给代理的对象，代理 [Week]Set/Map类型时使用的 Handlers。 computed.ts 计算属性代码 effect.ts operations.ts 操作类型枚举 reactive.ts 主要代码 ref.ts  Proxy 和 Reflect 回顾 将 reactive -\u0026gt; createReactiveObject 简化合并：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20  function reactive(target, toProxy, toRaw, baseHandlers, collectionHandlers) { // ... 必须是对象 return  // ... 已经设置过代理了  let observed = null // ... 本身就是代理  // ... 白名单检测  // ... handlers  // new 代理  let handlers = baseHandlers || collectionHandlers || {} // ...  observed = new Proxy(target, handlers) // 缓存代理设置结果到 toProxy, toRaw  return observed }   增加一个 reactive 对象：\n1 2 3 4 5 6 7 8 9 10 11 12  const target = { name: \u0026#39;vuejs\u0026#39; } const observed = reactive(target, null, null, { get: function (target, prop, receiver) { console.log(target, prop, receiver === observed, \u0026#39;get\u0026#39;) } }) console.log(target, observed)   输出结果：\n {name: \u0026ldquo;vuejs\u0026rdquo;} Proxy {name: \u0026ldquo;vuejs\u0026rdquo;}\n=\u0026gt; original.name \u0026ldquo;vuejs\u0026rdquo; =\u0026gt; observed.name index.js:28 true \u0026ldquo;name\u0026rdquo; true \u0026ldquo;get\u0026rdquo; undefined =\u0026gt; observed === original false\n 访问 target, observed 的属性 name 结果如上，observed 是被代理之后的对象。\n Observed.name 输出结果是 handler.get 执行之后的结果，因为没任何返回所以是 undefined get(target, prop, receiver) 有三个参数，分别代表  target: 被代理的对象，即原始的那个 target 对象 prop: 要获取对象的属性值的 key receiver: 代理之后的对象，即 observed    其他主要几个代理方法：\n set 赋值的时候触发，对应 Reflect.set(target, prop, value) get 取值的时候触发，对应 Reflect.get(target, prop, reciver) ownKeys 使用 for...in 时触发，对应 Reflect.ownKeys(target) has 使用 prop in obj 时触发，对应语法 ： ... in ... deleteProperty 使用 delete obj.name 触发，对应 delete obj.name apply 被代理对象是函数的时候，通过 fn.apply() 时触发，handler 里对应 fn() construct 构造器，new target() 时触发 getPrototypeOf 调用 Object.getPrototypeOf(target) 触发，返回对象 或 null  setPrototypeOf 设置对象原型时触发，如： obj.prototype = xxx  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73  let original = { name: \u0026#39;vuejs\u0026#39;, foo: 1 } original = test const observed = reactive(original, null, null, { get: function (target, prop, receiver) { console.log(target === original, prop, receiver === observed, \u0026#39;get\u0026#39;) return Reflect.get(...arguments) }, set: function (target, prop, value) { console.log(prop, value, \u0026#39;set\u0026#39;) Reflect.set(target, prop, value) }, ownKeys: function (target) { console.log(\u0026#39;get own keys...\u0026#39;) return Reflect.ownKeys(target) }, has: function (target, key) { console.log(\u0026#39;has proxy handler...\u0026#39;) return key in target }, deleteProperty: function (target, key) { console.log(key + \u0026#39;deleted from \u0026#39;, target) delete target[key] }, // 适用于被代理对象是函数类型的  apply: function (target, thisArg, argList) { console.log(\u0026#39;apply...\u0026#39;, argList) target(...argList) }, construct(target, args) { console.log(\u0026#39;proxy construct ... \u0026#39;, args) return new target(...args) }, // 必须返回一个对象或者 null，代理 Object.getPrototypeOf 取对象原型  getPrototypeOf(target) { console.log(\u0026#39;proxy getPrototypeOf...\u0026#39;) return null }, setPrototypeOf(target, proto) { console.log(\u0026#39;proxy setPrototypeOf...\u0026#39;, proto) } }) console.log(observed.name) // -\u0026gt; true \u0026#34;name\u0026#34; true \u0026#34;get\u0026#34; observed.name = \u0026#39;xxx\u0026#39; // -\u0026gt; name xxx set for (let prop in observed) { } // -\u0026gt; get own keys... \u0026#39;name\u0026#39; in observed // -\u0026gt; has proxy handler delete observed.foo // foo deleted from { name: \u0026#39;xxx\u0026#39;, foo: 1 }  function test() { console.log(this.name, \u0026#39;test apply\u0026#39;) } observed.apply(null, [1, 2, 3]) // apply... (3) [1, 2, 3] // 注意点：proxy-construct 的第二个参数是传入构造函数时的参数列表 // 就算是以下面方式一个个传递的 new observed(1, 2, 3) // proxy construct ... (3) [1, 2, 3] Object.getPrototypeOf(observed) // proxy getPrototypeOf... observed.prototype = { bar: 2 } // prototype {bar: 2} set // index.js:31 true \u0026#34;prototype\u0026#34; true \u0026#34;get\u0026#34; // index.js:90 {bar: 2} console.log(observed.prototype)   需要注意的点：\n construct 的代理 handler 中的第二个参数是一个参数列表数组。 getPrototypeOf 代理里面返回一个正常的对象 或 null表示失败。  reactive 函数 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  export function reactive(target: object) { // if trying to observe a readonly proxy, return the readonly version.  // 这里对只读的对象进行判断，因为只读的对象不允许修改值  // 只要曾经被代理过的就会被存到 readonlyToRaw 这个 WeakMap 里面  // 直接返回只读版本  if (readonlyToRaw.has(target)) { return target } return createReactiveObject( target, rawToReactive, reactiveToRaw, mutableHandlers, mutableCollectionHandlers ) }   传入一个 target 返回代理对象。\ncreateReactiveObject 真正执行代理的是这个函数里面。\n参数列表  target 被代理的对象 toProxy 一个 WeakMap 里面存储了 target -\u0026gt; observed toRaw 和 toProxy 刚好相反的一个 WeakMap 存储了 observed -\u0026gt; target baseHandlers 代理时传递给 Proxy 的第二个参数 collectionHandlers 代理时传递给 Proxy 的第二个参数(一个包含四种集合类型的 Set)  函数体 下面是将 reactive 和 createReactiveObject 进行合并的代码。\n事先声明的变量列表：\n1 2 3 4 5 6 7 8  // 集合类型的构造函数，用来检测 target 是使用 baseHandlers // 还是 collectionHandlers const collectionTypes = new Set([Set, Map, WeakMap, WeakSet]) // 只读对象的 map，只读对象代理时候直接返回原始对象 const readonlyToRaw = new WeakMap() // 存储一些只读或无法代理的值 const rawValues = new WeakSet()   合并后的 reactive(target, toProxy, toRaw, basehandlers, collectionHandlers) 函数\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44  function reactive(target, toProxy, toRaw, baseHandlers, collectionHandlers) { // 只读的对象  if (readonlyToRaw.has(target)) { return target } // ... 必须是对象 return  if (target \u0026amp;\u0026amp; typeof target !== \u0026#39;object\u0026#39;) { console.warn(\u0026#39;不是对象，不能被代理。。。\u0026#39;) return target } // toProxy 是一个 WeakMap ，存储了 observed -\u0026gt; target  // 因此这里检测是不是已经代理过了避免重复代理情况  let observed = toProxy.get(target) if (observed !== void 0) { console.log(\u0026#39;target 已经设置过代理了\u0026#39;) return observed } // ... 本身就是代理  // toRaw 也是一个 WeakMap 存储了 target -\u0026gt; observed  // 这里判断这个，可能是为了防止，将曾经被代理之后的 observed 传进来再代理的情况  if (toRaw.has(target)) { console.log(\u0026#39;target 本身已经是代理\u0026#39;) return target } // ...... 这里省略非法对象的判断，放在后面展示 ......  // 根据 target 类型决定使用哪个 handlers  // `Set, Map, WeakSet, SeakMap` 四种类型使用 collectionHandlers 集合类型的 handlers  // `Object, Array` 使用 basehandlers  const handlers = collectionTypes.has(target.constructor) ? collectionHandlers : baseHandlers // new 代理  observed = new Proxy(target, handlers) // 缓存代理设置结果到 toProxy, toRaw  toProxy.set(observed, target) toRaw.set(target, observed) return observed }     readonlyToRaw.has(target) 检测是否是只读对象，直接返回该对象\n  检测 target是引用类型还是普通类型，只有引用类型才能被代理\n  toProxy 中存储了 target-\u0026gt;observed 内容，检测 target 是不是已经有代理了\n  toRaw 中存储了 observed-\u0026gt;target 检测是否已经是代理了\n  五种不合法的对象类型，不能作为代理源\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39  // ... 白名单检测，源码中调用的是 `canObserve` 这里一个个拆分来检测  // 1. Vue 实例本身不能被代理  if (target._isVue) { console.log(\u0026#39;target 是 vue 实例，不能被代理\u0026#39;) return target } // 2. Vue 的虚拟节点，其实就是一堆包含模板字符串的对象解构  // 这个是用来生成 render 构建 DOM 的，不能用来被代理  if (target._isVNode) { console.log(\u0026#39;target 是虚拟节点，不能被代理\u0026#39;) return targtet } // 限定了只能被代理的一些对象： \u0026#39;Object, Array, Map, Set, WeakMap, WeakSet`  // Object.prototype.toString.call(target) =\u0026gt; [object Object] 取 (-1, 8)  // 其实 `Object` 构造函数字符串  const toRawType = (target) =\u0026gt; Object.prototype.toString.call(target).slice(8, -1) if ( ![\u0026#39;Object\u0026#39;, \u0026#39;Array\u0026#39;, \u0026#39;Map\u0026#39;, \u0026#39;Set\u0026#39;, \u0026#39;WeakMap\u0026#39;, \u0026#39;WeakSet\u0026#39;].includes( toRawType(target) ) ) { console.log( `target 不是可代理范围对象(\u0026#39;Object\u0026#39;, \u0026#39;Array\u0026#39;, \u0026#39;Map\u0026#39;, \u0026#39;Set\u0026#39;, \u0026#39;WeakMap\u0026#39;, \u0026#39;WeakSet\u0026#39;)` ) return target } // 那些被标记为只读或者非响应式的WeakSets的值  if (rawValues.has(target)) { return target } // 被冻结的对象，是不允许任何修改操作的，不可用作响应式对象  if (Object.isFrozen(target)) { return target }     根据 target 的类型检测采用哪种类型的 handlers，集合类型使用 collectionhandlers，对象类型采用 baseHandlers\n  创建代理 new Proxy(target, handlers)\n  缓存代理源及代理结果到 toProxy, toRaw 避免出现重复代理的情况\n  返回代理对象 observed。\n  使用 reactive 为了区分两种代理类型(集合类型，普通对象(对象和数组))，这里使用两个对象(setTarget, objTarget)，创建两个代理(setObserved, objObserved)，分别传入不同的代理 handlers，代码如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35  const toProxy = new WeakMap() const toRaw = new WeakMap() const setTarget = new Set([1, 2, 3]) const objTarget = { foo: 1, bar: 2 } const setObserved = reactive(setTarget, toProxy, toRaw, null, { get(target, prop, receiver) { console.log(prop, \u0026#39;set get...\u0026#39;) // return Reflect.get(target, prop, receiver)  }, // set/map 集合类型  has(target, prop) { const ret = Reflect.has(target, prop) console.log(ret, target, prop, \u0026#39;set has...\u0026#39;) return ret } }) const objObserved = reactive( objTarget, toProxy, toRaw, { // object/arary, 普通类型  get(target, prop, receiver) { console.log(prop, \u0026#39;object/array get...\u0026#39;) return Reflect.get(target, prop, receiver) } }, {} )   输出代理的结果对象如下：console.log(setObserved, objObserved)\n结果：Proxy {1, 2, 3} Proxy {foo: 1, bar: 2}\n然后出现了错误，当我试图调用 setObserved.has(1) 的时候报错了：\n获取 setObserved.size 属性报错，不同的是 set proxy handler 有被调用，这里应该是调用 Reflect.get() 时候报错了：\ngoogle 之后这里有篇文章里给出了问题原因和解决方案\n解决方法，在 get proxy handler 里面加上判断，如果是函数就使用 target去调用：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14  const setObserved = reactive(setTarget, toProxy, toRaw, null, { get(target, prop, receiver) { switch (prop) { default: { // 如果是函数，经过代理之后会丢失作用域问题，所以要  // 重新给他绑定下作用域  console.log(prop, \u0026#39;get...\u0026#39;) return typeof target[prop] === \u0026#39;function\u0026#39; ? target[prop].bind(target) : target[prop] } } },   结果：\n Proxy {1, 2, 3} Proxy {foo: 1, bar: 2} -\u0026gt; setObserved.has(1) has get\u0026hellip; true\n baseHandlers.ts 这个文件模块出现了几个 handlers 是需要弄清楚的，比如：\nbaseHandlers.ts 里面和 Array, Object 有关的四个：\n mutableHandlers readonlyHandlers shallowReactiveHandlers, shallowReadonlyHandlers  collectionHandlers.ts 里和集合相关的两个：\n mutableCollectionHandlers readonlyCollectionHandlers  在上一节讲过 createReactiveObject 需要给出两个 handlers 作为参数，一个是针对数组和普通对象的，另一个是针对集合类型的。\n下面分别来看看两个文件中分别都干了什么？？？\n列出文件中相关的函数和属性： 属性:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  // 符号集合 const builtInSymbols = new Set(/* ... */); // 四个通过 createGetter 生成的 get 函数 const get = /*#__PURE__*/ createGetter() const shallowGet = /*#__PURE__*/ createGetter(false, true) const readonlyGet = /*#__PURE__*/ createGetter(true) const shallowReadonlyGet = /*#__PURE__*/ createGetter(true, true) // 三个数组函数 \u0026#39;includes\u0026#39;, \u0026#39;indexOf\u0026#39;, \u0026#39;lastIndexOf\u0026#39; const arrayInstrumentations: Record\u0026lt;string, Function\u0026gt; = {} // setter const set = /*#__PURE__*/ createSetter() const shallowSet = /*#__PURE__*/ createSetter(true)   函数：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  // 创建 getter 函数的函数 function createGetter(isReadonly = false, shallow = false) { /* ... */ } // 创建 setter 函数的函数 function createSetter(shallow = false) { /* ... */ } // delete obj.name 原子操作 function deleteProperty(target: object, key: string | symbol): boolean { /*...*/ } // 原子操作 key in obj function has(target: object, key: string | symbol): boolean { /* ... */ } // Object.keys(target) 操作，取对象 key function ownKeys(target: object): (string | number | symbol)[] {/*...*/}   四个要被导出的 handlers：\n1 2 3 4  export const mutableHandlers: ProxyHandler\u0026lt;object\u0026gt; = {/*...*/} export const readonlyHandlers: ProxyHandler\u0026lt;object\u0026gt; = {/*...*/} export const shallowReactiveHandlers: ProxyHandler\u0026lt;object\u0026gt; = {/*...*/} export const shallowReadonlyHandlers: ProxyHandler\u0026lt;object\u0026gt; = {/*...*/}   接下来一个个来分析分析，看看每个都有什么作用？？？\n先从 createGetter 说起吧 -\u0026gt;\n为了下面方便调试，对上面的 reactive() 进行了简化，只保留了与 handlers 有关的部分：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22  const collectionTypes = new Set([Set, Map, WeakMap, WeakSet]) function reactive(target, toProxy, toRaw, baseHandlers, collectionHandlers) { // 简化  if (typeof target !== \u0026#39;object\u0026#39;) return target //... isVue, VNode...  let observed = null const handlers = collectionTypes.has(target.constructor) ? collectionHandlers : baseHandlers observed = new Proxy(target, handlers) toProxy.set(target, observed) toRaw.set(observed, target) return observed } const toProxy = new WeakMap(), toRaw = new WeakMap()   createGetter(isReadonly = false, shallow = false) 参数：\n isReadonly = false shallow = false  简化之后的 createGetter，先用它来创建一个 get 然后创建一个 baseHandler: mutableHandlers 可变的 handlers。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27  { // 很明显这个 proxy handler get, 简化之后...  return function get(target, key, receiver) { const res = Reflect.get(...arguments) // ... 省略1，如果是数组，且是 includes, indexOf, lastIndexOf 操作  // 直接返回它对应的 res  // ... 省略2，如果是符号属性，直接返回 res  // ... 省略3, 浅 reactive，不支持嵌套  // ... 省略4，isRef 类型，判断是数组还是对象，数组执行 track(...), 对象返回 res.value  // 非只读属性，执行 track()，收集依赖  !isReadonly \u0026amp;\u0026amp; track(target, \u0026#39;get\u0026#39;, key) console.log(res, key, \u0026#39;get...\u0026#39;) // return res  // 非对象直接返回原结果，如果是对象区分只读与否  return typeof res === \u0026#39;object\u0026#39; \u0026amp;\u0026amp; res !== null ? isReadonly ? // need to lazy access readonly and reactive here to avoid  // circular dependency  res // ... readonly(res)  : reactive(res, toProxy, toRaw, mutableHandlers) : res } }   上面我们省略了暂时不关心的是哪个部分：\n 数组类型且 key 是 ['includes', 'indexOf', 'lastIndexOf'] 其中任一一个 符号属性处理 ref 类型处理  目前我们只关心如何创建 get 和一个最简单的 basehandler: mutableHandler\n使用 createGetter: get\n1 2 3 4 5 6 7 8 9 10  // 示例 1 const objTarget = { foo: 1, bar: { name: \u0026#39;bar\u0026#39; } } // 将 createGetter 生成的 get -\u0026gt; mutableHandlers 传入 reactive const objObserved = reactive(objTarget, toProxy, toRaw, mutableHandlers)   这里 get 我认为只有两个目的：\n递归 reactive，就在最后返回的时候检测 res 结果时候 这里我们首先来验证下递归 reactive 问题，即当我们访问对象中嵌套对象里面的属性时候，实际上是不会触发 get 的，我们在 createGetter 的 return 前面加上一句 return res 。\n也就是说不检测结果是不是对象，而直接返回当前取值的结果：\n =\u0026gt; objObserved.foo \u0026ldquo;foo\u0026rdquo; \u0026ldquo;get\u0026hellip;\u0026rdquo; 1 =\u0026gt; objObserved.bar {name: \u0026ldquo;bar\u0026rdquo;} \u0026ldquo;bar\u0026rdquo; \u0026ldquo;get\u0026hellip;\u0026rdquo; {name: \u0026ldquo;bar\u0026rdquo;} {name: \u0026ldquo;bar\u0026rdquo;} \u0026ldquo;bar\u0026rdquo; \u0026ldquo;get\u0026hellip;\u0026rdquo; =\u0026gt; objObserved.bar.name {name: \u0026ldquo;bar\u0026rdquo;} \u0026ldquo;bar\u0026rdquo; \u0026ldquo;get\u0026hellip;\u0026rdquo; \u0026ldquo;bar\u0026rdquo; =\u0026gt; const bar = objObserved.bar {name: \u0026ldquo;bar\u0026rdquo;} \u0026ldquo;bar\u0026rdquo; \u0026ldquo;get\u0026hellip;\u0026rdquo; undefined =\u0026gt; bar.name \u0026ldquo;bar\u0026rdquo;\n 分析上面的测试结果：\n objObserved.foo 直接取对象的成员值，触发了 proxy get objObserved.bar 取对象的对象成员，触发了 proxy get   objObserved.bar.name 取嵌套对象的成员，触发了 proxy get但请注意实际上触发 get 的是 objObserved.bar 得取值过程，因为输出的 res 是 {name: \u0026quot;bar\u0026quot;}，也就是说取 bar.name 的name时候实际并没有触发 proxy get，这说明 proxy get 只能代理一级。   为了证明代理只能代理一级，下面通过 bar = objObserved.bar 再去取 bar.name 就很明显并没有触发 proxy get  通过上面的分析，这也就是为什么要在 return 的时候去检测是不是对象，如果是对象需要进行递归 reactive的动作。\n那么，我们将 return res 注释掉再来看看结果如何：\n =\u0026gt; objObserved.foo 1 \u0026ldquo;foo\u0026rdquo; \u0026ldquo;get\u0026hellip;\u0026rdquo; 1 =\u0026gt; objObserved.bar {name: \u0026ldquo;bar\u0026rdquo;} \u0026ldquo;bar\u0026rdquo; \u0026ldquo;get\u0026hellip;\u0026rdquo; Proxy {name: \u0026ldquo;bar\u0026rdquo;} =\u0026gt; objObserved.bar.name {name: \u0026ldquo;bar\u0026rdquo;} \u0026ldquo;bar\u0026rdquo; \u0026ldquo;get\u0026hellip;\u0026rdquo; bar name get\u0026hellip; \u0026ldquo;bar\u0026rdquo; =\u0026gt; const bar = objObserved.bar {name: \u0026ldquo;bar\u0026rdquo;} \u0026ldquo;bar\u0026rdquo; \u0026ldquo;get\u0026hellip;\u0026rdquo; bar.name =\u0026gt; bar name get\u0026hellip; \u0026ldquo;bar\u0026rdquo;\n 看到差异没，首先从 objObserved.bar.name 就可看出差异了，这里首先触发的实际是 objObserved.bar 的 proxy get，此时 return 的时候发现结果是个对象，因此将 bar 传入 reactive(bar) 进一步代理，完成之后取 bar.name 的时候 bar 已经是 reactive 对象了，因此就在 {name: \u0026ldquo;bar\u0026rdquo;} \u0026ldquo;bar\u0026rdquo; \u0026ldquo;get\u0026hellip;\u0026quot; 后面紧跟着出现了bar name get\u0026hellip; 输出。\n此时，无论后面是赋值到变量 bar 再取 bar.name 结果一样会触发对应的 proxy get，毕竟对象是引用类型，类似指针一样，新增了一个变量指向它，它依旧在哪里。\n到此，最基本的 proxy get 响应式也完成了，并且能做到嵌套对象的 reactive 化，感觉相比 vue3 之前的通过 defineProperty 实现更加清晰容易理解。\n收集依赖(track) 既然有了响应式数据，那么接下来的重点就是如果利用其特性为我们做点事情，但是它又如何知道为我们做什么的，这个时候就有了所谓的“收集依赖”。\n“收集依赖”就是在 get 取值期间发生的，也就是 createGetter 中的 track() 调用时触发了依赖收集动作。\ntrack() 相关的代码在 effect.ts 中：\n函数定义：\nexport function track(target: object, type: TrackOpTypes, key: unknown){} \n有三个参数：\n target：proxy get 时候传递给 proxy 的那个对象 type: 要 track 的类型，有三种： get, has,iterate，分别是取值，检测属性存在性，以及迭代时。 Key: 针对 target 对象里面的属性，收集依赖到 targetMap -\u0026gt; depsMap -\u0026gt; dep:Set 中  简化 track(target, type)代码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27  // trackType -\u0026gt; get, has, iterate function track(target, type, key) { // ...省略1 检测 shouldTrack 和 activeEffect 标记  // 取 target 自己的依赖 map ，如果没有说明是首次，需要给它创建一个  // 空的集合，这里使用 Map 而不是 WeakMap，为的是强引用，它涉及到  // 数据的更新触发 UI 渲染，因此不该使用 WeakMap，否则可能会导致依赖丢失问题  let depsMap = targetMap.get(target) if (!depsMap) { targetMap.set(target, (depsMap = new Map())) } // 接下来对 key 取其依赖  // 如果属性的依赖不存在，说明该对象是首次使用，需要创建其依赖库  // 且这里使用了 `Set` 是为了避免重复注册依赖情况，避免数据的更新导致重复触发  // 同一个 update 情况  let dep = depsMap.get(key) if (!dep) { depsMap.set(key, (dep = new Set())) } // 注册实际的 update: activeEffect 操作  if (!dep.has(activeEffect)) { dep.add(activeEffect) activeEffect.deps.push(dep) } }   代码实现主要有三个过程：\n 检测全局的 targetMap 中是不是有 target 自己的依赖仓库(Map) 检测 depsMap = targetMap.get(target) 中是不是有取值 key 对应的依赖集合 dep 注册 activeEffect对象，然后将当前 target-key-dep 注册到 activeEffect，然后发现每个 activeEffect会有自己的 deps 保存了所有对象 key 的依赖。  收集依赖的过程如图：，执行取值 activeEffect.deps 中就会新增一个 Set\n到这里，依赖收集算是完成，但并不是很明白 activeEffect 具体是做什么的???\n既然依赖收集，要搞明白 activeEffect 是做什么的，估计的从 set 入手了，下面来实现 set 从而完成一个完整的 get -\u0026gt; dep -\u0026gt; set -\u0026gt; update 的过程。\ngo on\u0026hellip;\ncreateSetter(shallow = false) 源码简化版：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34  function createSetter(shallow = false) { // 标准的 proxy set  return function set(target, key, value, receiver) { // 取旧值  const oldValue = target[key] // 先不管 shallow mode  // 还记得 reactive 里面的 toRaw啊，对象这里就是取出  // value 的原始对象 target，前提是它有 reactive() 过  // 才会被存入到 toRaw: observed -\u0026gt; target 中  // 暂时简化成： toRaw.get(value)  value = toRaw.get(value) // ... 省略，ref 检测  const hadKey = hasOwn(target, key) // 先执行设置原子操作  const result = Reflect.set(target, key, value, receiver) // 只有对象是它自身的时候，才触发 dep-update(排除原型链)  if (target === toRaw(receiver)) { if (!hadKey) { // 新增属性操作  trigger(target, \u0026#39;add\u0026#39;, key, value) } else if (hasChanged(value, oldValue)) { // 值改变操作,排除 NaN !== NaN 情况  trigger(target, \u0026#39;set\u0026#39;, key, value, oldValue) } } return result } }   这里主要有几个操作：\n shallow mode 检测，已省略。 value = toRaw(value) 如果 value 是 observed，那么可以通过 toRaw 取出被代理之前的对象 target，还记得 reactive() 里面的那个 toRaw, toProxy 缓存操作吧。 调用 Reflect.set() 先将值设置下去，然后再考虑是否触发依赖 检测对象原型链，只有当对象是自身的时候才触发依赖 触发的行为只有两种要么是新增属性(add)，要么是更改值(set, 值不变的情况不触发)  这里有个与 createGetter 里面收集依赖 (track())对应的触发依赖函数： trigger。\n接下来就是要看看 trigger() 里面都做了啥。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60  function trigger(target, type, key, newValue, oldValue, oldTarget) { // step1: 检测是否被 track 过，没有根本就没有依赖  const depsMap = targetMap.get(target) if (!depsMap) return // step2: 将 dep 加入到 effects  // 创建两个 effects, 一个普通的，一个计算属性  const effects = new Set() const computedRunners = new Set() // 根据 effect 的选项 computed 决定是添加到那个 Set 中  const add = (effectsToAdd) =\u0026gt; effectsToAdd.forEach( (effect) =\u0026gt; (effect !== activeEffect || !shouldTrack) \u0026amp;\u0026amp; (effect.options.computed ? computedRunners.push(effect) : effects.push(effect)) ) // if ... clear  if (false) { // TODO 清空动作，触发所有依赖  } // 数组长度变化  else if (false) { // TODO 触发更长度变化有关的所有依赖  } else { // 例如： SET | ADD | DELETE 操作  if (key !== void 0) { add(depsMap.get(key)) } const isAddOrDelete = type === \u0026#39;add\u0026#39; || (type === \u0026#39;delete\u0026#39; \u0026amp;\u0026amp; !Array.isArray(target)) if (isAddOrDelete || (type === \u0026#39;set\u0026#39; \u0026amp;\u0026amp; target instanceof Map)) { // 删除或添加操作，或者 map 的设置操作  add(depsMap.get(Array.isArray(target) ? \u0026#39;length\u0026#39; : ITERATE_KEY)) } // Map 的添加或删除操作  if (isAddOrDelete \u0026amp;\u0026amp; target instanceof Map) { add(depsMap.get(MAP_KEY_ITERATE_KEY)) } } // step3: 执行 effects 中所有的 dep  const run = (effect) =\u0026gt; { // 选项提供了自己的调度器，执行自己的  if (effect.options.scheduler) { effect.options.scheduler(effect) } else { effect() } } // 触发应该触发的依赖  computedRunners.forEach(run) effects.forEach(run) }   主要有三个步骤：\n step1: 检测是否收集过依赖，如果没有说明可能没有被用过，没什么可触发的 step2: 主要是过滤收集到依赖，针对当前更改操作的所有依赖触发(add) step2: 经过第二步的依赖过滤之后，触发所有的依赖(run)  这里面有两个重要的属性(effects,computedRunners)和两个函数(add,run)\nadd: 过滤，run: 执行。\n很明显，到这里，我们还是没有解决，依赖对应的 update 是如何收集的问题，因为 set 也只是将已经收集好 dep 执行而已。\neffect.ts 该文件中主要包含三个重要函数:\n trigger(target, type, key?, newValue?, oldValue?, oldTarget?) 触发依赖函数 effect-\u0026gt;createReactiveEffect(fn, options) 转换依赖函数成ReactiveEffect类型，并且立即执行它。 track(target, type, key)  以及一些辅助函数：\n  isEffect() 检测是不是 ReactiveEffect 类型 isEffect = fn =\u0026gt; fn?._isEffect === true\n  stop(effect: ReactiveEffect) 停止 effect ，如果选项中提供了 onStop 监听该动作，执行它，重置 effect.active。\n1 2 3 4 5 6 7 8 9  export function stop(effect: ReactiveEffect) { if (effect.active) { cleanup(effect) if (effect.options.onStop) { effect.options.onStop() } effect.active = false } }     cleanup(effect: ReactiveEffect)\n1 2 3 4 5 6 7 8 9 10 11  // 在 track 的时候，加入 effect 时，对其做一次清理工作 // 保证 effect.deps 干净 function cleanup(effect: ReactiveEffect) { const { deps } = effect if (deps.length) { for (let i = 0; i \u0026lt; deps.length; i++) { deps[i].delete(effect) } deps.length = 0 } }     pauseTracking() \n1 2 3 4 5  // 暂停 track 动作 export function pauseTracking() { trackStack.push(shouldTrack) shouldTrack = false }     enableTracking() \n1 2 3 4 5  // 恢复 track 动作 export function enableTracking() { trackStack.push(shouldTrack) shouldTrack = true }     resetTracking() \n1 2 3 4 5  // 重置 track，可能 fn 执行失败了，try ... finally ... 丢弃 fn:effect 时候调用 export function resetTracking() { const last = trackStack.pop() shouldTrack = last === undefined ? true : last }     包含的属性变量：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21  // 保存着 target 对象的所有依赖的 Map \u0026lt;target, dep\u0026lt;Set\u0026gt;\u0026gt; // target -\u0026gt; Map\u0026lt;key, dep[]\u0026gt; const targetMap = new WeakMap\u0026lt;any, KeyToDepMap\u0026gt;() // effect 栈，保存所有的 fn-\u0026gt;effect const effectStack: ReactiveEffect[] = [] // 当前激活状态的 effect let activeEffect: ReactiveEffect | undefined export const ITERATE_KEY = Symbol(__DEV__ ? \u0026#39;iterate\u0026#39; : \u0026#39;\u0026#39;) export const MAP_KEY_ITERATE_KEY = Symbol(__DEV__ ? \u0026#39;Map key iterate\u0026#39; : \u0026#39;\u0026#39;) // 执行 effect 时，uid++，即每个 effect 都会有自己的唯一的 uid let uid = 0 // 记录当前 effect 的状态， let shouldTrack = true // 当前 effect -\u0026gt; shouldTack // 每增加一个 effect 记录 shouldTrack = true, push 到 trackStack // 如果 effect.raw\u0026lt;fn\u0026gt; 执行异常会 pop 掉，还原 shouldTrack -\u0026gt; last, // pop trackStack const trackStack: boolean[] = []   一直到这里我们基本完成了 reactive-\u0026gt;get-\u0026gt;set-\u0026gt;track-\u0026gt;trigger-\u0026gt;effect 一系列动作，\n也该我们测试的时候了，按正常应该会有我们想要的结果，响应式-\u0026gt;注册fn:update-\u0026gt;取值收集依赖-\u0026gt; 设置触发 fn:udpate 调用\n=\u0026raquo;\u0026raquo;\u0026raquo;\u0026raquo;\u0026gt;\n比如：\n1 2 3 4 5 6 7 8 9 10 11 12 13  const r = (target) =\u0026gt; reactive(target, toProxy, toRaw, mutableHandlers) const fn = () =\u0026gt; console.log(\u0026#39;effect fn\u0026#39;) let res = effect(fn, {}) console.log(Object.keys(res), \u0026#39;after effect\u0026#39;) let dummy const counter = r({ num: 0 }) effect(() =\u0026gt; (dummy = counter.num)) console.log(dummy, \u0026#39;before\u0026#39;) counter.num = 7 console.log(dummy, \u0026#39;after\u0026#39;)   上面的例子运行之后，并没有得到我们想要的结果！！！\n effect fn [\u0026ldquo;id\u0026rdquo;, \u0026ldquo;_isEffect\u0026rdquo;, \u0026ldquo;active\u0026rdquo;, \u0026ldquo;raw\u0026rdquo;, \u0026ldquo;deps\u0026rdquo;, \u0026ldquo;options\u0026rdquo;] \u0026ldquo;after effect\u0026rdquo; 0 \u0026ldquo;num\u0026rdquo; \u0026ldquo;get\u0026hellip;\u0026rdquo; 0 \u0026ldquo;before\u0026rdquo; 0 \u0026ldquo;after\u0026rdquo;\n 按照我们的实现，理论上 after 的结果应该是 7 才对，但结果显示依然是 0，这说明了我们调用 effect(fn) 并没有与上面的 r({ num: 0 }) 发生任何联系，即 fn 并没有被收集到 counter.num 的依赖 deps 中去，那这是为什么呢？？？\n 我们来回顾分析下之前所作工作的整个过程(reactive-\u0026gt;get-\u0026gt;set-\u0026gt;track-\u0026gt;trigger-\u0026gt;effect):\n reactive 将数据通过 proxy 转成响应式 get-\u0026gt;track 收集依赖，相关属性：targetMap, depsMap, dep, activeEffect, activeEffect.deps。 set-\u0026gt;trigger 触发依赖 update 函数，涉及到的 targetMap, depsMap, add, run effect 将 update 函数，转换成 ReactiveEffect 类型  纵观这整个过程，尤其是 get-\u0026gt;track ， set-\u0026gt;trigger -\u0026gt; effect 收集，触发和 effect 三个过程，唯一有可能让他们发生联系的应该就是这个 activeEffect 模块域里的变量，标识着当前处于激活状态的 effect，它的使用几乎贯穿了整个过程(track-\u0026gt;trigger-\u0026gt;effect，这三个函数也都在 effect.ts 中实现)。\n那么接下来\u0026hellip;\u0026hellip;\n前面都是简化之后的，现在看看完整的这三个函数实现：\ntrack(target, type, key) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25  export function track(target: object, type: TrackOpTypes, key: unknown) { if (!shouldTrack || activeEffect === undefined) { return } let depsMap = targetMap.get(target) if (!depsMap) { targetMap.set(target, (depsMap = new Map())) } let dep = depsMap.get(key) if (!dep) { depsMap.set(key, (dep = new Set())) } if (!dep.has(activeEffect)) { dep.add(activeEffect) activeEffect.deps.push(dep) if (__DEV__ \u0026amp;\u0026amp; activeEffect.options.onTrack) { activeEffect.options.onTrack({ effect: activeEffect, target, type, key }) } } }   trigger(\u0026hellip;) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88  export function trigger( target: object, type: TriggerOpTypes, key?: unknown, newValue?: unknown, oldValue?: unknown, oldTarget?: Map\u0026lt;unknown, unknown\u0026gt; | Set\u0026lt;unknown\u0026gt; ) { const depsMap = targetMap.get(target) if (!depsMap) { // never been tracked  return } const effects = new Set\u0026lt;ReactiveEffect\u0026gt;() const computedRunners = new Set\u0026lt;ReactiveEffect\u0026gt;() const add = (effectsToAdd: Set\u0026lt;ReactiveEffect\u0026gt; | undefined) =\u0026gt; { if (effectsToAdd) { effectsToAdd.forEach(effect =\u0026gt; { if (effect !== activeEffect || !shouldTrack) { if (effect.options.computed) { computedRunners.add(effect) } else { effects.add(effect) } } else { // the effect mutated its own dependency during its execution.  // this can be caused by operations like foo.value++  // do not trigger or we end in an infinite loop  } }) } } if (type === TriggerOpTypes.CLEAR) { // collection being cleared  // trigger all effects for target  depsMap.forEach(add) } else if (key === \u0026#39;length\u0026#39; \u0026amp;\u0026amp; isArray(target)) { depsMap.forEach((dep, key) =\u0026gt; { if (key === \u0026#39;length\u0026#39; || key \u0026gt;= (newValue as number)) { add(dep) } }) } else { // schedule runs for SET | ADD | DELETE  if (key !== void 0) { add(depsMap.get(key)) } // also run for iteration key on ADD | DELETE | Map.SET  const isAddOrDelete = type === TriggerOpTypes.ADD || (type === TriggerOpTypes.DELETE \u0026amp;\u0026amp; !isArray(target)) if ( isAddOrDelete || (type === TriggerOpTypes.SET \u0026amp;\u0026amp; target instanceof Map) ) { add(depsMap.get(isArray(target) ? \u0026#39;length\u0026#39; : ITERATE_KEY)) } if (isAddOrDelete \u0026amp;\u0026amp; target instanceof Map) { add(depsMap.get(MAP_KEY_ITERATE_KEY)) } } const run = (effect: ReactiveEffect) =\u0026gt; { if (__DEV__ \u0026amp;\u0026amp; effect.options.onTrigger) { effect.options.onTrigger({ effect, target, key, type, newValue, oldValue, oldTarget }) } if (effect.options.scheduler) { effect.options.scheduler(effect) } else { effect() } } // Important: computed effects must be run first so that computed getters  // can be invalidated before any normal effects that depend on them are run.  computedRunners.forEach(run) effects.forEach(run) }   effect(fn, options) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45  export function effect\u0026lt;T = any\u0026gt;( fn: () =\u0026gt; T, options: ReactiveEffectOptions = EMPTY_OBJ ): ReactiveEffect\u0026lt;T\u0026gt; { if (isEffect(fn)) { fn = fn.raw } const effect = createReactiveEffect(fn, options) if (!options.lazy) { effect() } return effect } function createReactiveEffect\u0026lt;T = any\u0026gt;( fn: (...args: any[]) =\u0026gt; T, options: ReactiveEffectOptions ): ReactiveEffect\u0026lt;T\u0026gt; { const effect = function reactiveEffect(...args: unknown[]): unknown { if (!effect.active) { return options.scheduler ? undefined : fn(...args) } if (!effectStack.includes(effect)) { cleanup(effect) try { enableTracking() effectStack.push(effect) activeEffect = effect return fn(...args) } finally { effectStack.pop() resetTracking() activeEffect = effectStack[effectStack.length - 1] } } } as ReactiveEffect effect.id = uid++ effect._isEffect = true effect.active = true effect.raw = fn effect.deps = [] effect.options = options return effect }   对比三个函数    过程 shouldTrack/activeEffect      track if (!shouldTrack || activeEffect === undefined) return    trigger add 里面有个判断：if (!shouldTrack || effect !== activeEffect)`才会继续往下执行添加操作    effect effectStack.push(effect)\nactiveEffect = effect\n// enable tracking\ntrackStack.push(shouldTrack)\nshouldTrack = true     对下面测试代码逐行分析：\n1 2 3 4 5 6 7  let dummy const counter = r({ num: 0 }) effect(() =\u0026gt; (dummy = counter.num)) console.log(dummy, counter, \u0026#39;before\u0026#39;) counter.num = 7 console.log(dummy, \u0026#39;after\u0026#39;)     const counter = r({sum: 0}) 这里将 { sum: 0 } reactive 代理之后赋值给了 counter 也就是说这个 counter 是个 Proxy：  effect(() =\u0026gt; (dummy = counter.num)) 在这里调用 effect(fn) 注册了一个 updater，里面用到了 counter.num 那么就会触发 counter.num 的 proxy get，然后会触发 track() 收集依赖: 并且我们从图中结果可知， fn 实际被立即执行了一次，这是 effect 函数里面的操作。 按预期，这里的 fn 应该会被收集到 counter.num 的 deps 中。 我们在 track() 最后加上打印\n1 2 3 4 5  if (!dep.has(activeEffect)) { dep.add(activeEffect) activeEffect?.deps?.push(dep) console.log(dep, activeEffect.deps) }   结果：即，activeEffect.deps 以及收集到了 counter.num 的依赖: Map(1) {\u0026quot;num\u0026quot; =\u0026gt; Set(1)}。   console.log(dummy, counter, 'before') 经过上面的结果分析，在第2步的时候，确实已经收集到了 counter.num 的 fn:updater，且存放到了 targetMap -\u0026gt; despMap -\u0026gt; num:Set(1) 中。 因此这里的输出内容是： 0 \u0026ldquo;num\u0026rdquo; \u0026ldquo;get\u0026hellip;\u0026quot; 没什么毛病，那继续往下，问题或许处在设置的时候???\n  counter.num = 7 最后发现问题所在，原始是个超级低级的问题(捂脸~~，没脸见人~~~)。 没有创建 set handler 并添加到 mutableHandlers 里面。 只要添加两句： const set = createSetter() 然后： const mutableHandlers = { get, set } 就能得到我们想要的结果。\n  console.log(dummy, 'after') 最后看下最终输出：1 effect(() =\u0026gt; (dummy = counter.num)) 取值时 proxy get 里面的输出\n2： 设置值为 7 之前的输出\n3： 设置值当中的输出 4： 最后一个log取值 proxy get 的输出 5： 最后 log 的输出内容\n  虽然犯了个非常低级的错误，但也正因为这个低级错误，促使自己一步步的去跟踪 get-\u0026gt;track, set-\u0026gt;trigger, effect 整个过程，从而了解了依赖收集，updater 触发原理。\n小结 1 到此一个比较完整的响应式代码也算告一段落，这里贴一下简化后可运行的完整代码(reactive.js)如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276  const hasChanged = (value, oldValue) =\u0026gt; value !== oldValue \u0026amp;\u0026amp; (value === value || oldValue === oldValue) const __DEV__ = false let shouldTrack = true const ITERATE_KEY = Symbol(__DEV__ ? \u0026#39;iterate\u0026#39; : \u0026#39;\u0026#39;) const MAP_KEY_ITERATE_KEY = Symbol(__DEV__ ? \u0026#39;Map key iterate\u0026#39; : \u0026#39;\u0026#39;) const effectStack = [] const trackStack = [] let uid = 0 const reactiveToRaw = new WeakMap() const rawToReactive = new WeakMap() // baseHandlers.ts start const get = createGetter() const set = createSetter() // 存放目标依赖的 map： target -\u0026gt; depsMap // 一个目标，有自己的一个 map 存放依赖 const targetMap = new WeakMap() let activeEffect = { _isEffect: true, id: 0, active: false, raw: null, deps: [], options: {} } function toRaw(observed) { return reactiveToRaw.get(observed) || observed } function effect(fn, options = {}) { // 如果是个 activeEffect 类型，那么其执行函数应该是 fn.raw  if (fn?._isEffect === true) { fn = fn.raw } // 接下来要创建一个 effect  const _effect = function reactiveEffect(...args) { if (!_effect.active) { // 非激活状态  return options.scheduler ? undefined : fn(...args) } if (!effectStack.includes(_effect)) { // 如果栈中不包含当前的 effect，即没有注册过该 effect  // 注册过就不需要重复注册了  // 添加前先执行清理工作 cleanup -\u0026gt; effect.deps[i].delete(effect)  try { shouldTrack = true effectStack.push(_effect) activeEffect = _effect return fn(...args) } finally { // fn 执行异常了，移除对应的 effect  effectStack.pop() const last = trackStack.pop() // 还原状态值  shouldTrack = last === undefined ? true : last // 还原当前激活的 effect  activeEffect = effectStack[effectStack.length - 1] } } } _effect.id = uid++ _effect._isEffect = true _effect.active = true _effect.raw = fn _effect.deps = [] _effect.options = options if (!options.lazy) { _effect() } return _effect } function trigger(target, type, key, newValue, oldValue, oldTarget) { // step1: 检测是否被 track 过，没有根本就没有依赖  const depsMap = targetMap.get(target) if (!depsMap) return // step2: 将 dep 加入到 effects  // 创建两个 effects, 一个普通的，一个计算属性  const effects = new Set() const computedRunners = new Set() // 根据 effect 的选项 computed 决定是添加到那个 Set 中  const add = (effectsToAdd) =\u0026gt; { effectsToAdd?.forEach( (effect) =\u0026gt; (effect !== activeEffect || !shouldTrack) \u0026amp;\u0026amp; (effect.options.computed ? computedRunners.add(effect) : effects.add(effect)) ) } // if ... clear  if (false) { // TODO 清空动作，触发所有依赖  } // 数组长度变化  else if (false) { // TODO 触发更长度变化有关的所有依赖  } else { // 例如： SET | ADD | DELETE 操作  if (key !== void 0) { add(depsMap.get(key)) } const isAddOrDelete = type === \u0026#39;add\u0026#39; || (type === \u0026#39;delete\u0026#39; \u0026amp;\u0026amp; !Array.isArray(target)) if (isAddOrDelete || (type === \u0026#39;set\u0026#39; \u0026amp;\u0026amp; target instanceof Map)) { // 删除或添加操作，或者 map 的设置操作  add(depsMap.get(Array.isArray(target) ? \u0026#39;length\u0026#39; : ITERATE_KEY)) } // Map 的添加或删除操作  if (isAddOrDelete \u0026amp;\u0026amp; target instanceof Map) { add(depsMap.get(MAP_KEY_ITERATE_KEY)) } } // step3: 执行 effects 中所有的 dep  const run = (effect) =\u0026gt; { // 选项提供了自己的调度器，执行自己的  if (effect.options.scheduler) { effect.options.scheduler(effect) } else { effect() } } // 触发应该触发的依赖  computedRunners.forEach(run) effects.forEach(run) } // trackType -\u0026gt; get, has, iterate function track(target, type, key) { if (!shouldTrack || activeEffect === undefined) return // ...省略1 检测 shouldTrack 和 activeEffect 标记  // 取 target 自己的依赖 map ，如果没有说明是首次，需要给它创建一个  // 空的集合，这里使用 Map 而不是 WeakMap，为的是强引用，它涉及到  // 数据的更新触发 UI 渲染，因此不该使用 WeakMap，否则可能会导致依赖丢失问题  let depsMap = targetMap.get(target) if (!depsMap) { targetMap.set(target, (depsMap = new Map())) } // 接下来对 key 取其依赖  // 如果属性的依赖不存在，说明该对象是首次使用，需要创建其依赖库  // 且这里使用了 `Set` 是为了避免重复注册依赖情况，避免数据的更新导致重复触发  // 同一个 update 情况  let dep = depsMap.get(key) if (!dep) { depsMap.set(key, (dep = new Set())) } // 注册实际的 update: activeEffect 操作  if (!dep.has(activeEffect)) { dep.add(activeEffect) activeEffect?.deps?.push(dep) } } function createGetter(isReadonly = false, shallow = false) { // 很明显这个 proxy handler get, 简化之后...  return function get(target, key, receiver) { const res = Reflect.get(...arguments) // ... 省略1，如果是数组，且是 includes, indexOf, lastIndexOf 操作  // 直接返回它对应的 res  // ... 省略2，如果是符号属性，直接返回 res  // ... 省略3, 浅 reactive，不支持嵌套  // ... 省略4，isRef 类型，判断是数组还是对象，数组执行 track(...), 对象返回 res.value  // 非只读属性，执行 track()，收集依赖  !isReadonly \u0026amp;\u0026amp; track(target, \u0026#39;get\u0026#39;, key) console.log(res, key, \u0026#39;get...\u0026#39;) // return res  // 非对象直接返回原结果，如果是对象区分只读与否  return typeof res === \u0026#39;object\u0026#39; \u0026amp;\u0026amp; res !== null ? isReadonly ? // need to lazy access readonly and reactive here to avoid  // circular dependency  res // ... readonly(res)  : reactive(res, toProxy, toRaw, mutableHandlers) : res } } function createSetter(shallow = false) { // 标准的 proxy set  return function set(target, key, value, receiver) { // 取旧值  const oldValue = target[key] // 先不管 shallow mode  // 还记得 reactive 里面的 toRaw啊，对象这里就是取出  // value 的原始对象 target，前提是它有 reactive() 过  // 才会被存入到 toRaw: observed -\u0026gt; target 中  // 暂时简化成： toRaw.get(value)  value = toRaw(value) // ... 省略，ref 检测  console.log(target, key, value, reactiveToRaw, \u0026#39;set\u0026#39;) const hadKey = Object.hasOwnProperty(target, key) // 先执行设置原子操作  const result = Reflect.set(target, key, value, receiver) // 只有对象是它自身的时候，才触发 dep-update(排除原型链)  if (target === toRaw(receiver)) { if (!hadKey) { // 新增属性操作  trigger(target, \u0026#39;add\u0026#39;, key, value) } else if (hasChanged(value, oldValue)) { // 值改变操作,排除 NaN !== NaN 情况  trigger(target, \u0026#39;set\u0026#39;, key, value, oldValue) } } return result } } const mutableHandlers = { get, set } // baseHandlers.ts end  const collectionTypes = new Set([Set, Map, WeakMap, WeakSet]) function reactive(target, toProxy, toRaw, baseHandlers, collectionHandlers) { // 简化  if (typeof target !== \u0026#39;object\u0026#39;) return target //... isVue, VNode...  let observed = null const handlers = collectionTypes.has(target.constructor) ? collectionHandlers : baseHandlers observed = new Proxy(target, handlers) toProxy.set(target, observed) toRaw.set(observed, target) return observed } const r = (target) =\u0026gt; reactive(target, rawToReactive, reactiveToRaw, mutableHandlers) const fn = () =\u0026gt; console.log(\u0026#39;effect fn\u0026#39;) let res = effect(fn, {}) console.log(Object.keys(res), \u0026#39;after effect\u0026#39;) // 使用示例 let dummy const counter = r({ num: 0 }) effect(() =\u0026gt; (dummy = counter.num)) console.log(dummy, counter, \u0026#39;before\u0026#39;) counter.num = 7 console.log(dummy, counter, \u0026#39;after\u0026#39;)   核心函数：\n   函数名 功能     createGetter-\u0026gt;get 创建 proxy 的 get handler，里面会调用 track 收集依赖   createSetter-\u0026gt;set 创建 proxy 的 set handler，里面会调用 trigger 触发 targetMap\u0026gt;depsMap\u0026gt;dep:Set依赖执行   track(target, type, key) 收集 target 对象或 target[key] 属性的依赖   trigger(target, type, key?, newValue?, oldValue?, oldTarget?) 触发 target 对象的依赖调用   effect(fn, options) 注册reactive属性的updater    涉及到的核心属性：\nReactiveEffect 类型定义：\n1 2 3 4 5 6 7 8 9  export interface ReactiveEffect\u0026lt;T = any\u0026gt; { (...args: any[]): T _isEffect: true id: number active: boolean raw: () =\u0026gt; T deps: Array\u0026lt;Dep\u0026gt; options: ReactiveEffectOptions }      属性名 类型 作用     activeEffect ReactiveEffect 记录当前的 effect，在 effect()注册updater的时候置为当前的 RE，在 get-\u0026gt;track 里面添加到 targetMap-\u0026gt;depsMap-\u0026gt;dep 中，且同时更新自己的 activeEffect.deps.push(dep)   effectStack Array\u0026lt;ReactiveEffect\u0026gt; 存放所有的 ReactiveEffect 的数组，也就是说页面中所有的 updater\u0026lt;ReactiveEffect\u0026gt; 都是存在这里面。但是每个 updater 执行完之后就会被移出 effectStack，因为 efffect()调用里面有个 try...finally 无论结果如何都会被 pop 掉。   shouldTrack Boolean 用来追踪当前 effect-\u0026gt;activeEffect 的状态   trackStack Array\u0026lt;Boolean\u0026gt; 用来存放当前 effect 的 shouldTrack 状态值   targetMap WeakMap 存放被 reactive 对象依赖的 Map，即：每个 target 在 targetMap 里面有自己的一个 depsMap，里面以 target =\u0026gt; \u0026lt;key, Set\u0026gt; 形式存在，key 表示 target 上的一个属性键，Set 存放了该 key 的所有依赖 dep。层级关系：targetMap:WeakMap -\u0026gt; depsMap:Map -\u0026gt; dep:Set   depsMap Map target 对象里所有属性和其依赖对应的关系集合，如：counter.num 的依赖： { \u0026quot;num\u0026quot; =\u0026gt; Set(1) }   reactiveToRaw WeakMap 作为 reactive 的第三个参数 toRaw，保存了 observed-\u0026gt;target 关系的 WeakMap。   rawToReactive WeakMap 作为 reactive 的第二个参数 toProxy，保存了 target-\u0026gt;observed 关系的 WeakMap，和 reactiveToRaw 刚好相反。   uid Number 每个 effect 都有一个唯一的 id，一直递增。    支持数组 reactive 在这之前都是在对象基础上做的测试，并没有增加数组的支持，比如：jest(所有测试用例都来自官方仓库) -\u0026gt;\n1 2 3 4 5 6 7 8 9 10 11 12 13  test(\u0026#39;嵌套的 reactives\u0026#39;, () =\u0026gt; { const original = { nested: { foo: 1 }, array: [{ bar: 2 }] } const observed = reactive(original) expect(isReactive(observed.nested)).toBe(true) expect(isReactive(observed.array)).toBe(true) expect(isReactive(observed.array[0])).toBe(true) })   测试结果：\n也就是说做到现在，并不支持数组的 reactive，这也是这节将要完善的点。\n  数组三个方法(includes, indexOf, lastIndexOf)的依赖收集：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20  // 数组三个方法的处理 const arrayInstrumentations = {} // 兼容数组三个索引方法，收集他们相关的依赖 ;[\u0026#39;includes\u0026#39;, \u0026#39;indexOf\u0026#39;, \u0026#39;lastIndexOf\u0026#39;].forEach((key) =\u0026gt; { arrayInstrumentations[key] = function (...args) { const arra = toRaw(this) for (let i = 0, l = this.length; i \u0026lt; l; i++) { track(arr, \u0026#39;get\u0026#39;, i + \u0026#39;\u0026#39;) } // 使用原始方法执行一次(有可能是 reactive 的)  const res = arr[key](...args) if (res === -1 || res === false) { // 如果结果失败，使用原始方法再执行一次  return arr[key](...args.map(toRaw)) } else { return res } } })     createGetter -\u0026gt; get 的时候增加数组支持：\n1 2 3 4 5 6 7 8 9 10  function createGetter(isReadonly = false, shallow = false) { return function get(target, key, receiver) { const targetIsArray = Array.isArray(target) if (targetIsArray \u0026amp;\u0026amp; hasOwn(arrayInstrumentations, key)) { return Reflect.get(arrayInstrumentations, key, receiver) } // ...省略  } }   到这里，我们已经可以正常收集到数组的依赖了，测试代码：\n1 2 3 4 5 6 7 8 9 10  \u0026lt;script type=\u0026#34;module\u0026#34;\u0026gt; import { reactive, effect, targetMap } from \u0026#39;./packages/reactive.js\u0026#39; let n let arr = [\u0026#39;vue\u0026#39;, \u0026#39;reactive\u0026#39;] const observed = reactive(arr) effect(() =\u0026gt; (n = observed[0])) // 这里还可以添加多个依赖，比如：effect(() =\u0026gt; (m = observed[0]))  // 这样，targetMap\u0026gt;depsMap:arr\u0026gt;dep 里面就会有两个了 [f, f]  console.log({n, targetMap}) \u0026lt;/script\u0026gt;   输出结果：\n![image-20200519095740412](/Users/simon/Library/Application Support/typora-user-images/image-20200519095740412.png)\n effect(() =\u0026gt; (n = observed[0]))会执行一次 fn ，即取了一次数组的 0 下标值，触发了 get 检测到是数组进入数组依赖收集程序arrayInstrumentations ，触发 track 收集依赖  🙆‍♂️，依赖咱收集到了，第三步就是如何去触发它们了 \u0026raquo;\u0026raquo;\n  数组的 set-\u0026gt;trigger 实际上已经支持了\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18  // 触发 updater function trigger(target, type, key, newValue, oldValue, oldTarget) { // ...  if (type === \u0026#39;clear\u0026#39;) { // ...  } else if (key === \u0026#39;length\u0026#39; \u0026amp;\u0026amp; Array.isArray(target)) { // ...  } else { // 如果是数组，传入 key 是索引值，会进入这个 if 进行依赖收集  if (key !== void 0) { // 对象属性 deps  add(depsMap.get(key)) } // ...  }   所以下面的示例：\n1 2 3 4 5 6 7 8 9 10 11  \u0026lt;script type=\u0026#34;module\u0026#34;\u0026gt; import { reactive, effect, targetMap } from \u0026#39;./packages/reactive.js\u0026#39; let n, m let arr = [\u0026#39;vue\u0026#39;, \u0026#39;reactive\u0026#39;] const observed = reactive(arr) effect(() =\u0026gt; (n = observed[0])) effect(() =\u0026gt; (m = observed[0])) observed[0] = \u0026#39;setter n\u0026#39; observed[1] = \u0026#39;setter m\u0026#39; console.log({n, m, targetMap}) \u0026lt;/script\u0026gt;   输出结果(set 数组元素值的时候出发了 dep 更新 n, m 的值)：\n   最后 jest 测试结果(失败\u0026hellip;): 原因是之前的 createGetter代码又有个问题，返回的时候检测结果的时候，递归 reactive 传递了 target，应该是 res 才对：\n1 2 3 4 5  return res \u0026amp;\u0026amp; typeof res === \u0026#39;object\u0026#39; ? isReadonly ? readonly(target) // 修正：target -\u0026gt; res  : reactive(target) // 修正：target -\u0026gt; res  : res   修正之后 jest 结果(:perfect)：\n ☁ vue-next-code-read [master] ⚡ jest PASS packages/tests/reactive/reactive.spec.js reactivity/reactive ✓ Object (4 ms) ✓ 嵌套的 reactives (1 ms)\nTest Suites: 1 passed, 1 total Tests: 2 passed, 2 total Snapshots: 0 total Time: 7.547 s Ran all test suites. ☁ vue-next-code-read [master] ⚡\n   OK，数组的 reactive 完成。\n jest 测试： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18  ☁ vue-next-code-read [master] ⚡ jest FAIL packages/__tests__/reactive/reactive.spec.js reactivity/reactive ✓ Object (5 ms) ✓ 嵌套的 reactives (1 ms) ✓ observed value should proxy mutations to original (Object) (1 ms) ✓ setting a property with an unobserved value should wrap with reactive (1 ms) ✕ observing already observed value should return same Proxy (4 ms) ✕ should not pollute original object with Proxies (2 ms) ✕ unwrap ✓ should not unwrap Ref\u0026lt;T\u0026gt; ✓ should unwrap computed refs ✕ non-observable values (36 ms) ✕ markRaw ✕ should not observe frozen objects (1 ms) shallowReactive ✕ should not make non-reactive properties reactive ✕ should keep reactive properties reactive     ✕ observing already observed value should return same Proxy (4 ms) 这个是因为 createReactiveObject()里面判断的时候判断错误：\n1 2 3  if (toRaw.has(observed)) { // 修正成：target  return target }   修改后测试通过。\n  ✕ should not pollute original object with Proxies (5 ms) 修改：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14  function createSetter(shallow = false) { return function set(target, key, value, receiver) { // 新增判断，如果是递归 reactive 设置的时候取原始值去传递给 reflect  if (!shallow) { // 比如：value 如果是 Observed，那么从 reactiveToRaw 中取 proxy  // 之前的那个 target 出来，给 reflect  value = toRaw(value) // TODO !shallow is ref  } // const res = Reflect.set(...arguments)  // 这里就不能直接 ...arguments 了，都将最新的 value 传递下去  const res = Reflect.set(target, key, value, receiver) }   修改后测试通过。\n  ✕ unwrap 是因为没有导出 toRaw 函数导致的，导入下就好了。\n  ✕ non-observable values (8 ms) 需要改些下测试用例：源码里面加了 expect -\u0026gt; toHaveBeenWarnedLast 为了更友好的提示。\n1 2 3 4 5 6 7 8  /// 修改后： expect(reactive(1)).toBe(1) expect(reactive(\u0026#39;foo\u0026#39;)).toBe(\u0026#39;foo\u0026#39;) expect(reactive(false)).toBe(false) expect(reactive(null)).toBe(null) expect(reactive(undefined)).toBe(undefined) const s = Symbol() expect(reactive(s)).toBe(s)     ✕ markRaw 在 createReactiveObject() 中增加 canObserve(target) 检测解决，因为检测中就有一项 rawValues.has(value)\n  ✕ should not observe frozen objects (1 ms) 在 createReactiveObject() 中增加 canObserve(target) 检测解决。\n  ✕ should not make non-reactive properties reactive 没导出 shallowReactive。\n  ✕ should keep reactive properties reactive\n1 2 3 4 5 6 7  // 粗心的锅，这个写反了 const shallowSet = createGetter(false, true) const shallowGet = createSetter(true) // 修正： const shallowSet = createSetter(true) const shallowGet = createSetter(false, true)     修正上述问题之后 jest 结果：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24  vue-next-code-read [master] ⚡ jest PASS packages/__tests__/reactive/reactive.spec.js reactivity/reactive ✓ Object (6 ms) ✓ 嵌套的 reactives ✓ observed value should proxy mutations to original (Object) (1 ms) ✓ setting a property with an unobserved value should wrap with reactive (1 ms) ✓ observing already observed value should return same Proxy ✓ should not pollute original object with Proxies (1 ms) ✓ unwrap ✓ should not unwrap Ref\u0026lt;T\u0026gt; (1 ms) ✓ should unwrap computed refs ✓ non-observable values (2 ms) ✓ markRaw (1 ms) ✓ should not observe frozen objects (1 ms) shallowReactive ✓ should not make non-reactive properties reactive ✓ should keep reactive properties reactive Test Suites: 1 passed, 1 total Tests: 14 passed, 14 total Snapshots: 0 total Time: 6.436 s Ran all test suites.   阶段代码链接 reactive_with_array.js 代码\nhandlers续(baseHandlers 的 delete, has, ownKeys) 前面完成了 proxy-set 和 proxy-get，这节继续完成其他的 proxy，包含：\n deleteProperty(target, key) ownKeys(target) has(target, key)  delete 在之前实现的基础上 reactive.js 增加 delete proxy，这之前先来看下现有的功能是否支持 delete 操作。\n1 2 3 4 5 6 7 8 9 10 11 12  const target = { foo: 1, bar: 2 } const n = reactive(target) let dum effect(() =\u0026gt; { console.log(\u0026#39;updating...\u0026#39;) dum = n.bar }) /* console.log(targetMap.get(target), dum, \u0026#39;map\u0026#39;) */ console.log({ dum }, \u0026#39;before\u0026#39;) delete n.bar // code 1 // n.bar = 3 // code2 console.log({ dum }, \u0026#39;after\u0026#39;)   这里先注册一个 updater，后面通过更新 n.bar 值，来触发 updater，结果：\n updating\u0026hellip; {dum: 2} \u0026ldquo;before\u0026rdquo; updating\u0026hellip; {dum: 3} \u0026ldquo;after\u0026rdquo;\n 结果如我们所料，然后把 code1 放开，注释掉 code2，理论上也会触发 updater：\n updating\u0026hellip; {dum: 2} \u0026ldquo;before\u0026rdquo; {dum: 2} \u0026ldquo;after\u0026rdquo;\n 实际结果非我们所料，因为还没实现\u0026hellip;\u0026hellip;\n接下来看下要实现 delete proxy 需要哪些步骤 \u0026raquo;\u0026raquo;\u0026raquo;\n  声明 delete proxy handler : deleteProperty\n1 2 3 4 5 6 7 8 9 10 11 12 13  // delete proxy function deleteProperty(target, key) { const hadKey = target.hasOwnProperty(key) const oldValue = target[key] // 操作先执行下去  const result = Reflect.deleteProperty(target, key) // 如果执行成功且自身存在该属性，排除原型链操作  if (result \u0026amp;\u0026amp; hadKey) { // 直接触发 updaters  trigger(target, \u0026#39;delete\u0026#39;, key, undefined, oldValue) } return result // 不能丢，必须反馈删除结果 boolean }     加入到mutableHandlers\n1 2 3 4 5  const mutableHandlers = { get, set, deleteProperty }     只要经过上面简单的两步就实现了 delete 操作代理，但执行结果却报错了(明明和源码一样啊，悲催〒▽〒!!!)\n从输出可以看到， delete 操作确实触发了 updater，最后 dum: undefined 也证明了这点。\n至于报错\u0026hellip;，(⊙o⊙)…，(⊙o⊙)…，少了个 return result 将删除操作结果返回。\nhas 1 2 3 4 5  function has(target, key) { const result = Reflect.has(target, key) track(target, \u0026#39;has\u0026#39;, key) return result }   更新 mutableHandlers:\n1 2 3 4 5 6  const mutableHandlers = { get, set, deleteProperty, has }   测试：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  const target = { foo: 1, bar: 2 } const n = reactive(target) let dum, has const updater = () =\u0026gt; { console.log(\u0026#39;updating...\u0026#39;) dum = \u0026#39;bar\u0026#39; in n } effect(updater) const dep = targetMap.get(target).get(\u0026#39;bar\u0026#39;) for (let fn of dep) { console.log(fn.raw, fn.raw === updater, \u0026#39;deps\u0026#39;) } console.log({ dum }, \u0026#39;before\u0026#39;) n.bar = 3 console.log({ dum }, \u0026#39;after\u0026#39;)   结果：\n 'bar' in n 收集依赖 updater n.bar = 3 触发 ownKeys 收集到的 updater   updating\u0026hellip; () =\u0026gt; { console.log(\u0026lsquo;updating\u0026hellip;') dum = \u0026lsquo;bar\u0026rsquo; in n } true \u0026ldquo;deps\u0026rdquo; {dum: true} \u0026ldquo;before\u0026rdquo; updating\u0026hellip; {dum: true} \u0026ldquo;after\u0026rdquo;\n ownKeys 1 2 3 4  function ownKeys(target) { track(target, \u0026#39;iterate\u0026#39;, ITERATE_KEY) return Reflect.ownKeys(target) }   更新 mutableHandlers:\n1 2 3 4 5 6 7  const mutableHandlers = { get, set, deleteProperty, has, ownKeys }   注意 ownKeys 的实现里使用到 了一个 Symbol: ITERATE_KEY，开始一直不明白 trigger 里为啥会用到这个去 depsMap.get(ITERRATE_KEY)，这里应该明白是怎么回事了，就是针对对象的迭代器操作的时候，使用到 ownKeys，需要对该操作收集依赖，那么就需要有个唯一的 key 去设置 targetMap, depsMap，这里的 ITERATE_KEY 就是这个作用，用它来收集(track)对象迭代操作的所有依赖，然后通过 trigger 里面查找这个符号值去取所有 updaters。\n测试：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17  const target = { foo: 1, bar: 2 } const n = reactive(target) let dum, has const updater = () =\u0026gt; { console.log(\u0026#39;updating...\u0026#39;) dum = Object.keys(n) // 触发依赖收集 } effect(updater) const dep = targetMap.get(target).get(ITERATE_KEY) for (let it of dep) { console.log(it.raw, it.raw === updater, \u0026#39;deps\u0026#39;) } console.log(dum, \u0026#39;before\u0026#39;) n.bar = 3 // 触发 updaters console.log(dum, \u0026#39;after\u0026#39;)   结果：\n updating\u0026hellip; {foo: 1, bar: 2} \u0026ldquo;own keys\u0026rdquo; () =\u0026gt; { console.log(\u0026lsquo;updating\u0026hellip;') dum = Object.keys(n) } true \u0026ldquo;deps\u0026rdquo; (2) [\u0026ldquo;foo\u0026rdquo;, \u0026ldquo;bar\u0026rdquo;] \u0026ldquo;before\u0026rdquo; (2) [\u0026ldquo;foo\u0026rdquo;, \u0026ldquo;bar\u0026rdquo;] \u0026ldquo;after\u0026rdquo;\n 但是发现并没有触发 updaters。\ntrigger 里面加打印结果：\n1 2 3 4 5 6 7 8 9  // 非数组的删除或添加操作 const isAddOrDelete = type === \u0026#39;add\u0026#39; || (type === \u0026#39;delete\u0026#39; \u0026amp;\u0026amp; !Array.isArray(target)) console.log({ type, key }, target instanceof Map) // 对象的属性的新增和删除，或者 Map 类型的 set 操作 if (isAddOrDelete || (type === \u0026#39;set\u0026#39; \u0026amp;\u0026amp; target instanceof Map)) { add(depsMap.get(Array.isArray(target) ? \u0026#39;length\u0026#39; : ITERATE_KEY)) }   输出 {type: \u0026quot;set\u0026quot;, key: \u0026quot;foo\u0026quot;} false 说明确实有触发 trigger，但是条件：\nif (isAddOrDelete || (type === 'set' \u0026amp;\u0026amp; target instanceof Map))\n阻止了它进入 add 收集 ITERATE_KEY 对应的依赖，因为 target 不是 Map 类型。\nTODO 为啥会这样？？？？？？？\njest 测试 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233  ☁ vue-next-code-read [master] ⚡ jest PASS packages/__tests__/reactive/reactive.spec.js FAIL packages/__tests__/reactive/effect.spec.js ● reactivity/effect › should observe iteration expect(received).toBe(expected) // Object.is equality Expected: \u0026#34;Hello World!\u0026#34; Received: \u0026#34;Hello\u0026#34; 161 | expect(dummy).toBe(\u0026#39;Hello\u0026#39;) 162 | list.push(\u0026#39;World!\u0026#39;) \u0026gt; 163 | expect(dummy).toBe(\u0026#39;Hello World!\u0026#39;) \u0026gt; | ^ \u0026gt; 164 | list.shift() \u0026gt; 165 | expect(dummy).toBe(\u0026#39;World!\u0026#39;) \u0026gt; 166 | }) at Object.\u0026lt;anonymous\u0026gt; (packages/__tests__/reactive/effect.spec.js:163:19) ● reactivity/effect › should observe implicit array length changes expect(received).toBe(expected) // Object.is equality Expected: \u0026#34;Hello World!\u0026#34; Received: \u0026#34;Hello\u0026#34; 173 | expect(dummy).toBe(\u0026#39;Hello\u0026#39;) 174 | list[1] = \u0026#39;World!\u0026#39; \u0026gt; 175 | expect(dummy).toBe(\u0026#39;Hello World!\u0026#39;) \u0026gt; | ^ \u0026gt; 176 | list[3] = \u0026#39;Hello!\u0026#39; \u0026gt; 177 | expect(dummy).toBe(\u0026#39;Hello World! Hello!\u0026#39;) \u0026gt; 178 | }) at Object.\u0026lt;anonymous\u0026gt; (packages/__tests__/reactive/effect.spec.js:175:19) ● reactivity/effect › should observe enumeration expect(received).toBe(expected) // Object.is equality Expected: 7 Received: 3 203 | expect(dummy).toBe(3) 204 | numbers.num2 = 4 \u0026gt; 205 | expect(dummy).toBe(7) \u0026gt; | ^ \u0026gt; 206 | delete numbers.num1 \u0026gt; 207 | expect(dummy).toBe(4) \u0026gt; 208 | }) at Object.\u0026lt;anonymous\u0026gt; (packages/__tests__/reactive/effect.spec.js:205:19) ● reactivity/effect › should not observe well-known symbol keyed properties expect(received).toBe(expected) // Object.is equality Expected: undefined Received: true 234 | array[key] = true 235 | expect(array[key]).toBe(true) \u0026gt; 236 | expect(dummy).toBe(undefined) \u0026gt; | ^ \u0026gt; 237 | }) \u0026gt; 238 | \u0026gt; 239 | it(\u0026#39;should observe function valued properties\u0026#39;, () =\u0026gt; { at Object.\u0026lt;anonymous\u0026gt; (packages/__tests__/reactive/effect.spec.js:236:19) ● reactivity/effect › should observe json methods expect(received).toBe(expected) // Object.is equality Expected: 1 Received: undefined 523 | }) 524 | obj.a = 1 \u0026gt; 525 | expect(dummy.a).toBe(1) \u0026gt; | ^ \u0026gt; 526 | }) \u0026gt; 527 | \u0026gt; 528 | it(\u0026#39;should observe class method invocations\u0026#39;, () =\u0026gt; { at Object.\u0026lt;anonymous\u0026gt; (packages/__tests__/reactive/effect.spec.js:525:21) ● reactivity/effect › scheduler expect(jest.fn()).toHaveBeenCalledTimes(expected) Expected number of calls: 1 Received number of calls: 0 573 | // should be called on first trigger 574 | obj.foo++ \u0026gt; 575 | expect(scheduler).toHaveBeenCalledTimes(1) \u0026gt; | ^ \u0026gt; 576 | // should not run yet \u0026gt; 577 | expect(dummy).toBe(1) \u0026gt; 578 | // manually run at Object.\u0026lt;anonymous\u0026gt; (packages/__tests__/reactive/effect.spec.js:575:23) ● reactivity/effect › events: onTrack expect(jest.fn()).toHaveBeenCalledTimes(expected) Expected number of calls: 3 Received number of calls: 0 598 | ) 599 | expect(dummy).toEqual([\u0026#39;foo\u0026#39;, \u0026#39;bar\u0026#39;]) \u0026gt; 600 | expect(onTrack).toHaveBeenCalledTimes(3) \u0026gt; | ^ \u0026gt; 601 | expect(events).toEqual([ \u0026gt; 602 | { \u0026gt; 603 | effect: runner, at Object.\u0026lt;anonymous\u0026gt; (packages/__tests__/reactive/effect.spec.js:600:21) ● reactivity/effect › events: onTrigger expect(jest.fn()).toHaveBeenCalledTimes(expected) Expected number of calls: 1 Received number of calls: 0 637 | obj.foo++ 638 | expect(dummy).toBe(2) \u0026gt; 639 | expect(onTrigger).toHaveBeenCalledTimes(1) \u0026gt; | ^ \u0026gt; 640 | expect(events[0]).toEqual({ \u0026gt; 641 | effect: runner, \u0026gt; 642 | target: toRaw(obj), at Object.\u0026lt;anonymous\u0026gt; (packages/__tests__/reactive/effect.spec.js:639:23) ● reactivity/effect › stop TypeError: (0 , _reactive2.stop) is not a function 667 | obj.prop = 2 668 | expect(dummy).toBe(2) \u0026gt; 669 | stop(runner) \u0026gt; | ^ \u0026gt; 670 | obj.prop = 3 \u0026gt; 671 | expect(dummy).toBe(2) \u0026gt; 672 | at Object.\u0026lt;anonymous\u0026gt; (packages/__tests__/reactive/effect.spec.js:669:5) ● reactivity/effect › stop with scheduler expect(received).toBe(expected) // Object.is equality Expected: 1 Received: 2 689 | ) 690 | obj.prop = 2 \u0026gt; 691 | expect(dummy).toBe(1) \u0026gt; | ^ \u0026gt; 692 | expect(queue.length).toBe(1) \u0026gt; 693 | stop(runner) \u0026gt; 694 | at Object.\u0026lt;anonymous\u0026gt; (packages/__tests__/reactive/effect.spec.js:691:19) ● reactivity/effect › events: onStop TypeError: (0 , _reactive2.stop) is not a function 704 | }) 705 | \u0026gt; 706 | stop(runner) \u0026gt; | ^ \u0026gt; 707 | expect(onStop).toHaveBeenCalled() \u0026gt; 708 | }) \u0026gt; 709 | at Object.\u0026lt;anonymous\u0026gt; (packages/__tests__/reactive/effect.spec.js:706:5) ● reactivity/effect › stop: a stopped effect is nested in a normal effect TypeError: (0 , _reactive2.stop) is not a function 714 | dummy = obj.prop 715 | }) \u0026gt; 716 | stop(runner) \u0026gt; | ^ \u0026gt; 717 | obj.prop = 2 \u0026gt; 718 | expect(dummy).toBe(1) \u0026gt; 719 | at Object.\u0026lt;anonymous\u0026gt; (packages/__tests__/reactive/effect.spec.js:716:5) ● reactivity/effect › should trigger all effects when array length is set 0 expect(received).toBe(expected) // Object.is equality Expected: 3 Received: 1 773 | 774 | observed.unshift(3) \u0026gt; 775 | expect(dummy).toBe(3) \u0026gt; | ^ \u0026gt; 776 | expect(record).toBe(3) \u0026gt; 777 | \u0026gt; 778 | observed.length = 0 at Object.\u0026lt;anonymous\u0026gt; (packages/__tests__/reactive/effect.spec.js:775:19) Test Suites: 1 failed, 1 passed, 2 total Tests: 13 failed, 49 passed, 62 total Snapshots: 0 total Time: 2.917 s, estimated 3 s Ran all test suites.   全是失败啊！！！\n还是老老实实的一个个来解决吧\u0026hellip;\u0026hellip;\n  ● reactivity/effect › should observe iteration\n数组操作失败，push 的时候没有触发 updater。\n示例：\n1 2 3 4 5 6 7 8 9 10 11  const list = reactive([\u0026#39;Hello\u0026#39;]) let dummy effect(() =\u0026gt; { console.log(\u0026#39;updating....\u0026#39;) dummy = list.join(\u0026#39; \u0026#39;) }) console.log(targetMap, \u0026#39;dep\u0026#39;) console.log(dummy, \u0026#39;1\u0026#39;) list[0] = \u0026#39;hello\u0026#39; /* list.push(\u0026#39;World!\u0026#39;) */ console.log(dummy, \u0026#39;2\u0026#39;)   结果(直接索引赋值是生效的，那么为啥 push 没用？？？)：\n updating\u0026hellip;. test.html:20 WeakMap {Array(1) =\u0026gt; Map(3)} \u0026ldquo;dep\u0026rdquo; test.html:21 Hello 1 test.html:17 updating\u0026hellip;. test.html:24 hello 2\n 在 list.push('World!') 处打个断点：\n先触发的是list 的 get push :\n然后再是触发的 length get\n触发 key: 1 的 updater，但最后没有任何依赖被发现？？？\n看最后的图发现问题，首先，数组就一个元素，长度为1，最大索引为0，在 push 之后，长度为2，最大索引为1，也就是说这个新的索引即新的 key，属于新增属性操作，应该要走到 trigger:add ，但是实际走了 trigger:set 里面去了。\n问题就在 if(!target.hasOwnProperty(key)) 这一行，它不应该取 Reflect.set(...) 之后的 target 因为这是更新之后的，肯定有 key: 1了。\n修改：\n在 Reflect.set(...) 之前先 hadKey = target.hasOwnProperty(key) 然后使用缓存的 hadKey 进行判断 if(!hadKey) {...}。\n修改之后测试通过：\n ☁ vue-next-code-read [master] ⚡ jest PASS packages/tests/reactive/reactive.spec.js PASS packages/tests/reactive/effect.spec.js\nTest Suites: 2 passed, 2 total Tests: 26 passed, 26 total Snapshots: 0 total Time: 7.645 s Ran all test suites.\n   ● reactivity/effect › should not observe well-known symbol keyed properties\njs 内置的符号属性，不能被 observe，这是因为 createGetter 里面还没完成 Symbol 类型的检测，下面加上就OK了。\n需要增加以下内容：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21  // 1. 符号类型检测 const isSymbol = (val) =\u0026gt; typeof val === \u0026#39;symbol\u0026#39; // 2. Symbol 上的所有符号属性 const builtInSymbols = new Set( Object.getOwnPropertyNames(Symbol) .map(key =\u0026gt; (Symbol)[key]) .filter(isSymbol) ) // 3. createGetter中增加判断 function createGetter(...arg) { // ...  if (isSymbol(key) \u0026amp;\u0026amp; builtInSymbols.has(key) || key === \u0026#39;__proto__\u0026#39;) { return res } // .... }   重测 jest 通过。\n  ● reactivity/effect › scheduler 真怀疑当时自己是故意的，尽是些地级错误（捂脸，🤦‍♀️，(/ω＼)）！！！\n1 2 3 4  // 修改前： // if (effect.options \u0026amp;\u0026amp; effect.options.shecduler) { // 修改后： if (effect.options \u0026amp;\u0026amp; effect.options.scheduler) {     ● reactivity/effect › events: onTrack\n  ● reactivity/effect › events: onTrigger\n两个是在 DEV 模式下才会执行的，没有完成，现在给加上去吧。\nTrack 里面，在 if dep.has 最后面增加统计事件 onTrack：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14  function track(target, type, key) { // ...  if (!dep.has(activeEffect)) { // ...  if (__DEV__ \u0026amp;\u0026amp; activeEffect.options \u0026amp;\u0026amp; activeEffect.options.onTrack) { activeEffect.options.onTrack({ effect: activeEffect, target, type, key }) } } }   Trigger 里面，在执行 updaters 的开头增加 onTrigger 事件：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19  function trigger(target, type, key, newValue, oldValue, oldTarget) { // ...  const run = (effect) =\u0026gt; { const hasOpt = !!effect.options if (__DEV__ \u0026amp;\u0026amp; hasOpt \u0026amp;\u0026amp; effect.options.onTrigger) { effect.options.onTrigger({ effect, target, key, type, newValue, oldValue, oldTarget }) } // ...  } }   加完，jest 通过。\n  ● stop 增加 stop 函数，停止 effect 行为，主要通过 effect.active，清理 effect.deps 来控制，阻止触发 deps。\n1 2 3 4 5 6 7 8 9  function stop(effect) { if (effect.active) { cleanup(effect) if (effect.options \u0026amp;\u0026amp; effect.options.onStop) { effect.options.onStop() } effect.active = false } }     到此 effect.spec.ts 中除了 ref 有关的测试用例全部测试通过，\n下面来逐个分析 \u0026raquo;\u0026gt; go go go\u0026hellip;\n测试用例结果分析 通过运行 jest --verbose 将所有用例测试结果列出：\n  ✓ should run the passed function once (wrapped by a effect) (4 ms)\n1 2 3 4 5  it(\u0026#39;should run the passed function once (wrapped by a effect)\u0026#39;, () =\u0026gt; { const fnSpy = jest.fn(() =\u0026gt; {}) effect(fnSpy) // effect() 实现里面，如果没有传 options.lazy 就会立即执行一次  expect(fnSpy).toHaveBeenCalledTimes(1) // 因此这里 fnSpy 会被调用一次  })     ✓ should observe basic properties (1 ms)\n1 2 3 4 5 6 7 8 9 10 11 12 13  it(\u0026#39;should observe basic properties\u0026#39;, () =\u0026gt; { let dummy const counter = reactive({ num: 0 }) // updater: dummy = counter.num  // 被立即调用， dummy = 0  // 由于 counter.num 触发 trigger:get ，收集dep: \u0026#39;num\u0026#39;-\u0026gt;Set(1): updater  effect(() =\u0026gt; (dummy = counter.num)) expect(dummy).toBe(0) // true  counter.num = 7 // 赋值，trigger: set 触发 updater，赋值 dummy  expect(dummy).toBe(7) // true  })     ✓ should observe multiple properties\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20  it(\u0026#39;should observe multiple properties\u0026#39;, () =\u0026gt; { let dummy // obj ={num1: 0, num2: 0}  const counter = reactive({ num1: 0, num2: 0 }) // updater: ...  // updater 被立即调用，counter 的 num1, num2 被访问，分别触发他们的 trigger:get  // 收集依赖，三次访问，三次收集同一个 updater  // 由于 targetMap -\u0026gt; depsMap -\u0026gt; dep: new Set() 是个集合类型  // 因此虽然是三次访问，但收集的都是 updater，因此每个 dep 里面保存的是同一个 updater  effect(() =\u0026gt; (dummy = counter.num1 + counter.num1 + counter.num2)) expect(dummy).toBe(0) // 首次调用 updater 时候赋值了 0 + 0 + 0 = 0  // 这里先后赋值了 num1, num2，触发了两次 updater  // first: 0 + 0 + 7  // second: 7 + 7 + 7 = 21  // 测试如下面的示例代码  counter.num1 = counter.num2 = 7 expect(dummy).toBe(21) // true  })   测试代码：\n1 2 3 4 5 6 7 8  let dummy, n = 0 const counter = reactive({ num1: 0, num2: 0 }) effect(() =\u0026gt; (n++, (dummy = counter.num1 + counter.num1 + counter.num2))) console.log({ dummy, n }, 1) counter.num1 = counter.num2 = 7 console.log({ dummy, n }, 2)   结果图示：\n depsMap 有两个 map，分别是 num1, num2， trigger: set 触发了两次，且 num2 先触发 num1 紧随其后，因为赋值操作是从右到左的顺序进行。    ✓ should handle multiple effects (1 ms)\n1 2 3 4 5 6 7 8 9 10 11 12 13 14  it(\u0026#39;should handle multiple effects\u0026#39;, () =\u0026gt; { let dummy1, dummy2 const counter = reactive({ num: 0 }) effect(() =\u0026gt; (dummy1 = counter.num)) // 收集 updater1，执行一次，dummy1 = 0  effect(() =\u0026gt; (dummy2 = counter.num)) // 收集 updater2, 执行一次，dummy2 = 0  expect(dummy1).toBe(0) // true  expect(dummy2).toBe(0) // true  // trigger:set 取出 targetMap-depsMap-num:dep:Set(2) 即 updater1, updater2  // 执行 updaters 之后，重新复制dummy1, dummy2 = 1  counter.num++ expect(dummy1).toBe(1) // true  expect(dummy2).toBe(1) // true })     ✓ should observe nested properties (1 ms) \n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20  it(\u0026#39;should observe nested properties\u0026#39;, () =\u0026gt; { let dummy // 嵌套的 reactive 是在 createReativeObject 里面完成的  // 在最后 return 结果的时候检测了是否是 isObject ，如果是进一步检测  // isReadonly 与否，非只读返回 reactive(res) 对结果递归调用一次  // 前提是没有设置shallow 标志，该标识表明只对目前的对象只做浅reactive  // 即只做对象的一级响应式，里面嵌套的对象原样返回。  // 这里调用的是 reactive 显然是递归 reactive 的。  // obj = { nested: {num: 0 }}  const counter = reactive({ nested: { num: 0 } }) // 这里会触发两次 getter，一次是 counter.nested，一次是 nested.num  // targetMap{ obj -\u0026gt; map, nested -\u0026gt; map } 存放了两个对象的映射  // obj:map -\u0026gt; \u0026#39;nested\u0026#39;:Set(1), nested:map -\u0026gt; \u0026#39;num\u0026#39;:Set(1)  // Set(1) 都是下面的 updater  effect(() =\u0026gt; (dummy = counter.nested.num)) expect(dummy).toBe(0) // true  counter.nested.num = 8 // 只会触发 \u0026#39;num\u0026#39;:Set(1)  expect(dummy).toBe(8) // true })   转测试代码结果：\n1 2 3 4 5 6 7  let dummy const counter = reactive({ nested: { num: 0 } }) effect(() =\u0026gt; (dummy = counter.nested.num)) console.log({ dummy }, 1) counter.nested.num = 7 console.log({ dummy }, 2)   ​\n1.\tLoc1 : 访问 counter.nested 收集的 `{counter:{nested:{num:0}}} -\u0026gt; Map{'nested' -\u0026gt; Set(1)}` 依赖。 2.\tLoc2: 访问 nested.num 收集的 {num:7}-\u0026gt;Map{'num'-\u0026gt;Set(1)} 依赖。 3.\tLoc2: 注意看这里，当给 counter.nested.num = 7 赋值的时候只会触发 'num' -\u0026gt; Set(1)。    ✓ should observe delete operations (1 ms)\n1 2 3 4 5 6 7 8 9 10  it(\u0026#39;should observe delete operations\u0026#39;, () =\u0026gt; { let dummy const obj = reactive({ prop: \u0026#39;value\u0026#39; }) effect(() =\u0026gt; (dummy = obj.prop)) // 收集依赖 updater  expect(dummy).toBe(\u0026#39;value\u0026#39;) // true  // 对象属性的删除操作，只会触发 trigger 里面的 if (key !== void 0) 收集依赖进 effects: []  delete obj.prop // 触发 updater 重新复制 dummy: undefined  expect(dummy).toBe(undefined) // true })     ✓ should observe has operations (1 ms)\n  ✓ should observe properties on the prototype chain (9 ms)\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31  t(\u0026#39;should observe properties on the prototype chain\u0026#39;, () =\u0026gt; { let dummy const counter = reactive({ num: 0 }) const parentCounter = reactive({ num: 2 }) Object.setPrototypeOf(counter, parentCounter) effect(() =\u0026gt; (dummy = counter.num))// 收集 updater  expect(dummy).toBe(0) // true  // 这里删除操作触发 deleteProperty proxy handler  // trigger: delete -\u0026gt; run deps -\u0026gt; 触发 updater  // 由于 updater 里面访问了 counter.num ，而 counter 自身的 num 在这时候已经被删除了  // 注意：deletePropery 里面是先执行了 Reflect.deleteProperty(...)  // 然后再触发的 trigger:delete的，因此在 updater 执行的时候 counter.num 已经不存在  // 但是根据对象属性的访问原理，会去检查原型链上父级对象的，最后会找到 parentCounter.num  // 然后取出它的值：num: 2 赋值给 dummy，所以下面 dummy toBe(2) 为 true  delete counter.num expect(dummy).toBe(2) // 这里改变 parent num 时候也会触发 updater  // 是因为上面的 delete 操作导致去检查了原型链，访问了 parentCounter.num ，这个时候  // 也相当于触发了 parentCounter.num 的 get ，收集了 updater  parentCounter.num = 4 expect(dummy).toBe(4) // true  // 这里重新复制，触发 counter.num 的 set(createSetter)，  // 检测到自身没有该属性(在Reflect.set()之前)  // 然后触发 trigger:add 增加属性的操作  // 在 trigger 里面，触发之前收集到的 updater  // (注意：counter.num 的 dep 这个时候并没有被移除的)  counter.num = 3 expect(dummy).toBe(3) })     ✓ should observe has operations on the prototype chain\n  ✓ should observe inherited property accessors (2 ms)\n访问器属性也是一样的道理。\n  ✓ should observe function call chains (1 ms)\n  ✓ should observe iteration (1 ms)\n  ✓ should observe implicit array length changes\n  ✓ should observe sparse array mutations (1 ms)\n  ✓ should observe enumeration (2 ms)\n  ✓ should observe symbol keyed properties (2 ms)\n  ✓ should not observe well-known symbol keyed properties (2 ms)\n已知的符号属性，在 createReactiveObject 里面就被过滤掉了\nif (isSymbol(res) \u0026amp;\u0026amp; builtInSymbols.has(res) || res === '__proto__')。\n  ✓ should observe function valued properties (1 ms)\n  ✓ should observe chained getters relying on this (1 ms)\n  ✓ should observe methods relying on this (1 ms)\n  ✓ should not observe set operations without a value change (1 ms)\n值没发生变化的时候不会重复触发 udpaters，createSetter 里面就已经有了判断：\nif (value !== oldValue \u0026amp;\u0026amp; (value === value || oldValue === oldValue))\n值没变不会 trigger: set，后面的是为了过滤掉 NaN 的情况。\n  ✓ should not observe raw mutations (1 ms)\ntoRaw 就是将 observed 转成原始的那个对象，就不再是响应式的了，当然不会有啥作用。\n  ✓ should not be triggered by raw mutations\n同上。\n  ✓ should not be triggered by inherited raw setters (1 ms)\n同上。\n  ✓ should avoid implicit infinite recursive loops with itself (1 ms)\n1 2 3 4 5 6 7 8 9 10 11  const counter = reactive({ num: 0 }) let n = 0 const counterSpy = () =\u0026gt; { n++ counter.num++ } effect(counterSpy) console.log(counter, n, \u0026#39;1\u0026#39;) counter.num = 4 console.log(counter, n, \u0026#39;2\u0026#39;)   运行结果：\n // 这里是 updater 里面的 counter.num++ 触发的get\n{num: 0} {type: \u0026ldquo;get\u0026rdquo;, key: \u0026ldquo;num\u0026rdquo;, shouldTrack: true, activeEffect: ƒ} \u0026ldquo;track\u0026rdquo;\n// 因为 counter.num++ 触发的 set\nMap(1) {\u0026ldquo;num\u0026rdquo; =\u0026gt; Set(1)} {type: \u0026ldquo;set\u0026rdquo;, key: \u0026ldquo;num\u0026rdquo;, newValue: 1, oldValue: 0} \u0026ldquo;trigger\u0026rdquo; Proxy {num: 1} 1 \u0026ldquo;1\u0026rdquo; // log\n// 赋值操作引发的 trigger:set\nMap(1) {\u0026ldquo;num\u0026rdquo; =\u0026gt; Set(1)} {type: \u0026ldquo;set\u0026rdquo;, key: \u0026ldquo;num\u0026rdquo;, newValue: 4, oldValue: 1} \u0026ldquo;trigger\u0026rdquo;\n// set 触发了updater -\u0026gt; trigger:get\n{num: 4} {type: \u0026ldquo;get\u0026rdquo;, key: \u0026ldquo;num\u0026rdquo;, shouldTrack: true, activeEffect: ƒ} \u0026ldquo;track\u0026rdquo;\n// counter.num++ -\u0026gt; trigger:set\nMap(1) {\u0026ldquo;num\u0026rdquo; =\u0026gt; Set(1)} {type: \u0026ldquo;set\u0026rdquo;, key: \u0026ldquo;num\u0026rdquo;, newValue: 5, oldValue: 4} \u0026ldquo;trigger\u0026rdquo; Proxy {num: 5} 2 \u0026ldquo;2\u0026rdquo;\n 好像没发现哪里拦截了，但是通过下面的例子，确实又会死循环：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26  let dummy const counter = { num: 0 } let ob function update() { // ob.num = ob.num + 1  dummy = ob.num++ console.log({ dummy }, ob) } ob = new Proxy(counter, { set(target, key, value, receiver) { const res = Reflect.set(...arguments) update() return res }, get(target, key, receiver) { return Reflect.get(...arguments) } }) ob.num = 2   node 运行之后：\n /Users/simon/github/vuejs/vue-next-code-read/test/test.js:10 dummy = ob.num++ ^\nRangeError: Maximum call stack size exceeded\n 所以肯定还是有哪里做了处理，防止死循环。\n经过一通 console.log 之后发现关键点就在 trigger 的 add 函数里面，它在查找依赖添加到将要执行的 effects 集合中的时候有两个前提条件：\n !shouldTrack effect !== activeEffect  图中输出的主要关键点在红色 部分，这里检测到正在 add 的 effect 与当前激活状态的 activeEffect 是同一个所以结束触发 trigger:set，但是为什么 shouldTrack = true 且 effect === activeEffect呢？？？\n那么就要回头去看 effect() 的具体实现了，重点在 try...finally。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  try { enableTracking() effectStack.push(_effect) activeEffect = _effect // 这里的 _effect 就是在 trigger 里用来与 activeEffect 比较的  console.log({ ..._effect }, \u0026#39;effect 1\u0026#39;) return fn(...args) // trigger set 检测 shouldTrack 和 activeEffect } finally { effectStack.pop() // 而 shouldTrck 和 activeEffect 重置工作在这里，因此阻止了 fn 里面 ++ 操作引起的死循环  // 因为 trigger -\u0026gt; add 需要检测 if (!shouldTrack || effect !== activeEffect)  // 才会将找到的 dep:updater 加入到 run 要执行的 effects: [] 中去  resetTracking() activeEffect = effectStack[effectStack.length - 1] console.log({ ..._effect }, \u0026#39;effect 2\u0026#39;) }   这段代码含义如下：\n  当执行 effect(updater) 时，执行上面的一段代码。\n  enableTracking() 只要知道它是将 shouldTrack = true 了。\n  接下来缓存，赋值 effect\n  重点来了，执行 updater，这里执行的 updater里面是 counter.num++ 会依次触发 get -\u0026gt; set\nGet 就是收集依赖，同一个 updater 只会有一个 (Set(1))。\nSet 这里会触发 trigger:set 那么这里会检测 shouldTrack 和 activeEffect，但是这个时候两者的值并没有重置，也就是说告诉 trigger， effect(updater) 我还没执行完呢，你不能重复 trigger:set，但是我什么时候才能继续 trigger呢？？？这就是下面第5条该做的事情了。\n  finally 在 udpater 首次执行完成之后恢复shouldTrack 和activeEffect的值，从而继续完成 effect(updater) 的任务直到 finally 的代码执行完毕。\n  即这个问题的关键点在于 4和5，正是这里的逻辑防止了 updater 里面导致 set 死循环。\n  ✓ should allow explicitly recursive raw function loops (1 ms)\n1 2 3 4 5 6 7 8 9 10 11 12  it(\u0026#39;should allow explicitly recursive raw function loops\u0026#39;, () =\u0026gt; { const counter = reactive({ num: 0 }) const numSpy = jest.fn(() =\u0026gt; { counter.num++ if (counter.num \u0026lt; 10) { numSpy() } }) effect(numSpy) expect(counter.num).toEqual(10) expect(numSpy).toHaveBeenCalledTimes(10) })   有了前面一个测试用例的分析，这里的原理就一目了然了。\n首先 counter.num++ 还是会因为 effect(updater) 没有完全结束而中断，只会执行一次 +1 操作。\n紧跟着的 if 相当于在 try { return fn(...args) } } 返回结果之前又调用了下自己，也就是说 num+1 会执行知道 num = 10 ，所以最后结果是 num=10, updater 被调用了 10，才进入了 effect -\u0026gt; finally 结束当前的 effect()。\n  ✓ should avoid infinite loops with other effects (1 ms)\n原理如上上。\n  ✓ should return a new reactive version of the function (1 ms)\n因为 effect(fn) 最终都会被封装成 ReactiveEffect 类型的对象，所以肯定不相等了。\n  ✓ should discover new branches while running automatically (1 ms)\n  ✓ should discover new branches when running manually (1 ms)\n这两个原理都一样，在于 ?: 执行的时候根据条件的真假是否有触发 get。\n  ✓ should not be triggered by mutating a property, which is used in an inactive branch (1 ms)\n  ✓ should not double wrap if the passed function is a effect (1 ms)\nfunction effect(fn) 的第一句就是为了防止这种情况发生，检测是不是 _isEffect ，是的话会将 fn = fn.raw 提取出来。\n  ✓ should not run multiple times for a single mutation (1 ms)\n  ✓ should allow nested effects (4 ms)\n不管嵌套不嵌套只要 effect 完整执行完成，就能顺利的进行下一个 effect()。\n  ✓ should observe json methods\n1 2 3 4 5 6 7 8 9  let dummy = {} const obj = reactive({}) effect(() =\u0026gt; { dummy = JSON.parse(JSON.stringify(obj)) }) console.log(targetMap, dummy, \u0026#39;before\u0026#39;) /* obj.a = 1 */ /* console.log(targetMap, dummy, \u0026#39;after\u0026#39;) */   注释最后两行，看输出\n注意这里的一个迭代器为 key 的 dep，也就是 JSON.stringify(obj) 的时候说明有对 obj 进行遍历(迭代器操作，触发了 ownKeys proxy handler)。\n去看下 https://tc39.es/ecma262/ JSON.stringify 实现原理：\n 最后一步： Return ? SerializeJSONProperty(state, the empty String, wrapper). 进入到 SerializeJSONProperty\nStep2: 检测到是对象会去取它 的 toJson 值，这也就是为什么 最后收集到的依赖 depsMap 里面会有一个 key 为 toJSON 的项了：\nType(value) is Object or BigInt, then\n Let toJSON be ? GetV(value, \u0026ldquo;toJSON\u0026rdquo;).  然后检测到是对象会进入：SerializeJSONObject ( state, value )\n  let partial be a new empty List.\n  For each elemen P of K , do\n  // 这里会有一个迭代器操作，遍历对象属性，触发 ITERATE_KEY 依赖收集\n Let strP be ? SerializeJSONProperty(state, P, value).   结果就是说 JSON.stringify 会有对 obj 有迭代器操作，触发了 ownkeys proxy handler 调用 track:ITERATE_KEY 触发收集依赖。\n  ✓ should observe class method invocations (1 ms)\n  ✓ lazy (5 ms)\n  ✓ scheduler (1 ms)\n  ✓ events: onTrack (1 ms)\n  ✓ events: onTrigger (3 ms)\n  ✓ stop (1 ms)\n  ✓ stop with scheduler (2 ms)\n来看下 stop 结合 scheduler 调度器是如何使用的。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35  it(\u0026#39;stop with scheduler\u0026#39;, () =\u0026gt; { let dummy const obj = reactive({ prop: 1 }) const queue = [] const runner = effect( () =\u0026gt; { // updater  dummy = obj.prop // 这里会立即执行一次收集依赖  }, { scheduler: (e) =\u0026gt; queue.push(e) } ) // 这里设置触发 trigger:set，但是因为有 scheduler 的存在，所以没有立即调用 effect  // 而是执行了 scheduler 将 effect 推入了队列 queue  obj.prop = 2 // 所以这里还是 1  expect(dummy).toBe(1) // true  // 因为上面的赋值触发 scheduler 缘故  expect(queue.length).toBe(1) // true  // 清理依赖，targetMap-\u0026gt;depsMap-\u0026gt;dep 里面的所有依赖清理掉  // 且 effect.active = false  stop(runner) // a scheduled effect should not execute anymore after stopped  // 这里执行的其实是 updater -\u0026gt; ReactiveEffect 化之后的 effect  // 但是在 stop 之后 effect.active 已经是 FALSE 了  // 所以会直接检测到 effect.options.scheduler 存在，返回 undefined  // 真正 try 里面的 执行 fn:updater 实际没有到。所以这里相当于什么都没干  queue.forEach((e) =\u0026gt; e()) // 所以这里值也就不会有任何变化了  // 如果要这里 updater 被调用只要去掉 stop 那句即可，active = true 进入正常  // 的 effect{try...finaylly} 执行流程触发 updater  expect(dummy).toBe(1) }     ✓ events: onStop (1 ms)\n  ✓ stop: a stopped effect is nested in a normal effect (1 ms)\n  ✓ markRaw (1 ms)\n  ✓ should not be trigger when the value and the old value both are NaN (1 ms)\n  ✓ should trigger all effects when array length is set 0 (1 ms)\n  阶段代码链接：reactive_with_effect_spec_passed_js 代码\n小结 2 又是一个周一了，周末又荒废中度过\u0026hellip;\u0026hellip;，回顾下之前的内容(顺序按照当时实现前后顺序排列)：\nreactive - createReactiveObject  参数： [target, toProxy, toRaw, baseHandlers, collectionHandlers]； new Proxy(target, handlers)； 根据类型选择 handlers ，集合类型(Map, Set)用collection，其他对象类型用 base； 缓存 proxy-target 结果(toProxy: target -\u0026gt; observed, toRaw: observed -\u0026gt; target)； 过滤条件(已经 proxy 或 toProxy 中已经存在的不用重复 new )； 非对象判断，能 proxy 的必须是引用类型； 过滤掉 5 中非法情况(_isVue, _isVNode, rawValues, isFrozen, 非 observable 五种情况)。  createGetter 取值，递归 reactive，调用 track 收集依赖，数组检测(includes, indexOf, lastIndex 特殊处理)，等等。\n 参数： [isReadonly, shallow]； Reflect.get() 先取值 判断结果是不是引用类型，如果是调用 reactive 将结果转响应式(嵌套的对象) 检测是不是只读，如果是就返回只读版本(其实差别就是在 handlers) shallow = true 情况，只 reactive 对象一级(嵌套不处理) 非只读情况调用 track() 收集依赖 检测 key 是不是数组的三个索引方法(includes, indexOf, lastIndexOf)，单独处理(arrayInstrumentations)  createSetter 设置，调用 trigger 触发 deps(targetMap -\u0026gt; depsMap -\u0026gt; dep)，返回 Reflect.set() 结果。\n  参数：[shallow]\n  oldValue = target[key]\n  事先 hasOwnProperty 检测，缓存结果(添加属性的时候需要)\n  调用 Reflect.set(...) 设置下去\n  调用 trigger(target, type, key, newValue, oldValue, oldTarget) 触发 deps\n  增加条件判断，不是什么情况都可以调用 trigger的\na) target - receiver 必须是对应关系\nb) hasOwn 检测结果失败则为 add 操作，否则为 set 操作，且 set 操作必须是在值发生改变的情况(排除 NaN)\n  track createGetter 里面调用，用来收集依赖的，依赖都存储在 targetMap 里面，分为两级，\n第一级是 Map{target -\u0026gt; Map} 类型\n第二级也是 Map{key -\u0026gt; Set(deps)}\n 参数：[target, type, key] 从 targetMap 中取 depsMap 该 target 对象对应的所有依赖仓库，没有就初始化 new Map() 从 depsMap 取对应 key 的所有依赖仓库 dep，没有就初始化 new Set() 检测依赖是否存在(activeEffect)，确保不会重复添加 dep.add(activeEffect) -\u0026gt; activeEffect.deps.push(dep) 增加判断，如果当前 activeEffect 未具备收集条件(shouldTrack: true, activeEffect不为空)，就退出依赖收集。  trigger createSetter 里调用来，触发依赖调用的，主要包含两个内部函数(add, run)：\nAdd: 将于当前要 update 的 deps 收集到一个内部变量 effects: Set() 里。\nRun: 使用 run去执行 effects 里面的 dep\n  参数： [target, type, key, newValue, oldValue, oldTarget]\n  检测 targetMap -\u0026gt; target 没有依赖直接退出\n  实现 add，添加条件：shouldTrack = false, effect !== activeEffect 这两个条件能防止栈溢出的问题(比如在 effect(fn) 的 fn 里面做 ob.prop++ 操作，之前有分析。)\n  使用 add 收集 deps，三种情况\na) 如果 type: clear 将所有 depsMap 添加进去\nb) 如果 key: length 且 target 是数组，说明是数组的增加和删除操作，将 depsMap 中 key 为 \u0026lsquo;length\u0026rsquo; 或者 key \u0026gt; newValue 情况的 dep 添加\nc) 其他为对象情况处理(Map类型或Object操作)\n  最后去执行 run，flush 掉所有 deps(effects, computedEffects)。\n  effect 构造 dep 类型 ReactiveEffect，其中包含 [_isEffect, active, raw, deps, options, id]类型的对象。\n 参数：[fn, options] 检测 fn._isEffect 如果本身已经是个 ReactiveEffect，取出 fn = fn.raw，重新封装 定义 _effect 函数，所以 vue3 里面每个 dep 都是一个函数类型，上面追加了若干参数 _effect 函数的实现重点是 effectStack 和 try\u0026hellip;finally，try 里面 enable effect 执行 fn，finally 里面 disable effect。所以这里结合 trigger 里面的 shouldTrack 和 activeEffect 判断来协同防止栈溢出问题。 _effect 上追加 ReactiveEffect 必备的参数。 执行一次 _effect() (前提是没有设置 options.lazy 属性为 true)  ownKeys, has, delete 这三个的实现非常简单\n ownKeys 调用 track 收集依赖 has 调用 track 收集依赖 delete 调用 trigger 触发 delete 操作 最后都要返回对应的 Reflect\u0026hellip; 操作结果  其他 到此，第一阶段的工作基本已经完成了，我们也得到了一个基本可以跑起来，作用起来的 reactive 。\n接下的内容主要有以下几点：\n 集合类型的 collectionHandlers 实现，之前都是实现了 baseHandlers，既然 vue3 中独立成两个文件了，肯定有不小的差别，但是有了之前的基础，相信理解 collectionHandlers 不会那么困难。 ref 的实现，这块目前进度几乎为0️⃣，有待研究。 最后就是其他几个测试用例文件的测试了。  漫漫源码路其修远兮，吾将前后左右以贯之，加油파이팅🤜🤛！！！\n书大坐阵，稳~~~~~~\n更新(2020-05-25 10:54:40) 前两天更新了下 vue 仓库源码，发现有不小的改动，这里提前把这些改动合并到之前的阅读上去，以防止后面越走越远，导致越难合并。\n 5a3b44ca master origin/master chore: fix typo in comment (#1217) 2b2beb91 build(deps-dev): bump @types/puppeteer from 2.1.0 to 2.1.1 8e945c97 build(deps-dev): bump @microsoft/api-extractor from 7.8.1 to 7.8.2 91c4e9b8 build(deps-dev): bump rollup from 2.10.4 to 2.10.5 96a9d5c6 build(deps-dev): bump rollup from 2.10.2 to 2.10.4 42e48b83 build(deps-dev): bump @types/jest from 25.2.2 to 25.2.3 32b3f78a v3.0.0-beta.14 release: v3.0.0-beta.14\n 本节约定：\n 先列出变更对比代码 未变更的篇幅较多的代码将省略，如注释：// \u0026hellip;. 省略  reactive.ts 首先新增了两个类型：   ReactiveFlags 枚举对象，用来记录对象特征的，比如：是否只读等等\n1 2 3 4 5 6 7 8  export const enum ReactiveFlags { skip = \u0026#39;__v_skip\u0026#39;, isReactive = \u0026#39;__v_isReactive\u0026#39;, isReadonly = \u0026#39;__v_isReadonly\u0026#39;, raw = \u0026#39;__v_raw\u0026#39;, reactive = \u0026#39;__v_reactive\u0026#39;, readonly = \u0026#39;__v_readonly\u0026#39; }     Target 接口类型\n1 2 3 4 5 6 7 8 9 10 11  // 会发现这个和上面的 ReactiveFlags 是相对应的，上面的 enum 代表的是 key 值字符串 // 这里声明了一个 Target 类型，里面包含的就是上面所有 key 字符串对应值为 boolean 的一个对象 // 都是些标识，标识这对象的各种特性 interface Target { __v_skip?: boolean __v_isReactive?: boolean __v_isReadonly?: boolean __v_raw?: any __v_reactive?: any __v_readonly?: any }     canObserve 实现变化 更新后\n1 2 3 4 5 6 7 8 9  // 就是把三种非法类型(_isVue, _isVNode, rawValues)进行合并了，使用一个__v_skip 来检测 // 所以关键我们要关注的将是这个 __v_skip 是在哪里给初始化的值(预想应该是在 createGetter 里面) const canObserve = (value: Target): boolean =\u0026gt; { return ( !value.__v_skip \u0026amp;\u0026amp; isObservableType(toRawType(value)) \u0026amp;\u0026amp; !Object.isFrozen(value) ) }   更新前\n1 2 3 4 5 6 7 8 9  const canObserve = (value) =\u0026gt; { return ( !value._isVue \u0026amp;\u0026amp; !value._isVNode \u0026amp;\u0026amp; isObservableType(toRawType(value)) \u0026amp;\u0026amp; !rawValues.has(value) \u0026amp;\u0026amp; !Object.isFrozen(value) ) }   reactive(target) 更新后\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  export function reactive(target: object) { // if trying to observe a readonly proxy, return the readonly version.  // 变化1 ： 使用了 __v_isReadonly 代替了 readonlyToRaw: WeakMap  if (target \u0026amp;\u0026amp; (target as Target).__v_isReadonly) { return target } // 变化2：这里现在只需要四个参数了，将 toProxy 和 toRaw 合并了？？？  // 只能后面再说了  return createReactiveObject( target, false, mutableHandlers, mutableCollectionHandlers ) }   更新前\n1 2 3 4 5 6 7 8 9 10 11 12 13 14  // reactivity start function reactive(target) { if (readonlyToRaw.has(target)) { return target } return createReactiveObject( target, rawToReactive, reactiveToRaw, mutableHandlers, mutableCollectionHandlers ) }   createReactiveObject(target, isReadonly, baseHandlers, collectionHandlers) 去掉了 toProxy 和 toRaw，改成了 isReadonly，所以针对这个函数的更新，需要探究去掉这两者之后是如何实现该功能的，或者没有该功能了？？？\n更新后：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49  // 变化1：参数变少了 function createReactiveObject( target: Target, isReadonly: boolean, baseHandlers: ProxyHandler\u0026lt;any\u0026gt;, collectionHandlers: ProxyHandler\u0026lt;any\u0026gt; ) { if (!isObject(target)) { if (__DEV__) { console.warn(`value cannot be made reactive: ${String(target)}`) } return target } // target is already a Proxy, return it.  // exception: calling readonly() on a reactive object  // 变化2：直接通过两个 __v_raw 和 __v_isReactive 过滤  if (target.__v_raw \u0026amp;\u0026amp; !(isReadonly \u0026amp;\u0026amp; target.__v_isReactive)) { return target } // 变化3：直接返回对应的 target 版本  // target already has corresponding Proxy  // 这里应该是直接返回了 target 上的只读和reactive 版本  // 所以这里就必然存在一个行为，将只读和 reactive 版本赋值到 __v_readonly，__v_reactive  // 两个属性上去，继续\u0026gt;\u0026gt;\u0026gt;  if ( hasOwn(target, isReadonly ? ReactiveFlags.readonly : ReactiveFlags.reactive) ) { return isReadonly ? target.__v_readonly : target.__v_reactive } // only a whitelist of value types can be observed.  // 这里就不说了，变动存在于 canObserve 函数内部  if (!canObserve(target)) { return target } const observed = new Proxy( target, collectionTypes.has(target.constructor) ? collectionHandlers : baseHandlers ) // 变化4：使用了 def 函数，估计缓存target两个版本，就是在这里实现的  // 本次更新重点应该就是这个 def 了，离真相越来越近了......  def( target, isReadonly ? ReactiveFlags.readonly : ReactiveFlags.reactive, observed ) return observed }   更新前：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38  // 变化1：参数变少了 function createReactiveObject( target, toProxy, toRaw, baseHandlers, collectionHandlers ) { if (!target || typeof target !== \u0026#39;object\u0026#39;) { return target } // 变化2  let observed = toProxy.get(target) if (observed !== void 0) { return observed } if (toRaw.has(target)) { return target } // 变化2 end  // 变化3：... 新增  if (!canObserve(target)) { return target } const handlers = collectionTypes.has(target.constructor) ? collectionHandlers : baseHandlers observed = new Proxy(target, handlers) // 变化4：使用 def 代替  toProxy.set(target, observed) toRaw.set(observed, target) return observed }   下面就不继续更了，都是些小函数围绕 def, Target, ReactiveFlags 的更新。\nbaseHandlers.ts createGetter(isReadonly = false, shallow = false)  更新后(只有一个变化，标识性属性的读取处理)：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14  function createGetter(isReadonly = false, shallow = false) { return function get(target: object, key: string | symbol, receiver: object) { // 变化1：新增对标识性的属性读取，vue 给增加的一些属性  if (key === ReactiveFlags.isReactive) { return !isReadonly } else if (key === ReactiveFlags.isReadonly) { return isReadonly } else if (key === ReactiveFlags.raw) { return target } const targetIsArray = isArray(target) // ... 为了节省篇幅，未变化的就省略吧，后续的也如此 }   更新前：\n1 2 3 4 5 6 7 8 9  function createGetter(isReadonly = false, shallow = false) { return function get(target, key, receiver) { // 变化1：新增  /* ... */ const targetIsArray = Array.isArray(target) // ... 为了节省篇幅，未变化的就省略吧，后续的也如此 }   effect.ts 变量及类型声明变更：\n1 2 3  type Dep = Set\u0026lt;ReactiveEffect\u0026gt; // 新增 Dep 类型 type KeyToDepMap = Map\u0026lt;any, Dep\u0026gt; // 新增对象的 key -\u0026gt; Dep const targetMap = new WeakMap\u0026lt;any, KeyToDepMap\u0026gt;()   jest 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44  ☁ vue-next-code-read [master] jest FAIL packages/__tests__/reactive/reactive.spec.js (5.447 s) ● reactivity/reactive › markRaw expect(received).toBe(expected) // Object.is equality Expected: false Received: true 106 | }) 107 | expect(isReactive(obj.foo)).toBe(true) \u0026gt; 108 | expect(isReactive(obj.bar)).toBe(false) \u0026gt; | ^ \u0026gt; 109 | }) \u0026gt; 110 | \u0026gt; 111 | test(\u0026#39;should not observe frozen objects\u0026#39;, () =\u0026gt; { at Object.\u0026lt;anonymous\u0026gt; (packages/__tests__/reactive/reactive.spec.js:108:33) FAIL packages/__tests__/reactive/effect.spec.js (5.589 s) ● reactivity/effect › markRaw expect(received).toBe(expected) // Object.is equality Expected: 0 Received: 1 744 | expect(dummy).toBe(0) 745 | obj.foo.prop++ \u0026gt; 746 | expect(dummy).toBe(0) \u0026gt; | ^ \u0026gt; 747 | obj.foo = { prop: 1 } \u0026gt; 748 | expect(dummy).toBe(1) \u0026gt; 749 | }) at Object.\u0026lt;anonymous\u0026gt; (packages/__tests__/reactive/effect.spec.js:746:19) Test Suites: 2 failed, 2 total Tests: 2 failed, 59 passed, 61 total Snapshots: 0 total Time: 9.857 s Ran all test suites.   这两个原因其实都是因为 canObserve 还没更新过来，修改如下：\n1 2 3 4 5 6 7  const canObserve = (value) =\u0026gt; { return ( !value.__v_skip \u0026amp;\u0026amp; isObservableType(toRawType(value)) \u0026amp;\u0026amp; !Object.isFrozen(value) ) }   重新 jest 通过：\n ☁ vue-next-code-read [master] ⚡ jest PASS packages/tests/reactive/reactive.spec.js (5.311 s) PASS packages/tests/reactive/effect.spec.js (5.429 s)\nTest Suites: 2 passed, 2 total Tests: 61 passed, 61 total Snapshots: 0 total Time: 9.612 s Ran all test suites. ☁ vue-next-code-read [master] ⚡\n Reactive.js\n collectionHandlers.ts 也该开始集合类型支持了，这部分的修改主要集中在这个文件里面，因为之前 reactive.ts, effect.ts 里面都已经把集合类型代码合并进去了(其实除了 trigger 里面有部分的 map 相关区分之后，绝大部分都是一样的)。\n这里可能得做个事情，如果还想坚持使用一个 js 文件来完成功能，那只能考虑使用作用域对象来处理了，即将 baseHandlers 和 collectionHandlers 分别用单独一个对象来承载，因为里面的函数名都是同一个，不然就只能拆分成多个文件了。\n思考中 ☡☡☡☡☡☡☡☡☡☡☡☡☡☡☡☡☡☡☡☡☡\u0026hellip;\u0026hellip;\n还是拆分吧，和 vue 源码结构保持一致，增加 reactive 目录来承载。\n分离之后的目录备份 bakups/reactive_files_v\n下面进入正题 \u0026raquo;\u0026raquo;\u0026raquo;\u0026raquo;\n新建 collectionHandlers.js 用来定义集合类型有关的 proxy handlers。\n把 reactive.js 里面的\n1 2 3 4  // TODO export const mutableCollectionHandlers = {} export const readonlyCollectionHandlers = {} export const shallowCollectionHandlers = {}   移到 collectionHandler.js 里，这节接下来所有的工作都是为了构建这三个 handlers。\n将按 get -\u0026gt; set -\u0026gt; size -\u0026gt; add -\u0026gt; deleteEntry -\u0026gt; has -\u0026gt; clear 顺序来一步步实现。\n准备工作 有了 baseHandlers.ts 实现的基础，就没必要再那么详细的步骤去实现了，这里将所有准备工作做足，主要就是一些基础变量的声明，在理解它的基础上先声明好，而不是用的时候再去声明。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34  // reactive 化 const toReactive = \u0026lt;T extends unknown\u0026gt;(value: T): T =\u0026gt; isObject(value) ? reactive(value) : value // readonly reactive const toReadonly = \u0026lt;T extends unknown\u0026gt;(value: T): T =\u0026gt; isObject(value) ? readonly(value) : value // shallow reactive const toShallow = \u0026lt;T extends unknown\u0026gt;(value: T): T =\u0026gt; value // 取原型原子操作 Reflect const getProto = \u0026lt;T extends CollectionTypes\u0026gt;(v: T): any =\u0026gt; Reflect.getPrototypeOf(v) // 三个 handlers 对应的 instrumentations const mutableInstrumentations: Record\u0026lt;string, Function\u0026gt; = {/*...*/} const shallowInstrumentations: Record\u0026lt;string, Function\u0026gt; = {/*...*/} const readonlyInstrumentations: Record\u0026lt;string, Function\u0026gt; = {/*...*/} // 集合类型几个迭代方法和迭代器 const iteratorMethods = [\u0026#39;keys\u0026#39;, \u0026#39;values\u0026#39;, \u0026#39;entries\u0026#39;, Symbol.iterator] // 三个 handlers 只需要一个 get ???????????? export const mutableCollectionHandlers: ProxyHandler\u0026lt;CollectionTypes\u0026gt; = { get: createInstrumentationGetter(false, false) } export const shallowCollectionHandlers: ProxyHandler\u0026lt;CollectionTypes\u0026gt; = { get: createInstrumentationGetter(false, true) } export const readonlyCollectionHandlers: ProxyHandler\u0026lt;CollectionTypes\u0026gt; = { get: createInstrumentationGetter(true, false) }   createInstrumentationGetter 由于三个 handlers 都是由这个生成的，所以我们不得不以这个函数作为切入点。\n在这之前必须的完成准备工作，把需要的变量都实现准备好。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34  // proxy handlers 对象 const mutableInstrumentations = {} const shallowInstrumentations = {} const readonlyInstrumentations = {} function createInstrumentationGetter(isReadonly, shallow) { // 决定使用哪种类型的 instru...  const instrumentations = shallow ? shallowInstrumentations : isReadonly ? readonlyInstrumentations : mutableInstrumentations // Reflect.get 类型的 proxy handler  return (target, key, receiver) =\u0026gt; { switch (key) { case ReactiveFlags.isReactive: return !isReadonly case ReactiveFlags.isReadonly: return isReadonly case ReactiveFlags.raw: return target default: break } } // 难道集合类型的 proxy handler 统统走的都是 proxy get ???  return Reflect.get( hasOwn(instrumentations, key) \u0026amp;\u0026amp; key in target ? instrumentations : target, key, receiver ) }   这里对于集合类型只提供一个 get proxy handler 和之前碰到过的报错 VM1029:1 Uncaught TypeError: Method Map.prototype.get called on incompatible receiver [object Object] 问题是一样的，网上说的是丢失了作用域，看报错的提示也确实是这个原因。\n根源在于你使用 observed-\u0026gt;Map 的时候，需要通过 observed.get() 去调用，但 observed 是个 Proxy 类型，在 proxy handler 里面 Reflect 需要调用的又是 Map 类型上面的 get 方法(因为它是 target 的原子操作啊)，因此就出现了 Proxy -\u0026gt; 调用 Map.prototype.get 导致失败报错 。\n要解决这个问题，最简单是改变 Reflect.get 的调用作用，如：\n1 2 3 4 5 6 7 8 9 10 11  var m = new Map([ [\u0026#39;foo\u0026#39;, 1], [\u0026#39;bar\u0026#39;, 2] ]) var ob = new Proxy(m, { get(target, key, receiver) { console.log({ key }, target, \u0026#39;111 get proxy\u0026#39;) return Reflect.get.call(target, target, key, receiver) } })   既然现在知道了 map 的操作都需要通过 get 来进行进一步\u0026quot;代理\u0026rdquo;，createInstrumentationGetter 也实现了，这个也很简单，就是根据特性判断采用那一个 instrumentations，然后返回 Reflect.get 结果，中间加上了 ReactiveFlags 的一些判断而已。\n三个 handlers ：\n1 2 3 4 5 6 7 8 9  export const mutableCollectionHandlers = { get: createInstrumentationGetter(false, false) } export const readonlyCollectionHandlers = { get: createInstrumentationGetter(true, false) } export const shallowCollectionHandlers = { get: createInstrumentationGetter(false, true) }   get(target, key, wrap) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  function get(target, key, wrap) { target = toRaw(target) const rawKey = toRaw(key) console.log({ target, key, rawKey }, \u0026#39;get\u0026#39;) if (key !== rawKey) { track(target, \u0026#39;get\u0026#39;, key) } track(target, \u0026#39;get\u0026#39;, rawKey) const { has, get } = getProto(target) if (has.call(target, key)) { return wrap(get.call(target, key)) } else if (has.call(target, rawKey)) { return wrap(get.call(target, rawKey)) } }   测试：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18  var or = new Map([ [\u0026#39;foo\u0026#39;, 1], [\u0026#39;bar\u0026#39;, 2] ]) var ob = reactive(or) console.log(isReactive(ob), \u0026#39;is reactive\u0026#39;) console.log(or instanceof Map, \u0026#39;or is map\u0026#39;) console.log(ob instanceof Map, \u0026#39;ob is map\u0026#39;) console.log(\u0026#39;=============================\u0026#39;) let dummy effect(() =\u0026gt; { dummy = ob.get(\u0026#39;key\u0026#39;) }) console.log({ dummy }, \u0026#39;1\u0026#39;) ob.set(\u0026#39;foo\u0026#39;, 2)   结果：\n注意看 createInstrumentationGetter 返回的箭头函数里返回的值：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14  return Reflect.get( hasOwn(instrumentations, key) \u0026amp;\u0026amp; key in target ? instrumentations : target, key, receiver ) // 上面的假设是 mutableInstrumentations，那么上面的代码就相当于 // 假设调用的是 observed.get(key, ...)，那么第二个参数 key = \u0026#39;get\u0026#39; return Reflect.get({ get() { /* mutableInstrumentations 里面的 get 方法*/ } }, \u0026#39;get\u0026#39;, receiver)   经过上面的转换之后就比较有意思了，不管你通过 observed 调用什么方法，最终都会被转成 Reflect.get 取值操作，而取值的关键在于两点：\n 被取值的对象这里就是我们真正定义的 proxy handler 对象，里面包含了指定特性需要的函数 key 为 observed 调用的那个方法名称，必须取值 observed.get 那么 key 就是 \u0026lsquo;get\u0026rsquo;，observed.set ，那么 key 就是 \u0026lsquo;set\u0026rsquo;  最终 observed.get \u0026mdash;\u0026gt; 其实就是 mutableInstrumentations.get 。\nTODO 疑问？？   Get 里的 两次 toRaw 是啥意思？？？\n1 2 3 4 5 6 7 8 9  function get(target, key, wrap) { // 这里为啥要取两次 toRaw，然后可能会触发两次 track???  target = toRaw(target) const rawKey = toRaw(key) if (key !== rawKey) { track(target, \u0026#39;get\u0026#39;, key) } track(target, \u0026#39;get\u0026#39;, rawKey) }     在实现 get 的时候 vue 源码里是这样的： get(this: MapTypes, ...) 但实际这种语法在 js 中肯定是不支持的\n然后自己就改写了下：\n1 2 3 4 5 6 7  // proxy handlers 对象 const mutableInstrumentations = { get(scope, key) { return get(this, key, toReactive) }, set }   结果发现不太对：\n1 2 3 4 5 6 7 8 9 10 11 12 13  var or = new Map() var ob = reactive(or) let dummy effect(() =\u0026gt; { dummy = ob.get(\u0026#39;key\u0026#39;) console.log({ dummy }, \u0026#39;effect\u0026#39;) }) console.log({ dummy }, \u0026#39;1\u0026#39;) /* ob.set(\u0026#39;key\u0026#39;, \u0026#39;value\u0026#39;) */ /* console.log({ dummy }, \u0026#39;2\u0026#39;) */ console.log(targetMap.get(or))   结果：\n这里收集的依赖的 key 竟然是 undefined，也就是说传入给 get(target, key, wrap) 的 key 丢失了。\n虽然知道原因：就是上面的 mutableInstrumentations 的 get 多了一个参数啊，这貌似哪里不太对，无奈去看了下 vue.global.js 打包之后的代码，才发现端倪。\n1 2 3 4 5 6 7 8 9 10 11 12 13  // 打包之后的 get const readonlyInstrumentations = { get(key) { // 请看这里，打包之后第一个 this 没有了  return get$1(this, key, toReadonly) }, } // 打包之前的 get，ts语法 const mutableInstrumentations: Record\u0026lt;string, Function\u0026gt; = { get(this: MapTypes, key: unknown) { return get(this, key, toReactive) } }   由于 js 是不支持用 this 做函数参数的，所以只能从 TypeScript 去方向着手了\u0026hellip;\u0026hellip;，然后，然后就有了结果：\nts 中的 this 作为函数第一个参数的语法说明\n被圈圈的两个单词是关键，它就是个假的参数，作用也就是让函数能声明它被调用的那个对象是什么类型，因此也就明白为何打包之前和打包之后代码的差异了。\n所以该问题解决方法就是去掉第一个参数，只有一个参数 key ，如：\n1 2 3 4 5 6  const mutableInstrumentations = { get(key) { return get(this, key, toReactive) }, set }     set(this, key, value) 弄清楚 TypeScript 的 this argument 之后，解决了 get 也就解决了 set 问题了。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34  function set(key, value) { value = toRaw(value) // 取调用 set 的那个对象，取出它原型上的 has, get, set，  // 也就是 target: Map  const target = toRaw(this) const { has, get, set } = getProto(target) let hadKey = has.call(target, key) if (!hadKey) { // key 是不是有可能也是个 observed ???  // Map 的 key 不仅限于普通类型，可以是任意类型  key = toRaw(key) // 那么重新取一次值  hadKey = has.call(target, key) } else if (__DEV__) { // TODO  } // 取旧值  const oldValue = get.call(target, key) // 把值设置到 observed 之前的对象上，可参考下面的结果图  const result = set.call(target, key, value) // 下面就是跟 basehandler 一样的增加或设置操作了  if (!hadKey) { trigger(target, \u0026#39;add\u0026#39;, key, value) } else if (hasChanged(value, oldValue)) { trigger(target, \u0026#39;set\u0026#39;, key, value, oldValue) } // 记得返回设置结果  return result }   测试：\n1 2 3 4 5 6 7 8 9 10 11 12  var or = new Map() var ob = reactive(or) let dummy effect(() =\u0026gt; { dummy = ob.get(\u0026#39;key\u0026#39;) }) console.log({ dummy }, \u0026#39;1\u0026#39;) ob.set(\u0026#39;key\u0026#39;, \u0026#39;value\u0026#39;) console.log({ dummy }, \u0026#39;2\u0026#39;) console.log(targetMap.get(or))   结果：\n有了 get 和 set 实现打基础下面的实现就🌾渠成了，但革命还未成功，依旧需要努力谨慎，🐩🐩🐩\u0026hellip;\u0026hellip;\nsize(target) Map 的 size 属性是一个原型是上的属性： Map.prototype.size， 至于为什么要用ITERATE_KEY 那就需要看下\n这里了\n实现的时候是需要对 Map 进行迭代的(for [key, value] of map)，因此会触发 iterate 行为来收集依赖。\n1 2 3 4 5 6  function size(target) { target = toRaw(target) track(target, \u0026#39;iterate\u0026#39;, ITERATE_KEY) // size 是在 Map 原型上的一个属性  return Reflect.get(getProto(target), \u0026#39;size\u0026#39;, target) }   更新 mutableInstrumentations:\n1 2 3 4 5 6 7 8 9 10  // proxy handlers 对象 const mutableInstrumentations = { get(key) { return get(this, key, toReactive) }, set, get size() { return size(this) } }   add(value) 限于 Set 类型使用，但是为啥不加个判断呢？？？\n1 2 3 4 5 6 7 8 9 10 11  function add(value) { value = toRaw(value) const target = toRaw(this) const proto = getProto(target) // Set.prototype ....  const hadKey = proto.has.call(target, value) // Set.prototype.has  const result = proto.add.call(target, value) // Set.prototype.add  if (!hadKey) { trigger(target, \u0026#39;add\u0026#39;, value, value) } return result }   测试\n1 2 3 4 5 6 7 8 9 10 11 12  var or = new Set() var ob = reactive(or) const fn = () =\u0026gt; {} let dummy effect(() =\u0026gt; { dummy = ob.has(fn) }) console.log({ dummy }, \u0026#39;before\u0026#39;) ob.add(fn) console.log({ dummy }, \u0026#39;after\u0026#39;)   结果：\n {dummy: false} \u0026ldquo;before\u0026rdquo; {dummy: true} \u0026ldquo;after\u0026rdquo;\n deleteEntry(key) Map/Set.prototype.delete 的 proxy handler\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19  function deleteEntry(key) { const target = toRaw(this) const { has, get, delete: del } = getProto(target) const hadKey = has.call(target, key) if (!hadKey) { key = toRaw(key) hadKey = has.call(target, key) } else if (__DEV__) { // TODO  } const oldValue = get ? get.call(target, key) : undefined const result = del.call(target, key) if (hadKey) { trigger(target, \u0026#39;delete\u0026#39;, key, undefined, oldValue) } return result }   测试\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18  var or = new Map() var ob = reactive(or) const fn = () =\u0026gt; {} let dummy effect(() =\u0026gt; { dummy = ob.has(fn) }) console.log({ dummy }, \u0026#39;before\u0026#39;) // false ob.set(fn, true) // 增加，触发 fn -\u0026gt; updater console.log({ dummy }, \u0026#39;after\u0026#39;) // true ob.clear() // 清空，trigger: clear console.log({ dummy }, \u0026#39;cleared\u0026#39;) // false ob.set(fn, false) // trigger: add console.log({ dummy }, \u0026#39;add\u0026#39;) // true ob.delete(fn) // trigger: delete console.log({ dummy }, \u0026#39;deleted\u0026#39;) // false   结果\n {dummy: false} \u0026ldquo;before\u0026rdquo; {dummy: true} \u0026ldquo;after\u0026rdquo; {dummy: false} \u0026ldquo;cleared\u0026rdquo; {dummy: true} \u0026ldquo;add\u0026rdquo; {dummy: false} \u0026ldquo;deleted\u0026rdquo;\n has(key) 1 2 3 4 5 6 7 8 9 10 11  function has(key) { const target = toRaw(this) const rawKey = toRaw(key) if (key !== rawKey) { track(target, \u0026#39;has\u0026#39;, key) } track(target, \u0026#39;has\u0026#39;, rawKey) const has = getProto(target).has return has.call(target, key) || has.call(target, rawKey) }\t  测试：\n1 2 3 4 5 6 7 8 9 10 11 12  var or = new Map() var ob = reactive(or) let dummy, has effect(() =\u0026gt; { dummy = ob.size has = ob.has(\u0026#39;a\u0026#39;) }) console.log({ dummy, has }, \u0026#39;before\u0026#39;) ob.set(\u0026#39;a\u0026#39;, 1) // 改变了 size console.log({ dummy, has }, \u0026#39;after\u0026#39;)   结果：\n {dummy: 0, has: false} \u0026ldquo;before\u0026rdquo; {dummy: 1, has: true} \u0026ldquo;after\u0026rdquo;\n clear() 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  function clear() { const target = toRaw(this) const hadItems = target.size !== 0 const oldTarget = __DEV__ ? target instanceof Map ? new Map(target) : new Set(target) : undefined const result = getProto(target).clear.call(target) if (hadItems) { trigger(target, \u0026#39;clear\u0026#39;, undefined, undefined, oldTarget) } return result }   测试\n1 2 3 4 5 6 7 8 9 10 11 12 13 14  var or = new Set() var ob = reactive(or) const fn = () =\u0026gt; {} let dummy effect(() =\u0026gt; { dummy = ob.has(fn) }) console.log({ dummy }, \u0026#39;before\u0026#39;) ob.add(fn) console.log({ dummy }, \u0026#39;after\u0026#39;) ob.clear() console.log({ dummy }, \u0026#39;cleared\u0026#39;)   结果\n {dummy: false} \u0026ldquo;before\u0026rdquo; {dummy: true} \u0026ldquo;after\u0026rdquo; {dummy: false} \u0026ldquo;cleared\u0026rdquo;\n forEach(isReadonly, shallow) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  return function forEach(callback, thisArg) { const observed = this const target = toRaw(observed) const wrap = isReadonly ? toReadonly : shallow ? toShallow : toReactive !isReadonly \u0026amp;\u0026amp; track(target, \u0026#39;iterate\u0026#39;, ITERATE_KEY) // 封装的目的：  // 1. 确保在 thisArg 作用域下调用  // 2. 确保传递给 callback 的值都是 creative 的  function wrappedCallback(value, key) { return callback.call(thisArg, wrap(value), wrap(key), observed) } return getProto(target).forEach.call(target, wrappedCallback) }   测试\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18  var or = new Map() var ob = reactive(or) const fn = () =\u0026gt; {} let dummy effect(() =\u0026gt; { ob.forEach((key, val) =\u0026gt; { dummy++ }) }) console.log({ dummy }, 0) ob.set(1, 1) console.log({ dummy }, 1) ob.set(2, 2) console.log({ dummy }, 2) ob.set(3, 3) console.log({ dummy }, 3)   未实现之前结果\n {dummy: 0} 0 {dummy: 0} 1 {dummy: 0} 2 {dummy: 0} 3\n 实现之后结果\n {dummy: 0} 0 {dummy: 1} 1 {dummy: 3} 2 {dummy: 6} 3\n 三个小矮人(handlers, createIterableMethod) 只读操作的 handlers ：\n1 2 3 4 5 6 7 8 9 10 11 12 13  // 只读函数，会改变对象的操作均不响应 function createReadonlyMethod(type) { return function (...args) { if (__DEV__) { const key = args[0] ? `on key \u0026#34;${args[0]}\u0026#34; ` : `` console.warn( `${type}operation ${key}failed: target is readonly.`, toRaw(this) ) } return type === \u0026#39;delete\u0026#39; ? false : this } }   三个小主人公：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43  // proxy handlers 对象 const mutableInstrumentations = { get(key) { return get(this, key, toReactive) }, set, get size() { return size(this) }, has, add, clear, delete: deleteEntry, forEach: createForEach(false, false) } const shallowInstrumentations = { get(key) { return get(this, key, toShallow) }, get size() { return size(this) }, has, add, set, delete: deleteEntry, clear, forEach: createForEach(false, true) } const readonlyInstrumentations = { get(key) { return get(this, key, toReadonly) }, get size() { return size(this) }, has, add: createReadonlyMethod(\u0026#39;add\u0026#39;), set: createReadonlyMethod(\u0026#39;set\u0026#39;), delete: createReadonlyMethod(\u0026#39;delete\u0026#39;), clear: createReadonlyMethod(\u0026#39;clear\u0026#39;), forEach: createForEach(true, false) }   针对迭代器操作，创建迭代器代理 handler:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37  function createIterableMethod(method, isReadonly, shallow) { return function (...args) { const target = toRaw(this) const isMap = target instanceof Map // 检测是不是 Set 或 Map，Map迭代的时候返回的是for [key, value] of map  // Set 迭代的时候返回的时候是 for value of set  // Object.entries()  const isPair = method === \u0026#39;entries\u0026#39; || (method === Symbol.iterator \u0026amp;\u0026amp; isMap) // Object.keys()  const isKeyOnley = method === \u0026#39;keys\u0026#39; \u0026amp;\u0026amp; isMap // 取出原生的 迭代器  const innerIterator = getProto(target)[method].apply(target, args) // 嵌套 reactive  const wrap = isReadonly ? toReadonly : shallow ? toShallow : toReactive // 触发迭代器 收集依赖  !isReadonly \u0026amp;\u0026amp; track(target, \u0026#39;iterate\u0026#39;, isKeyOnley ? MAP_KEY_ITERATE_KEY : ITERATE_KEY) return { // 封装一层，迭代器的两个必备条件：1. next()，2. Symbol.iterator 必须实现  next() { // 原本的迭代器  const { value, done } = innerIterator.next() return done ? { value, done } : { // 处理 entries 或 keys, values，对嵌套的对象进行 reactiv  value: isPair ? [wrap(value[0]), wrap(value[1])] : wrap(value), done } }, // 可迭代对象实现基础  [Symbol.iterator]() { return this } } } }   测试\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  var or = new Map() var ob = reactive(or) const fn = () =\u0026gt; {} let keys, values, entries effect(() =\u0026gt; { keys = ob.keys() values = ob.values() entries = ob.entries() }) console.log(keys.next(), values.next(), entries.next(), 0) ob.set(\u0026#39;a\u0026#39;, 1) console.log(keys.next(), values.next(), entries.next(), 1)   结果\njest 结果：\n ☁ vue-next-code-read [master] ⚡ jest PASS packages/tests/reactive/reactive.spec.js PASS packages/tests/reactive/effect.spec.js PASS packages/tests/reactive/collection/WeakSet.spec.js PASS packages/tests/reactive/collection/Map.spec.js PASS packages/tests/reactive/collection/WeakMap.spec.js PASS packages/tests/reactive/collection/Set.spec.js\nTest Suites: 6 passed, 6 total Tests: 132 passed, 132 total Snapshots: 0 total Time: 5.278 s Ran all test suites.\n 分析\n  ✓ instanceof (3 ms)\n注意 Proxy 之后的 observed 的 proto 值是 Map ，所以对 observed 使用 instanceof Map(查找原型链) 结果肯定是 true。\n  ✓ should observe mutations (2 ms)\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22  it(\u0026#39;should observe mutations\u0026#39;, () =\u0026gt; { let dummy const map = reactive(new Map()) effect(() =\u0026gt; { // 这里触发的是 map 对象的 \u0026#39;get\u0026#39; proxy handler  // key = \u0026#39;get\u0026#39;, 最后通过 Reflect.get(instrumentations{...}, \u0026#39;get\u0026#39;, receiver)  // 即最后调用 \u0026#39;get\u0026#39; 方法的是 instrumentations 这些对象  // 如： mutableInstrmentations 的 get(key) { return get(this, key, toReactive) }  // 然后 get(key) 的 key = \u0026#39;key\u0026#39;，传递给 `get(this, ...)`  // 然后在 get(this, ...) 里面通过 call-\u0026gt;proto 去调用原型上的方法，解决作用域丢失的问题  dummy = map.get(\u0026#39;key\u0026#39;) }) expect(dummy).toBe(undefined) // true  // 调用的是 instrumentations 的 set =\u0026gt; set(this, ...)  map.set(\u0026#39;key\u0026#39;, \u0026#39;value\u0026#39;) // map{\u0026#39;key\u0026#39; =\u0026gt; \u0026#39;value\u0026#39;}, trigger: add  expect(dummy).toBe(\u0026#39;value\u0026#39;) // true  map.set(\u0026#39;key\u0026#39;, \u0026#39;value2\u0026#39;) // trigger: set  expect(dummy).toBe(\u0026#39;value2\u0026#39;) // true  map.delete(\u0026#39;key\u0026#39;) // trigger: delete  expect(dummy).toBe(undefined) })     ✓ should observe mutations with observed value as key (1 ms)\n1 2 3 4 5 6 7 8 9 10 11 12 13  let dummy const key = reactive({}) const value = reactive({}) const map = reactive(new Map()) effect(() =\u0026gt; { dummy = map.get(key) }) expect(dummy).toBe(undefined) map.set(key, value) // 用 observe 对象作为 key 和 value expect(dummy).toBe(value) // true，都是引用类型，非值传递 map.delete(key) expect(dummy).toBe(undefined)     ✓ should observe size mutations (1 ms)\n  ✓ should observe for of iteration (2 ms)\n  ✓ should observe forEach iteration (1 ms)\n  ✓ should observe keys iteration (3 ms)\n  ✓ should observe values iteration (3 ms)\n  ✓ should observe entries iteration (5 ms)\n  ✓ should be triggered by clearing (3 ms)\n  ✓ should not observe custom property mutations (6 ms)\n  ✓ should not observe non value changing mutations (4 ms)\n  ✓ should not observe raw data (1 ms)\n  ✓ should not pollute original Map with Proxies (7 ms)\n  ✓ should return observable versions of contained values (1 ms)\n  ✓ should observed nested data (2 ms)\n  ✓ should observe nested values in iterations (forEach) (1 ms)\n  ✓ should observe nested values in iterations (values) (1 ms)\n  ✓ should observe nested values in iterations (entries) (2 ms)\n  ✓ should observe nested values in iterations (for\u0026hellip;of) (2 ms)\n  ✓ should not be trigger when the value and the old value both are NaN (1 ms)\n  ✓ should work with reactive keys in raw map (1 ms)\n  ✓ should track set of reactive keys in raw map\n  ✓ should track deletion of reactive keys in raw map (1 ms)\n  ✓ should warn when both raw and reactive versions of the same object is used as key\n  ✓ should not trigger key iteration when setting existing keys (4 ms)\n  小结 这节工作也基本完成了，所有 collection 相关的四个测试用例都测试通过，说明代码照抄(🤦‍♂️)的结果也正常。那现在也应该基本了解对于集合类型的 proxy 处理，vue 是怎么个实现的。\n首先，proxy 是没有提供和集合类型有关的原子操作代理的，所以直接使用 new Proxy(map) 是没法实现我们想要的功能的，同时也会出现方法应用不当的报错(丢失方法的作用域了，把 Map.prototype.method 的方法应用到了 Proxy 类型)。\n为了解决这个问题，vue 里面 collection 有关的操作全部都是通过 get proxy 代理来实现，下面是几个关键点和疑问点：\n  所有接口全部使用 get proxy 通道转发，调用 Reflect.get(instrumentations, key, receiver)\n  在所有的实际 proxy handler里面(如：set, get, delete, \u0026hellip;)，解决作用域问题，取target 上的原型方法\n  并且所有的原型上的方法(如：has, get, set)都通过 has.call(target) 解决调用域的问题\n  Key 和 rawKey 的问题(get 中)，直接看测试代码分析🥵\n1 2 3 4 5 6 7 8 9 10 11 12 13  const key1 = {} const key11 = reactive(key1) const ob = reactive(new Map()) let n1, n2 effect(() =\u0026gt; { n1 = ob.get(key1) n2 = ob.get(key11) }) ob.set(key1, \u0026#39;1\u0026#39;) console.log({ n1, n2 }, ob, \u0026#39;1\u0026#39;) ob.set(key11, \u0026#39;11\u0026#39;) console.log({ n1, n2 }, ob, \u0026#39;2\u0026#39;)   结果\nGet 源码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  // key -\u0026gt; \u0026#39;key11\u0026#39; function get(target, key, wrap) { target = toRaw(target) // 这里会对 key 有个 toRaw 操作，就是针对 key 是 proxy 的可能  // 最后 key11 传进来实际 rawKey = key1，并且触发 track 的时候  // rawKey 是必定会触发的，这保证了 key 非 proxy 时的能正常收集依赖  // 而 key !== rawKey -\u0026gt; trigger: get-key 就是针对 proxy key11 的情况也会  // 触发 track:get 收集依赖，因为 proxy key11 肯定是不会等于 key1 的。  // 所以 key1, key11 在 map.get(key1) 或 map.get(key11) 的时候都能正常收集到依赖  const rawKey = toRaw(key) if (key !== rawKey) { track(target, \u0026#39;get\u0026#39;, key) } track(target, \u0026#39;get\u0026#39;, rawKey) // ... }   然后在 set 的时候：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18  function set(key, value) { // ...  // 这一段操作就是为了确保，key1 和 proxy key11 都能正确取到依赖  // 所以说 get 里面的 rawKey 和 key 的操作和这里的 toRaw 操作是相对应的  // 如果没有 get 里的 rawKey-key 操作，这里如果传入 proxy key11 就不会有依赖触发  // 因为 get 里面根本不会触发 track:get  // 如果 set 这里不加这一段处理，就算 get-track:get 了，这里也会找不到 proxy key11 导致  // 会触发非正常的 trigger:add 操作。  let hadKey = has.call(target, key) if (!hadKey) { key = toRaw(key) hadKey = has.call(target, key) } else if (__DEV__) { // TODO  } // ... }     为什么 key1 和 toReactive(key1) 后的 key11 前后 set 会改变 key1 对应的值？？？\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19  const key1 = {} const key2 = {} const ob = reactive(new Map()) ob.set(key1, \u0026#39;1\u0026#39;) // 这里 key1 被转成了 Proxy，在 createIterableMethod 里面做的 // 返回 iterable 的 next() 里面的行为，会把所有 value 都变成 wrap(value) // reactive 的，下面的 key11 其实就是 key1 经过 reactive 之后的 proxy const key11 = ob.keys().next().value // 验证 key11 与 key1 关系的猜测： // console.log(key11, key1, toRaw(key11) === key1) // code1  // 验证 key11 与 key1 关系的猜测： console.log(toRaw(key11) === key1, ob, \u0026#39;1\u0026#39;) // 然后我们将 key11 作为 key 设置给 ob ob.set(key11, \u0026#39;11\u0026#39;) console.log(toRaw(key11) === key1, ob, \u0026#39;11\u0026#39;)   直接看结果图：\n把 code1 注释掉，加上下面的代码，看下结果:\n修正：“命名” -\u0026gt; “明明”。\n也就是说我们通过设置 key1 的 proxy 版本 key11 却能让 key1 的值发生变化。那得分析分析这是为什么了？？？原因其实很简单，请看 set(key, value) 源码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21  // key -\u0026gt; key11, value -\u0026gt; \u0026#39;11\u0026#39; function set(key, value) { // ...  // 首先是检测有没有 key11，咦，发现没有诶，  // 那有没可能它是个 proxy ???  let hadKey = has.call(target, key) if (!hadKey) { // 好吧，那就还原下吧，取出 proxy 之前的那个 target  key = toRaw(key) // 返现 key11 你不就是 key1 转过来的吗？？？  // key1 我有啊 ，所以这里的 hadKey 就成了 true  // key 就成了 key1  hadKey = has.call(target, key) } else if (__DEV__) { // TODO  } // 因此下面其实就是通过 proxy:key11 的原版 key1 去触发 trigger: set \t// ... }   更直观点的测试：\n1 2 3 4 5 6 7 8 9 10  const key1 = {} const key11 = reactive(key1) const ob = reactive(new Map()) ob.set(key1, \u0026#39;1\u0026#39;) // 验证 key11 与 key1 关系的猜测： console.log(toRaw(key11) === key1, ob, \u0026#39;1\u0026#39;) // 然后我们将 key11 作为 key 设置给 ob ob.set(key11, \u0026#39;11\u0026#39;) console.log(toRaw(key11) === key1, ob, \u0026#39;11\u0026#39;)     ref.ts 前面已经完成了 reactive 模块大部分且最基本的功能了，这节将完成剩余两大块computed 和 ref 其中的 ref.ts，\n来揭露其真实的面目。\nRef 类型定义(unique symbol 类型定义)：\n1 2 3 4 5 6 7 8  declare const RefSymbol: unique symbol // Ref 类型主要有两个属性，一个 值为 true 的唯一的符号属性 // 一个是 value 值 export interface Ref\u0026lt;T = any\u0026gt; { [RefSymbol]: true value: T }   内容列表    变量/函数 描述     convert(val) 将对象转成 reactive   isRef(r) 判断是不是 Ref 类型，依据是 r.__v_isRef 标识的值   ref(value) 创建 Ref 类型，调用 createRef(value)   shallowRef(value) 创建 Ref 类型，调用 createRef(value, true)   createRef(rawValue, shallow) 创建 Ref 类型   triggerRef(ref: Ref) trigger Ref 的 value 值变更 deps   unref(ref) 取消 Ref，即返回 ref.value 原始值   customRef(factory) 由创建者去定义 get, set 应该做哪些事情   toRefs(object) 将对象的所有 key 的值转成 Ref   toRef(object, key) 被 toRefs 调用    完整的 ref.js(除了类型定义，不到100行，🐂👃)\n源码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89  import { isObject, hasChanged } from \u0026#39;../util.js\u0026#39; import { reactive, isProxy, toRaw, collectionTypes } from \u0026#39;./reactive.js\u0026#39; import { track, trigger, __DEV__ } from \u0026#39;./effect.js\u0026#39; export const convert = (val) =\u0026gt; (isObject(val) ? reactive(val) : val) export function ref(value) { return createRef(value) } export function shallowRef(value) { return createRef(value, true) } // get track, set trigger export function createRef(rawValue, shallow = false) { if (isRef(rawValue)) { return rawValue } let value = shallow ? rawValue : convert(rawValue) const r = { __v_isRef: true, get value() { track(r, \u0026#39;get\u0026#39;, \u0026#39;value\u0026#39;) return value }, set value(newVal) { if (hasChanged(toRaw(newVal), rawValue)) { rawValue = newVal value = shallow ? newVal : convert(newVal) trigger(r, \u0026#39;set\u0026#39;, \u0026#39;value\u0026#39;, __DEV__ ? { newValue: newVal } : void 0) } } } return r } // 手动触发 ref: set export function triggerRef(ref) { trigger(ref, \u0026#39;set\u0026#39;, \u0026#39;value\u0026#39;, __DEV__ ? { newValue: ref.value } : void 0) } export function isRef(r) { return r ? r.__v_isRef === true : false } export function unref(ref) { return isRef(ref) ? ref.value : ref } export function customRef(factory) { const { get, set } = factory( () =\u0026gt; track(r, \u0026#39;get\u0026#39;, \u0026#39;value\u0026#39;), () =\u0026gt; trigger(r, \u0026#39;set\u0026#39;, \u0026#39;value\u0026#39;) ) const r = { __v_isRef: true, get value() { return get() }, set value(v) { set(v) } } } export function toRefs(object) { const ret = {} for (const key in object) { ret[key] = toRef(object, key) } return ret } export function toRef(object, key) { return { __v_isRef: true, get value() { return object[key] }, set value(newVal) { object[key] = newVal } } }   给之前的代码加上 ref 功能：\n baseHandlers.js  测试 ref(value) 1 2 3 4 5 6 7 8  // 将 100 变成 reactive 的 r -\u0026gt; { __v_isRef: true, get value() {}, set value() {} } const r = ref(100) let dummy effect(() =\u0026gt; { dummy = r.value }) console.log(targetMap.get(r), \u0026#39;deps\u0026#39;)   输出：\neffect 里面使用到了 r.value 触发 get value() 访问器，里面使用 track(r, 'get', 'value', void 0) 收集依赖，所以从 targetMap.get(r) 可以取到 \u0026lsquo;value\u0026rsquo; =\u0026gt; Set(1) 这个 Dep。\n更新 ref 值：\n1 2 3 4 5 6 7 8 9  const r = ref(100) let dummy effect(() =\u0026gt; { dummy = r.value }) console.log({ dummy }, \u0026#39;1\u0026#39;) r.value = 200 console.log({ dummy }, \u0026#39;2\u0026#39;)   结果:\n {dummy: 100} \u0026ldquo;1\u0026rdquo; {dummy: 200} \u0026ldquo;2\u0026rdquo;\n 所以说，Ref 的存在就是让普通类型的值也能 reactive。\n应用到对象上\n1 2 3 4 5 6 7 8 9 10  const r = ref({ nested: { num: 0 } }) console.log(r) let dummy effect(() =\u0026gt; { dummy = r.value.nested.num }) console.log({ dummy }, \u0026#39;1\u0026#39;) r.value.nested.num = 100   结果：\n {__v_isRef: true} Map(1) {\u0026ldquo;value\u0026rdquo; =\u0026gt; Set(1)} {dummy: 0} \u0026ldquo;1\u0026rdquo; {dummy: 100} \u0026ldquo;2\u0026rdquo;\n shallowRef(value) shallowRef 就是针对对象类型使用 Ref 的时候是否需要对对象里面的嵌套对象进行 reactive 化。\n1 2 3 4 5 6 7 8 9 10  const r = shallowRef({ nested: { num: 0 } }) console.log(r) let dummy effect(() =\u0026gt; { dummy = r.value.nested.num }) console.log({ dummy }, \u0026#39;1\u0026#39;) r.value.nested.num = 100   结果：\n对象最终会被整个成为 value，因为是用的 shallowRef，所以改变 r.value.nested.num 的值是不会触发 dummy 更新的。\n其他用法直接看下面的测试用例解析吧！！！\njest 结果:\n ☁ vue-next-code-read [master] ⚡ jest PASS packages/tests/reactive/reactive.spec.js PASS packages/tests/reactive/ref.spec.js PASS packages/tests/reactive/effect.spec.js PASS packages/tests/reactive/collection/WeakSet.spec.js PASS packages/tests/reactive/collection/Set.spec.js PASS packages/tests/reactive/collection/Map.spec.js PASS packages/tests/reactive/collection/WeakMap.spec.js\nTest Suites: 7 passed, 7 total Tests: 149 passed, 149 total Snapshots: 0 total Time: 5.94 s Ran all test suites. ☁ vue-next-code-read [master] ⚡\n   ✓ should hold a value (8 ms)\n1 2 3 4 5 6  it(\u0026#39;should hold a value\u0026#39;, () =\u0026gt; { const a = ref(1) // a -\u0026gt; { get value() {}, set value(val) {}, __v_isRef: true }  expect(a.value).toBe(1) // true  a.value = 2 // 在构造 set value(val) { trigger(r, \u0026#39;set\u0026#39;, \u0026#39;value\u0026#39;, void 0) }  expect(a.value).toBe(2) // true })     ✓ should be reactive (2 ms)\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20  it(\u0026#39;should be reactive\u0026#39;, () =\u0026gt; { const a = ref(1) // { get value(), set value(), __v_isRef: true }  let dummy let calls = 0 effect(() =\u0026gt; { calls++ // 1  dummy = a.value // 1  }) expect(calls).toBe(1) // true，effect会立即执行一次  expect(dummy).toBe(1) // true，同上  a.value = 2 // 赋值触发 set value -\u0026gt; trigger: set  expect(calls).toBe(2) // 因为赋值 trigger: set 触发 updater  expect(dummy).toBe(2) // same value should not trigger  a.value = 2 // 值没变，被 hasChanged() 阻拦，不 trigger  // if (hasChanged(toRaw(newVal), rawValue)) {  expect(calls).toBe(2) expect(dummy).toBe(2) })     ✓ should make nested properties reactive (2 ms)\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  it(\u0026#39;should make nested properties reactive\u0026#39;, () =\u0026gt; { const a = ref({ count: 1 }) let dummy effect(() =\u0026gt; { // a.value 触发一次 ref track  // a.value.count 触发一次普通的 reactive track  // 所以这里会有两次 track  dummy = a.value.count }) expect(dummy).toBe(1) // true  a.value.count = 2 // 这里依旧会触发两次 get  expect(dummy).toBe(2) // true })   测试：  ✓ should work without initial value (1 ms)\ncreateRef(undefined) 并不影响它的使用，只会初始值是 undefined。\n  ✓ should work like a normal property when nested in a reactive object (2 ms)\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51  it(\u0026#39;should work like a normal property when nested in a reactive object\u0026#39;, () =\u0026gt; { const a = ref(1) // 这里 ref 类型的a 被作为对象成员传递给 reactive 之后，会被转成正常的值  // 因为 baseHandlers.js 里面的 createGetter 的时候，有检测 isRef 是不是 Ref 类型 ?  // 如果是且非数组的话会直接返回 res.value ，其实就是被普通化了(unref)之后将结果返回  // 也就是说它只影响在 get 的时候返回的值，实际上在嵌套的对象里面 a 还是 Ref: a 类型的那个 a  /* if (isRef(res)) { if (targetIsArray) { !isReadonly \u0026amp;\u0026amp; track(target, \u0026#39;get\u0026#39;, key) return res } return res.value } */ // 所有后面可以直接 obj.a++ 操作  const obj = reactive({ a, b: { c: a } }) let dummy1 let dummy2 effect(() =\u0026gt; { // 这个时候的 a 和 c 虽然一开始都是 a，但是由于传递给  // reactive 之后被还原成最原始的值 1 了，所以这里 dummy1,2 都是 1  // 而非表面上的 Ref(1)  dummy1 = obj.a dummy2 = obj.b.c }) const assertDummiesEqualTo = (val) =\u0026gt; [dummy1, dummy2].forEach((dummy) =\u0026gt; expect(dummy).toBe(val)) // 有了上面的结论下面结果就很明显了，也很好理解了  assertDummiesEqualTo(1) // true，被还原的 Ref(1)  a.value++ // ++ 之后改变的是 Ref:a，引用类型  // 但是这里为什么是 2 呢？？？  // 原因其实就是上面 reactive 的时候 只是在 trigger:get 的时候返回的是 ref.value  // 实际上并没有改变 Ref:a 自身，只是影响了 get 的返回值而已  assertDummiesEqualTo(2) // 但是这里 obj.a++ \u0026lt;=\u0026gt; obj.a = obj.a + 1  obj.a++ assertDummiesEqualTo(3) obj.b.c++ assertDummiesEqualTo(4) })   看下最后 obj 变成啥了？\n最后可以看到 Ref:a 在 obj 里面尽管执行了 obj.a++ 和 obj.b.c++ 依旧还是 Ref: a？？？？\n  ✓ should unwrap nested ref in types (1 ms)\n在 createRef 第一行就加了检测是不是 Ref 如果是就直接返回了。\n  ✓ should unwrap nested values in types (1 ms)\n1 2 3 4 5 6 7 8 9 10 11 12 13 14  it(\u0026#39;should unwrap nested values in types\u0026#39;, () =\u0026gt; { const a = { b: ref(0) // 这里虽然是 Ref  } const c = ref(a) // 发生嵌套了  // 但是在访问的时候，还记得之前那个测试用例碰到的问题吗？  // createGetter 里面返回 Ref 会直接 返回 ref.value  // 所以这里访问 c.value.b 其实相当于 c.value.b.value  // 所以 + 1 的结果肯定是 number 类型  expect(typeof (c.value.b + 1)).toBe(\u0026#39;number\u0026#39;) })     ✓ should NOT unwrap ref types nested inside arrays\n这个用例和上一个是一样的原理，有个不同的地方是，target 是数组，createGetter 不是返回 res.value 了，而是直接返回 res，因为是数组类型且取的是整个数组对象。\n而后面通过 arr[i] 取值就和上一个用例一样了，一样会检测到数组元素如果是 Ref 照样会返回 res.value，所以在数组中使用 Ref(val) 做数组成员，然后 ref 数组是没有问题的。\n  ✓ should keep tuple types (6 ms)\n不管你是什么类型元素，数组类型首先是整个数组访问直接返回 ref，然后如果是数组元素会检测是不是引用类型，如果是就 reactive ，不是直接返回结果。\n  ✓ should keep symbols (4 ms)\n  ✓ unref\n  ✓ shallowRef (2 ms)\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  test(\u0026#39;shallowRef\u0026#39;, () =\u0026gt; { const sref = shallowRef({ a: 1 }) // shallow，那么里面的 {a:1} 对象是不会被 reactive 的  expect(isReactive(sref.value)).toBe(false)// 所以这里就是 False  let dummy effect(() =\u0026gt; { // 这里依然会立即执行一次，且只会触发一次 track:get，因为有 sref.value 取值操作  // 但是由于 {a: 1} 并不是 Reactive ，所以对 a 的取值是不会触发 track:get 的  dummy = sref.value.a }) expect(dummy).toBe(1) // true  sref.value = { a: 2 } // 这里重新赋值整个 value  expect(isReactive(sref.value)).toBe(false) // 虽然改变了 value 但的值依旧是普通对象  expect(dummy).toBe(2) // 因为改变了 value，而 sref 还是 ref 类型，会触发 set value })     ✓ shallowRef force trigger (1 ms)\n手动调用 triggerRef 触发 trigger(r, 'set', 'value', void 0) 执行以来 deps\n  ✓ isRef (1 ms)\n  ✓ toRef (2 ms)\n  ✓ toRefs (1 ms)\n  ✓ customRef 自定义 Ref 功能最主要的就是将控制权交给使用者，比如何时 track dep，何时 trigger dep 操作。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31  test(\u0026#39;customRef\u0026#39;, () =\u0026gt; { let value = 1 let _trigger const custom = customRef((track, trigger) =\u0026gt; ({ get() { track() // 根据实际情况调用来收集依赖  return value }, set(newValue) { value = newValue _trigger = trigger // 可缓存 trigger 不一定要立即触发 deps  } })) expect(isRef(custom)).toBe(true) // customRef 依旧返回的是 Ref  let dummy effect(() =\u0026gt; { dummy = custom.value }) expect(dummy).toBe(1) custom.value = 2 // should not trigger yet  expect(dummy).toBe(1) _trigger() expect(dummy).toBe(2) })     ref 版 reactive.js\ncomputed.ts 最后一个了，两周的坚持总算快结束了。\n这块的实现就更简单了，就一个 computed() 函数，结合 effect() + ref 来实现。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48  export function computed(getterOrOptions) { let getter, setter if (typeof getterOrOptions === \u0026#39;function\u0026#39;) { getter = getterOrOptions setter = __DEV__ ? () =\u0026gt; console.warn(\u0026#39;计算属性只读。\u0026#39;) : noop } else { getter = getterOrOptions.get setter = getterOrOptions.set } let dirty = true // 脏位检查，为 true 表示值有变化，重新取值  let value let computed // runner 不会立即执行，直到计算属性取值在 get value 中手动调用  // 来触发所有有关的依赖，重新计算得到最新的值 value  const runner = effect(getter, { lazy: true, computed: true, // 然后这里提供调度器，不直接  scheduler: () =\u0026gt; { if (!dirty) { dirty = true trigger(computed, \u0026#39;set\u0026#39;, \u0026#39;value\u0026#39;) } } }) computed = { __v_isRef: true, effect: runner, get value() { // 取值时，检测 dirty ，如果脏了(有变)，就重新 runner 取值，运行所有 deps，得到最新的值  if (dirty) { value = runner() dirty = false // 重新计算后的重置  } track(computed, \u0026#39;get\u0026#39;, \u0026#39;value\u0026#39;) // 收集依赖  return value }, set value(newValue) { setter(newValue) } } return computed }   测试一：依赖收集 1 2 3 4 5 6 7  const value = reactive({}) const cValue = computed(() =\u0026gt; value.foo) cValue.value console.log( cValue.effect.deps[0].values().next().value === cValue.effect, value ) // true Proxy {__v_reactive: Proxy}   当 cValue.value 执行对 Ref 进行取值(get value())触发，执行\n1 2 3 4 5 6 7 8 9 10 11 12 13 14  computed = { // ...  effect: runner, get value() { if (dirty) { // 检测到 dirty = true  // 执行 effect -\u0026gt; 执行 getter: () =\u0026gt; value.foo  // 计算新值 undefined 赋值给 value  value = runner() dirty = false } track(computed, \u0026#39;get\u0026#39;, \u0026#39;value\u0026#39;) // 触发 \t} // ... }   cValue.value 首先这一句会触发两个 track\n {shouldTrack: true, type: \u0026ldquo;get\u0026rdquo;, key: \u0026ldquo;foo\u0026rdquo;, target: {…}, activeEffect: ƒ} {shouldTrack: true, activeEffect: undefined, type: \u0026ldquo;get\u0026rdquo;, key: \u0026ldquo;value\u0026rdquo;, target: {…}}\n  get value() 里面执行了 runner() -\u0026gt; value.foo 取了一次 foo ，所以 type: get, key: foo get value() 里手动执行了一次 track(computed, 'get', 'value')，但是由于 activeEffect 是 undefined 所以不会继续往下执行  因此，虽然调用了两次 track ，但只有 value.foo 的 track 会去往下收集 effect:runner 这个依赖。所以：\ncValue.effect.deps[0].values().next().value === cValue.effect // --\u0026gt; true\n随后， value.foo = 1 会触发上面收集到的依赖，执行一次 runner() 取 value.foo 的最新值： 1。\n注意图中圈起来的，其实我想知道在调用 value.foo = 1 之后 cValue.value 的值会不会发生改变，按照代码逻辑是不会改变的，也就还是 undefined。但是直接点击 ... 浏览器会相当于触发一次 getter 操作，最后结果会是 1，但是这不是我们想要的，不能让它触发。\n那么就得想办法在它触发之前将老的值输出出来才行，结合代码只有在 get value() 一开始加上打印才行，如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  computed = { // ...  get value() { // 因为点击省略号会触发 getter ，会进入到这里  // 所以只需要提前将值打印出来就知道在 value.foo 设置下去之后  // cValue.value 其实是没有发生任何改变的，依旧还是 undefined  console.log({ value }, \u0026#39;before runner\u0026#39;) if (dirty) { value = runner() dirty = false } track(computed, \u0026#39;get\u0026#39;, \u0026#39;value\u0026#39;) return value }, }   然后修改下输出：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14  const value = reactive({}) const cValue = computed(() =\u0026gt; value.foo) console.log(cValue.value, \u0026#39;1\u0026#39;) // undefined，触发 runner() 执行 () =\u0026gt; value.foo // 在这里并不会立即触发 runner() 调用 () =\u0026gt; value.foo 更新 cValue.value 的值 // 所以在这里设置之后到最后的 log 之前 cValue.value 依旧是 undefined // 但是这里会有个动作和 computed 有关，那就是计算属性里面的 scheduler() // 里面会检测 dirty = false(因为上面 get value 过，所以是 false)， // 触发 trigger(computed, \u0026#39;set\u0026#39;, \u0026#39;value\u0026#39;)，这里会触发所有和 computed-value 有关的依赖 // 还有个重要的就是将 dirty = true，这样，后面当访问计算属性的时候才会触发 runner() 更新值 value.foo = 1 // 然后访问一次 cValue.value 触发其 get value() 检测到 dirty 是 true // 然后触发 runner() 调用 () =\u0026gt; value.foo 更新 value 的值 // 所以下面的输出值就是 value.foo 的值 console.log(cValue.value, \u0026#39;2\u0026#39;) // 1   jest   ✓ should return updated value (5 ms)\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  it(\u0026#39;should return updated value\u0026#39;, () =\u0026gt; { const value = reactive({}) // 提供的是函数，所以只有 getter，且不会立即执行(计算属性有设置：lazy: true)  // 返回一个 Ref 类型值  // 依赖属性：value.foo  const cValue = computed(() =\u0026gt; value.foo) // 取值收集 value 的依赖，此时 dirty = true，执行 runner() 得到 undefined  expect(cValue.value).toBe(undefined) // 赋值触发 value.foo 的 trigger: set，然后检测到该 effect 有提供 scheduler  // 因此调用 cValue.options.scheduer  // 此时的 dirty = false(get value 的时候置为 false 的)，  // 触发 cValue 的 trigger: set -\u0026gt; value 调用 set value()  value.foo = 1 expect(cValue.value).toBe(1) })     ✓ should compute lazily (3 ms)\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35  it(\u0026#39;should compute lazily\u0026#39;, () =\u0026gt; { const value = reactive({}) const getter = jest.fn(() =\u0026gt; value.foo) const cValue = computed(getter) // lazy  expect(getter).not.toHaveBeenCalled() // 计算属性默认是 lazy 的所以不会立即执行  expect(cValue.value).toBe(undefined) // get value() -\u0026gt; runner() -\u0026gt; 触发一次 getter  expect(getter).toHaveBeenCalledTimes(1) // true  // should not compute again  cValue.value // 因为上面取过一次值了所有 dirty = false ，不会重复 runner()  expect(getter).toHaveBeenCalledTimes(1) // should not compute until needed  // 不会立即重新计算，此时 cValue.value 值依旧是 undefined，上面有分析过了  // 由于 foo 有收集到 computed.effect 这个依赖，一次赋值的时候会触发它执行  // 而 computed.effect.options.scheduler 又存在，因此会执行 scheduler  // 里面重置 dirty = true，标识值由变化  value.foo = 1 // 因为不会触发 get value() 就不会 runner()，也就不会重新 getter()  expect(getter).toHaveBeenCalledTimes(1) // now it should compute  // 发生取值操作，会触发 get value() 此时 dirty = true(value.foo = 1的时候触发的 scheduler)  // 因此这里取值的时候会发现值变化了，所以需要重新 runner() 取新值，然后又置 dirty = false  expect(cValue.value).toBe(1) // 上面取值，runn() -\u0026gt; getter()  expect(getter).toHaveBeenCalledTimes(2) // should not compute again  cValue.value // 一样的道理，dirty = false 了，所以不会重新 runner()  expect(getter).toHaveBeenCalledTimes(2) })     ✓ should trigger effect (1 ms)\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20  const value = reactive({}) const cValue = computed(() =\u0026gt; value.foo) let dummy effect(() =\u0026gt; { // 这个会立即执行一次，触发 get value() 执行 runner() -\u0026gt; getter()  // 但是 value.foo 是没有指定 所以是 undefined  dummy = cValue.value }) expect(dummy).toBe(undefined) // 这里设置为什么会触发 effect(fn) 里面的 fn 呢？？？ // 1. computed(updater1) 执行完之后，effect:runner() 并未立即执行 // 所以 shouldTrack = true 和 activeEffect = undefined 并没有任何改变 // 2. effect(fn) 执行完会立即执行 fn，里面访问了 cValue.value 触发 get value() // 执行 effect:runner() -\u0026gt; getter(): () =\u0026gt; value.foo 此时 value.foo 取值触发其收集依赖 // 此时的 activeEffect 其实还是 fn，因为 fn 没有执行完就不会重置(try...finally) // 3. 所以下面执行 value.foo = 1 的时候是会触发 fn 执行的，因为在 2 中已经将它收集到了 // 4. 执行 fn 导致 cValue.value 取值，触发 get value() 执行 runner() -\u0026gt; getter() 取最新的 // 值 1，因此 dummy 的值就是 1 了。 value.foo = 1 expect(dummy).toBe(1)   所以上这个用例的关键点在于**理解 value.foo 是如何收集到 effect(fn) 里面的fn**，因为 fn 里面并没有直接访问 value.foo ，而是访问的 cValue.value。\n  ✓ should work when chained (1 ms)\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20  it(\u0026#39;should work when chained\u0026#39;, () =\u0026gt; { const value = reactive({ foo: 0 }) const c1 = computed(() =\u0026gt; value.foo) const c2 = computed(() =\u0026gt; c1.value + 1) // 1. c2:runner() -\u0026gt; c2:getter() -\u0026gt; c1.value -\u0026gt; c1:runner() -\u0026gt; c1.getter() -\u0026gt; 0 + 1 = 1  // 且此时 value.foo 收集到了 c1.effect  // 且 c1.value 在触发 get value() 时候收集到了 c2.effect  expect(c2.value).toBe(1) // 2. 因为上面触发了 c1:runner() 所以 c1.value = 0  expect(c1.value).toBe(0) // 3. 因为在 step1 value.foo 收集到了 c1:effect，所以这里改变 value.foo  // 会触发 c1:effect，执行 runner()，将 c1:dirty 置为 true  value.foo++ // 4. c2.value -\u0026gt; c2: get value() -\u0026gt; c2 runner() -\u0026gt; c1.value: get value()  // -\u0026gt; c1 runner() -\u0026gt; value.foo = 1 + 1 = 2  expect(c2.value).toBe(2) // 5. c1.value 此时就算不访问 c1.value 触发 get value() 这里 c1.value 也是 1  expect(c1.value).toBe(1) })   为了方便区分，这里给 computed(getterOrOptions, id) 加个 id 参数，方便跟踪当前是按个 computed .\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58  // 从结果直接分析原因，将下面的输出行用 Pn 标记 const value = reactive({ foo: 0 }) const c1 = computed(() =\u0026gt; value.foo, \u0026#39;c1\u0026#39;) const c2 = computed(() =\u0026gt; c1.value + 1, \u0026#39;c2\u0026#39;) // 首先上面三行不会触发任何输出 // 1. log1 会触发 P1,P2,P3，原因： // c2.value -\u0026gt; c2:get value()输出P1, dirty = true -\u0026gt; // runner() + track + dirty = false -\u0026gt; // 执行 c2:getter(), c1.value + 1 -\u0026gt; 访问 c1.value // c1.value -\u0026gt; c1:get value()输出P2, dirty = true -\u0026gt; // runner() + track + dirty = false -\u0026gt; // 执行 c1:getter(), c1.value = value.foo = 0 // 然后往回推： c1.value -\u0026gt; c1.value + 1 = 1 -\u0026gt; c2.value -\u0026gt; 输出 P3，c2.value 值为 1 // 2. 第一步结束之后的状态： // value.foo, deps[c1.effect]，value.foo = 1 // 因为都触发了 get value() 所以各自收集到了自身的 effect // c1, deps[c1.effect], c1.value = 0, dirty = false，等待 scheduler 调用置为 true // c2, deps[c2.effect], c2.value = 1, dirty = false，等待 scheduler 调用置为 true console.log(c2.value, \u0026#39;c2.value 1\u0026#39;) // log1, 1 // 3. log2 会触发 P4, P5，原因： // 只是 c1.value 取值，会触发 get value()，因此有了 P4 输出 // 但因为此时的 dirty = false 不会重复执行 runner()，所以值依旧是 0，最后输出 P5 console.log(c1.value, \u0026#39;c1.value 1\u0026#39;) // log2, 0  // 增加下面三个输出，让依赖收集结果更清晰 const dep = targetMap.get(toRaw(value)) // 这里收集到的是 c1.effect，因为 c1.value -\u0026gt;get value() 执行了 runner() 触发 // value.foo 将 c1.effect 收进 deps console.log(dep, dep.get(\u0026#39;foo\u0026#39;).values().next().value === c1.effect) // , true console.log( c1.effect.deps, c1.effect.deps[0].values().next().value === c1.effect, // true  \u0026#39;c1 deps\u0026#39; ) console.log( c2.effect.deps, c2.effect.deps[0].values().next().value === c2.effect, // true  \u0026#39;c2 deps\u0026#39; ) // 这里++，会触发 c1.effect，因为 c1:dirty = false，所以调用 c1.options.scheduler， // c1.dirty = true，trigger-c1:set-value // 记住一点：computed 属性没有取值就不会触发 runner()，所以这句执行之后 // c1.value 依旧是 0，c2.value 依旧是 1 // 通过之前的方式可测试出结果，如下图中结果 value.foo++ // 4. log3 会输出 P9, P10, P11 // c2.value 取值，触发 c2:runner() 重新计算值，c1.value + 1，触发 // c1.value 取值，触发 c1:runner() 重新计算值，得到 c1.value = value.foo(++之后的值为1) = 1 // 然后：c2.value = c1.value + 1 = 1 + 1 = 2 // 所以这里会输出2，请看下面的，P9,P10,P11，其实这句之后 c1.value 已经是 1了 // 因为这里触发了 c1.value 取值 console.log(c2.value, \u0026#39;c2.value 2\u0026#39;) // log3, 2 // 5. log4会输出 P12,P13，其实这里无论用不用 c1.value 它的值都已经是 1 了 // 所以这里纯粹只是取值，不会重复 runner()，因为 step 4-log3 触发过 get value() diry = false // 了。 console.log(c1.value, \u0026#39;c1.value 2\u0026#39;) // log4, 1   输出：\n P1: {id: \u0026ldquo;c2\u0026rdquo;, value: undefined} \u0026ldquo;before runner\u0026rdquo; P2: {id: \u0026ldquo;c1\u0026rdquo;, value: undefined} \u0026ldquo;before runner\u0026rdquo; P3: 1 \u0026ldquo;c2.value 1\u0026rdquo; P4: {id: \u0026ldquo;c1\u0026rdquo;, value: 0} \u0026ldquo;before runner\u0026rdquo; P5: 0 \u0026ldquo;c1.value 1\u0026rdquo;\nP6: Map(1) {\u0026ldquo;foo\u0026rdquo; =\u0026gt; Set(1)} true P7: [Set(1)] true \u0026ldquo;c1 deps\u0026rdquo; P8: [Set(1)] true \u0026ldquo;c2 deps\u0026rdquo;\n// 新增 Log3 之后的输出\nP9: {id: \u0026ldquo;c2\u0026rdquo;, value: 1} \u0026ldquo;before runner\u0026rdquo; P10: {id: \u0026ldquo;c1\u0026rdquo;, value: 0} \u0026ldquo;before runner\u0026rdquo; P11: 2 \u0026ldquo;c2.value 2\u0026rdquo;\n// 新增 log4 之后的输出\nP12: {id: \u0026ldquo;c1\u0026rdquo;, value: 1} \u0026ldquo;before runner\u0026rdquo; P13: 1 \u0026ldquo;c1.value 2\u0026rdquo;\n 点击省略号输出：\n  ✓ should trigger effect when chained (3 ms)\n请看上一个用例的分析\u0026mdash;-\u0026raquo;\n  ✓ should trigger effect when chained (mixed invocations) (3 ms)\n请看上上一个用例的分析\u0026mdash;-\u0026raquo;\n  ✓ should no longer update when stopped (2 ms)\n同上。但是有一点需要知道，stop() 主要干两件事：\n cleanup(effect) -\u0026gt; deps = [] 清空依赖 effect.active = false  那么问题就很清晰了，stop 之后 active 为 false，在执行 effect() 的时候一开始就是检测是不是激活状态，如果不是会返回 undefined(有 scheduler清空)或者 fn(\u0026hellip;args) 执行结果。不会继续往下执行 try\u0026hellip;finally。\n1 2 3  if (!_effect.active) { return options.scheduler ? undefined : fn(...args) }   所以说这里 stop 之后再赋值，调用 effect.scheduler() 相当于什么都没干。\n  ✓ should support setter (2 ms)\n  ✓ should trigger effect w/ setter\nplusOne.value = 0会触发 setter 调用 options.set:n.value = val - 1`。\n那么 n.value 变了 就会触发 effect(fn) 里面的 dep:fn 更新 dummy 值。\n  ✓ should warn if trying to set a readonly computed\n  总结 Over💥💥💥💥💥💥💥💥💥💥💥💥💥💥💥💥💥💥💥💥.\n终于结束了，经过两周的坚持，终于将 vue3.0 reactivity 模块源码“抄完”了。\n此时此刻，貌似没什么话要写的了\u0026hellip;\u0026hellip;，唯有\n路漫漫其修远兮，吾将上下而求索！！！\n两周以来，每天脑子空闲了里面都是 vue3.0 reactivity 代码，甚至睡觉都在做梦敲这块的代码，做梦都在思考所经历的代码流程和细节。\n总的下来，只有感叹自己能力不足，越学习越觉得自己垃圾！！！\n路还很长，不能放弃，回来这几年总感觉心有力而余不足，更是感叹大学没好好学好基础，更体会到书到用时方恨少方恨少，(⊙o⊙)…，有点扯远了！！！\n 还是老老实实的来复盘⑧ （开始 -\u0026gt; 🔚）：\n**第一阶段：reactive() ** reactive(target) -\u0026gt; createObjectReactive(target, isReadonly, baseHandlers, collectionHandlers)\n创建 reactive 对象，之前的 toProxy, toRaw 改成了 ReactiveFlags 标记方式存储到 target 和 observed 对象上了，而不是单独的声明两个模块遍历来专门存储 target -\u0026gt; observed 和 observed -\u0026gt; target 的关系。\nbaseHandlers: 基本对象类型的 proxy handler，原生的 Reflect 基本都提供了对应的能力。\ncollectionHandlers：集合类型(Map, Set, WeakMap, WeakSet) 对象的 proxy handlers，由于原生 Reflect 并没有支持它们的原子操作，所以只能通过对象的 proxy get ，来获取所调用的方法名去对应的 instrumentations 里面查找与之相关的 handler 来模拟集合类型的所有操作。\n可进行 reactive 的的条件\n _isVue: false 表示 Vue 实例类型 _VNode: false 虚拟节点类型 !rawValues 中的类型或值 可 observable 类型(除Map, Set, WeakMap, WeakSet, Object, Array意外的类型) 非 Object.isFrozen 类型  经过更新之后前面三种都合并到了 ReactiveFlags.__v_skip 里面了(结合 markRaw(value) 将不能被观察的值置为 __v_skip: true)。\n最后变成了三种检测：\n __v_skip = false observable 类型 非 frozen 对象  取消 toProxy, toRaw 之后使用 target.__v_readonly 和 target.__v_reactive 来保存 observed, target.__v_raw 来保存 proxy 之前的对象。\n所以一旦检测到 __v_readonly 和 __v_reactive 值存在就直接返回这个缓存的 proxy。\n第二阶段：baseHandlers createGetter -\u0026gt; 创建 proxy get：\n返回的时候检测 isReadonly 决定使用 readonly() 还是 reactive() 做深层的 reactive。\n如果指定了 shallow = true 参数，那么只会针对对象的第一层做 reactive。\n如果是数组的三个索引操作，直接进入 arrayInstrumentations 处理，调用封装之后的 includes, indexOf, lastIndexOf。\n如果是 Ref 类型直接返回 res.value，如果又是数组，手动 track 一次数组元素的 \u0026lsquo;get\u0026rsquo; 操作，直接返回该数组 res。\ncreateSetter -\u0026gt; 创建 proxy set：\n如果是 Ref 类型要将值设置到 oldValue.value 上，而不是直接将值通过 Reflect.set() 设置下去。\n然后根据 oldValue 和 newValue 进行比较，排除 NaN 的可能之后，如果有发生变化就调用 trigger，如果 target 上没有的 key 就是 trigger: add，否则 trigger:set。\ndeleteProperty -\u0026gt; 创建 proxy delete：\ntrigger delete。\nhas -\u0026gt; 创建 proxy has：\ntrack has 收集依赖。\nownKeys -\u0026gt; 创建 proxy ownKeys ：\ntrack ITERATE_KEY 迭代器收集依赖。\n第三阶段：effect() 构建 Dep effect(fn, options) 是将 fn 构造成 Dep 类型，所以，其实Vue里面所有的依赖都是一个 effect 函数，函数上挂了若干个属性(_isEffect, active, id, deps, options, raw)。\n这里的重点在于 reactiveEffect 函数的实现里面有个 try\u0026hellip;finally 它结合 shouldTrack 和 activeEffect 保证了在 Dep 里面执行 value.n++ 不会出现死循环，因为 trigger 里面的 add 操作会检测这两个值，如果 activeEffect !== effect(当前的这个 Dep) 或者 shouldTrack = false 才会收集要执行的依赖。\n1 2 3 4 5 6 7 8  try { // enable effect  return fn(...) // 这个就是 effect(() =\u0026gt; {}) 传入的函数 } catch { // 结束当前 effect 构建 \t// shouldTrack = false \t// activeEffect = undefined }   第四阶段：collectionHandlers 这里就有意思了\u0026hellip;\u0026hellip;\n因为没有集合类型的直接 proxy 对应的 Reflect，因此只能采取另类的方式来解决这个问题。\n不管什么情况下，obj.fn 都属于属性值的访问，也就是说当使用 obj.fn() 的时候，无论如何都会出发 obj 对 fn 属性的 get 操作。\n所以对于 collectionHandlers 里面就只有一个 get。\n然后通过 obj.fn -\u0026gt; 出发 get, key 为 fn -\u0026gt; Reflect.get(instrumentations, 'fn', ...)，然后通过 fn 即函数名称去 instrumentations 里面找到对应的函数(比如：set, get, add, has, 等等\u0026hellip;)。\n最后根据调用 obj.fn(...args) 时传递的参数转接到 instrumentations 里面对应的函数参数上。\n这部分的重点在于 instrumentations 里面函数的调用时作用域问题的解决：\n 从 target.prototype 原型上取出对应的方法(如：has, get, set, add) 然后通过 has.call(target) 然后将调用域指回给 target(Map, Set\u0026hellip;)  不然会出现 Map.prototype.has 在 Proxy 类型上调用而找不到函数的问题。\n另一个需要关注的是 key, rawKey 的问题，这里的意义在于：\n​\t如果 key-\u0026gt; proxyKey ，如果同时用 key 和 proxyKey 取 get 值的时候会发现最终 proxyKey 会被转成 key再取值。这里应该是为了避免 proxyKey 和 key 会同时被添加如 Map 或 Set 问题。\n第四阶段：Ref Ref 类型，主要提供了将原始类型值转成 reactive 的能力。\n它通过将值封装成 ： {__v_isRef: true, get value(){}, set value() {} } 对象来完成 reactive 功能。\n这里重点是几个函数：\n ref(value) 将值转成 Ref 类型 createRef(value, shallow) 被 ref 或 shallowRef 调用来创建 Ref triggerRef(ref) 触发 Ref 上的 deps customRef(factory) 提供外部自定义 Ref 能力 toRef(object) 将对象转成 Ref 类型  Ref 类型关键：\n get value() -\u0026gt; track 收集依赖 set value(val) -\u0026gt; trigger 依赖  第五阶段：computed(getterOrOptions) computed 实现原理：\n Ref 类型 dirty 脏检查位  所以计算属性就是个 Ref 类型结果对象，包含(__v_isRef, get value(), set value())，有两种使用方式\n getterOrOptions 是函数那么就只会有 getter getterOrOptions 是对象可以提供自定义的 setter 和 getter  每个 computed 都有一个名为 runner 的 effect，用来处理计算属性所依赖的值的变更所需要作出的行为。\n一个计算属性使用流程大概是这样的：\n  取值触发 get value()\n  检查 dirty，如果为 true，表示值由边则调用 runner() 重新计算新值\n  如果依赖的值发生变更，也会触发 runner()\n因为 runner 是个 effect，在 fn 里面使用其他值(比如：obj.foo)会触发这些值来收集这个 effect:runner 所以这些值改变会触发 runner。\n  即 obj.foo++ 改变，调用 trigger:set，trigger的时候检测到 runner 有schudler 所有调用它\n此时 runner: dirty 如果是 false 情况下就会触发 trigger(computed, \u0026lsquo;set\u0026rsquo;, \u0026lsquo;value\u0026rsquo;)，重点是会将脏位标识置为 dirty = true，那么下次取值的时候就会知道值发生改变了，就会触发 runner() 重新计算值。\n  经过第四部之后， computed.value 并没有真正的更新，必须它被实际访问的时候才会去触发 runner() 重新计算值。\n  所以说计算属性并不是在依赖值更新之后就会立即发生变化，必须在依赖值变更之后被访问了之后触发 get value() 才会重新计算值。\n 严格来说应该不是按照这五个阶段来完成的，其实最耗时间的是在第一和第二阶段，尤其是第二阶段。\n第二阶段耗时间的地方有两个\n createGetter -\u0026gt; track createSetter -\u0026gt; trigger  主要时间花在这两个上了，所以如果还可以拆分阶段肯定是这里。\n","permalink":"https://www.cheng92.com/vue/vue3-source-code-reactivity/","tags":["vue","vue3","vuenext","reactivity"],"title":"Vue3.0源码系列（一）响应式原理 - Reactivity"},{"categories":["javascript"],"contents":" 参考链接：https://leanpub.com/understandinges6/read\n 简介 JavaScript 核心特性在 ECMA-262 标准中被定义，也叫做 ECMAScript ，我们所熟知的在浏览器端和 Node.js 实际上是 ECMAScript 的一个超集。\n本文包含 es6+ 新增特性。\nES6 演变之路 1999 发布 v3 1999.TC39 年发布了 ECMA-262 第三版。\n直到 2007 之前都没有任何变化。\n2007 发布 v4, v3.1 2007 年发布了第四版，包含以下特性：\n 新语法(new syntax) 模块(modules) 类概念(classes) 类继承概念(classical inheritance) 对象私有属性(private object members) 更多类型 其他  由于第四版涉及的内容太多，因此造成分歧，部分成员由此创建了\n3.1 版本，只包含少部分的语法变化，聚焦在：\n 属性 原生 JSON 支持 已有对象增加方法  但是两拨人在 v4 和 v3.1 版本之间并没有达成共识，导致最后不了了之。\n2008 JavaScript 创始人决定 Brendan Eich 决定将着力于 v3.1 版本。\n最后 v3.1 作为 ECMA-262 的第五个版本被标准化，即： ECMASCript 5\n2015 年发布 ECMAScript 6 也叫 ECMAScript 2015 即本书要讲的内容(ES6)。\n块级绑定(var, let, const) Var 声明和提升 使用 var 来声明变量时，在一个作用域内，无论它在哪里声明的，都会被升到到该作\n用域的顶部。\n比如：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17  function getValue(condition) { // 比如： var value; // undefined  if (condition) { // 虽然在这里声明的，其实会被提升到函数顶端  var value = \u0026#39;blue\u0026#39; // code  return value } else { // 这里依旧可以访问变量 `value` 只不过它的值是 `undefined`  return null } } console.log(getValue(false)) // \u0026#39;null\u0026#39;   上面的 getValue 相当于下面的变量声明版本（提升之后）：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  function getValue(condition) { var value; // undefined  if (condition) { value = \u0026#39;blue\u0026#39; // code  return value } else { return null } } console.log(getValue(false)) // \u0026#39;null\u0026#39;    +RESULTS:\nnull  块级声明 let/const 声明 块级作用域，如：函数，*{ … }* 大括号，等等都属于块级作用域，在该作用域下使\n用 let 声明的变量只在\n该作用域下可访问。\n声明提升问题 let 声明不会被提升，但是也有另一种说法是 let 会提升，并且在如果在提升处\n到赋值的中间范围内使用了该变量，\n会使该区域成为一块临时死区(TDZ)。\n在声明之前使用 let 变量：\nVM88:4 Uncaught ReferenceError: Cannot access \u0026lsquo;value\u0026rsquo; before\ninitialization\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20  function getValue(cond) { if (cond) { console.log(value) let value = \u0026#39;blue\u0026#39; // code  return value } else { // value 在该作用域不存在  return null } // value 在该作用域不存在 } getValue(true)   不能重复声明 使用 var 的时候是可以重复声明的：\nvar count = 39; var count;\n这样是不会有问题的，只不过它的声明只会被记录一次而已，即只会记录 var count = 39; 这里声明，但是不会出现异常。\n如果使用 let 就不一样了，如果出现重复声明则会异常：\nvar count = 39;let count;\n异常结果：*SyntaxError: Identifier \u0026lsquo;count\u0026rsquo; has already been declared*\n两者差别 let 声明的值可变，const 声明的是个常量，值是不能发生改变的。\n1 2 3 4 5 6 7  let name = \u0026#39;xxx\u0026#39;; name = \u0026#39;yyy\u0026#39;; // ok  const age = 100; age = 88; // error   临时死区(TDZ) 使用 let/const 声明的变量，任何时候试图在其声明之前使用变量都会抛出异常。\n即使是在声明之前使用 typeof 也会出现引用异常(ReferenceError)。\n1 2 3 4 5  if (true) { console.log(typeof value) let value = \u0026#39;blue\u0026#39; }   循环中使用块级声明 我们都知道使用 var 声明的变量是不存在块级作用域的，即在 if/for 的 {} 作\n用域内使用 var\n声明的变量其实是该全局作用下的全局变量。\n比如：我们常见的 for 循环中的 i 的值\n1 2 3 4 5  for (var i = 0; i \u0026lt; 10; i++) { // ... } console.log(i) // 10   +RESULTS:\n10  结果为 10 表明在 console.log(i) 处是可以访问 i 变量的，因为 var i = 0; 的声明\n被提升成了全局变量，即循环体中使用的一直是这一份全局变量。\n如果是同步代码，可能没什么问题，但要是异步代码就会出现问题，如下结果：\n1 2 3  for (var i = 0; i \u0026lt; 5; i++) { setTimeout(() =\u0026gt; console.log(i)) }   +RESULTS:\n5 5 5 5 5  很遗憾最后结果都成了 5，因为循环体是个异步代码 setTimeout\n解决方法有：\n 闭包:  形成一个封闭的作用域，将当前的 i 值传递进去。\n1 2 3 4 5 6  for (var i = 0; i \u0026lt; 5; i++) { (v =\u0026gt; { // 这里的 v 值即传递进来的当前次循环的 i 的值  setTimeout(() =\u0026gt; console.log(v)) })(i) }   +RESULTS:\n0 1 2 3 4   let  每次循环相当于新创建了一个变量，因此变量的值都得以保存。\n1 2 3  for (let i = 0; i \u0026lt; 5; i++) { setTimeout(() =\u0026gt; console.log(i)) }   +RESULTS:\n0 1 2 3 4  全局作用域声明 var, let, const 另一个区别是在全局环境下的声明作用域也是不一样，\n我们都知道在全局作用域下使用 var 声明的话，浏览器端是可以通过 window.name\n来访问该变量的，但是 let, const 却不行。\n1 2 3 4 5 6  var age = 100 let name = \u0026#39;xxx\u0026#39; console.log(window.name) console.log(window.age)   结果：\n浏览器端作用域：\n结论：\n无论 let 在那里声明的它都是个块级作用域变量，只在其声明到该作用域之后才能\n使用。\n而 var 声明的始终相对于当前作用域下是全局变量。\n总结(var, let, const) 在 es6 之后尽量使用 let 和 const 去声明变量，严格控制变量的作用域。\n var 变量声明会提升，可重复声明，且在该作用域内为全局变量 let/const 变量声明不会提升，不可重复声明，局部变量，且在 DTZ 范围内使用即\n使是 typeof 也会报错 let/const 区别在于 const 声明的变量值不能发生改变     关键词 提升 作用域 值属性     var 有提升，声明提升(命名函数定义也提升) 范围内全局 可变   let 无提升 局部变量，作用域内声明处开始往下 可变   const 无提升 局部变量，作用域内声明处开始往下 不可变    字符串和正则表达式(String\u0026amp;Regex) 更好的 Unicode 编码支持 UTF-16 编码 新增 str.codePointAt(n) 和 String.fromCodePoint(str) 已有的编码查询函数： str.charCodeAt 和 String.fromCodeAt 用来应对单字符一个\n字节的情况。\n新增的两个函数可以处理单个字符串占两个字节的大小，比如一些特殊字符“𠮷”需要用\n到两个字节来存储。\n即 2bytes = 16bits 大小。\ncharCodeAt 和 fromCodeAt 是以一个字节为单位来处理字符串的，因此如果遇到这些\n字就没法正常处理。\n1 2 3 4 5 6 7  var name = \u0026#39;𠮷\u0026#39; console.log(name.charCodeAt(0)) console.log(name.codePointAt(0)) console.log(String.fromCharCode(name.charCodeAt(0))) console.log(String.fromCodePoint(name.codePointAt(0)))   +RESULTS:\n55362 134071 � 𠮷  可以看到如果我们还用原来的函数 charCodeAt 和 fromCharCode 去处理这个字得到结\n果是不正确的。\nnormalize() 函数 参考链接：https://www.cnblogs.com/hahazexia/p/9257409.html\nrepeat(n) 函数 将一个字符串重复 n 次后返回。\n1 2 3 4 5  var c = \u0026#39;x\u0026#39; var b = c.repeat(3) console.log(b, c, b === c)   +RESULTS:\nxxx x false  正则表达式 y 标记 s(dotAll)flag2018 1 2  console.log(/one.two/.test(\u0026#39;one\\ntwo\u0026#39;)); // → false console.log(/one.two/s.test(\u0026#39;one\\ntwo\u0026#39;)); // → true   命名捕获组(Named Caputre Groups)2018 格式： ?\u0026lt;name\u0026gt;\n引用： match.groups 一个包含捕获组名称的对象\n1 2 3 4 5 6 7 8  const re = /(\\d{4})-(\\d{2})-(\\d{2})/ const match = re.exec(\u0026#39;2019-10-10\u0026#39;) console.log(match[0]) // -\u0026gt; 2019-10-10 console.log(match[1]) // -\u0026gt; 2019 console.log(match[2]) // -\u0026gt; 10 console.log(match[3]) // -\u0026gt; 10    命名捕获组：\n1 2 3 4 5 6 7  const namedRe = /(?\u0026lt;year\u0026gt;\\d{4})-(?\u0026lt;month\u0026gt;\\d{2})-(?\u0026lt;date\u0026gt;\\d{2})/ const namedMatch = namedRe.exec(\u0026#39;2019-10-10\u0026#39;) console.log(namedMatch.groups) // { year: \u0026#39;2019\u0026#39;, month: \u0026#39;10\u0026#39;, date: \u0026#39;10\u0026#39; } console.log(namedMatch.groups.year) // 2019 console.log(namedMatch.groups.month) // 10 console.log(namedMatch.groups.date) // 10   JSON JSON.stringify2019 更好的处理不支持的字符序列。\n字符串方法 String.prototype.trimStart()2019 String.prototype.trimEnd()2019 String.prototype.toString()2019 更好的处理空格，换行符等特殊字符，比如：字符串化函数的时候，会将函数原样输出。\n如：\n模板字符串 基本语法 1 2 3 4 5  let msg = `hello world` console.log(msg) console.log(typeof msg) console.log(msg.length)   +RESULTS:\nhello world string 11  如果需要用到反引号，则需要使用转义字符： \\`\n多行字符串 避免一行太长，进行换行书写，但是不影响最终结果显示在一行，可以使用反斜杠\n1 2 3 4  var msg = `multiline \\ string` console.log(msg)   +RESULTS:\nmultiline string  多行字符串情况：\n1 2 3  var msg = \u0026#34;multiline \\n string\u0026#34; console.log(msg)   +RESULTS:\nmultiline string  使用模板字符串，会按照模板字符串中的格式原样输出，而不再需要显示使用 `\\n` 来\n进行换行：\n1 2 3 4  var msg = `multiline string` console.log(msg)   +RESULTS:\nmultiline string  在模板字符串中空格也会是字符串的一部分\n1 2 3 4 5 6 7 8  var msg1 = `multiline string` var msg2 = `multiline string` console.log(`len1: ${msg1.length}`) console.log(`len2: ${msg2.length}`)   +RESULTS:\nlen1: 19 len2: 16  所以在书写模板字符串的时候必须慎重使用缩进。\n模板字符串插值 1 2 3 4 5 6  var name = \u0026#39;xxx\u0026#39; const getAge = () =\u0026gt; 100 console.log(`my name is ${name}`) // 普通字符串 console.log(`3 + 4 = ${3 + 4}`) // 可执行计算 console.log(`call function to get age : ${getAge()}`) // 可调用函数   +RESULTS:\nmy name is xxx 3 + 4 = 7 call function to get age : 100  标签模板 允许使用标签模板，该标签对应的是一个函数，后面的模板字符串会被解析成参数传递\n给该函数去进行处理，最后返回处理的结果。\n比如： let msg = tag`Hello World`\n定义标签：\n1 2 3  function tag(literals, ...substitutions) { // 返回一个字符串 }   示例：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  let count = 10, price = 0.25, msg = passthru`${count}items cost $${(count * price).toFixed(2)}.` function passthru(literals, ...subs) { console.log(literals.join(\u0026#39;--\u0026#39;)) console.log(subs) // 将结果拼起来  return subs.map((s, i) =\u0026gt; literals[i] + subs[i]).join(\u0026#39;\u0026#39;) + literals[literals.length - 1] } console.log(msg)   +RESULTS:\n-- items cost $--. [ 10, '2.50' ] 10 items cost $2.50.  从结果可以看到，标签函数参数的内容分别为:\n literals 被插值(${})分割成的字符串数组，比如上例的结果为： [\u0026quot;\u0026quot;, \u0026quot; items const $\u0026quot;, \u0026quot;.\u0026quot;] subs 为插值计算的结果值作为第2, … 第 n 个参数传递给了 passthru  标签模板原始值(String.raw()) 有时候需要在模板字符串中直接使用带有转义字符的内容，比如： `\\n` 而不是使用其\n转义之后的含义。\n这个时候则可以使用新增的内置 tag 函数来处理。\n比如：\n1 2 3 4 5  let msg1 = `multiline\\nstring` let msg2 = String.raw`multileline\\nstring` console.log(msg1) console.log(msg2)   +RESULTS:\nmultiline string multileline\\nstring  可看到在我们使用 String.raw 之后的 \\n 并没有被转义成换行符，而是按照其原\n始的样子输出。\n如果在不适用内置的 Strng.raw 该怎么做？\n1 2 3 4 5 6 7 8 9 10 11 12  function raw(literals, ...subs) { // 将结果拼起来  return subs.map((s, i) =\u0026gt; literals.raw[i] + subs[i]).join(\u0026#39;\u0026#39;) + literals.raw[literals.length - 1] } let msg = raw`multiline\\nstring` console.log(msg)   +RESULTS:\nmultiline\\nstring  nodejs 环境可能看起来不直观，通过下图我们来直观的查看下标签函数是怎么处理带\n转义字符的字符串的：\n会发现其实 literals 的值依旧是转义之后的，看数组中第一个元素的字符串中是有\n一个回车标识的。\n此外该数组对象本身上面多了一个 raw 属性，其值为没有转义的内容。\n从这里我们得出，标签模板是怎么处理带转义字符串的模板的。\n小结  完整的编码支持赋予了 JavaScript 处理 UTF-16 字符的能力(通过\ncodePointAt() 和 String.fromCodePoint() 来转换) u 新增的标记使得正则表达式可以通过码点来代替 UTF-16 字符 normalize() 模板字符串，支持原始字符串，插值支持计算表达式或函数调用 标签模板，第一个参数为分割后的字符串列表，后面的参数分别为插值结果 转义标签模板，转义标签的第一个参数数组对象上包含一个 raw 数组，其中包含\n了原始值列表  函数(Function) 参数默认值 1 2 3  function makeRequest(url, timeout = 2000, callback = () =\u0026gt; {}) { // ... }   默认参数值是如何影响 arguments 对象的？\n严格非严格模式下的 arguments 只要记住一旦使用了默认值，那么 arguments 对象的行为将发生改变。\n在 ECMAScript5 的非严格模式下，arguments 对象的内容是会随着函数内部函数参数值得变化而发生变化的，也就是说它\n并不是在调用函数之初值就固定了，比如：\n1 2 3 4 5 6 7 8 9 10  function maxArgs(first, second) { console.log(first === arguments[0]) console.log(second === arguments[1]) first = \u0026#39;c\u0026#39; second = \u0026#39;d\u0026#39; console.log(first === arguments[0]) console.log(second === arguments[1]) } maxArgs(\u0026#39;a\u0026#39;, \u0026#39;b\u0026#39;)   +RESULTS:\ntrue true true true  从结果我们会发现，参数值发生变化也会导致 arguments 对象跟着变化，这种情况只会在非严格模式下产生，\n在严格模式下， arguments 对象是不会随着参数值改变而改变的。\n1 2 3 4 5 6 7 8 9 10 11 12 13  function maxArgs(first, second) { \u0026#39;use strict\u0026#39;; console.log(first === arguments[0]) console.log(second === arguments[1]) first = \u0026#39;c\u0026#39; second = \u0026#39;d\u0026#39; console.log(first === arguments[0]) console.log(second === arguments[1]) } maxArgs(\u0026#39;a\u0026#39;, \u0026#39;b\u0026#39;)   +RESULTS:\ntrue true false false  喏，后面结果为 false 。\n带默认参数值情况下 arguments 在 es6 之后，arguments 的行为和之前严格模式下是一样的，即不会映射参数值得变化。\n  带默认值得参数，如果在调用的时候不传递，是不会计入到 arguments 对象当中\n即 arguments 的实际个数是根据调用的时候所传递的参数个数来决定的。\n  arguments 对象不再响应参数值得变化\n  1 2 3 4 5 6 7 8 9 10 11  function mixArgs(first, second = \u0026#39;b\u0026#39;) { console.log(arguments.length) console.log(first === arguments[0]) // true  console.log(second === arguments[1]) // false  first = \u0026#39;c\u0026#39; second = \u0026#39;d\u0026#39; console.log(first === arguments[0]) // false  console.log(second === arguments[1]) // false } mixArgs(\u0026#39;a\u0026#39;)   +RESULTS:\n1 true false false false  默认参数表达式 参数默认值不仅可以使用静态值，还可以赋值为调用函数的结果\n1 2 3 4 5 6 7 8 9 10 11  function getValue() { console.log(\u0026#39;get value...\u0026#39;) return 5 } function add(first, second = getValue()) { return first + second } console.log(add(1, 1)) // 2 console.log(add(1)) // 6   +RESULTS:\n2 get value... 6  从结果显示：\n 如果 second 没传，会在调用 add() 时候执行 getValue() 获取默认值 如果传递了 second，那么 getValue() 是不会被执行的  即在默认参数中调用的函数，是由在调用时该对应的函数参数是否有传递来决定是否调用。\n而不是传递了 second，先调用 getValue() 得到值，然后用传递的 second 值去覆盖。\n也就是说 getValue() 返回的值不用每次都一样，是可以在每次调用的时候发生变化的，比如：\n1 2 3 4 5 6 7 8 9 10 11 12 13  var n = 5 function getValue() { return n++ } function add(first, second = getValue()) { return first + second } console.log(add(1, 1)) // 2 console.log(add(1)) // 6 console.log(add(1)) // 7   +RESULTS:\n2 6 7  由于上面的特性，参数默认值可以是动态的，因此我们可以将前面参数值作为后面参数的默认值来使用，\n比如：\n1 2 3 4 5 6  function add(first, second = first) { return first + second } console.log(add(1, 1)) // 2 console.log(add(1)) // 2   +RESULTS:\n2 2  甚至还可以将 first 作为参数传递给 getValue(first) 获取新值作为默认值来用。\n默认参数值的临时死区(TDZ) 这里临时死区的意思是指，第二个参数在使用之前未进行声明，因为参数的声明相当于使用了 let 。\n根据 let 的特性，在为声明之前使用属于在 TDZ 范围，会抛异常。\n实例：\n1 2 3 4 5 6 7 8 9 10 11  function add(first = second, second) { return first + second } console.log(add(1, 1)) // 2  try { add(undefined, 1) // error } catch (e) { console.log(e.message) }   +RESULTS:\n2 second is not defined  既然都存在 TDZ 那为什么第一次调用就没事了，下面来分析下看看：\n记住上一节所讲的：\n默认值的调用(如： getValue() )只有在参数未传递的情况下才会发生，这里 first=second 的情况依旧适用。\n那么将这句话应用到这里：\n  add(1, 1) 这里 first 传递了 1\n那么 first 在 add 被调用的时候会被初始化成 1，根据上面那句话，即此时 first=second 这句相当于并没有被执行\n因此就不会去检测 second ，也就不会出现未定义了，从而能得出正确结果：2。\n  add(undefined, 1) 传递了 `undefined` 相当于没传这个参数，只是占了个位\n那么既然没传， first=second 就会被执行， second 就会被检测是否定义，然而检测的结果就是“未定义”，\n因此抛出异常。\n  将 add 函数参数的变化用下来转声明来表示，问题就会更明显了：\n1 2 3 4 5 6 7 8  // add(1, 1)  let first = 1 // first = second 未执行，不检测 let second = 1 // add(undefined, 1) let first = second // 这句被执行，相当于这里提前使用了 second 变量，let 特性生效 let second = 1    函数参数是有它自己的作用域和TDZ的，并且和函数体作用域是区分开的，\n这就意味着函数参数是无法访问函数体内的任何变量的，因为根据就是两个不同的作用域。\n 未命名参数 为什么会存在未命名参数？\n因为 JavaScript 是没有限制调用函数的时候传递参数个数的。\n比如：声明了一个函数 function add() {} 没任何参数，但是调用的时候是可以这样\n的 add(1, 2, 3, ...)\n那么这些调用的时候传递给 add 的参数对应的函数参数就叫做未命名参数。\n1 2 3 4 5 6 7 8  function add() { let n = 0 ;[].slice.call(arguments).forEach(v =\u0026gt; n += v) return n } console.log(add(1, 2, 3, 4, 5))   +RESULTS:\n15  参数展开符(…) 未命名参数一般很少使用，因为这让使用者会很迷惑该函数的作用，因此参数没任何明\n显特征表示它是干什么用的，\n在 es6 中增加了一个展开符号(…)，在函数参数中的作用是将传递进的参数列表合并\n成一个参数数组。\n适用于一个函数参数个数未知的情况下使用。\n比如：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21  function pick(object, ...keys) { // 这里 keys 会成为一个包含传入的其余参数值的数组  let result = Object.create(null) console.log(arguments.length) for (let i = 0; i \u0026lt; keys.length; i++) { result[keys[i]] = object[keys[i]] } return result } const book = { author: \u0026#39;xxx\u0026#39;, name: \u0026#39;yyy\u0026#39;, pages: 300 } const res = pick(book, \u0026#39;author\u0026#39;, \u0026#39;name\u0026#39;) console.log(JSON.stringify(res))   +RESULTS:\n3 {\u0026quot;author\u0026quot;:\u0026quot;xxx\u0026quot;,\u0026quot;name\u0026quot;:\u0026quot;yyy\u0026quot;}  利用 …keys 将传入的 (\u0026lsquo;author\u0026rsquo;, \u0026lsquo;name\u0026rsquo;) 合并成了一个数组： ['author', 'name'] ，方便应对\n函数参数个数可变的情况。\n参数展开符两种异常使用情况   展开符参数必须是最后一个，不能在其后面还有其他参数\n比如： function add(n, ...vals, more) {} 这会出现异常\n  不能用在对象的 setter 函数上\n  实例：\n1 2 3  const obj = { set name(...val) {} }   1 2 3  function add(n, ...vals, more) { }   参数展开符对 arguments 的影响 记住一点：\narguments 总是由函数调用时传递进来的参数决定\n1 2 3 4 5 6 7 8  function checkArgs(...args) { console.log(args.length); console.log(arguments.length); console.log(args[0], arguments[0]); console.log(args[1], arguments[1]); } checkArgs(\u0026#34;a\u0026#34;, \u0026#34;b\u0026#34;);   +RESULTS:\n2 2 a a b b  函数构造函数能力增强 在实际编码过程，我们很少直接使用 Function() 构造函数去创建一个函数。\n比如这么使用：\n1 2 3 4  // 参数：参数一名称 first, 参数二名称 second，... 最后一个是函数体 var add = new Function(\u0026#39;first\u0026#39;, \u0026#39;second\u0026#39;, \u0026#39;return first + second\u0026#39;) console.log(add(1, 2))   +RESULTS:\n3  在 es6 中对构造函数的使用能力增强了，给其赋予了更多的功能，比如\n 默认参数值 展开符  1 2 3 4 5 6 7 8 9  var add = new Function(\u0026#34;first\u0026#34;, \u0026#34;second = first\u0026#34;, \u0026#34;return first + second\u0026#34;); console.log(add(1, 1)); // 2 console.log(add(1)); // 2  var pickFirst = new Function(\u0026#34;...args\u0026#34;, \u0026#34;return args[0]\u0026#34;); console.log(pickFirst(1, 2)); // 1   +RESULTS:\n2 2 1  展开符(…) 在之前我们在函数参数中用到了展开符，这个时候的用途是将参数合并成数组来用。\n普通参数传递 我们一般调用函数的时候都是将参数逐个传递：\n1 2 3 4  let v1 = 20, v2 = 30 console.log(Math.max(v1, v2))   +RESULTS:\n30  这仅仅两个参数，比较好书写，一旦参数多了起来就比较麻烦，在 es6 之前的做法可以利用 Function.prototype.apply 去实现：\napply 传递多个参数 1 2 3  let vs = [1, 2, 3, 4, 5] console.log(Math.max.apply(Math, vs))   +RESULTS:\n5  因为 apply 会将数组进行展开作为函数的参数传递个调用它的函数。\nes6 之后展开符传递 在 es6 之后我们将使用展开符去完成这项工作，让代码更简洁和便于理解。\n1 2 3  let vs = [1, 2, 3, 4] console.log(Math.max(...vs))   +RESULTS:\n4  展开符，传统方式相结合 1 2 3 4 5  let vs = [1, 2, 3, 4] console.log(Math.max(10, ...vs)) // 10 console.log(Math.max(...vs, 0)) // 4 console.log(Math.max(3, ...vs, 10)) // 10   +RESULTS:\n10 4 10  函数名字属性 以往，由于函数的各种使用方式使 JavaScript 在识别函数的时候成为一种挑战，并且\n匿名函数的频繁使用使得程序的 debugging 过程异常痛苦，经常造成追踪栈很难理解。\n因此在 es6 中给所有函数添加了一个 name 属性。\n name 属性只是对函数的一种描述特性，并不会有实际的引用特性，也就是说\n在实际编程中不可能通过函数的 name 属性去干点啥。\n 选择合适的名称 JavaScript 会根据函数的声明方式去给其选择合适的名称，比如：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  function doSomething() { // ... } var doAnotherThing = function() { // ... }; var doThirdThing = function do3rdThing() { } console.log(doSomething.name); // \u0026#34;doSomething\u0026#34; console.log(doAnotherThing.name); // \u0026#34;doAnotherThing\u0026#34; console.log(doThirdThing.name); // \u0026#34;do3rdThing\u0026#34;   +RESULTS:\ndoSomething doAnotherThing do3rdThing    如果是命名函数式声明方式，则使用的就是它的名字作为 name 属性值，如： doSomething\n  如果是表达式匿名方式声明函数，则将使用表达式中左边的变量名称来作为 name 属性值，如： doAnotherThing\n  表达式命名方式声明函数，则将使用命名函数的名称作为 name 属性，如： doThridThing 的名字是： do3rdThing\n   通过第三个输出可知，命名函数的优先级高于表达式的变量名。\n name 属性的特殊情况  对象的函数名称，即该函数的名字 对象的访问器函数名称，通过 Object.getOwnPropertyDescriptor(obj, 'keyname') 获取访问器对象 调用 bind() 之后的函数名称，总是在原始函数名前加上 bound 使用 new Function() 创建的函数名称，总是返回 anonymous  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20  var doSth = function() {} var person = { get firstName() { return \u0026#39;Nicholas\u0026#39; }, sayName: function() { console.log(this.name) } } console.log(person.sayName.name) // sayName // 访问器属性，只能通过 getOwnPropertyDescriptor 去获取 var descriptor = Object.getOwnPropertyDescriptor(person, \u0026#39;firstName\u0026#39;) console.log(descriptor.get.name) // get firstName  // 调用 bind 之后的函数名称总是会在原始的函数名称之前加上 `bound fname` console.log(doSth.bind().name) // bound doSth console.log((new Function()).name) // anonymous   +RESULTS:\nsayName get firstName bound doSth anonymous  澄清函数双重目的 函数使用方式   直接调用，当做函数来使用 Person()\n  使用 new 的时候当做构造函数来使用创建一个实例对象\n  在 es6 之后为了搞清楚这两种使用方式，添加了两个内置属性： [[Call]] 和 [[Constructor]]\n当当做函数直接调用时，其实内部是调用了 [[Call]] 执行了函数体，\n当结合 new 来使用是，调用的是 [[Contructor]] 执行了以下步骤：\n  创建一个新的对象 newObj\n  将 this 绑定到 newObj\n  将 newObj 对象返回作为该构造函数的一个实例对象\n  也就是说我们可以在构造函数中去改变它的行为，如果它没有显示的 return 一个合\n法的对象，则会默认走 #3 步，如果我们显示的去返回了一个对象，那么最后得到的实\n例对象即这个显示返回的对象。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25  function Person1(name) { this.name = name || \u0026#39;xxx\u0026#39; } // 没有显示的 return 一个合法对象 // 返回的是新创建的对象，并且 this 被绑定到这个心对象上 const p1 = new Person1(\u0026#39;张三\u0026#39;) // 因此这里访问的 name 即构造函数中的 this.name console.log(p1.name) function Person2(name) { this.name = name || \u0026#39;xxx\u0026#39; return { name: \u0026#39;李四\u0026#39; } } // 按照构造函数的使用定义，这里返回的是 // 显示 return 的那个对象： { name: \u0026#39;李四\u0026#39; } const p2 = new Person2(\u0026#39;张三\u0026#39;) // 因此这里输出的结果为：李四 console.log(p2.name)   +RESULTS:\n张三 李四   并不是所有的函数都有 [[Constructor]] ，比如箭头函数就没有，因此箭头函数\n也就不能被用来 new 对象实例。\n 判断函数被如何使用？ 有时候我们需要知道函数是如何被使用的，是当做构造函数？还是单纯当做函数直接调用？\n这个时候 instanceof 就派上用场了，它的作用是用来检测一个对象是否在当前对象的\n原型链上出现过。\n比如：在 es5 中强制一个函数只能当做构造函数来使用，一般这么做\n1 2 3 4 5 6 7 8 9 10 11 12 13 14  function Person(name) { if (this instanceof Person) { this.name = name } else { throw new Error(\u0026#39;必须使用 new 来创建实例对象。\u0026#39;) } } var person = new Person(\u0026#39;张三\u0026#39;) // 这种调用，内部的 `this` 被绑定到了全局对象 // 而全局对象并非 Person 原型链上的对象，因此会 // 执行 else 抛出异常 var notAPerson = Person(\u0026#39;李四\u0026#39;)   但是有一种直接调用的情况，不会走 else ，即通过 call 调用指定 person 实\n例为调用元。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  function Person(name) { if (this instanceof Person) { this.name = name } else { throw new Error(\u0026#39;必须使用 new 来创建实例对象。\u0026#39;) } } var person = new Person(\u0026#39;张三\u0026#39;) // 这样是合法的，请 this instanceof Person 成立 // 因为 Person.call(person, ...) 指定了作用域为实例对象 person // 因此函数内部的 this 会被绑定到这个实例对象 person 上， // 而 person 确实是 Person 的实例对象，因此不会报错 var notAPerson = Person.call(person, \u0026#39;李四\u0026#39;)   正常运行的结果\n+RESULTS:\nundefined  因此，如果是 Person.call(person, ...) 这种情况调用，函数内部同样无法判断它的被使用方式是如何。\nnew.target 元属性 为了解决上一节的“函数调用方式”判断的问题， es6 中引入了 new.target 元属性。\n 元属性：一个非对象的属性，用来为他的目标（比如： new )提供额外的相关信息。\n new.target 的取值？？\n  如果函数当做构造函数\n使用 new 来调用，内部调用 [[Constructor]] 的时候， new.target 会被填充\n为 new 操作符指定的目标对象，这个目标对象通常是执行内部构造函数的时候新\n创建的那个对象实例(在函数体重一般是 this ）。\n  如果函数当做普通函数直接调用，那么 new.target 的值为 undefined\n  从上面两点，那么我们就可以通过在函数内部判断 new.target 来判断函数的使用方\n式了。\n1 2 3 4 5 6 7 8 9 10 11 12 13  function Person(name) { if (typeof new.target !== \u0026#39;undefined\u0026#39;) { this.name = name } else { throw new Error(\u0026#39;必须使用 new 创建实例。\u0026#39;) } } var person = new Person(\u0026#39;张三\u0026#39;) console.log(person.name, \u0026#39;new\u0026#39;) var notAPerson = Person.call(person, \u0026#39;李四\u0026#39;) console.log(notAPerson.name, \u0026#39;call\u0026#39;)   由图中的输出证明上面 #1 和 #2 的结论，也由此结论我们可以直接使用 new.target === Person 作为判定条件。\n函数外部使用 new.target :\n1 2 3 4 5 6 7 8  function Person() { } if (new.target === Person) { // ... } console.log(new.target)   块级函数 \u0026lt;= es3 行为 在 es3 或更早些时候，在块级作用域中声明函数会出现语法错误，虽然在之后默认允\n许这样使用（不会报错了），但是各个浏览器之间的处理方式依旧不同，因此在实际开\n发过程中，应该尽量避免这么使用，如果非要在块级作用域声明函数可以考虑使用函数\n表达式方式。\nes5 行为 另外，为了尝试去兼容这种怪异情况，在 es5 的严格模式下如果在块级作用域声明函\n数，会爆出异常。\n1 2 3 4 5 6  \u0026#39;use strict\u0026#39;; if (true) { // 在 es5 中会报语法错误， es6 中不会  function doSth() {} }   es6 行为 在 es6 之后，这种函数声明将会变的合法，且声明之后 doSth() 就成了一个局部函\n数变量，即只能在 if (true) { ... } 这个作用域内部访问，外部无法访问，比如：\n1 2 3 4 5 6 7 8 9 10 11 12 13  \u0026#39;use strict\u0026#39;; if (true) { // 因为有提升，且命名函数的提升包含声明和定义都会被提升  console.log(typeof doSth) // function  function doSth() {} doSth() } // es6 之后存在块级作用域，因此 doSth 是个局部变量，在 // 它的作用域范围之外无法访问 console.log(typeof doSth); // undefined   +RESULTS:\nfunction undefined  决定什么时候该用块级函数 在 4.7.3 一节中使用的是命名式函数声明方式，这种方式声明和定义均被提升，\n因此在声明处至上访问能得到正常结果。\n如果使用表达式 + let 方式，则结果会和用 let 声明一样存在 TDZ 的问题。\n1 2 3 4 5 6 7 8 9 10 11 12  \u0026#39;use strict\u0026#39;; if (true) { // TDZ 区域，访问会异常  console.log(typeof doSth) // error  let doSth = function () {} doSth() } console.log(typeof doSth) // undefined   因此，我们可以根据需求去决定该使用哪种方式去声明块级函数，如果需要有提升则应\n该使用“命名式函数”，如果不需要提升，只需要在声明之后的范围使用应该使用“函数\n表达式”方式去声明函数。\n非严格模式块级函数 在 es6 中的非严格模式下，块级函数的提升不再是针对块级作用域，而是函数体或全\n局环境。\n1 2 3 4 5 6 7 8 9 10 11 12  // 相当于提升到了这里  if (true) { console.log(typeof doSth) // 非严格模式，全局提升  function doSth() {} doSth() } console.log(typeof doSth) // function   +RESULTS:\nfunction function  结果显示外面的 typeof doSth 也是 \u0026lsquo;function\u0026rsquo; 。\n因此，在 es6 之后函数的声明只需要区分严格或非严格模式，而不再需要考虑浏览器\n的兼容问题，相当于统一了标准。\n箭头函数 箭头函数特性 在 es6 中引入了箭头函数，大大的简化了函数的书写，比如\n声明一个函数： function run() {}\n现在： const run = () =\u0026gt; {} 或者 const getName = () =\u0026gt; '张三'\n虽然用起来方便了，但是箭头函数与普通函数又很大的不同，使用的时候必须要注意以\n下几点：\n   序 特性 说明     1 无 this 减少问题，便于优化   2 无 super    3 无 arguments 箭头函数必须依赖命名参数或 rest 参数去访问函数的参数列表   4 无 new.target 元属性 不能被实例化，功能无歧义，不需要这个属性   5 不能 new 实例化    6 无原型 因为不能用 new 因此也不需要原型   7 不能改变 this 指向 此时指向不再受函数本身限制   8 不能有重复的命名参数 之前非严格模式下普通函数是可以有的     箭头函数中如果引用 arguments ，它指向的不再是该箭头函数的参数列表，\n而是包含该箭头函数的那个非箭头函数的参数列表(4.8.6)。\n 没有 this 绑定主要有两点理由：\n  不易追踪，易造成未知行为，众多错误来源\n函数内部 this 的值非常不容易追踪，经常会造成未知的函数行为，箭头函数去\n掉它可以避免这些烦恼\n  便于引擎优化\n限制箭头函数内部使用 this 去执行代码也有利于 JavaScript 引擎更容易去优\n化内部操作，而不像普通函数一样，函数有可能会当做构造函数使用或其他用途。\n   同样，箭头函数也有自己的 name 属性，用来描述函数的名称特征。\n 1 2 3 4 5 6 7 8 9  const print = msg =\u0026gt; { console.log(arguments.length, \u0026#39;arguments\u0026#39;) console.log(this, \u0026#39;this\u0026#39;) console.log(msg) } console.log(print.name) print(\u0026#39;...end\u0026#39;)   +RESULTS:\nprint 0 'arguments' Object [global] { // ... 省略 { [Function: setImmediate] [Symbol(util.promisify.custom)]: [Function] } } 'this' ...end undefined  因为是 nodejs 环境，因此 this 被绑定到了 global 对象上。\n第二行输出结果是 0 'arguments' 说明已经不能使用 arguments 去正确获取传入\n的参数了。\n箭头函数语法 箭头函数语法非常灵活，具体如何使用根据使用场景和实际情况决定。\n比如：\nvar reflect = value =\u0026gt; value; 直接返回原值\n相当于\nvar reflect = function(value) { return value; }\n当只有一个参数时刻省略小括号 ()\n多个参数时候：\nvar sum = (n1, n2) =\u0026gt; n1 + n2;\n函数体更多内容时候：\n1 2 3 4  var sum = (n1, n2) =\u0026gt; { // do more...  return n1 + n2; }   空函数：\nvar empty = () =\u0026gt; {}\n返回一个对象：\nvar getTempItem = id =\u0026gt; ({ id: id, name: 'Temp' })\n等等。。。\n箭头立即函数表达式 在 es6 之前我们要实现一个立即执行函数，一般这样：\n1 2 3 4 5 6 7 8 9 10  let person = function(name) { return { getName: function() { return name } } // 直接在函数后面加上小括号即成为立即执行函数 }(\u0026#39;张三\u0026#39;) console.log(person.getName()) // 张三   +RESULTS:\n张三  PS: 但是为了代码可读性，建议给函数加上小括号。\n箭头函数形式的立即执行函数，不可以直接在 } 后面使用小括号方式：\n1 2 3 4 5 6 7 8 9 10  let person = ((name) =\u0026gt; { return { getName: function() { return name } } })(\u0026#39;张三\u0026#39;) console.log(person.getName()) // 张三   +RESULTS:\n张三  没有 this 对象 在之前我们经常遇到的一个问题写法是事件的监听回调函数中直接使用 this ，这将\n导致引用错误问题，因为事件的回调属于被动触发的，而触发调用该回调的对象是不确\n定的，这就会导致各种问题。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17  var PageHandler = { id: \u0026#34;123456\u0026#34;, init: function() { document.addEventListener(\u0026#34;click\u0026#34;, function(event) { // 这里用了 this ，意图是想在点击事件触发的时候去调用 PageHandler 的  // doSomething 这个函数，但实际却是事与愿违的  // 因为这里的 this 并非指向 Pagehandler 而是事件触发调用回调时候的那个目标对象  this.doSomething(event.type); // error  }, false); }, doSomething: function(type) { console.log(\u0026#34;Handling \u0026#34; + type + \u0026#34; for \u0026#34; + this.id); } };   以往解决方法：通过 bind(this) 手动指定函数调用对象\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18  var PageHandler = { id: \u0026#34;123456\u0026#34;, init: function() { // 经过 bind 之后，回调函数的调用上下文就被绑定到了 PageHandler 这个对象  // 真正绑定到 click 事件的函数其实是执行 bind(this) 之后绑定了上下文的一个函数副本  // 从而执行能得到我们想要的结果  document.addEventListener(\u0026#34;click\u0026#34;, (function(event) { this.doSomething(event.type); // no error  }).bind(this), false); }, doSomething: function(type) { console.log(\u0026#34;Handling \u0026#34; + type + \u0026#34; for \u0026#34; + this.id); } };   虽然问题是解决了，但是使用 bind(this) 无疑多创建了一份函数副本，多少都会有\n些奇怪。\n然后，在 es6 之后这个问题就很好的被箭头函数解决掉：\n根据箭头函数没有 this 绑定的特性，在其内部使用 this 的时候这个指向将是包\n含该箭头函数的非箭头函数所在的上下文，即：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19  var PageHandler = { id: \u0026#34;123456\u0026#34;, init: function() { document.addEventListener( \u0026#34;click\u0026#34;, // 箭头函数无 this 绑定，内部使用 this  // 这个 this 的上下文将有包含该箭头函数的上一个非箭头函数  // 这里即 init() 函数，而 init() 函数的上下文为 PageHandler 对象  // 也就是说这里箭头函数内部的 this 指向的就是 Pagehandler 这个对象  // 从而让代码按照预期运行  event =\u0026gt; this.doSomething(event.type), false); }, doSomething: function(type) { console.log(\u0026#34;Handling \u0026#34; + type + \u0026#34; for \u0026#34; + this.id); } };   箭头函数和数组 在使用数组的一些内置函数时，我们经常会碰到需要传递一个参考函数给他们，比如，\n排序函数 Array.prototype.sort 就需要我们传递一个比较函数用来决定是升序还是\n降序等等。\n如果用箭头函数将大大简化代码：\n1 2 3 4 5 6 7 8 9 10 11 12  // es6 之前 const values = [1, 10, 2, 5, 3] var res1 = values.sort(function(a, b) { // 指定为升序  return a - b; }) // es6 之后 var res2 = values.sort((a, b) =\u0026gt; a - b) console.log(res1.toString(), res2.toString())   +RESULTS:\n1,2,3,5,10 1,2,3,5,10  或者 map(), reduce() 等等用起来会更方便更简洁许多。\n无参数绑定(arguments) 看实例：\n1 2 3 4 5 6 7  function createArrowFunctionReturningFirstArg() { return () =\u0026gt; arguments[0] } var arrowFunction = createArrowFunctionReturningFirstArg(5) console.log(arrowFunction()) // 5   +RESULTS:\n5  从结果看出，返回的 arrowFunction() 箭头函数调用的时候并没有传递任何参数，\n但是执行结果得到了结果这个结果正是包含它的那个非箭头函数\n(createArrowFunctionReturingFirstArt())所接受的参数值。\n因此箭头函数内部如果访问 arguments 对象，此时该对象指向的是包含它的那个非箭头函数的参数列表对象。\n箭头函数的识别 跟普通函数一样， typeof 和 instanceof 对齐依然使用。\n1 2 3 4  var comparator = (a, b) =\u0026gt; a - b; console.log(typeof comparator) // function console.log(comparator instanceof Function) // true   +RESULTS:\nfunction true  在 4.8.1 一节提到过箭头函数是不能改变 this 指向的，但是\n并不代表我们就完全不能使用 call, apply, bind\n比如：\n1 2 3 4  var sum = (n1, n2) =\u0026gt; (this.n1 || 0) + n2 console.log(sum.call(null, 1, 2)) // 3 console.log(sum.call({ n1: 10 }, 1, 2)) // 3   +RESULTS:\n2 2  从这个例子中可以验证，箭头函数是无法修改它的 this 指向的，如果可以修改\n第二个结果值就应该是 12 而不是和第一个一样为 2 ，因为在第二个中\n我们手动将 sum 执行上下文绑定到了一个新的对象上 {n1: 10} 。\n 也就是说，并非不能使用，而是用了也不会有任何变化而已。\n 使用 bind 保留参数：\n1 2 3 4 5 6 7 8 9  var sum = (n1, n2) =\u0026gt; n1 + n2 console.log(sum.call(null, 1, 2)) // 3 console.log(sum.apply(null, [1, 2])) // 3  // 产生新的函数，这种和普通函数使用方式一样 var boundSum = sum.bind(null, 1, 2) console.log(boundSum())   +RESULTS:\n3 3 3  尾调用优化 尾调用：将一个函数的调用放在两一个函数的最后一行。\n或许在 es6 中对于函数相关的最感兴趣的改动就是引擎的优化了，它改变了函数的尾调\n用系统。\n1 2 3  function doSth() { return doSthElse() // tail call }   在 es6 之前，它和普通的函数调用一样被处理：创建一个新的栈帧然后将它推到调用栈\n的栈顶等待被执行, 也就意味着之前的每一个栈帧都在内存里面保留着，如果调用栈过\n大那这将可能是问题的来源。\n有什么不同？ 在 es6 之后优化了引擎，包含尾调用系统的优化（严格模式下，非严格模式下依旧未\n发生改变）。\n优化之后，不再会为尾部调用创建一个新的栈帧，而是将当前的栈帧情况，然后将其复\n用到尾部调用，前提是满足下面几个条件：\n  尾调用函数不需要访问当前栈帧中的任何变量(即尾调用的函数不能是闭包，闭包的\n作用就是用来持有变量)\n  即在尾调用的函数之后不能有其他的代码，即尾调用函数必须是函数体的最后一行\n  尾调用函数的调用结果要作为当前函数的返回值返回\n  比如：下面的函数就满足尾调用优化的条件\n1 2 3 4 5 6 7 8 9 10 11  \u0026#39;use strict\u0026#39;; // 1. 严格模式  function doSth() { // 2. 没有引用任何内部变量，非闭包  // 3. 最后一行  // 4. 调用结果被作为 doSth 的返回值返回  return doSthElse() }   以下情况不会被优化：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21  \u0026#39;use strict\u0026#39;; function doSth() { doSthElse() // 返回作为返回值，不会优化 } function doSth1() { return 1 + doSthElse() // 在尾调用函数返回之后不能有其他操作，不会优化 } function doSth2() { var res = doSthElse() return res // 不是最后一行，即不是将结果立即返回，不会优化 } function doSth3() { var num = 1, func = () =\u0026gt; num return func() // 闭包，不会优化 }   如何利用尾调用优化？ 尾调用最经典的莫过于递归调用了，比如斐波那契数列问题。\n1 2 3 4 5 6 7 8 9 10 11 12  function factorial(n) { if (n \u0026lt;= 1) { return 1; } else { // 不会被优化，因为函数返回之后还需要进行乘积计算才返回  return n * factorial(n - 1); } } console.log(factorial(10))   +RESULTS:\n3628800  上面的并不会被优化，因为尾调用函数并不是立即返回的，修改如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14  function factorial(n, p = 1) { if (n \u0026lt;= 1) { return 1 * p; } else { let res = n * p // 被优化  return factorial(n - 1, res); } } console.log(factorial(10))   +RESULTS:\n3628800  尾调用优化应该是我们在书写代码的时候时常应该考虑的问题，尤其是书写递归的时候，\n当使用递归涉及到大量的计算的时候，\n尾调用优化的优势将会很明显。\n小结    选项 功能 描述 其他     arguments       ES6之前非严格模式 值会随着函数体内参数的改变而改变     ES6之前严格模式 不会响应改变，调用之初就定了     ES6之后行为统一 不会响应改变，内容由实际调用者传递个数决定    函数默认参数 可以是常量值 function add(f, s = 3) {}     可以是变量 var n = 10; function add(f, s = n) {}     可以是函数调用 function getVal() {}; function add(f, s = getVal) {}     默认值参数的执行 调用时有传递则不会检测或执行，未传递则会检测和执行     相互引用 后面的参数可以引用前面的参数变量 function add(f, s = f) {}     临时死区(TDZ)     参数 rest 符号 接受多个参数，合并成数组供函数内部使用 function add(f, ...a) {}     异常使用一 不能用在访问器函数 obj = { set name(...val) {} } 非法。    异常使用二 必须作为函数最后一个参数使用 function add(f, ...s, t) {} 非法。    对arguments影响 非箭头函数没什么影响 arguments总是由调用者传递的参数决定个数   构造函数 new Function() 可以使用默认值，rest符号等功能    展开符(…) 普通多参数函数 Math.max(1, 2, 3, 4, ...)     普通多参数函数apply Math.max.apply(Math, [1, 2, 3, 4])     ES6展开符 Math.max(...[1, 2, 3, 4, ...])    name 属性 函数名称 仅辅助描述功能，易于跟踪函数     特殊情况: 访问器函数 get fnName     特殊情况：bind() 函数 bound fnName     特殊情况：new Function() 匿名函数 anonymous    new.target 函数可直接调用可new构造实例 因此造成函数内部如何识别使用释放问题？     如果作为函数调用 [[Call]] new.target = undefined     如果是 new 构造函数 [[Constructor]] new.target = Person 构造函数本身    块级函数 在 es6之情块级函数的声明处理并没有统一 严格模式必出异常，非严格不好说     es6之后统一标准 严格模式：块级函数只是局部函数 只在作用域内有效     非严格模式：块级函数会提升到函数顶部或全局环境 全局或函数体生效   箭头函数特性 无 this 不易追踪，易于引擎优化 内部可以使用，但是它指向的是当前箭头函数所在的非箭头函数所在的上下文     无 super 没有原型，继承等，不需要 super     无 arguments 内部访问的该对象，其实是当前环境函数的参数，而非箭头函数本身的参数列表     无 new.target 不支持 new 就不存在使用方式问题     无原型 不支持 new     不能改变 this 指向 其内部的 this 已经不是它管辖，可以调用 call, apply, bind 之流，但是不会有任何作用     不能有重复命名参数 非严格模式下ES6之前的普通参数可以用     箭头函数语法 使用方式灵活多变     立即表达式 必须括号包起来再执行，普通函数可直接在 } 后执行 (() =\u0026gt; {})(), function(name){}('xxx')    typeof, instanceof 对箭头函数依旧有效， typeof fn = \u0026lsquo;function\u0026rsquo;, fn instanceof Function (true)    尾调用优化 必须满足三个条件 不满足条件不会优化，典型的递归调用     1. 非闭包，尾函数体内不能访问正函数体内任何变量      2. 结果值必须立即返回，不能参与其他计算后再返回      3. 必须是正函数的最后一个语句      优化之前 尾函数新建栈帧，放在调用栈顶等待调用     优化之后 清空调用栈，将它作为尾调用函数的栈帧复用     对象扩展(Object) 对象分类    类型 说明     普通对象(Ordinary) 拥有所有对象的默认行为   异类对象(Exotic) 和默认行为有所差异   标准对象(Standard) 那些由 ECMAScript 6 定义的，如： Array, Date 等等   内置对象(Built-in) 脚本当前执行环境中的对象，所有标准对象都是内置对象    对象字面量(literal)语法扩展 字面量语法在 JavaScript 中使用非常普遍\n 书写方便 简洁易懂 JSON 就是基于字面量语法演变而来  es6 的来到是的对象字面量语法更加强大简洁易用。\n对象属性简写 \u0026lt;= es5:\n1 2 3 4 5 6  function createPerson(name, age) { return { name: name, age: age } }   es6:\n1 2 3 4 5 6  function createPerson(name, age) { return { name, age } }   简洁函数写法 \u0026lt;= es5:\n1 2 3 4 5 6  var person = { name: \u0026#39;张三\u0026#39;, sayName: function() { console.log(this.name) } }   es6:\n1 2 3 4 5 6  var person = { name: \u0026#39;张三\u0026#39;, sayName() { console.log(this.name) } }   计算属性 在 es6 之前书写对象字面量的时候，可以直接使用多个字符串组成的字符串作为\nkey ，但是这种方式在实际使用中是非常不方便的，假如说 key 是个很长的串呢？？\n1 2 3 4 5  var person = { \u0026#39;first name\u0026#39;: \u0026#39;张三\u0026#39; } console.log(person[\u0026#39;first name\u0026#39;]) // 张三   +RESULTS:\n张三  因此， es6 中支持了变量作为对象属性名去访问，根据变量的值动态决定使用什么\nkey 去访问对象的属性值，这样不管 key 多长，只需要使用变量将它存储起来，\n直接使用变量名去使用将更加方便。\n1 2 3 4 5 6 7 8  var person = {}, lastName = \u0026#34;last name\u0026#34;; person[\u0026#34;first name\u0026#34;] = \u0026#34;张三\u0026#34;; person[lastName] = \u0026#34;李四\u0026#34;; console.log(person[\u0026#34;first name\u0026#34;]); // \u0026#34;张三\u0026#34; console.log(person[lastName]); // \u0026#34;李四\u0026#34;   +RESULTS:\n张三 李四  支持表达式计算属性名：\n1 2 3 4 5 6 7 8 9  var suffix = \u0026#39; name\u0026#39; var person = { [\u0026#39;first\u0026#39; + suffix]: \u0026#39;张三\u0026#39;, [\u0026#39;last\u0026#39; + suffix]: \u0026#39;李四\u0026#39; } console.log(person[\u0026#39;first name\u0026#39;]) // 张三 console.log(person[\u0026#39;last name\u0026#39;]) // 李四   +RESULTS:\n张三 李四  新方法 Object.fromEntries(iterable)2019 将一组 map 类型或似 map 类型的数组转成对象。\n如： [ ['key1', 'value1' ], ['key2', 'value2'] ]\n转换之后： { key1: 'value1', key2: 'value2' }\nObject.is(value1, value2) 在以往我们判断两个值是否相等，经常使用的是 == 和 === ，一般推荐使用后者\n因为前者会有隐式强转，会在比较之前将两个值进行强制转换成同一个类型再比较。\n1 2 3 4 5 6  console.log(\u0026#39;\u0026#39; == false) // true console.log(0 == false) // true console.log(0 == \u0026#39;\u0026#39;) // true console.log(5 == \u0026#39;5\u0026#39;) // true console.log(-0 == +0) // true console.log(NaN == NaN) // true   +RESULTS:\ntrue true true true true false  对于 +0 和 -0 使用 === 的结果是 true ，但实际上他们是有符号的，理论\n上应该是不相等的。\n而两个 NaN 五路你是 == 或 === 都判定他们是不相等的。\n为了解决这些差异， es6 中加入了 Object.is() 接口，意指将等式的判断更加合理\n化，它的含义是两个值是否是同一个值。\n我们看下各对值使用 Object.is() 比较的结果:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20  const is = Object.is const log = console.log // +0, -0 log(\u0026#39;+0 == -0\u0026#39;, +0 == -0) log(\u0026#39;+0 === -0\u0026#39;, +0 === -0) log(\u0026#39;+0 is -0: \u0026#39;, is(+0, -0)) // NaN log(\u0026#39;NaN == NaN: \u0026#39;, NaN == NaN) log(\u0026#39;NaN === NaN: \u0026#39;, NaN === NaN) log(\u0026#39;NaN is NaN: \u0026#39;, is(NaN, NaN)) // number, string log(\u0026#39;5 == \u0026#34;5\u0026#34;: \u0026#39;, 5 == \u0026#39;5\u0026#39;) log(\u0026#39;5 == 5: \u0026#39;, 5 == 5) log(\u0026#39;5 === \u0026#34;5\u0026#34;: \u0026#39;, 5 === \u0026#39;5\u0026#39;) log(\u0026#39;5 === 5: \u0026#39;, 5 === 5) log(\u0026#39;5 is \u0026#34;5\u0026#34;: \u0026#39;, is(5, \u0026#39;5\u0026#39;)) log(\u0026#39;5 is 5: \u0026#39;, is(5, 5))   +RESULTS:\n+0 == -0 true +0 === -0 true +0 is -0: false NaN == NaN: false NaN === NaN: false NaN is NaN: true 5 == \u0026quot;5\u0026quot;: true 5 == 5: true 5 === \u0026quot;5\u0026quot;: false 5 === 5: true 5 is \u0026quot;5\u0026quot;: false 5 is 5: true  因此， Object.is 能够弥补， === 无法判断出 +0, -0, NaN, Nan 相等的结\n果。\nObject.assign(target, source, source1, source2, …) 参数：\n target 接受拷贝的对象，也将返回这个对象 source 拷贝内容的来源对象 来源对象参数可以有多个，如果存在同名属性值，最后的值由最后一个拥有同名属\n性对象中的值为准  TC39.ECMA262 实现原理图：\n合并对象，将 source 中自身的可枚举的属性浅拷贝到 target 对象中，返回\ntarget 对象。\n混合器(Mixins)在 JavaScript 中被广泛使用，在一个 mixin 中，一个对象可以从\n另个对象中接受他们的属性和方法，即浅拷贝，许多 JavaScript 库都会有一个与下面\n类似的 mixin 函数:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36  const mixin = (receiver, supplier) =\u0026gt; { Object.keys(supplier).forEach( key =\u0026gt; receiver[key] = supplier[key]) return receiver } function EventTarget() {} EventTarget.prototype = { constructor: EventTarget, get name() { return \u0026#39;EventTarget.prototype\u0026#39; }, emit: function(msg) { console.log(msg, \u0026#39;in EventTarget.prototype\u0026#39;) }, on: function(msg) { console.log(msg, \u0026#39;on EventTarget.prototype\u0026#39;) } } const myObj1 = {} mixin(myObj1, EventTarget.prototype) myObj1.emit(\u0026#39;something changed from myObj1\u0026#39;) console.log(myObj1.name, \u0026#39;obj1 name\u0026#39;) const myObj2 = {} Object.assign(myObj2, EventTarget.prototype) myObj2.on(\u0026#39;listen from myObj1\u0026#39;) console.log(myObj2.name, \u0026#39;obj2 name\u0026#39;) console.log(EventTarget.prototype, myObj1, myObj2)   +RESULTS:\nsomething changed from myObj1 in EventTarget.prototype EventTarget.prototype obj1 name listen from myObj1 on EventTarget.prototype EventTarget.prototype obj2 name  由于 mixin(), Object.assign 的实现都是采用的 = 操作符，因此是没法拷贝\n访问器属性的，或者说拷贝过来之后就不会再是访问器属性了，看上面代码的运行结果对比图：\n多个来源对象支持：\n1 2 3 4 5 6 7 8 9 10 11 12 13  const receiver = {} const res = Object.assign(receiver, { name: \u0026#39;xxx\u0026#39;, age: 100 }, { height: 180 }, { color: \u0026#39;yellow\u0026#39;, age: 80 }) console.log(receiver === res) console.log(res)   +RESULTS:\ntrue { name: 'xxx', age: 80, height: 180, color: 'yellow' }  最后 age: 80 值是最后一个来源对象中的值，返回值即第一个参数对象。\n重复属性 \u0026lt;= es5 严格模式下，重复属性会出现语法错误：\n1 2 3 4 5 6  \u0026#39;use strict\u0026#39;; var person = { name: \u0026#39;xxx\u0026#39;, name: \u0026#39;yyy\u0026#39; // syntax error in es5 strict mode }   es6 无论严格或非严格模式下都属合法操作，其值为最后一个指定的值：\n1 2 3 4 5 6 7 8  \u0026#39;use strict\u0026#39;; var person = { name: \u0026#39;xxx\u0026#39;, name: \u0026#39;yyy\u0026#39; // no error } console.log(person.name)   +RESULTS:\nyyy  自有属性枚举顺序 \u0026lt;= es5 中是不会定义对象属性的枚举顺序的，它的枚举顺序是在实际运行时取决于所处\n的 JavaScript 引擎。\nes6 中严格定义了枚举时返回的属性顺序，这将会影响在使用\nObjct.getOwnPropertyNames() 和 Reflect.ownKeys 时属性该如何返回。\n枚举时基本顺序遵循：\n  所有数字类型的 keys 为升序排序\n  所有字符串类型的 keys 按照它添加的时机排序\n  所有符号类型(Symbols)的 keys 按照它添加的时机排序\n  三者的优先级为： numbers \u0026gt; strings \u0026gt; symbols\n1 2 3 4 5 6 7 8 9 10 11 12  var obj = { a: 1, 0: 1, c: 1, 2: 1, b: 1, 1: 1 } obj.d = 1 console.log(Object.getOwnPropertyNames(obj).join(\u0026#39;\u0026#39;)) // 012acbd   +RESULTS:\n012acbd   由于并非所有 JavaScript 引擎并非统一实现方式，导致 for-in 循环依旧无法确定\n枚举的顺序。\n并且 Object.keys() 和 JSON.stringify() 采用的枚举顺序和 for-in 一样。\n 1 2 3 4 5 6 7 8 9 10 11 12 13 14  var obj = { a: 1, 0: 1, c: 1, 2: 1, b: 1, 1: 1 } obj.d = 1 for (let prop in obj) { console.log(prop) }   功能更强的原型对象 原型是 JavaScript 中实现继承的基石，早起的版本中严重限制了原型能做的事情，\n然后随着 JavaScript 的逐渐成熟程序员们开始越来越依赖原型，我们现在能很清晰\n地感受到开发者们对原型控制上和易用性的渴望越来越强烈，由此 ES6 对齐进行了加强。\n改变对象原型 正常情况下，对象通过构造函数或 Object.create() 创建的同时原型也就被创建了。\nES5 中可以通过 Object.getPrototypeof() 方法去获取对象原型，但是依然\n缺少一个标准的方式去获取失利之后的对象原型。\nES6 增加了 Object.setPrototypeof(source, target) 用来改变对象的原型指向，\n指将 source.prototype 指向 target 对象。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21  let person = { getGreeting() { return \u0026#34;Hello\u0026#34;; } }; let dog = { getGreeting() { return \u0026#34;Woof\u0026#34;; } }; // prototype is person let friend = Object.create(person); console.log(friend.getGreeting()); // \u0026#34;Hello\u0026#34; console.log(Object.getPrototypeOf(friend) === person); // true  // set prototype to dog Object.setPrototypeOf(friend, dog); console.log(friend.getGreeting()); // \u0026#34;Woof\u0026#34; console.log(Object.getPrototypeOf(friend) === dog); // true   实际上，一个对象的原型是存储在它的内部属性 [[Prototype]] 上的， Object.getPrototypeOf()\n获取的也是这个属性的值， Object.setPrototypeOf() 设置也是改变这个属性的值。\n旧版原型的访问 比如：如果想在实例中重写原型的某个方法的时候，需要在重写的方法内调用原型方法\n时候，以往是这样搞\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28  let person = { getGreeting() { return \u0026#34;Hello\u0026#34;; } }; let dog = { getGreeting() { return \u0026#34;Woof\u0026#34;; } }; let friend = { getGreeting() { return Object.getPrototypeOf(this).getGreeting.call(this) + \u0026#34;, hi!\u0026#34;; } }; // set prototype to person Object.setPrototypeOf(friend, person); console.log(friend.getGreeting()); // \u0026#34;Hello, hi!\u0026#34; console.log(Object.getPrototypeOf(friend) === person); // true  // set prototype to dog Object.setPrototypeOf(friend, dog); console.log(friend.getGreeting()); // \u0026#34;Woof, hi!\u0026#34; console.log(Object.getPrototypeOf(friend) === dog); // true   通过 Object.getPrototypeOf(this).getGreeting.call(this) … 去获取原型中的\n方法\n通过 super 引用简化原型的访问 如之前所提，原型是 JavaScript 中一个很重要也很常用的一个对象，ES6 对他们的使\n用进行了简化。\n另外 es6 对原型的另一个改变是 super 的引用，这让对象访问原型对象更加方便。\n而在 es6 增加 super 之后就变得异常简洁了：\n1 2 3 4 5 6 7  let friend = { getGreeting() { // in the previous example, this is the same as:  // Object.getPrototypeOf(this).getGreeting.call(this)  return super.getGreeting() + \u0026#34;, hi!\u0026#34;; } };   类似其他语言的继承， friend 是实例，它的原型是它的父类，在实例中的 super\n其实是指向父类的引用，因此可以直接在子类中直接使用 super 去使用父类的方法。\n只能在简写函数中访问 super 但是 super 只能在对象的简写方法中使用，如果是使用 “function” 关键词声明的\n函数中使用会出现\nsyntax error\n比如：下面的方式是非法的\n1 2 3 4 5 6  let friend = { getGreeting: function() { // syntax error  return super.getGreeting() + \u0026#34;, hi!\u0026#34;; } };   因为 super 在这种函数的上下文中中不存在的。\nObject.getPrototypeOf() 并不是所有场景都能使用的 因为 this 的指向是根据函数的执行上下文来决定了，因此使用 this 是完全靠谱\n的。\n比如：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21  let person = { getGreeting() { return \u0026#34;Hello\u0026#34;; } }; // prototype is person let friend = { getGreeting() { return Object.getPrototypeOf(this).getGreeting.call(this) + \u0026#34;, hi!\u0026#34;; } }; Object.setPrototypeOf(friend, person); // prototype is friend let relative = Object.create(friend); console.log(person.getGreeting()); // \u0026#34;Hello\u0026#34; console.log(friend.getGreeting()); // \u0026#34;Hello, hi!\u0026#34; console.log(relative.getGreeting()); // error!   上面的 relative.getGreeting()) 会报错，原因是 relative 本身是个新的变量，\n这个变量指向由 Object.create(friend) 创建的一个空对象，其原型为 friend ，\n即 reletive.getGreeting() 的调用首先在 friend 中找但没找到，最后在\nfriend 中找到了，也就是说它实际上调用的就是原型上的 getGreeting() 然后原\n型方法里面又是通过 this 去调用了原型的方法(也就自身)，由于 this 始终是根\n据当前上下文发生变化的，此时它的指向是 friend ，最终会导致循环调用。\n而用 super 就不会有上面的问题，因为 super 指向是固定的，就是指向当前对象\n的原型对象（父对象），即这里指向的是 person 。\nsuper 引用的过程 一般情况下是没什么区别的，但是在我们做继承或者获取对象的原型的时候就很有用了，\n因为 super 的指向是和 [[HomeObject]] 密切相关的， super 获取指向的过程：\n  通过在当前方法的内部属性 [[HomeObject]] 上面调用 Object.getPrototypeOf()\n去获取这个方法所在对象的原型对象；\n  在原型对象上搜与这个函数同名函数；\n  最后将这个同名函数绑定当前的 this 执行，然后执行这个函数。\n  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  let person = { getGreeting() { return \u0026#34;Hello\u0026#34;; } }; // prototype is person let friend = { getGreeting() { return super.getGreeting() + \u0026#34;, hi!\u0026#34;; } }; Object.setPrototypeOf(friend, person); console.log(friend.getGreeting()); // \u0026#34;Hello, hi!\u0026#34;   比如，上面的代码\n  将 person 设置为 friend 的原型，成为它的父对象\n  调用 friend.getGreeting() 执行之后在其内部使用 super.getGreeting() 这\n个一开始会找到 friend.getGreeting 这个方法的 [[HomeObject]] 也就是 friend\n  然后根据扎到的 friend ，通过 Object.getPrototypeOf() ，去找到原型对象，\n即 person ，找到之后再去这里面找同名函数 getGreeting\n  找到之后将该函数执行上下文绑定到 this (即 friend 所在的上下文）。\n  执行同名函数，此时这个虽是原型(person)上的函数，但是上下文已经被绑定到\n了 friend 上\n  过程简单描述就是：\n设置继承\n=\u0026gt; 重写方法\n=\u0026gt; super 调用父级方法\n=\u0026gt; 找当前函数的 [[HomeObject]]\n=\u0026gt; Object.getPrototypeOf([[HomeObject]]) 找原型\n=\u0026gt; 找原型上同名函数\n=\u0026gt; 绑定找到的同名函数到当前的 this\n=\u0026gt; 执行同名函数\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  var person = { fnName: \u0026#39;person\u0026#39;, getName() { return this.fnName } } var child = { fnName: \u0026#39;child\u0026#39;, getName() { return super.getName() + \u0026#39;,\u0026#39; + this.fnName } } Object.setPrototypeOf(child, person) console.log(child.getName()) // child child   方法定义 在 es6 之前是没有“方法”这个词的定义的，但在 es6 之后对方法的定义才正式有了规定。\n函数和方法定义 在对象中的函数才叫做方法，非对象中的叫做函数，且 es6 给方法增加了一个\n[[HomeObject]] 内置属性， 它指向的是包含这个方法的那个对象。\n比如：\n1 2 3 4 5 6 7 8 9 10 11  let person = { // method  getGreeting() { return \u0026#39;xxx\u0026#39; } } // not method function shareGreeting() { return \u0026#39;yyy\u0026#39; }   getGreeting 叫做方法，且其有个内部属性 [[HomeObject]] 指向了 person 说明这\n个对象拥有它。\nshareGreeting 叫做函数，不是方法\n总结 更新内容\n   内容 示例/说明     属性简写 {name, age} \u0026lt;=\u0026gt; {name: name, age: age}   计算属性 { [first + 'name']: '张三' }, { ['first name']: '张三' }   简写方法 { getName() {} }   重复属性名合法化 { age: 10, age: 100 } \u0026lt;=\u0026gt; { age: 100 }   Object.assign 合并对象 浅拷贝，内部 = 实现拷贝   Object.is 加强判断，弥补 === 不能判断 +0, -0 和 NaN, NaN 问题   固定对象属性枚举顺序 number \u0026gt; string \u0026gt; symbol, string 和 symbol 按照增加先后顺序排列   Object.setPrototypeOf 可改变对象原型   super 指向原型对象，可通过它去访问原型对象中的方法    数据解构 解构优势 在 es5 及之前如果我们想要从对象中取出属性的值，只能通过普通的赋值表达式来实现，\n一个还好，如果是多个的话就会出现很重复的代码，比如：\n1 2 3 4 5 6 7 8 9 10  let options = { repeat: true, save: false } let repeat = options.repeat, save = options.save // if more ???   上面只是取两个对象的属性，如果很多呢，十几个二十几个？？\n不仅代码量大，还不美观。\n因此 es6 加入了解构系统，让这些操作变的很容易，很简洁。\n对象解构 对象解构的时候，等号右边不能是 null 或 undefined ，这样会报错，这是因为，\n无论什么时候去读取 null 或 undefined 的属性都会出发运行时错误。\n声明式解构 解构的同时声明解构后赋值的变量：\n1 2 3 4 5 6 7 8 9  let node = { type: \u0026#39;Identifier\u0026#39;, name: \u0026#39;foo\u0026#39; } let { type, name } = node console.log(type) // Identifier console.log(name) // foo   在使用解构的过程中必须要有右边的初始值，而不能只是用来声明变量，这是不合法的\n操作, 比如：\n1 2 3 4 5 6 7 8  // syntax error! var { type, name }; // syntax error! let { type, name }; // syntax error! const { type, name };   先声明后解构 有时候有些变量早已经存在了，只是后面我们需要将它的值改变，也正好是需要从对象\n中去取值，这个时候就是先声明后解构：\n1 2 3 4 5 6 7 8 9 10 11 12 13  let node = { type: \u0026#34;Identifier\u0026#34;, name: \u0026#34;foo\u0026#34; }, // 这里变量已经声明好了  type = \u0026#34;Literal\u0026#34;, name = 5; // assign different values using destructuring ({ type, name } = node); console.log(type); // \u0026#34;Identifier\u0026#34; console.log(name); // \u0026#34;foo\u0026#34;   这个时候必须用 () 将解构语句包起来，让其成为一个执行语句，如果不，左边就相\n当于一个块级语句，然而块级语句是不能出现在等式的左边的。\n在这基础上，另一种情况是将 {type, name} = node 作为参数传递给函数的时候，\n这个时候传递给函数的参数其实就是 node 本身，例如：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  let node = { type: \u0026#34;Identifier\u0026#34;, name: \u0026#34;foo\u0026#34; }, type = \u0026#34;Literal\u0026#34;, name = 5; function outputInfo(value) { console.log(value === node); } outputInfo({ type, name } = node); // true  console.log(type); // \u0026#34;Identifier\u0026#34; console.log(name); // \u0026#34;foo\u0026#34;   解构默认值 在解构过程中，可能左边声明的变量在右边的对象中并不存在或者值为 undefined\n的时候，这个变量的值将会赋值为 undefined ，因此这个时候就需要针对这种情况\n有个默认处理，即这里的解构默认值。\n1 2 3 4 5 6 7 8 9 10  let node = { type: \u0026#34;Identifier\u0026#34;, name: \u0026#34;foo\u0026#34; }; let { type, name, value } = node; console.log(type); // \u0026#34;Identifier\u0026#34; console.log(name); // \u0026#34;foo\u0026#34; console.log(value); // undefined   属性值为 undefined 的情况：\n1 2 3 4 5 6 7 8 9 10 11  let node = { type: \u0026#34;Identifier\u0026#34;, name: \u0026#34;foo\u0026#34;, value: undefined }; let { type, name, value = 0 } = node; console.log(type); // \u0026#34;Identifier\u0026#34; console.log(name); // \u0026#34;foo\u0026#34; console.log(value); // 0   属性变量重命名 解构出来之后，可能不想沿用右边对象中的属性名，因此需要将左边的变量名称重命名：\n1 2 3 4 5 6 7 8 9  let node = { type: \u0026#34;Identifier\u0026#34;, name: \u0026#34;foo\u0026#34; }; let { type: localType, name: localName } = node; console.log(localType); // \u0026#34;Identifier\u0026#34; console.log(localName); // \u0026#34;foo\u0026#34;   重命名 + 默认值:\n1 2 3 4 5 6 7 8 9  let node = { type: \u0026#34;Identifier\u0026#34;, name: \u0026#34;foo\u0026#34; }; let { type: localType, name: localName = \u0026#39;xxx\u0026#39; } = node; console.log(localType); // \u0026#34;Identifier\u0026#34; console.log(localName); // \u0026#34;foo\u0026#34;   多级对象解构 右边对象中的属性的值不一定是普通类型，可能是对象，或对象中包含对象，数组等等\n类型，次数可以使用内嵌对象解构来进行解构：\n原则就是左边的变量的结构要和右边实际对象中的结构保持一致\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19  let node = { type: \u0026#34;Identifier\u0026#34;, name: \u0026#34;foo\u0026#34;, loc: { start: { line: 1, column: 1 }, end: { line: 1, column: 4 } } }; let { loc: { start }} = node; console.log(start.line); // 1 console.log(start.column); // 1   多层解构重命名：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21  let node = { type: \u0026#34;Identifier\u0026#34;, name: \u0026#34;foo\u0026#34;, loc: { start: { line: 1, column: 1 }, end: { line: 1, column: 4 } } }; // 重命名 let { loc: { start: localStart }} = node; console.log(start.line); // 1 console.log(start.column); // 1    #+BEGINQUOTE\n语法陷阱 1 2  // no variables declared! let { loc: {} } = node;   这种形式实际上是没任何作用的，因为左边的 loc 只是起到了站位的作用，实际起\n作用的是在 {} 里面，但是里面没任何东西，也就是说这个不会解构出任何东西，也\n不会产生任何新的变量。\n#+ENDQUOTE\n数组解构 数组解构和对象解构用法基本是一样的，无非就是讲 {} 改成数组的 [] ，和对象\n一样，右边不可以是 null 和 undefined\n   表达式 结果 说明     let [first, second] = [1, 2] first = 1, first = 2 普通解构   let [ , , third] = [1, 2, 3] third = 3 空置解构，只指定某个位置解构   let first = 1, second = 2 =\u0026gt; [first, second] = [11, 22] first = 11, second = 22 先声明再解构   let a = 1, b = 2 =\u0026gt; [a, b] = [b, a] a = 2, b = 1 替换值快捷方式   let [a = 1, b] = [11, 22] a = 11, b = 22 默认值   let [a = 1, b] = [, 22] a = 1, b = 22 默认值   let [a, b = 2] = [ 1 ] a = 1, b = 2 默认值   let [a, [b]] = [1, [2]] a = 1, b = 2 嵌套解构   let [a, [b]] = [1, [2, 3], 4] a = 1, b = 2 嵌套解构   let [a, [b], c] = [1, [2, 3], 4] a = 1, b = 2, c = 4 复杂解构   let [a, ...bs] = [1, 2, 3, 4, 5] a = 1, bs = [2, 3, 4, 5] rest 符号解构   [1, 2, 3].concat() =\u0026gt; [1, 2, 3] =\u0026gt; es6: [...as] = [1, 2, 3] as = [1, 2, 3] 克隆数组    混合解构 混合解构意味着被解构的对象中可能既包含对象由包含数组，也是按照对象和数组的解\n构原理进行解构就OK。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24  let node = { type: \u0026#34;Identifier\u0026#34;, name: \u0026#34;foo\u0026#34;, loc: { start: { line: 1, column: 1 }, end: { line: 1, column: 4 } }, range: [0, 3] }; let { loc: { start }, range: [ startIndex ] } = node; console.log(start.line); // 1 console.log(start.column); // 1 console.log(startIndex); // 0   参数解构 参数解构，即函数在声明的时候，参数是采用解构等式左边的形式书写，这种就需要要\n求在调用的时候, 这个参数位置必须有个非 null 和 Undefined 值，否则会报错，原因\n一样解构时候无法从 null 或 undefined 读取属性。\n被解构的参数属性列表 实例：\n1 2 3 4 5 6 7 8 9  function setCookie(name, value, { secure, path, domain, expires }) { // code to set the cookie } setCookie(\u0026#34;type\u0026#34;, \u0026#34;js\u0026#34;, { secure: true, expires: 60000 })   不传值得非法操作：\n1 2  // Error! setCookie(\u0026#34;type\u0026#34;, \u0026#34;js\u0026#34;);   这样第三个参数就是 undefined 报错。\n优化参数解构写法有两种：\n 函数体内解构 解构体默认值方式(推荐)  函数体内解构： 1 2 3 4 5 6 7  function setCookie(name, value, options) { // 函数体内解构，给个默认值 || {} ，或者在参数那里这样： (name, value, options = {})  let { secure, path, domain, expires } = options || {}; // code to set the cookie }   或者：\n1 2 3 4 5 6 7  function setCookie(name, value, options = {}) { let { secure, path, domain, expires } = options; // code to set the cookie }   直接参数解构体给默认值： 1 2 3 4  function setCookie(name, value, { secure, path, domain, expires } = {}) { // ... }   默认值，如果不传第三个参数，那么它的默认值就是 {} 避免解构出错。\n解构的参数默认值 和普通对象一样，解构出来的参数我们还可以给他们一个默认值：\n1 2 3 4 5 6 7 8 9 10 11  function setCookie(name, value, { secure = false, path = \u0026#34;/\u0026#34;, domain = \u0026#34;example.com\u0026#34;, expires = new Date(Date.now() + 360000000) } = {} ) { // ... }    第三个参数没传，四个参数都取默认值 第三个参数有传递，根据普通对象定义解构  总结  对象，先声明再解构，表达式必须用 () 包起来，作为表达式执行 对象数组解构都可以给默认值，重命名，多层解构，混合解构 解构遵循左侧最内层的变量声明，如果左侧最内层无任何变量，则解构表达式无任何意义 参数解构，要么给当前参数默认值，要么保证调用时该参数都有传入非 null 或\nundefined 的值，推荐参数默认值  符号和符号属性(Symbols) 符号类型值(Symbol())是 es6 新增的一种原始数据类型和 strings, numbers,\nbooleans, null 和 undefined 属于原始值类型。\n它相当于数字的 42 或字符串的 \u0026ldquo;hello\u0026rdquo; 一样，只是单穿的一些值，因此不能对其使\n用 new Symbol() 否则会报错。\n符号类型是作为一种创建私有对象成员的类型，在 es6 之前是没有什么方法可以区分普\n通属性和私有属性的。\n新增属性或方法 Symbol.description2019 返回符号变量的描述。\n如： Symbol('my symbol') 的 Symbol.description 值为 \u0026lsquo;my symbol\u0026rsquo;。\n也就是返回内置属性 [[Description] ] 的值。\n创建符号 符号类型会创建一个包含唯一值得符号变量，这些变量是没有实际字面量表示的，也就\n是说一旦符号变量创建之后，只能通过这个变量去访问你所创建的这个符号类型。\n创建符号 通过 Symbol([ description ]) 来创建符号，创建过程：\n 如果 description 是 undefined, 让 descString = undefined 否则 descString = ToString(description) 让内部值 [[Description]] 为 descString 返回一个唯一的 Symbol 值  1 2 3 4 5 6 7 8 9 10 11 12  let firstName = Symbol(); let secondName = Symbol(); let person = {}; person[firstName] = \u0026#34;Nicholas\u0026#34;; console.log(person[firstName]); // \u0026#34;Nicholas\u0026#34;  console.log(firstName) console.log(secondName) console.log(firstName == secondName) console.log(firstName === secondName) console.log(Object.is(firstName, secondName))   +RESULTS:\nNicholas Symbol() Symbol() false false false  firstName 是存放了一个唯一值得符号类型变量，并且用来作为 person 对象的一\n个属性使用。\n因此，如果要访问对象中的对应的这个属性的值，每次都必须使用 firstName 这个\n符号变量去访问。\n 如果需要实在需要符号类型对象，可以通过 new Object(Symbol()) 去创建一个对象，\n而不能直接 new Symbol() 因为 Symbol() 得到的是一个原始值，就像你不能直接\nnew 42 一个道理。\n 带参数的 Symbol(arg) 有时候可能需要对创建的符号做一些简单的区分，或者让其更加语义化，可以在创建的\n时候给 Symbol() 函数\n一个参数，参数本身并没有实际的用途，但是有利于代码调试。\n1 2 3 4 5 6 7 8 9 10  let firstName = Symbol(\u0026#34;first name\u0026#34;); let person = {}; person[firstName] = \u0026#34;Nicholas\u0026#34;; console.log(\u0026#34;first name\u0026#34; in person); // false console.log(person[firstName]); // \u0026#34;Nicholas\u0026#34; console.log(firstName); // \u0026#34;Symbol(first name)\u0026#34; console.log(firstName.description) // undefined console.log(Symbol(\u0026#39;xxx\u0026#39;).description) // undefined   +RESULTS:\nfalse Nicholas Symbol(first name) undefined undefined  如输出，参数会一并输出，因此推荐使用的时候加上参数，这样在调试的时候你就能区\n分开哪个符号来自哪里，而不至于输出都是 Symbol() 无法区分。\n参数作为符号的一种描述性质特征被储存在了内部 [[Description]] 属性中，这个属性\n会在对符号调用 toString() (隐式或显示调用)的时候去读取它的值，除了这个没有\n其他方法可以直接去访问 [[Description]] 。\n符号类型检测(typeof) 由于符号属于原始值，因此可以直接通过 typeof 就可以去判断变量是不是符号类型，\nes6 对 typeof 进行了扩展，如果是符号类型检测的结果值是“symbol”\n1 2 3  let symbol = Symbol(\u0026#34;test symbol\u0026#34;) console.log(typeof symbol) // \u0026#34;symbol\u0026#34;   +RESULTS:\nsymbol  使用符号 之前的例子中使用变量作为对象属性名的，都可以使用符号来替代，并且还可以对符号\n类型的属性进行定制，让其变成只读的。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22  // 创建符号，唯一 let firstName = Symbol(\u0026#39;first name\u0026#39;) let person = { // 直接当做计算属性使用  [firstName]: \u0026#39;张三\u0026#39; } // 让属性只读 Object.defineProperty(person, firstName, { writable: false }) let lastName = Symbol(\u0026#39;last name\u0026#39;) Object.defineProperties(person, { [lastName]: { value: \u0026#39;李四\u0026#39;, writable: false } }) console.log(person[firstName]) console.log(person[lastName])   +RESULTS:\n张三 李四  分享符号 在使用过程中我们需要考虑一个问题：\n假设某个地方声明了一个符号类型及一个使用了这个符号作为属性 key 的对象，哪天\n如果我想在其他地方去使用它，该怎么办？？\n如今模块化得到普及，现在经常都是一个文件一个模块，用的时候导入这个文件得到相应的对象\n但由于符号值是唯一的，那外部模块又怎么知道另一个模块内部用了怎样的符号值作为对象？？\n这就是下面要讲的“符号分享”问题。\n 全局符号注册表(Global Symbol Registry) 会在所有代码执行之前就创建好，且列表为空。\n它和全局对象一样属于环境变量，因此不要去假设它是什么或它不存在之类的，因此它在所有代码执行之前\n就创建好了，所以它是确确实实存在的。\n Symbol.for() 在之前我们通过 let firstName = Symbol('first name'); 来创建一个符号变量，但是在使用的时候必须的用\nfirstName 去使用这个变量，而现在我们想将符号分享出去需要用到 Symbol.for() 。\nSymbol.for(description) 会针对 description 去创建一个唯一的符号值：\n1 2 3 4 5 6 7  let uid = Symbol.for(\u0026#34;uid\u0026#34;); let object = {}; object[uid] = \u0026#34;12345\u0026#34;; console.log(object[uid]); // \u0026#34;12345\u0026#34; console.log(uid); // \u0026#34;Symbol(uid)\u0026#34;   Symbol.for(desc) 在第一次调用的时候，首先会去“全局符号注册表(global symbol registry)” 中去查找\n这个 desc 对应的符号值，找到了就返回这个符号值，如果没找到会创建一个新的符号值并且将它注册到全局符号注册表中，\n供下次调用时使用。\n-—\nSymbol.for(key) 内部实现步骤(伪代码)：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29  Symbol.for = function (key) { // 1 key 转字符串  let stringKey = ToString(key); // 2. 遍历 GlobalSymbolRegistryList 注册表  for (let e in GlobalSymbolRegistryList) { // 符号值已经存在  if (SameValue(e.[[Key]], stringKey)) { return e.[[Symbol]]; } } // 3. 注册表中不含 `stringKey` 的符号值，则创建新的符号值  // 3.1 新建符号值  let newSymbol = Symbol(stringKey); // 3.1 给 [[Description]] 赋值  newSymbol.[[Description]] = stringKey; // 4. 注册到符号注册表中去  GlobalSymbolRegistryList.push({ [[Key]]: stringKey, [[Symbol]]: newSymbol }); // 5. 返回新建的符号值  return newSymbol; }   总结起来为3个步骤： 查找 -\u0026gt; 新建 -\u0026gt; 注册\n注册表中的每个符号片段是以对象形式存在(对象中包含 Key 和 Symbol 两个属性分别表示创建时的描述和符号值)。\n使用分享符号 在上一节7.4.1 中我们描述过了用来创建分享符号的 Symbol.for(desc) 接口，这里将探讨如何具体使用它来分享符号值。\n1 2 3 4 5 6 7 8 9 10 11 12 13  let uid = Symbol.for(\u0026#34;uid\u0026#34;); let object = { [uid]: \u0026#34;12345\u0026#34; }; console.log(object[uid]); // \u0026#34;12345\u0026#34; console.log(uid); // \u0026#34;Symbol(uid)\u0026#34;  let uid2 = Symbol.for(\u0026#34;uid\u0026#34;); console.log(uid === uid2); // true console.log(object[uid2]); // \u0026#34;12345\u0026#34; console.log(uid2); // \u0026#34;Symbol(uid)   在当前代码运行的全局作用域中都可以分享到一份 Symbol.for(\u0026quot;uid\u0026quot;) 符号，只需要调用它就可以拿到那个\n唯一的值。\n比如：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32  function createObj1() { let uid = Symbol.for(\u0026#34;uid\u0026#34;); let object = { [uid]: \u0026#34;12345\u0026#34; }; return object } function createObj2() { let uid = Symbol.for(\u0026#34;uid\u0026#34;); let object = { [uid]: \u0026#34;67890\u0026#34; }; return object } let uid1 = Symbol.for(\u0026#34;uid\u0026#34;); const obj1 = createObj1() let uid2 = Symbol.for(\u0026#34;uid\u0026#34;); const obj2 = createObj2() console.log(uid1 === uid2); console.log(obj1[uid1]); console.log(obj1[uid2]); console.log(obj2[uid1]); console.log(obj2[uid2]);   +RESULTS:\ntrue 12345 12345 67890 67890  Symbol.keyFor(symbolValue) 我们如果想创建或获取全局注册表中的符号是可以通过 7.4.1 中的 Symbol.for(key) ，但是\n如果我们只知道一个符号值变量的情况下，使用 Symbol.for(key) 就没法从注册表中取值了。\n因此，这里将介绍如何使用 Symbol.keyFor(symbolValue) 去根据符号变量查找注册表中的值。\n在这之前需要知道\n Symbol.for(key) 创建的符号才会进入全局注册表 Symbol() 直接创建的是不会加入全局注册表的  也就有了下面的代码及结果：\n1 2 3 4 5 6 7 8  let uid = Symbol.for(\u0026#34;uid\u0026#34;); console.log(Symbol.keyFor(uid)); // \u0026#34;uid\u0026#34;  let uid2 = Symbol.for(\u0026#34;uid\u0026#34;); console.log(Symbol.keyFor(uid2)); // \u0026#34;uid\u0026#34;  let uid3 = Symbol(\u0026#34;uid\u0026#34;); console.log(Symbol.keyFor(uid3)); // undefined   +RESULTS:\nuid uid undefined  因此 Symbol(\u0026quot;uid\u0026quot;); 结果不会加入注册表，因此结果是 undefined 。\n符号强制转换 在 JavaScript 中类型强制转换是经常会被用到的一个特性，也让 JavaScript 使用起\n来会很灵活地可以将一个数据类型转成另一种数据类型。\n但是符号类型不支持强制转换。\n1 2 3 4 5  let uid = Symbol.for(\u0026#34;uid\u0026#34;) console.log(uid) // Symbol(uid)  // 在输出的时候实际上是调用了 uid.toString()   +RESULTS:\nSymbol(uid)  当我们将符号变量加入计算或字符串操作时会报错，因为两个不同类型的值进行操作会\n发生隐式转换，但是符号类型不支持强转的，因此会报异常。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  let uid = Symbol.for(\u0026#39;uid\u0026#39;), desc = \u0026#39;\u0026#39;, sum = 0 try { desc = uid + \u0026#34;\u0026#34; } catch (e) { console.log(e.message) } try { sum = uid / 1 } catch (e) { console.log(e.message) }   +RESULTS: 异常信息\nCannot convert a Symbol value to a string Cannot convert a Symbol value to a number  获取对象符号属性 获取对象属性的方法：\n Object.keys() 会获取所有可枚举的属性 Object.getOwnPropertyNames() 获取所有属性，忽略可枚举性  但是为了兼容 es5 及以前的版本，他们都不会去获取符号属性，因此需要使用\nObject.getOwnPropertySymbols() 去单独获取对象所有的符号属性，返回一个包含所\n有符号属性的数组。\n1 2 3 4 5 6 7 8 9 10 11  let uid = Symbol.for(\u0026#34;uid\u0026#34;); let object = { [uid]: \u0026#34;12345\u0026#34;, [Symbol.for(\u0026#34;uid2\u0026#34;)]: \u0026#34;67890\u0026#34; }; let symbols = Object.getOwnPropertySymbols(object); console.log(symbols.length); // 1 console.log(symbols[0]); // \u0026#34;Symbol(uid)\u0026#34; console.log(object[symbols[0]]); // \u0026#34;12345\u0026#34;   +RESULTS:\n2 Symbol(uid) 12345  符号内部操作(方法) 在 es6 中 JavaScript 的许多特性中其内部的实现都是使用到了符号内部方法。\n比如下表涉及到的内容：\n   符号方法 类型 JavaScript 特性 描述     Symbol.hasInstance boolean instanceof 7.7.1 实例(原型链)检测   Symbol.isConcatSpreadable boolean Array.prototype.concat 7.7.2 检测参数合法性   Symbol.iterator function 调用后得到迭代器 遍历对象或数组(等可迭代的对象)的时候会用到   Symbol.asyncIterator function 调用后得到异步迭代器(返回一个 Promise ) 遍历对象或数组(等可迭代的对象)的时候会用到   Symbol.match function String.prototype.match 7.7.3 正则表达式对象内部属性   Symbol.matchAll function String.prototype.matchAll 7.7.3 正则表达式对象内部属性   Symbol.replace function String.prototype.replace 7.7.3 正则表达式对象内部属性   Symbol.search function String.prototype.search 7.7.3 正则表达式对象内部属性   Symbol.split function String.prototype.split 7.7.3 正则表达式对象内部属性   Symbol.species constructor - 派生对象生成   Symbol.toPrimitive function - 7.7.4 返回一个对象的原始值   Symbol.toStringTag string Object.prototype.toString() 7.7.5 返回一个对象的字符串描述   Symbol.unscopables object with 7.7.8 不能出现在 with 语句中的一个对象     通过改变对象的上面的内部符号属性的实现，可以让我们去修改对象的一些\n默认行为，比如 instanceof 一个对象的时候可以改变它的行为让它返回一个非预期值。\n Symbol.hasInstance 每个函数都有一个内部 Symbol.hasInstance 方法用来判断给定的对象是不是这个函\n数的一个实例。\n这个函数定义在 Function.prototype 上，因此所有的函数都会继承 instanceof\n属性的默认行为，\n并且这个方法是 nonwritable, nonconfigurable, 和 nonenumerable 的，确保\n它不会被错误的重写。\n因此下面的中的两句 obj instanceof Array 和\nArray[Symbol.hasInstance](obj) 是等价的。\n1 2 3 4 5 6 7 8 9 10  const obj = {} let v1 = obj instanceof Array; // 等价于  let v2 = Array[Symbol.hasInstance](obj); console.log(v1, v2)   +RESULTS:\nfalse false  在 es6 中实际上已经对 instanceof 操作做了重定义，其内部还让它支持了函数调\n用方式，即其内部的 Symbol.hasInstance 不再限定只是 boolean 类型，它还可\n以是函数类型，因此我们可以通过重写这个方法来改变 instanceof 的默认行为。\n比如：让一个对象的 instanceof 操作总是返回 false\n1 2 3 4 5 6 7 8 9 10 11 12 13 14  function MyObj() { // ... } Object.defineProperty(MyObj, Symbol.hasInstance, { value: function(v) { console.log(\u0026#39;override method\u0026#39;) return false; } }) let obj = new MyObj(); console.log(obj instanceof MyObj); // false   +RESULTS:\noverride method false  由于 Symbol.hasInstance 属性是 nonwritable 的因此需要通过\nObject.defineProperty 去重新定义这个属性。\n#+BIGINQUOTE\n虽然 es6 赋予了这种可以重写一些 JavaScript 特性的默认行为的能力，但是依旧不\n推荐去这么做，很可能让你的代码变得很不可控，也不容易让人理解你的代码。\n#+ENDQUOTE\nSymbol.isConcatSpreadable 对应着 Array.prototype.concat 的内部使用 Symbol.isConcatSpreadable 。\nconcat 使用示例：\n1 2 3 4 5  let colors1 = [ \u0026#34;red\u0026#34;, \u0026#34;green\u0026#34; ], colors2 = colors1.concat([ \u0026#34;blue\u0026#34;, \u0026#34;black\u0026#34; ]); console.log(colors2.length); // 4 console.log(colors2); // [\u0026#34;red\u0026#34;,\u0026#34;green\u0026#34;,\u0026#34;blue\u0026#34;,\u0026#34;black\u0026#34;]   +RESULTS:\n4 [ 'red', 'green', 'blue', 'black' ]  我们一般用 concat 去扩展一个数组，把他们合并到一个新的数组中去。\n根据 Array.prototype.concat(value1, ...valueNs) 的定义，它是可以接受 n\n多个参数的，比如：\n[].concat(1, 2, 3, ...) \u0026gt; =[1, 2, 3, ...]\n并且并没有限定参数的类型，即这些 value1, ...valuesNs 可以是任意类型的值\n（数组，对象，纯值等等）。\n另外，如果参数是数组的话，它会将数组项一一展开合并到源数组中区(且只会做一级\n展开，数组中的数组不会展开)。\n比如：\n1 2 3 4 5 6 7  let colors1 = [ \u0026#34;red\u0026#34;, \u0026#34;green\u0026#34; ], colors2 = colors1.concat( [ \u0026#34;blue\u0026#34;, \u0026#34;black\u0026#34;, [ \u0026#34;white\u0026#34; ] ], \u0026#34;brown\u0026#34;, { color: \u0026#34;red\u0026#34; }); console.log(colors1 === colors2) console.log(colors2.length); // 5 console.log(colors2); // [\u0026#34;red\u0026#34;,\u0026#34;green\u0026#34;,\u0026#34;blue\u0026#34;,\u0026#34;black\u0026#34;,\u0026#34;brown\u0026#34;]   +RESULTS:\nfalse 7 [ 'red', 'green', 'blue', 'black', [ 'white' ], 'brown', { color: 'red' } ]  但是，如果我们需要的是将 { color: 'red' } 中的属性值 'red' 合并到数组末\n尾，该如何做？？\n-\u0026raquo;\u0026gt; Symbol.isConcatSpreadable 就是它\n和其他内置符号不一样，这个在所有的对象中默认是不存在的，因此如果我们需要就得\n手动去添加，让这个对象\n变成 concatable 只需要将这个属性值置为 true 即可:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26  let collection = { 0: \u0026#39;aaa\u0026#39;, \u0026#39;1\u0026#39;: \u0026#39;bbb\u0026#39;, length: 2, [Symbol.isConcatSpreadable]: true } let objNoLength = { 0: \u0026#39;xxx\u0026#39;, 1: \u0026#39;yyy\u0026#39;, [Symbol.isConcatSpreadable]: true } let objNoNumberAttrs = { a: \u0026#39;www\u0026#39;, b: \u0026#39;vvv\u0026#39;, length: 2, [Symbol.isConcatSpreadable]: true } let words = [ \u0026#39;somthing\u0026#39; ]; console.log(words.concat(collection).toString()) console.log(words.concat(objNoLength).toString()) console.log(words.concat(objNoNumberAttrs).toString())   +RESULTS:\nsomthing,aaa,bbb somthing somthing,,  分析结果得出，对象要变的可以被 Array.prototype.concat 使用，\n需要满足以下条件：\n 必须有 length 属性，否则对结果没任何影响，如结果第二行输出： somthing 必须有以数字为 key 的属性，否则数组中将使用空值代替追加的值追加到数组中\n去，如第三行输出： somthing,, 必须增加符号属性 Symbol.isConcatSpreadable 且值为 true  同理，我们可以将数组对象的 Symbol.isConcatSpreadable 符号属性置为 false\n来阻止数组的 concatable 行为。\nSymbol.match, Symbol.replace, Symbol.search, Symbol.split 和字符串，正则表达式有关的一些符号，对应着字符串和正则表达式的方法：\n match(regex) 字符串是否匹配正则 replace(regex, replacement) 字符串替换 search(regex) 字符串搜索 split(regex) 字符串切割  这些都需要用到正则表达式 regex\n在 es6 之前这些方法与正则表达式的交互过程对于开发者而已都是隐藏了其内部细节\n的，也就是说开发者无法通过自己定义的对象去表示一个正则。\n在 es6 中定义了四个符号便是用来实现 RegExp 内部实现对象，即可以通过对象的\n方式去实现一个正则表达式规则。\n这四个符号属性是在 RegExp.prototype 原型上被定义的，作为以上方法的默认实现。\n 意思就是 math, replace, search, split 这四个方法的 regex 正则\n表达式的内部实现基于对应的四个符号属性函数 Symbol.math, Symbol.replace,\nSymbol.search, Symbol.split 。\n  Symbol.match 接受一个字符串参数，如果匹配会返回一个匹配的数组，未匹配返回 null 。 Symbol.replace 接受一个字符串参数和一个用来替换的字符串，返回一个新的字符串。 Symbol.search 接受一个字符串，返回匹配到的数字所以呢，未匹配返回 -1。 Symbol.split 接受一个字符串，返回以匹配到的字符串位置分割成的一个字符串数组  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48  // 等价于 /^.${10}$/ let hasLengthOf10 = { [Symbol.match]: function(value) { return value.length === 10 ? [value] : null }, [Symbol.replace]: function(value, replacement) { return value.length === 10 ? replacement : value }, [Symbol.search]: function(value) { return value.length === 10 ? 0 : -1 }, [Symbol.split]: function(value) { return value.length === 10 ? [\u0026#34;\u0026#34;, \u0026#34;\u0026#34;] : [value] } } let msg1 = \u0026#34;Hello World\u0026#34;, // 11 chars  msg2 = \u0026#34;Hello John\u0026#34;; // 10 chars  let m1 = msg1.match(hasLengthOf10) let m2 = msg2.match(hasLengthOf10) console.log(m1) console.log(m2) let r1 = msg1.replace(hasLengthOf10, \u0026#34;Howdy!\u0026#34;) let r2 = msg2.replace(hasLengthOf10, \u0026#34;Howdy!\u0026#34;) console.log(r1) console.log(r2) let s1 = msg1.search(hasLengthOf10) let s2 = msg2.search(hasLengthOf10) console.log(s1) console.log(s2) let sp1 = msg1.split(hasLengthOf10) let sp2 = msg2.split(hasLengthOf10) console.log(sp1) console.log(sp2)   +RESULTS:\nnull [ 'Hello John' ] Hello World Howdy! -1 0 [ 'Hello World' ] [ '', '' ]  通过这几个正则对象的内部符号属性，使得我们有能力根据需要去完成更复杂的正则匹配规则。\nSymbol.toPrimitive 在 es6 之前，如果我们要使用 == 去比较两个对象的时候，其内部都会讲对象转成\n原始值之后再去比较，且此时的转换属于内部操作，我们是无法知晓更无法干涉的。\n但在 es6 出现之后，这种内部实现通过 Symbol.toPrimitvie 被暴露出来了，从而\n使得我们有能力取改变他们的默认行为。\nSymbol.toPrimitvie 是定义在所有的标准类型对象的原型之上，用来描述在对象被\n转换成原始值之前的都做了些什么行为。\n当一个对象发生原始值转换的时候， Symbol.toPrimitive 就会带上一个参数\n(hint)被调用，这个参数值为 \u0026ldquo;number\u0026rdquo;, \u0026ldquo;string\u0026rdquo;, \u0026ldquo;default\u0026rdquo; 中的一个(值是由\nJavaScript 引擎所决定的)，分别表示：\n \u0026ldquo;number\u0026rdquo; ：表示 Symbol.toPrimitive 应该返回一个数字。 \u0026ldquo;string\u0026rdquo; ：表示 Symbol.toPrimitvie 应该返回一个字符串。 \u0026ldquo;default\u0026rdquo; ： 表示原样返回。  在大部分的标准对象中， number 模式的行为按照以下的优先级来返回：\n 先调用 valueOf() 如果结果是一个原始值，返回它。 然后调用 toString() 如果结果是一个原始值，返回它。 否则，抛出异常。  同样， string 模式的行为优先级如下：\n 先调用 toString() 如果结果是一个原始值，返回它。 然后调用 valueOf() 如果结果是一个原始值，返回它。 否则，抛出异常。  在此，可以通过重写 Symbol.toPrimitive 方法，可以改变以上的默认行为。\n \u0026ldquo;default\u0026rdquo; 模式仅在使用 ==, + 操作符，以及调用 Date 构造函数的时候\n只传递一个参数的时候才会用到。大部分的操作都是采用的 \u0026ldquo;number\u0026rdquo; 或 \u0026ldquo;string\u0026rdquo; 模式。\n 实例：\n1 2 3 4 5 6 7 8 9  function Temperature(degrees) { this.degrees = degrees } let freezing = new Temperature(32) console.log(freezing + \u0026#34;!\u0026#34;) // [object Object]! console.log(freezing / 2) // NaN console.log(String(freezing)) // [object Object]   输出结果：\n因为默认情况下一个对象字符串化之后会变成 [object Object] 这是其内部的默认\n行为。\n通过重写原型上的 Symbol.toPrimitive 函数可以改写这种默认行为。\n比如：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20  function Temperature(degrees) { this.degrees = degrees } Temperature.prototype[Symbol.toPrimitive] = function(hint) { switch (hint) { case \u0026#39;string\u0026#39;: return this.degrees + \u0026#39;\\u00b0\u0026#39; case \u0026#39;number\u0026#39;: return this.degrees case \u0026#39;default\u0026#39;: return this.degrees + \u0026#34; degrees\u0026#34; } } let freezing = new Temperature(32) console.log(freezing + \u0026#34;!\u0026#34;) console.log(freezing / 2) console.log(String(freezing))   +RESULTS:\n32 degrees! 16 32°  结果就像我们之前分析的， 只有 == 和 + 执行的是 “default\u0026quot; 模式，\n其他情况执行的要么是 \u0026ldquo;number\u0026rdquo; 模式(如： freezing / 2)\n要么是 \u0026ldquo;string\u0026rdquo; 模式(如： String(freezing))\nSymbol.toStringTag 介绍 在 JavaScript 的一个有趣的问题是，能同时拥有多个全局执行上下文的能力。\n这个发生在 web 浏览器环境下，一个页面可能包含一个 iframe ，因此当前页面和\n这个 iframe 各自都拥有自己的执行环节。\n通常情况下，这并不是什么问题，因为数据可以通过一些手段让其它当前页和\niframe 之间进行传递，问题是如何去识别这个被传递的对象是源自哪个执行环境？？\n比如，一个典型的问题是在 page 和 iframe 之间互相传递一个数组。在 es6 的\n术语中， 页面和iframe 每一个都代表着一个不同的领域(realm, JavaScript 执行\n环境)。每个领域都有它自己的全局作用域包含了它自己的一份全局对象的副本。\n无论，数组在哪个领域被创建，它都很明确的是一个数组对象，当它被传递到另一个领\n域的时候，使用 instanceof Array 的结果都是 false ，因为数组是通过构造函\n数在别的领域所创建的，而\nArray 代表的仅仅是当前领域下的构造函数，即两个领域下的 Array 不是一回事。\n这就造成了在当前领域下去判断另一个领域下的一个数组变量是不是数组，得到的结\n果将是 false 。\nSymbol.toStringTag 延伸(不同 realm 下的对象识别)  对象识别的应对之策(Object.prototype.toString.call(obj))\n1 2 3 4 5  function isArray(value) { return Object.prototype.toString.call(value) === \u0026#34;[object Array]\u0026#34;; } console.log(isArray([])); // true   +RESULTS:\ntrue  这种方式虽然比较麻烦，但是却是最靠谱的方法。\n因为每个类型的 toString() 可能有自己的实现，返回的值是无法统一的，但是\nObject.prototype.toString 返回的内容始终是 [object Array] 这种，后面是被\n检测数据代表的类型的构造函数，它总是能得到正确且精确的\n结果。\nObject.prototype.toString 内部实现的伪代码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50  // toString(object)  function toString(obj) { // 1. 判断 undefined 和 null  if (this === undefined) { return \u0026#39;[object Undefined]\u0026#39;; } if (this === null) { return \u0026#39;[object Null]\u0026#39;; } let O = ToObject(this); // 上下文变量对象化  let isArray = IsArray(O); // 先判断是不是数组类型  let builtinTag = \u0026#39;\u0026#39; let has = builtinName =\u0026gt; !!O.builtinName; // 2. 根据内置属性，检测各对象的类型  if (isArray === true) { // 数组类型  builtinTag = \u0026#39;Array\u0026#39;; } else if ( has([[ParameterMap]]) ) { // 参数列表，函数参数对象  // 函数的参数 arguments 对象  builtinTag = \u0026#39;Arguments\u0026#39;; } else if ( has([[Call]]) ) { // 函数  builtinTag = \u0026#39;Function\u0026#39;; } else if ( has([[ErrorData]]) ) { // Error对象  builtinTag = \u0026#39;Error\u0026#39;; } else if ( has([[BooleanData]]) ) { // Boolean 布尔对象  builtinTag = \u0026#39;Boolean\u0026#39;; } else if ( has([[StringData]]) ) { // String 对象  builtinTag = \u0026#39;String\u0026#39;; } else if ( has([[DateValue]]) ) { // Date 对象  builtinTag = \u0026#39;Date\u0026#39;; } else if ( has([[RegExpMatcher]]) ) { // RegExp 正则对象  builtinTag = \u0026#39;RegExp\u0026#39;; } else { builtinTag = \u0026#39;Object\u0026#39; // 其他  } // 3. 最后检测 @@toStringTag - Symbol.toStringTag 的值  let tag = Get(O, @@toStringTag); if (Type(tag) !== \u0026#39;string\u0026#39;) { tag = builtinTag; } return `[object ${tag}]`; }   从伪代码中我们知道，最后的实现中使用到了 @@toStringTag 即对应这里的\nSymbol.toStringTag 属性值,\n并且这个放在最后判断，优先级最高，即如果我们重写了 Symbol.toStringTag 那么\n重写之后的返回值将最优先返回。\nSymbol.toStringTag 的 ES6 实现 正如 7.7.6 中的伪代码所示，在 es6 中对于\nObject.prototype.toString.call(obj) 的实现中加入了 @@toStringTag 内部属\n性的检测，即对应着这里的 Symbol.toStringTag ，那么我们便\n可以通过改变这个值来修改它的默认行为，从而得到我们想要的类型值。\n比如：我们有一个 Person 构造函数，我们希望在使用 toString() 的时候得到结\n果是 [object Person]\n1 2 3 4 5 6 7 8 9 10 11 12 13 14  function Person(name) { this.name = name } Person.prototype[Symbol.toStringTag] = \u0026#39;Person\u0026#39; let me = new Person(\u0026#39;xxx\u0026#39;) Person.prototype.toString = () =\u0026gt; \u0026#39;[object Test]\u0026#39; console.log(me.toString()) // [object Person] console.log(Object.prototype.toString.call(me)) // [object Person] console.log(me.toString === Object.prototype.toString) // true    +RESULTS: 未重写 Person.prototype.toString 结果\n[object Person] [object Person] true  +RESULTS: 重写 Person.prototype.toString 的结果\n[object Test] [object Person] false  我们发现就算重写了 Person.prototype.toString 也不会影响\nSymbol.toStringTag 赋值后的运行结果，如后面调用\nObject.prototype.toString.call(me) 结果依旧是 [object Person] 。\n因为我们重写了 Symbol.toStringTag 属性值，因此7.7.6实现部分：\n1 2 3 4 5 6 7 8  // 3. 最后检测 @@toStringTag - Symbol.toStringTag 的值 let tag = Get(O, @@toStringTag); // 这里的结果就成了 \u0026#39;Person\u0026#39;  if (Type(tag) !== \u0026#39;string\u0026#39;) { tag = builtinTag; } return `[object ${tag}]`   因此得到 [object Person] 返回结果。\n我们还可以通过重写 Person 自身的 toString() 的实现让其拥有自己的默认行为，\n上面的第三行\n结果表明 me.toString() 最终调用的是 Object.prototype.toString 。\nSymbol.unscopables with 语句在 JavaScript 世界中是最具争议的一项特性之一。\n原本设计的初衷是避免重复书写一样的代码，但是在实际使用过程中，却是让代码更难\n理解，很容易出错，也有性能上的影响。\n虽然，极力不推荐使用它，但是在 es6 中为了考虑向后兼容性问题，在非严格模式下\n依旧对它做了支持。\n比如：\n1 2 3 4 5 6 7 8 9 10  let values = [1, 2, 3], colors = [\u0026#34;red\u0026#34;, \u0026#34;green\u0026#34;], color = \u0026#34;black\u0026#34;; with(colors) { push(color); push(...values); } console.log(colors.toString())   +RESULTS:\nred,green,black,1,2,3  上面代码，在 with 里面调用的两次 push 等价于 colors.push 调用，\n因为 with 将本地执行上下文绑定到了 colors 上。\nvalues, color 指向的均是在 with 语句外面创建的 values 和 color 。\n但是在 ES6 中给数组增加了一个 values 方法，这个方法会返回当前数组的迭代器\n对象： Array Iterator {}\n这就意味着在 ES6 的环境中， values 指向的将是数组本身的 values() 方法而\n不是外面声明的 values = [1, 2, 3] 这个数组，将破坏整个代码的运行。\n这就是 Symbol.unscopables 存在的原因。\nSymbol.unscopables 被用在 Array.prototype 上用来指定那些属性不能在\nwith 中创建绑定：\n1 2 3 4 5 6 7 8 9 10 11  // built into ECMAScript 6 by default Array.prototype[Symbol.unscopables] = Object.assign(Object.create(null), { copyWithin: true, entries: true, fill: true, find: true, findIndex: true, keys: true, values: true });   上面是默认情况下 ES6 内置的设定，即数组中的上列属性不允许在 with 中创建绑\n定，从列表能发现这些被置为 true 的属性都是 es6 中新赠的方法，这主要是为\n了兼容以前的代码只针对新增的属性这么使用。\n#+BIGINQUOTE\n一般情况下，不需要重新定义 Symbol.unscopables ，除非代码中存在 with 语句并且\n需要做一些特殊处理的时候，但是建议尽量避免使用 with 。\n#+ENDQUOTE\n总结  Symbols 是一种新的原始值类型，用来创建一些属性，这些属性只能使用对应的符号\n或符号变量去访问。 Symbol([description]) 用来创建一个符号，推荐传入描述，便于识别。 Symbol.for(key) 首先查找注册表(GSR)，如果 key 对应的符号存在直接返回，\n如果不存在则创建新符号并加入到注册表，然后返回新创建的符号。 Symbol.keyFor(symbolValue) 通过符号变量从注册表中找到对应的符号值，没有\n返回 undefined 。 符号共享通过 Symbol.for(key) 和 Symbol.keyFor(symbolValue) 可以让符号\n达到共享的目的，因为全局注册表在所有代码运行之前就已经创建好了。 符号不允许类型转换(或隐式转换)。 Object.keys() 和 Object.getOwnPropertyNames() 不能获取到符号属性。 Object.getOwnPropertySymbols(obj) 能获取到对象的所有符号属性。 Object.defineProperty() 和 Object.defineProperties() 对符号属性也有效。 知名符号7.7，以往的内部实现是不对开发者开放的，如今有了这些知名\n符号属性，可以让开发者自信改变一些功能和接口的默认行为。  Sets 和 Maps  set 集合是一组没有重复元素的一个序列。 map key 值得集合，指向对应的值  ECMAScript 5 中的 Sets 和 Maps 在 es6 之前会有各种 sets/maps 的实现方式，但是大都或多或少有所缺陷。\n背景 比如： 使用对象属性实现\n1 2 3 4 5 6 7  let st = Object.create(null) set.foo = true if (set.foo) { // sth }   在将对象作为 set 或 map 使用的时候唯一的区别在于：\nmap 里面的 key 有存储对应的具体内容，而不像 set 仅仅用来存储 true or false,\n用来标识 key 是否存在。\n1 2 3 4 5 6 7  let map = Object.create(null) map.foo = \u0026#39;bar\u0026#39; let value = map.foo console.log(value) // \u0026#39;bar\u0026#39;   +RESULTS:\nbar  潜在问题 使用对象实现 set/map 的问题：\n 无法避免字符串 key 的唯一性问题 无法避免对象作为 key 的唯一性问题  字符串作为 key :\n1 2 3 4 5  let map = Object.create(null) map[5] = \u0026#39;foo\u0026#39; console.log(map[\u0026#34;5\u0026#34;]) // \u0026#39;foo\u0026#39;   +RESULTS:\nfoo  因为对于对象来说，使用数字下表去访问的时候，实际上是将下标数值转成字符串去访问了，\n即相当于 map[5] 等价于 map['5'] 因此，有上面的结果输出。\n但是，你偏偏想使用 5 和 \u0026lsquo;5\u0026rsquo; 去标识两个 key 的时候就无法达到目的了。\n对象作为 key :\n1 2 3 4 5 6 7  let map = Object.create(null), key1 = {}, key2 = {} map[key1] = \u0026#39;foo\u0026#39; console.log(map[key2]) // \u0026#39;foo\u0026#39;   +RESULTS:\nfoo  对象作为 key 值得时候，内部会发生类型转换，将对象转成 \u0026quot;[object Object]\u0026quot;\n因此无论用 key1 还是 key2 去访问 map ，最后的结果都是 map[\u0026quot;[object Object]\u0026quot;] 去访问了\n因此，结果都是 \u0026lsquo;foo\u0026rsquo;。\nSets 集合  创建使用 new Set() 创建实例。 添加使用 set.add() 方法。 集合区分数值的数字类型和字符串类型，不会发生类型强转。 -0 和 +0 在集合中会被当做一样处理 对象可以作为 set 的元素，且两个 {} 会被当做两个不同的元素处理  set 初始化 new Set() 创建了一个空的 set\n可以在初始化的时候传入一个数组。\n 实际上， Set 构造函数可以接受任意一个 iterable 对象作为参数。\n 1 2 3  let set = new Set([1, 2, 3, 4]) console.log(set.size) // 4   +RESULTS:\n4  添加元素 set.add() 添加的元素区分类型，不会做类型转换，即 5 和 '5' 是不一样的，重复添加也只\n会执行一次，=set= 的元素是不会重复的。\n1 2 3 4 5 6 7  let set = new Set() set.add(5) set.add(\u0026#39;5\u0026#39;) set.add(5) console.log(set.size, set)   +RESULTS:\n2 Set { 5, '5' }  对象元素：\n1 2 3 4 5 6 7 8 9  let set = new Set(), key1 = {}, key2 = {} set.add(key1) set.add(key2) set.add(key1) console.log(set.size) // 2   +RESULTS:\n2  set apis  set.has(v) 判断 set 中是否有元素 v ，返回 true/false set.add(v) 添加元素 set.size 集合大小 set.delete(v) 删除元素 set.clear() 清空集合  集合迭代(forEach) 对集合使用 forEach 和对数组使用的方法一样，它接受一个函数，抓个函数又三个\n参数：\n 第一个参数：集合的当前值 第二个参数：和第一个参数一样是当前元素的值，跟数组不一样，数组使用\nforEach 这个参数是当前索引值 第三个参数：被遍历的集合本身。  Sets 没有 Key 值。\n1 2 3 4 5 6  let set = new Set([\u0026#39;a\u0026#39;, \u0026#39;b\u0026#39;, \u0026#39;c\u0026#39;, \u0026#39;d\u0026#39;, \u0026#39;e\u0026#39;]) console.log(set[0]) // undefined, 没有下标值 set.forEach(function(idx, v, ownerSet) { console.log(idx, v, ownerSet === set, ownerSet) })   +RESULTS:\nundefined a a true Set { 'a', 'b', 'c', 'd', 'e' } b b true Set { 'a', 'b', 'c', 'd', 'e' } c c true Set { 'a', 'b', 'c', 'd', 'e' } d d true Set { 'a', 'b', 'c', 'd', 'e' } e e true Set { 'a', 'b', 'c', 'd', 'e' }  结果所示：\n 集合的 key 就是 value。 遍历的函数第三个参数 ownerSet 就是被遍历的 set 集合本身。  在使用 forEach 可以给它传递一个上下文参数，让绑定回调函数里面的 this\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21  let set = new Set([1,2]) let processor = { output(value) { console.log(\u0026#39;output from processor: \u0026#39; + value) }, process(dataSet, scope = 1) { const obj = { output(value) { console.log(\u0026#39;output from obj: \u0026#39; + value) } } dataSet.forEach(function(value) { this.output(value) }, scope === 1 ? this : obj) } } processor.process(set) // scope: processor processor.process(set, 2) // scope: obj   +RESULTS:\noutput from processor: 1 output from processor: 2 output from obj: 1 output from obj: 2   将 this 传递给回调，从而 output 来自 processor 。 将 obj 传递给回调，从而 output 来自 obj 。  结论：*我们可以通过给 forEach 传递第二个参数来改变回调函数的执行上下文。*\n使用箭头函数解决 this 指向问题：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  let set = new Set([1,2]) let processor = { output(value) { console.log(\u0026#39;output from processor: \u0026#39; + value) }, process(dataSet) { // this 总是绑定到 processor  dataSet.forEach(value =\u0026gt; this.output(value), {}) } } processor.process(set) // scope: processor    +RESULTS:\noutput from processor: 1 output from processor: 2  无论第二个参数 {} 传或不传结果都一样，箭头函数里的 this 指向不会发生改变。\n 集合不能直接使用索引访问元素，如果需要使用到索引访问元素，那最好将集合转成数组来使用。\n Set 和 Array 之间的转换  集合转数组 let set = new Set([1, 2, 3, 2]); ，且会将重复的元素去掉只余\n一个。 数组转集合，最简单的就是展开符了 let arr = [...set];  展开符(…)可以作用域任何 iterable 的对象。即任何可 iterable 的对象都可以通\n过 ... 转成数组。\n也因为有了 Set 和 ... 从而是数组的去重变得异常简单:\n1 2 3 4 5  const eleminateDuplicates = items =\u0026gt; [...new Set(items)] let nums = [1, 2, 3, 2, 4, 3, 4] console.log(eleminateDuplicates(nums).toString())   +RESULTS:\n1,2,3,4  弱集(Weak Sets) 因为它存储对象引用的方式，集合类型也可以叫做强集合类型。\n即集合中对于对象的存储是存储了该对象的引用而不是被添加到集合是的那个变量名而\n已，类似对象的属性的值为对象一样，就算改变了这个属性的值，那个对象如果有其他\n变量指向它，那他一样存在（类似 C 的指针概念，两个指针同时指向一块内存，一个\n指针的指向发生变化并不会影响另一个指针指向这块内存）。\n比如：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21  let animal = { dog: { name: \u0026#39;xxx\u0026#39;, age: 10 } } let dog1 = animal.dog console.log(dog1.name) // \u0026#39;xxx\u0026#39; // 引用发生变化 animal.dog = null // 并不影响别的变量指向 { name: \u0026#39;xxx\u0026#39;, age: 10 } 这个对象 console.log(dog1.age) // 10  // 指回去，依旧是它原来指向的那个对象 animal.dog = dog1 console.log(animal.dog.name) // \u0026#39;xxx\u0026#39; console.log(animal.dog.age) // 10    +RESULTS:\nxxx 10 xxx 10  根据引用的特性，对于集合元素也一样实用：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14  let set = new Set(); let key = {}; set.add(key) // 实际将对象的引用加到集合中  console.log(set) // 1 console.log(set.size) // 1  key = null // 改变了变量值而已，实际引用的那个对象还在 console.log(set.size) // 1  key = [...set][0] console.log(key)// {}   +RESULTS:\nSet { {} } 1 1 {} undefined  这种强引用在某些情况下很可能会出现内存泄漏，比如，在浏览器环境中\n集合中保存了一些 DOM 元素的引用，而这些元素本身可能会被其他地方的\n代码从 DOM 树中移除，同时你也不想再保有这些 DOM 元素的引用了，或者说以后\n都不会用到它了，应该被释放回收才对，但是实际上集合中仍然保有这些元素的引用\n(实际已经不存在的东西)，这种情况就叫做内存泄漏(memory leak)。\n为了解决这种情况， ECMAScript 6 中增加了一种集合类型： weak sets ,弱引用只\n会保存对象的弱引用 。\n创建 Weak Sets(WeakSet) 弱引用集合构造函数： WeakSet\n1 2 3 4 5 6 7 8 9 10 11  let set = new WeakSet(), key = {}, key1 = key set.add(key) console.log(set) key = null console.log(set.has(key)) console.log(set.has(key1)) console.log(set.has(null)) console.log(set)   +RESULTS:\nWeakSet { [items unknown] } false true false WeakSet { [items unknown] } undefined  浏览器环境输出结果：\nSet 和 WeakSet 对比 Set 中添加对象，添加的是对该对象的引用，因此保存该对象的变量值发生变化，并不\n影响该对象在集合中的事实。\nWeakSet 中添加的是该变量的原始值？？变量值一旦改变，集合中的内容将随之改变(由\nJavaScript 引擎处理)。\n TODO: Set 保存引用？WeekSet 保存原始值？？有啥区别？？\n 这里我们将对比两种集合在不同形式下的运行结果，通过对比分析来搞清楚集合中引用\n和原始值的概念。\nSet, WeakSet 添加对象的结果 1 2 3 4 5 6 7 8 9 10 11 12 13  let set = new Set() let key = { a: 1 } set.add(key) console.log(set) console.log(set.has(key)) // true  let wset = new WeakSet() let wkey = { a: 1 } wset.add(wkey) console.log(wset) console.log(wset.has(wkey))   +RESULTS:\nSet { { a: 1 } } true WeakSet { [items unknown] } true undefined  这里 WeakSet 结果不直观，下面是浏览器结果：\n从浏览器端的结果分析：\n 两者在内部属性 Entries 中都有一个我们添加的 {a : 1} 对象元素。 WeakSet 没有 size 属性， Set 有 size 属性。  改变对象 key/wkey 的值 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18  let set = new Set() let key = { a: 1 } set.add(key) console.log(set) // 改变之前 key = null console.log(set) // 改变之后 console.log(set.has(key)) // true  let wset = new WeakSet() let wkey = { a: 1 } wset.add(wkey) console.log(wset) // weak key 改变之前 wkey = null console.log(wset) // weak key 改变之后 console.log(wset.has(wkey))   +RESULTS: emacs nodejs\nSet { { a: 1 } } Set { { a: 1 } } false WeakSet { [items unknown] } WeakSet { [items unknown] } false undefined  浏览器环境输出结果：\n结果：\n  对于 Set 对象变量 key 值得改变并不会影响 Set 中 {a:1} 对象\nSet 存放的是对象 {a:1} 的引用，即在 set.add(key) 之后，实际上是有两个引用指向了\n{a:1} 对象，一个是 key 这个变量，一个是集合 set 中的某个位置上的变量(假设为: fkey)。\n根据引用的特性， key 的释放并不会影响 {a:1} 这个对象本身在内存中的存在，即不会影响 fkey\n对这个对象的影响，从而并不影响 set 的内容。\n  WeakSet 中的 {a:1} 没有了\nWeakSet 我们说它添加的是 wkey 的原始值，即使直接和 wkey 这个变量的原始值挂钩的，\n执行 wkey = null 就是讲它的原始值发生改变，最终将影响 WeakSet 。\n  针对 #2 中的 WeakSet 情况，将程序改造一下:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21  let set = new Set() let key = { a: 1 } let key1 = key set.add(key) console.log(set) // 改变之前 key = null console.log(set) // 改变之后 console.log(set.has(key)) // true  console.log(\u0026#39;-------- 楚河汉界 ---------\u0026#39;) let wset = new WeakSet() let wkey = { a: 1 } let wkey1 = wkey wset.add(wkey) console.log(wset) // weak key 改变之前 wkey = null console.log(wset) // weak key 改变之后 console.log(wset.has(wkey)) console.log(wset.has(wkey1))   +RESULTS:\nSet { { a: 1 } } Set { { a: 1 } } false -------- 楚河汉界 --------- WeakSet { [items unknown] } WeakSet { [items unknown] } false true undefined  再来看看输出结果：\n我们得到了令人意外的结果：\n 并没有显示的 wset.add(wkey1) 但是最后的 wset.has(wkey1) 的结果却是 true 。 wset 集合中的 {a:1} 依然存在。  要理解这个问题，则需要知道“强引用”和“弱引用”的区别：\n强引用和弱引用 我们都知道 JavaScript 的垃圾回收机制中有一个相关知识点就叫做引用计数，即一个\n对象如果有被其他变量\n引用那么这个对象的引用计数就 +1 如果这个变量被释放该对象的引用计数就 -1\n一旦引用计数为 0 垃圾回收机制就会将这个对象回收掉，因为没有人再使用它了。\n强引用(Set) ：相当于让该对象的引用计数 +1 ，如 Set 集合保存了对象的引用导\n致引用计数 +1 ，在拥有该对象的变量 key 的值怎么变化都不会导致引用计数为\n0 从而阻止了垃圾回收器将其回收掉。\n弱引用(WeakSet): 对对象的引用不会计入到引用计数中，即将 wkey 加入到\nWeakSet 中，并不会引起 wkey 指向的那个对象的引用计数 +1 ，因此只要释放了\nwkey 对其的引用，对象的引用计数就变成 0 了，因此此时只有 wkey 指向 {a:1}\n这个对象，改变 wkey 就会改变 WeakSet 中的内容，因为这个内容已经被回收掉了。\n/根据上面的结论，我们就知道为什么我们增加了一行 let key1 = key 之后，\n{a:1} 对象依然会在 wset 中因为此时 {a:1} 引用计数不为 0 并没有被释放\n掉。/\nMaps es6 的 Map 类型是一个有序的键值对列表， key 和 value 可以是任意类型，并且 key\n不会发生类型强转，也就是说 5 和 \u0026quot;5\u0026quot; 属于不同的两个键，和对象不一样(对象把他\n们当做一个键，因为对象的 key 最终表示形式为 string 内部有发生强制转换)。\nMap 初始化 一个 map 实例必须通过构造函数来创建 new Map() ，同时可以给构造函数传递一个\niterable 的对象，在创建的时候初始化，这个 iterable 对象会被转成 map。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44  let map = new Map([[\u0026#39;name\u0026#39;, \u0026#39;张三\u0026#39;], [\u0026#39;age\u0026#39;, 25]]) console.log(map) console.log(map.has(\u0026#39;name\u0026#39;)) // true console.log(map.get(\u0026#39;name\u0026#39;)) // 张三 console.log(map.has(\u0026#39;age\u0026#39;)) // true console.log(map.get(\u0026#39;age\u0026#39;)) // 25 console.log(map.size) // 2  try { // 一维数组，不符合 entry object  let map1 = new Map([1, 2, 3]) console.log(map1) } catch (e) { console.log(e.message) } try { // 对象非 iterable  let map2 = new Map({a: 1, b: 2, length: 2}) console.log(map2) } catch (e) { console.log(e.message) } try { let map3 = new Map(new Set([[\u0026#39;name\u0026#39;, \u0026#39;张三\u0026#39;, 1], [\u0026#39;age\u0026#39;, 25, 2]])) console.log(map3) } catch (e) { console.log(e.message) } try { let map4 = new Map(new Set([\u0026#39;name\u0026#39;, \u0026#39;张三\u0026#39;])) console.log(map4) } catch (e) { console.log(e.message) } try { let map5 = new Map(new Set([[\u0026#39;name\u0026#39;, \u0026#39;张三\u0026#39;], [\u0026#39;age\u0026#39;, 25]])) console.log(map5) } catch (e) { console.log(e.message) }   +RESULTS:\nMap { 'name' =\u0026gt; '张三', 'age' =\u0026gt; 25 } true 张三 true 25 2 Iterator value 1 is not an entry object #\u0026lt;Object\u0026gt; is not iterable Map { 'name' =\u0026gt; '张三', 'age' =\u0026gt; 25 } Iterator value name is not an entry object Map { 'name' =\u0026gt; '张三', 'age' =\u0026gt; 25 } undefined  因此能被转成 map 的对象需要满足：\n 必须是 iterable 必须有键值对类型的列表对象，比如二维数组。  Map 的 key 和 value 可以是任意对象。\n\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18  let map = new Map() map.set({}, \u0026#39;EmptyObject\u0026#39;) // 虽然都是 {} 但是对象是引用类型，是不能等同的 console.log(map.get({})) // undefined  map.clear() let emptyObj = {} map.set(emptyObj, \u0026#39;EmptyObject\u0026#39;) console.log(map) console.log(map.get(emptyObj)) // \u0026#39;EmptyObject\u0026#39; console.log(map.size) // 1  emptyObj = null console.log(map) console.log(map.get(emptyObj)) // \u0026#39;undefined\u0026#39; console.log(map.size) // 1, 因为 Map 是强引用，emptyObj = null 并不会改变   +RESULTS:\nundefined Map { {} =\u0026gt; 'EmptyObject' } EmptyObject 1 Map { {} =\u0026gt; 'EmptyObject' } undefined 1 undefined  map.set(key, value) 和 map.get(key) Map 实例可以通过 set 和 get 方法去设置键值对然后获取该值。\n1 2 3 4 5 6 7 8  let map = new Map() map.set(\u0026#39;title\u0026#39;, \u0026#39;u es6\u0026#39;) map.set(\u0026#39;year\u0026#39;, 2019) console.log(map) console.log(map.get(\u0026#39;title\u0026#39;)) console.log(map.get(\u0026#39;year\u0026#39;)) console.log(map[0])   +RESULTS:\nMap { 'title' =\u0026gt; 'u es6', 'year' =\u0026gt; 2019 } u es6 2019 undefined undefined  map 数据的内部存储格式({ 'key' =\u0026gt; value })：\n方法  map.has(key) 检测 map 中是否存在 key map.delete(key) 删除 key 对应的值 map.clear() 清空所有键值对 map.size map 的大小，键值对的个数  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28  let map = new Map() map.set(\u0026#39;name\u0026#39;, \u0026#39;张三\u0026#39;) map.set(\u0026#39;age\u0026#39;, 22) console.log(\u0026#39;-------- init ---------\u0026#39;) console.log(map) console.log(map.size) // 2 console.log(map.has(\u0026#39;name\u0026#39;)) // true console.log(map.get(\u0026#39;name\u0026#39;)) // 张三 console.log(map.has(\u0026#39;age\u0026#39;)) // true console.log(map.get(\u0026#39;age\u0026#39;)) // 22  console.log(\u0026#39;-------- delete ---------\u0026#39;) map.delete(\u0026#39;name\u0026#39;) console.log(map) console.log(map.has(\u0026#39;name\u0026#39;)) // false console.log(map.get(\u0026#39;name\u0026#39;)) // undefined console.log(map.size) // 1  console.log(\u0026#39;-------- clear ---------\u0026#39;) map.clear() console.log(map) console.log(map.has(\u0026#39;name\u0026#39;)) // false console.log(map.get(\u0026#39;name\u0026#39;)) // undefined console.log(map.has(\u0026#39;age\u0026#39;)) // false console.log(map.get(\u0026#39;age\u0026#39;)) // undefined console.log(map.size) // 0   +RESULTS:\n-------- init --------- Map { 'name' =\u0026gt; '张三', 'age' =\u0026gt; 22 } 2 true 张三 true 22 -------- delete --------- Map { 'age' =\u0026gt; 22 } false undefined 1 -------- clear --------- Map {} false undefined false undefined 0 undefined  forEach forEach 在 map 上的使用方式跟集合和数组类似，回调接受三个参数分别代表：\n value: 代表当前循环 map 中元素键值中的值 key: 代表 map 元素键值中的键 map: 当前的 map 自身  因此， map 的 forEach 看起来与数组更像，有 value, key, map ，并且 value\n代表值，key 表示键（数组中的索引），map 代表自身。\n1 2 3 4 5 6  let map = new Map([[\u0026#39;name\u0026#39;, \u0026#39;张三\u0026#39;], [\u0026#39;age\u0026#39;, 22]]) map.forEach(function(value, key, ownerMap) { console.log(`${key}: ${value}`) console.log(ownerMap === map) })   +RESULTS:\nname: 张三 true age: 22 true undefined  和 Set 一样，也可以将 this 作为第二个参数传入，绑定回调函数的上下文，或者直接\n使用箭头函数，就可以省略这个参数了。\nWeakMap WeakMap 类似 WeakSet 一样，是一种弱引用类型。\n有了8.3的说明，理解将让我们很容易理解 WeakMap 。\n**WeakMap 弱引用，即它里面的引用类型，不计入引用计数统计，不会阻止垃圾回收器回收。**  看下 8.4.1 的示例，将 Map 改成 WeakMap 看下结果：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24  let map = new WeakMap() try { map.clear() } catch (e) { console.log(e.message) } let emptyObj = {} map.set(emptyObj, \u0026#39;EmptyObject\u0026#39;) console.log(map.get(emptyObj)) // \u0026#39;EmptyObject\u0026#39; console.log(map.size) // undefined  emptyObj = null console.log(map.get(emptyObj)) // \u0026#39;undefined\u0026#39; console.log(map.size) // undefined  map.delete(emptyObj) let obj = {a: 1, b: 2} map.set(obj, \u0026#39;NormalObject\u0026#39;) console.log(map.get(obj)) map.delete(obj) console.log(map.get(obj))   +RESULTS:\nmap.clear is not a function EmptyObject undefined undefined undefined NormalObject undefined   WeakMap 中没有 map.clear() WeakMap 没有 size 属性，和 WeakSet 一样 弱引用， emptyObj = null 会使 map 中的 emptyObj 被删除  迭代器和生成器(Iterators \u0026amp; Generators) 什么是迭代器(Iterators)？ 迭代器：拥有特殊接口(用来遍历该对象)的一些对象。\n所有迭代器对象都有一个 next() 方法返回一个结果对象。\n该结果对象包含两个属性：\n value 迭代过程中下一个值 done , boolean 是否是最后一个  迭代器拥有一个内部指针指向总是指向下一个值。\n创建一个迭代器：\n 返回对象中必须有 next() 方法 必须有终结条件属性 done  \n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24  function createIterator(items) { var i = 0; return { next: function() { var done = ( i \u0026gt;= items.length); var value = !done ? items[i++] : undefined; return { done, value }; } } } var iterator = createIterator([1, 2, 3]); console.log(iterator.next()); // { value: 1, done: false } console.log(iterator.next()); // { value: 2, done: false } console.log(iterator.next()); // { value: 3, done: false } console.log(iterator.next()); // { value: undefined, done: true } console.log(iterator.next()); // { value: undefined, done: true } console.log(iterator.next()); // { value: undefined, done: true }    +RESULTS:\n{ done: false, value: 1 } { done: false, value: 2 } { done: false, value: 3 } { done: true, value: undefined } { done: true, value: undefined } { done: true, value: undefined }  什么是生成器(Generators)？ 生成器：一个返回迭代器的函数。\n生成器声明方式： function *createIterator() {} ，使用 *fnName 方式。\n它的返回值也是一个迭代器，里面使用 yield 关键词暂停语句。\n\n1 2 3 4 5 6 7 8 9 10 11 12 13 14  function *createIterator() { yield 1; yield 2; yield 3; } let iterator = createIterator(); console.log(iterator.next()) // { value: 1, done: false } console.log(iterator.next()) // { value: 2, done: false } console.log(iterator.next()) // { value: 3, done: false } console.log(iterator.next()) // { value: undefined, done: true } console.log(iterator.next()) // { value: undefined, done: true } console.log(iterator.next()) // { value: undefined, done: true }   +RESULTS:\n{ value: 1, done: false } { value: 2, done: false } { value: 3, done: false } { value: undefined, done: true } { value: undefined, done: true } { value: undefined, done: true }  跟 9.1 结果一样。\n生成器函数与普通函数区别：\n 使用星号(*) 加名字声明 返回值是一个迭代器 iterator 只有使用迭代器调用了 next() 才会返回值，该值为函数中 yield 关键词语句对应  yield 告诉引擎，我在这里要暂停下，如果要我继续下去，就请用我返回的迭代器调用下\nnext() 获取当前 yield 暂停地方的返回结果。\n循环中的 yield yield 关键词可以用于任意值或语句，比如：循环中使用 yield\n1 2 3 4 5 6 7 8 9 10 11 12 13 14  function *createIterator(items) { for (let i = 0; i \u0026lt; items.length; i++) { yield items[i]; } } const iterator = createIterator([1, 2, 3]); console.log(iterator.next()) // { value: 1, done: false } console.log(iterator.next()) // { value: 2, done: false } console.log(iterator.next()) // { value: 3, done: false } console.log(iterator.next()) // { value: undefined, done: true } console.log(iterator.next()) // { value: undefined, done: true } console.log(iterator.next()) // { value: undefined, done: true }   +RESULTS:\n{ value: 1, done: false } { value: 2, done: false } { value: 3, done: false } { value: undefined, done: true } { value: undefined, done: true } { value: undefined, done: true }  两个 yield 之间有多个语句 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  function *createIterator(items) { for (let i = 0; i \u0026lt; items.length; i++) { console.log(i, \u0026#39;i\u0026#39;); yield items[i]; } } const iterator = createIterator([1, 2, 3]); console.log(iterator.next()) // { value: 1, done: false } //console.log(iterator.next()) // { value: 2, done: false } //console.log(iterator.next()) // { value: 3, done: false } // console.log(iterator.next()) // { value: undefined, done: true } // console.log(iterator.next()) // { value: undefined, done: true } // console.log(iterator.next()) // { value: undefined, done: true }    yield 在 console.log 语句之后的结果分析：\n1 2  console.log(i, \u0026#39;i\u0026#39;); yield items[i];      next() 个数 结果     console.log(iterator.next()) * 0 :   console.log(iterator.next()) * 1 : 0 \u0026lsquo;i\u0026rsquo;    : { value: 1, done: false }   console.log(iterator.next()) * 2 : 0 \u0026lsquo;i\u0026rsquo;    : { value: 1, done: false }    : 1 \u0026lsquo;i\u0026rsquo;    : { value: 2, done: false }   console.log(iterator.next()) * 3 : 0 \u0026lsquo;i\u0026rsquo;    : { value: 1, done: false }    : 1 \u0026lsquo;i\u0026rsquo;    : { value: 2, done: false }    : 2 \u0026lsquo;i\u0026rsquo;    : { value: 3, done: false }    yield 在 console.log 语句之前的结果分析：\n1 2  yield items[i]; console.log(i, \u0026#39;i\u0026#39;);      next() 个数 结果     console.log(iterator.next()) * 1 : { value: 1, done: false }   console.log(iterator.next()) * 2 : { value: 1, done: false }    : 0 \u0026lsquo;i\u0026rsquo;    : { value: 2, done: false }   console.log(iterator.next()) * 3 : { value: 1, done: false }    : 0 \u0026lsquo;i\u0026rsquo;    : { value: 2, done: false }    : 1 \u0026lsquo;i\u0026rsquo;    : { value: 3, done: false }    从上面三种结果得出： yield 在调用 next() 之后执行的语句范围是：当前 yield\n与上一个 yield 之间的语句。\n得出上述结果的原因：执行生成器函数本身的时候，它只是返回了一个迭代器，本身的函数\n体是不会执行的，除非调用了 next() 才会去执行函数体。\n证明：\n1 2 3 4 5 6 7 8 9  function *createIterator(items) { console.log(\u0026#39;generator called...\u0026#39;) for (let i = 0; i \u0026lt; items.length; i++) { console.log(i, \u0026#39;i\u0026#39;); yield items[i]; } } const iterator = createIterator([1, 2, 3]);   +RESULTS: 结果什么都没有，第一个 console.log 并没有被执行。\nundefined  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  function *createIterator(items) { console.log(\u0026#39;generator called...\u0026#39;) for (let i = 0; i \u0026lt; items.length; i++) { console.log(i, \u0026#39;i\u0026#39;); yield items[i]; } } const iterator = createIterator([1, 2, 3]); console.log(iterator.next()) // { value: 1, done: false } console.log(iterator.next()) // { value: 2, done: false } console.log(iterator.next()) // { value: 3, done: false } console.log(iterator.next()) // { value: undefined, done: true } console.log(iterator.next()) // { value: undefined, done: true } console.log(iterator.next()) // { value: undefined, done: true }   +RESULTS:\ngenerator called... 0 'i' { value: 1, done: false } 1 'i' { value: 2, done: false } 2 'i' { value: 3, done: false } { value: undefined, done: true } { value: undefined, done: true } { value: undefined, done: true } undefined  生成器函数表达式(Generator Function Expressions) 除了可以在声明式命名函数生成迭代器函数，还可以通过表达式的方式创建生成器函数：\n 右边带名字的 var createIterator = function *createIterator() {} 右边不名字的 var createIterator = function *() {}  使用和效果和普通生成器函数 9.2一样。\n 箭头函数不能用来生成生成器函数。\n1 2 3  let createIterator = *() =\u0026gt; { yield 1; }   执行后错误结果：\n/private/var/folders/kt/b5x0yl_56h1drdb8xgfmbk_r0000gn/T/babel-IQ9JEI/js-script-4JzlJj:3 let createIterator = *() =\u0026gt; { ^\nSyntaxError: Unexpected token * at Module._compile (internal/modules/cjs/loader.js:721:23) at Object.Module._extensions..js (internal/modules/cjs/loader.js:787:10) at Module.load (internal/modules/cjs/loader.js:653:32) at tryModuleLoad (internal/modules/cjs/loader.js:593:12) at Function.Module._load (internal/modules/cjs/loader.js:585:3) at Function.Module.runMain (internal/modules/cjs/loader.js:829:12) at startup (internal/bootstrap/node.js:283:19) at bootstrapNodeJSCore (internal/bootstrap/node.js:622:3)\n 对象中的生成器方法成员 ECMAScript 5 风格：\n1 2 3 4 5 6 7 8 9 10 11  let o = { createIterator: function *(items) { for (let i = 0; i \u0026lt; items.length; i++) { yield items[i]; } } } let iterator = o.createIterator([1, 2, 3]); console.log(iterator.next()); // { value: 1, done: false }   +RESULTS:\n{ value: 1, done: false }  ECMAScript 6 方法简写风格：\n1 2 3 4 5 6 7 8 9 10 11 12  let o = { *createIterator(items) { for (let i = 0; i \u0026lt; items.length; i++) { yield items[i]; } } } let iterator = o.createIterator([1, 2, 3]); console.log(iterator.next()); // { value: 1, done: false }    +RESULTS:\n{ value: 1, done: false }  可迭代性和 for-of 一个可迭代的对象必须有一个 Symbol.iterator 属性。\n像我们在迭代集合对象(arrays, sets, maps)和字符串的时候，在内部其实是使用了到了他\n们默认的 Symbol.iterator 迭代器的。\n 所有由生成器创建的迭代器都是可以迭代的，因为生成器也有默认的 Symbol.iterator\n内部属性。\n for-of for-of 会在每次迭代的时候自动调用 next() 进入下一次迭代，并且将 value 的值\n保存到一个变量当中以供使用。\n1 2 3 4 5  let values = [1, 2, 3]; for (let num of values) { console.log(num); }   +RESULTS:\n1 2 3  如果，在迭代过程中只需要用到该被迭代对象的元素值得时候，推荐使用 for-of 因为它\n依赖和检测的条件更少。\n for-of 语句使用在 non-iterable 对象， null 或 undefined 上的时候会报错。\n 访问默认迭代器 之前我们讲过，任何一个可以迭代的对象，都必须有 Symbol.iterator 属性，无论是内\n部实现还是用户实现也好。\n这里将探讨如果使用和访问默认迭代器：\n1 2 3 4 5 6 7 8 9 10  let values = [1, 2, 3]; // 得到数组内部的迭代器 let iterator = values[Symbol.iterator]() console.log(iterator.next()); // { value: 1, done: false } console.log(iterator.next()); // { value: 2, done: false } console.log(iterator.next()); // { value: 3, done: false } console.log(iterator.next()); // { value: undefined, done: true } console.log(iterator.next()); // { value: undefined, done: true }   +RESULTS:\n{ value: 1, done: false } { value: 2, done: false } { value: 3, done: false } { value: undefined, done: true } { value: undefined, done: true }  和我们自定义方式创建的迭代器9.1结果一样。\n检测一个对象是否是可迭代的，根据每个可迭代的对象都会有一个 Symbol.iterator 属\n性(内部或自定义)，且是一个函数。\n则有：\n1 2 3 4 5 6 7 8 9 10  function isIterable(object) { return typeof object[Symbol.iterator] === \u0026#39;function\u0026#39;; } console.log(isIterable([1, 2, 3,])); // true console.log(isIterable(\u0026#39;string\u0026#39;)); // true console.log(isIterable(new Map())); // true console.log(isIterable(new Set())); // true console.log(isIterable(new WeakMap())); // false console.log(isIterable(new WeakSet())); // false   +RESULTS:\ntrue true true true false false  创建或重写迭代器 通过 Symbol.iterator 属性加上生成器函数可以很容易的让一个 non-iterable 对象变成\niterable :\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  let collection = { items: [], *[Symbol.iterator]() { for (let item of this.items) { yield item; } } } collection.items.push(...[1, 2, 3]); for (let x of collection) { // 事实上是调用了自定义实现的 `*[Symbol.iterator]() {}` 函数  console.log(x); }   +RESULTS:\n1 2 3  内置迭代器 迭代器是 ECMASCript 6 的很重要的一部分，因此你不再需要为许多内置类型去构建自己的\n的迭代器，因为从现在开始他们自己内部就已经包含了一个默认的迭代器。\n集合迭代器(for-of) 从 ECMAScript 6 开始有三种类型的集合对象： arrays, maps 和 sets。并且他们都有内\n置的迭代器帮助我们遍历操作内中的元素。\n entries() 返回一个迭代器的 key-value 键值对 values() 返回一个迭代器的所有值的集合 keys() 返回一个迭代器所有键的集合  entries() 迭代器:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21  let colors = [\u0026#39;red\u0026#39;, \u0026#39;green\u0026#39;, \u0026#39;blue\u0026#39;]; let tracking = new Set([123, 456, 789]); let data = new Map(); data.set(\u0026#39;title\u0026#39;, \u0026#39;xxx\u0026#39;); data.set(\u0026#39;format\u0026#39;, \u0026#39;yyy\u0026#39;); console.log(\u0026#39;------ array.entries() ---------\u0026#39;) for (let entry of colors.entries()) { console.log(entry) } console.log(\u0026#39;------ set.entries() ---------\u0026#39;) for (let entry of tracking.entries()) { console.log(entry) } console.log(\u0026#39;------ map.entries() ---------\u0026#39;) for (let entry of data.entries()) { console.log(entry) }   +RESULTS:\n------ array.entries() --------- [ 0, 'red' ] [ 1, 'green' ] [ 2, 'blue' ] ------ set.entries() --------- [ 123, 123 ] [ 456, 456 ] [ 789, 789 ] ------ map.entries() --------- [ 'title', 'xxx' ] [ 'format', 'yyy' ]   数组 key - key， value - value set key - value, value - value map key - key, value - value  通过 entries() 获取到的 array, set, map 迭代器：\nvalues() 迭代器:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22  let colors = [\u0026#39;red\u0026#39;, \u0026#39;green\u0026#39;, \u0026#39;blue\u0026#39;]; let tracking = new Set([123, 456, 789]); let data = new Map(); data.set(\u0026#39;title\u0026#39;, \u0026#39;xxx\u0026#39;); data.set(\u0026#39;format\u0026#39;, \u0026#39;yyy\u0026#39;); console.log(\u0026#39;------ array.values() ---------\u0026#39;) for (let value of colors.values()) { console.log(value) } console.log(\u0026#39;------ set.entries() ---------\u0026#39;) for (let value of tracking.values()) { console.log(value) } console.log(\u0026#39;------ map.entries() ---------\u0026#39;) for (let value of data.values()) { console.log(value) }   +RESULTS:\n------ array.values() --------- red green blue ------ set.entries() --------- 123 456 789 ------ map.entries() --------- xxx yyy  keys() 迭代器:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22  let colors = [\u0026#39;red\u0026#39;, \u0026#39;green\u0026#39;, \u0026#39;blue\u0026#39;]; colors.name = \u0026#39;colors\u0026#39;; let tracking = new Set([123, 456, 789]); let data = new Map(); data.set(\u0026#39;title\u0026#39;, \u0026#39;xxx\u0026#39;); data.set(\u0026#39;format\u0026#39;, \u0026#39;yyy\u0026#39;); console.log(\u0026#39;------ array.keys() ---------\u0026#39;) for (let key of colors.keys()) { console.log(key) } console.log(\u0026#39;------ set.entries() ---------\u0026#39;) for (let key of tracking.keys()) { console.log(key) } console.log(\u0026#39;------ map.entries() ---------\u0026#39;) for (let key of data.keys()) { console.log(key) }   +RESULTS:\n------ array.keys() --------- 0 1 2 ------ set.entries() --------- 123 456 789 ------ map.entries() --------- title format   如上，数组中的 name 属性并没有输出，这是因为 for-of 只会针对数组的数字索引属\n性，对于非数字的属性会忽略掉，因此如果需要遍历到非数字属性就需要用到 for-in 去\n遍历。\n for-in 是根据该对象的属性遍历的，它会将对象中的所有属性遍历出来：\n1 2 3 4 5 6 7  let colors = [\u0026#39;red\u0026#39;, \u0026#39;green\u0026#39;, \u0026#39;blue\u0026#39;]; colors.name = \u0026#39;colors\u0026#39;; for (let key in colors) { console.log(key) }   +RESULTS:\n0 1 2 name  集合类型默认迭代器 :\n上面所有使用到 for-of 加上 entries(), values(), keys(), 的情况都可以使用\n默认的迭代器来替代，其实这些迭代器方法最终取得也是集合的默认迭代器：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23  let colors = [\u0026#39;red\u0026#39;, \u0026#39;green\u0026#39;, \u0026#39;blue\u0026#39;]; colors.name = \u0026#39;colors\u0026#39;; let tracking = new Set([123, 456, 789]); let data = new Map(); data.set(\u0026#39;title\u0026#39;, \u0026#39;xxx\u0026#39;); data.set(\u0026#39;format\u0026#39;, \u0026#39;yyy\u0026#39;); console.log(\u0026#39;------ array ---------\u0026#39;) for (let value of colors) { // 相当于使用了 colors.values()  console.log(value) } console.log(\u0026#39;------ set ---------\u0026#39;) for (let value of tracking) { // 相当于使用了 tracking.values()  console.log(value) } console.log(\u0026#39;------ map ---------\u0026#39;) for (let entry of data) { // 相当于 data.entries()  console.log(entry) }   +RESULTS:\n------ array --------- red green blue ------ set --------- 123 456 789 ------ map --------- [ 'title', 'xxx' ] [ 'format', 'yyy' ]  for-of 循环的解构 在集合类型默认迭代器9.4.1中我们讲了，在对 arrays, sets,\nmaps 使用 for-in 的时候，其实都是分别使用了他们的默认迭代器(arrays.values(),\nsets.values(), maps.entries()) 。\n那针对 maps 其内部用到的是 entries() 迭代器，得到的结果是： [key, value] 类\n型，如果我们想要再循环体内使用，可以结合 ECMAScript 6 的解构功能，很方便的去使用\n他们：\n1 2 3 4 5 6 7 8 9 10  let data = new Map([ [\u0026#39;title\u0026#39;, \u0026#39;xxxx\u0026#39;], [\u0026#39;format\u0026#39;, \u0026#39;yyyy\u0026#39;] ]); for (let [key, value] of data) { console.log(`${key}= ${value}`); }   +RESULTS:\ntitle = xxxx format = yyyy  字符串迭代器 在我们字符串的使用当中经常会看到 str[0] 和数组一样通过下标方式去访问字符串中的\n字符。\n但是需要注意的一点是：字符串中括号索引方式的访问不是基于字符的而是基于编码单元的\n(即单个字节的)。\n比如：\n1 2 3 4 5  var message = \u0026#34;A ð ®· B\u0026#34;; for (let i=0; i \u0026lt; message.length; i++) { console.log(message[i]); }   ECMAScript 6 之前的输出结果：\nA (blank) (blank) (blank) (blank) B  ECMAScript 6 之后的输出结果：\n+RESULTS:\nA ð ® · B  ECMASCript 6 之后能正确输出是因为，在字符串一章3.1新增的 16 字节的编码支\n持，且字符串的默认迭代器是基于字符而不是编码字节去遍历的，所以通过 for 可以得\n到正确的结果。\n同样，ES6 的 for-of 也一样能获得正确结果：\n1 2 3 4 5  var message = \u0026#34;A ð ®· B\u0026#34;; for (let c of message) { console.log(c) }   +RESULTS:\nA ð ® · B  NodeList 迭代器(DOM元素列表迭代器) 1 2 3 4 5  var divs = document.getElementsByTagName(\u0026#34;div\u0026#34;); for (let div of divs) { console.log(div.id); }   浏览器实例：\n展开符(…)和非数组类可迭代对象 展开符将集合转成数组：\n1 2 3  let set = new Set([1, 2, 3]); let array = [...set]; console.log(array)   将 maps 转成数组：\n1 2 3 4 5 6 7  let map = new Map([ [\u0026#39;name\u0026#39;, \u0026#39;xxx\u0026#39;], [\u0026#39;age\u0026#39;, 100] ]) let array = [...map]; console.log(JSON.stringify(array))   +RESULTS:\n[[\u0026quot;name\u0026quot; (\\, \u0026quot;xxx\u0026quot;)] (\\, [\u0026quot;age\u0026quot; (\\, 100)])]  数组的合并:\n1 2 3 4 5  let nums = [1, 2, 3]; let moreNums = [0, ...nums, ...[4, 5, 6]] console.log(moreNums.toString())   +RESULTS:\n0,1,2,3,4,5,6  NodeList9.4.4一节中提到过在新的 HTML 标准中 NodeList 也有自己的默认迭代器，\n因此展开符也对 NodeList 有效。\n如图示例：(浏览器环境)\n高级迭代器功能 之前的章节讲述了使用迭代器和生成器如何去实现一些基本的功能，这一章节将讲述如何去\n使用迭代器和生成去去实现一些高级功能。\n给迭代器传递参数 之前使用迭代器，使用 iterator.next() 都是没有传递参数的，其实它是可以传递参数\n的，其实就跟普通的函数参数传递是一样的。\n结合生成器使用时候的特殊性： next(v) 中的参数 v 的值会当做当前 yield 的返\n回值返回，不管该 yield 后面表达式的结果是什么：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  function *createIterator() { let first = yield 1; // 不传值理应是： first + 2 =\u0026gt; 1 + 2 =\u0026gt; 3  // 但 next(4) 有参数，则该参数就是 yield 表达式的值，因此结果会是： 4 + 2  let second = yield first + 2; // 如上，结果是 5 + 3 = 8  yield second + 3; } let iterator = createIterator(); console.log(iterator.next()); // { value: 1, done: false } console.log(iterator.next(4)); // { value: 6, done: false } console.log(iterator.next(5)); // { value: 8, done: false } console.log(iterator.next()); // { value: undefined, done: true }   +RESULTS:\n{ value: 1, done: false } { value: 6, done: false } { value: 8, done: false } { value: undefined, done: true }  上面代码执行过程：\n迭代器中触发异常 由于给 next() 传递的参数不管是什么内容，它都会作为当前 yield 表达式的返回值\n给返回。\n迭代器对象有一个方法： iterator.throw(Error) 可以给当前的 yield 处抛出一个异\n常。\n1 2 3 4 5 6 7 8 9 10 11 12  function * createIterator() { let first = yield 1; let second = yield first + 2; yield second + 3; } let iterator = createIterator() console.log(iterator.next()) // { value: 1, done: false } console.log(iterator.next(4)) // { value: 6, done: false } console.log(iterator.throw(new Error(\u0026#39;Boom\u0026#39;))) // 异常    +RESULTS:\n: { value: 1, done: false } : { value: 6, done: false } /private/var/folders/kt/b5x0yl_56h1drdb8xgfmbk_r0000gn/T/babel-IQ9JEI/js-script-bSJrfN:4 let second = yield first + 2; ^ Error: Boom at /private/var/folders/kt/b5x0yl_56h1drdb8xgfmbk_r0000gn/T/babel-IQ9JEI/js-script-bSJrfN:12:28 at Object.\u0026lt;anonymous\u0026gt; (/private/var/folders/kt/b5x0yl_56h1drdb8xgfmbk_r0000gn/T/babel-IQ9JEI/js-script-bSJrfN:14:2)  代码中，前面两个 next() 会正常执行得到结果，但当 throw() 调用的时候，迭代器\n会在执行 let second = 之前抛出异常(yield first + 2; 已经返回结果了)。\n如图：\n捕获异常 :\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19  function * createIterator() { let first = yield 1; let second; try { second = yield first + 2; } catch (e) { console.log(e.message) second = 6; } yield second + 3; } let iterator = createIterator() console.log(iterator.next()) // { value: 1, done: false } console.log(iterator.next(4)) // { value: 6, done: false } console.log(iterator.throw(new Error(\u0026#39;Boom\u0026#39;))) // { value: 9, done: true }    +RESULTS:\n{ value: 1, done: false } { value: 6, done: false } Boom { value: 9, done: false }  从结果会惊奇的发现，调用 throw() 之后，返回了下一个 yield 的执行结果。\n原因： iterator.throw() 调用之后，生成器将这个异常捕获到了，并且继续往下执行了，\n从触发了下一个 yield 的执行。\n next() 和 throw() 都可以让生成器继续往下执行，只不过执行方式不一样，前者会从\n下一个 yield 位置执行返回结果，后者是在上一个 yield 执行之后的位置触发一个异\n常，如果这个异常被捕获就继续往下执行异常处理及后面的代码，如果没有被捕获就抛出一\n个异常中断整个生成器的执行。\n 生成器函数中使用 return 语句 在生成器中的 return 语句表示该迭代器结束了，后面不会再有值过来了。\n1 2 3 4 5 6 7 8 9 10 11  function *createIterator() { yield 1; return; // 这里结束迭代器  yield 2; // 不会执行  yield 3; // 不会执行 } let iterator = createIterator() console.log(iterator.next()) // { value: 1, done: false } console.log(iterator.next()) // { value: undefined, done: true }   +RESULTS:\n{ value: 1, done: false } { value: undefined, done: true }  因此 return 语句在生成器中的效果就是终结迭代器，在它后面的 yield 都无效，\n还可以 return 一个值：\n1 2 3 4 5 6 7 8 9 10 11 12 13  function *createIterator() { yield 1; return 42; // 这里结束迭代器  yield 2; // 不会执行  yield 3; // 不会执行 } let iterator = createIterator() console.log(iterator.next()) // { value: 1, done: false } console.log(iterator.next()) // { value: 42, done: true } console.log(iterator.next()) // { value: undefined, done: true }    +RESULTS:\n{ value: 1, done: false } { value: 42, done: true } { value: undefined, done: true }  这里有点特殊，之前迭代器结束了，最后一个 done: true 的值是 undefined 这里使\n用 return 返回了一个值会当做迭代器结束之返回。\n 在使用展开符和 for-of 时候如果有 return 语句，该语句中的 value 会被忽略掉，因\n为它一旦发现了 done: true 就会结束。\n 委托生成器(Delegating Generators) 在有些情况下，将两个迭代器的值结合成一个通常会很有用。生成器可以通过 yield 和\n* 一起使用来实现代理到其他迭代器，比如：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24  function *createNumIterator() { yield 1; yield 2; } function *createColorIterator() { yield \u0026#39;red\u0026#39;; yield \u0026#39;blue\u0026#39;; } function *createCombineIterator() { yield *createNumIterator(); yield *createColorIterator(); yield true; } var iterator = createCombineIterator(); console.log(iterator.next()) // { value: 1, done: false } console.log(iterator.next()) // { value: 2, done: false } console.log(iterator.next()) // { value: \u0026#39;red\u0026#39;, done: false } console.log(iterator.next()) // { value: \u0026#39;blue\u0026#39;, done: false } console.log(iterator.next()) // { value: true, done: false } console.log(iterator.next()) // { value: undefined, done: true }   +RESULTS:\n{ value: 1, done: false } { value: 2, done: false } { value: 'red', done: false } { value: 'blue', done: false } { value: true, done: false } { value: undefined, done: true }  结合 return 使用，比如：迭代器 B 依赖迭代器 A 的返回结果：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31  function *createNumIterator() { yield 1; yield 2; return 3; // #1 } function *createRepeatingIterator(count) { for (let i = 0; i \u0026lt; count; i++) { yield \u0026#39;repeat\u0026#39;; } } function *createCombinedIterator() { // #2  let result = yield *createNumIterator(); // #2.1  yield result; // #3  // 这里得到 createNumIterator 中 return 3 返回的结果 3  yield *createRepeatingIterator(result); } let iterator = createCombinedIterator(); console.log(iterator.next()) // { value: 1, done: false } console.log(iterator.next()) // { value: 2, done: false } console.log(iterator.next()) // { value: 3, done: false } console.log(iterator.next()) // { value: \u0026#39;repeat\u0026#39;, done: false } console.log(iterator.next()) // { value: \u0026#39;repeat\u0026#39;, done: false } console.log(iterator.next()) // { value: \u0026#39;repeat\u0026#39;, done: false } console.log(iterator.next()) // { value: undefined, done: true }   +RESULTS: 增加 #2.1 将 #2 结果输出后：\n{ value: 1, done: false } { value: 2, done: false } { value: 3, done: false } { value: 'repeat', done: false } { value: 'repeat', done: false } { value: 'repeat', done: false } { value: undefined, done: true }  +RESULTS: 有 return 3; 的返回结果\n{ value: 1, done: false } { value: 2, done: false } { value: 'repeat', done: false } { value: 'repeat', done: false } { value: 'repeat', done: false } { value: undefined, done: true }  +RESULTS: 没有 return 3; 的返回结果\n{ value: 1, done: false } { value: 2, done: false } { value: undefined, done: true } { value: undefined, done: true } { value: undefined, done: true } { value: undefined, done: true }  因为如果没有 return 3; 那么最后 #2 处的的 yield 返回结果会是\ncreateNumiterator() 执行后返回的结果 undefined\n如果有 return 3; #2 处的函数又自己的返回值，作为 #2 处 yield 代理完成的\n结果保存到了 result 中，下一次 next() 会执行 #3 处的 yield 进入下一个代\n理迭代器。\n1 2 3 4 5 6 7 8 9 10 11 12  function *createIterator() { yield * \u0026#39;hello\u0026#39;; } let it = createIterator() console.log(it.next()) // { value: \u0026#39;h\u0026#39;, done: false } console.log(it.next()) // { value: \u0026#39;e\u0026#39;, done: false } console.log(it.next()) // { value: \u0026#39;l\u0026#39;, done: false } console.log(it.next()) // { value: \u0026#39;l\u0026#39;, done: false } console.log(it.next()) // { value: \u0026#39;o\u0026#39;, done: false } console.log(it.next()) // { value: undefined, done: true }   +RESULTS: 因为字符串本身有自己的默认迭代器，因此 yield * 'hello'; 结果会去调用\n默认迭代器对每个字符进行迭代。\n{ value: 'h', done: false } { value: 'e', done: false } { value: 'l', done: false } { value: 'l', done: false } { value: 'o', done: false } { value: undefined, done: true }  异步迭代器 for-await-of2019 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17  const promise = (timeout) =\u0026gt; new Promise((resolve, reject) =\u0026gt; { setTimeout(() =\u0026gt; { resolve() }, timeout * 1000) }) function delay(time) { setTimeout(() =\u0026gt; { console.log(time) }, time * 1000) } async function test() { for await (const x of [\u0026#39;a\u0026#39;, \u0026#39;b\u0026#39;]) { console.log(x) } }   异步任务 一般我们使用生成器和迭代器最常用，也用起来最爽的估计就是异步任务了吧!!!\n比如：异步读取一个文件\n1 2 3 4 5 6 7 8 9  let fs = require(\u0026#39;fs\u0026#39;) console.log(__dirname); fs.readFile(__dirname + \u0026#39;/config.json\u0026#39;, (err, cnt) =\u0026gt; { if (err) throw err; console.log(cnt); console.log(\u0026#39;Done\u0026#39;); })   +RESULTS: 通过异步接口取文件内容\n/private/var/folders/kt/b5x0yl_56h1drdb8xgfmbk_r0000gn/T/babel-IQ9JEI \u0026lt;Buffer 7b 20 22 6e 61 6d 65 22 3a 20 22 78 78 78 22 20 7d 0a\u0026gt; Done  接下来我们将讲述如何使用 generator 来实现异步任务。\n一个简单的任务执行器 这个任务执行器的作用就是：\n 启动迭代器 循环调用 next() 知道结束  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44  function run(taskDef) { // 创建迭代器，首先确保 taskDef 是一个 generator 函数  let task = taskDef(); // 启动迭代器  let result = task.next(); const step = () =\u0026gt; { if (!result.done) { // #1  // result = task.next();  // #2 将上一个 yield 的结果作为下一个 yield 的返回值  result = task.next(result.value); step() } } // 启动循环递归，知道迭代器结束  step(); } // 使用  function *log() { console.log(\u0026#39;------- log --------\u0026#39;) console.log(1); yield; console.log(2); yield; console.log(3); } function *logVal() { console.log(\u0026#39;------- logVal --------\u0026#39;) let val = yield 1; console.log(val); // 1  val = yield val + 3; console.log(val) // 3 } run(log) run(logVal)   +RESULTS: #2 执行结果\n------- log -------- 1 2 3 ------- logVal -------- 1 4 undefined  +RESULTS: #1 的执行结果\n------- log -------- 1 2 3  通过 #2 的改造，让每次 yield 的表达式值依赖上一次 next() 的结果值。\n异步任务执行器 我们可以将上一届9.8.1中的 run 进行改造让其支持异步任务:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45  function run(taskDef) { let task = taskDef() let result = task.next() function step() { if (!result.done) { if (typeof result.value === \u0026#39;function\u0026#39;) { // 如果 yield 返回的是一个函数，就执行这个函数(异步任务)  // 结束之后，进行下一次 next() -\u0026gt; yield  result.value(function(err, data) { if (err) { result = task.throw(err) return; } result = task.next(data) step(); }) } else { result = task.next(result.value); step(); } } } step(); } let fs = require(\u0026#39;fs\u0026#39;) function readFile(filename) { return function(callback) { setTimeout(() =\u0026gt; { fs.readFile(__dirname + filename, callback) }, 1000) } } run(function *() { let result = yield readFile(\u0026#39;/config.json\u0026#39;) console.log(result) console.log(\u0026#39;Done\u0026#39;) })   +RESULTS:\n\u0026lt;Buffer 7b 20 22 6e 61 6d 65 22 3a 20 22 78 78 78 22 20 7d 0a\u0026gt; Done  Generator 内部抽象操作(伪码) 小结  Symbol.iterator 用来定义对象的默认迭代器 for-of 可以用来遍历可迭代的对象，即包含 Symbol.iterator 函数的对象  entries() 迭代器，取 [key, value] 键值对，如 for-of-map 默认就是用的\n这个迭代器 values() 迭代器，取 value 值，如果是数组 for-of-array 只会去索引为数\n值的元素，忽略非数值索引的元素，比如： arr.name = 'xxx' 这个 name 是不\n会被遍历到的(默认用 values() 迭代器的有： arrays 和 sets)。   ... 展开符其实内部实现也是去调用了对象内部的 Symbol.iterator 。 Generator 调用会生成一个迭代器，通过 it.next() 触发 yield 语句执行并得到\n结果  多个 generator 的嵌套调用可实现互相之间的代理(内部使用 yield *generatorFn() 调用生成器函数) generator 内部使用 return 42; 终止迭代并返回 { value: 42, done: true}\n，返回值由 return 返回值决定，但该值不会被 for-of 遍历到，因为 for-of\n检测到 done: true 了就即刻结束。 可以通过 return 特性灵活运用 generator 代理。 由于字符串本身是有迭代器的，因此可以直接： yield * 'hello'; 使用。 generator + iterator 实现同步任务 runner 。 generator + iterator + callback 实现异步任务 runner。    类(Classes) 类声明 基本类声明 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18  class PersonClass { constructor(name) { this.name = name } sayName() { console.log(this.name) } } let person = new PersonClass(\u0026#39;xxx\u0026#39;); person.sayName(); // xxx  console.log(person instanceof PersonClass) // true console.log(person instanceof Object) // true  console.log(typeof PersonClass); // function console.log(typeof PersonClass.prototype.sayName); // function   实际上 class 声明只是个语法糖而已，它最终产生的 PersonClass 依旧是个函数，且这\n个函数行为和 constructor 一致，这就是为什么上面 typeof PersonClass 输出结果\n是 \u0026lsquo;function\u0026rsquo; 。\n经过 babel 转换之后的代码：\n\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43  function _defineProperties(target, props) { for (var i = 0; i \u0026lt; props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\u0026#34;value\u0026#34; in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; } function () { function PersonClass(name) { _classCallCheck(this, PersonClass); this.name = name; } _createClass(PersonClass, [{ key: \u0026#34;sayName\u0026#34;, value: function sayName() { console.log(this.name); } }]); return PersonClass; }(); var person = new PersonClass(\u0026#39;xxx\u0026#39;); person.sayName(); // xxx  console.log(_instanceof(person, PersonClass)); // true console.log(_instanceof(person, Object)); // true console.log(_typeof(PersonClass)); // function console.log(_typeof(PersonClass.prototype.sayName)); // function   需要关注的点：\n  constructor 中的 this.name 依旧是在 PersonClass 这适用于函数的 new 特性\n最终 name 会被绑定到 new PersonClass() 之后的实例上。\n  sayName() 类中的方法都会被绑定到 PersonClass() 的原型上。\n如： _createClass 里面的 protoProps 。\n  静态属性会被绑定到函数名(即类名，构造函数上)\n如： _createClass 里面的 staticProps 。\n  最后将函数 PersonClass 返回。\n  类语法的好处 类和其他类型之间，有很多重要的区别：\n  类声明不会被提升(hoisted)，和 let 声明性质一样，也存在 TDZ 问题。\n  所有在类声明里面的代码默认启用 strict mode ，并且无法改变。\n  所有的方法都是不可枚举的， babel 转换之后 enumerable 默认值就是 false\n如上一节 babel 转换之后的代码 10.1.1 。\n  所有的方法都没有 [ [Constructor]] 内部属性，因此不能 new ，否则会抛出异常。\n  不能直接调用类的构造函数。\n  在类方法里面试图重写类名将抛出异常。\n  根据上面 6 个重要差异，我们就可以手动去模拟一个类了：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43  // 1. let 声明，不存在提升，TDZ let PersonType = (function() { // 2. 必须是严格模式  \u0026#39;use strict\u0026#39;; // 6. 因为是用 const 声明的类名，因此在类内部不能对类名重新赋值  const PersonType = function(name) { // 5. 不能直接调用，必须使用 new  // 这里用到了一个新的属性， new.target ，只能在非箭头函数  // 内部使用，表示：  // 如果是通过 new 调用的 new.target 就是 PersonType 自身  // 如果不是通过 new 调用的 new.target 就是 undefined  // 这也就很好的区分了一个函数是通过什么方式调用的  if (typeof new.target === \u0026#39;undefined\u0026#39;) { throw new Error(\u0026#39;类名必须通过 new 调用。\u0026#39;) } // 类实例属性  this.name = name } // 所有方法都挂在原型上  Object.defineProperty(PersonType.prototype, \u0026#39;sayName\u0026#39;, { value: function() { // 4. 前面说过了 new.target 作用  if (typeof new.target !== \u0026#39;undefined\u0026#39;) { // 能进这里，表示用 new 调用了  throw new Error(\u0026#39;类方法不能通过 new 调用\u0026#39;); } console.log(this.name) }, // 3. 所有方法都不能枚举  enumerable: false, writable: true, configurable: true }) return PersonType; }())   如上例，类内部是不能对 PersonType 重新复制的，因为它是用 const 方式声明的，\n但是在外部是可以重写的，因为外部是用的 let 声明的。\n因此：\n1 2 3 4 5 6 7  class Foo { constructor() { Foo = \u0026#39;bar\u0026#39;; // 错误，非法  } } Foo = \u0026#39;bar\u0026#39;; // OK   类表达式 类也可以使用表达式的方式声明。\n1 2 3 4 5 6 7 8 9 10 11  let PersonClass = class { // 等价于 PersonType 的构造函数  constructro(name) { this.name = name } // 等价于 PersonType.prototype.sayName  sayName() { console.log(this.name) } }   命名式表达式：跟命名式函数表达式是一样的， class 后面可以跟一个类名：\nlet PersonClass = class PersonClass2 {...}\n但是 class 后面的类名，只能在类的内部使用，在外部是访问不到的，比如：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  let PersonClass = class PersonClass2 { // 等价于 PersonType 的构造函数  constructor(name) { this.name = name console.log(typeof PersonClass2); // \u0026#39;function\u0026#39;  } // 等价于 PersonType.prototype.sayName  sayName() { console.log(this.name) } } new PersonClass(\u0026#39;xxx\u0026#39;).sayName(); console.log(typeof PersonClass2); // \u0026#39;undefined\u0026#39;   +RESULTS:\nfunction xxx undefined  PersonClass2 将作为类内部的函数名称。\n1 2 3 4 5 6 7 8 9  let PersonClass = (function() { const PersonClass2 = function(name) { ... } Object.defineProperty(PersonClass2, ...) return PersonClass2; }())   类作为一等公民 当一个对象可以被当做值，意味着可以：\n 当做参数传递给函数 从一个函数返回 赋值给一个变量  比如函数就是 JavaScript 中的一等公民。\n作为参数 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20  function createObject(classDef) { return new classDef() } let obj1 = createObject(class { sayHi() { console.log(\u0026#39;Hi!\u0026#39;) } }) let obj2 = createObject(class PersonClass { sayHi() { console.log(\u0026#39;Hi!\u0026#39;) } }) obj1.sayHi(); // \u0026#39;Hi!\u0026#39; obj2.sayHi(); // \u0026#39;Hi!\u0026#39;    +RESULTS:\nHi! Hi!  匿名类和命名类作为参数传递。\n立即执行实现单例 1 2 3 4 5 6 7 8 9 10 11  let person = new class { constructor(name) { this.name = name } sayName() { console.log(this.name) } }(\u0026#39;xxx\u0026#39;) person.sayName(); // \u0026#39;xxx\u0026#39;   +RESULTS:\nxxx   匿名类 立即执行 person 为一个单例，声明时就已经决定了是一个类(匿名类，只会在这里使用一次)实例。  访问器属性 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20  class CustomHTMLElement { constructor(element) { this.element = element } get html() { return this.element.innerHTML } set html(value) { this.element.innerHTML = value } } var descriptor = Object.getOwnPropertyDescriptor(CustomHTMLElement.prototype, \u0026#39;html\u0026#39;) console.log(descriptor) console.log(\u0026#39;get\u0026#39; in descriptor); // true console.log(\u0026#39;set\u0026#39; in descriptor); // true console.log(descriptor.enumerable); // false   +RESULTS:\n{ get: [Function: get html], set: [Function: set html], enumerable: false, configurable: true } true true false  注意要从 CustomHTMLElement.prototype 原型上去取 html ，因为类的方法都会被挂\n到原型上。\n计算成员名称 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  let methodName = \u0026#39;sayName\u0026#39; class PersonClass { constructor(name) { this.name = name } [methodName]() { console.log(this.name) } } let me = new PersonClass(\u0026#39;xx\u0026#39;) me.sayName(); // \u0026#39;xx\u0026#39;   +RESULTS:\nxx  计算成员名称，可以让类或对象的成员名动态生成，这赋予了类和对象更加灵活的使用方式。\n且访问器属性名称也可以使用变量。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  let propertyName = \u0026#39;html\u0026#39; class CustomHTMLElement { constructor(element) { this.element = element } get [propertyName]() { return this.element.innerHTML } set [propertyName](value) { this.element.innerHTML = value } }   生成器方法(Generator Methods) 类内部方法还可以是生成器方法。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  class MyClass { *createIterator() { yield 1 yield 2 yield 3 } } const ins = new MyClass() const it = ins.createIterator() console.log(it.next()); // { value: 1, done: false } console.log(it.next()); // { value: 2, done: false } console.log(it.next()); // { value: 3, done: false } console.log(it.next()); // { value: undefined, done: true }   +RESULTS:\n{ value: 1, done: false } { value: 2, done: false } { value: 3, done: false } { value: undefined, done: true }  迭代器和生成器9描述过，一个实现了 Symbol.iterator 或内置它\n的一个对象都可以被迭代，也就可以使用 for...of 去遍历它，最终调用的都会是\nSymbol.iterator 这个内部或自定义的函数。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17  class Collection { constructor() { this.items = [] } *[Symbol.iterator]() { yield *this.items.values() } } var c = new Collection() c.items.push(...[1, 2, 3]) for (let x of c) { console.log(x) }   +RESULTS:\n1 2 3  回顾代理生成器和集合内置迭代器的内容，我们分析这一句：\nyield *this.items.values()\n 首先 values() 为集合内置的值得迭代器 yield *iterator() 这种方式为生成器代理，即一个生成器中调用另一个生成器  也就是说当我们 for (let x of c) {} 的时候，首先是调用了 Collection 类内部实\n现的 *[Symbol.iterator]() 迭代器，然后在迭代器内部由调用了类成员的 items 数\n组的内置迭代器，也就是说这一句最终其实就是去遍历 items 数组，输出每个元素值。\n静态成员 静态成员，即只属于构造函数的属性，只能通过类名去访问的成员。\n\u0026lt; ECMAScript 6 之前的做法：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14  function Person(name) { this.name = name } Person.create = function(name) { return new Person(name); } Person.prototype.sayName = function() { console.log(this.name) } var person = Person.create(\u0026#39;xxx\u0026#39;) person.sayName(); // \u0026#39;xxx\u0026#39;   +RESULTS:\nxxx  直接在函数名称上挂一个属性，因为函数也是一个对象，也可以有自己的属性，和对象一样\n可以通过 obj[attrName] 访问或新增属性。\n = ECMAScript 6 开始可以使用类静态成员方式：\n 通过 static 关键词声明一个方法，这个方法将成为类的静态属性，只能通过类名访问。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  class Person { constructor(name) { this.name = name } sayName() { console.log(this.name) } static create(name) { return new Person(name); } } let p = Person.create(\u0026#39;xx\u0026#39;); p.sayName(); // \u0026#39;xx\u0026#39;   +RESULTS:\nxx  类继承 \u0026lt; ECMAScript 6 之前的类继承 一般都是使用原型的方式去实现继承\n构造函数-实例-函数三者之间的关系简图：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35  function Rectangle(l, w) { this.len = l this.width = w } Rectangle.prototype.getArea = function() { return this.len * this.width } function Square(l) { // 调用父类的构造函数，将实例属性拷贝一份到子类中  Rectangle.call(this, l, l) } // #1 Square.prototype = /* Object.create(Rectangle.prototype, { constructor: { value: Square, enumerable: false, writable: true, configurable: true } }) */ Object.create(Rectangle.prototype) // Rectangle.prototype  var s = new Square(3) console.log(s.getArea()); // 9 console.log(s instanceof Square); // true console.log(s.constructor === Square.prototype.constructor); // true console.log(Square === Square.prototype.constructor); // true console.log(Square.prototype.constructor); // true console.log(s instanceof Rectangle); // true   +RESULTS: #1 被注释，意味着没有重新定义构造函数的输出\n9 true true false [Function: Rectangle] true  这里 Square 的构造函数不再是自身了，因为它的原型被重写了，而构造函数对象又是挂\n在原型对象上的 Square.prototype.constructor 因此使用原型继承的时候尤其要记得重\n新定义构造函数，才能得到下面的正确继承效果：\n+RESULTS: #1 没有注释，有重新定义构造函数的输出结果\n9 true true true [Function: Square] true  上面代码对于初学者来说不太容易明白的一般有两点：\n  Rectangle.call(this, l, l) 这一步，这里是拷贝一份是实例属性到子类上\n这里相当于让 Square 也有了自己的 len 和 width 实例属性。\n  Square.prototype 原型赋值的一步构造函数被覆盖了，需要重新定义构造函数\n  注意点： 重写 Square 的原型，且需要重新定义构造函数，因为构造函数是在原型之上的，\n如果将原型覆盖了，那么 Square 将没有自己的构造函数了，将没法创建实例，因此在使用\nObject.create() (Object.create伪码实现)的时候需要把构造函数属性给加上去。\n\u0026gt;= ECMAScript 6 之后的 class 类继承 在有了 class 语法糖之后，让 JavaScript 中的继承变得简单易懂。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22  class Rectangle { constructor(l, w) { this.len = l this.width = w } getArea() { return this.len * this.width } } class Square extends Rectangle { constructor(l) { super(l, l) } } var s = new Square(3) console.log(s.getArea()); // 9 console.log(s instanceof Square); // true console.log(s instanceof Rectangle); // true   +RESULTS:\n9 true true  将上面的代码 babel 转换，删除一些不关心的代码之后：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66  \u0026#34;use strict\u0026#34;; // ... 省略  function _inherits(subClass, superClass) { if (typeof superClass !== \u0026#34;function\u0026#34; \u0026amp;\u0026amp; superClass !== null) { throw new TypeError(\u0026#34;Super expression must either be null or a function\u0026#34;); } subClass.prototype = Object.create( superClass \u0026amp;\u0026amp; superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); } // ... 省略  var Rectangle = /*#__PURE__*/ function () { function Rectangle(l, w) { _classCallCheck(this, Rectangle); this.len = l; this.width = w; } _createClass(Rectangle, [{ key: \u0026#34;getArea\u0026#34;, value: function getArea() { return this.len * this.width; } }]); return Rectangle; }(); var Square = /*#__PURE__*/ function (_Rectangle) { _inherits(Square, _Rectangle); function Square(l) { _classCallCheck(this, Square); return _possibleConstructorReturn(this, _getPrototypeOf(Square).call(this, l, l)); } return Square; }(Rectangle); var s = new Square(3); console.log(s.getArea()); // 9  console.log(_instanceof(s, Square)); // true  console.log(_instanceof(s, Rectangle)); // true   我们重点关注的应该是 _inherits 这个函数，其实它里面实现的就和我们 ECMAScript6\n之前的版本10.8.1一样。\n类 super() 使用注意点 在使用 es6 的类的 super() 需要注意几点：\n 只能在子类的方法中使用 super() ，如果试图在一个非继承的类(不是用 extends\n实现的继承的子类)中使用都会报错。 必须在构造函数中调用 this 之前调用 super() 因为 super() 会对 this 做\n一些初始化工作，比如拷贝实例属性等等。 唯一一个避免调用 super() 的途径就是在构造函数中返回一个对象。  第一点: 不能非继承调用 super()\n1 2 3 4 5 6 7 8  class Person { constructor(name) { super(name) this.name = name } } const p = new Person(\u0026#39;xxx\u0026#39;)   +RESULTS: 报错结果，表明不能在非继承的子类中直接调用 super ，因为它被定义指向\n的是 extends 的父类那个对象。\n/private/var/folders/kt/b5x0yl_56h1drdb8xgfmbk_r0000gn/T/babel-la0Zuf/js-script-UZ7NKG:4 super(name) ^^^^^ SyntaxError: 'super' keyword unexpected here at Module._compile (internal/modules/cjs/loader.js:721:23) at Object.Module._extensions..js (internal/modules/cjs/loader.js:787:10)  第二点: 必须在使用 this 之前调用 super() 初始化 this\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18  class Person { constructor(name) { this.name = name } } class Man extends Person { constructor(name) { console.log(this.name) super(name); } sayName() { console.log(this.name) } } const m = new Man(\u0026#39;xxx\u0026#39;); // undefined   +RESULTS: 直接报错，不能在使用 this 之后调用 super() ,必须在之前调用\n/private/var/folders/kt/b5x0yl_56h1drdb8xgfmbk_r0000gn/T/babel-la0Zuf/js-script-c51Wqa:10 console.log(this.name) ^ ReferenceError: Must call super constructor in derived class before accessing 'this' or returning from derived constructor at new Man (/private/var/folders/kt/b5x0yl_56h1drdb8xgfmbk_r0000gn/T/babel-la0Zuf/js-script-c51Wqa:10:17) at /private/var/folders/kt/b5x0yl_56h1drdb8xgfmbk_r0000gn/T/babel-la0Zuf/js-script-c51Wqa:19:11  重写父类方法(Shadowing Class Methods) 重写父类方法，通过实例调用该方法时候，会先从当前类中查找，如果没找到就会去父类中\n找。\n因此，如果想子类拥有某种自己的行为，可以通过重写方法来实现。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  class Human { run() { console.log(\u0026#39;human running.\u0026#39;) } } class Person extends Human { run() { console.log(\u0026#39;person running.\u0026#39;) } } const p = new Person() p.run(); // \u0026#39;human running.\u0026#39;   +RESULTS: 重写之后\nperson running.  +RESULTS: 重写之前\nhuman running.  Babel 编译之后的代码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41  var Human = /*#__PURE__*/ function () { function Human() { _classCallCheck(this, Human); } _createClass(Human, [{ key: \u0026#34;run\u0026#34;, value: function run() { console.log(\u0026#39;human running.\u0026#39;); } }]); return Human; }(); var Person = /*#__PURE__*/ function (_Human) { _inherits(Person, _Human); function Person() { _classCallCheck(this, Person); return _possibleConstructorReturn(this, _getPrototypeOf(Person).apply(this, arguments)); } _createClass(Person, [{ key: \u0026#34;run\u0026#34;, value: function run() { console.log(\u0026#39;person running.\u0026#39;); } }]); return Person; }(Human); var p = new Person(); p.run(); // \u0026#39;human running.\u0026#39;   _inherits 让 Person.prototype 指向了 Human.prototype,\n两个 _createClass ，前一个让 run 挂到了 Human 的原型上，后一个又在 Person 的\n原型上重新挂了一个同名的 run 方法，但由于继承 _inherits 的原型\nPerson.prototype 实际上是指向 Human.prototype 的，因此两个 _createClass 实际上\n是覆盖了前一个 _createClass 的 run 方法。\n继承静态成员 静态成员在 extends 继承过程中，也会被继承到子类当中，但是也只能通过构造函数访\n问。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26  class Rectangle { constructor(l, w) { this.len = l this.width = w } getArea() { return this.len * this.width } static create(l, w) { return new Rectangle(l, w) } } class Square extends Rectangle { constructor(l) { super(l, l) } } var rect = Square.create(3, 4) console.log(rect instanceof Rectangle); // true console.log(rect.getArea()); // true console.log(rect instanceof Square); // false   +RESULTS:\ntrue 12 false  动态父类 即 extends 后面的可以是任意类型，只要满足两个条件：\n 有 [ [Constructor]] 可以构建实例(使用 new) 有自己的原型  普通构造函数：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19  function Rectangle(l, w) { this.len = l this.width = w } Rectangle.prototype.getArea = function() { return this.len * this.width } class Square extends Rectangle { constructor(l) { super(l, l) } } var x = new Square(3) console.log(x.getArea()); // 9 console.log(x instanceof Rectangle); // true   +RESULTS:\n9 true  函数调用方式：只要返回值满足有构造器和原型\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24  function Rectangle(l, w) { this.len = l this.width = w } Rectangle.prototype.getArea = function() { return this.len * this.width } function getBase() { return Rectangle } class Square extends getBase() { constructor(l) { super(l, l) } } var x = new Square(3) console.log(x.getArea()); // 9 console.log(x instanceof Rectangle); // true    +RESULTS:\n9 true  根据父类可以动态决定的特性，我们可以实现一些比较有用的东西，比如：混合器类型\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29  let SerializableMixin = { serialize() { return JSON.stringify(this) } } let AreaMixin = { getArea() { return this.length * this.width } } function mixin(...mixins) { let base = function() {} Object.assign(base.prototype, ...mixins) return base } class Square extends mixin(SerializableMixin, AreaMixin) { constructor(l) { super() this.length = l this.width = l } } const x = new Square(3) console.log(x.getArea()) console.log(x.serialize())   +RESULTS:\n9 {\u0026quot;length\u0026quot;:3,\u0026quot;width\u0026quot;:3}  让 Square 同时具备多个混合器的能力，使用多个混合器构建一个函数类。\n 记住：只要满足有原型和构造函数都可以放在 extends 右边作为被继承的父类。\n除下面两钟类型不能之外：\n null 生成器函数  因为他们没有 [[Constructor] ] 属性。\n 继承内置对象 可以通过原型继承的方式来基于内置对象定义一个新的对象，该对象将有用内置对象的相同\n的功能。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20  function MyArray() { // 调用 Array 的构造函数，初始化 this  Array.apply(this, arguments) } MyArray.prototype = Object.create(Array.prototype, { constructor: { value: MyArray, writable: true, configurable: true, enumerable: true } }) var colors = new MyArray() colors[0] = \u0026#39;red\u0026#39; console.log(colors.length) colors.length = 0 console.log(colors[0])   +RESULTS:\n0 red  结果并非如我们所预期。 length 属性和数值属性并没有像内置数组类型一样发生变化，\n这是因为这个功能无法通过 Array.apply() 或赋值原型类实现。\n在 ECMAScript5 的类继承中， this 的值会在调用 Array.apply 之前会被新的类型\n(比如： MyArray)创建好了，然后基础类型的构造函数才会被调用，这就意味着 this\n只是绑定到了 MyArray 的本 身的实例上而已，此时并不具备数组的一些基础特性，而后\n的基础类型构造函数的调用只不过是对新类型做了一点扩展而已。\n而在 ECMAScript6 的基于类的继承当中， this 会优先被 Array 内置类型的构造函数\n调用，然后才是被新类型 MyArray 的构造函数修改，修饰新类型的一些内容。结果就是\nthis 将拥有基础类型的内置功能。\n1 2 3 4 5 6 7 8 9 10  class MyArray extends Array { // empty } var colors = new MyArray(); colors[0] = \u0026#34;red\u0026#34;; console.log(colors.length); // 1  colors.length = 0; console.log(colors[0]); // undefined   +RESULTS:\n1 undefined  也就是说要继承基础类型，必须“先使用基础类型构造函数去创建 this ，然后对新类型\n做进一步扩充”，否则，如果相反的话， this 由新类型创建，那只会拥有新类型的一些\n基本特征，后面才调用基础类型的话只是做了一个粉饰而已。\nSymbol.species 符号属性 1 2 3 4 5 6 7 8 9  class MyArray extends Array { } let items = new MyArray(1, 2, 3, 4), subItems = items.slice(1, 3) console.log(items instanceof MyArray); // true console.log(subItems instanceof MyArray); // true   +RESULTS:\ntrue true  通过 class-extends 的继承，不仅能让新类型实现原生类型的能力，而且也会改变一些默\n认行为，比如上面的 subItems instanceof MyArray 的结果会是 true ，这是因为\nSymbol.species 在继承过程中影响了它的默认行为。\nSymbol.species 符号属性用来定义一个静态的访问器属性，返回一个函数。该函数被当做一个\n构造函数使用，每当一个类的实例必须在一个实例方法中被创建的时候(而不是使用构造函\n数)。\n以下内置类型定义了 Symbol.species :\n Array ArrayBuffer Map Promise RegExp Set Typed Arrays  上面每个类型都有一个默认的 Symbol.species 属性，返回 this ，也就是说它总是会\n返回构造函数。\n1 2 3 4 5 6 7 8  class Person { getSpecies() { const descriptor = Object.getOwnPropertyDescriptor(Person, Symbol.species) console.log(descriptor, \u0026#39;11\u0026#39;) } } console.log(new Person().getSpecies())   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17  class MyClass { // 上面内置类型的 Symbol.species 默认实现，类似这里的实现  static get [Symbol.species]() { console.log(\u0026#39;get spcies\u0026#39;) return this } constructor(value) { this.value = value } clone() { // this.constructor[Symbol.species] 会返回 MyClass 构造函数  // 因此这里也相当于是 new MyClass(this.value)  return new this.constructor[Symbol.species](this.value) } }   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33  class A { static get [Symbol.species]() { return this; } constructor(value) { this.value = value; } clone() { return new this.constructor[Symbol.species](this.value); } } class B extends A { // empty } class C extends A { static get [Symbol.species]() { return A; } } let b = new B(\u0026#34;foo\u0026#34;), a1 = instance1.clone(), c = new C(\u0026#34;bar\u0026#34;), a2 = instance2.clone(); console.log(b instanceof A); // #1: true console.log(a1 instanceof B); // #2: true console.log(c instanceof A); // #3: true console.log(a2 instanceof C); // #4: false   +RESULTS:\ntrue true true false  #1: true 因为 A 是 B 的父类，在 B 实例的原型链之上，因此这里结果为 true。\n#2: true 因为 B 继承 A ，且 B 的实例 b 中并没有重写 Symbol.species 因此他会\n返回默认的 Symbol.species 实现也就是该类自身的构造函数。\n#3: true 因为 C 继承 A，同 #1 。\n#4: false 这里结果意味着 C 并不在实例 a2 的原型链上，这是因为 C 中重写了\nSymbol.species 改变了继承的默认行为。\nnew.target 属性 在类中 new.target 永远不会是 undefined 因为类名不能直接被调用。\n利用 new.target 的特性：如果是通过 new 调用它的值就是当前类的构造函数\n我们可以将一个类变成的抽象化，让它不能被用来创建实例，只能被其他类继承：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  class Shape { constructor() { if (new.target === Shape) { throw new Error(\u0026#39;不能被实例化。\u0026#39;) } } } class Rect extends Shape { // ... } var x = new Shape(); // 报错，不能被实例化  var y = new Rect(); // ok   小结   类声明，支持普通方式，表达式方式，不提升，性质和 let 一样，存在 TDZ。\n  类可以直接作为表达式的一部分，也可以跟函数一样立即执行，还可以直接当做参数传\n递，可用来实现单例。\n  类成员的名称和普通对象一样使用计算属性，动态决定其属性名称。\n  类方法可以是生成器方法，返回迭代器。\n  类的静态方法(通过 static 修饰的方法)会被子类继承到构造函数上。\n  super() 只能在继承式的子类构造函数中调用，且必须在使用 this 之前调用，否\n则会报错。\n  父类，即 extends 右边可以是动态的，只需要满足它的返回结果必须有\n[[Constructor] ] 和自己的原型对象。\n  内置对象的继承，ES5的继承有缺陷，因为 this 绑定的先后问题\nes5 先绑定新类型然后是基础类型修饰，es6 是先绑定基础类型，然后是新类型的修饰，\n这样将是该新类型具备基础类型的功能。\n  Symbol.species 只能在类方法内部使用，不能通过构造函数调用，返回当前类的构造\n函数。\n  new.target 类的该属性只会是构造函数，因为类本身是不可以直接调用的，通过它\n的特性可以让一个类抽象化，不能被实例化，只能被其他类继承。\n  提升数组能力(Array) 创建数组 Array.of(…items) ECMAScript5 中构建数组：通过 Array() 构造函数，但是使用这种方式很容易产生疑惑，\n比如：\n值传递一个数值： new Array(2) 则会创建一个长度为 2 的数组。\n传递一个字符串数值： new Array('2') 则会当做一个数组元素，创建了一个元素的数组。\n传递多个参数的时候： new Array(3, '2') 则参数列表中的元素都会被当做数组元素。\n这对我们的使用并不是什么好事，有时候你可能只是想创建一个 2 元素的数组而已，但\n是实际上是一个长度为 2 的空数组。\nECMAScript6 中则新增了 Array.of() 就不会有这种混淆，它只会将参数当做数组元素来\n创建数组，比如：\nArray.of(1, 2) ：两个元素的数组， arr[0] = 1, arr[1] = 2。\nArray.of(2) : 一个元素数组， arr[0] = 2。\nArray.of('2') ：一个元素的数组，arr[0] = \u0026lsquo;2\u0026rsquo;。\n Array.of() 不使用 Symbol.species 决定返回值得类型，它使用的是当前构造函数(在\nof() 函数里面的 this)来决定返回的正确数据类型。\n Array.from(items[, mapFn[, thisArg]]) Array.from 内部伪码实现-\u0026gt;\n将类数组的对象转换成数组类型，类数组对象：\n 有长度属性 有数值索引  1 2 3 4 5 6 7 8 9  let obj = { length: 2 } const objArr = Array.from(obj) console.log(objArr.length) console.log(Array.isArray(objArr)) console.log(objArr[0])   +RESULTS:\n2 true undefined  对于类数组对象如果想使用数组的方法，以往都是通过 call(arrayLike) 方式来调用的，\n比如： Array.prototype.slice.call(arrayLike) 相当于 arrayLike.slice() 借用一\n下数组的 slice 方法因为该方法只要对象有数值索引和长度属性就可以了。\n参数 mapFn ：让转换过程中可以改变被转换元素的结果值，意思就是如果 mapFn 传递\n两个合法的函数，遍历过程中元素的值会进过 mapFn 先处理一遍然后在返回到新的数组\n列表中。\n1 2 3 4 5 6 7 8 9  var obj = { length: 2, \u0026#39;0\u0026#39;: 100, \u0026#39;1\u0026#39;: 200 } var arr = Array.from(obj, v =\u0026gt; v * v); console.log(arr[0], arr[1]); // 10000, 40000   +RESULTS:\n10000 40000  参数 thisArg ：指定 mapFn 的 this 指向：\n1 2 3 4 5 6 7 8 9 10 11 12 13  var helper = { add: v =\u0026gt; v * v } var obj = { length: 2, \u0026#39;0\u0026#39;: 10, \u0026#39;1\u0026#39;: 20 } var arr = Array.from(obj, helper.add, helper); console.log(arr[0], arr[1]); // 100, 400   +RESULTS:\n100 400  用于可迭代的对象 :\n在伪码中可以知道 Array.from 可以处理有迭代器的也可以处理无迭代器的，这里也可以\n使用与自定义迭代器的对象，而不需要具备类数组对象的特征(必须有 length 和数值索\n引值)\n1 2 3 4 5 6 7 8 9 10 11  var nums = { *[Symbol.iterator]() { yield 1; yield 2; yield 3; } } let nums2 = Array.from(nums, v =\u0026gt; v + 1); console.log(nums2[0], nums2[1], nums2[2]); // 2, 3, 4   +RESULTS:\n2 3 4  对应伪码中的实现：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32  // 列表类型，有自己的迭代器 if (usingIterator) { // 取出同步迭代器  let iteratorRecord = GetIterator(items, sync, usingIterator); let k = 0, error; while(1) { // 循环启动迭代器，相当于自动调用了 iterator.next()  // ... 省略  // #1 调用 iterator.next() 启动迭代器，取下一个 yield 值  let next = IteratorStep(iteratorRecord); // ... 省略  // #2 取出当前迭代 { value: xxx, done: false } 中的 value 值  let nextValue = IteratorValue(next); // ... 省略  // #3 将迭代出的值，添加到数组 Pk 位置上。  let defineStatus = CreateDataPropertyOrThrow(A, Pk, mappedValue); // ... 省略  // #4 进入下一次循环。  k++; } }   如上，我们省略了部分代码，只保留我我们需要关注的地方：\n GetIterator(items, sync, usingIterator) 会取出 items 对象的迭代器 while(1) 一个无限循环，用来触发迭代器，相当于 iterator.next() IteratorValue(next) 取出迭代器 {value: xx, done: false} 中 value 的值 最后将值添加到新数组 A 上， k++ 进入下一次 iterator.next()  用于类数组且可迭代的对象 :\n1 2 3 4 5 6 7 8 9 10 11 12 13 14  let nums = { length: 2, \u0026#39;0\u0026#39;: 100, \u0026#39;1\u0026#39;: 200, *[Symbol.iterator]() { yield 1; yield 2; yield 3; } } var nums2 = Array.from(nums); console.log(nums2.length, nums2[0], nums2[1], nums2[2]);   +RESULTS:\n3 1 2 3  从结果看出使用的是 Symbol.iterator 迭代器优先，这从伪码的处理过程中也可确定优\n先级。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32  Array.from = function(items[, mapFn[, thisArg]]) { // ...  // 取出类数组对象的迭代器，将用来取出有效的数组元素  let usingIterator = GetMethod(items, @@iterator); // 列表类型，有自己的迭代器  if (usingIterator) { // 迭代器判断在前  // .... return  } // 非列表类型，没有自己的迭代器，可能是个类数组对象  let arrayLike = ToObject(items); // 必须具备长度属性，才能转数组，这也是类数组对象必备条件之一  let len = ToLength(Get(arrayLike, \u0026#39;length\u0026#39;)) // ...  let k = 0; while (k \u0026lt; len) { // 类数组对象的判断在后  // ...  } Set(A, \u0026#39;length\u0026#39;, len, true); return A; }   原型上新增的方法 flat([depth])2019 扁平化数组，降维。 depth 表示降多少次，如果是 Infinity 则把数组降维到一维数\n组。\n1 2 3  const nums = [1, 2, 3, [4, 5]] console.log(nums.flat()) // [ 1, 2, 3, 4, 5 ]   flatMap()2019 find(mapFn[, thisArg]) \u0026amp; findIndex(mapFn[, thisArg]) 查找元素，内部实现伪码。\n以往并没有什么内置的方法用来查找数组中的元素，一般我们都是使用 indexOf 和\nlastIndexOf 或者利用他们实现自己的自定义方法。\nECMAScript 6 中新增了两个专门用来查找元素的两个方法：\n find(mapFn[, thisArg]) 返回满足条件的第一个元素值 findIndex(mapFn[, thisArg]) 返回满足条件的第一个元素值的索引  两个方法的 mapFn 接受的参数与 map() 和 forEach() 一样，接收三个参数：\n value 遍历当前值 index 当前索引 array 数组本身  1 2 3 4  let nums = [1, 2, 3, 4]; console.log(nums.find(n =\u0026gt; n \u0026gt; 2)); console.log(nums.findIndex(n =\u0026gt; n \u0026gt; 2));   fill(value[, start[, end]]) fill 内部实现伪码。\n从指定起始结束位置将数组元素替换成 value 。\n参数：\n value required 替换的值 start optional, 默认(0)， 起始位置 end optional, 默认(length)，结束位置  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29  let nums = [1, 2, 3, 4]; nums.fill(1); // 1, 1, 1, 1 console.log(nums.toString()); nums.fill(2, 1); // 1,2,2,2 console.log(nums.toString()); nums.fill(3, 2, 4); // 1,2,3,3 console.log(nums.toString()); // 负数，len + (-1) = 3 =\u0026gt; fill(1, 3); nums.fill(1, -1); // 1,2,3,1 console.log(nums.toString()); // 负数，len + (-2) = 2 =\u0026gt; fill(1, 2); nums.fill(1, -2); // 1,2,1,1 console.log(nums.toString()); // 负数，start: len + -2 = 2 =\u0026gt; fill(1, 2, 1) // 2 \u0026lt; 1 =\u0026gt; start \u0026lt; end =\u0026gt; 无效 nums.fill(1, -2, 1); // 1,2,1,1 console.log(nums.toString()); // start: len + -2 = 2 // end: len + -1 = 3 // =\u0026gt; fill(1, 2, 3) nums.fill(4, -2, -1); // 1,2,4,1 console.log(nums.toString());   +RESULTS:\n1,1,1,1 1,2,2,2 1,2,3,3 1,2,3,1 1,2,1,1 1,2,1,1 1,2,4,1  copyWithin(target, start[, end]) copyWithin 内部实现伪码。\n方法功能：拷贝 count = start:0 - end:length 之间的元素，用这些元素从\ntarget(num = target:0 - len ) 位置开始替换数组内的元素，实际被替换的元素个数由\nnum 决定。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14  let nums = [1, 2, 3, 4, 5, 6, 7, 8, 9]; let res = nums.copyWithin(0, 3, 5); console.log(\u0026#39;\u0026gt;\u0026gt;\u0026gt; 拷贝元素个数 \u0026lt;= len - 起始位置\u0026#39;) console.log(res.toString(), \u0026#39;res\u0026#39;) console.log(nums.toString(), \u0026#39;nums\u0026#39;) console.log(nums === res, \u0026#39;res === nums ?\u0026#39;) console.log(\u0026#39;\u0026gt;\u0026gt;\u0026gt; 拷贝元素个数 \u0026gt; len - 起始位置\u0026#39;) nums = [1, 2, 3, 4, 5, 6, 7, 8, 9]; res = nums.copyWithin(6, 3); console.log(res.toString(), \u0026#39;res\u0026#39;) console.log(nums.toString(), \u0026#39;nums\u0026#39;) console.log(nums === res, \u0026#39;res === nums ?\u0026#39;)   +RESULTS:\n\u0026gt;\u0026gt;\u0026gt; 拷贝元素个数 \u0026lt;= len - 起始位置 4,5,3,4,5,6,7,8,9 res 4,5,3,4,5,6,7,8,9 nums true 'res === nums ?' \u0026gt;\u0026gt;\u0026gt; 拷贝元素个数 \u0026gt; len - 起始位置 1,2,3,4,5,6,4,5,6 res 1,2,3,4,5,6,4,5,6 nums true 'res === nums ?'   如果 end - start \u0026gt; len - target 则只替换 len - target 个元素 如果 end - start \u0026lt; len - target 则只替换 end - start 个元素  被替换的元素个数决定因素： Math.min(end - start, len - target) 取最小值得个数。\nTODO 类型化数组(Typed Arrays) TODO 类型化数组和普通数组的相似点 TODO 类型化数组和普通数组的不同点 TODO 小结 Promises和异步编程 Nodejs 异步编程：事件触发 + 回调。\nPromise: 指定一些代码延时执行，并且可知道代码是否执行成功或失败，支持链式调用。\n为了更好的理解 Promise 如何工作，有必要了解一些与异步相关的基本概念。\nPromise Apis Promise.prototype.finally(onFinally) 不管异步任务执行结果如何，都会在任务都完成之后被执行的代码。\n1 2 3 4 5 6 7 8 9 10  new Promise((resolve, reject) =\u0026gt; { setTimeout(() =\u0026gt; { resolve() }, 2000) }).then(() =\u0026gt; { console.log(\u0026#39;p then\u0026#39;) }).finally(() =\u0026gt; { console.log(\u0026#39;p finally\u0026#39;) })   异步编程背景 JavaScript 引擎基于事件循环的单线程，单线程意味着一次只能执行一个代码片段。\n因此 JavaScript 引擎就需要去跟踪和管理这些代码片段，而这些代码片段会被一个叫“任\n务队列”的东西所持有，无论什么时候如果代码准备执行，它就会被添加到“任务队列”，当\n代码被执行完成，，事件循环就会开始执行队列中的下一个任务。\n在队列中，任务的执行顺序总是从第一个任务开始执行到最后一个人任务执行结束。\n事件模型 比如，用户点击了一个键盘上的按键，触发点击(onclick)事件，那么引擎会通过在任务\n队列的末尾添加一个新的任务来响应这个事件，这也是 JavaScript 中最基本的异步编程模\n型，被添加到队列中的事件的回调并不会立即执行直到事件被触发，且被触发执行回调时\n候会拥有自己合适的上下文执行环境。\n比如：\n1 2 3 4  let button = document.getElementById(\u0026#34;my-btn\u0026#34;); button.onclick = function(event) { console.log(\u0026#34;Clicked\u0026#34;); };   上面的按钮点击事件，在按钮点击之前是不会被执行，一旦按钮被点击，那么赋值给\nonclick 的代码片段(或叫“任务”)就会立即被添加到“任务队列”的末尾，等待它前面的其\n他任务执行完成之后再执行(也就是说它不一定点击之后立即执行，前面可能还有其他任务\n在等待执行)。\n回调模式 在 JavaScript 中，我们最常用的异步莫过于回调的使用了，比如在读取一个文件的时候，\n读取完成之后要做一些处理，这个时候就会用到回调函数，因为读取文件相对来说是一个比\n较耗时的操作，不太可能使用同步进行处理，因此通过回调来处理异步读取文件是个非常不\n错的体验。\n比如：\n1 2 3 4 5 6 7 8  readFile(\u0026#34;example.txt\u0026#34;, function(err, contents) { if (err) { throw err; } console.log(contents); }); console.log(\u0026#34;Hi!\u0026#34;);   在读取 example.txt 文件内容之后将其立即答应出来，这里的回调函数并不会立即执行，\n而是在文件读取完成之后，会立即被添加到“任务队列”的列尾，在其他在它前面的任务执行\n完成之后会被立即执行，这和上面讲的“事件模型”是一样的原理。\n这相对来说读取一个文件，然后执行输出这种算是比较简单的应用场景，而现实中往往并不\n是这样的，现实中往往是多个事情之间有其关联性，也就是说工人在流水线上工作的时候，\n就必须依赖于上一个人工作的传递才能继续往下执行，这如果体现在代码使用回调完成这将\n会不可思议(这也就是我们常说的回调地狱问题)：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32  method1(function(err, result) { if (err) { throw err; } method2(function(err, result) { if (err) { throw err; } method3(function(err, result) { if (err) { throw err; } method4(function(err, result) { if (err) { throw err; } method5(result); }); }); }); });   method4 必须等待 method3 执行完成，\nmethod3 必须等待 method2 执行完成，\n…\n一直到 method1 执行完成，这无论是在逻辑还是代码阅读性上都将会让人崩溃。\n一直到 Promise 的出现才比较有效的解决了这回调地狱及代码可读性的问题。\nPromise 基础 一个 promise 实例作为一个异步操作的结果返回，而不再使用时间绑定或将回调作为参数\n传递给一个函数的方式，现在一个函数可以直接返回一个 promise ，比如：\n1  let promise = readFile(\u0026#39;example.txt\u0026#39;);   上面的代码中读取文件操作实际上并不会立即执行，而是返回了一个 promise 可以让你决\n定如何去响应这个读取文件操作。\nPromise 的生命周期   pending, 表示异步操作尚未完成，也被标记为 unsettled 。\n比如 let promise = readFile('example.txt'); 执行之后，这个 promise 状态就\n成为了 pending 一旦文件读取操作完成，该 promise 就会被设置为 settled ，随\n后进入下面两种状态的一种，且不可逆。\n  Fulfilled : 表示该 promise 代表的异步任务执行成功\n  Rejected : 表示该 promise 代码的异步任务执行失败了或者执行过程中出现异常等其\n它非正常结果。\n  且 promise 有个内部属性 [[PromiseState] ] 用来记录了整个 promise 状态的变化，\n它的值由三个： pending, fulfilled, rejected 对应着 promise 的三种不同状态。\n该内部属性没有对外的接口，因此是无法直接去访问或操作它的，但是 promise 提供了一\n个 then() 方法，可以接受处理的结果(fulfilled 或 rejected)。\nthen(fulfilled, rejected) 接受两个参数，这两个参数为函数类型，第一个会在\npromise 状态变成 fulfilled 的时候调用，第二个则会在 rejected 状态下调用。\nfulfilled(data) : 函数会接受 promise 成功之后传递出来的数据。\nrejected(error) : 函数会接受 promise 失败之后触发的异常数据。\n 任意对象只要实现了 then() 方法都可以叫做一个 thenable ，所有的 promises 都是\nthenable 的，但并不是所有的 thenable 都是 promises 。\n 使用：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14  let fs = require(\u0026#39;fs\u0026#39;) let promise = new Promise(function(resolve, reject) { fs.readFile(__dirname + \u0026#39;/config.json\u0026#39;, (err, data) =\u0026gt; { if (err) { reject(err) } else { resolve(data) } }) }) console.log(promise)   +RESULTS: 上面代码我们只是将读取文件操作包装成了一个 promise 但是并没有立即去读\n取文件，且此刻 promise 的状态显示为 pending 。\nPromise { \u0026lt;pending\u0026gt; }  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23  let fs = require(\u0026#39;fs\u0026#39;) let promise = new Promise(function(resolve, reject) { fs.readFile(__dirname + \u0026#39;/config.json\u0026#39;, (err, data) =\u0026gt; { if (err) { reject(err) } else { resolve(data) } }) }) // 将触发 promise 状态发生改变 promise.then(data =\u0026gt; { console.log(promise) console.log(data) }, err =\u0026gt; { console.log(promise) console.log(err) }) console.log(promise)   +RESULTS: promise 成功之后的输出，状态将成为 fulfilled (这里没输出出来，o(╯□╰)o)。\nPromise { \u0026lt;pending\u0026gt; } Promise { \u0026lt;Buffer 49 27 6d 20 61 20 70 72 6f 6d 69 73 65 20 65 78 61 6d 70 6c 65 2e 2e 2e 2e 2e 2e 0a\u0026gt; } \u0026lt;Buffer 49 27 6d 20 61 20 70 72 6f 6d 69 73 65 20 65 78 61 6d 70 6c 65 2e 2e 2e 2e 2e 2e 0a\u0026gt;  +RESULTS: 读取失败之后状态为 rejected 的输出。\nPromise { \u0026lt;pending\u0026gt; } Promise { \u0026lt;rejected\u0026gt; { Error: ENOENT: no such file or directory, open '/private/var/folders/kt/b5x0yl_56h1drdb8xgfmbk_r0000gn/T/babel-LzyRrW/config.json' errno: -2, code: 'ENOENT', syscall: 'open', path: '/private/var/folders/kt/b5x0yl_56h1drdb8xgfmbk_r0000gn/T/babel-LzyRrW/config.json' } } { [Error: ENOENT: no such file or directory, open '/private/var/folders/kt/b5x0yl_56h1drdb8xgfmbk_r0000gn/T/babel-LzyRrW/config.json'] errno: -2, code: 'ENOENT', syscall: 'open', path: '/private/var/folders/kt/b5x0yl_56h1drdb8xgfmbk_r0000gn/T/babel-LzyRrW/config.json' }  promise 也提供了一个 catch() 接口给我们用来捕获异常，比如上面的例子还可以这样：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27  let fs = require(\u0026#39;fs\u0026#39;) let promise = new Promise(function(resolve, reject) { fs.readFile(__dirname + \u0026#39;/config.json\u0026#39;, (err, data) =\u0026gt; { if (err) { reject(err) } else { resolve(data) } }) }) // 将触发 promise 状态发生改变 promise.then(data =\u0026gt; { console.log(promise) console.log(data) }, err =\u0026gt; { console.log(\u0026#39;error in then\u0026#39;) console.log(err) }).catch(function(err) { console.log(\u0026#39;error in catch\u0026#39;) console.log(err) }) console.log(promise)   +RESULTS: 结果是 then 中和 catch 中都有执行\nPromise { \u0026lt;pending\u0026gt; } error in then { [Error: ENOENT: no such file or directory, open '/private/var/folders/kt/b5x0yl_56h1drdb8xgfmbk_r0000gn/T/babel-LzyRrW/config.json'] errno: -2, code: 'ENOENT', syscall: 'open', path: '/private/var/folders/kt/b5x0yl_56h1drdb8xgfmbk_r0000gn/T/babel-LzyRrW/config.json' }  使用 promise 有个好处就是，比如上面的遇到执行异常，它会将异常捕获并处暴露出来，\n一旦出现异常，或执行失败 promise 的状态会立即成为 rejected ，且无法逆转，即该\npromise 已经彻底完成(无关成功或失败)。\n而事件模型中如果发生错误，该事件就不会被触发，而在回调中你就必须时常记住去检查异\n常情况的出现可能性，并作出相应的处理。\n而在 promise 中异常会被捕获，如果你想针对异常做处理可以使用 then-reject 或\ncatch() 都行，如果不想处理就静默结束 promise 即可，而不用关心是否会导致任务失\n败而中断业务。\n一个 fufillment 或 rejection 的任务，如果在 promise 状态已经发生改变(settled,\n成为 fulfilled 或 rejected )的情况下，依然添加了新的任务，那么它依旧会继续执\n行。其实这也就相当于给其赋予了一个新的任务，比如：\n1 2 3 4 5 6 7 8 9 10 11 12  let promise = readFile(\u0026#34;example.txt\u0026#34;); // original fulfillment handler promise.then(function(contents) { console.log(contents); // #1 now add another  promise.then(function(contents) { console.log(contents); }); });   #1 处相当于针对 promise 又在任务队列末尾新增了一个任务，等待被执行。\n创建 unsettled Promises 通过 Promise 构造函数可以创建一个 unsettled 状态的 promise 实例：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23  let fs = require(\u0026#39;fs\u0026#39;) function readFile(name) { return new Promise(function(resolve, reject) { console.log(\u0026#39;...outer\u0026#39;) fs.readFile(__dirname + \u0026#39;/config.json\u0026#39;, (err, data) =\u0026gt; { console.log(\u0026#39;...inner\u0026#39;) if (err) { reject(err) } else { resolve(data) } }) }) } // 得到了一个 pending - unsettled 的 promise let promise = readFile() // 触发 promise 任务，状态将变成 settled: fulfilled 或 rejected // #1 promise.then(data =\u0026gt; console.log(data), err =\u0026gt; console.log(err)) console.log(promise)   +RESULTS: #1 注释之后的输出结果，Promise 的参数函数会立即执行。\n...outer Promise { \u0026lt;pending\u0026gt; } ...inner  +RESULTS: fulfilled 结果\nPromise { \u0026lt;pending\u0026gt; } \u0026lt;Buffer 49 27 6d 20 61 20 70 72 6f 6d 69 73 65 20 65 78 61 6d 70 6c 65 2e 0a\u0026gt;  +RESULTS: rejected 结果\nPromise { \u0026lt;pending\u0026gt; } { [Error: ENOENT: no such file or directory, open '/private/var/folders/kt/b5x0yl_56h1drdb8xgfmbk_r0000gn/T/babel-fFqHec/config.json'] errno: -2, code: 'ENOENT', syscall: 'open', path: '/private/var/folders/kt/b5x0yl_56h1drdb8xgfmbk_r0000gn/T/babel-fFqHec/config.json' }   Promise 需要一个参数作为参数 该函数的参数有两个：1）resolve 任务执行成功之后调用，2）reject 任务失败调用 创建成功之后传递给 Promise 的函数会立即执行，并且将会在任务队列末尾添加一个任\n务去处理这个 promise，这被称为“任务调度”。 参数函数立即执行，但是 resolve 和 reject 会被当做异步任务添加到任务队列末尾去\n等待执行。  创建 settled Promises  Promise.resolve() 会创建一个状态必定是 fullfilled 的 promise Promise.reject() 会创建一个状态必定是 rejected 的 promise  1 2 3 4 5  let promise = Promise.resolve(42); promise.then(function(value) { console.log(value) })   +RESULTS:\n42  Promise.resolve() 创建的 promise 状态永远只会是 fulfilled 因此， reject 函数\n是永远不会执行的，同理 =Promise.reject()=。\n1 2 3 4 5 6 7 8  let promise = Promise.reject(100) promise.then(null, function(value) { console.log(value, \u0026#39;1\u0026#39;) }) promise.catch(function(value) { console.log(vlaue, \u0026#39;2\u0026#39;) })   +RESULTS:\n100 '1'   如果给 Promise.resolve() 或 Promise.reject() 传递了一个 promise 那么它什么都\n不会做，直接原样返回这个 promise 。\n 非 Promise 的 Thenables 非 Promise 的 Thenable : 对象有自己的 then(resolve,reject) 方法，那么就可以使\n用 Promise.resolve() 或 Promise.reject() 将该 thenable 转变成一个\nfulfilled 或 rejected 的 promise，至于到底是哪个状态的要取决于 thenable 函数\n内部是执行了 resolve() 还是 reject() 。\n1 2 3 4 5 6 7 8 9 10 11  let thenable = { then: function(resolve, reject) { resolve(42) } } // 变成了一个 Fulfilled promise let p1 = Promise.resolve(thenable) p1.then(function(value) { console.log(value) })   +RESULTS:\n42  1 2 3 4 5 6 7 8 9 10 11 12  let thenable = { then: function(resolve, reject) { reject(42) } } // 变成了一个 Fulfilled promise let p1 = Promise.resolve(thenable) p1.catch(function(value) { console.log(value) })   +RESULTS:\n42  执行异常 Promise 会在其内部将代码的执行过程，使用 try...catch 捕获到异常，然后通过\nthen(null, reject) 或 catch(function(error){}) 将异常暴露出来。\n1 2 3 4 5 6 7 8  let promise = new Promise(function(resolve, reject) { throw new Error(\u0026#39;Explosion!\u0026#39;) }) promise.catch(function(error) { console.log(error) })   +RESULTS:\nError: Explosion! at /private/var/folders/kt/b5x0yl_56h1drdb8xgfmbk_r0000gn/T/babel-fFqHec/js-script-7ANcUx:3:9 at new Promise (\u0026lt;anonymous\u0026gt;) at /private/var/folders/kt/b5x0yl_56h1drdb8xgfmbk_r0000gn/T/babel-fFqHec/js-script-7ANcUx:2:15  也可以手动捕获异常调用 reject() :\n1 2 3 4 5 6 7 8 9 10 11 12 13  let promise = new Promise(function(resolve, reject) { try { throw new Error(\u0026#39;Explosion!\u0026#39;) } catch(err) { reject(err) } }) promise.catch(function(error) { console.log(error) })   +RESULTS: 结果是一样的\nError: Explosion! at /private/var/folders/kt/b5x0yl_56h1drdb8xgfmbk_r0000gn/T/babel-fFqHec/js-script-oIepKJ:4:11 at new Promise (\u0026lt;anonymous\u0026gt;)  全局 Promise Rejection 处理 在之前的章节我们讲过，如果 promise 中的状态变成 rejected ，可能是任务失败，或\n代码执行异常了，而这些异常实际上被捕获了，可以通过 then(null, reject) 的\nreject 来接受或使用 catch(function(err){} 捕获。\n正式由于这种灵活性导致我们很难决定这些异常什么时候应该被处理，哪些有被处理，哪些\n没有被处理，哪些又是什么时候被处理了???\n比如 promise 状态已经 rejected 完成了，但是 rejection 相关的处理却并没有在合\n适的时候得到处理，因为这完全取决于编程者愿不愿意或什么时候去调用 then(null, reject) 或 catch(function(err){} 去处理。\n在 ECMAScript6 版本中并没有涉及到该问题的解决。\n在浏览器端和 Node.js 已经更新解决了该痛点问题，但这并非是 ECMAScript 6 的一部分。\nNode.js Rejection 处理 在 Node.js 中有两个 process 对象上的事件与 promise rejection 处理相关：\n unhandledRejection: 在一个事件循环中一个 promise 状态已经 rejected 了，但\n是没有任何 rejection 操作被调用的时候触发。 rejectionHandled: 与上面的相反，表示状态 rejected 了，且有相关的 rejection\n操作被调用。  unahdnledRejection 事件的回调接受两个参数，一个是 reason 失败原因，一个是该\npromise 对象本身，如：\n1 2 3 4 5 6 7 8  let rejected process.on(\u0026#39;unhandledRejection\u0026#39;, function(reason, promise) { console.log(reason.message) console.log(rejected === promise) }) rejected = Promise.reject(new Error(\u0026#39;Explosion!\u0026#39;))   +RESULTS:\nExplosion! true  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  let rejected process.on(\u0026#39;unhandledRejection\u0026#39;, function(reason, promise) { console.log(reason.message, \u0026#39;unhandledrejection\u0026#39;) console.log(rejected === promise, \u0026#39;unhandledrejection\u0026#39;) }) process.on(\u0026#39;rejectionHandled\u0026#39;, function(promise) { console.log(rejected === promise, \u0026#39;rejectionHandled\u0026#39;) }) rejected = Promise.reject(new Error(\u0026#39;Explosion!\u0026#39;)) setTimeout(() =\u0026gt; rejected.catch(function(err) { console.log(err.message, \u0026#39;catch\u0026#39;) }), 1000)   +RESULTS:\nExplosion! unhandledrejection true 'unhandledrejection' Explosion! catch true 'rejectionHandled'  如上结果，首先触发的是 unhandledRejection 事件，1 秒之后 rejection 被\ncatch() 处理掉了，触发 rejectionHandled 事件。\n有了上面的基础，我们这里就可以实现一个简易的 unhandled rejections tracker ，来\n跟踪哪些 promise 的 rejection 有被处理，哪些没有被处理，如果没有可以针对这些\nrejection 做些什么事情。\n 使用 Map 结构保存 promise =\u0026gt; reason 当前 Promise 和它的 rejection 没有被\n处理的原因。 监听 unhandledRejection 事件，在这里面将 promise=\u0026gt;reason 添加到 map。 监听 rejectionHandled 事件，这里执行删除，因为 rejection 已经被处理，不需要\n再保留了。  这里使用的是强引用类型的 Map ，因为我们需要能够用到的 promise 引用去获取当前的\npromise 执行设置或删除处理。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28  // 需要使用 Map 强引用类型，因为 unhandledRejection 和 rejectionHandled // 需要用到同一个 promise let possiblyUnhandledRejections = new Map() process.on(\u0026#39;unhandledRejection\u0026#39;, function(reason, promise) { possiblyUnhandledRejections.set(promise, reason) }) process.on(\u0026#39;rejectionHandled\u0026#39;, function(promise) { possiblyUnhandledRejections.delete(promise) }) function handleRejection(promise, reason) { // ... 对每个 promise 的 rejection 进行处理 } setInterval(function() { // 每隔 6 秒检查一次 rejections ，如果有未处理的 rejection 就立即处理掉  possiblyUnhandledRejections.forEach(function(reason, promise) { console.log(reason.message || reason) handleRejection(promise, reason) }) // 处理完成之后清空 rejections  possiblyUnhandledRejections.clear() }, 6000)   上面的代码功能：每隔 6 秒监听一次未处理的 promise rejections 的情况，如果有未处\n理的，就立即将它处理掉，然后清空 map ，这样就不会存在没有被处理的 rejections\n了。\n浏览器 Rejection 处理 在浏览器端也是通过监听两个同名的事件来处理这些 rejections ，使用方式基本相同，只\n需要注意几点：\n unhandledRejection 和 rejectionHandled 两个事件是在 window 对象上 事件的处理句柄的参数只有一个 event ，指向的是当前事件对象，该对象内包含三个\n我们感兴趣的内容：  type : 事件类型， unhandledRejection 或 rejectionHandled promise : 当前的 promise 对象 reason : 当前的 rejection 产生的原因    1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  let rejected; window.onunhandledrejection = function(event) { console.log(event.type); // \u0026#34;unhandledrejection\u0026#34;  console.log(event.reason.message); // \u0026#34;Explosion!\u0026#34;  console.log(rejected === event.promise); // true }; window.onrejectionhandled = function(event) { console.log(event.type); // \u0026#34;rejectionhandled\u0026#34;  console.log(event.reason.message); // \u0026#34;Explosion!\u0026#34;  console.log(rejected === event.promise); // true }; rejected = Promise.reject(new Error(\u0026#34;Explosion!\u0026#34;));   unhandled rejections tracking 代码和 Node.js 实现一样：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25  let possiblyUnhandledRejections = new Map(); // when a rejection is unhandled, add it to the map // 与 nodejs 版本不同点：这里只有一个事件参数，而不是 reason,promise window.onunhandledrejection = function(event) { possiblyUnhandledRejections.set(event.promise, event.reason); }; // 与 nodejs 版本不同点：这里参数不再是 promise 而是事件对象 window.onrejectionhandled = function(event) { possiblyUnhandledRejections.delete(event.promise); }; setInterval(function() { possiblyUnhandledRejections.forEach(function(reason, promise) { console.log(reason.message ? reason.message : reason); // do something to handle these rejections  handleRejection(promise, reason); }); possiblyUnhandledRejections.clear(); }, 60000);   链式 Promises 实际上，每次调用 then() 或 catch() 都是创建并返回了另一个 promise ，第二个\npromise 只会在第一个的状态已经 settled 之后(无论是 fulfilled 或 rejected)才会\nresolved。\n链式 Promise 语法 1 2 3 4 5 6 7 8 9  let p1 = new Promise(function(resolve, reject) { resolve(42) }) p1.then(function(value) { console.log(value) }).then(function() { console.log(\u0026#39;finished.\u0026#39;) })   +RESULTS:\n42 finished.  实际上调用第二个 then() 的 promise 是一个全新的 Promise 。\n1 2 3 4 5 6 7 8 9 10 11 12 13  let p1 = new Promise(function(resolve, reject) { resolve(42) }) let p2 = p1.then(function(value) { console.log(value) }) p2.then(function() { console.log(\u0026#39;finished.\u0026#39;) }) console.log(p1 === p2)   +RESULTS:\nfalse 42 finished.  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17  let p1 = new Promise(function(resolve, reject) { resolve(42) }) let p3 = null let p2 = p1.then(function(value) { console.log(value) p3 = Promise.resolve(100) return p3 }).then(function(val) { console.log(val, \u0026#39;p3\u0026#39;) console.log(p3 === p2, \u0026#39;p3 is not p2\u0026#39;) }) console.log(p1 === p2, \u0026#39;p2 is not p1\u0026#39;)   +RESULTS: 我们也可以显示的在上一个 then() 里面返回一个 promise，从下面的第三行\n输出可知，下一个 then() 处理的即上一个 then() 里面返回的 promise，如果没有显\n式返回一个 promise 默认会创建一个新的 Promise 返回。\nfalse 'p2 is not p1' 42 100 'p3' false 'p3 is not p2'  效果是一样的，但 p1 和 p2 并非同一个 promise。\n异常捕获 通过链式调用可以使用 catch() 捕获上一个 promise 中的异常。\n\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  let p1 = new Promise(function(resolve, reject) { resolve(42) }) p1.then(function(value) { console.log(\u0026#39;first then.\u0026#39;) }).then(function(value) { throw new Error(\u0026#39;Boom!\u0026#39;) }).then(function(value) { console.log(\u0026#39;third then.\u0026#39;) }).catch(function(error) { console.log(error.message) return Promise.resolve(\u0026#39;100\u0026#39;) }).then(function(value) { console.log(value, \u0026#39;four then.\u0026#39;) })   +RESULTS: 在第一个 catch() 中返回一个 Promise.resolve('100') 结果，这也说明\n`four then` 来自 catch() 里面的 promise.resolve。\nfirst then. Boom! 100 four then.  +RESULTS: four then 有输出，这是因为之前的异常已经被上一个 catch() 捕获并处理\n了， promise 恢复正常状态。\nfirst then. Boom! four then.  +RESULTS: 新增 first then 结果，异常之后得 thenable 不会被执行，因为该 promise\n已经终结。\nfirst then. Boom!  +RESULTS: 新增 third then 输出和之前的一样，因为前面的发生了异常后面的就无法再\n继续了。\nBoom!  +RESULTS:\nBoom!  从以上结果，不难看出，如果链式 promise 当中有一处发生异常，会终结这个 promise 链，\n除非后面有一个 catch() 将该异常捕获并处理掉了，才能继续在链后面追加 then()\n。\n 通常情况下，最好是在链式调用的结束有一个 rejection 处理(reject 或 catch)，确\n保链式调用中出现的异常能得到适当的处理。\n Promise 链式调用中返回值 其实在上一节的实例中，我们就已经用到了在 thenable 中返回一个值，该例中是直接返\n回了一个 Promise.resolve() 其本身就是返回了一个新的 Promise 对象，其实我们还可\n以直接返回一个普通的表达式或者其他类型的值，它的结果最终也会被封装成一个新的\nPromise 实例返回出来。\n返回值：\n 普通类型值或表达式 Promise.resolve() 或 Promise.reject() 或者直接 new Promise() 返回一个全新的 promise 还可以返回另一个已经存在的 promise 实例 前面出现的异常即可以用 rejection 来接收，也可以使用 catch() 来接受，实际根\n据需要作出选择  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30  let p1 = new Promise(function(resolve, reject) { resolve(42) }) p1.then(function(value) { console.log(value) // 42  return value + 1 }).then(function(value) { console.log(value) // 43  return Promise.resolve(value + 1) }).then(function(value) { console.log(value); // 44  throw new Error(\u0026#39;Boom!\u0026#39;) }).catch(function(error) { console.log(error.message); // Boom!  let p2 = new Promise(function(resolve, reject) { resolve(100) }) return p2 }).then(function(value) { console.log(value); // 100  return Promise.reject(\u0026#39;end here.\u0026#39;) }).then(null, function(reason) { // 上一个的异常可以使用 rejection 接受  console.log(reason); // end here.  return Promise.reject(\u0026#39;end end here.\u0026#39;) }).catch(function(error) { // 也可以用 catch 来接受  console.log(error) })   +RESULTS:\n42 43 44 Boom! 100 end here. end end here.  返回值也可以在一个 rejection，比如 catch() 中使用。\n响应多个 Promises 在之前的章节中，我们所使用的实例都是一次只能接受处理一个 promise，但是，如果你想\n要同时去接收多个 promise 且下一步的行为由这些多个 promise 共同决定的时候，就需要\n考虑使用下面这两个方法。\n Promise.all() 所有的 promise 状态完成了，才会被视为 resolved。 Promise.race() 多个 promise 只要有一个状态完成了，那么 race() 就被视为已经\n完成  Promise.all(iterable) 参数 iterable 是一个元素为 promise 的列表，该接口的含义是只有 iterable 中所有的\npromise 状态都为 resolved 了，这个接口返回的 promise 才会是 resolved ，否则只要\n有一个 rejected 了，返回的 promise 就会是 rejected。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19  let p1 = new Promise(function(resolve, reject) { resolve(42) }) let p2 = new Promise(function(resolve, reject) { resolve(43) }) let p3 = new Promise(function(resolve, reject) { resolve(44) }) let p4 = Promise.all([p1 , p2, p3]) p4.then(function(value) { // 结果是由 p1, p2, p3 的结果值组成的数组  console.log(Array.isArray(value)); // true  console.log(value.toString()); // 42, 43, 44 })   +RESULTS:\ntrue 42,43,44   Promise.all() 是：一荣俱荣(resolved)，一损俱损(rejected)，大家都在一条船上，一根\n绳上的蚂蚱，谁也别想偷懒。\n 只要有一个 rejected 的了，那么立即 rejected 不会得到其他的 promise 完成：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20  let p1 = new Promise(function(resolve, reject) { resolve(42) }) let p2 = new Promise(function(resolve, reject) { reject(43) }) let p3 = new Promise(function(resolve, reject) { resolve(44) }) let p4 = Promise.all([p1 , p2, p3]) p4.catch(function(value) { // 结果是由 p1, p2, p3 的结果值组成的数组  console.log(Array.isArray(value)); // true  console.log(value.toString()); // 42, 43, 44 })   +RESULTS: 因为只要有一个 rejected 了，就会立即 rejected 因此异常的结果值只会是所\n有 promises 中的一个。\nfalse 43  Promise.race(iterable) iterable 中的所有 promises 属于竞争关系，利己主义者，并且不管第一个状态完成的状\n态是 fulfilled 或 rejected 只要是 settled 那么 race() 就会立即 settled。\nrace() 中的每个 promise 都是自私鬼，宁愿自己失败也要赶在第一时间将大伙消灭(主体\npromise 都结束了)\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  let p1 = Promise.resolve(42) let p2 = new Promise(function(resolve, reject) { resolve(43) }) let p3 = new Promise(function(resolve, reject) { resolve(44) }) let p4 = Promise.race([p1 , p2, p3]) p4.then(function(value) { console.log(value); })   +RESULTS:\n42  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22  let delay = (fn, timeout) =\u0026gt; setTimeout(fn, timeout) let p1 = new Promise(function(resolve, reject) { delay(() =\u0026gt; resolve(42), 100) }) let p2 = new Promise(function(resolve, reject) { resolve(43) }) let p3 = new Promise(function(resolve, reject) { delay(() =\u0026gt; resolve(44), 50) }) let p4 = Promise.race([p1 , p2, p3]) p4.then(function(value) { console.log(value); // 43 })   +RESULTS:\n43  异步任务执行器 在之前的章节9.8.1中我们有使用 iterator + generator 实现一个简易的异\n步任务执行函数，会在上一个任务完成之后立即启动下一个任务，如此往复直到所有任务都\n完成为止。\n在这里我们将使用 Promise 来实现它：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43  let fs = require(\u0026#39;fs\u0026#39;) function run(taskDef) { let task = taskDef(); let result = task.next(); function step() { if (!result.done) { // 这里不用判断值是什么类型，promise.resolve 统统转成 promise  let promise = Promise.resolve(result.value) promise.then(function(value) { result = task.next(value) step() }).catch(function(error) { result = task.throw(error) step(); }) } } step(); } function readFile(filename) { return new Promise(function(resolve, reject) { fs.readFile(filename, function(err, contents) { if (err) { reject(err) } else { resolve(contents) } }) }) } run(function *() { let contents = yield readFile(__dirname + \u0026#39;/config.json\u0026#39;) // do something with response data  console.log(contents) console.log(\u0026#39;Done\u0026#39;) })   Promise 版本需要注意的点：\n readFile 即任务函数必须返回一个 Promise 对象 在 step() 里面讲迭代器的值无论什么类型，让它变成一个 promise ，通过\nthen() 去接受执行结果， catch() 去捕获并处理异常。  Promise 版本相对于 iterator + generator 版本有点：\n 不用关心迭代器中 value 的值是什么类型，只要转成 promise 能有效的处理异常，使用 catch() 捕获异常，不用中断程序 不用使用回调传递(readFile 返回一个带有回调的函数，这个回调会被传递到迭代器的\nvalue 值，但实际最后被使用的是 readFile 中的 fs.readFile())，而使用 Promise\n就不需要关心回调是如何被传递和执行了。  未来异步任务执行器(async…await) 在 ECMAScript 2017(es8) 中引入了一个新的语法糖： async...await 这让异步任务变\n得异常简单，其内部实现也是基于 Promise 来实现的。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19  let fs = require(\u0026#39;fs\u0026#39;) function readFile(filename) { return new Promise(function(resolve, reject) { fs.readFile(filename, function(err, data) { if (err) { reject(err) } else { resolve(data) } }) }) } (async function() { let contents = await readFile(__dirname + \u0026#39;/config.json\u0026#39;) console.log(contents) console.log(\u0026#39;Done\u0026#39;) })()   +RESULTS:\n\u0026lt;Buffer 78 78 78 78 78 78 78 78 78 78 78 78 78 78 78 78 78 78 78 78 78 78 78 78 78 78 78 78 78 0a 78 78 78 78 78 78 78 78 78 78 78 78 78 78 78 78 78 78 78 78 ... \u0026gt; Done  小结   Promise 有三个状态： pending(创建之初时), fulfilled(执行成功) 和 rejected(执行\n失败或异常)，且状态一旦改变就无法逆转。\n  promise.then(resolve, reject) 用回调来接收上一个 promise 执行成功或失败的结\n果\n  catch(rejection) 失败或异常处理可以用 then(null, reject) 来接受之外也可以\n使用 catch ，并且建议在每个链式 promise 调用结尾保证总有一个 catch() 来保\n证异常能被捕获到并得到处理\n  Promise.all(iterable) 所有的 promise resolved 才能 resolved\n  Promise.race(iterable) 所有的 promise 之间处于竞争关系，只要有一个首先\nsettled 之后该 race() 就结束，状态由第一个 settled 的 promise 决定。\n  Promise 链式调用，中每一个 then() 中都会默认返回一个新的 promise 给后面的\nthen() 也可以显示返回，如果显示返回的是一个普通值或表达式则会被封装成一个\npromise，如果是一个 promise 则会被原样返回。\n  结合 promise 和 generator 将让异步任务执行器更加容易\n  es8 中的 async…await 语法糖将让异步任务执行更加简易\n  Proxies 和 Reflection Api ECMAScript 5 和 ECMAScript 6 出现的目的都是为了简化 JavaScript 的使用，在\nECMAScript 5 之前在 JavaScript 环境中包含一些拥有不能枚举(nonenumerable)和不能写\n入(nonwritable)的对象属性，但是开发者却不能给自己声明的对象添加不能枚举和不能写\n入的属性，因为并没有任务接口能使用，知道 ECMAScript 5 出现之后增加了\nObject.defineProperty() 方法，可以让开发者为自己的对象属性修改其描述符对象，从\n而增加不可写或不可枚举的属性等。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  const obj = {} Object.defineProperty(obj, \u0026#39;count\u0026#39;, { value: \u0026#39;100\u0026#39;, enumerable: false, // 不可枚举  writable: false, // 不可赋值改变  configurable: true, }) obj.count = 3 console.log(obj.count, \u0026#39;count\u0026#39;) for (let prop in obj) { console.log(prop, \u0026#39;prop\u0026#39;) }   +RESULTS:\n100 count   输出 100 表示 obj.count = 3 并没有生效 for..in 中没有输出，说明 count 不能被枚举  ECMAScript 6 中赋予了开发者更多干涉 JavaScript 引擎工作的能力，它通过 proxies\n将一些内部操作暴露出来， proxies 是一些包可以中断或拦截引擎的一些操作包装器。\n这一章节将开始于 proxies 相关的知识和使用。\n数组问题(Array Problem) 比如，长度的问题，我们可以通过控制参数组的长度来达到控制数组内容的目的。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14  let colors = [\u0026#39;red\u0026#39;, \u0026#39;green\u0026#39;, \u0026#39;blue\u0026#39;] console.log(colors.length); // 3  colors[3] = \u0026#39;black\u0026#39; console.log(colors.length); // 4 console.log(colors[3]) // \u0026#39;black\u0026#39;  colors.length = 2; // 相当于截取了数组，后面的元素将被丢弃 console.log(colors.length); // 2 console.log(colors[3]); // undefined console.log(colors[2]); // undefined console.log(colors[1]); // \u0026#39;green\u0026#39;   +RESULTS:\n3 4 black 2 undefined undefined green   这一非标准的行为也是为什么数组在 ECMAScript 6 中被视为异类了。\n 什么是 Proxies 和 Reflection 我们可以通过 new Proxy() 创建一个 proxy 用来代替另一个对象(假设叫：\ntarget)使用。这个 proxy 会虚拟化这个 target 以至于 proxy 和 target 能好似一个\n东西一样被使用。\n就相当于给 target 生了个孪生兄弟，用法功能都差不多，甚至可以当做是一个人。\nProxies 允许你可以中断低级对象操作(偏底层的操作, low-level object operations)，\n这些操作可以被 trap 函数(一个可响应特定操作的函数)中断\nRelect 对象，是一组方法的集合，为一些低级操作提供了默认行为(这些行为可以通过\nproxies 重写)。对于每一个 proxy trap 都有一个 Relect 方法与之对应，且这些方法\n和他们的 proxy traps 有一样的名字且传递了一样的参数。\n下表列出了一些默认行为和 proxy trap 的对应关系：\n   proxy trap 重写的行为 默认行为     get 13.3.3 读取一个对象属性值 Reflect.get()   set 13.3.2 设置属性值 Reflect.set()   has 是否包含 Reflect.has()   deleteProperty delete obj.name 删除对象属性操作 Reflect.deleteProperty()   getPrototypeOf Object.getPrototypeOf() Reflect.getPrototypeOf()   setPrototypeOf Object.setPrototypeOf() Reflect.setPrototypeOf()   isExtensible Object.isExtensible() Reflect.isExtensible()   preventExtensions Object.preventExtensions() Reflect.preventExtensions()   getOwnPropertyDescriptor Object.getOwnPropertyDescriptor() Reflect.getOwnPropertyDescriptor()   defineProperty Object.definePropery() Reflect.definePropery()   ownKeys Object.keys(), Object.getOwnPropertyNames(), Object.getOwnPropertySymbols() Reflect.ownKeys()   apply fn.apply(thisArg, argsArr) Reflect.apply()   construct new Ctor() Reflect.construct()    每一个 trap 重写了 JavaScript 对象的内置行为，允许中断和修改这些行为。如果依然需\n要用到内置行为，可以使用对应的 reflection api 方法。\n 原来 ECMAScript 6 规范中有一个叫 enumerate 的 trap，被设计用来改变 for...in\n和 Object.keys() 枚举对象属性的行为。但是在 ECMAScript 7 中随即被移除，原因是\n实现起来比较困难，因此以后都不会有 enumerate 了。\n 使用 Proxies 和 Reflection Proxy 简单应用 使用 new Proxy(target, handler) 创建一个 proxy 时候需要传递两个参数：\n target 需要被代理的那个对象 handler 一个定义了一个或多个 proxy traps 的对象  proxy 将使用所有操作的默认行为，除非在 handler 中定义了对应的 proxy trap。\n1 2 3 4 5 6 7 8 9 10 11 12  let target = {} let proxy = new Proxy(target, {}) proxy.name = \u0026#39;proxy\u0026#39; console.log(proxy.name); // \u0026#39;proxy\u0026#39; console.log(target.name); // \u0026#39;proxy\u0026#39;  target.name = \u0026#39;target\u0026#39;; console.log(proxy.name); // \u0026#39;target\u0026#39; console.log(target.name); // \u0026#39;target\u0026#39;   +RESULTS: target 和 proxy 对象之间互相影响\nproxy proxy target target  在这个例子上， proxy 代理了 target 对象的所有默认行为(因为传入了一个空的 {} 对\n象给 Proxy() )。也就是说对 target 和 proxy 对象的所有行为都会在两个对象上有所\n体现，形同操作对方本身一样。\n像这个简单的 proxy 例子，代理了 target 但是却没有提供任何 traps，这并没有任何意义\n用 set(trapTarget, key, value, receiver) trap 验证属性 假设你想创建一个属性值必须是数值类型的对象，这意味着每一个新增的属性必须要有一个\n验证机制去确保它是一个数值类型，否则就要抛出异常。\n为了实现这个功能，我们可以使用 proxy 的 set trap 去重写赋值的默认行为。\nset trap 接受四个参数：\n trapTarget 那个被代理的对象 target，也是即将被新增属性的那个对象 key 新增属性的 key 值(字符串或符号类型) value 新增属性的值，将要被检测的内容 receiver 该操作的目标对象(一般就是 target 的代理实例 proxy)  set =\u0026gt; 赋值操作 =\u0026gt; Reflect.set()\n在“什么是 Proxies 和 Reflection”一节就将过 proxy trap 和 reflect 对应的操作函数\n名称和参数都是一模一样的，也就是说 Reflect.set() 也将接受 set trap 一样的四\n个参数： trapTarget, key, value, receiver 且含义一样。\nReflect.set() 的返回值为 true/false ，成功为 true 失败为 false，且在 set\ntrap 中也应该要返回一个 boolean 值表示该 trap 是否成功或失败了，一般直接返回\nReflect.set() 的返回值即可。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27  let target = { name: \u0026#39;target\u0026#39; } let proxy = new Proxy(target, { set(trapTarget, key, value, receiver) { console.log(trapTarget === target, \u0026#39;trapTarget is target\u0026#39;) if (!trapTarget.hasOwnProperty(key)) { if (isNaN(value)) { throw new TypeError(\u0026#39;属性必须是 `number` 类型！\u0026#39;) } } return Reflect.set(trapTarget, key, value, receiver) } }) // 添加一个属性 proxy.count = 1 console.log(proxy.count) console.log(target.count) proxy.name = \u0026#39;proxy\u0026#39; console.log(proxy.name) console.log(target.name)   +RESULTS:\ntrue 'trapTarget is target' 1 1 true 'trapTarget is target' proxy proxy undefined  如上面的例子，操作 proxy 就像直接操作 target 一样，所有的操作都能在 target 上面\n有所体现，但是使用 proxy \u0026amp; reflect 和直接操作 target 的好处是，允许我们拦截这一\n底层操作，从而对其进行一些额外的处理。\nget(trapTarget, key, receiver) trap 获取对象属性值的操作代理。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20  let proxy = new Proxy({}, { get(trapTarget, key, receiver) { if (!(key in receiver)) { throw new TypeError(\u0026#39;错误：属性 \u0026#39; + key + \u0026#39; 不存在。\u0026#39;) } return Reflect.get(trapTarget, key, receiver) } }) // proxy.name = \u0026#39;proxy\u0026#39; try { console.log(proxy.name) } catch (e) { console.log(e.message) } proxy.name = \u0026#39;proxy\u0026#39; console.log(proxy.name)   +RESULTS:\n错误：属性 name 不存在。 proxy  has(trapTarget, key) trap   trapTarget 被代理的那个对象(比如： target) key 被检测的属性的名称  in 操作符可以用来检测一个属性是否存在于指定对象或者它的原型上，如果能找到返回 true\n1 2 3 4 5 6  let target = { value: 42 } console.log(\u0026#39;value\u0026#39; in target) console.log(\u0026#39;toString\u0026#39; in target)   +RESULTS:\ntrue true  in 操作符在 Proxy 中对应的是 has -\u0026gt; Reflect.has(trapTarget, key) 接口。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14  let target = { name: \u0026#39;target\u0026#39;, value: 42 } let proxy = new Proxy(target, { has(trapTarget, key) { return key === \u0026#39;value\u0026#39; ? false : Reflect.has(trapTarget, key) } }) console.log(\u0026#39;value\u0026#39; in proxy) console.log(\u0026#39;name\u0026#39; in proxy) console.log(\u0026#39;toString\u0026#39; in proxy)   +RESULTS:\nfalse true true  deleteProperty(trapTarget, key) trap 删除对象属性(delete 关键词的使用)  delete 操作符会将对象中的属性从这个对象中移除，如果成功返回 true 否则返回\nfalse ，在严格模式下试图删除一个 non-configurable 的属性会报错，非严格模式下\n会返回 false 。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20  let target = { name: \u0026#39;target\u0026#39;, value: 42 } Object.defineProperty(target, \u0026#39;name\u0026#39;, { configurable: false }) console.log(\u0026#39;value\u0026#39; in target) // true  let res1 = delete target.value console.log(res1) // true console.log(\u0026#39;value\u0026#39; in target) // false  let res2 = delete target.name // error 严格模式 console.log(res2, \u0026#34;严格模式\u0026#34;) console.log(\u0026#39;name\u0026#39; in target, \u0026#34;删除失败\u0026#34;) // true 删除失败   通过 proxy 的 deleteProperty -\u0026gt; deleteProperty(trapTarget, key) 代理 delete\n行为：\n trapTarget 被代理的对象 key 被删除的属性名称  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20  let target = { name: \u0026#39;target\u0026#39;, value: 42 } let proxy = new Proxy(target, { deleteProperty(trapTarget, key) { return key === \u0026#39;value\u0026#39; ? false : Reflect.deleteProperty(trapTarget, key) } }) console.log(\u0026#39;value\u0026#39; in proxy) let res1 = delete proxy.value console.log(res1) console.log(\u0026#39;value\u0026#39; in proxy, \u0026#39;删除失败\u0026#39;) // true, 删除失败  console.log(\u0026#39;name\u0026#39; in proxy) // true console.log(delete proxy.name, \u0026#39;name\u0026#39; in proxy) // true false   +RESULTS:\ntrue false true '删除失败' true true false  原型代理Traps(Prototype Proxy Traps) 与原型有关的 traps :\n getPrototypeOf(trapTarget) -\u0026gt; Object.getPrototypeOf(trapTarget) -\u0026gt;\nReflect.getPrototypeOf(trapTarget) setPrototypeOf(trapTarget, proto) -\u0026gt; Object.setPrototypeOf(trapTarget, proto) -\u0026gt;\nReflect.setPrototypeOf(trapTarget, proto)  原型代理 Traps 工作原理 在使用原型 trap 的时候有一些严格的规定：\n getPrototypeOf trap 必须返回一个对象或者 null ,如果是其他值就会发生运行时\n错误 setPrototypeOf 在失败的时候必须返回 false ，如果不是那么默认会被当做成功\n处理  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24  let target = {} let proxy = new Proxy(target, { getPrototypeOf(trapTarget) { return null }, setPrototypeOf(trapTarget, proto) { return false } }) let targetProto = Object.getPrototypeOf(target) let proxyProto = Object.getPrototypeOf(proxy) console.log(targetProto === Object.prototype) // true console.log(proxyProto === Object.prototype) // false console.log(proxyProto) // null  Object.setPrototypeOf(target, {}) // succeed try { Object.setPrototypeOf(proxy, {}) // error } catch (error) { console.log(error.message) }   +RESULTS:\ntrue false null 'setPrototypeOf' on proxy: trap returned falsish  使用默认行为(Reflect.get/setPrototypeOf())\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25  let target = {} let proxy = new Proxy(target, { getPrototypeOf(trapTarget) { return Reflect.getPrototypeOf(trapTarget) }, setPrototypeOf(trapTarget, proto) { return Reflect.setPrototypeOf(trapTarget, proto) } }) let targetProto = Object.getPrototypeOf(target) let proxyProto = Object.getPrototypeOf(proxy) console.log(targetProto === Object.prototype) // true console.log(proxyProto === Object.prototype) // false console.log(proxyProto) // null  Object.setPrototypeOf(target, {}) // succeed try { Object.setPrototypeOf(proxy, {}) // error } catch (error) { console.log(error.message) }   +RESULTS:\ntrue true {}  为什么有两种方法?(Reflect 和 Object 上都有 get/setPrototypeOf) 相同点 ：\n最终都是操作的内部属性： [[GetPrototypeOf] ] 和 [[setPrototypeOf] ]\n不同点 :\n    getPrototypeOf setPrototypeOf     Object 参数会被强转成对应的对象 失败抛异常，成功返回 trapTarget   Reflect 参数只能是对象，否则报错 失败返回 false , 成功返回 true         参数不同点：\n1 2 3 4 5 6 7 8 9  let res = Object.getPrototypeOf(1) console.log(res === Number.prototype) // true  try { Reflect.getPrototypeOf(1) } catch (e) { console.log(e.message) }   +RESULTS:\ntrue Reflect.getPrototypeOf called on non-object  返回值不同点：\n1 2 3 4 5 6 7 8 9  let target1 = {} let res1 = Object.setPrototypeOf(target1, {}) console.log(res1 === target1) // true  let target2 = {} let res2 = Reflect.setPrototypeOf(target2, {}) console.log(res2 === target2) // false console.log(res2) // true   +RESULTS:\ntrue false true  对象扩展性 Traps(Object Extensibility Traps) 在 ECMAScript 5 中新增了两个方法： Object.preventExtensions() 和\nObject.isExtensible() 用来阻止对象被扩展和检测对象的扩展性，这两个 api 都只\n有一个参数 trapTarget 表示作用的对象，返回值都是 boolean 前者表示阻止是否\n成功，后者表示对象是否可扩展，在 proxy-reflect 中也有相应的 api 与之对应，且\n参数和返回值均一样。\nObject.preventExtensions() 阻止给对象增加属性：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22  let target = { value: 42 } let res = Object.isExtensible(target) target.name = \u0026#39;xxx\u0026#39; console.log(res, target) // true  Object.preventExtensions(target) target.age = \u0026#39;100\u0026#39; try { Object.defineProperty(target, \u0026#39;height\u0026#39;, { value: \u0026#39;166\u0026#39; }) } catch(e) { console.log(e.message) } res = Object.isExtensible(target) console.log(res, target) // false   +RESULTS: age 并没有被添加, height 添加报错\ntrue { value: 42, name: 'xxx' } Cannot define property height, object is not extensible false { value: 42, name: 'xxx' } undefined  代理：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23  let target = {} let proxy = new Proxy(target, { isExtensible(trapTarget) { console.log(\u0026#39;is extensible ...\u0026#39;) return Reflect.isExtensible(trapTarget) }, preventExtensions(trapTarget) { console.log(\u0026#39;preventing extension\u0026#39;) return Reflect.preventExtensions(trapTarget) } }) console.log(Object.isExtensible(target), \u0026#39;before\u0026#39;) // true console.log(Object.isExtensible(proxy), \u0026#39;before\u0026#39;) // true  Object.preventExtensions(proxy) console.log(Object.isExtensible(target), \u0026#39;after\u0026#39;) // false console.log(Object.isExtensible(proxy), \u0026#39;after\u0026#39;) // false    +RESULTS: 因为使用了 Reflect.xxx 所以作用在 proxy 上的操作也将体现在 target 上\ntrue 'before' is extensible ... true 'before' preventing extension false 'after' is extensible ... false 'after'  如果总是允许代理对象能被扩展，只需要在代理的 preventExtensions trap 中直接返回\nfalse 就行了，但是并不影响 target 除非调用了 reflect 。\nReflect 和 Object 上的区别：\n    isExtensible preventExtensions     Reflect 参数非对象，触发异常 参数非对象，触发异常   Object 参数非对象，总是返回 false 参数非对象，会返回该参数自身    1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18  let res1 = Object.isExtensible(1) console.log(res1) // false  try { Reflect.isExtensible(1) } catch(e) { console.log(e.message) } let res2 = Object.preventExtensions(1) console.log(res2) // true  try { Reflect.preventExtensions(1) } catch(e) { console.log(e.message) }   +RESULTS:\nfalse Reflect.isExtensible called on non-object 1 Reflect.preventExtensions called on non-object  属性描述符 Traps(Property Descriptor Traps) ECMAScript 5 更新中包含了可以通过 Object.defineProperty(obj, key, descObj) 自\n定义属性的功能，这让开发者可以自己定义一些特定功能的对象属性，比如：只读、只写、\n或不可枚举等等特性，然后可以通过 Object.getOwnPropertyDescriptor() 来获取对象\n属性的描述符对象。\nObject.defineProperty() 详细使用\n属性描述符代理 在 proxy-reflect 中对应着：\n defineProperty -\u0026gt; Reflect.defineProperty(trapTarget, key, descriptor) getOwnPropertyDescriptor -\u0026gt; Reflect.getOwnPropertyDescriptor(trapTarget, key)  返回值：\ndefineProperty 成功返回 true, 失败返回 false\ngetOwnPropertyDescriptor 成功返回描述符\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21  let target = {} let proxy = new Proxy(target, { definePropery(trapTarget, key, descriptor) { return Reflect.defineProperty(trapTarget, key, descriptor) }, getOwnPropertyDescriptor(trapTarget, key) { return Reflect.getOwnPropertyDescriptor(trapTarget, key) } }) Object.defineProperty(proxy, \u0026#39;name\u0026#39;, { value: \u0026#39;proxy\u0026#39; }) console.log(proxy.name) // \u0026#39;proxy\u0026#39;  let descriptor = Object.getOwnPropertyDescriptor(proxy, \u0026#39;name\u0026#39;) console.log(descriptor.value) // \u0026#39;proxy\u0026#39;   +RESULTS:\nproxy proxy  阻止给对象扩展符号属性：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27  let target = {} let proxy = new Proxy(target, { defineProperty(trapTarget, key, descriptor) { if (typeof key === \u0026#39;symbol\u0026#39;) { return false; } return Reflect.defineProperty(trapTarget, key, descriptor) } }) Object.defineProperty(proxy, \u0026#39;name\u0026#39;, { value: \u0026#39;proxy\u0026#39; }) console.log(proxy.name) // \u0026#39;proxy\u0026#39; let nameSymbol = Symbol(\u0026#39;name\u0026#39;); // error try { Object.defineProperty(proxy, nameSymbol, { value: \u0026#39;symbol-proxy\u0026#39; }) } catch(e) { console.log(e.message) }   +RESULTS:\nproxy 'defineProperty' on proxy: trap returned falsish for property 'Symbol(name)'  因为 Object.defineProperty() 返回 false 的话会触发异常表示扩展失败。\n如果想要扩展失败隐藏异常，可以在 trap 中不满足条件的时候也让它返回 true\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23  let target = {} let proxy = new Proxy(target, { defineProperty(trapTarget, key, descriptor) { if (typeof key === \u0026#39;symbol\u0026#39;) { return true; } return Reflect.defineProperty(trapTarget, key, descriptor) } }) Object.defineProperty(proxy, \u0026#39;name\u0026#39;, { value: \u0026#39;proxy\u0026#39; }) console.log(proxy.name) // \u0026#39;proxy\u0026#39; let nameSymbol = Symbol(\u0026#39;name\u0026#39;); // error Object.defineProperty(proxy, nameSymbol, { value: \u0026#39;symbol-proxy\u0026#39; })   +RESULTS: 运行结果无错误提示，因为 key === 'symbol' 条件中依旧返回了 true\nproxy  标准中失败抛异常：  描述符对象约束(Descriptor Object Restrictions) 在上一节中描述了属性描述符代理的使用，在使用过程中对描述符对象的定义有一定的约束\n条件，比如 defineProperty(trapTarget, key, descriptor) 第三个参数就并非是完整\n的传入的描述符对象 Object.defineProperty(obj, key, descObj) 。\n在 trap 的 descriptor 会忽略掉除下面属性以外的属性,\n enumerable configurable value writable get set  除了上面 6 个属性之外，其他的属性都会被忽略掉，即使你调用\nObject.defineProperty 的时候传入了更多的属性。\n1 2 3 4 5 6 7 8 9 10 11 12 13  let proxy = new Proxy({}, { defineProperty(trapTarget, key, descriptor) { console.log(descriptor.value) // \u0026#39;proxy\u0026#39;  console.log(descriptor.name) // undefined  return Reflect.defineProperty(trapTarget, key, descriptor); } }) Object.defineProperty(proxy, \u0026#39;name\u0026#39;, { value: \u0026#39;proxy\u0026#39;, name: \u0026#39;custom\u0026#39; })   +RESULTS: 结果显示实际传入的 {value: 'proxy', name: 'custom'} 在 trap 中并没有\nname 。\nproxy undefined  这是因为 trap 中的 descriptor 参数并非是 {value: 'proxy', name: 'custom'} 对\n象的引用，而是一个全新的对象，只会包含标准的 6 个属性值，其他的均不会收藏。\n同样， Reflect.defineProperty() 也一样会忽略掉非标准的属性。\n在 getOwnPropertyDescriptor() 方法中也有此类约束，这个方法要求它的返回值必须是\nnull, undefined 或一个对象，如果是一个对象的时候，就会遵循这个约束，即返回的\n对象中只能包含标准的属性(enumerable, configurable, value, writable,\nget, set)\n1 2 3 4 5 6 7 8 9 10 11 12 13  let proxy = new Proxy({}, { getOwnPropertyDescriptor(trapTarget, key) { return { name: \u0026#39;proxy\u0026#39; } } }) try { let descriptor = Object.getOwnPropertyDescriptor(proxy, \u0026#39;name\u0026#39;) } catch(e) { console.log(e) }   +RESULTS:\nTypeError: 'getOwnPropertyDescriptor' on proxy: trap reported non-configurability for property 'name' which is either non-existant or configurable in the proxy target  重复的描述符方法 与之前描述的一样在 Object 和 Reflect 都同时有 defineProperty() 和\ngetOwnPropertyDescriptor() 方法，但双方都有一点差异。\n Object.defineProperty(target) 返回 target 对象 Reflect.defineProperty(trapTarget, key, descriptor) 返回 true 或 false\n表示成功或失败  1 2 3 4 5 6 7 8 9 10 11 12  let target = {} let res1 = Object.defineProperty(target, \u0026#39;name\u0026#39;, { value: \u0026#39;target\u0026#39;, configurable: true }) console.log(res1 === target) // true  let res2 = Reflect.defineProperty(target, \u0026#39;name\u0026#39;, { value: \u0026#39;reflect\u0026#39; }) console.log(res2) // true   +RESULTS:\ntrue true   Object.getOwnPropertyDescriptor(obj, key) 如果 obj 是原始类型会强制转换成\n对象后再获取描述符对象，没有就返回 undefined Reflect.getOwnPropertyDescriptor(obj, key) 和上面的不一样，如果为非对象类型\n则会触发异常。  1 2 3 4 5 6 7 8  let res1 = Object.getOwnPropertyDescriptor(2, \u0026#39;name\u0026#39;) console.log(res1) // undefined  try { let res2 = Reflect.getOwnPropertyDescriptor(2, \u0026#39;name\u0026#39;) } catch(e) { console.log(e.message) }   +RESULTS:\nundefined Reflect.getOwnPropertyDescriptor called on non-object  ownKeys Trap ownKeys -\u0026gt; Reflect.ownKeys(trapTarget)\n这个 trap 的用途是用来中断 [[OwnPropertyKeys] ] 的操作，然后允许在 trap 里面重\n写“返回一个值的数组”的动作。\n有四个内置方法用到这个数组(ownKeys)\n Object.keys() 会过滤掉 ownKeys 中的符号类型 key Object.getOwnPropertyNames() 会过滤掉 ownKeys 中的符号类型 key Object.getOwnPropertySymbols() 会过滤掉 ownKeys 中的字符串类型 key Object.assign() 用 ownKeys 来决定哪些属性会被拷贝，字符串和符号 key 都会用\n到  对应默认行为的 trap 是： Reflect.ownKeys() 返回一个所有自身属性的 key，包含符\n号属性。\n接受一个对象参数，且返回数组或类数组对象否则会报错，使用 ownKeys trap 可以让我们\n在对该对象使用诸如 Object.keys(), Object.getOwnPropertyNames(), 等等这些方法\n的时候去过滤一些我们不想让人获取到的一些属性，比如以下划线开头的内部方法(一般使\n用下划线开头的放表示内部方法)。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26  let proxy = new Proxy({}, { ownKeys(trapTarget) { return Reflect .ownKeys(trapTarget) // 过滤掉 _xxx() {} 的方法  .filter(key =\u0026gt; typeof key !== \u0026#39;string\u0026#39; || key[0] !== \u0026#39;_\u0026#39;) } }) let nameSymbol = Symbol(\u0026#39;name\u0026#39;) proxy.name = \u0026#39;proxy\u0026#39; proxy._name = \u0026#39;private\u0026#39; proxy[nameSymbol] = \u0026#39;symbol\u0026#39; let names = Object.getOwnPropertyNames(proxy), // 会过滤符号key  keys = Object.keys(proxy), // 会过滤符号 key  symbols = Object.getOwnPropertySymbols(proxy) console.log(names.length) // 1 console.log(names[0]) // \u0026#39;name\u0026#39;  console.log(keys.length) // 1 console.log(keys[0]) // \u0026#39;name\u0026#39;  console.log(symbols.length) // 1 console.log(symbols[0]) // \u0026#34;Symbol(name)\u0026#34;   +RESULTS: 前两个为 1 是因为 Object.getOwnPropertyNames() 和 Object.keys() 默\n认会过滤掉符号属性。\n1 name 1 name 1 Symbol(name)   ownKeys 对 for-in 循环中也有效，它会调用 ownKeys trap 来决定哪些键可以被遍历。\n 函数代理(apply和construct traps) 在所有的 traps 中，只有 apply 和 construct trap 必须要求 trapTarget 是一个\n函数。\n这两个 trap 分别对应 [[Call] ] 和 [[Construct] ] 低级操作，而这两个内部属性\n对应的是函数的两种调用方式(1. 函数方式调用，2. 通过 new 调用)，通过 apply 和\nconstruct 这两个 trap 可以拦截这两种调用操作。\napply -\u0026gt; Reflect.apply(trapTarget, thisArg, argumentsList)\nconstruct -\u0026gt; Reflect.construct(trapTarget, argumentsList[, newTarget])\n trapTarget 被代理的那个函数对象 thisArg 调用 apply 时指定的作用域对象 argumentsList 传递给函数的参数列表 newTarget 指向函数内部 new.target 的值  示例：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25  let target = function() { return 42 } let proxy = new Proxy(target, { apply(trapTarget, thisArg, argList) { console.log(thisArg, \u0026#39;applied\u0026#39;) return Reflect.apply(trapTarget, thisArg, argList) }, construct(trapTarget, argList, newTarget) { console.log(newTarget, \u0026#39;newTarget\u0026#39;) return Reflect.construct(trapTarget, argList) } }) console.log(typeof proxy) // function console.log(proxy()) // 42  var ins = new proxy() console.log(ins instanceof proxy) console.log(ins instanceof target) proxy.apply({a:1}) target.apply({a:1})   +RESULTS: apply 和 construct 分别代理了函数的两种不用使用方式(apply 和 new)。\nfunction undefined 'applied' 42 [Function: target] 'newTarget' true true { a: 1 } 'applied' undefined  从结果可知 newTarget 参数指向的是被代理的那个原始对象 trapTarget 。\n下面将介绍如何使用这两个代理做一些事情，比如验证参数或验证函数调用方式。\n验证函数参数 检查函数参数的合法性，或限定函数只能以普通方式调用不能通过 new 调用。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33  function sum(...values) { return values.reduce((prev, next) =\u0026gt; prev + next, 0) } let sumProxy = new Proxy(sum, { apply(trapTarget, thisArg, argList) { argList.forEach(arg =\u0026gt; { if (typeof arg !== \u0026#39;number\u0026#39;) { throw new TypeError(\u0026#39;所有参数必须是数字。\u0026#39;) } }) return Reflect.apply(trapTarget, thisArg, argList) }, construct(trapTarget, argList) { throw new TypeError(\u0026#39;这个函数不能被 new 实例化。\u0026#39;) } }) console.log(sumProxy(1, 2, 3, 4)) try { console.log(sumProxy(1, \u0026#39;2\u0026#39;, 3, 4)) } catch(e) { console.log(e.message) } try { let res = new sumProxy() } catch(e) { console.log(e.message) }   +RESULTS:\n10 所有参数必须是数字。 这个函数不能被 new 实例化。  上面例子也可以反过来只允许 new 实例化，不能被直接调用。\n无 new 直接调用构造函数检测 根据 construct trap 的第三个可选参数 newTarget 这个值指向的是函数的\nnew.target 值(new.target)。\n这个值由两种值： 1. 函数调用时值为 undefined , 2. new 实例化时为当前构造函数\n本身。\n使用 apply 和 construct 两个 trap 结合使用，可以做到让一个函数无 new 情况下直\n接调用构造函数就可以实例化：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17  function Nums(...values) { if (new.target === \u0026#39;undefined\u0026#39;) { throw new TypeError(\u0026#39;该函数必须通过 `new` 调用。\u0026#39;) } this.values = values } let NumsProxy = new Proxy(Nums, { apply: function(trapTarget, thisArg, argList) { console.log(argList.toString()) return Reflect.construct(trapTarget, argList) } }) let ins = NumsProxy(1, 2, 3, 4) console.log(ins.values)   +RESULTS:\n1,2,3,4 [ 1, 2, 3, 4 ]  重写抽象基类(Abstract Base Class)构造函数 让一个类智能被继承，不能被实例化，可以通过构造函数内部的 new.target 来检测。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22  class AbstractNums { constructor(...values) { if (new.target === AbstractNums) { throw new TypeError(\u0026#39;该类不能被实例化，只能被继承。\u0026#39;) } this.values = values } } class Nums extends AbstractNums { } let ins = new Nums(1, 2, 3, 4) console.log(ins.values.toString()) try { new AbstractNums(1, 2, 3, 4) } catch(e) { console.log(e.message) }   +RESULTS:\n1,2,3,4 该类不能被实例化，只能被继承。  通过代理实现屏蔽这里的异常，即让 AbstractNums 构造函数中的检测失败。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22  class AbstractNums { construct(...values) { if (new.target === AbstractNums) { throw new TypeError(\u0026#39;该类不能被实例化，只能被继承。\u0026#39;) } this.values = values console.log(this.values.toString(), \u0026#39;this.values\u0026#39;) } } let AbstractNumsProxy = new Proxy(AbstractNums, { construct: function(trapTarget, argList) { console.log(argList.toString(), \u0026#39;proxy\u0026#39;); // 因为第三个参数即 new.target 值，这里第三个参数传递个空函数  return Reflect.construct(trapTarget, argList, function() {}) } }) /// 这里就不会报错了 let ins = new AbstractNumsProxy(1, 2, 3, 4) console.log(ins.values, \u0026#39;eee\u0026#39;)   可调用的类的构造函数 类的使用，在代理出现之前是无法直接调用的，因为其内部的 [[Call] ] 属性被绑定到\n异常上，只要发生调用就会触发异常。\n但是有了代理之后，我们可以通过代理去实现一个可直接调用的类去创建一个实例，实际上\n还是代理里面去创建了实例。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  class Person { constructor(name) { this.name = name } } let PersonProxy = new Proxy(Person, { apply: function(trapTarget, thisArg, argList) { return new trapTarget(...argList) } }) let me = PersonProxy(\u0026#39;xxx\u0026#39;) console.log(me.name) // xxx console.log(me instanceof Person) // true console.log(me instanceof PersonProxy) // true   +RESULTS:\nxxx true true  可撤销的代理(Revocable) 通常情况下，代理一旦被创建就无法与 target 解绑，但是有一些特殊情况，比如代理可\n能不再需要了，需要将其解绑掉。\n在这之前通过 new Proxy() 创建的都是不可撤销的代理，如果需要创建可撤销的代理得\n使用 Proxy.revocable() 接口。\n参数和 Proxy() 一样，需要一个被代理对象和一个代理 traps 对象：\nProxy.revocable(target, trapObj)\n调用之后的返回值是一个包含两个属性的对象：\n proxy 一个可被撤销的代理 revoke 用来撤销代理的函数  任何时候执行了 revoke() 那就表示 proxy 不再可用，任意试图去通过 proxy trap\n去中断低级操作的行为都将触发异常，因为 proxy 已经被撤销了没法用了。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  let target = { name: \u0026#39;target\u0026#39; } let { proxy, revoke } = Proxy.revocable(target, {}) console.log(proxy.name) revoke(); try { console.log(proxy.name) } catch(e) { console.log(e.message) }   +RESULTS:\ntarget Cannot perform 'get' on a proxy that has been revoked  解决数组问题 proxy-reflect 的出现同样赋予了开发者跟踪数组变化的能力，比如数组长度变化可以做一\n些特殊处理。\n对数组的访问和设置，可以使用之前讲过的 get-trap(13.3.3) 和 set-trap(13.3.2)，\n用来监听数组的访问、长度或内容的变化。\n监听数组长度的变化 通过数组对象的代理，可以监听数组对象长度或值的变化，从而触发一些自定义的行为。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37  const toUnit32 = v =\u0026gt; Math.floor(Math.abs(Number(v))) % Math.pow(2, 32) const isArrayIndex = key =\u0026gt; { let numericKey = toUnit32(key) return String(numericKey) == key \u0026amp;\u0026amp; numericKey \u0026lt; (Math.pow(2, 32) - 1) } function createArray(length = 0) { return new Proxy({ length }, { set(trapTarget, key, value) { let currLen = Reflect.get(trapTarget, \u0026#39;length\u0026#39;) if (isArrayIndex(key)) { let numericKey = Number(key) if (numericKey \u0026gt;= currLen) { Reflect.set(trapTarget, \u0026#39;length\u0026#39;, numericKey + 1) } } return Reflect.set(trapTarget, key, value) } }) } let colors = createArray(3) console.log(colors.length) colors[0] = \u0026#39;red\u0026#39; colors[1] = \u0026#39;green\u0026#39; colors[2] = \u0026#39;blue\u0026#39; console.log(colors.length) colors[3] = \u0026#39;black\u0026#39; console.log(colors.length) console.log(colors[3])   +RESULTS:\n3 3 4 black undefined  删除数组元素 在以往，要删除数组元素(缩减数组)，可以通过数组长度的设置来达到目的，数组多余的元素会被抛弃掉。\n1 2 3 4 5 6  let nums = [1, 2, 3] console.log(nums.toString()) nums.length = 1 console.log(nums.toString()) nums.length = 3 console.log(nums.toString())   +RESULTS:\n1,2,3 1 1,,  使用代理也可以达到这个目的，并且可以监听数组的变化：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46  const toUnit32 = v =\u0026gt; Math.floor(Math.abs(Number(v))) % Math.pow(2, 32) const isArrayIndex = key =\u0026gt; { let numericKey = toUnit32(key) return String(numericKey) == key \u0026amp;\u0026amp; numericKey \u0026lt; (Math.pow(2, 32) - 1) } function createArray(length = 0) { return new Proxy({ length }, { set(trapTarget, key, value) { let currLen = Reflect.get(trapTarget, \u0026#39;length\u0026#39;) if (isArrayIndex(key)) { let numericKey = Number(key) if (numericKey \u0026gt;= currLen) { Reflect.set(trapTarget, \u0026#39;length\u0026#39;, numericKey + 1) } } else if (key == \u0026#39;length\u0026#39;) { if (value \u0026lt; currLen) { for (let i = currLen - 1; i \u0026gt;= value; i--) { Reflect.deleteProperty(trapTarget, i) } } } return Reflect.set(trapTarget, key, value) } }) } let colors = createArray(3) console.log(colors.length) colors[0] = \u0026#39;red\u0026#39; colors[1] = \u0026#39;green\u0026#39; colors[2] = \u0026#39;blue\u0026#39; colors[3] = \u0026#39;black\u0026#39; console.log(colors.length) colors.length = 2 console.log(colors.length) console.log(colors[3]) // undefined console.log(colors[2]) // undefined console.log(colors[1]) // \u0026#39;green\u0026#39; console.log(colors[0]) // \u0026#39;black\u0026#39;   +RESULTS:\n3 4 2 undefined undefined green red  上面代码中实现了两种变化：\n key 为数组下标，即数组元素值的变化，会将长度基于它的索引加 1 length 属性值的变化，如果新的长度值小于原有的元素长度，多余的元素会被删除掉  实现数组类 最简单的实现方式是按照普通类定义然后在构造函数中返回一个代理。\n1 2 3 4 5 6 7 8  class Thing { constructor() { return new Proxy(this, {}) } } let myTh = new Thing() console.log(myTh instanceof Thing) // true   返回的 new Proxy(this, {}) 有两个参数：\n this 为 Thing 类的实例 {} 为 Thing 实例的代理 trap 对象  myTh 是 Thing 实例的代理对象。\n这里的实现和“删除数组元素13.10.2”一节中基本一样，不同点在于 new Proxy() 在类的构造函数中返回。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49  const toUnit32 = v =\u0026gt; Math.floor(Math.abs(Number(v))) % Math.pow(2, 32) const isArrayIndex = key =\u0026gt; { let numericKey = toUnit32(key) return String(numericKey) == key \u0026amp;\u0026amp; numericKey \u0026lt; (Math.pow(2, 32) - 1) } class MyArray { constructor(length = 0) { return new Proxy({ length }, { set(trapTarget, key, value) { let currLen = Reflect.get(trapTarget, \u0026#39;length\u0026#39;) if (isArrayIndex(key)) { let numericKey = Number(key) if (numericKey \u0026gt;= currLen) { Reflect.set(trapTarget, \u0026#39;length\u0026#39;, numericKey + 1) } } else if (key == \u0026#39;length\u0026#39;) { if (value \u0026lt; currLen) { for (let i = currLen - 1; i \u0026gt;= value; i--) { Reflect.deleteProperty(trapTarget, i) } } } return Reflect.set(trapTarget, key, value) } }) } } let colors = new MyArray(3) console.log(colors.length) colors[0] = \u0026#39;red\u0026#39; colors[1] = \u0026#39;green\u0026#39; colors[2] = \u0026#39;blue\u0026#39; colors[3] = \u0026#39;black\u0026#39; console.log(colors.length) colors.length = 2 console.log(colors.length) console.log(colors[3]) // undefined console.log(colors[2]) // undefined console.log(colors[1]) // \u0026#39;green\u0026#39; console.log(colors[0]) // \u0026#39;black\u0026#39;    +RESULTS:\n3 4 2 undefined undefined green red  Proxy 作为原型使用，从而实例共享代理 原型 get trap 原型代理在使用上有一定的限制，它只能响应原型至上的操作，比如：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  let target = {} let newTarget = Object.create(new Proxy(target, { defineProperty(trapTarget, name, descriptor) { // 正常的话这里返回 false 会触发异常  return false; } })) Object.defineProperty(newTarget, \u0026#39;name\u0026#39;, { value: \u0026#39;newTarget\u0026#39; }) console.log(newTarget.name) // \u0026#39;newTarget\u0026#39; console.log(newTarget.hasOwnProperty(\u0026#39;name\u0026#39;)) // true   +RESULTS:\nnewTarget true  上面的代理并没有响应 name 属性增加操作，因为 new Proxy() 在\nObject.create(proxy) 作为参数传递结果会是新创建对象的原型，也就是说\nnewTarget 的原型是 new Proxy() 的代理，而原型代理是没法响应对象本身的变化。\n但是在有些情况下原型代理还是很有用的，比如获取对象属性操作，因为对象的获取遵循原\n型链查找，如果对象本身找不到该属性就会往上查找原型对象，此时如果原型对象是代理的\n话就可以监听到该属性值的获取操作，从而做出响应。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17  let target = {} let thing = Object.create(new Proxy(target, { get(trapTarget, key, receiver) { throw new ReferenceError(`${key}doesn\u0026#39;t exist.`) } })) thing.name = \u0026#39;thing\u0026#39; console.log(thing.name) // \u0026#39;thing\u0026#39;  try { console.log(thing.unknown) // error } catch(e) { console.log(e.message) }   +RESULTS:\nthing unknown doesn't exist.  给 thing 新增了一个 name 属性，获取的时候拿到的是该对象本身的 name 属性，\n因此正常，但是当获取 thiing.unknown 的时候对象本身没找到会到原型上去找，而原型\n是一个代理对象， get trap 中阻止了任何原型属性的获取操作，因此报错异常。\n原型 set trap 对象操作的 set 和 get 一样首先查找本身，如果没有就往原型查找，因此这里也可以\n通过 set trap 去对原型属性的设置操作做一定的响应和拦截。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18  let target = {} let thing = Object.create(new Proxy(target, { set(trapTarget, key, value, receiver) { console.log(\u0026#39;key: \u0026#39; + key, \u0026#39;value: \u0026#39; + value) return Reflect.set(trapTarget, key, value, receiver) } })) console.log(thing.hasOwnProperty(\u0026#39;name\u0026#39;)) // false  thing.name = \u0026#39;thing\u0026#39; // 这里会触发 `set` 代理，因为 thing 中没有 `name` 属性 console.log(thing.name) // \u0026#39;thing\u0026#39; console.log(thing.hasOwnProperty(\u0026#39;name\u0026#39;)) // true  thing.name = \u0026#39;boo\u0026#39; // 这个时候 thing 中已经有 `name` 了，因此不会触发 `set` trap  console.log(thing.name)   +RESULTS:\nfalse key: name value: thing thing true boo  原型 has trap key in obj 对于 in 操作符，它不仅会检测对象本身，还会检查原型链，与其对应的\nproxy-trap 为 has trap，即我们可以通过这个 trap 来对 in 操作做一定的处理，比\n如让它针对被代理的对象在原型上的查找都失效。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14  let target = {} let thing = Object.create(new Proxy(target, { has(trapTarget, key) { // return false 让原型的查找失效  return Reflect.has(trapTarget, key) } })) console.log(\u0026#39;name\u0026#39; in thing) // 触发代理，因为 target 没 name 属性，会去查找原型  thing.name = \u0026#39;thing\u0026#39; console.log(\u0026#39;name\u0026#39; in thing) // 不会触发   +RESULTS:\nfalse true  代理作为原型作用域类上面 类是不能直接使用代理作为原型，因为累的原型属性是 non-writable 的，但是我们可以\n通过类的继承来变相实现代理原型.\n构造函数风格的原型代理：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17  function NoSuchProperty() { // ... } NoSuchProperty.prototype = new Proxy({}, { get(trapTarget, key, receiver) { throw new ReferenceError(`${key}doesn\u0026#39;t exist`) } }) let thing = new NoSuchProperty() try { let res = thing.name } catch(e) { console.log(e.message) }   +RESULTS:\nname doesn't exist  有了上面的 NoSuchProperty 构造函数之后，就可以让一个类去继承它，从而让类的原型\n成为代理。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28  function NoSuchProperty() { // ... } NoSuchProperty.prototype = new Proxy({}, { get(trapTarget, key, receiver) { throw new ReferenceError(`${key}doesn\u0026#39;t exist`) } }) class Square extends NoSuchProperty { constructor(length, width) { super() this.length = length this.width = width } } let shape = new Square(2, 6) let area1 = shape.length * shape.width console.log(area1) try { // error, no `wdth` property, 会去原型查找  let area2 = shape.length * shape.wdth } catch(e) { console.log(e.message) }   +RESULTS:\n12 wdth doesn't exist  上面的实例中 new Proxy() 代理实际上是 NoSuchProperty 的原型，而非 Square\n的，但是依然有效是因为原型链特征的原因，原型链查找不单单是查找父级对象还会往上一\n直查找原型，直到 Object.prototype 结束查找。\n上例中各对象原型间的关系：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28  function NoSuchProperty() { // ... } let proxy = new Proxy({}, { get(trapTarget, key, receiver) { throw new ReferenceError(`${key}doesn\u0026#39;t exist`) } }) NoSuchProperty.prototype = proxy class Square extends NoSuchProperty { constructor(length, width) { super() this.length = length this.width = width } } let shape = new Square(2, 6) let shapeProto = Object.getPrototypeOf(shape) console.log(proxy === shapeProto) // false  let secondLevelProto = Object.getPrototypeOf(shapeProto) console.log(secondLevelProto === proxy) // true    +RESULTS:\nfalse true  小结 Proxy : 允许拦截底层操作，给这些操作定义一些非标准的行为，比如监听数组长度变化，\n对象属性的删除操作。\nReflect : 针对每个 proxy trap 执行它们的默认行为，每一个 proxy trap 都有一个相\n对应且同名的 Reflect 方法与之对应，如对应表。\nrevocable proxy : 允许解绑的 proxy 。\n原型代理：可以让一个代理成为一个对象的原型，从而可以对该对象的原型的操作进行拦\n截，比如 get, set, has proxy traps。\n代码模块化 什么是模块？ 模块与普通的 scripts 使用有很大的不同：\n 模块代码默认严格模式运行，并且不能改变 当前模块创建的全局变量只针对于该模块而言，作用域仅限于该模块内 一个模块的 this 值为 undefined 模块内的代码不允许包含 html 格式的注释 模块内必须有导出，提供给模块外部使用 模块内通过 import 可以导入其他模块代码  模块赋予了指定需要的代码导入导出的能力.\n基本导出(export) 你可以使用 export 关键字去将模块内的指定内容导出给其他模块使用，比如：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29  // 导出变量 export var color = \u0026#39;red\u0026#39; export let name = \u0026#39;xx\u0026#39; export const magicNumber = 7 // 导出函数 export function sum(n1, n2) { return n1 + n2 } // 导出类 export class Rect { constructor(len, width) { this.len = len this.width = width } } function subtract(n1, n2) { return n1 - n2 } function multiply(n1, n2) { return n1 * n2 } // 先定义后导出 export { multiply }    变量、函数、类的导出都必须明确指定一个名字，因为外部使用的时候需要通过这个名\n字去使用 multiply 并没有在定义的时候导出，也就是说不需要总是导出定义也可以只导出引用 subtract 并没有被导出，就意味着模块外无法访问它，但是模块内部只要满足作用域\n就可以访问  基本导入(import) 一旦拥有使用 exports 导出的模块了，那么就可以在其他模块通过 import 关键词来\n导入这些内容，比如：\nimport { identifier1, identifier2 } from './example.js';\n可以从 example.js (一个文件视为一个模块)，将 identifier1 导入。\n模块导入语法导入的变量默认使用的是 const 定义的，也就意味着导入之后不能改变变\n量的值。\n但是可以通过 import { a as b } from './c.js'; 语法来重新定义命令名称。\n导入有多种方式，比如：只导入一个，导入多个，导入全部等等。\n导入单个 1 2 3 4 5 6  import { sum } from \u0026#39;./example.js\u0026#39; console.log(sum(1, 2)) // import 导入默认 const 不能改变 sum = 1; // error   导入时候的路径必须与使用导入模块的文件路径想匹配，即必须要能找到模块文件的正确路\n径。\n导入多个 1 2 3 4  import { sum, multiply, magicNumber } from \u0026#39;./example.js\u0026#39; console.log(sum(1, magicNumber)) // 8 console.log(multiply(1, 2)); // 2   导入所有 可以通过\nimport * as example from './example.js';\n将 example.js 模块导出的所有绑定导出到 example 对象中，然后可以通过\nexample.sum() 方式去访问模块中的内容。\n对同一个模块使用多个 import 最终模块都会只执行一次，它会在第一次导入的时候就存\n在于内存中等待复用，其他后面的使用的 import 语句都只是服用内存中的模块。\n不仅仅一个模块中多次使用 import 导入一个模块多次只会执行一次，就是多个模块同时\n多次导入同一个模块也只会在内存中保存一份引用，且所有模块对该模块的导入都只会使用\n这一份引用。\n也就是说在一个应用实例中，单个模块只会有一份，尽管会被多个模块多次导入。\n 模块语法限制：\nexport 和 import 不能在函数或语句表达式中使用，比如：\nif (flag) { export flag; } 语法错误。\n导出只能在模块的顶级作用域才能使用，函数或块级作用域中不允许使用。\n同样， import 只能在文件顶部执行导入。\n 重命名导入导出 导出重命名：\n1 2 3 4 5 6 7 8 9 10  // example.js function sum(n1, n2) { return n1 + n2 } export { sum as add } // a.js import { add } from \u0026#39;./example.js\u0026#39;   导入重命名：\n1 2 3 4 5 6 7 8 9  // example.js function sum(n1, n2) { return n1 + n2 } export { sum } // a.js import { sum as add } from \u0026#39;./example.js\u0026#39;   模块默认值 导出默认值：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  // example.js // 导出默认值不需要变量名 export default function(n1, n2) { return n1 + n2 } // 变量名方式 function sum(n1, n2) { return n1 + n2 } export { sum as default }   导入默认值：\n1 2 3 4  // a.js import sum from \u0026#39;./example.js\u0026#39; console.log(sum(1, 2)); // 3   将 example.js 中 export default 内容导出且赋予名称为 sum 。\n混合使用：\n1 2 3 4 5 6 7 8 9 10 11 12  // a.js export let color = \u0026#39;red\u0026#39; export default function(n1, n2) { return n1 + n2 } // b.js import sum, { color } from \u0026#39;./example.js\u0026#39; console.log(sum(1, 2)); // 3 console.log(color); // \u0026#39;red\u0026#39;   导出默认重命名：\nimport { default as sum, color } from './example.js'\n导入之后导出 即从一个模块导出一个内容，然后在当前模块中又将这个内容导出。\n1 2 3 4 5 6 7 8 9 10 11 12  import { sum } from \u0026#39;./a.js\u0026#39; export { sum } // 简写 export { sum } from \u0026#39;./a.js\u0026#39; // 导入-导出-重命名 export { sum as add } from \u0026#39;./a.js\u0026#39; // 导入所有导出所有 export * from \u0026#39;./a.js\u0026#39;   无导出的模块导入 即被导入的模块中并没有要导出的内容，这个时候只需要导入这个模块并且执行它即可。\n1 2 3 4 5 6 7 8 9 10 11 12  // a.js Array.prototype.pushAll = function(items) { // ... } // b.js import \u0026#39;./a.js\u0026#39; let colors = [\u0026#39;red\u0026#39;, \u0026#39;green\u0026#39;, \u0026#39;blue\u0026#39;] let items = [] items.pushAll(colors)   上面的代码会将 a.js 的内容直接在 b.js 中导入执行，这样 Array 上有了\npushAll 方法。\n 无导出的模块通常用来创建 polyfills 和 shims，模块代码只希望导入时立即执行。\n 加载模块 浏览器中使用模块 ECMAScript 6中虽然定义了模块语法，但并没有定义如何去加载他们。\n 通过 \u0026lt;script\u0026gt; 标签的 src 属性加载一个脚本文件执行里面的代码 通过嵌入 \u0026lt;script\u0026gt; 标签，在标签里面直接书写 js 代码 加载 js 代码放到一个 worker 里面执行  为了完全支持模块，浏览器不得不更新这些机制。\nscript标签中使用模块，script 标签的默认行为是当 type 属性不指定或指定为一个 JavaScript 脚本类型的时\n候(比如： text/javascript)，会加载一个 JavaScript 作为脚本去执行它而非模块。\nscript 标签会执行 src 加载的文件内的代码或者 \u0026lt;script\u0026gt; 与 \u0026lt;/script\u0026gt; 之间的\n代码。\n为了支持模块， type 类型新增了一个 \u0026quot;module\u0026quot; 类型值，通过设置 type=\u0026quot;module\u0026quot;\n告诉浏览器，该脚本包含的是一个模块代码。\n1 2 3 4 5 6  \u0026lt;script type=\u0026#34;module\u0026#34; src=\u0026#34;module.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;script type=\u0026#34;module\u0026#34;\u0026gt; import { sum } from \u0026#39;./example.js\u0026#39;; var result = sum(1,2); \u0026lt;/script\u0026gt;   第一个 \u0026lt;script\u0026gt; 标签加载了一个 src 指定的外部文件，唯一不同的是指定的类型为\n\u0026quot;module\u0026quot; 。\n第二个 \u0026lt;scrpt\u0026gt; 标签直接嵌入了一段代码通过 import 导入了一个外部脚本文件，因\n此 result 变量不会被加入到 window 对象上去，因为它只在这个 \u0026lt;script\u0026gt; 模块中\n生效。\n测试实例：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23  \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;title\u0026gt;\u0026lt;/title\u0026gt; \u0026lt;meta charset=\u0026#34;utf-8\u0026#34;\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;h1\u0026gt;a.html\u0026lt;/h1\u0026gt; \u0026lt;script src=\u0026#34;./a.js\u0026#34; type=\u0026#34;module\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;script\u0026gt; var globalResult = 1000; \u0026lt;/script\u0026gt; \u0026lt;script type=\u0026#34;module\u0026#34;\u0026gt; import { sum } from \u0026#39;./a.js\u0026#39;; var result = sum(1,2); console.log(\u0026#39;module result 1\u0026#39;, result); \u0026lt;/script\u0026gt; \u0026lt;script\u0026gt; console.log(\u0026#39;global result\u0026#39;, window.globalResult); console.log(\u0026#39;module result 2\u0026#39;, window.result); // undefined  \u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt;   chrome 浏览器执行结果：\n从结果所示：\n type='module' 的 script 最后被加载执行，因为其默认应用了 defer 属性 模块内部的变量不会添加到 window 对象上  Web浏览器中的模块加载序列 \u0026lt;script type=\u0026quot;module\u0026quot;\u0026gt; 的标签默认应用了 defer 属性，意味着它会被下载但不会被\n立即执行，只有当 DOM 被完全解析完成之后才会被执行，多个模块的时候会按照它们在\nDOM 结构中的顺序来执行，不区分是 src 引入模块文件还是直接嵌入代码方式。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21  \u0026lt;body\u0026gt; \u0026lt;h1\u0026gt;a.html\u0026lt;/h1\u0026gt; \u0026lt;script src=\u0026#34;./a.js\u0026#34; type=\u0026#34;module\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;script\u0026gt; var globalResult = 1000; \u0026lt;/script\u0026gt; \u0026lt;script type=\u0026#34;module\u0026#34;\u0026gt; import { sum } from \u0026#39;./a.js\u0026#39;; var result = sum(1,2); console.log(\u0026#39;module result 1\u0026#39;, result); const testEl1 = document.getElementById(\u0026#39;test\u0026#39;); console.log(testEl1, \u0026#39;test el 1\u0026#39;); \u0026lt;/script\u0026gt; \u0026lt;script\u0026gt; console.log(\u0026#39;global result\u0026#39;, window.globalResult); console.log(\u0026#39;module result 2\u0026#39;, window.result); // undefined  const testEl2 = document.getElementById(\u0026#39;test\u0026#39;); console.log(testEl2, \u0026#39;test el 2\u0026#39;); \u0026lt;/script\u0026gt; \u0026lt;div id=\u0026#34;test\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;/body\u0026gt;   结果：\n可以看到在普通的 script 标签中 \u0026lsquo;test el 2\u0026rsquo; 结果是 undefined 因为这个时候\ndiv#test 并没有并创建，因为它在所有的 script 之后。\n但是 \u0026lsquo;test el 1\u0026rsquo; 得到了正确的结果能获取到 div#test 元素，这恰恰说明了类型为\n\u0026lsquo;module\u0026rsquo; 的 script 标签在 DOM 解析完成之后执行。\n 多个 script#module 标签，会同步下载文件以及每个 script 里面的 import 的文\n件，但是不会立即执行，只有当 document 解析完成之后才会去执行它们，执行顺序为先\nscript 后 script 中的 import, 然后下一个 script 及其里面的 import，如此知道执行\n完成。\n 浏览器中的异步模块加载 \u0026lt;script type=\u0026quot;module\u0026quot; async src=\u0026quot;module1.js\u0026quot;\u0026gt;\u0026lt;/script\u0026gt;\nasync 表示 module1.js 一旦下载完成就会被立即执行，且不影响其他脚本的下载和执\n行，哪个下载完成谁就先执行。\nWorker 加载模块 我们都知道 JavaScript 是单线程的，但是有时候我们又需要做一些繁琐的工作，却不希望\n影响到主线程的运行，这个时候就可以用到 Worker 它相当于重新起了一个线程给指定的\n脚本去执行，并且不会阻塞主线程，还提供了与之通信的接口。\n脚本 Worker : new Worker('script.js');\n模块 Worker : new Worker('module.js', { type: 'module' });\n模块和脚本 Worker 差异：\n 脚本 Worker 只能加载同源脚本文件，即不支持跨域，但是模块 Worker 没有找个限制 脚本 Worker 可以使用 self.importScripts() 方法去加载其他的脚本，而在模块\nWorker 中只能使用 import 去加载其他脚本文件  加载文件路径限制 在模块引入的时候的路径只能是 /, ./, ../ 这种相对路径或者直接是包含域名的绝\n对路径，比如： http://x.x.x.x/path/to/file.js (需要配置 CORS 允许跨域访问)。\n其他情况不被允许，比如：\nimport { first } from 'a.js'; // error\nimport { second } from 'path/a.js'; // error\n上面两种都不会被浏览器下载，因为模块文件的路径不合法，尽管在 script 的 src\n属性值中可以这么使用，这也是 script 和 import 的一个区别。\n异常处理 try…catch 简写2019 try {} catch {} 现在可以省略 catch(e) ，直接将 catch 变成一个关键字。\n附录 A： 更小的变更 Integers 整型数据 JavaScript 使用了 IEEE 754 编码系统来表示整型和浮点数，这在以往引起不少困惑。\nECMAScript 6 中与数值有关的更新让整型的表示和使用更加便利。\nNumber.isInteger() 判断数值是否是整型数值：\n1 2 3 4 5 6 7 8  const isInt = v =\u0026gt; Number.isInteger(v) console.log(isInt(\u0026#39;1\u0026#39;)) console.log(isInt(1)) console.log(isInt(1.0)) console.log(isInt(1.8)) console.log(isInt(\u0026#39;\u0026#39;)) console.log(isInt(\u0026#39;a\u0026#39;))   +RESULTS:\nfalse true true false false false  1.0 会被当做整型值 1 存储，因此这里得到的结果是 true ,\nNumber.isInteger() 如果遇到数值型数据，在判断的时候会依据这些数值型数据在内存\n中的存储形式来决定最终结果(浮点、整型存储方式是不一样的)。\n安全整型值 IEEE754 的安全整型值范围为： -253 ~ 253，超出这个范围的值都被视为非安全数\n值。\n1 2  console.log(Math.pow(2, 53)) console.log(Math.pow(2, 53) + 1)   +RESULTS:\n9007199254740992 9007199254740992  第二个 +1 之后超出了范围，得的结果相当于没有执行加法操作的结果值。\nNumber.isSafeInteger() 检测是否是安全整型值。\nNumber.MAX_SAFE_INTEGER 得到当前机器上的最大安全整型值。\nNumber.MIN_SAFE_INTEGER 得到当前机器上的最小安全整型值。\n1 2 3 4 5 6 7 8  var inside = Number.MAX_SAFE_INTEGER, outside = inside + 1 console.log(Number.isInteger(inside)) // true console.log(Number.isSafeInteger(inside)) // true  console.log(Number.isInteger(outside)) // true console.log(Number.isSafeInteger(outside)) // false   +RESULTS:\ntrue true true false  新 Math 方法    方法名 功能     Math.acosh(x)    Math.asinh(x)    Math.atanh(x)    Math.cbrt(x)    Math.clz32(x)    Math.cosh(x)    Math.expm1(x)    Math.fround(x) x 最近的单精度浮点数   Math.hypot(...values) 参数列表平方和的平方根   Math.imul(x, y)    Math.log1p(x) 1 + x 的自然对数   Math.log10(x) 10 为底 x 的对数   Math.log2(x) 2 为底 x 的对数   Math.sign(x) 检查数值符号    -1 : x 负数    0 : x 为 +0 或 -0    1 : x 正数   Math.sigh(x) x 的双曲正弦   Math.tanh(x) x 的双曲正切   Math.trunc(x) 浮点数取整    1 2 3 4  console.log(Math.acosh(30), \u0026#39;cos\u0026#39;) console.log(Math.sinh(1), \u0026#39;sinh\u0026#39;) console.log(Math.tanh(30), \u0026#39;tanh\u0026#39;) console.log(Math.trunc(30.112), \u0026#39;trunc\u0026#39;) // 30   Unicode 标识符 用 Unicode 标识符做变量名称：\n1 2 3 4 5 6  var \\u0061 = \u0026#39;abc\u0026#39; console.log(\\u0061) // 等价于 console.log(a)   +RESULTS:\nabc abc  正规化 __proto__ 属性 附录 B：理解 ECMAScript 7 (2016) 为了更好的记录规范，最终将采用版本号+年份方式来记录，比如\nECMAScript 6 为 ECMAScript 2015，表示 2015 年发布的标准。\nECMAScript 7 为 ECMAScript 2016，表示 2016 年发布的标准\nECMAScript 7 发布与 2016年3月，它值包好了三个新增内容：\n ** 幂运算操作符，等同于 Math.pow(x, y) 方法 Array.prototype.includes() 方法，用来检测数组是否包含某个元素，返回\ntrue/false 支持函数域的严格模式  ** 幂运算操作符 1 2 3 4  let res = 5 ** 2 console.log(res) // 25 console.log(res === Math.pow(5, 2)) // true   +RESULTS:\n25 true  优先级 : 高于所有的二元元算法，低于一元运算符。\n1 2 3 4 5 6 7  let res = 2 * 5 ** 2; // ** 高于 * console.log(res) // 50  console.log(5 ** -2) // 0.04    +RESULTS:\n50 0.04  但是不允许一元运算符出现在 ** 的左侧，因为这样就没法判定哪个优先级更高，容易造\n成混淆，如果非要使用就必须使用 () 括起来。\n1 2 3 4  let res1 = -(5 ** 2) // -25 let res2 = (-5) ** 2 // 25  console.log(res1, res2)   +RESULTS:\n-25 25  ++ 和 -- 在 ** 中表达式中的使用：\n1 2 3 4 5 6 7 8 9  let n1 = 2, n2 = 2 console.log(++n1 ** 2) // 9 console.log(n1) // 3  console.log(n2-- ** 2) // 4 console.log(n2) // 1   +RESULTS:\n9 3 4 1  但是不允许直接在数字上使用 ++ 和 --\n1 2  let res = ++5 ** 2 console.log(res)   +RESULTS:\nReferenceError: Invalid left-hand side expression in prefix operation  Array.prototype.includes(val[, startIdx]) includes 内部实现伪码。\n查找 val 是否在数组中， startIdx 指定查找的其实索引，找到返回 true 否则返\n回 false 。\nincludes() 会将 NaN 视为同一个值，也就是说在比较的时候 NaN 和 NaN 比较的\n结果是真值，而 indexOf() 中使用的是 === 判断， NaN === NaN 结果是 false\n所以使用 includes() 更合理更安全，如果不需要被查找元素的索引值的话。\n1 2 3 4  let vals = [1, NaN, 2] console.log(vals.indexOf(NaN)) console.log(vals.includes(NaN))   +RESULTS:\n-1 true  实现内部对于零值的比较实用的是抽象操作 SameValueZero内中对 NaN 的判断并非是等\n式判断而是通过 isNaN() 方式的判断，对于零值有正负零值的判断(1/0 === Infinity, 1/-0 === Infinity)，更多详情请查看实现伪码。\n函数域的严格模式 即可以在函数顶部使用 \u0026quot;use strict\u0026quot;; 来指定当前函数执行模式为严格模式，不影响函\n数外的代码。\n相关链接  new-es2018-features-every-javascript-developer-should-know  新增内容列表 Object 和 Reflect 重复函数比较     Object Reflect     getOwnPropertyDescriptor(obj, key) obj 原始类型强转 obj 原始类型会抛异常    代理和映射    Proxy Traps Reflect Apis 原生功能 描述     get 13.3.3 Reflect.get(trapTarget, key, receiver) 对象属性读取 访问对象属性的时候触发   set 13.3.2 Reflect.set(trapTarget, key, value, receiver) 对象属性赋值操作 改变对象属性的值时触发   has 13.3.4 Reflect.has(trapTarget, key) key in obj 检测存在性   deleteProperty 13.3.5 Reflect.deleteProperty(trapTarget, key) delete obj.name 删除属性   getPrototypeOf 13.4 Reflect.getPrototypeOf(trapTarget) 获取对象原型 Object.getPrototypeOf()   setPrototypeOf 13.4 Reflect.setPrototypeOf(trapTarget, proto) 设置对象原型 Object.setPrototypeOf()   isExtensible 13.5 Reflect.isExtensible(trapTarget) 扩展性 Object.isExtensible()   preventExtensions 13.5 Reflect.preventExtensions(trapTarget) 扩展对象 Object.preventExtensions()   definePropery 13.6.3 Reflect.definePropery(trapTarget, key, descriptor) 属性描述符代理 Object.defineProperty(obj, key, desc)   getOwnPropertyDescriptor 13.6.3 Reflect.getOwnPropertyDescriptor(trapTarget, key) 获取属性描述符对象 Object.getOwnPropertyDescriptor(trapTarget, key   ownKeys 13.7 Reflect.ownKeys(trapTarget) 返回自身属性 Object.keys(), Object.getOwnPropertyNames()     Object.keys() 不包含符号属性     =Object.getOwnPropertyNames()= 不包含符号属性     Object.getOwnPropertySymbols() 不包含符号属性     Object.assign() 包含符号属性   apply 13.8 Reflect.apply(trapTarget, thisArg, argumentsList) 函数的调用 -   construct 13.8 Reflect.construct(trapTarget, argList[, newTarget] 函数实例化(new) -   Proxy.revocable(target, trapObj) 13.9 - 可撤销的代理 返回代理实例和 revoke() 撤销函数          表中参数说明：\n   参数名 类型 说明     trapTarget Object 被代理的对象   key - 要操作的对象属性名   value - 对象属性值   receiver Proxy 代理对象    符号    符号方法 类型 JavaScript 特性 描述     Symbol.hasInstance boolean instanceof 7.7.1 实例(原型链)检测   Symbol.isConcatSpreadable boolean Array.prototype.concat 7.7.2 检测参数合法性   Symbol.iterator function 调用后得到迭代器 遍历对象或数组(等可迭代的对象)的时候会用到   Symbol.asyncIterator function 调用后得到异步迭代器(返回一个 Promise ) 遍历对象或数组(等可迭代的对象)的时候会用到   Symbol.match function String.prototype.match 7.7.3 正则表达式对象内部属性   Symbol.matchAll function String.prototype.matchAll 7.7.3 正则表达式对象内部属性   Symbol.replace function String.prototype.replace 7.7.3 正则表达式对象内部属性   Symbol.search function String.prototype.search 7.7.3 正则表达式对象内部属性   Symbol.split function String.prototype.split 7.7.3 正则表达式对象内部属性   Symbol.species constructor new this.constructor[Symbol.species](value) symbol-species 返回构造函数，类内部使用，不能构造函数调用   Symbol.toPrimitive function - 7.7.4 返回一个对象的原始值   Symbol.toStringTag string Object.prototype.toString() 7.7.5 返回一个对象的字符串描述   Symbol.unscopables object with 7.7.8 不能出现在 with 语句中的一个对象    函数    分类 函数名 描述 其他     Promise Promise.all(iterable) 所有的 promise resolved     Promise.race(iterable) 只要有一个 promise settled 那么 race 立即 settled(无论是 rejected 还是 fulfilled)    Array Array.of(...items) 将参数了列表中的值组合成数组 和构造函数不一样，该方法会将参数只当做元素处理，而不会像 Array() 传一个参数当做长度处理。    Array.from(items[, mapFn[, thisArg]]) 将满足条件的对象转成数组 条件：1. 必须有长度属性，2. 要有数值索引元素。可迭代的对象会直接访问迭代器。    Array.prototype.find(mapFn[, thisArg]) 查找 mapFn 返回 true 条件的元素，返回该元素值 -    Array.prototype.findIndex(mapFn[, thisArg]) 查找 mapFn 返回 true 条件的元素，返回该元素索引 -    Array.prototype.fill(value[, start[, end]]) 用 value 替换区间 [start, end) 之间的元素值 返回值是原数组(元素被替换之后的)    Array.prototype.copyWithin(target, start[, end]) 拷贝区间 [start, end) 的元素替换 [target, len) 区间的元素 实际替换的区间长度由 min(end - start, len - target) 决定。   Function      Object Object.is(v1, v2) v1 是否是 v2 弥补 === 不能判断 +0，-0 和 NaN，NaN    Object.assign(target, ...sources) 合并对象，浅拷贝，赋值运算     Object.getPrototypeOf(obj) 取原型对象     Object.setPrototypeOf(obj, protoObj) 设置原型对象     Object.getOwnPropertySymbols(obj) 获取对象所有符号属性 Object.keys, Object.getOwnPropertyNames 不能取符号属性    Object.getOwnPropertyDescriptor(obj, key) 获取对象的描述符对象     Object.preventExtensions() 阻止对象呗扩展 -    Object.isExtensible() 对象是否可被扩展 -   String str.codePointAt(n) Unicode编码值 str.charCodeAt(n)    str.fromCodePoint(s) 根据编码转字符 str.fromCharCode(s)    str.normalize() 将字符的不同表示方式统一成一种表示形式 undefined, \u0026ldquo;NFC\u0026rdquo;, \u0026ldquo;NFD\u0026rdquo;, \u0026ldquo;NFKC\u0026rdquo;, or \u0026ldquo;NFKD\u0026rdquo;    str.repeat(n) 将字符串重复 n 遍，作为新字符串返回 \u0026lsquo;x\u0026rsquo;.repeat(3) =\u0026gt; \u0026lsquo;xxx\u0026rsquo;    ","permalink":"https://www.cheng92.com/web/javascript-ecma-6-plus/","tags":["javascript","es6"],"title":"Javascript ECMA 6 Plus"},{"categories":["algorithm,","string"],"contents":" 基于 leetcode 的算法学习记录文章，使用语言主要是 JavaScript，可能会有少于 C/Python 实现，在没标明的情况下默认都是 JavaScript 实现。\n约定 ：\n1. 有每日 角标的标识是每日一题的题目 2. 有leetcode角标的标识是该方案是Leetcode 网站上的题解 删除字符串中重复的字符  https://leetcode.com/articles/remove-all-adjacent-duplicates-in-string/\n 题解：删除靠着的重复字符，然后对删除后的字符执行同样的操作，直到没有紧靠着的重复字符为止。\n 比如： abbaca =\u0026gt; del, bb =\u0026gt; aaca =\u0026gt; del, aa =\u0026gt; ca\n 最终 abbaca 经过处理得到 ca 。\nwhile 循环版本  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  const del = str =\u0026gt; str.replace(/([a-z])\\1{1,}/gi, \u0026#39;\u0026#39;); function rmDupsWithWhile(current) { let last = \u0026#39;\u0026#39; while (last !== current) { last = current current = del(current) } return current } console.time(\u0026#39;Time\u0026#39;) console.log(\u0026#39;result:\u0026#39;, rmDupsWithWhile(\u0026#39;abbaca\u0026#39;)) console.timeEnd(\u0026#39;Time\u0026#39;)    result: ca Time: 7.468ms undefined   原理含简单，就是不断的使用正则去重复替换掉重复的连续字符，直到最后 last === current 为止，\n 因为一旦没有重复连续字符了， replace 的结果都最终一样。\n  正则递归版本(尾调用未优化)  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20  const str = \u0026#39;abbaca\u0026#39; const del = s =\u0026gt; s.replace(/([a-z])\\1{1,}/gi, \u0026#39;\u0026#39;) function rmDupsWithRecursionNoOptimized(current, last) { if (last == current) return current last = current current = del(current) const res = rmDupsWithRecursionNoOptimized(current, last) // 不满足尾调用优化：未立即返回执行结果，非最后一个语句  return res } console.time(\u0026#39;Time\u0026#39;) const res = rmDupsWithRecursionNoOptimized(str) console.timeEnd(\u0026#39;Time\u0026#39;) console.log(res)    Time: 0.336ms ca undefined    正则递归版本(尾调用优化)  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19  const str = \u0026#39;abbaca\u0026#39; const del = s =\u0026gt; s.replace(/([a-z])\\1{1,}/gi, \u0026#39;\u0026#39;) function rmDupsWithRecursionOptimized(current, last) { if (last == current) return current last = current current = del(current) // 尾调用优化条件： 1. 立即返回结果，2. 无变量引用，3. 最后一行  return rmDupsWithRecursionOptimized(current, last) } console.time(\u0026#39;Time\u0026#39;) const res = rmDupsWithRecursionOptimized(str) console.timeEnd(\u0026#39;Time\u0026#39;) console.log(res)    Time: 0.604ms ca undefined      ","permalink":"https://www.cheng92.com/algo/algo-leetcode-string-01/","tags":["algorithm,","leetcode,","javascript,","string"],"title":"Algorithm On Leetcode\u003cString\u003e 1 (Easy Level)"},{"categories":["emacs"],"contents":" ob-jq  1 2 3  {\u0026#34;a\u0026#34;: \u0026#34;test\u0026#34;} .a      Restclient  基础用法  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38  # -*- restclient -*- # # Gets all Github APIs, formats JSON, shows response status and headers underneath. # Also sends a User-Agent header, because the Github API requires this. # GET https://api.github.com User-Agent: Emacs Restclient # # It can even show an image! # GET http://upload.wikimedia.org/wikipedia/commons/6/63/Wikipedia-logo.png # # A bit of json GET, you can pass headers too # GET http://jira.atlassian.com/rest/api/latest/issue/JRA-9 User-Agent: Emacs24 Accept-Encoding: compress, gzip # # Post works too, entity just goes after an empty line. Same is for PUT. # 请求数据 # POST https://jira.atlassian.com/rest/api/2/search Content-Type: application/json { \u0026#34;jql\u0026#34;: \u0026#34;project = HCPUB\u0026#34;, \u0026#34;startAt\u0026#34;: 0, \u0026#34;maxResults\u0026#34;: 15, \u0026#34;fields\u0026#34;: [ \u0026#34;summary\u0026#34;, \u0026#34;status\u0026#34;, \u0026#34;assignee\u0026#34; ] }     删除：\n1 2 3 4  # # And delete, will return not-found error... # DELETE https://jira.atlassian.com/rest/api/2/version/20     设置变量：\n1 2 3  # Set a variable to the value of your ip address using a jq expression GET http://httpbin.org/ip -\u0026gt; jq-set-var :my-ip .origin      变量  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  # :myvar = the value # :myvar := (some (artbitrary \u0026#39;elisp) # 多行 :myvar = \u0026lt;\u0026lt; Authorization: :my-auth Content-Type: application/json User-Agent: SomeApp/1.0 # # 或使用 lisp，要以 # 结束 :myvar := \u0026lt;\u0026lt; (some-long-elisp (code spanning many lines) #     使用：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18  # Some generic vars :my-auth = 319854857345898457457 :my-headers = \u0026lt;\u0026lt; Authorization: :my-auth Content-Type: application/json User-Agent: SomeApp/1.0 # # Update a user\u0026#39;s name :user-id = 7 :the-name := (format \u0026#34;%s %s %d\u0026#34; \u0026#39;Neo (md5 \u0026#34;The Chosen\u0026#34;) (+ 100 1)) PUT http://localhost:4000/users/:user-id/ :my-headers { \u0026#34;name\u0026#34;: \u0026#34;:the-name\u0026#34; }     测试：\n 取单个用户\n1 2 3 4  :origin = https://reqres.in # get single user by id=2 GET :origin/api/users/2     创建用户\n1 2 3 4 5 6  # create user :origin = https://reqres.in POST :origin/api/users { \u0026#34;name\u0026#34;: \u0026#34;test\u0026#34;, \u0026#34;job\u0026#34;: \u0026#34;test\u0026#34; }        Verb   Examples\n Response Buffer   Response Buffer 的内容类型主要由 Content-Type 和 verb-content-type-handlers 的 内容决定，而字符编码要么是用 Content-Type 中指定的要么是 verb-default-response-charset 的值，默认是 utf-8 。\n 而类型主要就两种， Text 和 Binary, 文本会根据 charset 来进行解码后显示，对于二 进制内容则使用 emacs 内置能力直接显示。\n verb-content-type-handlers 的值：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  ;; Value (setq verb-content-type-handlers \u0026#39;((\u0026#34;text/html\u0026#34; html-mode) (\u0026#34;\\\\(application\\\\|text\\\\)/xml\u0026#34; xml-mode) (\u0026#34;application/xhtml\\\\+xml\u0026#34; xml-mode) (\u0026#34;application/json\u0026#34; verb-handler-json) (\u0026#34;application/javascript\u0026#34; js-mode) (\u0026#34;application/css\u0026#34; css-mode) (\u0026#34;text/plain\u0026#34; text-mode) (\u0026#34;application/pdf\u0026#34; doc-view-mode t) (\u0026#34;image/png\u0026#34; image-mode t) (\u0026#34;image/svg\\\\+xml\u0026#34; image-mode t) (\u0026#34;image/x-windows-bmp\u0026#34; image-mode t) (\u0026#34;image/gif\u0026#34; image-mode t) (\u0026#34;image/jpe?g\u0026#34; image-mode t)))     关闭 Response Buffer 两个函数：\n verb-kill-response-buffer-and-window, \u0026lt;C-c C-r C-k\u0026gt; 关闭当前。\n verb-kill-all-response-buffers, \u0026lt;C-c C-r C-a\u0026gt; 关闭所有。\n 重新发送请求： verb-re-send-request, \u0026lt;C-c C-r r\u0026gt;\n 如果在 Response Buffer 中想查看请求内容可以使用：\n verb-show-request, \u0026lt;C-c C-r C-q\u0026gt;\n verb-toggle-show-headers, \u0026lt;C-c C-r C-h\u0026gt;\n  Request Headers\u0026#xa0;\u0026#xa0;\u0026#xa0;verb  1 2 3  get https://reqres.in/api/users Accept: application/json Content-Language: de-DE     头部信息必须紧随 url 后面，中间可以有空行或注释(# 注释)。\n 有些字段有自己的默认值\n1 2 3 4 5 6 7  MIME-Version: 1.0 Connection: close or keep-alive Content-Length: number of bytes in request body (only when body is present) Host: URL host Accept: */* (default value, but may be overwritten by the user) Accept-Encoding: gzip Extension: Security/Digest Security/SSL     例子：\n1 2 3 4 5 6 7 8  post https://reqres.in/api/users Accept: application/json Content-Type: application/json; charset=utf-8 { \u0026#34;name\u0026#34;: \u0026#34;John\u0026#34;, \u0026#34;age\u0026#34;: 42 }    1  (Request timed out after 10.03 seconds)     另外请求的数据体还可以用\n1 2 3 4  { \u0026#34;name\u0026#34;: \u0026#34;John\u0026#34;, \u0026#34;age\u0026#34;: 42 }     形式表示。\n  Verb Variables\u0026#xa0;\u0026#xa0;\u0026#xa0;verb   template https://reqres.in/api/users Accept: application/json Authentication: {{(verb-var token)}}\n {{(verb-var token)}}\n 这等于是执行的时候要求你输入一个 token 值，如果想设置默认的值就这样：\n {{(verb-var token \u0026#34;default value\u0026#34;)}}\nGet users list  get Content-Language: de-DE\n  Create a user  post Content-Type: application/json; charset=utf-8\n { \u0026#34;name\u0026#34;: \u0026#34;{{(user-full-name)}}\u0026#34;, \u0026#34;age\u0026#34;: \u0026#34;{{(read-string \u0026#34;Age: \u0026#34;)}}\u0026#34; }\n    Org Header Properties\u0026#xa0;\u0026#xa0;\u0026#xa0;verb  :properties: :test: 这是个标题属性 🔚\n 除了 Verb-Store 之外的其它以 Verb- 开始的都会被当作 metadata 添加到请求中去。\nVerb-Map-Request  :properties: :Verb-Map-Request: remove-body-newlines 🔚\n post /{{(verb-var user-id)}}/upload Content-Type: text/plain; charset=utf-8\n foo, bar, baz\n 如上面的数据在发送之前会被 remove-body-newlines 处理之后返回，即实际发送给服务 器的变成了： foo,bar,baz\n1 2 3 4  (defun remove-body-newlines (rs) ;; RS is of type `verb-request-spec\u0026#39; (oset rs body (replace-regexp-in-string \u0026#34;\\n\u0026#34; \u0026#34; \u0026#34; (oref rs body))) rs)     可以通过给 org head 增加 Verb-Map-Request 来指定一个函数，这个函数会在请求发出 或导出之前执行。\n  Verb-Store\u0026#xa0;\u0026#xa0;\u0026#xa0;verb   template https://reqres.in/api Accept: application/json Content-Type: application/json; charset=utf-8\n 这个属性很特殊，当指定了这个之后，请求的结果会自动保存到这它指定的变量上去。\n 然后可以通过 verb-stored-response 函数去取到这个变量的值。\n 如：\nCreate a user  :properties: :Verb-Store: new-user 🔚\n post Content-Type: application/json; charset=utf-8\n { \u0026#34;name\u0026#34;: \u0026#34;{{(user-full-name)}}\u0026#34;, \u0026#34;age\u0026#34;: \u0026#34;{{(read-string \u0026#34;Age: \u0026#34;)}}\u0026#34; }\n 这里的结果保存到了 new-user\n  Get last created user  get /{{(verb-json-get (oref (verb-stored-response \u0026#34;new-user\u0026#34;) body) \u0026#34;id\u0026#34;)}} Accept: application/json\n 这里去取保存的结果。\n  Get IP  :properties: :Verb-Store: new-person 🔚\n post /users\n { \u0026#34;name\u0026#34;: \u0026#34;John\u0026#34;, \u0026#34;age\u0026#34;: 42 }\n  get Stored IP   get /users/{{(verb-json-get (oref (verb-stored-response \u0026#34;new-person\u0026#34;) body) \u0026#34;id\u0026#34;)}}\n  Get Last Response   get /users/{{(verb-json-get (oref verb-last body) \u0026#34;id\u0026#34;)}}\n 取上一个请求的响应数据。\n      Org Source Block Properties  :wrap   :wrap src ob-verb-response\n 指定结果用 src block 将结果包起来。\n1  get https://api.ipify.org?format=json    1 2 3 4 5 6 7 8 9 10 11 12  HTTP/1.1 200 OK Server: Cowboy Connection: keep-alive Content-Type: application/json Vary: Origin Date: Sat, 24 Jul 2021 11:15:56 GMT Content-Length: 22 Via: 1.1 vegur { \u0026#34;ip\u0026#34;: \u0026#34;27.38.254.246\u0026#34; }      :op   没有指定 :op 的时候默认是 :op send\nTIP\n 可以使用 :var keyword 来给 verb src block 传递参数，然后在代码块中用\n (verb-var \u0026lt;variable-name\u0026gt;) 使用。\n   :op send get-headers: 只显示响应头信息。\n1  get https://api.ipify.org?format=json    1 2 3 4 5 6 7  Server: Cowboy Connection: keep-alive Content-Type: application/json Vary: Origin Date: Sat, 24 Jul 2021 11:11:31 GMT Content-Length: 22 Via: 1.1 vegur      :op send get-body: 只显示响应体信息。\n1  get https://api.ipify.org?format=json    1 2 3  { \u0026#34;ip\u0026#34;: \u0026#34;27.38.254.246\u0026#34; }      :op export curl 将请求导出为 CURL 格式。\n1  get https://api.ipify.org?format=json    curl \u0026#39;https://api.ipify.org/?format=json\u0026#39;    :op export verb 将请求导出为 verb 格式。\n1  get https://api.ipify.org?format=json    GET https://api.ipify.org/?format=json        Upload File  1 2 3 4  post /{{(verb-var user-id)}}/upload Content-Type: text/markdown; charset=utf-8 {{(verb-read-file \u0026#34;~/Desktop/test.md\u0026#34;)}}     下面为什么内容前面要加上 {{}} ，因为 org-mode 默认 ** 是标题，加个空的 {{}} 可避免问题。\n1 2 3 4 5 6 7  post /{{(verb-var user-id)}}/upload Content-Type: text/markdown; charset=utf-8 # Sample Markdown file {{}}**This text is bold.** {{}}*This text is italicized.*      Upload Multiple Files   post www.example.com Accept: / Content-Type: multipart/form-data; boundary={{(verb-boundary)}}\n {{(verb-part \u0026#34;file\u0026#34; \u0026#34;1.txt\u0026#34;)}} Content-Type: text/plain\n {{(verb-read-file \u0026#34;/path/to/1.txt\u0026#34;)}} {{(verb-part \u0026#34;file\u0026#34; \u0026#34;2.html\u0026#34;)}} Content-Type: text/html\n {{(verb-read-file \u0026#34;/path/to/2.html\u0026#34;)}} {{(verb-part)}}\n  Binary content type tests\u0026#xa0;\u0026#xa0;\u0026#xa0;verb  template https://www.gnu.org\nPDF  get /licenses/quick-guide-gplv3.pdf\n  Images  template /graphics\nPNG image  get /gnu-head.png\n  JPG image  get /bokma-gnu.jpg\n  SVG image  get /logo-fsf.org.svg\n      /dev/null as a Service\u0026#xa0;\u0026#xa0;\u0026#xa0;verb  #\n post https://devnull-as-a-service.com/dev/null Content-Type: text/plain; charset=utf-8\n Hello!\n  Hacker News API\u0026#xa0;\u0026#xa0;\u0026#xa0;verb   template https://hacker-news.firebaseio.com/v0 Accept: application/json\nItem   get /item/{{(read-string \u0026#34;Item ID: \u0026#34;)}}.json?print=pretty\n  User   get /user/{{(read-string \u0026#34;User ID: \u0026#34;)}}.json\n  Live Data  Max Item ID  get /maxitem.json\n  Top Stories  get /topstories.json\n  New Stories  get /newstories.json\n  Best Stories  get /beststories.json\n      Export to EWW example\u0026#xa0;\u0026#xa0;\u0026#xa0;verb  get http://neverssl.com Accept: text/html\n  ipify API\u0026#xa0;\u0026#xa0;\u0026#xa0;verb  IPv4  template https://api.ipify.org\nJSON  get ?format=json\n  Text  get ?format=text\n    IPv6  template https://api6.ipify.org\nJSON  get ?format=json\n  Text  get ?format=text\n      Kanye REST API\u0026#xa0;\u0026#xa0;\u0026#xa0;verb   template https://api.kanye.rest\nGet quotes text response (Babel)  :properties: :Verb-Store: kanye 🔚\n1  get ?format=text    1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19  HTTP/1.1 200 OK Date: Sat, 24 Jul 2021 05:29:44 GMT Content-Type: application/json Transfer-Encoding: chunked Connection: keep-alive Access-Control-Allow-Origin: * Access-Control-Allow-Headers: Content-Type Access-Control-Allow-Methods: GET Expect-CT: max-age=604800, report-uri=\u0026#34;https://report-uri.cloudflare.com/cdn-cgi/beacon/expect-ct\u0026#34; Report-To: {\u0026#34;endpoints\u0026#34;:[{\u0026#34;url\u0026#34;:\u0026#34;https:\\/\\/a.nel.cloudflare.com\\/report\\/v3?s=yHwX2nlypygqT90DSvEtAsrxWQU9YjDmSajgfG9hzsmYqNFvKAAZRP0CqOKVhvgSZ4b1cdLk1d%2BF8gxrow4rkKyy1xnIxtB9qUv4XfU2Ls6GETgSh7uthXVNf5T6oz3V2g%3D%3D\u0026#34;}],\u0026#34;group\u0026#34;:\u0026#34;cf-nel\u0026#34;,\u0026#34;max_age\u0026#34;:604800} NEL: {\u0026#34;report_to\u0026#34;:\u0026#34;cf-nel\u0026#34;,\u0026#34;max_age\u0026#34;:604800} Vary: Accept-Encoding Server: cloudflare CF-RAY: 673ac0a53ce6eb3d-LAX alt-svc: h3-27=\u0026#34;:443\u0026#34;; ma=86400, h3-28=\u0026#34;:443\u0026#34;; ma=86400, h3-29=\u0026#34;:443\u0026#34;; ma=86400, h3=\u0026#34;:443\u0026#34;; ma=86400 { \u0026#34;quote\u0026#34;: \u0026#34;I don\u0026#39;t wanna see no woke tweets or hear no woke raps ... it\u0026#39;s show time ... it\u0026#39;s a whole different energy right now\u0026#34; }      Get JSON quotes, body only (Babel)  1  get    1 2 3  { \u0026#34;quote\u0026#34;: \u0026#34;The thought police want to suppress freedom of thought\u0026#34; }      Get JSON quotes  1  get    1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19  HTTP/1.1 200 OK Date: Sun, 25 Jul 2021 06:37:39 GMT Content-Type: application/json Transfer-Encoding: chunked Connection: keep-alive Access-Control-Allow-Origin: * Access-Control-Allow-Headers: Content-Type Access-Control-Allow-Methods: GET Expect-CT: max-age=604800, report-uri=\u0026#34;https://report-uri.cloudflare.com/cdn-cgi/beacon/expect-ct\u0026#34; Report-To: {\u0026#34;endpoints\u0026#34;:[{\u0026#34;url\u0026#34;:\u0026#34;https:\\/\\/a.nel.cloudflare.com\\/report\\/v3?s=b%2Bwjrw%2BO3AfKcLJXXQYyedGb%2BGEF%2BOrodpiucCNhs2kiJRw4kI6axDCBz6uIXKsMajdiiL2FLSy34eVmH0HyBQ22Vt6zK91I4aeHHXQ2bJYC4OQs6tj34Cc3x4Y93xOplg%3D%3D\u0026#34;}],\u0026#34;group\u0026#34;:\u0026#34;cf-nel\u0026#34;,\u0026#34;max_age\u0026#34;:604800} NEL: {\u0026#34;report_to\u0026#34;:\u0026#34;cf-nel\u0026#34;,\u0026#34;max_age\u0026#34;:604800} Vary: Accept-Encoding Server: cloudflare CF-RAY: 67436180ffac3131-LAX alt-svc: h3-27=\u0026#34;:443\u0026#34;; ma=86400, h3-28=\u0026#34;:443\u0026#34;; ma=86400, h3-29=\u0026#34;:443\u0026#34;; ma=86400, h3=\u0026#34;:443\u0026#34;; ma=86400 { \u0026#34;quote\u0026#34;: \u0026#34;If I got any cooler I would freeze to death\u0026#34; }        Open Library API\u0026#xa0;\u0026#xa0;\u0026#xa0;verb   template http://openlibrary.org User-Agent: Verb/Emacs Emacs/{{emacs-version}} Accept: application/json\nSearch  template /search.json\nBy Title  1  get ?title={{(verb-var title)}}      By Author  get ?author={{(verb-var author \u0026#34;Frank Herbert\u0026#34;)}}\n    Subjects  get /subjects/{{(verb-var subject)}}.json\n  Books  :properties: :Verb-Store: book 🔚\n get /api/books?bibkeys=ISBN:{{(verb-var isbn)}}\u0026amp;format=json\n  Book Cover  get {{(verb-json-get (oref (verb-stored-response \u0026#34;book\u0026#34;) body) (concat \u0026#34;ISBN:\u0026#34; (verb-var isbn)) \u0026#34;thumbnail_url\u0026#34;)}} Accept: image/jpeg\n    Postman Echo API\u0026#xa0;\u0026#xa0;\u0026#xa0;verb   template https://postman-echo.com\nGZIP test  get /gzip Accept-Encoding: gzip\n  Stream test  get /stream/5\n  Post  post /post Content-Type: application/json\n { \u0026#34;hello\u0026#34;: 1, \u0026#34;bye\u0026#34;: {} }\nPost (raw text)  template Content-Type: text/plain\n {{(verb-read-file \u0026#34;../test/test.txt\u0026#34;)}}\n    Status code  get /status/{{(read-number \u0026#34;Status: \u0026#34;)}}\n    REQ|RES\u0026#xa0;\u0026#xa0;\u0026#xa0;verb   template https://reqres.in/api?delay=0 Content-Type: application/json\nUsers   template /users\nGet endpoint headers  head\n  Get endpoint options  options\n  List users   get ?page=1\n  Create user  post Content-Type: application/json\n { \u0026#34;name\u0026#34;: \u0026#34;{{(user-login-name)}}\u0026#34;, \u0026#34;age\u0026#34;: 55 }\n  Operate on a single user   template /2\nGet a single user  get\n  Replace a user  put\n { \u0026#34;name\u0026#34;: \u0026#34;Bob\u0026#34; }\n  Update a user  patch\n { \u0026#34;name\u0026#34;: \u0026#34;Bob\u0026#34; }\n  Delete a user  delete\n      Login   post /login\n1 2 3 4  { \u0026#34;email\u0026#34;: \u0026#34;eve.holt@reqres.in\u0026#34;, \u0026#34;password\u0026#34;: \u0026#34;hello\u0026#34; }        Scryfall REST API\u0026#xa0;\u0026#xa0;\u0026#xa0;verb   template https://api.scryfall.com\nCards list   get /cards\nSingle card by ID   get /{{(read-string \u0026#34;Card ID: \u0026#34; \u0026#34;4b332e3d-dcf4-4f62-8130-124ec5d23b90\u0026#34;)}}?format=text\n  Get a random card image   get /random?format=image\n    Sets   get /sets\nSingle set by ID   get /{{(read-string \u0026#34;Set ID: \u0026#34; \u0026#34;914a6c6d-cb3b-45e8-a2db-9978a2339faf\u0026#34;)}}\n      API2 convert\u0026#xa0;\u0026#xa0;\u0026#xa0;verb   template https://api2.online-convert.com x-oc-api-key: d89c39a23d8f41ca8fd13ef85297b9a7 Cache-Control: no-cache\n api documents\nget id and server  :properties: :Verb-Store: convert-response 🔚\n post /jobs\n { \u0026#34;conversion\u0026#34;: [{ \u0026#34;category\u0026#34;: \u0026#34;image\u0026#34;, \u0026#34;target\u0026#34;: \u0026#34;png\u0026#34; }] }\n  base64 -\u0026gt; image  :properties: :Verb-Store: image-response 🔚\n POST {{(verb-json-get (oref (verb-stored-response \u0026#34;convert-response\u0026#34;) body) \u0026#34;server\u0026#34;)}}/upload-base64/{{(verb-json-get (oref (verb-stored-response \u0026#34;convert-response\u0026#34;) body) \u0026#34;id\u0026#34;)}} Content-Type: image/png\n { \u0026#34;content\u0026#34;: \u0026#34;data:image/gif;base64,R0lGODlhAQABAIAAAAUEBAAAACwAAAAAAQABAAACAkQBADs=\u0026#34;, \u0026#34;filename\u0026#34;: \u0026#34;black-pixel\u0026#34; }\n  get the upload image   POST /jobs\n { \u0026#34;input\u0026#34;: [{ \u0026#34;type\u0026#34;: \u0026#34;input_id\u0026#34;, \u0026#34;source\u0026#34;: \u0026#34;{{(verb-json-get (oref (verb-stored-response \u0026#34;image-response\u0026#34;) body) \u0026#34;id\u0026#34; \u0026#34;input\u0026#34;)}}\u0026#34; }], \u0026#34;conversion\u0026#34;: [{ \u0026#34;target\u0026#34;: \u0026#34;png\u0026#34; }] }\n  multiple image   POST /dl/web2/upload-base64/a6f691e2-839e-49e5-829d-dc2d97486fe1 Content-Type: application/json\n [{ \u0026#34;content\u0026#34;: \u0026#34;data:image/gif;base64,R0lGODlhAQABAIAAAAUEBAAAACwAAAAAAQABAAACAkQBADs=\u0026#34;, \u0026#34;filename\u0026#34;: \u0026#34;black_pixel.gif\u0026#34; },{ \u0026#34;content\u0026#34;: \u0026#34;data:text/plain;base64,dGVzdCBzdHJpbmc=\u0026#34;, \u0026#34;filename\u0026#34;: \u0026#34;example_string.txt\u0026#34; }]\n      tables  列宽和对齐(Column width and alignment)     1 one some   2 two boring   3 this is a long text column        keybindings  逗号(,)  , s trees/subtrees 操作     key function description     , s h org-premote-subtree 升级, h4 -\u0026gt; h3   , s l org-demote-subtree 降级, h3 -\u0026gt; h4   , s n org-narrow-to-subtree 定位到当前的标题试图，隐藏其他   , s N widen 恢复隐藏   , s j org-move-subtree-down 当前树下移   , s k org-move-subtree-up 当前树上移      , b org-babel-* 操作     key function description     , b p org-babel-previous-src-block 跳转到上一个代码块   , b n org-babel-next-src-block 跳转到下一个代码块          Hyperlinks(超链接)  Internal Links(内部链接)    org file link target: \u0026lt;\u0026lt;target\u0026gt;\u0026gt; link source: target\n 这种方式在 hugo 中无法时候用，但是可以通过第二种方式的 PROP: CUSTOM_ID 来实现。\n  in hugo link target: doc_header 必须在某个标题下面声明属性，才能其效果。\n:PROPERTIES: :COLUMNS: %CUSTOM_ID[(Custom Id)] :CUSTOM_ID: doc_header :END:   link source: C-c C-l 或者 org-insert-link 或者直接 [[#doc_header][文档开 头位置]] ，请点击：文档开头位置\n    实现非标题项内部跳转   添加 meta: @@html:\u0026lt;span id=\u0026#34;test-link\u0026#34;\u0026gt;\u0026lt;/span\u0026gt;\n 添加链接跳转到上面的 meta： @@html:\u0026lt;a href=\u0026#34;#test-link\u0026#34;\u0026gt;some thing\u0026lt;/a\u0026gt;\n 这样点击 some thing 会占满到 id 为 test-link 的那个元素位置。\n 如： 请点击下面的链接跳回到我这里来。。。。\n some thing !!!\n some thing !!!\n some thing !!!\n some thing !!!\n some thing !!!\n some thing !!!\n some thing !!!\n some thing !!!\n some thing !!!\n some thing !!!\n some thing !!!\n some thing !!!\n some thing !!!\n 🔗点我跳回到上面！！\n    Markup for Rich Contents(富文本)  Literal Examples(文本模板)   适合长文本内容的：\n* some example from a text file   如果只是简短的语句，可直接使用 `:`(冒号)也可以达到同样效果：\n* some short example from a text file   代码模板：\n1 2 3  (defun org-xor (a b) (ref:sc) \u0026#34;Exclusive or.\u0026#34; (ref:jump) (if a (not b) b))     配置选项: -n ，可以在代码中加入引用 (ref:sc) ，然后在文章任意地方使用 [[(sc)]] 创建一个链接，点击后可以定位到代码中该出。\n In line (sc) we remember the current position. Line (jump) jumps to point-min.\n link: literal_eg\n    16 Miscellaneous(杂项)  16.2 Structure Templates(结构化模板)  a\t‘#+BEGIN_EXPORT ascii’ … ‘#+END_EXPORT’ c\t‘#+BEGIN_CENTER’ … ‘#+END_CENTER’ C\t‘#+BEGIN_COMMENT’ … ‘#+END_COMMENT’ e\t‘#+BEGIN_EXAMPLE’ … ‘#+END_EXAMPLE’ E\t‘#+BEGIN_EXPORT’ … ‘#+END_EXPORT’ h\t‘#+BEGIN_EXPORT html’ … ‘#+END_EXPORT’ l\t‘#+BEGIN_EXPORT latex’ … ‘#+END_EXPORT’ q\t‘#+BEGIN_QUOTE’ … ‘#+END_QUOTE’ s\t‘#+BEGIN_SRC’ … ‘#+END_SRC’ v\t‘#+BEGIN_VERSE’ … ‘#+END_VERSE’    16.7 Summary of In-Buffer Settings(文件设置)    `#+STARTUP:`\n   option function     indent 开启自动缩进   noindent 关闭西东缩进          Org-mode in hugo   给图片增加属性(使用 #+attr_html)：\n#+attr_html: :width 100 :height 200 [[/images/some-img.png]]  #+ 开头的属性    #+caption: 设置表名称\n  #+attr_html 增加 html 属性，比如：\n  增加样式名： #+attr_html: :class classname\n  设置宽高： #+attr_html: :width 100 :height 100\n    #+attr_css 增加 css 样式，比如：\n  设置宽高： #+attr_css: :width 100px :height 200px :text-align center ，注意和 html 属性区 分开\n        snippets  首字母大写   新增函数：\n1 2 3 4 5 6  (defun my/capitalize-first-char (\u0026amp;optional string) \u0026#34;Capitalize only the first character of the input STRING.\u0026#34; (when (and string (\u0026gt; (length string) 0)) (let ((first-char (substring string nil 1)) (rest-str (substring string 1))) (concat (capitalize first-char) rest-str))))     然后在 snippet 文件中调用：\n# -*- mode: snippet -*- # name: intro # key: zname # -- Hi, my name is ${1:$$(my/capitalize-first-char yas-text)}. $0      org-html-themes   ","permalink":"https://www.cheng92.com/emacs/emacs-org-mode/","tags":["emacs,","org-mode"],"title":"My Emacs Org-Mode Document"},{"categories":["algorithm,","array"],"contents":" 基于 leetcode 的算法学习记录文章，使用语言主要是 JavaScript，可能会有少于 C/Python 实现，在没标明的情况下默认都是 JavaScript 实现。\n约定 ：\n1. 有每日 角标的标识是每日一题的题目 2. 有leetcode角标的标识是该方案是Leetcode 网站上的题解 01. 数组中重复的数字  方案一： reduce + Object.keys + map + filter  下面这种方案适合于将所有重复的数字都找出来的案例，如果只需要找到第一个，该方案有多余的处理步骤，不建议使用。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30  /** ,* @param {number[]} nums ,* @return {number} ,*/ var findRepeatNumber = function (nums) { if (!Array.isArray(nums)) return [] // 通过 reduce 得到 { val: times } 结果  // 如果重复出现过 times \u0026gt; 0 否则 times === 0  let res = nums.reduce((acc, num) =\u0026gt; { const k = num + \u0026#34;\u0026#34; let v = acc[num + \u0026#34;\u0026#34;] || 0 if (acc.hasOwnProperty(k)) { acc[k] = ++v } else { acc[k] = 0 } return acc }, {}) // 然后通过 keys, map 整理结果 times \u0026gt; 0 的值  // 最后 filter 过滤掉 0 值得到的数组就是源数组中重复的数集合  const found = +Object.keys(res) .map(k =\u0026gt; (res[k] ? k : 0)) .filter(Boolean)[0] return found !== found ? -1 : found } console.log(findRepeatNumber([2, 3, 1, 0, 2, 5, 3]))    2 undefined   执行结果：\n 执行用时：152 ms, 在所有 JavaScript 提交中击败了 24.41%的用户\n 内存消耗：51.9 MB, 在所有 JavaScript 提交中击败了 100.00%的用户\n   提交时间 提交结果 运行时间 内存消耗 语言     几秒前 通过 152 ms 51.9 MB Javascript      方案二: for  使用 for 语法，明显会比使用 reduce 快，因为它只要遇到重复的立即退出函数，而 reduce 版本无论什么时候都需要将数组所有元素遍历完，方案一更适合于查找\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18  var findRepeatNumber = function (nums) { if (!Array.isArray(nums)) return -1 let res = {} for (let i = 0, len = nums.length; i \u0026lt; len; i++) { let k = nums[i] + \u0026#34;\u0026#34;, v = res[k] if (res.hasOwnProperty(k)) { return k } else { res[k] = 0 } } return -1 }     提交结果 ：\n 执行用时：88 ms, 在所有 JavaScript 提交中击败了 57.41%的用户\n 内存消耗：43.1 MB, 在所有 JavaScript 提交中击败了 100.00%的用户\n   提交时间 提交结果 运行时间 内存消耗 语言     几秒前 通过 \u0026lt;font color=\u0026#34;red\u0026#34;\u0026gt;88 ms\u0026lt;/font\u0026gt; 43.1 MB Javascript   3 分钟前 通过 104 ms 43 MB Javascript   1 天前 通过 152 ms 51.9 MB Javascript      方案三: 递归  这个方法也可以通过，但效率上面感觉并没什么优势，并且这个方法找出的并不是第一个重复的元素。\n 对比[方案二]：\n  重复元素在中心点两边，同样需要遍历相同的次数才能找到这个重复元素(因为左边的递归必须先完成)\n  重复元素在左边，左边递归次数和方案二循环次数是一样的\n  重复元素在右边，左边必须递归完，右边的也必须递归直到两个重复元素出现(同方案一一样)\n  能否针对上面的情况进行优化( text 考虑中心点两边同 时进行比较，而不是等一边完成再处理另一边，那貌似就不适用递归了 )???\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28  findRepeatNumber = function _(nums, res = {}) { if (!Array.isArray(nums)) return -1 // 过滤掉非数组的情况  let len = nums.length, mid = ~~(len / 2) const v = nums[0] const val = res[v] if (v !== void 0) { // 这里应该可以再优化下，空数组不应该会到这里  res[v] = val \u0026gt;= 0 ? val + 1 : 0 // console.log(v, \u0026#34;-------\u0026#34;, res)  if (res[v] \u0026gt; 0) { return v // 这里的返回值会被下面递归是的 x 变量接受  } } let x = null if (mid \u0026gt; 0) {// 这里优化空数组情况，不应该继续往下分解了  x = _(nums.slice(1, mid), res) if (x \u0026gt; -1) return x x = _(nums.slice(mid), res) if (x \u0026gt; -1) return x } return -1 }     执行用时：112 ms, 在所有 JavaScript 提交中击败了 28.43%的用户\n 内存消耗：49.8 MB, 在所有 JavaScript 提交中击败了 100.00%的用户\n   提交时间 提交结果 运行时间 内存消耗 语言     几秒前 通过 112 ms 49.8 MB Javascript   3 天前 通过 92 ms 45.5 MB Javascript   3 天前 通过 104 ms 45.1 MB Javascript   4 天前 通过 88 ms 43.1 MB Javascript   4 天前 通过 104 ms 43 MB Javascript   6 天前 通过 152 ms 51.9 MB Javascript      方案四：二分 for  这个方案好处就是当两个数分布在中心点的两边的时候。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23  var findRepeatNumber = function _(nums) { if (!Array.isArray(nums)) return -1 const len = nums.length const mid = ~~(len / 2) let res = {} for (let i = 0, j = mid + 1; i \u0026lt;= mid || j \u0026lt; len; i++, j++) { const v1 = nums[i] if (v1 !== void 0) { res[v1] = res[v1] === void 0 ? 0 : res[v1] + 1 } if (res[v1] \u0026gt; 0) return v1 const v2 = nums[j] if (v2 !== void 0) { res[v2] = res[v2] === void 0 ? 0 : res[v2] + 1 } if (res[v2] \u0026gt; 0) return v2 } return -1 }     结果好像并没啥优势，😅!!!\n   提交时间 提交结果 运行时间 内存消耗 语言     几秒前 通过 104 ms 45.4 MB Javascript   1 分钟前 通过 108 ms 45.6 MB Javascript   1 分钟前 通过 116 ms 45.6 MB Javascript   1 分钟前 通过 88 ms 45.7 MB Javascript      其他方案(leetcoders)  其他 leetcode 上的方案，觉得有趣挺好的方案列表：\n  set.has 通过集合特性检测是否存在\n  1 2 3 4 5 6 7 8 9 10  var findRepeatNumber = function _(nums) { let s = new Set() for (let i = 0, len = nums.length; i \u0026lt; len; i++) { const val = nums[i] // 这里还可以改造下，通过检测长度变化来做为退出条件  if (s.has(val)) return val else s.add(val) } return -1 }        02. 两数之和 II - 输入有序数组  方案一：两个 for，O(n2)   这种方法最简单暴力，但是时间复杂度为 O(n^2)\n1 2 3 4 5 6 7 8 9 10 11 12 13  // 最基本的遍历 O(n^2)  var twoSum = function(numbers, target) { let len = numbers.length for (let i = 0; i \u0026lt; len; i++) { for (let j = i + 1; j \u0026lt; len; j++) { if (numbers[i] + numbers[j] === target) { return [i + 1, j + 1] } } } return -1 };     执行用时：444 ms, 在所有 JavaScript 提交中击败了 5.30%的用户\n 内存消耗：38 MB, 在所有 JavaScript 提交中击败了 10.00%的用户\n   提交时间 提交结果 运行时间 内存消耗 语言     几秒前 通过 444 ms 38 MB Javascript     该方案基础上可以做点优化，排除非法值。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33  // 把上面的实现，领出来作为一个函数  function base(numbers, target) { let len = numbers.length for (let i = 0; i \u0026lt; len; i++) { for (let j = i + 1; j \u0026lt; len; j++) { if (numbers[i] + numbers[j] === target) { return [i + 1, j + 1] } } } return [] } // 这里加一层过滤。  // 过滤不合法的值，因为Numbers 是已排序的数组，所以 numbers[0] 肯定是最小的  // 通过和这个数相加如果大于 target 那肯定是不满足条件的元素，可以直接排除  // 时间复杂度依旧是 O(n^2)  var twoSum = function(numbers, target) { let len = numbers.length // 过滤掉不合法的值，比如：\u0026gt; target  let n = -1, min = numbers[0] for (let i = 1; i \u0026lt; len; i++) { if (numbers[i] + min \u0026gt; target) { n = i break } } if (n \u0026gt; -1) { numbers = numbers.slice(0, n) } return base(numbers, target) }     这种优化只针对后面又大量的比 target 大的值的元素情况，否则几乎没任何改善。\n 执行用时：200 ms, 在所有 JavaScript 提交中击败了 23.08%的用户\n 内存消耗：37.9 MB, 在所有 JavaScript 提交中击败了 10.00%的用户\n   提交时间 提交结果 运行时间 内存消耗 语言     几秒前 通过 200 ms 37.9 MB Javascript      方案二: 排除 + 二分(O(n2), O(1))   优化后的代码，依旧需要找出 midIdx，经过两次循环，时间复杂度为 O(n2)，过程中不需要开辟新的数组，完全是在索引上进行操作的，因此空 间复杂度是 O(1)\n  这个方案是基于方案一实现，在它的基础上将数组二分之后做加法比 较，因为遍历的是有序数组，在排除不合法的值之后(`min + max \u0026gt; target`的最大值)有效 数字的索引是不会发生改变的。\n 这个方案的重点在于二分，减少遍历的次数，最坏的情况是排除的时 候没任何变化，即数组元素都是有效数字，且较小值在左侧末尾，较大值也在左侧末尾，这 样会导致双层遍历都需要走完才能找到有效两个值。\n 比如：[-1, 2, 3, 10, 12, 13] -\u0026gt; 16 经过两步\n  排除较大值无变化\n  二分数组成: `[-1, 2, 3]` 和 `[10, 12, 13]` 即要找到 3 + 13 = 16 就得将两个数组遍历到最后(3x3=9 次)。\n  *写到这里会发现其实每次遍历并不需要都遍历完，考虑下将右边数字倒序遍历，那么就会 有如果 leftval + rightval \u0026lt; target 的时候那么它之后的数都不可能等于 target 便可 以退出本次循环，减少比较次数。*\n 比如： left = -1, right = 13 相加 \u0026lt; 16 那么 -1 + 12/10/… 都不可能等于 target 因此可以直接排除掉。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63  // 取中间值，然后搜索左值和右值，需要开辟 两个数组空间总大小最大为 numbers.length  var twoSum = function (numbers, target) { numbers = filterLarger(numbers, target) const len = numbers.length const min = numbers[0], max = numbers[len - 1] // 目标的中间值作为基准，分割出左右小-大两个数组元素区  const mid = Math.floor(target / 2) let midIdx = -1 // 找出大值起始索引  for (let i = 0; i \u0026lt; len; i++) { const val = numbers[i] if (val \u0026gt; mid) { midIdx = i break } else if (val === mid) { midIdx = i + 1 break } } //console.log({ mid, midIdx }, numbers)  // 如果 midIdx === -1 说明有两种情况：  // 1. 余下的元素都是比 mid 小的数，这种情况就不会存在两个数相加等于 target  // 2. 余下的元素都是等于 mid 的数，这个时候可能性只有 mid 为 0情况  if (midIdx === -1) { if (target === 0) { // q2  // 这种情况只要找出两个值为 0 的元素索引  let res = [] for (let i = 0; i \u0026lt; len; i++) { if (res.length \u0026lt; 2) { numbers[i] === 0 \u0026amp;\u0026amp; res.push(i + 1) } if (res.length === 2) { return res } } } else { // q1  return -1 } } // 到这里说明 midIdx \u0026gt; -1，两边都有值且一大一小  let count = 0 for (let i = 0; i \u0026lt; midIdx; i++) { // 较小数  for (let j = midIdx; j \u0026lt; len; j++) { ++count // 较大数  if (numbers[i] + numbers[j] === target) { console.log(count, \u0026#34;two sum 1\u0026#34;) return [i + 1, j + 1] } } } return -1 }     上面示例提交结果： 执行用时：96 ms, 在所有 JavaScript 提交中击败了 28.05%的用户\n 内存消耗：38.3 MB, 在所有 JavaScript 提交中击败了 10.00%的用户\n 根据上面的分析，进一步优化，使第二个 for 倒序遍历，减少遍历次数：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69  // 取中间值，然后搜索左值和右值，需要开辟 两个数组空间总大小最大为 numbers.length  var twoSum2 = function (numbers, target) { numbers = filterLarger(numbers, target) const len = numbers.length const min = numbers[0], max = numbers[len - 1] // 目标的中间值作为基准，分割出左右小-大两个数组元素区  const mid = Math.floor(target / 2) let midIdx = -1 // 找出大值起始索引  for (let i = 0; i \u0026lt; len; i++) { const val = numbers[i] if (val \u0026gt; mid) { midIdx = i break } else if (val === mid) { midIdx = i + 1 break } } //console.log({ mid, midIdx }, numbers)  // 如果 midIdx === -1 说明有两种情况：  // 1. 余下的元素都是比 mid 小的数，这种情况就不会存在两个数相加等于 target  // 2. 余下的元素都是等于 mid 的数，这个时候可能性只有 mid 为 0情况  if (midIdx === -1) { if (target === 0) { // q2  // 这种情况只要找出两个值为 0 的元素索引  let res = [] for (let i = 0; i \u0026lt; len; i++) { if (res.length \u0026lt; 2) { numbers[i] === 0 \u0026amp;\u0026amp; res.push(i + 1) } if (res.length === 2) { return res } } } else { // q1  return -1 } } // 到这里说明 midIdx \u0026gt; -1，两边都有值且一大一小  let count = 0 for (let i = 0; i \u0026lt; midIdx; i++) { // 较小数  for (let j = len - 1; j \u0026gt;= midIdx; j--) { const lval = numbers[i], rval = numbers[j] ++count if (lval + rval \u0026lt; target) { // 直接退出 j 循环  break } // 较大数  if (lval + rval === target) { console.log(count, \u0026#34;two sum 2\u0026#34;) return [i + 1, j + 1] } } } return -1 }     测试：\nconsole.log(twoSum([-1, 2, 3, 10, 12, 13], 16), \u0026#34;result1\u0026#34;) console.log(twoSum2([-1, 2, 3, 10, 12, 13], 16), \u0026#34;result2\u0026#34;) // 输出结果: ➜ algo git:(master) ✗ node test.js node test.js 9 two sum 1 [ 3, 6 ] result1 3 two sum 2 [ 3, 6 ] result2 ➜ algo git:(master) ✗   从上结果看出，优化之前 count = 9，优化之后 count = 3，很明显大大减少了遍历次数。\n 提交结果 1 ：\n 执行用时：96 ms, 在所有 JavaScript 提交中击败了 28.05%的用户\n 内存消耗：38.1 MB, 在所有 JavaScript 提交中击败了 10.00%的用户\n 提交结果 2 ：\n 执行用时：76 ms, 在所有 JavaScript 提交中击败了 51.90%的用户\n 内存消耗：38.1 MB, 在所有 JavaScript 提交中击败了 10.00%的用户\n 提交多次后的结果 ：\n   提交时间 提交结果 运行时间 内存消耗 语言     几秒前 通过 76 ms 38.5 MB Javascript   几秒前 通过 92 ms 38.1 MB Javascript   1 分钟前 通过 76 ms 38.1 MB Javascript   1 分钟前 通过 96 ms 38.1 MB Javascript   26 分钟前 通过 96 ms 38.3 MB Javascript     PS：结果好像并没什么改善，使用双层循环始终不完美，能否只是用一个层循环就能解决问题呢？？？\n  方案三：计算，存储差值方式(O(n), O(n))  差值计算原理\n  缓存不满足条件的值(作为索引)，其索引作为值，用来待查询\n  使用插值作为索引去取值，能取到说明这个值被遍历且被存储去，属于有 效值，最终返回其作为索引对应的值(即它的索引值)，和当前的值索引，即 最后满足条件的两个值的索引\n  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23  var twoSum = function (numbers, target) { // 这里可以左一层过滤，过滤掉非法的值  // numbers = filterLarger(numbers, target)  const deltas = [] const len = numbers.length for (let i = 0; i \u0026lt; len; i++) { const val = numbers[i] // 记录当前的值  const delta = target - numbers[i] // 计算差值  if (deltas[delta] !== void 0) { // 进入这里说明当前值的差值在 deltas 中存在过  return [deltas[delta] + 1, i + 1] } // 保存当前值和它的索引  // 这里保存的目的是为了使用上面的 delta 走位索引来找差值  // 到这里说明并没有找到对应的差值  deltas[val] = i } //console.log(deltas, \u0026#34;0\u0026#34;)  return -1 }     使用数组存储遍历过待比较的值会有个问题，如果这些值很大的时候，会创建一个长度很大的里面有很多空置的数组，也就是说会创建一个包含很多无意义元素的数组，在某种情况下对浪费巨大的内存。 搞清楚我们要存储的内容，其实最主要的是满足条件的两个值的索引，而又需要很方便的找到这个值，其实可以考虑使用 `Map` 来实现。 \n 比如：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21  // 插值 + map 减少空间浪费  var twoSum = function (numbers, target) { // 可以过滤一层不合法值  // numbers = filterLarger(numbers, target)  const deltas = new Map() const len = numbers.length for (let i = 0; i \u0026lt; len; i++) { const val = numbers[i] const delta = target - numbers[i] if (deltas.has(delta)) { return [deltas.get(delta) + 1, i + 1] } // 保存当前值和它的索引  deltas.set(val, i) } // console.log(deltas, \u0026#34;0\u0026#34;)  return -1 }     执行结果：好像也不怎么理想\n 执行用时：84 ms, 在所有 JavaScript 提交中击败了 36.05%的用户\n 内存消耗：38.1 MB, 在所有 JavaScript 提交中击败了 10.00%的用户\n   提交时间 提交结果 运行时间 内存消耗 语言     几秒前 通过 84 ms 38.1 MB Javascript   1 分钟前 通过 92 ms 38.1 MB Javascript      方案四: 对撞双指针   这种方案是在 leetcode 解题答案中看到的，这位作者说是击败 80%，但实际我试过几次结果其实并不理想，\n 执行用时：92 ms, 在所有 JavaScript 提交中击败了 29.67%的用户\n 内存消耗：37.9 MB, 在所有 JavaScript 提交中击败了 10.00%的用户\n 上代码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21  // 对撞双指针  var twoSum = function (numbers, target) { let i = 0, j = numbers.length - 1 let lval = -1, rval = -1 while (i \u0026lt; j) { ;(lval = numbers[i]), (rval = numbers[j]) if (lval + rval \u0026lt; target) { i++ } else if (lval + rval \u0026gt; target) { j-- } else { return [i + 1, j + 1] } } return -1 }     这种方案还是比较好理解的，因为是有序数组，所以：\n  只要两个数小于 target 说明需要增加值大小，由于 j 是从最右边开始没有可加空 间了，那么只能 i++ 取新的更大的值去弥补空缺。\n  只要两个数大于 target 说明需要减小和的值，但由于在此时左边的值也没减小的 空间了，因此只能 j– 取新的更小的值去剔除多余的值\n  这种方案，不需要另开辟空间，while 里面是 logn 是因为将第一个数右边的所有数通过不断二分排除左边或右边一系列不合法的值。\n 实测结果：\n 执行用时：80 ms, 在所有 JavaScript 提交中击败了 41.01%的用户\n 内存消耗：38 MB, 在所有 JavaScript 提交中击败了 10.00%的用户\n  二分查找(O(nlogn), O(1)) leetcode  先用第一层的 for 固定第一个数，然后在 for 里面使用 while 二分查找第二个数， 第一个 for 是 O(n) 第二个 while 是 logn 因此最后的时间复杂度是 (O(nlogn))。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30  // 二分法[官方]  var twoSum = function (numbers, target) { let len = numbers.length for (let i = 0; i \u0026lt; len; i++) { const first = numbers[i] let left = 0, right = len - 1 while (left \u0026lt;= right) { // 取中间的那个索引值  const mid = Math.ceil((right - left) / 2) + left const val = numbers[mid], delta = target - first if (val === delta) { return [i + 1, mid + 1] } else if (val \u0026gt; delta) { // 如果值大了，排除 mid 右边的所有元素值  right = mid - 1 } else { // 如果小了，排除 mid 左边的所有元素值  left = mid + 1 } } } return -1 }      对撞双指针法(O(n), O(1)) leetcode  如：方案四，采用两端指针分别右移和左移方式来定位唯一解， 这种方案在位移过程中不会出现过滤掉唯一解的情况，因为头端右移的前提是 value \u0026lt; target，需要补值(就算尾端先达到条件，只要值小尾端就不会发生位移)，尾端左移前 提是 value \u0026gt; target ，需要减值(就算头端先达到条件，只要值大尾端就不会发生位 移)，因此保证了左右两端任一一端先达到符合条件的值该值都不会被过滤掉，从而当 两端值都满足条件的时候退出循环。\n    03. 剑指 Offer 11. 旋转数组的最小数字每日  方案一：for 循环直接遍历查找(O(n), O(1))  明确问题含义之后，最简单的方法就是通过遍历找到比前面更小的数即可。\n 问题?：既然 target 前面的数都是升序列表，说明我们只要比较目标 值和数组第一个数就可以了，第一个数到目标值之间的数的比较其实都是多余的。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18  /** ,* @param {number[]} numbers ,* @return {number} ,*/ var minArray = function(numbers) { let min = numbers[0], len = numbers.length if (len === 0) return -1 if (len \u0026lt; 2) return min for (let i = 1; i \u0026lt; len; i++) { let val = numbers[i] if (val \u0026lt; min) { return val } } return min };     结果：\n 执行用时：92 ms, 在所有 JavaScript 提交中击败了 12.99%的用户\n 内存消耗：38 MB, 在所有 JavaScript 提交中击败了 100.00%的用户\n   提交时间 提交结果 运行时间 内存消耗 语言     几秒前 通过 92 ms 38 MB Javascript      方案二 leetcode ：二分法(O(logn))  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33  // 二分法  var minArray = function (numbers) { let len = numbers.length, i = 0, j = len - 1 if (len === 0) return -1 if (len === 1) return numbers[0] if (numbers[0] \u0026gt; numbers[1]) return numbers[1] while ( i \u0026lt; j) { let lVal = numbers[i], rVal = numbers[j] let mid = Math.floor((j - i) / 2) + i, midVal = numbers[mid] // 中间值比右边的值大，说明在旋转的数组范围内，左侧指针右移  if (midVal \u0026gt; rVal) { i = mid + 1 } else if (midVal \u0026lt; rVal) { // 中间值比右边值小，说明在非旋转数组范围内，右侧指针左移  // 但是为了不过滤掉目标值，这里不能 mid - 1，因为我要找的值  // 肯定是在非旋转的数组范围内的  j = mid } else { // 这里指针一步一步左移，是为了应对相同值的情况，即 midVal === rVal 的时候  // 这里为何不需要考虑 i++ 的情况???  // ----\u0026gt; 因为low指针右移的前提是 midVal \u0026gt; rVal，即此时的 midVal 一定是在  // 旋转数组范围内，只要进行 mid + 1 将左侧的值全部过滤掉，就算有相同的值，那一定  // 都还是在旋转数组范围内，因此直接过滤即可。  j-- } } // 最后循环结束的时候，肯定就是最小值的位置  return numbers[i] }     执行用时：112 ms, 在所有 JavaScript 提交中击败了 6.90%的用户\n 内存消耗：38.1 MB, 在所有 JavaScript 提交中击败了 100.00%的用户\n   提交时间 提交结果 运行时间 内存消耗 语言     几秒前 通过 112 ms 38.1 MB Javascript        04. 两数之和   给定一个整数数组 nums 和一个目标值 target，请你在该数组中找出和为目标值的那 两个 整数，并返回他们的数组下标。\n 你可以假设每种输入只会对应一个答案。但是，数组中同一个元素不能使用两遍。\n 这一题和 02. 两数之和 II - 输入有序数组 解法相差不大，唯一不同的是 02 中是输入的有序数组，这里的数组顺序是未知的，可能有序可能乱序。\n 因此解法上的差异从 4 个方案+两个官方方案来分析的话会有如下结果：\n  方案一 两个 for 循环，不需要改动啥，暴力解法不在乎是否有序\n  方案二 二分法，会根据有序数组进行排除，因此在这里不适用，但二分法依旧有用\n  方案三 差值法，依旧适用，该方案不区分是否有序\n  方案四 对撞法，依旧适用\n  … 官方方案二分查找采用了有序数组过滤类似方案二，对撞法就是方案三。\n    ","permalink":"https://www.cheng92.com/algo/algo-leetcode-array-01/","tags":["algorithm,","leetcode,","programming,","javascript,","array"],"title":"Algorithm On Leetcode\u003cArray\u003e 1 (Easy Level)"},{"categories":["vue"],"contents":"  诗号：六道同坠，魔劫万千，引渡如来。  \n  --  insertCssLink(\"https://unpkg.com/element-plus/lib/theme-chalk/index.css\");    TODO ShapeFlags 的溯源和用途？  涉及模块： runtime-core\n  标签(组件)种类(element, component, slot, template)   标签解析时的 TagType 检测\n  element，原生标签类型，默认值(如： div ，结合 options.isNativeTag())\n  component 类型\n  !options.isNativeTag() 类型\n  有 v-is 指令的\n  core component 类型的([Teleport, Suspense, KeepAlive BaseTransition])\n  options.isBuiltInComponent() 指定的类型\n  大写字母开头的标签(如： \u0026lt;Comp\u0026gt;\u0026lt;/Comp\u0026gt;)\n  标签名直接是 component 的(\u0026lt;component\u0026gt;\u0026lt;/component\u0026gt;)\n    slot 类型\n  template 类型\n  这些类型的定义和解析均在 parseTag(context, type, parent) 函数中完成\n 源码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60  function parseTag( context: ParserContext, type: TagType, parent: ElementNode | undefined ): ElementNode { // ...省略，这里我们之关系 tagType  let tagType = ElementTypes.ELEMENT const options = context.options if (!context.inVPre \u0026amp;\u0026amp; !options.isCustomElement(tag)) { const hasVIs = props.some( p =\u0026gt; p.type === NodeTypes.DIRECTIVE \u0026amp;\u0026amp; p.name === \u0026#39;is\u0026#39; ) if (options.isNativeTag \u0026amp;\u0026amp; !hasVIs) { // 1. 如果非原生(isNativeTag 范畴内的)，视为组件类型，优先级最高  if (!options.isNativeTag(tag)) tagType = ElementTypes.COMPONENT } else if ( // 2. 有 v-is 指令的直接视为组件类型  hasVIs || // 3. vue 内置的核心组件\u0026lt;Teleport, Suspense, KeepAlive BaseTransition\u0026gt;  isCoreComponent(tag) || // 4. 内置组件，由开发者定义的内置类型？  (options.isBuiltInComponent \u0026amp;\u0026amp; options.isBuiltInComponent(tag)) || // 5. 标签名以大写字母开头的视为 组件类型  /^[A-Z]/.test(tag) || // 6. 标签名直接是 component 的  tag === \u0026#39;component\u0026#39; ) { tagType = ElementTypes.COMPONENT } if (tag === \u0026#39;slot\u0026#39;) { tagType = ElementTypes.SLOT } else if ( tag === \u0026#39;template\u0026#39; \u0026amp;\u0026amp; props.some(p =\u0026gt; { return ( p.type === NodeTypes.DIRECTIVE \u0026amp;\u0026amp; isSpecialTemplateDirective(p.name) ) }) ) { tagType = ElementTypes.TEMPLATE } } return { type: NodeTypes.ELEMENT, ns, tag, tagType, props, isSelfClosing, children: [], loc: getSelection(context, start), codegenNode: undefined // to be created during transform phase  } }      指令解析过程   parseChildren(context, mode, ancestors) -\u0026gt; parseElement(context, mode) -\u0026gt; 解析出整个 element parseTag(context, type, parent) -\u0026gt; 解析出标签 parseAttributes(context, type) -\u0026gt; 解析所有属性 parseAttribute(context, nameSet) -\u0026gt; 解析单个属性，结果返回到 props 中\n 解析的时候会根据映射关系，将缩写转换成名称。\n 如：\n   abbrev name     : bind   @ on   # slot     处理代码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79  // function: parseAttribute(...)  // v-dir 或 缩写  if (!context.inVPre \u0026amp;\u0026amp; /^(v-|:|@|#)/.test(name)) { // ?: 非捕获组  // 1. (?:^v-([a-z0-9]+))? -\u0026gt; 匹配 v-dir 指令，非贪婪匹配，捕获指令名  // 称([a-z0=9]+)  // 2. (?:(?::|^@|^#)([^\\.]+))? -\u0026gt; 匹配 :,@,#  // 3. (.+)?$ 匹配任意字符  const match = /(?:^v-([a-z0-9]+))?(?:(?::|^@|^#)([^\\.]+))?(.+)?$/i.exec( name ) let arg // ([a-z0-9]+), ([^\\.]+)  if (match[2]) { const startOffset = name.indexOf(match[2]) const loc = getSelection( context, getNewPosition(context, start, startOffset), getNewPosition(context, start, startOffset + match[2].length) ) let content = match[2] let isStatic = true // 静态属性名  // 动态属性名解析  if (content.startsWith(\u0026#39;[\u0026#39;)) { isStatic = false if (!content.endsWith(\u0026#39;]\u0026#39;)) { // 如果是动态属性名，必须是 [varName] 形式  emitError( context, ErrorCodes.X_MISSING_DYNAMIC_DIRECTIVE_ARGUMENT_END ) } content = content.substr(1, content.length - 2) } arg = { type: NodeTypes.SIMPLE_EXPRESSION, content, isStatic, isConstant: isStatic, loc } } // 属性是否被引号包起来  if (value \u0026amp;\u0026amp; value.isQuoted) { const valueLoc = value.loc valueLoc.start.offset++ valueLoc.start.column++ valueLoc.end = advancePositionWithClone(valueLoc.start, value.content) // 取引号内的所有内容  valueLoc.source = valueLoc.source.slice(1, -1) } return { type: NodeTypes.DIRECTIVE, // : -\u0026gt; v-bind, @ -\u0026gt; v-on, # -\u0026gt; v-slot 的缩写  name: match[1] || (name.startsWith(\u0026#39;:\u0026#39;) ? \u0026#39;bind\u0026#39; : name.startsWith(\u0026#39;@\u0026#39;) ? \u0026#39;on\u0026#39; : \u0026#39;slot\u0026#39;), exp: value \u0026amp;\u0026amp; { type: NodeTypes.SIMPLE_EXPRESSION, content: value.content, isStatic: false, isConstant: false, loc: value.loc }, arg, // 修饰符处理, v-bind.m1.m2 -\u0026gt; .m1.m2 -\u0026gt; [\u0026#39;m1\u0026#39;, \u0026#39;m2\u0026#39;]  modifiers: match[3] ? match[3].substr[1].split(\u0026#39;.\u0026#39;) : [], loc } }     属性解析的顺序是，先解析属性值，然后解析指令名称(name)，参数(arg)，修饰符(modifiers)。\n 这里有完整的解析流程图，可以清晰完整的知道属性，指令解析整个过程。\n  RCDATA/CDATA 类型解析   示例：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27  const ast = baseParse(code, { getNamespace: (tag, parent) =\u0026gt; { const ns = parent ? parent.ns : Namespaces.HTML; if (ns === Namespaces.HTML) { // 在 parseChildren while 中将进入  // if (ns !== Namespaces.HTML) {  // node = parseCDATA(context, ancestors);  // }  if (tag === \u0026#34;svg\u0026#34;) { return Namespaces.HTML + 1; } } return ns; }, getTextMode: ({ tag }) =\u0026gt; { if (tag === \u0026#34;textarea\u0026#34;) { // RCDATA 标签内的内容会直接进入 parsText 当做文本解析  return TextModes.RCDATA; } if (tag === \u0026#34;script\u0026#34;) { return TextModes.RAWTEXT; } return TextModes.DATA; }, ...options, onError: spy, });     这两种类型数据的解析关键有几点(详情请移步 🛬🛬🛬 )：\n  重写 getTextMode 在里面对有需要的 tag 类型指定其是什么 mode\n1 2 3 4 5 6 7 8 9 10  function parseElement(...) { // ...  const mode = context.options.getTextMode(element, parent); // RCDATA 模式，它的内容都会被当做文本来处理  // 如：\u0026lt;textarea\u0026gt;\u0026lt;/div\u0026gt;\u0026lt;/textarea\u0026gt; 中的 `\u0026lt;/div\u0026gt;` 只是个文本内容  const children = parseChildren(context, mode, ancestors); // ...  }      重写 getNamespace 告知 parseChildren 走哪个分支\n1 2 3 4 5 6 7 8  else if (s.startsWith(\u0026#34;\u0026lt;![CDATA[\u0026#34;)) { if (ns !== Namespaces.HTML) { node = parseCDATA(context, ancestors); } else { emitError(context, ErrorCodes.CDATA_IN_HTML_CONTENT); node = parseBogusComment(context); } }        一个较完整的 AST 结构：  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124  { \u0026#34;type\u0026#34;:0, // root 节点  \u0026#34;children\u0026#34;:[ // 节点的子组件列表  { \u0026#34;type\u0026#34;:1, // 标签 div  \u0026#34;ns\u0026#34;:0, // html  \u0026#34;tag\u0026#34;:\u0026#34;div\u0026#34;, // 标签名  \u0026#34;tagType\u0026#34;:0, // 标签类型：start-0, end-1  \u0026#34;props\u0026#34;:[ // 标签的属性列表，如： v-bind:keyup.prevent.enter  { // 属性有几个重要的属性：  // 1. name, 指令名称，v- 及缩写(#, @, :) 会转换成属性名称，如：bind  // 2. exp 表达式即=号后边的值，  // 3. arg 参数名，绑定的变量名，可能是动态的  // 4. 修饰符，modifiers  \u0026#34;type\u0026#34;:7, \u0026#34;name\u0026#34;:\u0026#34;bind\u0026#34;, \u0026#34;exp\u0026#34;:{ \u0026#34;type\u0026#34;:4, \u0026#34;content\u0026#34;:\u0026#34;ok\u0026#34;, // 表达式内容，  \u0026#34;isStatic\u0026#34;:false, \u0026#34;isConstant\u0026#34;:false, \u0026#34;loc\u0026#34;:{ \u0026#34;start\u0026#34;:{ \u0026#34;column\u0026#34;:34, \u0026#34;line\u0026#34;:1, \u0026#34;offset\u0026#34;:33 }, \u0026#34;end\u0026#34;:{ \u0026#34;column\u0026#34;:36, \u0026#34;line\u0026#34;:1, \u0026#34;offset\u0026#34;:35 }, \u0026#34;source\u0026#34;:\u0026#34;ok\u0026#34; } }, \u0026#34;arg\u0026#34;:{ // 参数，绑定的事件或变量  \u0026#34;type\u0026#34;:4, \u0026#34;content\u0026#34;:\u0026#34;keyup\u0026#34;, \u0026#34;isStatic\u0026#34;:true, // 支持 v-bind:[varname] 动态属性  \u0026#34;isConstant\u0026#34;:true, \u0026#34;loc\u0026#34;:{ \u0026#34;start\u0026#34;:{ \u0026#34;column\u0026#34;:13, \u0026#34;line\u0026#34;:1, \u0026#34;offset\u0026#34;:12 }, \u0026#34;end\u0026#34;:{ \u0026#34;column\u0026#34;:18, \u0026#34;line\u0026#34;:1, \u0026#34;offset\u0026#34;:17 }, \u0026#34;source\u0026#34;:\u0026#34;keyup\u0026#34; } }, \u0026#34;modifiers\u0026#34;:[ \u0026#34;prevent\u0026#34;, \u0026#34;enter\u0026#34; ], \u0026#34;loc\u0026#34;:{ \u0026#34;start\u0026#34;:{ \u0026#34;column\u0026#34;:6, \u0026#34;line\u0026#34;:1, \u0026#34;offset\u0026#34;:5 }, \u0026#34;end\u0026#34;:{ \u0026#34;column\u0026#34;:37, \u0026#34;line\u0026#34;:1, \u0026#34;offset\u0026#34;:36 }, \u0026#34;source\u0026#34;:\u0026#34;v-bind:keyup.prevent.enter=\u0026#34;ok\u0026#34;\u0026#34; } } ], \u0026#34;isSelfClosing\u0026#34;:false, \u0026#34;children\u0026#34;:[ // 如果 \u0026lt;div\u0026gt;...\u0026lt;/div\u0026gt; 还有内容这里会递归解析出子节点 ast  ], \u0026#34;loc\u0026#34;:{ \u0026#34;start\u0026#34;:{ \u0026#34;column\u0026#34;:1, \u0026#34;line\u0026#34;:1, \u0026#34;offset\u0026#34;:0 }, \u0026#34;end\u0026#34;:{ \u0026#34;column\u0026#34;:44, \u0026#34;line\u0026#34;:1, \u0026#34;offset\u0026#34;:43 }, \u0026#34;source\u0026#34;:\u0026#34;\u0026lt;div v-bind:keyup.prevent.enter=\u0026#34;ok\u0026#34;\u0026gt;\u0026lt;/div\u0026gt;\u0026#34; } } ], \u0026#34;loc\u0026#34;:{ \u0026#34;start\u0026#34;:{ \u0026#34;column\u0026#34;:1, \u0026#34;line\u0026#34;:1, \u0026#34;offset\u0026#34;:0 }, \u0026#34;end\u0026#34;:{ \u0026#34;column\u0026#34;:44, \u0026#34;line\u0026#34;:1, \u0026#34;offset\u0026#34;:43 }, \u0026#34;source\u0026#34;:\u0026#34;\u0026lt;div v-bind:keyup.prevent.enter=\u0026#34;ok\u0026#34;\u0026gt;\u0026lt;/div\u0026gt;\u0026#34; }, \u0026#34;helpers\u0026#34;:[ ], \u0026#34;components\u0026#34;:[ ], \u0026#34;directives\u0026#34;:[ ], \u0026#34;hoists\u0026#34;:[ ], \u0026#34;imports\u0026#34;:[ ], \u0026#34;cached\u0026#34;:0, \u0026#34;temps\u0026#34;:0 }      辅助代码   这章主要是一些辅助代码。\nparseUrl(url)   parseUrl 实现模拟：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22  const { parse: uriParse } = require(\u0026#39;url\u0026#39;) function parseUrl(url) { const firstChar = url.charAt(0) if (firstChar === \u0026#39;~\u0026#39;) { const secondChar = url.charAt(1) url = url.slice(secondChar === \u0026#39;/\u0026#39; ? 2 : 1) } return parseUriParts(url) } function parseUriParts(urlString) { // A TypeError is thrown if urlString is not a string  // @see https://nodejs.org/api/url.html#url_url_parse_urlstring_parsequerystring_slashesdenotehost  return uriParse(typeof urlString === \u0026#39;string\u0026#39; ? urlString : \u0026#39;\u0026#39;, false, true) } console.log(\u0026#39;1. ~/ccc/tmp -\u0026gt; \u0026#39;, parseUrl(\u0026#39;~/ccc/tmp\u0026#39;)) console.log(\u0026#39;2. ~ccc/tmp/test.png -\u0026gt; \u0026#39;, parseUrl(\u0026#39;~ccc/tmp/test.png\u0026#39;)) console.log(\u0026#39;3. /ccc/tmp -\u0026gt;\u0026#39;, parseUrl(\u0026#39;/ccc/tmp\u0026#39;)) console.log(\u0026#39;4. @ccc/tmp -\u0026gt;\u0026#39;, parseUrl(\u0026#39;@ccc/tmp\u0026#39;)) console.log(\u0026#39;5. ~@svg/file.svg#fragment -\u0026gt; \u0026#39;, parseUrl(\u0026#39;~@svg/file.svg#fragment\u0026#39;)) console.log(\u0026#39;6. https://www.cheng92.com -\u0026gt;\u0026#39;, parseUrl(\u0026#39;https://www.cheng92.com\u0026#39;))    1. ~/ccc/tmp -\u0026gt; Url { protocol: null, slashes: null, auth: null, host: null, port: null, hostname: null, hash: null, search: null, query: null, pathname: \u0026#39;ccc/tmp\u0026#39;, path: \u0026#39;ccc/tmp\u0026#39;, href: \u0026#39;ccc/tmp\u0026#39; } 2. ~ccc/tmp/test.png -\u0026gt; Url { protocol: null, slashes: null, auth: null, host: null, port: null, hostname: null, hash: null, search: null, query: null, pathname: \u0026#39;ccc/tmp/test.png\u0026#39;, path: \u0026#39;ccc/tmp/test.png\u0026#39;, href: \u0026#39;ccc/tmp/test.png\u0026#39; } 3. /ccc/tmp -\u0026gt; Url { protocol: null, slashes: null, auth: null, host: null, port: null, hostname: null, hash: null, search: null, query: null, pathname: \u0026#39;/ccc/tmp\u0026#39;, path: \u0026#39;/ccc/tmp\u0026#39;, href: \u0026#39;/ccc/tmp\u0026#39; } 4. @ccc/tmp -\u0026gt; Url { protocol: null, slashes: null, auth: null, host: null, port: null, hostname: null, hash: null, search: null, query: null, pathname: \u0026#39;@ccc/tmp\u0026#39;, path: \u0026#39;@ccc/tmp\u0026#39;, href: \u0026#39;@ccc/tmp\u0026#39; } 5. ~@svg/file.svg#fragment -\u0026gt; Url { protocol: null, slashes: null, auth: null, host: null, port: null, hostname: null, hash: \u0026#39;#fragment\u0026#39;, search: null, query: null, pathname: \u0026#39;@svg/file.svg\u0026#39;, path: \u0026#39;@svg/file.svg\u0026#39;, href: \u0026#39;@svg/file.svg#fragment\u0026#39; } 6. https://www.cheng92.com -\u0026gt; Url { protocol: \u0026#39;https:\u0026#39;, slashes: true, auth: null, host: \u0026#39;www.cheng92.com\u0026#39;, port: null, hostname: \u0026#39;www.cheng92.com\u0026#39;, hash: null, search: null, query: null, pathname: \u0026#39;/\u0026#39;, path: \u0026#39;/\u0026#39;, href: \u0026#39;https://www.cheng92.com/\u0026#39; } undefined      ","permalink":"https://www.cheng92.com/vue/vue3-source-picking-shell/","tags":["vue,","vue3,","vuenext"],"title":"Vue3.0源码系列 -- 知识点及问题汇总"},{"categories":["emacs"],"contents":"  Emacs相关中文问题以及解决方案\n 在 doom-emacs 中使用 spacemacs 的 layers\n Doom-emacs   感觉 Spacemacs 用起来还是有点卡，且启动慢，用久了更卡了，只能怪自己太菜了，所以今天开始尝试转向 doom-emacs\n 配置列表：\n  https://github.com/rschmukler/doom.d\n  https://github.com/forrestchang/.doom.d\n  https://rgoswami.me/dotdoom/config.html\n  https://github.com/hlissner/doom-emacs-private\n  https://github.com/sunnyhasija/Academic-Doom-Emacs-Config\n  https://emacs.nasy.moe/\n  主题：https://github.com/hlissner/emacs-doom-themes\n  https://github.com/tecosaur/emacs-config/blob/master/config.org\n  常用按键     key function     \u0026lt;f12\u0026gt; smerge-vc-next-conflict   \u0026lt;f11\u0026gt; +vc/smerge-hydra/body   \u0026lt;f10\u0026gt; ebuku   C-s-, parrot previous   C-s-. parrot next   SPC * +default/search-project-for-symbol-at-point   SPC \u0026#39; ivy-resume   SPC , +ivy/switch-workspace-buffer   SPC . counsel-find-file, find file in current dir   SPC / +default/search-project   SPC \u0026lt; ivy-switch-buffer   SPC RET counsel-bookmark   SPC v o ivy-pop-view   SPC v p ivy-push-view   SPC a l leetcode   SPC b m set bookmark   SPC b M delete bookmark      Base Configuration/Operation  重新加载配置     key mode function     gr evil 选中模式下 执行选中代码   C-x C-e - eval-last-sexp   SPC c e - M-x +eval/buffer-or-region        packages  ebuku, browser bookmarks management   install buku: https://github.com/jarun/buku\n  web-mode  hydra:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48  (defhydra hydra-web-mode (:color blue :quit-key \u0026#34;q\u0026#34; :hint nil :columns 4) \u0026#34; ^Element^ ^Element^ ^Attribute^ ^Block\u0026amp;Other ^^^^^^^^--------------------------------------------------------------------------------------------- _a_ : Select content _r_ : Rename _0_ : Start _\u0026lt;_ : Begin _b_ : Start _s_ : Select _9_ : End _\u0026gt;_ : End _C_ : Clone _t_ : Move Down _*_ : Insert _-_ : Select _e_ : End _u_ : Parent _N_ : Next _f_ : Fold/unfold children _v_ : Delete without content _P_ : Previous _i_ : Insert _w_ : Wrap Element _S_ : Select _I_ : Insert cursor _t_ : Last(open/close) _K_ : Delete _k_ : Delete _T_ : Next(open/close) _n_ : Next _._ : Wrap Markup _p_ : Previous \u0026#34; (\u0026#34;a\u0026#34; web-mode-element-content-select) (\u0026#34;b\u0026#34; web-mode-element-beginning) (\u0026#34;e\u0026#34; web-mode-element-end) (\u0026#34;f\u0026#34; web-mode-element-children-fold-or-unfold) (\u0026#34;F\u0026#34; web-mode-fold-unfold) (\u0026#34;i\u0026#34; web-mode-element-insert) (\u0026#34;I\u0026#34; web-mode-element-insert-at-point) (\u0026#34;k\u0026#34; web-mode-element-kill) (\u0026#34;m\u0026#34; web-mode-element-mute-blanks) (\u0026#34;n\u0026#34; web-mode-element-next :exit nil :color \u0026#34;pink\u0026#34;) (\u0026#34;p\u0026#34; web-mode-element-previous :exit nil :color \u0026#34;pink\u0026#34;) (\u0026#34;r\u0026#34; web-mode-element-rename) (\u0026#34;s\u0026#34; web-mode-element-select) (\u0026#34;t\u0026#34; web-mode-element-transpose) (\u0026#34;u\u0026#34; web-mode-element-parent :exit nil :color \u0026#34;pink\u0026#34;) (\u0026#34;v\u0026#34; web-mode-element-vanish) (\u0026#34;w\u0026#34; web-mode-element-wrap) (\u0026#34;t\u0026#34; web-mode-tag-previous :exit nil :color \u0026#34;pink\u0026#34;) (\u0026#34;T\u0026#34; web-mode-tag-next :exit nil :color \u0026#34;pink\u0026#34;) (\u0026#34;.\u0026#34; emmet-wrap-with-markup) ;; attribute (\u0026#34;0\u0026#34; web-mode-attribute-beginning) (\u0026#34;9\u0026#34; web-mode-attribute-end) (\u0026#34;*\u0026#34; web-mode-attribute-insert) (\u0026#34;K\u0026#34; web-mode-attribute-kill) (\u0026#34;N\u0026#34; web-mode-attribute-next :exit nil :color \u0026#34;pink\u0026#34;) (\u0026#34;P\u0026#34; web-mode-attribute-previous :exit nil :color \u0026#34;pink\u0026#34;) (\u0026#34;S\u0026#34; web-mode-attribute-select) ;; block (\u0026#34;\u0026lt;\u0026#34; web-mode-block-next :exit nil :color \u0026#34;pink\u0026#34;) (\u0026#34;\u0026gt;\u0026#34; web-mode-block-previous :exit nil :color \u0026#34;pink\u0026#34;) (\u0026#34;-\u0026#34; web-mode-block-select) )        key functions desc     [t web-mode-tag-previous 上一个标签(包含开闭标签)   ]t web-mode-tag-next 下一个标签(包含开闭标签)     z     z. emmet-wrap-with-markup      C-c     C-s web-mode-snippet-insert 插入snippets   C-f web-mode-fold-or-unfold -     C-c C-d DOM 操作    d web-mode-dom-errors-show 显示DOM错误信息，标签是否闭合等等     C-c C-e element操作    a web-mode-element-content-select 选择标签内容   b web-mode-element-beginning -   e web-mode-element-end -   f web-mode-element-children-fold-or-unfold fold/unfold children element   i web-mode-element-insert 插入标签根据输入标签名   I web-mode-element-insert-at-point 根据光标处的名字插入标签   k web-mode-element-kill 删除当前标签   m web-mode-element-mute-blanks ?   n web-mode-element-next    p web-mode-element-previous -   r web-mode-element-rename    s web-mode-element-select 选中标签及其内容   t web-mode-element-transpose 将当前标签移到下一个标签后面   u web-mode-element-parent -   v web-mode-element-vanish 删除标签只保留标签内容，如： \u0026lt;div\u0026gt;{{xx}}\u0026lt;/div\u0026gt; 变成： {{xx}}   w web-mode-element-wrap wrap with tag     C-c C-b block 操作    n web-mode-block-next 下一个block   p web-mode-block-previous 上一个 block   s web-mode-block-select 选中当前block     C-c C-a attribute 操作    b web-mode-attribute-beginning 定位到属性开始   e web-mode-attribute-end 定位到属性结尾   i web-mode-attribute-insert 插入属性   k web-mode-attribute-kill 删除属性   n web-mode-attribute-next    p web-mode-attribute-previous    s web-mode-attribute-select    t web-mode-attribute-transpose      web-mode Keybindings     lsp-mode   leetcode   https://github.com/kaiwk/leetcode.el\n1 2 3 4 5 6 7 8 9  (:prefix (\u0026#34;l\u0026#34; . \u0026#34;Leetcode\u0026#34;) \u0026#34;l\u0026#34; #\u0026#39;leetcode \u0026#34;s\u0026#34; #\u0026#39;leetcode-submit \u0026#34;t\u0026#34; #\u0026#39;leetcode-try \u0026#34;r\u0026#34; #\u0026#39;leetcode-refresh \u0026#34;R\u0026#34; #\u0026#39;leetcode-refresh-fetch \u0026#34;f\u0026#34; #\u0026#39;leetcode-set-filter-difficulty \u0026#34;.\u0026#34; #\u0026#39;leetcode-reset-filter )     keybinds:\n   key function     SPC a l l leetcode   SPC a l s leetcode-submit   SPC a l t leetcode-try   SPC a l T leetcode-set-filter-tags   SPC a l r leetcode-refresh   SPC a l R leetcode-refresh-fetch   SPC a l f leetcode-set-filter-difficulty   SPC a l . leetcode-reset-filter   SPC a l x leetcode-set-filter-regex   SPC a l p leetcode-show-current-problem     hydra/body:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  (defhydra hydra-leetcode (:columns 3) \u0026#34; ^^^^Leetcode^^^^ ---------------------------------------------------------------------- \u0026#34; (\u0026#34;s\u0026#34; leetcode-submit \u0026#34;sumbit\u0026#34;) (\u0026#34;t\u0026#34; leetcode-try \u0026#34;try\u0026#34;) (\u0026#34;r\u0026#34; leetcode-refresh \u0026#34;refresh\u0026#34;) (\u0026#34;R\u0026#34; leetcode-refresh-fetch \u0026#34;refresh fetch\u0026#34;) (\u0026#34;s\u0026#34; leetcode-show-current-problem \u0026#34;show current problem\u0026#34;) (\u0026#34;f\u0026#34; leetcode-set-filter-difficulty \u0026#34;filter by difficulty\u0026#34;) (\u0026#34;g\u0026#34; leetcode-set-filter-tag \u0026#34;filter by tag\u0026#34;) (\u0026#34;e\u0026#34; leetcode-set-filter-regex \u0026#34;filter by regexp\u0026#34;) (\u0026#34;0\u0026#34; leetcode-reset-filter \u0026#34;reset filter\u0026#34;) )      go-mode   install: https://www.mdeditor.tw/pl/2KAi\n  no such file or directory gocode ?\n    smart-hungry-delete   https://github.com/hrehfeld/emacs-smart-hungry-delete\n1 2 3 4 5 6 7  (use-package smart-hungry-delete :ensure t :bind ((\u0026#34;\u0026lt;backspace\u0026gt;\u0026#34; . smart-hungry-delete-backward-char) (\u0026#34;C-d\u0026#34; . smart-hungry-delete-forward-char)) :defer nil ;; dont defer so we can add our functions to hooks  :config (smart-hungry-delete-add-default-hooks) )      string-inflection 代码风格切换(python/java/ruby/…)   github link-\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  (defun gcl/string-inflection-cycle-auto () \u0026#34;switching by major-mode\u0026#34; (interactive) (cond ;; for emacs-lisp-mode ((eq major-mode \u0026#39;emacs-lisp-mode) (string-inflection-all-cycle)) ;; for python ((eq major-mode \u0026#39;python-mode) (string-inflection-python-style-cycle)) ;; for java ((eq major-mode \u0026#39;java-mode) (string-inflection-java-style-cycle)) (t ;; default (string-inflection-java-style-cycle))))      parrot(C-s)   https://github.com/dp12/parrot\n rotate text，在约定的几个字符串之间来回切换。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39  (setq parrot-rotate-dict \u0026#39;( (:rot (\u0026#34;alpha\u0026#34; \u0026#34;beta\u0026#34;) :caps t :lower nil) ;; =\u0026gt; rotations are \u0026#34;Alpha\u0026#34; \u0026#34;Beta\u0026#34; (:rot (\u0026#34;snek\u0026#34; \u0026#34;snake\u0026#34; \u0026#34;stawp\u0026#34;)) ;; =\u0026gt; rotations are \u0026#34;snek\u0026#34; \u0026#34;snake\u0026#34; \u0026#34;stawp\u0026#34; (:rot (\u0026#34;yes\u0026#34; \u0026#34;no\u0026#34;) :caps t :upcase t) ;; =\u0026gt; rotations are \u0026#34;yes\u0026#34; \u0026#34;no\u0026#34;, \u0026#34;Yes\u0026#34; \u0026#34;No\u0026#34;, \u0026#34;YES\u0026#34; \u0026#34;NO\u0026#34; (:rot (\u0026#34;\u0026amp;\u0026#34; \u0026#34;|\u0026#34;)) ;; =\u0026gt; rotations are \u0026#34;\u0026amp;\u0026#34; \u0026#34;|\u0026#34; ;; default dictionary starts here (\u0026#39;v\u0026#39;) (:rot (\u0026#34;begin\u0026#34; \u0026#34;end\u0026#34;) :caps t :upcase t) (:rot (\u0026#34;enable\u0026#34; \u0026#34;disable\u0026#34;) :caps t :upcase t) (:rot (\u0026#34;enter\u0026#34; \u0026#34;exit\u0026#34;) :caps t :upcase t) (:rot (\u0026#34;forward\u0026#34; \u0026#34;backward\u0026#34;) :caps t :upcase t) (:rot (\u0026#34;front\u0026#34; \u0026#34;rear\u0026#34; \u0026#34;back\u0026#34;) :caps t :upcase t) (:rot (\u0026#34;get\u0026#34; \u0026#34;set\u0026#34;) :caps t :upcase t) (:rot (\u0026#34;high\u0026#34; \u0026#34;low\u0026#34;) :caps t :upcase t) (:rot (\u0026#34;in\u0026#34; \u0026#34;out\u0026#34;) :caps t :upcase t) (:rot (\u0026#34;left\u0026#34; \u0026#34;right\u0026#34;) :caps t :upcase t) (:rot (\u0026#34;min\u0026#34; \u0026#34;max\u0026#34;) :caps t :upcase t) (:rot (\u0026#34;on\u0026#34; \u0026#34;off\u0026#34;) :caps t :upcase t) (:rot (\u0026#34;prev\u0026#34; \u0026#34;next\u0026#34;)) (:rot (\u0026#34;start\u0026#34; \u0026#34;stop\u0026#34;) :caps t :upcase t) (:rot (\u0026#34;true\u0026#34; \u0026#34;false\u0026#34;) :caps t :upcase t) (:rot (\u0026#34;\u0026amp;\u0026amp;\u0026#34; \u0026#34;||\u0026#34;)) (:rot (\u0026#34;==\u0026#34; \u0026#34;!=\u0026#34;)) (:rot (\u0026#34;.\u0026#34; \u0026#34;-\u0026gt;\u0026#34;)) (:rot (\u0026#34;if\u0026#34; \u0026#34;else\u0026#34; \u0026#34;elif\u0026#34;)) (:rot (\u0026#34;ifdef\u0026#34; \u0026#34;ifndef\u0026#34;)) (:rot (\u0026#34;int8_t\u0026#34; \u0026#34;int16_t\u0026#34; \u0026#34;int32_t\u0026#34; \u0026#34;int64_t\u0026#34;)) (:rot (\u0026#34;uint8_t\u0026#34; \u0026#34;uint16_t\u0026#34; \u0026#34;uint32_t\u0026#34; \u0026#34;uint64_t\u0026#34;)) (:rot (\u0026#34;1\u0026#34; \u0026#34;2\u0026#34; \u0026#34;3\u0026#34; \u0026#34;4\u0026#34; \u0026#34;5\u0026#34; \u0026#34;6\u0026#34; \u0026#34;7\u0026#34; \u0026#34;8\u0026#34; \u0026#34;9\u0026#34; \u0026#34;10\u0026#34;)) (:rot (\u0026#34;1st\u0026#34; \u0026#34;2nd\u0026#34; \u0026#34;3rd\u0026#34; \u0026#34;4th\u0026#34; \u0026#34;5th\u0026#34; \u0026#34;6th\u0026#34; \u0026#34;7th\u0026#34; \u0026#34;8th\u0026#34; \u0026#34;9th\u0026#34; \u0026#34;10th\u0026#34;)) ))     配置：\n1 2 3 4 5 6 7 8 9 10 11 12 13  (use-package! parrot :init (progn (define-key global-map (kbd \u0026#34;C-s ,\u0026#34;) \u0026#39;parrot-rotate-prev-word-at-point) (define-key global-map (kbd \u0026#34;C-s .\u0026#34;) \u0026#39;parrot-rotate-next-word-at-point)) :config (parrot-mode) (setq parrot-ratate-dict \u0026#39;( (:rot (\u0026#34;alpha\u0026#34; \u0026#34;beta\u0026#34;) :caps t :lower nil) ;; =\u0026gt; Alpha, Beta (:rot (\u0026#34;yes\u0026#34; \u0026#34;no\u0026#34;) :caps t :upcase t) ;; =\u0026gt; yes,no,No,YES,NO (:rot (\u0026#34;\u0026amp;\u0026#34; \u0026#34;|\u0026#34;)) )))        Keybindings  所有常用按键均通过 hydra 注释方式展现，方便查询：\ntest  key 绑定函数：\n  define-key\n  global-set-key\n  map!\n  undefined-key!\n  define-key!\n  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64  ;; bind a global key (global-set-key (kbd \u0026#34;C-x y\u0026#34;) #\u0026#39;do-something) (map! \u0026#34;C-x y\u0026#34; #\u0026#39;do-something) ;; bind a key on a keymap (define-key emacs-lisp-mode-map (kbd \u0026#34;C-c p\u0026#34;) #\u0026#39;do-something) (map! :map emacs-lisp-mode-map \u0026#34;C-c p\u0026#34; #\u0026#39;do-something) ;; unbind a key defined elsewhere (define-key lua-mode-map (kbd \u0026#34;SPC m b\u0026#34;) nil) (map! :map lua-mode-map \u0026#34;SPC m b\u0026#34; nil) ;; bind multiple keys (global-set-key (kbd \u0026#34;C-x x\u0026#34;) #\u0026#39;do-something) (global-set-key (kbd \u0026#34;C-x y\u0026#34;) #\u0026#39;do-something-else) (global-set-key (kbd \u0026#34;C-x z\u0026#34;) #\u0026#39;do-another-thing) (map! \u0026#34;C-x x\u0026#34; #\u0026#39;do-something \u0026#34;C-x y\u0026#34; #\u0026#39;do-something-else \u0026#34;C-x z\u0026#34; #\u0026#39;do-another-thing) ;; bind global keys in normal mode (evil-define-key* \u0026#39;normal \u0026#39;global (kbd \u0026#34;C-x x\u0026#34;) #\u0026#39;do-something (kbd \u0026#34;C-x y\u0026#34;) #\u0026#39;do-something-else (kbd \u0026#34;C-x z\u0026#34;) #\u0026#39;do-another-thing) (map! :n \u0026#34;C-x x\u0026#34; #\u0026#39;do-something :n \u0026#34;C-x y\u0026#34; #\u0026#39;do-something-else :n \u0026#34;C-x z\u0026#34; #\u0026#39;do-another-thing) ;; or on a deferred keymap (evil-define-key \u0026#39;normal emacs-lisp-mode-map (kbd \u0026#34;C-x x\u0026#34;) #\u0026#39;do-something (kbd \u0026#34;C-x y\u0026#34;) #\u0026#39;do-something-else (kbd \u0026#34;C-x z\u0026#34;) #\u0026#39;do-another-thing) (map! :map emacs-lisp-mode-map :n \u0026#34;C-x x\u0026#34; #\u0026#39;do-something :n \u0026#34;C-x y\u0026#34; #\u0026#39;do-something-else :n \u0026#34;C-x z\u0026#34; #\u0026#39;do-another-thing) ;; or multiple maps (dolist (map (list emacs-lisp-mode go-mode-map ivy-minibuffer-map)) (evil-define-key \u0026#39;(normal insert) map \u0026#34;a\u0026#34; #\u0026#39;a \u0026#34;b\u0026#34; #\u0026#39;b \u0026#34;c\u0026#34; #\u0026#39;c)) (map! :map (emacs-lisp-mode go-mode-map ivy-minibuffer-map) :ni \u0026#34;a\u0026#34; #\u0026#39;a :ni \u0026#34;b\u0026#34; #\u0026#39;b :ni \u0026#34;c\u0026#34; #\u0026#39;c) ;; or in multiple states (order of states doesn\u0026#39;t matter) (evil-define-key* \u0026#39;(normal visual) emacs-lisp-mode-map (kbd \u0026#34;C-x x\u0026#34;) #\u0026#39;do-something) (evil-define-key* \u0026#39;insert emacs-lisp-mode-map (kbd \u0026#34;C-x x\u0026#34;) #\u0026#39;do-something-else) (evil-define-key* \u0026#39;(visual normal insert emacs) emacs-lisp-mode-map (kbd \u0026#34;C-x z\u0026#34;) #\u0026#39;do-another-thing) (map! :map emacs-lisp-mode :nv \u0026#34;C-x x\u0026#34; #\u0026#39;do-something ; normal+visual :i \u0026#34;C-x y\u0026#34; #\u0026#39;do-something-else ; insert :vnie \u0026#34;C-x z\u0026#34; #\u0026#39;do-another-thing) ; visual+normal+insert+emacs ;; You can nest map! calls: (evil-define-key* \u0026#39;(normal visual) emacs-lisp-mode-map (kbd \u0026#34;C-x x\u0026#34;) #\u0026#39;do-something) (evil-define-key* \u0026#39;normal go-lisp-mode-map (kbd \u0026#34;C-x x\u0026#34;) #\u0026#39;do-something-else) (map! (:map emacs-lisp-mode :nv \u0026#34;C-x x\u0026#34; #\u0026#39;do-something) (:map go-lisp-mode :n \u0026#34;C-x x\u0026#34; #\u0026#39;do-something-else))      所有按键表   C-Control, s-Command, S-Shift, M-option/alt\n   prefix key function mode description     g 字母 g       ~~        z 字母 z       - sp-splice-sexp  取消括号     C Control       ( sp-backward-slurp-sexp  左括号左移    ) sp-forward-slurp-sexp  右括号右移    + cnfonts-increase-fontsize  -    - cnfonts-decrease-fontsize  -     M Option/Alt       u upcase-word      l downcase-word      c capitalize-word       s Command       \u0026lt; move-text-up      \u0026gt; move-text-down      ( sp-forward-barf-sexp  左括号右移    ) sp-backward-barf-sexp  右括号左移    q +workspace/kill-session-and-quit  save-buffers-kill-terminal     C-s        , parrot-rotate-prev-word-at-point  -    . parrot-rotate-next-word-at-point  -     C-c        d insert-current-date-time      t insert-current-time      r vr/replace  -    q vr/query-replace      u crux-view-url      U browse-url-at-point       C-S Control + Shift        SPC        b f osx-lib-reveal-in-finder  -    b O kill-other-buffers  -    c e +eval/buffer-or-region  -    l m lsp-ui-imenu  -    l t treemacs  -    n n org-capture      n N org-goto-capture      m r intant-rename-tag web-mode 同步修改标签名    w - evil-window-split  水平分割    w v evil-window-vsplit  垂直分割      主面板  1 2 3 4 5 6 7 8 9 10 11 12 13 14  (defhydra hydra-main (:color blue :exit t :hint nil) \u0026#34; all hydra apps: ------------------------------------------------------------------ [_a_] Tip [_h_] Launcher [_m_] Multiple Cursors [_w_] Window [_t_] Text Zoom [_o_] Org Agenda \u0026#34; (\u0026#34;a\u0026#34; hydra-tip/body) (\u0026#34;h\u0026#34; hydra-launcher/body) (\u0026#34;m\u0026#34; hydra-multiple-cursors/body) (\u0026#34;w\u0026#34; +hydra/window-nav/body) (\u0026#34;t\u0026#34; +hydra/text-zoom/body) (\u0026#34;o\u0026#34; hydra-org-agenda-view/body) )      提示面板入口  1 2 3 4 5 6 7 8 9 10 11 12  ;; 提示面板 (defhydra hydra-tip (:color blue :hint nil) \u0026#34; Tips for modes or kyes. ------------------------------------------------------------------ [_m_] M-Cursors [_e_] Evil [_u_] 常用 [_q_] Quit \u0026#34; (\u0026#34;m\u0026#34; hydra-tip-mcursors/body) (\u0026#34;u\u0026#34; hydra-tip-useful/body) (\u0026#34;e\u0026#34; hydra-tip-evil/body) (\u0026#34;q\u0026#34; nil) )      常用按键提示面板  1 2 3 4 5 6 7 8 9 10 11 12 13 14  (defhydra hydra-tip-useful (:color blue :hint nil) \u0026#34; 常用操作提示(C-Control, s-Command, M-option/alt)： ------------------------------------------------------------------ 括号操作 文本操作 搜索/替换 ------------------------------------------------------------------ [C-(] 左括号左移 [s-\u0026lt;] move-text-up [C-c r] 替换 [C-)] 右括号右移 [s-\u0026gt;] move-text-down [C-c q] 搜索替换 [s-)] 左括号右移 [C-+] 放大字体 [s-(] 右括号左移 [C--] 缩小字体 [z--] 取消括号 [M-u] 大写化 [M-l] 小写化 [M-c] 首字母大写 \u0026#34;)      SPC 开始按键提示面板  1 2 3 4 5 6 7 8 9 10 11  (defhydra hydra-tip-spc (:hint nil) \u0026#34; SPC 按键列表 ------------------------------------------------------------------ \u0026lt;a~l\u0026gt; ------------------------------------------------------------------ [SPC b O] kill-other-buffers [SPC l m] lsp-ui-imenu [SPC l t] treemacs \u0026#34;)      Org-mode 按键提示面板  1 2 3 4 5 6 7 8 9 10 11  (defhydra hydra-tip-org (:hint nil) \u0026#34; Org-mode 按键提示 ------------------------------------------------------------------ Table 操作 跳转 ------------------------------------------------------------------ [M-l] 列右移 [gj] 上一个同级标题 [M-h] 列左移 [gk] 下一个同级标题 [M-j] 行下移 [gh] 父级标题 [M-k] 行上移 \u0026#34;)      evil-mode按键提示面板  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51  (defhydra hydra-tip-evil (:hint nil) \u0026#34; evil 模式下操作命令提示。 ------------------------------------------------------------------ 符号/字母 \u0026lt;z\u0026gt; ------------------------------------------------------------------ [+] 数字+1 [z-] 取消括号 [-] 数字-1 [z.] wrap 标签 [K] 查文档 [za] fold 所有 [s/S] wrap 字符(选中) [zo] open 当前 [s/S] 文件内字符定位 [zj] fold 下一个 [f/F] 行内字符定位 [zk] fold 上一个 [t/T] 行内字符定位 [zr] open所有 [;] 向后重复查找 [zm] close所有 [,] 向前重复查找 [zt] 当前行定位到顶部 [zx] kill 当前buffer ------------------------------------------------------------------ \u0026lt;g\u0026gt; ------------------------------------------------------------------ [_g[_] 函数开头 [_gd_] 查找定义(definition) [_g0_] 行首 [_g]_] 函数结尾 [_gD_] 查找引用(reference) [_gsj_] 按字符往后定位 [_gr_] 执行选中内容 [_gss_] 按两个字符定位 [_gt_] 切换下一个workspace [_gs/_] 按单个字符定位 [_gx_] 交换两个选中区内容 [_gsk_] 按字符往前定位 [_gf_] 查找光标处名称的文件 [_gs[[_] 按段首向前定位 [_gs[]_] 按断尾向前定位 [_gs]]_] 按段首向后定位 [_gs][_] 按断尾向后定位 \u0026#34; (\u0026#34;g[\u0026#34; beginning-of-defun) (\u0026#34;g]\u0026#34; end-of-defun) (\u0026#34;g0\u0026#34; evil-beginning-of-visual-line) (\u0026#34;gd\u0026#34; xref-find-definitions) (\u0026#34;gD\u0026#34; xref-find-references) (\u0026#34;gb\u0026#34; xref-pop-marker-stack) (\u0026#34;gr\u0026#34; +eval:region) (\u0026#34;gjj\u0026#34; dumb-jump-go) (\u0026#34;gjb\u0026#34; dumb-jump-back) (\u0026#34;gt\u0026#34; +workspace:switch-next) (\u0026#34;gx\u0026#34; evil-exchange) (\u0026#34;gf\u0026#34; +lookup/file) (\u0026#34;gss\u0026#34; evil-avy-goto-char-2) (\u0026#34;gs/\u0026#34; evil-avy-goto-char-timer) (\u0026#34;gsj\u0026#34; evilem-motion-next-line) (\u0026#34;gsk\u0026#34; evilem-motion-previous-line) (\u0026#34;gs[[\u0026#34; evilem-motion-backward-section-begin) (\u0026#34;gs[]\u0026#34; evilem-motion-backward-section-end) (\u0026#34;gs][\u0026#34; evilem-motion-forward-section-end) (\u0026#34;gs]]\u0026#34; evilem-motion-forward-section-begin) )      multiple cursors(C-S-c, Control-Shift-c)     key function description     C-\u0026gt; mc/mark-next-like-this -   C-\u0026lt; mc/mark-previous-like-this -   C-c C-\u0026lt; mc/mark-all-like-this -   C-S-c C-S-c mc/edit-lines S: Shift Key   C-S-c 0 mc/insert-numbers -   C-S-c 1 mc/insert-letters -   C-S-c s mc/mark-all-in-region -   C-S-c S mc/mark-all-in-region-regexp -   C-j - insert newline    1 2 3 4 5 6 7 8 9 10  (defhydra hydra-tip-mcursors (:color blue :hint nil) \u0026#34; Multiple Cursors Mode Tip(C-Control, S-Shift). [C-S-c 0] insert numbers [C-\u0026gt;] next [C-S-c 1] insert letters [C-\u0026gt;] previous [C-S-c s] region [C-c C-\u0026lt;] all [C-S-c S] region regexp [C-S-c C-S-c] edit lines \u0026#34;)      Launcher 按键面板  1 2 3 4 5 6 7 8 9 10 11 12 13  (defhydra hydra-launcher (:color blue :hint nil :exit t) \u0026#34; all hydra apps or browse urls: ------------------------------------------------------------------ [_h_] Man [_r_] Reddit [_w_] EmacsWiki [_z_] Zhihu [_s_] Shell [_q_] Cancel \u0026#34; (\u0026#34;h\u0026#34; man) (\u0026#34;r\u0026#34; (browse-url \u0026#34;http://www.reddit.com/r/emacs\u0026#34;)) (\u0026#34;w\u0026#34; (browse-url \u0026#34;http://www.emacswiki.org/\u0026#34;)) (\u0026#34;z\u0026#34; (browse-url \u0026#34;https://www.zhihu.com/\u0026#34;)) (\u0026#34;s\u0026#34; shell) (\u0026#34;q\u0026#34; nil))      crux tool(C-c)     key function description     C-c o crux-open-with open with specific application   C-c u crux-view-url open the url under cursor   C-c D crux-delete-file-and-buffer SPC f D -\u0026gt; doom/delete-this-file   C-c S crux-find-shell-init-file -    中文对齐？？       window operations     key function description     SPC w L +evil/window-move-right -   SPC w H +evil/window-move-left    SPC w J +evil/window-move-down    SPC w K +evil/window-move-up       smartparen 括号操作     key function description     z [ sp-wrap-square replace with S   z ( sp-wrap-round replace with S   z { sp-wrap-curly replace with S   z - sp-splice-sexp -   z . emmet-wrap-with-markup -     C-( sp-backward-slurp-sexp    C-) sp-forward-slurp-sexp    s-( sp-backward-barf-sexp    s-) sp-forward-barf-sexp    C-{ sp-backward-sexp    C-} sp-forward-sexp       +workspace     key function description     SPC TAB 0-9 - +workspaces switch to(0-9)   SPC TAB . +workspace/switch -   SPC TAB [ +workspace/previous -   SPC TAB ] +workspace/next -   SPC TAB ` +workspace/last -   SPC TAB d +workspace/delete delete this workspace   SPC TAB l +workspace/load -   SPC TAB n +workspace/new -   SPC TAB r +workspace/rename -   SPC TAB s +workspace/save -   SPC TAB x +workspace/kill-session -   SPC TAB R +workspace/restore-last -          Spaceamcs  我的 Spacemacs 配置文件，参考配置来源于 子龙山人 的配置方案(进行了部分删减)，我的完整配置文档链接🛬🛬🛬。\nAwesome/有趣/实用     key function description     SPC i s ivy-yas 插入 snippet 实时显示要插入的内容   C-c i m helm-imenu 函数，变量列表     SPC i s\n   Key bindings   我的自定义按键：\n   Key Binding Description     SPC a m n emms-next   SPC a m p emms-previous     SPC b i ibuffer   SPC b D spacemacs/kill-other-buffers   SPC b m s bookmark-set   SPC b m r bookmark-rename   SPC b m d bookmark-delete   SPC b m j counsel-bookmark     SPC d d dash-at-point     SPC e n flycheck-next-error   SPC e p flycheck-previous-error     SPC f d projectile-find-file-dwim-other-window     SPC g g magit   SPC g L magit-log-buffer-file, show git logs   SPC g n smerge-next   SPC g p smerge-prev   SPC g M git-messenger:popup-message, show git log message, with `f\u0026#39; open in browser.     SPC h h zilongshanren/highlight-dwim   SPC h c zilongshanren/clearn-highlight, TODO     SPC o o zilongshanren/helm-hotspots   SPC o x org-open-at-point-global, open link   SPC o r zilongshanren/browser-refresh–chrome-applescript   SPC o s spacemacs/search-engine-select, open search engine list to search   SPC o g my-git-timemachine, git record   SPC o ! zilongshanren/iterm-shell-command, go current dir \u0026amp; run command   SPC o e tiny-expand   SPC o i org-mode insert command   SPC o i t org-set-tags-command, –\u0026gt; :done:     SPC p b counsel-projectile-switch-to-buffer   SPC p t my-simple-todo   SPC p f zilongshanren/open-file-with-projectile-or-counsel-git     SPC r l ivy-resume, resume last search result     SPC s j counsel-jump-in-buffer     SPC y i yas/insert-snippet   SPC y d youdao-dictionary-search-at-point+     C-c l zilongshanren/insert-chrome-current-tab-url   C-c t org-capture   C-c r vr/replace   C-c q vr/query-replace     M-- zilongshanren/goto-match-paren   M-i string-inflection-java-style-cycle   M-\u0026#39; avy-goto-char-2     s-p find-file-in-project     , \u0026#39; ielm, lisp-repl   , g d xref-find-definition   , g b xref-pop-marker-stack     + evil-numbers/inc-at-pt，number +1   - evil-numbers/dec-at-pt, number -1     g [ beginning-of-defun   g ] end-of-defun     z [ sp-wrap-square   z ( sp-wrap-round   z { sp-wrap-curly   z - sp-splice-sexp   z . emmet-wrap-with-markup    vue-mode  vue-mode-key-bindings\n  smartparens(括号操作)     key function     C-( sp-backward-slurp-sexp   s-( sp-backward-barf-sexp   C-) sp-forward-slurp-sexp   s-) sp-forward-barf-sexp   C-{ sp-backward-sexp   C-} sp-forward-sexp      move-text, up/down     key function     s-\u0026lt; move-text-up   s-\u0026gt; move-text-down        Modes  emms, play music  1 2 3 4 5 6 7 8 9  (spacemacs/set-leader-keys \u0026#34;ama\u0026#34; \u0026#39;emms-add-directory-tree) (spacemacs/set-leader-keys \u0026#34;ame\u0026#34; \u0026#39;emms-smart-browse) (spacemacs/set-leader-keys \u0026#34;aml\u0026#34; \u0026#39;emms-play-playlist) (spacemacs/set-leader-keys \u0026#34;amn\u0026#34; \u0026#39;emms-next) (spacemacs/set-leader-keys \u0026#34;amp\u0026#34; \u0026#39;emms-previous) (spacemacs/set-leader-keys \u0026#34;amP\u0026#34; \u0026#39;emms-pause) (spacemacs/set-leader-keys \u0026#34;ams\u0026#34; \u0026#39;emms-start) (spacemacs/set-leader-keys \u0026#34;amS\u0026#34; \u0026#39;emms-stop) (spacemacs/set-leader-keys \u0026#34;amt\u0026#34; \u0026#39;emms-toggle-repeat-playlist)       key function     SPC a m a \u0026#39;emms-add-directory-tree   SPC a m e \u0026#39;emms-smart-browse   SPC a m l \u0026#39;emms-play-playlist   SPC a m n \u0026#39;emms-next   SPC a m p \u0026#39;emms-previous   SPC a m P \u0026#39;emms-pause   SPC a m s \u0026#39;emms-start   SPC a m S \u0026#39;emms-stop   SPC a m t \u0026#39;emms-toggle-repeat-playlist      DONE ranger  CLOSED: [2020-08-27 Thu 21:14]\n  State \u0026#34;DONE\u0026#34; from [2020-08-27 Thu 21:14]\n     key function     SPC a r open ranger   q quit   j move down   k move up   l into current directory   h up to parent dir     file manangement:\n   key function     r revert buffer   R rename   D delete   yy copy   pp paste   f search file names   i toggle showing literal / full-text previews   zh toggle dot files   o sort options   H search through history   z- or z+ reduce/increase parents   C-SPC mark a file or directory   v toggle mark   V visually select lines   ;C copy / move directory   ;+ create directory   SPC a d deer   C-j scroll preview window down   C-k scroll preview window up   S enter shell      org-mode   ref: https://practicalli.github.io/spacemacs/org-mode/\n   key function     , i p set property    text-style   code: , x c\n italic: , x i\n line-throught: , x s\n underline: , x u\n verbatim: , x v\n bold: , x b\n  checkbox   todo one, C-c C-c change status\n todo two, done\n todo three\n    todos  TODO todo one  SCHEDULED: \u0026lt;2020-08-27 Thu\u0026gt;\n  WAITING todo two waiting    State \u0026#34;WAITING\u0026#34; from \u0026#34;TODO\u0026#34; [2020-08-25 Tue 14:46] –\n    todo scheduler  SCHEDULED: \u0026lt;2020-08-25 Tue\u0026gt;\n      TODO tiny, SPC o e  https://github.com/abo-abo/tiny\n  TODO multiple-cursors   TODO prodigy  blog settings.\n  TODO wrap-region   https://github.com/rejeep/wrap-region.el/blob/master/wrap-region.el\n    Misc Settings   超过 80 列自动换行 ：\n1 2  (add-hook \u0026#39;org-mode-hook \u0026#39;turn-on-auto-fill) (setq-default fill-column 80)     自动缩进:\n (global-aggressive-indent-mode)\n  Issues  Points  org-mode 简介    Jump to inner link: \u0026lt;\u0026lt;text\u0026gt;\u0026gt; \u0026lt;- [[test][text]]\n          ","permalink":"https://www.cheng92.com/emacs/my-emacs-configuration/","tags":["emacs"],"title":"My Emacs Configuration[已废弃]"},{"categories":null,"contents":";; -- mode: emacs-lisp --\n;; pandoc-mode project settings file ;; saved on 2021.07.22 14:15\n((master-file . “/Users/simon/blog/cheng92.com/content/post/my-first-post.org”))\n","permalink":"https://www.cheng92.com/post/project./","tags":null,"title":""},{"categories":null,"contents":"  用 config.org 文件来维护 doom emacs 配置。\n View on GitHub  他人配置列表：\n    name\u0026amp;link brief     dot-doom/doom.org at master · zzamboni/dot-doom -   Sacha Chua\u0026#39;s Emacs configuration -   daedreth/UncleDavesEmacs: My personal ~/.emacs.d -   PythonNut/quark-emacs: An incredible wonderland of code -   Mastering Emacs -   Doom Emacs Configuration -   GitHub - KaratasFurkan/.emacs.d: My literate Emacs configuration -   eggcaker/.doom.d: My private doom-emacs configurations rime + pyim   https://www.gtrun.org/custom/config.html#org57b461c     Update Logs  [2021-05-30]\n  add gcl/async-shell-command-silently\n  [2021-07-02]\n  upgrade emacs27 to emacs28 native\n    Function declaration  mine  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97  ;;;###autoload (defun gcl/edit-zsh-configuration () (interactive) (find-file \u0026#34;~/.zshrc\u0026#34;)) ;;;###autoload (defun gcl/use-eslint-from-node-modules () \u0026#34;Set local eslint if available.\u0026#34; (let* ((root (locate-dominating-file (or (buffer-file-name) default-directory) \u0026#34;node_modules\u0026#34;)) (eslint (and root (expand-file-name \u0026#34;node_modules/eslint/bin/eslint.js\u0026#34; root)))) (when (and eslint (file-executable-p eslint)) (setq-local flycheck-javascript-eslint-executable eslint)))) ;;;###autoload (defun gcl/goto-match-paren (arg) \u0026#34;Go to the matching if on (){}[], similar to vi style of % .\u0026#34; (interactive \u0026#34;p\u0026#34;) (cond ((looking-at \u0026#34;[\\[\\(\\{]\u0026#34;) (evil-jump-item)) ((looking-back \u0026#34;[\\]\\)\\}]\u0026#34; 1) (evil-jump-item)) ((looking-at \u0026#34;[\\]\\)\\}]\u0026#34;) (forward-char) (evil-jump-item)) ((looking-back \u0026#34;[\\[\\(\\{]\u0026#34; 1) (backward-char) (evil-jump-item)) (t nil))) ;;;###autoload (defun gcl/string-inflection-cycle-auto () \u0026#34;switching by major-mode\u0026#34; (interactive) (cond ;; for emacs-lisp-mode ((eq major-mode \u0026#39;emacs-lisp-mode) (string-inflection-all-cycle)) ;; for python ((eq major-mode \u0026#39;python-mode) (string-inflection-python-style-cycle)) ;; for java ((eq major-mode \u0026#39;java-mode) (string-inflection-java-style-cycle)) (t ;; default (string-inflection-all-cycle)))) ;; Current time and date (defvar current-date-time-format \u0026#34;%a %b %d %H:%M:%S %Z %Y\u0026#34; \u0026#34;Format of date to insert with `insert-current-date-time\u0026#39;func See help of `format-time-string\u0026#39;for possible replacements\u0026#34;) (defvar current-time-format \u0026#34;%H:%M\u0026#34; \u0026#34;Format of date to insert with `insert-current-time\u0026#39;func. Note the weekly scope of the command\u0026#39;s precision.\u0026#34;) ;;;###autoload (defun insert-current-date-time () \u0026#34;insert the current date and time into current buffer. Uses `current-date-time-format\u0026#39;for the formatting the date/time.\u0026#34; (interactive) (insert (format-time-string current-date-time-format (current-time))) ) ;;;###autoload (defun insert-current-time () \u0026#34;insert the current time (1-week scope) into the current buffer.\u0026#34; (interactive) (insert (format-time-string current-time-format (current-time))) ) ;;;###autoload (defun my/capitalize-first-char (\u0026amp;optional string) \u0026#34;Capitalize only the first character of the input STRING.\u0026#34; (when (and string (\u0026gt; (length string) 0)) (let ((first-char (substring string nil 1)) (rest-str (substring string 1))) (concat (capitalize first-char) rest-str)))) ;;;###autoload (defun my/lowcase-first-char (\u0026amp;optional string) \u0026#34;Capitalize only the first character of the input STRING.\u0026#34; (when (and string (\u0026gt; (length string) 0)) (let ((first-char (substring string nil 1)) (rest-str (substring string 1))) (concat first-char rest-str)))) ;;;###autoload (defun gcl/async-shell-command-silently (command) \u0026#34;async shell command silently.\u0026#34; (interactive) (let ((display-buffer-alist (list (cons \u0026#34;\\\\*Async Shell Command\\\\*.*\u0026#34; (cons #\u0026#39;display-buffer-no-window nil))))) (async-shell-command command)))      aj(AloisJanicek)  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19  ;;;###autoload (defun aj-fix-buffer-file-name-for-indirect-buffers-a (orig-fn \u0026amp;rest args) \u0026#34;Advice for functions expecting `buffer-file-name\u0026#39;to work.\u0026#34; (let ((buffer-file-name buffer-file-truename)) (cl-letf (((symbol-function \u0026#39;buffer-file-name) (lambda (\u0026amp;optional buffer) \u0026#34;Return value of `buffer-file-truename\u0026#39;.\u0026#34; (with-current-buffer (or buffer (current-buffer)) buffer-file-truename)))) (apply orig-fn args)))) ;;;###autoload (defun aj-zeal-at-point-run-search-on-wsl-a (search) \u0026#34;Launch Windows Zeal from WSL emacs. Use `call-process\u0026#39;instead of `start-process\u0026#39;. Use in conjunction with https://github.com/Konfekt/wsl-gui-bins/blob/master/zeal \u0026#34; (call-process (executable-find \u0026#34;zeal\u0026#34;) nil 0 nil search))      org-mode  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48  ;;;###autoload (defun gcl/indent-org-block-automatically () (interactive) (when (org-in-src-block-p) (org-edit-special) (indent-region (point-min) (point-max)) (org-edit-src-exit))) ;;;###autoload (defun aj-org-agenda-save-and-refresh-a (\u0026amp;rest _) \u0026#34;Save org files and refresh. Only org files contributing to `org-agenda\u0026#39;are saved. Refreshed are `org-agenda\u0026#39;org `org-ql-view\u0026#39;, depending on which one is currently active.\u0026#34; (org-save-all-org-buffers) (if (string-match \u0026#34;Org QL\u0026#34; (buffer-name)) (org-ql-view-refresh) (org-agenda-redo))) ;;;###autoload (defun aj-org-roam-setup-dailies-file-h () \u0026#34;Setup org-roam dailies file to my taste. Initialy create id inside top-level \\\u0026#34;:PROPERTIES:\\\u0026#34; drawer. Finally save buffer. \u0026#34; (let ((fname (or (buffer-file-name) (buffer-file-name (buffer-base-buffer)))) hstub) ;; Run this only when file is newly created (hasn\u0026#39;t been saved yet) (unless (file-exists-p fname) (org-id-get-create) (save-buffer)) (goto-char (point-max)) (newline) ;; prompt for HH:MM if we are not in present day file (if (string-equal (format-time-string \u0026#34;%Y-%m-%d\u0026#34;) (file-name-sans-extension (file-name-nondirectory (or (buffer-file-name) (buffer-file-name (buffer-base-buffer)))))) (setq hstub (format-time-string \u0026#34;* %H:%M \u0026#34; (current-time))) (setq hstub (concat \u0026#34;* \u0026#34; (ivy-read \u0026#34;Time of the day (HH:MM): \u0026#34; nil) \u0026#34; \u0026#34;))) (insert hstub) (evil-insert 0)))      quick-find  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26  ;;;###autoload (defun dired-timesort (filename \u0026amp;optional wildcards) (let ((dired-listing-switches \u0026#34;-lhat\u0026#34;)) (dired filename wildcards))) ;;;###autoload (defmacro quick-find (key file \u0026amp;optional path find-args) `(bind-key ,key (cond ((stringp ,find-args) \u0026#39;(lambda (\u0026amp;optional arg) (interactive) (find-dired (expand-file-name ,file ,path) ,find-args))) ((and ;; (not (tramp-tramp-file-p (expand-file-name ,file ,path))) (or (file-directory-p (expand-file-name ,file ,path)) (not (file-exists-p (expand-file-name ,file ,path))))) \u0026#39;(lambda (\u0026amp;optional arg) (interactive) (dired-timesort (expand-file-name ,file ,path)))) (t \u0026#39;(lambda (\u0026amp;optional arg) (interactive) (find-file (expand-file-name ,file ,path)))))))      embrace  1 2 3 4 5 6 7 8 9  ;;;###autoload (defun gcl/embrace-prog-mode-hook () (dolist (lst \u0026#39;((?` \u0026#34;`\u0026#34; . \u0026#34;`\u0026#34;))) (embrace-add-pair (car lst) (cadr lst) (cddr lst)))) ;;;###autoload (defun gcl/embrace-org-mode-hook () (dolist (lst \u0026#39;((?c \u0026#34;@@html:\u0026lt;font color=\\\u0026#34;red\\\u0026#34;\u0026gt;\u0026#34; . \u0026#34;\u0026lt;/font\u0026gt;@@\u0026#34;))) (embrace-add-pair (car lst) (cadr lst) (cddr lst))))        Init.el  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198  ;;; init.el -*- lexical-binding: t; -*- (doom! :input ;;chinese ;;japanese ;;layout ; auie,ctsrnm is the superior home row :completion company ; the ultimate code completion backend ;;helm ; the *other* search engine for love and life ;;ido ; the other *other* search engine... (ivy ; a search engine for love and life +icons +prescient) :ui ;;deft ; notational velocity for Emacs doom ; what makes DOOM look the way it does doom-dashboard ; a nifty splash screen for Emacs doom-quit ; DOOM quit-message prompts when you quit Emacs (emoji +ascii +github) ; 🙂 fill-column ; a `fill-column\u0026#39; indicator hl-todo ; highlight TODO/FIXME/NOTE/DEPRECATED/HACK/REVIEW hydra ;;indent-guides ; highlighted indent columns (ligatures ; ligatures and symbols to make your code pretty again +extra) ;;minimap ; show a map of the code on the side modeline ; snazzy, Atom-inspired modeline, plus API nav-flash ; blink cursor line after big motions ;;neotree ; a project drawer, like NERDTree for vim ophints ; highlight the region an operation acts on (popup +all +defaults) ; tame sudden yet inevitable temporary windows ;;tabs ; a tab bar for Emacs ;; (treemacs +lsp) ; a project drawer, like neotree but cooler ;; unicode ; extended unicode support for various languages vc-gutter ; vcs diff in the fringe vi-tilde-fringe ; fringe tildes to mark beyond EOB (window-select +numbers) ; visually switch windows workspaces ; tab emulation, persistence \u0026amp; separate workspaces ;;zen ; distraction-free coding or writing :editor (evil +everywhere); come to the dark side, we have cookies file-templates ; auto-snippets for empty files fold ; (nigh) universal code folding (format +onsave) ; automated prettiness ;;god ; run Emacs commands without modifier keys ;;lispy ; vim for lisp, for people who don\u0026#39;t like vim multiple-cursors ; editing in many places at once ;; objed ; text object editing for the innocent ;;parinfer ; turn lisp into python, sort of rotate-text ; cycle region at point between text candidates snippets ; my elves. They type so I don\u0026#39;t have to word-wrap ; soft wrapping with language-aware indent :emacs (dired +icons) ; making dired pretty [functional] electric ; smarter, keyword-based electric-indent (ibuffer +icons) ; interactive buffer management ;; (undo +tree) ; persistent, smarter undo for your inevitable mistakes vc ; version-control and Emacs, sitting in a tree :term ;;eshell ; the elisp shell that works everywhere ;;shell ; simple shell REPL for Emacs ;;term ; basic terminal emulator for Emacs vterm ; the best terminal emulation in Emacs :checkers syntax ; tasing you for every semicolon you forget ;; (:if (executable-find \u0026#34;aspell\u0026#34;) spell +flyspell) ; tasing you for misspelling mispelling grammar ; tasing grammar mistake every you make :tools ;;ansible ;;debugger ; FIXME stepping through code, to help you add bugs ;;direnv ;;docker editorconfig ; let someone else argue about tabs vs spaces ;;ein ; tame Jupyter notebooks with emacs (eval +overlay) ; run code, run (also, repls) ;;gist ; interacting with github gists (lookup ; navigate your code and its documentation +dictionary +docsets) (lsp +peek) (magit +forge) ; a git porcelain for Emacs make ; run make tasks from Emacs ;;pass ; password manager for nerds pdf ; pdf enhancements ;;prodigy ; FIXME managing external services \u0026amp; code builders rgb ; creating color strings ;;taskrunner ; taskrunner for all your projects ;;terraform ; infrastructure as code ;;tmux ; an API for interacting with tmux upload ; map local to remote projects via ssh/ftp :os (:if IS-MAC macos) ; improve compatibility with macOS tty ; improve the terminal Emacs experience :lang ;;agda ; types of types of types of types... ;;beancount ; mind the GAAP (cc +lsp) ; C \u0026gt; C++ == 1 ;;clojure ; java with a lisp ;;common-lisp ; if you\u0026#39;ve seen one lisp, you\u0026#39;ve seen them all ;;coq ; proofs-as-programs ;;crystal ; ruby at the speed of c ;;csharp ; unity, .NET, and mono shenanigans data ; config/data formats (dart +flutter +lsp) ; paint ui and not much else ;;elixir ; erlang done right ;;elm ; care for a cup of TEA? emacs-lisp ; drown in parentheses ;;erlang ; an elegant language for a more civilized age ;;ess ; emacs speaks statistics ;;factor ;;faust ; dsp, but you get to keep your soul ;;fsharp ; ML stands for Microsoft\u0026#39;s Language ;;fstar ; (dependent) types and (monadic) effects and Z3 ;;gdscript ; the language you waited for (go +lsp) ; the hipster dialect ;;(haskell +dante) ; a language that\u0026#39;s lazier than I am ;;hy ; readability of scheme w/ speed of python ;;idris ; a language you can depend on (json +lsp) ; At least it ain\u0026#39;t XML (java +meghanada +lsp) ; the poster child for carpal tunnel syndrome (javascript +lsp) ; all(hope(abandon(ye(who(enter(here)))))) ;;julia ; a better, faster MATLAB ;;kotlin ; a better, slicker Java(Script) (latex ; writing papers in Emacs has never been so fun +latexmk +cdlatex +lsp +fold) ;;lean ; for folks with too much to prove ;;ledger ; be audit you can be (lua +lsp) ; one-based indices? one-based indices markdown ; writing docs for people to ignore ;;nim ; python + lisp at the speed of c nix ; I hereby declare \u0026#34;nix geht mehr!\u0026#34; ;;ocaml ; an objective camel (org ; organize your plain life in plain text +attach +babel +capture +dragndrop +hugo ;; +jupyter +export +pandoc +gnuplot +pretty +present +protocol +pomodoro +roam2 +noter) (php +lsp) ; perl\u0026#39;s insecure younger brother plantuml ; diagrams for confusing people more ;;purescript ; javascript, but functional (python +lsp +pyright) ; beautiful is better than ugly ;;qt ; the \u0026#39;cutest\u0026#39; gui framework ever ;;racket ; a DSL for DSLs ;;raku ; the artist formerly known as perl6 rest ; Emacs as a REST client ;;rst ; ReST in peace (ruby +rails +lsp) ; 1.step {|i| p \u0026#34;Ruby is #{i.even? ? \u0026#39;love\u0026#39; : \u0026#39;life\u0026#39;}\u0026#34;} (rust +lsp) ; Fe2O3.unwrap().unwrap().unwrap().unwrap() ;;scala ; java, but good (scheme +guile) ; a fully conniving family of lisps (sh +lsp +powershell) ; she sells {ba,z,fi}sh shells on the C xor ;;sml ;;solidity ; do you need a blockchain? No. ;;swift ; who asked for emoji variables? ;;terra ; Earth and Moon in alignment for performance. (web +lsp) ; the tubes (yaml +lsp) ; JSON, but readable ;;zig ; C, but simpler :email (mu4e +gmail) ;;notmuch ;;(wanderlust +gmail) :app calendar emms everywhere ; *leave* Emacs!? You must be joking irc ; how neckbeards socialize (rss +org) ; emacs as an RSS reader ;;twitter ; twitter client https://twitter.com/vnought :config literate (default +bindings +smartparens))      Theme Settings  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19  (setq doom-theme \u0026#39;doom-vibrant) ;; (setq doom-font (font-spec :family \u0026#34;JetBrains Mono\u0026#34; :size 16)) (setq doom-font (font-spec :family \u0026#34;Fira Code\u0026#34; :size 15)) ;; (setq doom-font (font-spec :family \u0026#34;Source Code Pro\u0026#34; :size 15)) ;; set title ;; (setq frame-title-format ;; \u0026#39;(\u0026#34;\u0026#34; ;; ;; (:eval ;; ;; (if (s-contains-p org-roam-directory (or buffer-file-name \u0026#34;\u0026#34;)) ;; ;; (replace-regexp-in-string ;; ;; \u0026#34;.*/[0-9]*-?\u0026#34; \u0026#34;☰ \u0026#34; ;; ;; (subst-char-in-string ?_ ? buffer-file-name)) ;; ;; \u0026#34;%b\u0026#34;)) ;; (:eval ;; (let ((project-name (projectile-project-name))) ;; (unless (string= \u0026#34;-\u0026#34; project-name) ;; (format (if (buffer-modified-p) \u0026#34; ◉ %s\u0026#34; \u0026#34; ● %s\u0026#34;) project-name))))))      Basic Settings   auto generate code into config.el, init.el, packages.el, …, and run `cp-config-org.sh`\n to bakup some of my private things.\n1 2 3 4 5 6 7 8 9 10 11  (doom-load-envvars-file \u0026#34;~/.doom.d/env\u0026#34; ) (defadvice! +literate-tangle-async-h () \u0026#34;A very simplified version of `+literate-tangle-h\u0026#39;, but async.\u0026#34; :override #\u0026#39;+literate-tangle-h (let ((default-directory doom-private-dir)) (gcl/async-shell-command-silently (format \u0026#34;emacs --batch --eval \\\u0026#34;(progn \\ (require \u0026#39;org) (setq org-confirm-babel-evaluate nil) \\ (org-babel-tangle-file \\\\\\\u0026#34;%s\\\\\\\u0026#34;))\\\u0026#34; \\ \u0026amp;\u0026amp; /bin/bash ~/.gclrc/bin/rsync-doom-config\u0026#34; +literate-config-file))))     private:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67  ;; 启动全屏 (add-to-list \u0026#39;initial-frame-alist \u0026#39;(fullscreen . maximized)) (add-hook \u0026#39;org-mode-hook \u0026#39;turn-on-auto-fill) ;; 个人信息配置 (setq user-full-name \u0026#34;Zhicheng Lee\u0026#34; user-mail-address \u0026#34;gccll.love@gmail.com\u0026#34; user-blog-url \u0026#34;https://www.cheng92.com\u0026#34; read-process-output-max (* 1024 1024) display-line-numbers-type t ;; web, js, css css-indent-offset 2 js2-basic-offset 2 js-switch-indent-offset 2 js-indent-level 2 js2-mode-show-parse-errors nil js2-mode-show-strict-warnings nil web-mode-attr-indent-offset 2 web-mode-code-indent-offset 2 web-mode-css-indent-offset 2 web-mode-markup-indent-offset 2 web-mode-enable-current-element-highlight t web-mode-enable-current-column-highlight t ;; org org-roam-v2-ack t ; close v2 warning org-roam-directory \u0026#34;~/.gclrc/roam/\u0026#34; org-directory \u0026#34;~/.gclrc/org/\u0026#34; org-log-done \u0026#39;time ; having the time a item is done sounds convenient org-list-allow-alphabetical t ; have a. A. a) A) list bullets org-export-in-background t ; run export processes in external emacs process org-catch-invisible-edits \u0026#39;smart ; try not to accidently do weird stuff in invisible regions org-fontify-done-headline t ; 已完成的加上删除线 ;; scroll behavior redisplay-dont-pause t scroll-margin 1 scroll-step 1 scroll-conservatively 10000 scroll-preserve-screen-position 1 ;; mouse wheel mouse-wheel-follow-mouse \u0026#39;t mouse-wheel-scroll-amount \u0026#39;(1 ((shift) . 1)) vc-log-view-type nil ;; mu4e +mu4e-backend \u0026#39;offlineimap ;; osx ;; browse-url-browser-function \u0026#39;browse-url-default-macosx-browser ) (setq-default fill-column 80 undo-limit 80000000 delete-by-moving-to-trash t window-combination-resize t delete-trailing-lines t x-stretch-cursor t typescript-indent-level 2 custom-file (expand-file-name \u0026#34;.custom.el\u0026#34; doom-private-dir)) (when (file-exists-p custom-file) (load custom-file))      Keybindings   Keybindings reference:\n evil-bindings.el\n editor/evil/config.el\nUnbindings  To Unbind\n1 2 3 4 5 6 7 8 9 10 11 12 13  (global-set-key (kbd \u0026#34;C-d\u0026#34;) nil) ; ns-print-buffer (global-set-key (kbd \u0026#34;s-p\u0026#34;) nil) ; ns-print-buffer (global-set-key (kbd \u0026#34;\u0026lt;f1\u0026gt;\u0026#34;) nil) ; ns-print-buffer (global-set-key (kbd \u0026#34;\u0026lt;f2\u0026gt;\u0026#34;) nil) ; ns-print-buffer (define-key evil-normal-state-map (kbd \u0026#34;,\u0026#34;) nil) (define-key evil-visual-state-map (kbd \u0026#34;,\u0026#34;) nil) ;; (global-set-key (kbd \u0026#34;,\u0026#34;) nil) (map! \u0026#34;C-e\u0026#34; nil :n \u0026#34;C-t\u0026#34; nil) ;; (undefine-key! \u0026#34;SPC :\u0026#34; \u0026#34;SPC ~\u0026#34; \u0026#34;SPC .\u0026#34; \u0026#34;SPC X\u0026#34; \u0026#34;C-c C-r\u0026#34; \u0026#34;,\u0026#34;) ;; (undefine-key! evil-normal-state-map \u0026#34;,\u0026#34;) (undefine-key! org-mode-map \u0026#34;C-c C-r\u0026#34;)      F1~12(kbd)  1 2 3 4 5 6 7 8 9  (global-set-key (kbd \u0026#34;\u0026lt;f1\u0026gt;\u0026#34;) \u0026#39;gcl-everything/body) (global-set-key (kbd \u0026#34;\u0026lt;f5\u0026gt;\u0026#34;) \u0026#39;deadgrep) (global-set-key (kbd \u0026#34;\u0026lt;M-f5\u0026gt;\u0026#34;) \u0026#39;deadgrep-kill-all-buffers) (global-set-key (kbd \u0026#34;\u0026lt;f8\u0026gt;\u0026#34;) \u0026#39;quickrun) (global-set-key (kbd \u0026#34;\u0026lt;f12\u0026gt;\u0026#34;) \u0026#39;smerge-vc-next-conflict) (global-set-key (kbd \u0026#34;\u0026lt;f11\u0026gt;\u0026#34;) \u0026#39;+vc/smerge-hydra/body) (global-set-key (kbd \u0026#34;C-t\u0026#34;) \u0026#39;+vterm/toggle) (global-set-key (kbd \u0026#34;C-S-t\u0026#34;) \u0026#39;+vterm/here) (global-set-key (kbd \u0026#34;C-d\u0026#34;) \u0026#39;kill-current-buffer)      Global  M(Option/Alt)  1 2 3 4 5 6 7 8 9  (map! ;; \u0026#34;M-1\u0026#34; #\u0026#39;bm-toggle ;; \u0026#34;M-2\u0026#34; #\u0026#39;bm-next ;; \u0026#34;M-@\u0026#34; #\u0026#39;bm-previous \u0026#34;M--\u0026#34; #\u0026#39;gcl/goto-match-paren \u0026#34;M-i\u0026#34; #\u0026#39;parrot-rotate-next-word-at-point \u0026#34;M-TAB\u0026#34; #\u0026#39;gcl-everything/body ;; \u0026#34;S-M-SPC\u0026#34; #\u0026#39;counsel-osx-app )      C(Control)  1 2 3 4 5 6 7  (map! :niv \u0026#34;C-e\u0026#34; #\u0026#39;evil-end-of-line :niv \u0026#34;C-=\u0026#34; #\u0026#39;er/expand-region \u0026#34;C-a\u0026#34; #\u0026#39;crux-move-beginning-of-line \u0026#34;C-s\u0026#34; #\u0026#39;+default/search-buffer )    C-c  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52  (map! ;; a -\u0026gt; applications, ... \u0026#34;C-c a\u0026#34; #\u0026#39;org-agenda ;; b -\u0026gt; bookmark, buffer ... \u0026#34;C-c b l\u0026#34; #\u0026#39;bm-show-all \u0026#34;C-c b s\u0026#34; #\u0026#39;bm-buffer-save ;; i -\u0026gt; date, time, ... \u0026#34;C-c i d\u0026#34; #\u0026#39;insert-current-date-time \u0026#34;C-c i t\u0026#34; #\u0026#39;insert-current-time ;; f -\u0026gt; file, directory, ... \u0026#34;C-c f o\u0026#34; #\u0026#39;crux-open-with ;; h -\u0026gt; help \u0026#34;C-c h d\u0026#34; #\u0026#39;dash-at-point \u0026#34;C-c h D\u0026#34; #\u0026#39;dash-at-point-with-docset ;; n -\u0026gt; network utils ;; \u0026#34;C-c n x\u0026#34; #\u0026#39;xxx ;; s -\u0026gt; search/engine ... ;; \u0026#34;C-c s r\u0026#34; ;; ... ;; s -\u0026gt; replace \u0026#34;C-c r r\u0026#34; #\u0026#39;vr/replace \u0026#34;C-c r q\u0026#34; #\u0026#39;vr/query-replace ;; u -\u0026gt; url, ... \u0026#34;C-c u u\u0026#34; #\u0026#39;crux-view-url \u0026#34;C-c u o\u0026#34; #\u0026#39;link-hint-open-link \u0026#34;C-c u c\u0026#34; #\u0026#39;link-hint-copy-link \u0026#34;C-c u a\u0026#34; #\u0026#39;link-hint-open-link-at-point \u0026#34;C-c u C\u0026#34; #\u0026#39;link-hint-copy-link-at-point ;; y -\u0026gt; youdao, ... \u0026#34;C-c y y\u0026#34; #\u0026#39;youdao-dictionary-search-at-point+ \u0026#34;C-c C-r C-r\u0026#34; #\u0026#39;verb-send-request-on-point-other-window-stay \u0026#34;C-c C-r C-s\u0026#34; #\u0026#39;verb-send-request-on-point-other-window \u0026#34;C-c C-r C-f\u0026#34; #\u0026#39;verb-send-request-on-point \u0026#34;C-c C-r C-m\u0026#34; #\u0026#39;verb-send-request-on-point-no-window \u0026#34;C-c C-r C-k\u0026#34; #\u0026#39;verb-kill-response-buffer-and-window \u0026#34;C-c C-r C-a\u0026#34; #\u0026#39;verb-kill-all-response-buffers \u0026#34;C-c C-r C-u\u0026#34; #\u0026#39;verb-export-request-on-point-curl \u0026#34;C-c C-r C-b\u0026#34; #\u0026#39;verb-export-request-on-point-verb \u0026#34;C-c C-r C-w\u0026#34; #\u0026#39;verb-export-request-on-point-eww \u0026#34;C-c C-r C-l\u0026#34; #\u0026#39;verb-show-vars ; 查看已存在的变量值列表 \u0026#34;C-c C-r C-v\u0026#34; #\u0026#39;verb-set-var )      C-x  1 2 3 4 5  (map! ;; \u0026#34;C-x p\u0026#34; #\u0026#39;vmd-mode ;; \u0026#34;C-x d\u0026#34; #\u0026#39;dash-at-point ;; \u0026#34;C-x D\u0026#34; #\u0026#39;dash-at-point-with-docset )        s(Command)  1 2 3 4 5 6 7 8 9 10 11 12 13  (map! \u0026#34;s-\u0026lt;\u0026#34; #\u0026#39;move-text-up \u0026#34;s-\u0026gt;\u0026#34; #\u0026#39;move-text-down ;; \u0026#34;s-\u0026#39;\u0026#34; #\u0026#39;cycle-quotes \u0026#34;s-i\u0026#34; #\u0026#39;gcl/string-inflection-cycle-auto ;; projector --- --- ;; \u0026#34;s-p b\u0026#34; #\u0026#39;projector-switch-to-shell-buffer ;; \u0026#34;s-p B\u0026#34; #\u0026#39;projector-run-shell-command-current-directory-background ;; \u0026#34;s-p c\u0026#34; #\u0026#39;projector-run-shell-command-current-directory ;; \u0026#34;s-p d\u0026#34; #\u0026#39;projector-run-default-shell-command ;; \u0026#34;s-p r\u0026#34; #\u0026#39;projector-run-shell-command-project-root ;; \u0026#34;s-p R\u0026#34; #\u0026#39;projector-rerun-buffer-process )      Evil  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58  (evil-define-minor-mode-key \u0026#39;(normal motion) \u0026#39;evil-snipe-local-mode \u0026#34;s\u0026#34; #\u0026#39;avy-goto-char \u0026#34;S\u0026#34; #\u0026#39;avy-goto-char-2 \u0026#34;w\u0026#34; #\u0026#39;avy-goto-word-1 \u0026#34;W\u0026#34; #\u0026#39;avy-goto-word-0 ) (evil-define-key \u0026#39;(normal motion visual) map \u0026#34;s\u0026#34; #\u0026#39;avy-goto-char \u0026#34;S\u0026#34; #\u0026#39;avy-goto-char-2 \u0026#34;w\u0026#34; #\u0026#39;avy-goto-word-1 \u0026#34;W\u0026#34; #\u0026#39;avy-goto-word-0 ) (map! :n \u0026#34;+\u0026#34; #\u0026#39;evil-numbers/inc-at-pt :n \u0026#34;-\u0026#34; #\u0026#39;evil-numbers/dec-at-pt ;; g :n \u0026#34;g[\u0026#34; #\u0026#39;beginning-of-defun :n \u0026#34;g]\u0026#34; #\u0026#39;end-of-defun :n \u0026#34;gd\u0026#34; #\u0026#39;xref-find-definitions :n \u0026#34;gD\u0026#34; #\u0026#39;xref-find-references :n \u0026#34;gb\u0026#34; #\u0026#39;xref-pop-marker-stack ;; z :n \u0026#34;z-\u0026#34; #\u0026#39;sp-splice-sexp :n \u0026#34;z.\u0026#34; #\u0026#39;emmet-wrap-with-markup :n \u0026#34;gi\u0026#34; nil (:prefix (\u0026#34;gi\u0026#34; . \u0026#34;mine\u0026#34;) :n \u0026#34;f\u0026#34; #\u0026#39;+org/attach-file-and-insert-link) :nv \u0026#34;,\u0026#34; nil (:prefix (\u0026#34;,\u0026#34; . \u0026#34;gccll\u0026#34;) :nv \u0026#34;`\u0026#34; #\u0026#39;gcl-everything/body ;; embrace (:prefix (\u0026#34;e\u0026#34; . \u0026#34;embrace\u0026#34;) :n \u0026#34;a\u0026#34; #\u0026#39;embrace-add :n \u0026#34;c\u0026#34; #\u0026#39;embrace-change :n \u0026#34;d\u0026#34; #\u0026#39;embrace-delete ) ) ) ;; remap gs-\u0026gt; keybinding (map! :after evil-easymotion :map evilem-map \u0026#34;c\u0026#34; #\u0026#39;avy-goto-char \u0026#34;C\u0026#34; #\u0026#39;avy-goto-char-2 \u0026#34;w\u0026#34; #\u0026#39;avy-goto-word-1 \u0026#34;W\u0026#34; #\u0026#39;avy-goto-word-0 \u0026#34;ll\u0026#34; #\u0026#39;avy-goto-line \u0026#34;lu\u0026#34; #\u0026#39;avy-goto-line-above \u0026#34;ld\u0026#34; #\u0026#39;avy-goto-line-below )      SPC  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43  (map! :leader :nv \u0026#34;SPC\u0026#34; #\u0026#39;execute-extended-command (:prefix (\u0026#34;a\u0026#34; . \u0026#34;Applications\u0026#34;) :n \u0026#34;e\u0026#34; #\u0026#39;emms :n \u0026#34;E\u0026#34; #\u0026#39;emms-smart-browse ) ;; b -\u0026gt; Buffer :n \u0026#34;bf\u0026#34; #\u0026#39;osx-lib-reveal-in-finder ;; f -\u0026gt; File :n \u0026#34;fo\u0026#34; #\u0026#39;crux-open-with :n \u0026#34;fj\u0026#34; #\u0026#39;dired-jump ;; d -\u0026gt; directory :n \u0026#34;dd\u0026#34; #\u0026#39;deft ;; d -\u0026gt; edit :n \u0026#34;es\u0026#34; #\u0026#39;sudo-edit ;; i -\u0026gt; Insert, Imenu :n \u0026#34;ia\u0026#34; #\u0026#39;+org/attach-file-and-insert-link :n \u0026#34;im\u0026#34; #\u0026#39;imenu-list :n \u0026#34;iM\u0026#34; #\u0026#39;lsp-ui-imenu ;; l -\u0026gt; load, ... :n \u0026#34;lr\u0026#34; #\u0026#39;ranger :n \u0026#34;ld\u0026#34; #\u0026#39;dired ;; r -\u0026gt; Run ;; :n \u0026#34;rp\u0026#34; #\u0026#39;projector-run-shell-command-project-root ;; :n \u0026#34;rP\u0026#34; #\u0026#39;projector-run-default-shell-command ;; s -\u0026gt; search ? (:map (scss-mode-map css-mode-map) :n \u0026#34;si\u0026#34; #\u0026#39;counsel-css ) ;; / -\u0026gt; Search ;; :n \u0026#34;/r\u0026#34; #\u0026#39;deadgrep )        Org-mode  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55  (map! :map org-mode-map (:prefix \u0026#34;t\u0026#34; :n \u0026#34;t\u0026#34; #\u0026#39;org-todo :n \u0026#34;T\u0026#34; #\u0026#39;counsel-org-tag (:prefix (\u0026#34;c\u0026#34; . \u0026#34;checkbox\u0026#34;) :n \u0026#34;c\u0026#34; #\u0026#39;org-toggle-checkbox :n \u0026#34;u\u0026#34; #\u0026#39;org-update-checkbox-count ) (:prefix (\u0026#34;p\u0026#34; . \u0026#34;priority\u0026#34;) :n \u0026#34;p\u0026#34; #\u0026#39;org-priority :n \u0026#34;u\u0026#34; #\u0026#39;org-priority-up :n \u0026#34;d\u0026#34; #\u0026#39;org-priority-down )) (:prefix \u0026#34;C-c\u0026#34; (:prefix ( \u0026#34;d\u0026#34; . \u0026#34;Do\u0026#34; ) \u0026#34;f\u0026#34; #\u0026#39;gcl/indent-org-block-automatically ) (:prefix (\u0026#34;e\u0026#34; . \u0026#34;Emoji\u0026#34;) \u0026#34;e\u0026#34; #\u0026#39;all-the-icons-insert \u0026#34;a\u0026#34; #\u0026#39;all-the-icons-insert-faicon \u0026#34;f\u0026#34; #\u0026#39;all-the-icons-insert-fileicon \u0026#34;w\u0026#34; #\u0026#39;all-the-icons-insert-wicon \u0026#34;o\u0026#34; #\u0026#39;all-the-icons-insert-octicon \u0026#34;m\u0026#34; #\u0026#39;all-the-icons-insert-material \u0026#34;i\u0026#34; #\u0026#39;all-the-icons-insert-alltheicon ) (:prefix (\u0026#34;c\u0026#34; . \u0026#34;Org Clock\u0026#34;) \u0026#34;i\u0026#34; #\u0026#39;org-clock-in \u0026#34;o\u0026#34; #\u0026#39;org-clock-out \u0026#34;h\u0026#34; #\u0026#39;counsel-org-clock-history \u0026#34;g\u0026#34; #\u0026#39;counsel-org-clock-goto \u0026#34;c\u0026#34; #\u0026#39;counsel-org-clock-context \u0026#34;r\u0026#34; #\u0026#39;counsel-org-clock-rebuild-history ) (:prefix (\u0026#34;i\u0026#34; . \u0026#34;Insert\u0026#34;) \u0026#34;u\u0026#34; #\u0026#39;org-mac-chrome-insert-frontmost-url \u0026#34;c\u0026#34; #\u0026#39;copyright ) ;; org-roam, C-c r \u0026lt;x\u0026gt; (:prefix (\u0026#34;C-r\u0026#34; . \u0026#34;Verb\u0026#34;) \u0026#34;C-r\u0026#34; #\u0026#39;verb-send-request-on-point-other-window-stay \u0026#34;C-s\u0026#34; #\u0026#39;verb-send-request-on-point-other-window \u0026#34;C-f\u0026#34; #\u0026#39;verb-send-request-on-point \u0026#34;C-m\u0026#34; #\u0026#39;verb-send-request-on-point-no-window \u0026#34;C-k\u0026#34; #\u0026#39;verb-kill-response-buffer-and-window \u0026#34;C-a\u0026#34; #\u0026#39;verb-kill-all-response-buffers \u0026#34;C-u\u0026#34; #\u0026#39;verb-export-request-on-point-curl \u0026#34;C-b\u0026#34; #\u0026#39;verb-export-request-on-point-verb \u0026#34;C-w\u0026#34; #\u0026#39;verb-export-request-on-point-eww \u0026#34;C-l\u0026#34; #\u0026#39;verb-show-vars ; 查看已存在的变量值列表 ) ) )      Web-mode   QuickFind  1 2 3 4  (quick-find \u0026#34;C-h C-x C-s\u0026#34; \u0026#34;~/.ssh/config\u0026#34;) (quick-find \u0026#34;C-h C-x C-z\u0026#34; \u0026#34;~/.zshrc\u0026#34;) (quick-find \u0026#34;C-h C-x C-d\u0026#34; \u0026#34;~/.gclrc/org/todo.org\u0026#34;) (quick-find \u0026#34;C-h C-x C-o\u0026#34; \u0026#34;~/.offlineimaprc\u0026#34;)        Package Settings  Autoinsert  1 2 3  (use-package! autoinsert :hook (find-file . auto-insert))      Avy  1 2 3 4 5 6  (global-set-key (kbd \u0026#34;M-g f\u0026#34;) \u0026#39;avy-goto-line) (global-set-key (kbd \u0026#34;M-g w\u0026#34;) \u0026#39;avy-goto-word-1) (after! avy ;; home row priorities: 8 6 4 5 - - 1 2 3 7 (setq avy-keys \u0026#39;(?n ?e ?i ?s ?t ?r ?i ?a)))      Bm, bookmark  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19  (use-package! bm :bind (\u0026#34;M-1\u0026#34; . bm-toggle) (\u0026#34;M-2\u0026#34; . bm-next) (\u0026#34;M-@\u0026#34; . bm-previous) :custom (bm-cycle-all-buffers t) :config (add-hook \u0026#39;after-init-hook \u0026#39;bm-repository-load) (add-hook \u0026#39;kill-buffer-hook #\u0026#39;bm-buffer-save) (add-hook \u0026#39;kill-emacs-hook #\u0026#39;(lambda nil (bm-buffer-save-all) (bm-repository-save))) (add-hook \u0026#39;after-save-hook #\u0026#39;bm-buffer-save) (add-hook \u0026#39;find-file-hooks #\u0026#39;bm-buffer-restore) (add-hook \u0026#39;after-revert-hook #\u0026#39;bm-buffer-restore) (setq bm-repository-file \u0026#34;~/.doom.d/bm-repository\u0026#34;) (setq-default bm-buffer-persistence t) )      Color-rg  1 2 3 4 5 6 7  (use-package! color-rg :commands (color-rg-search-input color-rg-search-symbol color-rg-search-input-in-project) :bind (:map isearch-mode-map (\u0026#34;M-s M-s\u0026#34; . isearch-toggle-color-rg)))      Company  1 2 3 4  (after! company (setq company-idle-delay 0.5 company-minimum-prefix-length 2) (add-hook \u0026#39;evil-normal-state-entry-hook #\u0026#39;company-abort)) ;; make aborting less annoying.      Counsel-osx-app  1 2 3 4 5 6 7 8 9 10 11  (use-package! counsel-osx-app :bind* (\u0026#34;S-M-SPC\u0026#34; . counsel-osx-app) :commands counsel-osx-app :config (setq counsel-osx-app-location (list \u0026#34;/Applications\u0026#34; \u0026#34;/Applications/Misc\u0026#34; \u0026#34;/Applications/Utilities\u0026#34; (expand-file-name \u0026#34;~/Applications\u0026#34;) (expand-file-name \u0026#34;~/.nix-profile/Applications\u0026#34;) \u0026#34;/Applications/Xcode.app/Contents/Applications\u0026#34;)))      Cycle-quotes  1 2 3  (use-package! cycle-quotes :bind (\u0026#34;s-\u0026#39;\u0026#34; . cycle-quotes))      EAF  1 2 3 4 5 6  ;; (use-package! eaf ;; :commands (eaf-open-browser eaf-open find-file) ;; :config ;; (use-package! ctable) ;; (use-package! deferred) ;; (use-package! epc))      Emacs-everywhere  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17  (use-package! emacs-everywhere :if (daemonp) :config (require \u0026#39;spell-fu) (setq emacs-everywhere-major-mode-function #\u0026#39;org-mode emacs-everywhere-frame-name-format \u0026#34;Edit ∷ %s — %s\u0026#34;) (defadvice! emacs-everywhere-raise-frame () :after #\u0026#39;emacs-everywhere-set-frame-name (setq emacs-everywhere-frame-name (format emacs-everywhere-frame-name-format (emacs-everywhere-app-class emacs-everywhere-current-app) (truncate-string-to-width (emacs-everywhere-app-title emacs-everywhere-current-app) 45 nil nil \u0026#34;…\u0026#34;))) ;; need to wait till frame refresh happen before really set (run-with-timer 0.1 nil #\u0026#39;emacs-everywhere-raise-frame-1)) (defun emacs-everywhere-raise-frame-1 () (call-process \u0026#34;wmctrl\u0026#34; nil nil nil \u0026#34;-a\u0026#34; emacs-everywhere-frame-name)))      Embrace  1 2  (add-hook \u0026#39;org-mode-hook \u0026#39;gcl/embrace-org-mode-hook) (add-hook \u0026#39;prog-mode-hook \u0026#39;gcl/embrace-prog-mode-hook)      Engine-mode  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55  (use-package! engine-mode :config (engine/set-keymap-prefix (kbd \u0026#34;C-c s\u0026#34;)) ;; (setq engine/browser-function \u0026#39;eww-browse-url) (defengine amazon \u0026#34;http://www.amazon.com/s/ref=nb_sb_noss?url=search-alias%3Daps\u0026amp;field-keywords=%s\u0026#34; :keybinding \u0026#34;a\u0026#34;) (defengine baidu \u0026#34;https://www.baidu.com/s?wd=%s\u0026#34; :keybinding \u0026#34;bb\u0026#34;) (defengine baidu-image \u0026#34;https://image.baidu.com/search/index?tn=baiduimage\u0026amp;word=%s\u0026#34; :keybinding \u0026#34;bi\u0026#34;) (defengine ctan \u0026#34;http://www.ctan.org/search/?x=1\u0026amp;PORTAL=on\u0026amp;phrase=%s\u0026#34; :docstring \u0026#34;Search the Comprehensive TeX Archive Network (ctan.org)\u0026#34; :keybinding \u0026#34;c\u0026#34;) (defengine duckduckgo \u0026#34;https://duckduckgo.com/?q=%s\u0026#34; :keybinding \u0026#34;d\u0026#34;) (defengine github \u0026#34;https://github.com/search?ref=simplesearch\u0026amp;q=%s\u0026#34; :keybinding \u0026#34;g\u0026#34;) (defengine qwant \u0026#34;https://www.qwant.com/?q=%s\u0026#34; :docstring \u0026#34;什么都能搜到哦~~😍😍\u0026#34; :keybinding \u0026#34;q\u0026#34;) (defengine rfcs \u0026#34;http://pretty-rfc.herokuapp.com/search?q=%s\u0026#34; :keybinding \u0026#34;r\u0026#34;) (defengine stack-overflow \u0026#34;https://stackoverflow.com/search?q=%s\u0026#34; :keybinding \u0026#34;s\u0026#34;) (defengine twitter \u0026#34;https://twitter.com/search?q=%s\u0026#34; :keybinding \u0026#34;t\u0026#34;) (defengine wolfram-alpha \u0026#34;http://www.wolframalpha.com/input/?i=%s\u0026#34; :docstring \u0026#34;数学搜索引擎，公式，坐标图等。\u0026#34; :keybinding \u0026#34;w\u0026#34;) ; 数学搜索引擎，公式，坐标图等 (defengine youtube \u0026#34;http://www.youtube.com/results?aq=f\u0026amp;oq=\u0026amp;search_query=%s\u0026#34; :keybinding \u0026#34;y\u0026#34;) (defengine google-images \u0026#34;http://www.google.com/images?hl=en\u0026amp;source=hp\u0026amp;biw=1440\u0026amp;bih=795\u0026amp;gbv=2\u0026amp;aq=f\u0026amp;aqi=\u0026amp;aql=\u0026amp;oq=\u0026amp;q=%s\u0026#34; :keybinding \u0026#34;/i\u0026#34;) (defengine google-maps \u0026#34;http://maps.google.com/maps?q=%s\u0026#34; :docstring \u0026#34;Mappin\u0026#39; it up.\u0026#34; :keybinding \u0026#34;/m\u0026#34;) (defengine google \u0026#34;http://www.google.com/search?ie=utf-8\u0026amp;oe=utf-8\u0026amp;q=%s\u0026#34; :keybinding \u0026#34;//\u0026#34;) (engine-mode 1))      Dash-at-point  1 2 3 4  (use-package! dash-at-point :bind ((\u0026#34;C-x d\u0026#34; . dash-at-point) (\u0026#34;C-x D\u0026#34; . dash-at-point-with-docset)))      Deadgrep   正则搜索要在搜索的结果中，选中 regexp 来筛选。\n 按键绑定：\n   key func     \u0026lt;f5\u0026gt; deadgrep   M-\u0026lt;f5\u0026gt; deadgrep-kill-all-buffers     RET 查看结果   o 在另一个窗口打开   n/p 结果中上下移动   M-n/M-p 文件头尾之间移动   g 重新搜索   TAB 展开/闭合结果   C-c C-k 停止正在执行的搜索      Delsel  1 2 3  (use-package! delsel :config (delete-selection-mode t))      Dotenv-mode  1 2  (use-package! dotenv-mode :mode (\u0026#34;\\\\.env\\\\.?.*\\\\\u0026#39;\u0026#34; . dotenv-mode))      Emoji  …\n  Evil  1 2 3 4 5 6 7 8 9 10 11 12  ;; (defalias \u0026#39;ex! \u0026#39;evil-ex-define-cmd) ;; 快捷操作，通过 : 冒号进入 evil 命令模式 ;; File operations ;; (ex! \u0026#34;cp\u0026#34; #\u0026#39;+evil:copy-this-file) ;; (ex! \u0026#34;mv\u0026#34; #\u0026#39;+evil:move-this-file) ;; (ex! \u0026#34;rm\u0026#34; #\u0026#39;+evil:delete-this-file) ;; window 操作 (setq evil-split-window-below t evil-vsplit-window-right t)      Flycheck   使用项目本身的 eslint, node_modules/.bin/eslint\n1 2 3 4  (use-package! flycheck :config (add-hook \u0026#39;after-init-hook \u0026#39;global-flycheck-mode) (add-hook \u0026#39;flycheck-mode-hook \u0026#39;gcl/use-eslint-from-node-modules))      (Ma)git  1 2 3  (use-package! git-gutter :config (global-git-gutter-mode \u0026#39;t))      Hungry-delete  1 2 3 4  (use-package! hungry-delete :config (add-hook! \u0026#39;after-init-hook #\u0026#39;global-hungry-delete-mode) (global-hungry-delete-mode 1))      Hydra   scimax-hydra.el\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39  (map! :map dired-mode-map \u0026#34;\u0026lt;f2\u0026gt;\u0026#34; #\u0026#39;gcl-dired/body :map ranger-mode-map \u0026#34;\u0026lt;f2\u0026gt;\u0026#34; #\u0026#39;gcl-dired/body :map org-agenda-mode-map \u0026#34;\u0026lt;f2\u0026gt;\u0026#34; #\u0026#39;gcl-agenda-view/body :map web-mode-map \u0026#34;\u0026lt;f2\u0026gt;\u0026#34; #\u0026#39;hydra-web-mode/body ) (defhydra gcl-jump-hydra (:color blue :columns 3 :hint nil) \u0026#34;Jump -\u0026gt; Body\u0026#34; (\u0026#34;a\u0026#34; gcl-agenda-view/body \u0026#34;Org-Agenda\u0026#34;) (\u0026#34;c\u0026#34; gcl-jump-char/body \u0026#34;Char Jump\u0026#34;) (\u0026#34;l\u0026#34; gcl-jump-line/body \u0026#34;Line Jump\u0026#34;) (\u0026#34;w\u0026#34; gcl-jump-word/body \u0026#34;Word Jump\u0026#34;) ) (defhydra gcl-repl-hydra (:color blue :columns 3 :hint nil) \u0026#34;REPL \u0026#34; (\u0026#34;e\u0026#34; ielm \u0026#34; ELisp\u0026#34;) (\u0026#34;h\u0026#34; httprepl \u0026#34; HTTP\u0026#34;) (\u0026#34;j\u0026#34; jq-interactivly \u0026#34; JSON\u0026#34;) (\u0026#34;l\u0026#34; +lua/open-repl \u0026#34; Lua\u0026#34;) (\u0026#34;n\u0026#34; nodejs-repl \u0026#34; Node.js\u0026#34;) (\u0026#34;p\u0026#34; +python/open-repl \u0026#34; Python\u0026#34;) (\u0026#34;s\u0026#34; skewer-repl \u0026#34; Skewer\u0026#34;) ) (defhydra gcl-everything (:color blue :columns 3 :hint nil) \u0026#34;🗯 做任何你想不到的事情~~~~ 👁👁👁👁👁👁👁👁👁 🌻\u0026#34; (\u0026#34;j\u0026#34; gcl-jump-hydra/body \u0026#34;Avy\u0026#34;) (\u0026#34;r\u0026#34; gcl-repl-hydra/body \u0026#34;REPL\u0026#34;) (\u0026#34;v\u0026#34; gcl-verb-hydra/body \u0026#34;Verb\u0026#34;) )    Avy   Char:\n1 2 3 4 5 6 7 8 9  (defhydra gcl-jump-char (:color blue :columns 3 :hint nil) \u0026#34;Jump By Char -\u0026gt;\u0026#34; (\u0026#34;c\u0026#34; avy-goto-char \u0026#34;Char\u0026#34;) (\u0026#34;l\u0026#34; avy-goto-char-in-line \u0026#34;In line\u0026#34;) (\u0026#34;t\u0026#34; avy-goto-char-timer \u0026#34;Timer\u0026#34;) (\u0026#34;2\u0026#34; avy-goto-char-2 \u0026#34;Char2\u0026#34;) (\u0026#34;a\u0026#34; avy-goto-char-2-above \u0026#34;Above\u0026#34;) (\u0026#34;b\u0026#34; avy-goto-char-2-below \u0026#34;Below\u0026#34;) )     Line:\n1 2 3 4 5 6 7  (defhydra gcl-jump-line (:color blue :columns 3 :hint nil) \u0026#34;Jump To Line -\u0026gt;\u0026#34; (\u0026#34;u\u0026#34; avy-goto-line-above \u0026#34;Above\u0026#34;) (\u0026#34;d\u0026#34; avy-goto-line-below \u0026#34;Below\u0026#34;) (\u0026#34;s\u0026#34; avy-goto-line \u0026#34;Line Start\u0026#34;) (\u0026#34;e\u0026#34; avy-goto-end-of-line \u0026#34;Line End\u0026#34;) )     Word:\n1 2 3 4 5 6 7 8 9 10 11 12 13  (defhydra gcl-jump-word (:color blue :columns 3 :hint nil) \u0026#34;Jump By Word -\u0026gt;\u0026#34; (\u0026#34;l\u0026#34; avy-jump-to-word-in-line \u0026#34;in line\u0026#34;) (\u0026#34;w\u0026#34; avy-goto-word-1 \u0026#34;word1\u0026#34;) (\u0026#34;0\u0026#34; avy-goto-word-0 \u0026#34;word0\u0026#34;) (\u0026#34;a\u0026#34; avy-goto-word-0-above \u0026#34;above-0\u0026#34;) (\u0026#34;A\u0026#34; avy-goto-word-1-above \u0026#34;above-1\u0026#34;) (\u0026#34;b\u0026#34; avy-goto-word-0-below \u0026#34;below0\u0026#34;) (\u0026#34;B\u0026#34; avy-goto-word-1-below \u0026#34;below1\u0026#34;) (\u0026#34;o\u0026#34; avy-goto-word-or-subword-1 \u0026#34;word or subword\u0026#34;) (\u0026#34;s\u0026#34; avy-subword-0 \u0026#34;subword-0\u0026#34;) (\u0026#34;S\u0026#34; avy-subword-1 \u0026#34;subword-1\u0026#34;) )      Dired  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53  (defhydra gcl-dired (:color blue :hint nil) \u0026#34; Mark Operate Misc Navigate ---- ------- ---- -------- _fd_: flag del _C_: copy _+_: mkdir _\u0026lt;up\u0026gt;_: up directory _f#_: autosave _R_: rename _o_: open other _f~_: backups _D_: delete _f\u0026amp;_: garbage _F_: open marks _fe_: extension ---- _m_: mark _T_: touch _/_: directories _M_: chmod _@_: symlinks _G_: chgrp _O_: omitted _O_: chown ---- _U_: unmark all _A_: find regx _t_: toggle marks _Q_: find/rep \u0026#34; ;; marking (\u0026#34;t\u0026#34; dired-toggle-marks) (\u0026#34;m\u0026#34; dired-mark :exit nil) (\u0026#34;u\u0026#34; dired-unmark :exit nil) (\u0026#34;fd\u0026#34; dired-flag-file-deletion) (\u0026#34;f#\u0026#34; dired-flag-auto-save-files) (\u0026#34;f~\u0026#34; dired-flag-backup-files) (\u0026#34;f\u0026amp;\u0026#34; dired-flag-garbage-files) (\u0026#34;fe\u0026#34; dired-flag-extension) (\u0026#34;/\u0026#34; dired-mark-directories) (\u0026#34;@\u0026#34; dired-mark-symlinks) (\u0026#34;.\u0026#34; dired-mark-extension) (\u0026#34;O\u0026#34; dired-mark-omitted) (\u0026#34;U\u0026#34; dired-unmark-all-marks) (\u0026#34;C\u0026#34; dired-do-copy) (\u0026#34;R\u0026#34; dired-do-rename) (\u0026#34;D\u0026#34; dired-do-delete :exit nil) (\u0026#34;F\u0026#34; dired-do-find-marked-files) (\u0026#34;!\u0026#34; dired-do-shell-command) (\u0026#34;\u0026amp;\u0026#34; dired-do-async-shell-command) (\u0026#34;T\u0026#34; dired-do-touch) (\u0026#34;M\u0026#34; dired-do-chmod) (\u0026#34;G\u0026#34; dired-do-chgrp) (\u0026#34;O\u0026#34; dired-do-chown) (\u0026#34;A\u0026#34; dired-do-find-regexp) (\u0026#34;Q\u0026#34; dired-do-find-regexp-and-replace) (\u0026#34;+\u0026#34; dired-create-directory) (\u0026#34;o\u0026#34; dired-find-file-other-window) (\u0026#34;\u0026lt;up\u0026gt;\u0026#34; dired-up-directory) )      Movement  1 2 3 4 5  (defhydra hydra-movement () (\u0026#34;j\u0026#34; next-line \u0026#34;down\u0026#34; :column \u0026#34;Vertical\u0026#34;) (\u0026#34;k\u0026#34; previous-line \u0026#34;up\u0026#34;) (\u0026#34;l\u0026#34; forward-char \u0026#34;forward\u0026#34; :column \u0026#34;Horizontal\u0026#34;) (\u0026#34;h\u0026#34; backward-char \u0026#34;back\u0026#34;))      Org-agenda  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38  (defun org-agenda-cts () (and (eq major-mode \u0026#39;org-agenda-mode) (let ((args (get-text-property (min (1- (point-max)) (point)) \u0026#39;org-last-args))) (nth 2 args)))) (defhydra gcl-agenda-view (:color blue :columns 3 :hint none) \u0026#34; _d_: ?d? day _g_: time grid=?g? _a_: arch-trees _w_: ?w? week _[_: inactive _A_: arch-files _t_: ?t? fortnight _f_: follow=?f? _r_: clock report=?r? _m_: ?m? month _e_: entry text=?e? _D_: include diary=?D? _y_: ?y? year _q_: quit _L__l__c_: log = ?l?\u0026#34; (\u0026#34;SPC\u0026#34; org-agenda-reset-view) (\u0026#34;d\u0026#34; org-agenda-day-view (if (eq \u0026#39;day (org-agenda-cts)) \u0026#34;[x]\u0026#34; \u0026#34;[ ]\u0026#34;)) (\u0026#34;w\u0026#34; org-agenda-week-view (if (eq \u0026#39;week (org-agenda-cts)) \u0026#34;[x]\u0026#34; \u0026#34;[ ]\u0026#34;)) (\u0026#34;t\u0026#34; org-agenda-fortnight-view (if (eq \u0026#39;fortnight (org-agenda-cts)) \u0026#34;[x]\u0026#34; \u0026#34;[ ]\u0026#34;)) (\u0026#34;m\u0026#34; org-agenda-month-view (if (eq \u0026#39;month (org-agenda-cts)) \u0026#34;[x]\u0026#34; \u0026#34;[ ]\u0026#34;)) (\u0026#34;y\u0026#34; org-agenda-year-view (if (eq \u0026#39;year (org-agenda-cts)) \u0026#34;[x]\u0026#34; \u0026#34;[ ]\u0026#34;)) (\u0026#34;l\u0026#34; org-agenda-log-mode (format \u0026#34;% -3S\u0026#34; org-agenda-show-log)) (\u0026#34;L\u0026#34; (org-agenda-log-mode \u0026#39;(4))) (\u0026#34;c\u0026#34; (org-agenda-log-mode \u0026#39;clockcheck)) (\u0026#34;f\u0026#34; org-agenda-follow-mode (format \u0026#34;% -3S\u0026#34; org-agenda-follow-mode)) (\u0026#34;a\u0026#34; org-agenda-archives-mode) (\u0026#34;A\u0026#34; (org-agenda-archives-mode \u0026#39;files)) (\u0026#34;r\u0026#34; org-agenda-clockreport-mode (format \u0026#34;% -3S\u0026#34; org-agenda-clockreport-mode)) (\u0026#34;e\u0026#34; org-agenda-entry-text-mode (format \u0026#34;% -3S\u0026#34; org-agenda-entry-text-mode)) (\u0026#34;g\u0026#34; org-agenda-toggle-time-grid (format \u0026#34;% -3S\u0026#34; org-agenda-use-time-grid)) (\u0026#34;D\u0026#34; org-agenda-toggle-diary (format \u0026#34;% -3S\u0026#34; org-agenda-include-diary)) (\u0026#34;!\u0026#34; org-agenda-toggle-deadlines) (\u0026#34;[\u0026#34; (let ((org-agenda-include-inactive-timestamps t)) (org-agenda-check-type t \u0026#39;timeline \u0026#39;agenda) (org-agenda-redo) (message \u0026#34;Display now includes inactive timestamps as well\u0026#34;))) (\u0026#34;q\u0026#34; (message \u0026#34;Abort\u0026#34;) :exit t) (\u0026#34;v\u0026#34; nil) )      Verb  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  (defhydra gcl-verb-hydra (:colors yellow :columns 3 :hint nil) (\u0026#34;r\u0026#34; verb-send-request-on-point-other-window-stay \u0026#34;Send Focus\u0026#34;) (\u0026#34;s\u0026#34; verb-send-request-on-point-other-window \u0026#34;Send Blur\u0026#34;) (\u0026#34;f\u0026#34; verb-send-request-on-point \u0026#34;Fullscreen\u0026#34;) (\u0026#34;m\u0026#34; verb-send-request-on-point-no-window \u0026#34;No Window\u0026#34;) (\u0026#34;K\u0026#34; verb-kill-all-response-buffers \u0026#34;Kill All\u0026#34;) (\u0026#34;vl\u0026#34; verb-show-vars \u0026#34;Show Vars\u0026#34;) (\u0026#34;vl\u0026#34; verb-set-var \u0026#34;Set Var\u0026#34;) (\u0026#34;vu\u0026#34; verb-unset-vars \u0026#34;Unset Vars\u0026#34;) (\u0026#34;ec\u0026#34; verb-export-request-on-point-curl \u0026#34;Export Curl\u0026#34;) (\u0026#34;ev\u0026#34; verb-export-request-on-point-verb \u0026#34;Export Verb\u0026#34;) (\u0026#34;ew\u0026#34; verb-export-request-on-point-verb \u0026#34;Export EWW\u0026#34;) )        Imenu  1  (global-set-key (kbd \u0026#34;C-\u0026#39;\u0026#34;) \u0026#39;imenu-list-smart-toggle)      JS Doc  1 2 3 4 5 6 7 8 9  (use-package! js-doc :bind (:map js2-mode-map (\u0026#34;C-c i\u0026#34; . js-doc-insert-function-doc) (\u0026#34;@\u0026#34; . js-doc-insert-tag)) :config (setq js-doc-mail-address user-mail-address js-doc-author (format \u0026#34;%s\u0026lt;%s\u0026gt;\u0026#34; user-full-name js-doc-mail-address) js-doc-url user-blog-url js-doc-license \u0026#34;MIT\u0026#34;))      Leetcode  1 2 3 4 5  (after! leetcode (setq leetcode-prefer-language \u0026#34;javascript\u0026#34; leetcode-prefer-sql \u0026#34;mysql\u0026#34; leetcode-save-solutions t leetcode-directory \u0026#34;~/github/make-leetcode\u0026#34;))      Link-hint  1 2 3 4 5 6 7  ;; (use-package! link-hint ;; :config ;; (setq ;; browse-url-browser-function \u0026#39;browse-url ;; ;; browse-url-generic-args \u0026#39;(\u0026#34;--target\u0026#34; \u0026#34;tab\u0026#34;) ;; ) ;; )      Lsp  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34  (use-package! lsp-mode :hook ((web-mode . lsp) (rjsx-mode . lsp) (typescript-mode . lsp) ;; (vue-mode . lsp) (python-mode . lsp) (go-mode . lsp) (css-mode . lsp) (js2-mode . lsp) (bibtex-mode . lsp) (tex-mode . lsp) (latex-mode . lsp)) :commands lsp :config (setq lsp-idle-delay 0.2 lsp-enable-file-watchers nil)) (use-package! lsp-ui :commands lsp-ui-mode :config (setq lsp-headerline-breadcrumb-enable t ; 左上角显示文件路径 lsp-lens-enable t ; 显示被引用次数 ) :bind (:map lsp-ui-mode-map ([remap xref-find-definitions] . lsp-ui-peek-find-definitions) ([remap xref-find-references] . lsp-ui-peek-find-references) ([remap xref-pop-marker-stack] . lsp-ui-peek-jump-backward) )) ;; 关闭自动格式化，全局关闭 ;; (setq +form-with-lsp nil) ;; 指定模式 ;; (setq-hook! \u0026#39;typescript-mode-hook +format-with-lsp nil) ;; (setq-hook! \u0026#39;typescript-tsx-mode-hook +format-with-lsp nil)     open Lsp in org source block:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28  (cl-defmacro lsp-org-babel-enable (lang) \u0026#34;Support LANG in org source code block.\u0026#34; (setq centaur-lsp \u0026#39;lsp-mode) (cl-check-type lang stringp) (let* ((edit-pre (intern (format \u0026#34;org-babel-edit-prep:%s\u0026#34; lang))) (intern-pre (intern (format \u0026#34;lsp--%s\u0026#34; (symbol-name edit-pre))))) `(progn (defun ,intern-pre (info) (let ((file-name (-\u0026gt;\u0026gt; info caddr (alist-get :file)))) (unless file-name (setq file-name (make-temp-file \u0026#34;babel-lsp-\u0026#34;))) (setq buffer-file-name file-name) (lsp-deferred))) (put \u0026#39;,intern-pre \u0026#39;function-documentation (format \u0026#34;Enable lsp-mode in the buffer of org source block (%s).\u0026#34; (upcase ,lang))) (if (fboundp \u0026#39;,edit-pre) (advice-add \u0026#39;,edit-pre :after \u0026#39;,intern-pre) (progn (defun ,edit-pre (info) (,intern-pre info)) (put \u0026#39;,edit-pre \u0026#39;function-documentation (format \u0026#34;Prepare local buffer environment for org source block (%s).\u0026#34; (upcase ,lang)))))))) (defvar org-babel-lang-list \u0026#39;(\u0026#34;go\u0026#34; \u0026#34;python\u0026#34; \u0026#34;ipython\u0026#34; \u0026#34;bash\u0026#34; \u0026#34;sh\u0026#34; \u0026#34;js\u0026#34; \u0026#34;typescript\u0026#34; \u0026#34;css\u0026#34;)) (dolist (lang org-babel-lang-list) (eval `(lsp-org-babel-enable ,lang)))      Markdown  Grip-mode   issue: Error (after-save-hook): Error running hook \u0026#34;grip-org-to-md\u0026#34; because: (void-variable vc-log-view-type)\n1 2 3 4 5  ;; (use-package! grip-mode ;; :hook ((markdown-mode org-mode) . grip-mode) ;; :config ;; (setq grip-github-user \u0026#34;gcclll\u0026#34; ;; grip-github-password \u0026#34;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\u0026#34;))      Pandoc-mode  1 2 3 4 5  (use-package! pandoc-mode :after (markdown-mode org-mode) :hook (markdown-mode org-mode) (pandoc-mode . pandoc-load-default-settings))      Vmd-mode  1 2 3 4  (use-package! vmd-mode :after markdown-mode :bind (:map markdown-mode-map (\u0026#34;C-x p\u0026#34; . vmd-mode)))        Maple-iedit  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  (use-package! maple-iedit :commands (maple-iedit-match-all maple-iedit-match-next maple-iedit-match-previous) :config (delete-selection-mode t) (setq maple-iedit-ignore-case t) (defhydra maple/iedit () (\u0026#34;n\u0026#34; maple-iedit-match-next \u0026#34;next\u0026#34;) (\u0026#34;t\u0026#34; maple-iedit-skip-and-match-next \u0026#34;skip and next\u0026#34;) (\u0026#34;T\u0026#34; maple-iedit-skip-and-match-previous \u0026#34;skip and previous\u0026#34;) (\u0026#34;p\u0026#34; maple-iedit-match-previous \u0026#34;prev\u0026#34;)) :bind (:map evil-visual-state-map (\u0026#34;n\u0026#34; . maple/iedit/body) (\u0026#34;C-n\u0026#34; . maple-iedit-match-next) (\u0026#34;C-p\u0026#34; . maple-iedit-match-previous) (\u0026#34;C-t\u0026#34; . map-iedit-skip-and-match-next) (\u0026#34;C-T\u0026#34; . map-iedit-skip-and-match-previous)))      Mu4e   README.org -\u0026gt;\n  Net-utils  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32  (use-package! net-utils :bind (:map mode-specific-map :prefix-map net-utils-prefix-map ; C-c n x :prefix \u0026#34;n\u0026#34; (\u0026#34;p\u0026#34; . ping) (\u0026#34;i\u0026#34; . ifconfig) (\u0026#34;w\u0026#34; . iwconfig) (\u0026#34;n\u0026#34; . netstat) (\u0026#34;p\u0026#34; . ping) (\u0026#34;a\u0026#34; . arp) (\u0026#34;r\u0026#34; . route) (\u0026#34;h\u0026#34; . nslookup-host) (\u0026#34;d\u0026#34; . dig) (\u0026#34;s\u0026#34; . smbclient) (\u0026#34;t\u0026#34; . traceroute))) (use-package! browse-at-remote :config (setq browse-at-remote-remote-type-domains \u0026#39;((\u0026#34;bitbucket.org\u0026#34; . \u0026#34;bitbucket\u0026#34;) (\u0026#34;github.com\u0026#34; . \u0026#34;github\u0026#34;) (\u0026#34;gitlab.com\u0026#34; . \u0026#34;gitlab\u0026#34;) (\u0026#34;git.savannah.gnu.org\u0026#34; . \u0026#34;gnu\u0026#34;) (\u0026#34;gist.github.com\u0026#34; . \u0026#34;gist\u0026#34;) (\u0026#34;git.sr.ht\u0026#34; . \u0026#34;sourcehut\u0026#34;) (\u0026#34;vs-ssh.visualstudio.com\u0026#34; . \u0026#34;ado\u0026#34;) (\u0026#34;pagure.io\u0026#34; . \u0026#34;pagure\u0026#34;) (\u0026#34;src.fedoraproject.org\u0026#34; . \u0026#34;pagure\u0026#34;) (\u0026#34;code.aliyun.com\u0026#34; . \u0026#34;aliyun\u0026#34;) ) ))      Org-mode  Basic  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66  ;; (org-hide-emphasis-markers t) (setq org-list-demote-modify-bullet \u0026#39;((\u0026#34;+\u0026#34; . \u0026#34;-\u0026#34;) (\u0026#34;-\u0026#34; . \u0026#34;+\u0026#34;) (\u0026#34;*\u0026#34; . \u0026#34;+\u0026#34;) (\u0026#34;1.\u0026#34; . \u0026#34;a.\u0026#34;))) ;; (use-package! org ;; :hook ( ;; ;; (verb-mode . org-mode) ;; (+org-pretty-mode . org-mode))) (after! org (add-hook \u0026#39;org-mode-hook (lambda () (visual-line-mode -1))) (org-babel-do-load-languages \u0026#39;org-babel-load-languages (append org-babel-load-languages \u0026#39;((restclient . t) (verb . t)) )) (setq org-todo-keywords \u0026#39;((sequence \u0026#34;TODO(t)\u0026#34; \u0026#34;PROJECT(p)\u0026#34; \u0026#34;NEXT(n)\u0026#34; \u0026#34;WAIT(w)\u0026#34; \u0026#34;HOLD(h)\u0026#34; \u0026#34;IDEA(i)\u0026#34; \u0026#34;SOMEDAY(s)\u0026#34; \u0026#34;MAYBE(m)\u0026#34; \u0026#34;|\u0026#34; \u0026#34;DONE(d)\u0026#34; \u0026#34;CANCELLED(c)\u0026#34;) (sequence \u0026#34;[ ](T)\u0026#34; \u0026#34;[-](S)\u0026#34; \u0026#34;[?](W)\u0026#34; \u0026#34;|\u0026#34; \u0026#34;[X](D)\u0026#34;) ;; (sequence \u0026#34;|\u0026#34; \u0026#34;OKAY(o)\u0026#34; \u0026#34;YES(y)\u0026#34; \u0026#34;NO(x)\u0026#34;) ) org-todo-keyword-faces `((\u0026#34;NEXT\u0026#34; . ,(doom-color \u0026#39;green)) (\u0026#34;TODO\u0026#34; . ,(doom-color \u0026#39;yellow)) (\u0026#34;PROJECT\u0026#34; . ,(doom-color \u0026#39;tan)) (\u0026#34;WAIT\u0026#34; . ,(doom-color \u0026#39;teal)) (\u0026#34;HOLD\u0026#34; . ,(doom-color \u0026#39;red)) (\u0026#34;IDEA\u0026#34; . ,(doom-color \u0026#39;tomato)) ;; (\u0026#34;OKAY\u0026#34; . ,(doom-color \u0026#39;cyan)) ;; ,(if (eq doom-theme \u0026#39;doom-vibrant) ;; (cons \u0026#34;OKAY\u0026#34; (doom-color \u0026#39;base7)) ;; (cons \u0026#34;OKAY\u0026#34; (doom-color \u0026#39;base5))) ;; (\u0026#34;YES\u0026#34; . ,(doom-color \u0026#39;blue)) (\u0026#34;SOMEDAY\u0026#34; . ,(doom-color \u0026#39;base7)) (\u0026#34;MAYBE\u0026#34; . ,(doom-color \u0026#39;base5)) (\u0026#34;[ ]\u0026#34; . ,(doom-color \u0026#39;green)) (\u0026#34;[-]\u0026#34; . ,(doom-color \u0026#39;yellow)) (\u0026#34;[?]\u0026#34; . ,(doom-color \u0026#39;red)) ) ;; org-enforce-todo-dependencies nil ;; if t, it hides todo entries with todo children from agenda ;; org-enforce-todo-checkbox-dependencies nil org-provide-todo-statistics t org-pretty-entities t org-hierarchical-todo-statistics t ;; org-startup-with-inline-images t org-hide-emphasis-markers t ;; org-fontify-whole-heading-line nil org-src-fontify-natively t org-imenu-depth 9 org-use-property-inheritance t org-log-done \u0026#39;time org-log-redeadline \u0026#39;time org-log-reschedule \u0026#39;time org-log-into-drawer \u0026#34;LOGBOOK\u0026#34; ;; org-columns-default-format \u0026#34;%50ITEM(Task) %10CLOCKSUM %16TIMESTAMP_IA\u0026#34; ) )      counsel-org-clock  1 2 3 4 5 6  (use-package! counsel-org-clock :commands (counsel-org-clock-context counsel-org-clock-history counsel-org-clock-goto) :config (setq counsel-org-clock-history-limit 20))      engrave-faces-latex  1 2  (use-package! engrave-faces-latex :after ox-latex)      valign  1 2 3 4 5  (use-package! valign :custom (valign-fancy-bar t) :hook (org-mode . valign-mode))      Verb  1 2 3 4 5 6 7 8 9 10 11 12  ;; (setq verb-base-headers \u0026#39;((\u0026#34;User-Agent\u0026#34; . \u0026#34;my-user-agent\u0026#34;))) ;; unused: b,d,f,g,j,k,m,n,o,p,r,t,u,v,w,x,y,z (use-package! verb :after org :config (setq tempo-template-org-verb \u0026#39;(\u0026#34;#+begin_src verb :wrap src ob-verb-response\u0026#34; nil \u0026#39;\u0026gt; n p n \u0026#34;#+end_src\u0026#34; \u0026gt;) verb-auto-kill-response-buffers t) )    1  get https://api.ipify.org/?format=json     Demos\n  org-clock  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28  (after! org-clock (advice-add #\u0026#39;org-clock-in :after (lambda (\u0026amp;rest _) \u0026#34;Save all opened org-mode files.\u0026#34; (org-save-all-org-buffers))) (advice-add #\u0026#39;org-clock-out :after (lambda (\u0026amp;rest _) \u0026#34;Save all opened org-mode files.\u0026#34; (org-save-all-org-buffers))) (advice-add #\u0026#39;org-clock-load :around #\u0026#39;doom-shut-up-a) (advice-add #\u0026#39;org-clock-report :after (lambda (\u0026amp;rest _) \u0026#34;Save all opened org-mode files.\u0026#34; (org-save-all-org-buffers))) (advice-add #\u0026#39;org-clock-goto :after (lambda (\u0026amp;rest _) \u0026#34;Narrow view after switching.\u0026#34; (interactive) (widen) (+org-narrow-and-show))) (doom-store-persist \u0026#34;custom\u0026#34; \u0026#39;(org-clock-out-time)) (setq org-clock-clocked-in-display nil org-clock-history-length 50 org-clock-in-resume t org-clock-out-remove-zero-time-clocks t org-clock-persist t org-clock-persist-query-resume nil org-clock-report-include-clocking-task t ) )      org-chef  1 2  (use-package! org-chef :commands (org-chef-insert-recipe org-chef-get-recipe-from-url))      org-appear  1 2 3 4 5 6 7  (use-package! org-appear :hook (org-mode . org-appear-mode) :config (setq org-appear-autoemphasis t org-appear-autosubmarkers t org-appear-autolinks nil) )      org-fancy-priorities  1 2 3 4 5 6  (use-package! org-fancy-priorities :diminish :hook (org-mode . org-fancy-priorities-mode) :config (setq org-fancy-priorities-list \u0026#39;(\u0026#34;🅰\u0026#34; \u0026#34;🅱\u0026#34; \u0026#34;🅲\u0026#34; \u0026#34;🅳\u0026#34; \u0026#34;🅴\u0026#34;)))      org-fragtog  1  (add-hook \u0026#39;org-mode-hook \u0026#39;org-fragtog-mode)      ox-gfm  1  (use-package! ox-gfm :after org)      org-pandoc-import  1  (use-package! org-pandoc-import :after org)      org-ol-tree 目录树  1 2 3 4 5 6 7  (use-package! org-ol-tree :commands org-ol-tree) (map! :map org-mode-map :after org :localleader :desc \u0026#34;Outline\u0026#34; \u0026#34;O\u0026#34; #\u0026#39;org-ol-tree)      org-pretty-capture  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108  (defun org-capture-select-template-prettier (\u0026amp;optional keys) \u0026#34;Select a capture template, in a prettier way than default Lisp programs can force the template by setting KEYS to a string.\u0026#34; (let ((org-capture-templates (or (org-contextualize-keys (org-capture-upgrade-templates org-capture-templates) org-capture-templates-contexts) \u0026#39;((\u0026#34;t\u0026#34; \u0026#34;Task\u0026#34; entry (file+headline \u0026#34;\u0026#34; \u0026#34;Tasks\u0026#34;) \u0026#34;* TODO %?\\n %u\\n %a\u0026#34;))))) (if keys (or (assoc keys org-capture-templates) (error \u0026#34;No capture template referred to by \\\u0026#34;%s\\\u0026#34; keys\u0026#34; keys)) (org-mks org-capture-templates \u0026#34;Select a capture template\\n━━━━━━━━━━━━━━━━━━━━━━━━━\u0026#34; \u0026#34;Template key: \u0026#34; `((\u0026#34;q\u0026#34; ,(concat (all-the-icons-octicon \u0026#34;stop\u0026#34; :face \u0026#39;all-the-icons-red :v-adjust 0.01) \u0026#34;\\tAbort\u0026#34;))))))) (advice-add \u0026#39;org-capture-select-template :override #\u0026#39;org-capture-select-template-prettier) (defun org-mks-pretty (table title \u0026amp;optional prompt specials) \u0026#34;Select a member of an alist with multiple keys. Prettified. TABLE is the alist which should contain entries where the car is a string. There should be two types of entries. 1. prefix descriptions like (\\\u0026#34;a\\\u0026#34; \\\u0026#34;Description\\\u0026#34;) This indicates that `a\u0026#39;is a prefix key for multi-letter selection, and that there are entries following with keys like \\\u0026#34;ab\\\u0026#34;, \\\u0026#34;ax\\\u0026#34;… 2. Select-able members must have more than two elements, with the first being the string of keys that lead to selecting it, and the second a short description string of the item. The command will then make a temporary buffer listing all entries that can be selected with a single key, and all the single key prefixes. When you press the key for a single-letter entry, it is selected. When you press a prefix key, the commands (and maybe further prefixes) under this key will be shown and offered for selection. TITLE will be placed over the selection in the temporary buffer, PROMPT will be used when prompting for a key. SPECIALS is an alist with (\\\u0026#34;key\\\u0026#34; \\\u0026#34;description\\\u0026#34;) entries. When one of these is selected, only the bare key is returned.\u0026#34; (save-window-excursion (let ((inhibit-quit t) (buffer (org-switch-to-buffer-other-window \u0026#34;*Org Select*\u0026#34;)) (prompt (or prompt \u0026#34;Select: \u0026#34;)) case-fold-search current) (unwind-protect (catch \u0026#39;exit (while t (setq-local evil-normal-state-cursor (list nil)) (erase-buffer) (insert title \u0026#34;\\n\\n\u0026#34;) (let ((des-keys nil) (allowed-keys \u0026#39;(\u0026#34;\\C-g\u0026#34;)) (tab-alternatives \u0026#39;(\u0026#34;\\s\u0026#34; \u0026#34;\\t\u0026#34; \u0026#34;\\r\u0026#34;)) (cursor-type nil)) ;; Populate allowed keys and descriptions keys ;; available with CURRENT selector. (let ((re (format \u0026#34;\\\\`%s\\\\(.\\\\)\\\\\u0026#39;\u0026#34; (if current (regexp-quote current) \u0026#34;\u0026#34;))) (prefix (if current (concat current \u0026#34; \u0026#34;) \u0026#34;\u0026#34;))) (dolist (entry table) (pcase entry ;; Description. (`(,(and key (pred (string-match re))) ,desc) (let ((k (match-string 1 key))) (push k des-keys) ;; Keys ending in tab, space or RET are equivalent. (if (member k tab-alternatives) (push \u0026#34;\\t\u0026#34; allowed-keys) (push k allowed-keys)) (insert (propertize prefix \u0026#39;face \u0026#39;font-lock-comment-face) (propertize k \u0026#39;face \u0026#39;bold) (propertize \u0026#34;›\u0026#34; \u0026#39;face \u0026#39;font-lock-comment-face) \u0026#34; \u0026#34; desc \u0026#34;…\u0026#34; \u0026#34;\\n\u0026#34;))) ;; Usable entry. (`(,(and key (pred (string-match re))) ,desc . ,_) (let ((k (match-string 1 key))) (insert (propertize prefix \u0026#39;face \u0026#39;font-lock-comment-face) (propertize k \u0026#39;face \u0026#39;bold) \u0026#34; \u0026#34; desc \u0026#34;\\n\u0026#34;) (push k allowed-keys))) (_ nil)))) ;; Insert special entries, if any. (when specials (insert \u0026#34;─────────────────────────\\n\u0026#34;) (pcase-dolist (`(,key ,description) specials) (insert (format \u0026#34;%s %s\\n\u0026#34; (propertize key \u0026#39;face \u0026#39;(bold all-the-icons-red)) description)) (push key allowed-keys))) ;; Display UI and let user select an entry or ;; a sub-level prefix. (goto-char (point-min)) (unless (pos-visible-in-window-p (point-max)) (org-fit-window-to-buffer)) (let ((pressed (org--mks-read-key allowed-keys prompt (not (pos-visible-in-window-p (1- (point-max))))))) (setq current (concat current pressed)) (cond ((equal pressed \u0026#34;\\C-g\u0026#34;) (user-error \u0026#34;Abort\u0026#34;)) ;; Selection is a prefix: open a new menu. ((member pressed des-keys)) ;; Selection matches an association: return it. ((let ((entry (assoc current table))) (and entry (throw \u0026#39;exit entry)))) ;; Selection matches a special entry: return the ;; selection prefix. ((assoc current specials) (throw \u0026#39;exit current)) (t (error \u0026#34;No entry available\u0026#34;))))))) (when buffer (kill-buffer buffer)))))) (advice-add \u0026#39;org-mks :override #\u0026#39;org-mks-pretty)      org-capture  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219  (use-package! doct :commands (doct)) (after! org-capture (defun +doct-icon-declaration-to-icon (declaration) \u0026#34;Convert :icon declaration to icon\u0026#34; (let ((name (pop declaration)) (set (intern (concat \u0026#34;all-the-icons-\u0026#34; (plist-get declaration :set)))) (face (intern (concat \u0026#34;all-the-icons-\u0026#34; (plist-get declaration :color)))) (v-adjust (or (plist-get declaration :v-adjust) 0.01))) (apply set `(,name :face ,face :v-adjust ,v-adjust)))) (defun +doct-iconify-capture-templates (groups) \u0026#34;Add declaration\u0026#39;s :icon to each template group in GROUPS.\u0026#34; (let ((templates (doct-flatten-lists-in groups))) (setq doct-templates (mapcar (lambda (template) (when-let* ((props (nthcdr (if (= (length template) 4) 2 5) template)) (spec (plist-get (plist-get props :doct) :icon))) (setf (nth 1 template) (concat (+doct-icon-declaration-to-icon spec) \u0026#34;\\t\u0026#34; (nth 1 template)))) template) templates)))) (setq doct-after-conversion-functions \u0026#39;(+doct-iconify-capture-templates)) (defvar +org-capture-recipies \u0026#34;~/.gclrc/org/recipies.org\u0026#34;) (defun set-org-capture-templates () (setq org-capture-templates (doct `((\u0026#34;Personal todo\u0026#34; :keys \u0026#34;t\u0026#34; :icon (\u0026#34;checklist\u0026#34; :set \u0026#34;octicon\u0026#34; :color \u0026#34;green\u0026#34;) :file +org-capture-todo-file :prepend t :headline \u0026#34;Inbox\u0026#34; :type entry :template (\u0026#34;* TODO %?\u0026#34; \u0026#34;%i %a\u0026#34;) ) (\u0026#34;Personal note\u0026#34; :keys \u0026#34;n\u0026#34; :icon (\u0026#34;sticky-note-o\u0026#34; :set \u0026#34;faicon\u0026#34; :color \u0026#34;green\u0026#34;) :file +org-capture-todo-file :prepend t :headline \u0026#34;Notes\u0026#34; :type entry :template (\u0026#34;* %?\u0026#34; \u0026#34;%i %a\u0026#34;)) (\u0026#34;Emacs\u0026#34; :keys \u0026#34;e\u0026#34; :icon (\u0026#34;emacs\u0026#34; :set \u0026#34;fileicon\u0026#34; :color \u0026#34;purple\u0026#34;) :file +org-capture-todo-file :prepend t :headline \u0026#34;Emacs\u0026#34; :type entry :template (\u0026#34;* TODO %? :emacs:\u0026#34; \u0026#34;%i %a\u0026#34;)) (\u0026#34;Email\u0026#34; :keys \u0026#34;E\u0026#34; :icon (\u0026#34;envelope\u0026#34; :set \u0026#34;faicon\u0026#34; :color \u0026#34;blue\u0026#34;) :file +org-capture-todo-file :prepend t :headline \u0026#34;Inbox\u0026#34; :type entry :template (\u0026#34;* TODO %^{type|reply to|contact} %\\\\3 %? ✉️\u0026#34; \u0026#34;Send an email %^{urgancy|soon|ASAP|anon|at some point|eventually} to %^{recipiant}\u0026#34; \u0026#34;about %^{topic}\u0026#34; \u0026#34;%U %i %a\u0026#34;)) (\u0026#34;Web\u0026#34; :keys \u0026#34;w\u0026#34; :icon (\u0026#34;web\u0026#34; :set \u0026#34;material\u0026#34; :color \u0026#34;yellow\u0026#34;) :file +org-capture-todo-file :prepend t :headline \u0026#34;Web\u0026#34; :type entry :template (\u0026#34;* TODO %{desc}%? :%{i-type}:\u0026#34; \u0026#34;%i %a\u0026#34;) :children ((\u0026#34;Vue\u0026#34; :keys \u0026#34;v\u0026#34; :icon (\u0026#34;vue\u0026#34; :set \u0026#34;fileicon\u0026#34; :color \u0026#34;green\u0026#34;) :desc \u0026#34;\u0026#34; :headline \u0026#34;Vue\u0026#34; :i-type \u0026#34;web:vue\u0026#34;) (\u0026#34;React\u0026#34; :keys \u0026#34;r\u0026#34; :icon (\u0026#34;react\u0026#34; :set \u0026#34;alltheicon\u0026#34; :color \u0026#34;blue\u0026#34;) :desc \u0026#34;\u0026#34; :headline \u0026#34;React\u0026#34; :i-type \u0026#34;web:react\u0026#34; ) (\u0026#34;JavaScript\u0026#34; :keys \u0026#34;j\u0026#34; :icon (\u0026#34;javascript-shield\u0026#34; :set \u0026#34;alltheicon\u0026#34; :color \u0026#34;yellow\u0026#34;) :desc \u0026#34;\u0026#34; :i-type \u0026#34;web:javascript\u0026#34; ) (\u0026#34;HTML\u0026#34; :keys \u0026#34;h\u0026#34; :icon (\u0026#34;html5\u0026#34; :set \u0026#34;alltheicon\u0026#34; :color \u0026#34;orange\u0026#34;) :desc \u0026#34;\u0026#34; :i-type \u0026#34;web:html\u0026#34; ) (\u0026#34;CSS\u0026#34; :keys \u0026#34;c\u0026#34; :icon (\u0026#34;css3\u0026#34; :set \u0026#34;alltheicon\u0026#34; :color \u0026#34;blue\u0026#34;) :desc \u0026#34;\u0026#34; :i-type \u0026#34;web:css\u0026#34; )) ) (\u0026#34;Interesting\u0026#34; :keys \u0026#34;i\u0026#34; :icon (\u0026#34;eye\u0026#34; :set \u0026#34;faicon\u0026#34; :color \u0026#34;lcyan\u0026#34;) :file +org-capture-todo-file :prepend t :headline \u0026#34;Interesting\u0026#34; :type entry :template (\u0026#34;* [ ] %{desc}%? :%{i-type}:\u0026#34; \u0026#34;%i %a\u0026#34;) :children ((\u0026#34;Webpage\u0026#34; :keys \u0026#34;w\u0026#34; :icon (\u0026#34;globe\u0026#34; :set \u0026#34;faicon\u0026#34; :color \u0026#34;green\u0026#34;) :desc \u0026#34;%(org-cliplink-capture) \u0026#34; :i-type \u0026#34;read:web\u0026#34; ) (\u0026#34;Links\u0026#34; :keys \u0026#34;l\u0026#34; :icon (\u0026#34;link\u0026#34; :set \u0026#34;octicon\u0026#34; :color \u0026#34;blue\u0026#34;) :desc \u0026#34;%(org-cliplink-capture) \u0026#34; :i-type \u0026#34;link:web\u0026#34; ) (\u0026#34;Article\u0026#34; :keys \u0026#34;a\u0026#34; :icon (\u0026#34;file-text\u0026#34; :set \u0026#34;octicon\u0026#34; :color \u0026#34;yellow\u0026#34;) :desc \u0026#34;\u0026#34; :i-type \u0026#34;read:reaserch\u0026#34; ) (\u0026#34;\\tRecipie\u0026#34; :keys \u0026#34;r\u0026#34; :icon (\u0026#34;spoon\u0026#34; :set \u0026#34;faicon\u0026#34; :color \u0026#34;dorange\u0026#34;) :file +org-capture-recipies :headline \u0026#34;Unsorted\u0026#34; :template \u0026#34;%(org-chef-get-recipe-from-url)\u0026#34; ) (\u0026#34;Information\u0026#34; :keys \u0026#34;i\u0026#34; :icon (\u0026#34;info-circle\u0026#34; :set \u0026#34;faicon\u0026#34; :color \u0026#34;blue\u0026#34;) :desc \u0026#34;\u0026#34; :i-type \u0026#34;read:info\u0026#34; ) (\u0026#34;Idea\u0026#34; :keys \u0026#34;I\u0026#34; :icon (\u0026#34;bubble_chart\u0026#34; :set \u0026#34;material\u0026#34; :color \u0026#34;silver\u0026#34;) :desc \u0026#34;\u0026#34; :i-type \u0026#34;idea\u0026#34; ))) (\u0026#34;Tasks\u0026#34; :keys \u0026#34;k\u0026#34; :icon (\u0026#34;inbox\u0026#34; :set \u0026#34;octicon\u0026#34; :color \u0026#34;yellow\u0026#34;) :file +org-capture-todo-file :prepend t :headline \u0026#34;Tasks\u0026#34; :type entry :template (\u0026#34;* TODO %? %^G%{extra}\u0026#34; \u0026#34;%i %a\u0026#34;) :children ((\u0026#34;General Task\u0026#34; :keys \u0026#34;k\u0026#34; :icon (\u0026#34;inbox\u0026#34; :set \u0026#34;octicon\u0026#34; :color \u0026#34;yellow\u0026#34;) :extra \u0026#34;\u0026#34; ) (\u0026#34;Task with deadline\u0026#34; :keys \u0026#34;d\u0026#34; :icon (\u0026#34;timer\u0026#34; :set \u0026#34;material\u0026#34; :color \u0026#34;orange\u0026#34; :v-adjust -0.1) :extra \u0026#34;\\nDEADLINE: %^{Deadline:}t\u0026#34; ) (\u0026#34;Scheduled Task\u0026#34; :keys \u0026#34;s\u0026#34; :icon (\u0026#34;calendar\u0026#34; :set \u0026#34;octicon\u0026#34; :color \u0026#34;orange\u0026#34;) :extra \u0026#34;\\nSCHEDULED: %^{Start time:}t\u0026#34; ) )) (\u0026#34;Project\u0026#34; :keys \u0026#34;p\u0026#34; :icon (\u0026#34;repo\u0026#34; :set \u0026#34;octicon\u0026#34; :color \u0026#34;silver\u0026#34;) :prepend t :type entry :headline \u0026#34;Inbox\u0026#34; :template (\u0026#34;* %{time-or-todo} %?\u0026#34; \u0026#34;%i\u0026#34; \u0026#34;%a\u0026#34;) :file \u0026#34;\u0026#34; :custom (:time-or-todo \u0026#34;\u0026#34;) :children ((\u0026#34;Project-local todo\u0026#34; :keys \u0026#34;t\u0026#34; :icon (\u0026#34;checklist\u0026#34; :set \u0026#34;octicon\u0026#34; :color \u0026#34;green\u0026#34;) :time-or-todo \u0026#34;TODO\u0026#34; :file +org-capture-project-todo-file) (\u0026#34;Project-local note\u0026#34; :keys \u0026#34;n\u0026#34; :icon (\u0026#34;sticky-note\u0026#34; :set \u0026#34;faicon\u0026#34; :color \u0026#34;yellow\u0026#34;) :time-or-todo \u0026#34;%U\u0026#34; :file +org-capture-project-notes-file) (\u0026#34;Project-local changelog\u0026#34; :keys \u0026#34;c\u0026#34; :icon (\u0026#34;list\u0026#34; :set \u0026#34;faicon\u0026#34; :color \u0026#34;blue\u0026#34;) :time-or-todo \u0026#34;%U\u0026#34; :heading \u0026#34;Unreleased\u0026#34; :file +org-capture-project-changelog-file)) ) (\u0026#34;\\tCentralised project templates\u0026#34; :icon (\u0026#34;ionic-project\u0026#34; :set \u0026#34;fileicon\u0026#34; :color \u0026#34;cyan\u0026#34;) :keys \u0026#34;o\u0026#34; :type entry :prepend t :template (\u0026#34;* %{time-or-todo} %?\u0026#34; \u0026#34;%i\u0026#34; \u0026#34;%a\u0026#34;) :children ((\u0026#34;Project todo\u0026#34; :keys \u0026#34;t\u0026#34; :prepend nil :time-or-todo \u0026#34;TODO\u0026#34; :heading \u0026#34;Tasks\u0026#34; :file +org-capture-central-project-todo-file) (\u0026#34;Project note\u0026#34; :keys \u0026#34;n\u0026#34; :time-or-todo \u0026#34;%U\u0026#34; :heading \u0026#34;Notes\u0026#34; :file +org-capture-central-project-notes-file) (\u0026#34;Project changelog\u0026#34; :keys \u0026#34;c\u0026#34; :time-or-todo \u0026#34;%U\u0026#34; :heading \u0026#34;Unreleased\u0026#34; :file +org-capture-central-project-changelog-file)) ))))) (set-org-capture-templates) (unless (display-graphic-p) (add-hook \u0026#39;server-after-make-frame-hook (defun org-capture-reinitialise-hook () (when (display-graphic-p) (set-org-capture-templates) (remove-hook \u0026#39;server-after-make-frame-hook #\u0026#39;org-capture-reinitialise-hook))))))     org-capture bin\n1 2 3 4 5 6 7  (setf (alist-get \u0026#39;height +org-capture-frame-parameters) 15) ;; (alist-get \u0026#39;name +org-capture-frame-parameters) \u0026#34;❖ Capture\u0026#34;) ;; ATM hardcoded in other places, so changing breaks stuff (setq +org-capture-fn (lambda () (interactive) (set-window-parameter nil \u0026#39;mode-line-format \u0026#39;none) (org-capture)))      org-agenda  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53  (after! org-agenda (advice-add #\u0026#39;org-agenda-archive :after #\u0026#39;org-save-all-org-buffers) (advice-add #\u0026#39;org-agenda-archive-default :after #\u0026#39;org-save-all-org-buffers) (advice-add #\u0026#39;org-agenda-refile :after (lambda (\u0026amp;rest _) \u0026#34;Refresh view.\u0026#34; (if (string-match \u0026#34;Org QL\u0026#34; (buffer-name)) (org-ql-view-refresh) (org-agenda-redo)))) (advice-add #\u0026#39;org-agenda-redo :around #\u0026#39;doom-shut-up-a) (advice-add #\u0026#39;org-agenda-set-effort :after #\u0026#39;org-save-all-org-buffers) (advice-add #\u0026#39;org-schedule :after (lambda (\u0026amp;rest _) (org-save-all-org-buffers))) (advice-add #\u0026#39;org-deadline :after (lambda (\u0026amp;rest _) (org-save-all-org-buffers))) (advice-add #\u0026#39;+org-change-title :after (lambda (\u0026amp;rest _) (org-save-all-org-buffers))) (advice-add #\u0026#39;org-cut-special :after #\u0026#39;org-save-all-org-buffers) (advice-add #\u0026#39;counsel-org-tag :after #\u0026#39;org-save-all-org-buffers) (advice-add #\u0026#39;org-agenda-todo :after #\u0026#39;aj-org-agenda-save-and-refresh-a) (advice-add #\u0026#39;org-todo :after (lambda (\u0026amp;rest _) (org-save-all-org-buffers))) (advice-add #\u0026#39;org-agenda-kill :after #\u0026#39;aj-org-agenda-save-and-refresh-a) (setq org-agenda-prefix-format \u0026#39;((agenda . \u0026#34; %-6t %6e \u0026#34;) (timeline . \u0026#34; %-6t %6e \u0026#34;) (todo . \u0026#34; %-6t %6e \u0026#34;) (tags . \u0026#34; %-6t %6e \u0026#34;) (search . \u0026#34;%l\u0026#34;) ) org-agenda-tags-column 80 org-agenda-skip-scheduled-if-done t org-agenda-skip-deadline-if-done t org-agenda-skip-timestamp-if-done t ;; org-agenda-todo-ignore-scheduled t ;; org-agenda-todo-ignore-deadlines t ;; org-agenda-todo-ignore-timestamp t ;; org-agenda-todo-ignore-with-date t org-agenda-start-on-weekday nil ; 从今天开始 org-agenda-todo-list-sublevels t org-agenda-include-deadlines t org-agenda-log-mode-items \u0026#39;(closed clock state) org-agenda-block-separator nil org-agenda-compact-blocks t org-agenda-breadcrumbs-separator \u0026#34; ❱ \u0026#34; org-agenda-current-time-string \u0026#34;⏰ ┈┈┈┈┈┈┈┈┈┈┈ now\u0026#34; org-agenda-sorting-strategy \u0026#39;((agenda habit-down time-up effort-up priority-down category-keep) (todo priority-up effort-up todo-state-up category-keep) (tags priority-down category-keep) (search category-keep)) ) )      org-super-agenda  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42  (use-package! org-super-agenda :commands (org-super-agenda-mode)) (after! org-agenda (org-super-agenda-mode)) (setq org-agenda-custom-commands \u0026#39;((\u0026#34;o\u0026#34; \u0026#34;Overview\u0026#34; ((agenda \u0026#34;\u0026#34; ((org-agenda-span \u0026#39;day) (org-super-agenda-groups \u0026#39;((:name \u0026#34;Today\u0026#34; :time-grid t :date today :todo \u0026#34;TODAY\u0026#34; :scheduled today :order 1))))) (alltodo \u0026#34;\u0026#34; ((org-agenda-overriding-header \u0026#34;\u0026#34;) (org-super-agenda-groups \u0026#39;((:name \u0026#34;Next(接下来)\u0026#34; :todo \u0026#34;NEXT\u0026#34; :order 1) (:name \u0026#34;Important(重要)\u0026#34; :tag \u0026#34;Important\u0026#34; :order 2 :priority \u0026#34;A\u0026#34;) (:name \u0026#34;Due Today(今天完成)\u0026#34; :deadline today :order 3) (:name \u0026#34;Due Soon(很快过期)\u0026#34; :deadline future :order 8) (:name \u0026#34;Overdue(过期)\u0026#34; :deadline past :order 9 :face error) (:name \u0026#34;Emacs\u0026#34; :tag \u0026#34;Emacs\u0026#34; :order 10) (:name \u0026#34;Vue\u0026#34; :tag \u0026#34;Vue\u0026#34; :order 15) (:name \u0026#34;React\u0026#34; :tag \u0026#34;React\u0026#34; :order 18) (:name \u0026#34;Assignments(作业)\u0026#34; :tag \u0026#34;Assignment\u0026#34; :order 20) (:name \u0026#34;Waiting(等待)\u0026#34; :todo \u0026#34;WAITING\u0026#34; :order 21) (:name \u0026#34;To read(阅读)\u0026#34; :tag \u0026#34;Read\u0026#34; :order 25) (:name \u0026#34;Issues(问题)\u0026#34; :tag \u0026#34;Issue\u0026#34; :order 30) (:name \u0026#34;Projects(项目)\u0026#34; :tag \u0026#34;Project\u0026#34; :order 40) (:name \u0026#34;Research(研究)\u0026#34; :tag \u0026#34;Research\u0026#34; :order 50) (:name \u0026#34;University(综合)\u0026#34; :tag \u0026#34;uni\u0026#34; :order 60) (:name \u0026#34;Trivial(不重要)\u0026#34; :priority\u0026lt;= \u0026#34;E\u0026#34; :tag (\u0026#34;Trivial\u0026#34; \u0026#34;Unimportant\u0026#34;) :todo (\u0026#34;SOMEDAY\u0026#34; ) :order 90) (:discard (:tag (\u0026#34;Chore\u0026#34; \u0026#34;Routine\u0026#34; \u0026#34;Daily\u0026#34;)))))))))))      org-roam  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22  ;; (use-package! org-roam-lib ;; :after org-roam) (use-package! org-roam :config (setq org-roam-file-extensions \u0026#39;(\u0026#34;txt\u0026#34; \u0026#34;org\u0026#34;) org-roam-capture-templates (quote ((\u0026#34;d\u0026#34; \u0026#34;default\u0026#34; plain (function org-roam-capture--get-point) \u0026#34;%?\u0026#34; :file-name \u0026#34;%\u0026lt;%Y_%m%d\u0026gt;_${slug}\u0026#34; :head \u0026#34;#+TITLE: ${title}\\n\\n\u0026#34; :unnarrowed t))) ) (org-roam-setup) :bind ((\u0026#34;C-c r l\u0026#34; . org-roam-buffer-toggle) (\u0026#34;C-c r f\u0026#34; . org-roam-node-find) (\u0026#34;C-c r g\u0026#34; . org-roam-graph) (\u0026#34;C-c r i\u0026#34; . org-roam-node-insert) (\u0026#34;C-c r c\u0026#34; . org-roam-capture) (\u0026#34;C-c r j\u0026#34; . org-roam-dailies-capture-today) ))      org-preview-html  1 2  (use-package! org-preview-html :after org)      org-download  1 2 3 4 5 6 7  (use-package! org-download :after org :bind (:map org-mode-map ((\u0026#34;s-Y\u0026#34; . org-download-screenshot) (\u0026#34;s-y\u0026#34; . org-download-yank))) )      mathpix.el   mathpix.el uses Mathpix’s API to convert clips into latex equations:\n 要收费~。\n1 2 3 4 5  ;; (use-package! mathpix.el ;; :custom ((mathpix-app-id \u0026#34;app-id\u0026#34;) ;; (mathpix-app-key \u0026#34;app-key\u0026#34;)) ;; :bind ;; (\u0026#34;C-x m\u0026#34; . mathpix-screenshot))        OSX   Keybindings:\n  Parrot  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54  (use-package! parrot :config (parrot-mode)) (setq parrot-rotate-dict \u0026#39;( (:rot (\u0026#34;alpha\u0026#34; \u0026#34;beta\u0026#34;) :caps t :lower nil) ;; =\u0026gt; rotations are \u0026#34;Alpha\u0026#34; \u0026#34;Beta\u0026#34; (:rot (\u0026#34;snek\u0026#34; \u0026#34;snake\u0026#34; \u0026#34;stawp\u0026#34;)) ;; =\u0026gt; rotations are \u0026#34;snek\u0026#34; \u0026#34;snake\u0026#34; \u0026#34;stawp\u0026#34; (:rot (\u0026#34;yes\u0026#34; \u0026#34;no\u0026#34;) :caps t :upcase t) ;; =\u0026gt; rotations are \u0026#34;yes\u0026#34; \u0026#34;no\u0026#34;, \u0026#34;Yes\u0026#34; \u0026#34;No\u0026#34;, \u0026#34;YES\u0026#34; \u0026#34;NO\u0026#34; (:rot (\u0026#34;\u0026amp;\u0026#34; \u0026#34;|\u0026#34;)) ;; =\u0026gt; rotations are \u0026#34;\u0026amp;\u0026#34; \u0026#34;|\u0026#34; ;; default dictionary starts here (\u0026#39;v\u0026#39;) (:rot (\u0026#34;begin\u0026#34; \u0026#34;end\u0026#34;) :caps t :upcase t) (:rot (\u0026#34;enable\u0026#34; \u0026#34;disable\u0026#34;) :caps t :upcase t) (:rot (\u0026#34;enter\u0026#34; \u0026#34;exit\u0026#34;) :caps t :upcase t) (:rot (\u0026#34;forward\u0026#34; \u0026#34;backward\u0026#34;) :caps t :upcase t) (:rot (\u0026#34;front\u0026#34; \u0026#34;rear\u0026#34; \u0026#34;back\u0026#34;) :caps t :upcase t) (:rot (\u0026#34;get\u0026#34; \u0026#34;set\u0026#34;) :caps t :upcase t) (:rot (\u0026#34;high\u0026#34; \u0026#34;low\u0026#34;) :caps t :upcase t) (:rot (\u0026#34;in\u0026#34; \u0026#34;out\u0026#34;) :caps t :upcase t) (:rot (\u0026#34;left\u0026#34; \u0026#34;right\u0026#34;) :caps t :upcase t) (:rot (\u0026#34;min\u0026#34; \u0026#34;max\u0026#34;) :caps t :upcase t) (:rot (\u0026#34;on\u0026#34; \u0026#34;off\u0026#34;) :caps t :upcase t) (:rot (\u0026#34;prev\u0026#34; \u0026#34;next\u0026#34;)) (:rot (\u0026#34;start\u0026#34; \u0026#34;stop\u0026#34;) :caps t :upcase t) (:rot (\u0026#34;true\u0026#34; \u0026#34;false\u0026#34;) :caps t :upcase t) (:rot (\u0026#34;\u0026amp;\u0026amp;\u0026#34; \u0026#34;||\u0026#34;)) (:rot (\u0026#34;==\u0026#34; \u0026#34;!=\u0026#34;)) (:rot (\u0026#34;===\u0026#34; \u0026#34;!==\u0026#34;)) (:rot (\u0026#34;.\u0026#34; \u0026#34;-\u0026gt;\u0026#34;)) (:rot (\u0026#34;if\u0026#34; \u0026#34;else\u0026#34; \u0026#34;elif\u0026#34;)) (:rot (\u0026#34;ifdef\u0026#34; \u0026#34;ifndef\u0026#34;)) ;; javascript (:rot (\u0026#34;var\u0026#34; \u0026#34;let\u0026#34; \u0026#34;const\u0026#34;)) (:rot (\u0026#34;null\u0026#34; \u0026#34;undefined\u0026#34;)) (:rot (\u0026#34;number\u0026#34; \u0026#34;object\u0026#34; \u0026#34;string\u0026#34; \u0026#34;symbol\u0026#34;)) ;; c/... (:rot (\u0026#34;int8_t\u0026#34; \u0026#34;int16_t\u0026#34; \u0026#34;int32_t\u0026#34; \u0026#34;int64_t\u0026#34;)) (:rot (\u0026#34;uint8_t\u0026#34; \u0026#34;uint16_t\u0026#34; \u0026#34;uint32_t\u0026#34; \u0026#34;uint64_t\u0026#34;)) (:rot (\u0026#34;1\u0026#34; \u0026#34;2\u0026#34; \u0026#34;3\u0026#34; \u0026#34;4\u0026#34; \u0026#34;5\u0026#34; \u0026#34;6\u0026#34; \u0026#34;7\u0026#34; \u0026#34;8\u0026#34; \u0026#34;9\u0026#34; \u0026#34;10\u0026#34;)) (:rot (\u0026#34;1st\u0026#34; \u0026#34;2nd\u0026#34; \u0026#34;3rd\u0026#34; \u0026#34;4th\u0026#34; \u0026#34;5th\u0026#34; \u0026#34;6th\u0026#34; \u0026#34;7th\u0026#34; \u0026#34;8th\u0026#34; \u0026#34;9th\u0026#34; \u0026#34;10th\u0026#34;)) ;; org (:rot (\u0026#34;DONE\u0026#34; \u0026#34;DOING\u0026#34; \u0026#34;WAITING\u0026#34; \u0026#34;PENDING\u0026#34;)) (:rot (\u0026#34;increment\u0026#34;, \u0026#34;decrement\u0026#34;)) ))      PDF   Popper  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28  (use-package! popper :bind (\u0026#34;C-`\u0026#34; . popper-toggle-latest) (\u0026#34;C-~\u0026#34; . popper-cycle) (\u0026#34;C-s-`\u0026#34; . popper-kill-latest-popup) :custom (popper-reference-buffers \u0026#39;(\u0026#34;*eshell*\u0026#34; \u0026#34;*vterm*\u0026#34; \u0026#34;*color-rg*\u0026#34; \u0026#34;Output\\\\*$\u0026#34; \u0026#34;*Process List*\u0026#34; \u0026#34;COMMIT_EDITMSG\u0026#34; embark-collect-mode deadgrep-mode grep-mode rg-mode rspec-compilation-mode inf-ruby-mode nodejs-repl-mode ts-comint-mode compilation-mode)) :config (defun zero-point-thirty-seven () 0.37) (advice-add \u0026#39;popper-determine-window-height :override #\u0026#39;zero-point-thirty-seven) :init (popper-mode) )      Projectile   ignore some directories.\n1 2 3 4  (setq projectile-ignored-projects \u0026#39;(\u0026#34;~/\u0026#34; \u0026#34;/tmp\u0026#34; \u0026#34;~/.emacs.d/.local/straight/repos/\u0026#34;)) (defun projectile-ignored-project-function (filepath) \u0026#34;Return t if FILEPATH is within any of `projectile-ignored-projects\u0026#39;\u0026#34; (or (mapcar (lambda (p) (s-starts-with-p p filepath)) projectile-ignored-projects)))      Projector  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17  (use-package! projector :after (projectile vterm)) (map! (:prefix \u0026#34;s-p\u0026#34; \u0026#34;b\u0026#34; #\u0026#39;projector-switch-to-shell-buffer \u0026#34;-\u0026#34; #\u0026#39;projector-rerun-buffer-process (:prefix (\u0026#34;r\u0026#34; . \u0026#34;Run\u0026#34;) \u0026#34;c\u0026#34; #\u0026#39;projector-run-shell-command-current-directory-background \u0026#34;C\u0026#34; #\u0026#39;projector-run-shell-command-current-directory \u0026#34;r\u0026#34; #\u0026#39;projector-run-shell-command-project-root-background \u0026#34;R\u0026#34; #\u0026#39;projector-run-shell-command-project-root ) ) )      Ranger  1 2 3  (after! ranger :config (setq ranger-show-literal nil))      Restclient  1 2 3 4 5 6 7 8 9 10 11 12  (use-package! restclient :mode ((\u0026#34;\\\\.rest\\\\\u0026#39;\u0026#34; . restclient-mode) (\u0026#34;\\\\.restclient\\\\\u0026#39;\u0026#34; . restclient-mode))) (use-package! restclient-jq :after restclient) (use-package! ob-restclient :after org restclient :init (org-babel-do-load-languages \u0026#39;org-babel-load-languages \u0026#39;((restclient . t))))      Smartparen  1 2 3 4 5 6 7 8 9 10 11 12 13  (sp-local-pair \u0026#39;(org-mode) \u0026#34;\u0026lt;\u0026lt;\u0026#34; \u0026#34;\u0026gt;\u0026gt;\u0026#34; :actions \u0026#39;(insert)) (use-package! smartparens :init (map! :map smartparens-mode-map \u0026#34;C-)\u0026#34; #\u0026#39;sp-forward-slurp-sexp \u0026#34;C-(\u0026#34; #\u0026#39;sp-forward-barf-sexp \u0026#34;C-{\u0026#34; #\u0026#39;sp-backward-slurp-sexp \u0026#34;C-}\u0026#34; #\u0026#39;sp-backward-barf-sexp ))      Server  卡死了…\n1 2 3 4 5 6 7 8 9 10  ;; (use-package! server ;; :unless (or noninteractive ;; alternate-emacs) ;; :no-require ;; :config ;; (unless (file-exists-p \u0026#34;/tmp/gcl-emacs\u0026#34;) ;; (make-directory \u0026#34;/tmp/gcl-emacs\u0026#34;) ;; (chmod \u0026#34;/tmp/gcl-emacs\u0026#34; 448)) ;; (setq server-socket-dir \u0026#34;/tmp/gcl-emacs\u0026#34;) ;; :hook (after-init . server-start))      Sudo-edit  1 2  (map! )      Treemacs  1 2 3 4 5 6 7 8  (after! treemacs (setq evil-treemacs-state-cursor \u0026#39;box treemacs-project-follow-cleanup t treemacs-width 25 ) (treemacs-follow-mode +1) )      Visual-regexp  1 2 3 4 5  (use-package! visual-regexp :commands (vr/select-replace vr/select-query-replace)) (use-package! visual-regexp-steriods :commands (vr/select-replace vr/select-query-replace))      Which-key   Doom Emacs default configuration is too slow, let’s speed it up.\n1 2 3 4 5 6 7 8 9 10 11 12  (after! which-key (setq! which-key-idle-delay 0.1 which-key-idle-secondary-delay 0.2)) ;; dont display evilem-... (setq which-key-allow-multiple-replacements t) (after! which-key (pushnew! which-key-replacement-alist \u0026#39;((\u0026#34;\u0026#34; . \u0026#34;\\\\`+?evil[-:]?\\\\(?:a-\\\\)?\\\\(.*\\\\)\u0026#34;) . (nil . \u0026#34;◂\\\\1\u0026#34;)) \u0026#39;((\u0026#34;\\\\`g s\u0026#34; . \u0026#34;\\\\`evilem--?motion-\\\\(.*\\\\)\u0026#34;) . (nil . \u0026#34;◃\\\\1\u0026#34;)) ))      YASnippets  1 2 3 4 5 6 7  (setq yas-triggers-in-field t) (use-package! doom-snippets ; hlissner :after yasnippet) (use-package! yasnippet-snippets ; AndreaCrotti :after yasnippet)        Development Settings  1 2 3 4 5 6 7 8  (add-to-list \u0026#39;auto-mode-alist \u0026#39;(\u0026#34;\\\\.js\\\\(x\\\\)?\\\\\u0026#39;\u0026#34; . rjsx-mode)) (add-to-list \u0026#39;auto-mode-alist \u0026#39;(\u0026#34;\\\\.vue\\\\\u0026#39;\u0026#34; . web-mode)) (add-to-list \u0026#39;auto-mode-alist \u0026#39;(\u0026#34;\\\\.[a-z]+rc$\u0026#34; . conf-mode)) (add-to-list \u0026#39;auto-mode-alist \u0026#39;(\u0026#34;\\\\.vim\\\\(rc\\\\)?\\\\\u0026#39;\u0026#34; . vimrc-mode)) (add-to-list \u0026#39;auto-mode-alist \u0026#39;(\u0026#34;[Mm]akefile\u0026#34; . makefile-gmake-mode)) (add-to-list \u0026#39;auto-mode-alist \u0026#39;(\u0026#34;\\\\.mak$\u0026#34; . makefile-gmake-mode)) (add-to-list \u0026#39;auto-mode-alist \u0026#39;(\u0026#34;\\\\.make$\u0026#34; . makefile-gmake-mode)) (add-to-list \u0026#39;auto-mode-alist \u0026#39;(\u0026#34;[._]bash.*\u0026#34; . shell-script-mode))    Web   Use `.prettierrc` file for prettier.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14  (defun maybe-use-prettier () \u0026#34;Enable prettier-js-mode if an rc file is located.\u0026#34; (if (locate-dominating-file default-directory \u0026#34;.prettierrc\u0026#34;) (prettier-js-mode +1))) (add-hook \u0026#39;typescript-mode-hook \u0026#39;maybe-use-prettier) (add-hook \u0026#39;js2-mode-hook \u0026#39;maybe-use-prettier) (add-hook \u0026#39;web-mode-hook \u0026#39;maybe-use-prettier) (add-hook \u0026#39;rjsx-mode-hook \u0026#39;maybe-use-prettier) ;; set docsets (after! (:any js-mode js2-mode rjsx-mode web-mode typescript-mode) (set-docsets! \u0026#39;(js-mode js2-mode rjsx-mode web-mode typescript-mode) \u0026#34;JavaScript\u0026#34; \u0026#34;AngularJS\u0026#34; \u0026#34;Bootstrap_4\u0026#34; \u0026#34;jQuery\u0026#34; \u0026#34;NodeJS\u0026#34; \u0026#34;React\u0026#34; \u0026#34;VueJS\u0026#34; \u0026#34;TypeScript\u0026#34;))    jest  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18  (use-package! jest :after js2-mode :config (advice-add #\u0026#39;jest--project-root :around (lambda (orig-fn \u0026amp;rest args) (if (string-match \u0026#34;exercism\u0026#34; (projectile-project-name)) (cl-letf (((symbol-function \u0026#39;projectile-project-root) (lambda (\u0026amp;rest _) (file-name-directory buffer-file-name)))) (apply orig-fn args)) (apply orig-fn args)))) (setq jest-pdb-track nil) (add-hook \u0026#39;jest-mode-hook (lambda () (evil-motion-state) )) (set-popup-rule! \u0026#34;*jest\\*\u0026#34; :size 20 :side \u0026#39;bottom :select t :quit t :modeline nil) )      react  1 2  (use-package! js-react-redux-yasnippets :after yasnippet)        Python  1 2 3 4 5 6 7 8 9 10 11 12 13 14  (after! python (set-docsets! \u0026#39;python-mode \u0026#34;Python_3\u0026#34;) (set-popup-rule! \u0026#34;*Python*\u0026#34; :size 16 :vslot -2 :side \u0026#39;bottom :select t :quit t :ttl nil :modeline nil) ) (after! python-pytest (advice-add #\u0026#39;python-pytest--find-test-file :around (lambda (orig-fn \u0026amp;rest args) (if (string-match \u0026#34;exercism\u0026#34; (projectile-project-name)) (concat (file-name-sans-extension (buffer-file-name)) \u0026#34;_test.py\u0026#34;) (apply orig-fn args)))) )      Java  Jdee ?       My Packages  Development  1 2 3 4 5 6 7 8 9  (package! dotenv-mode) (package! leetcode) (package! ob-restclient) ;; FIX: jq-set-var not found (package! restclient-jq :recipe (:host github :repo \u0026#34;pashky/restclient.el\u0026#34; :files (\u0026#34;restclient-jq.el\u0026#34;))) ;; (package! ob-jq)    WEB  1 2 3 4 5 6 7 8 9 10 11 12 13 14  (package! instant-rename-tag :recipe (:host github :repo \u0026#34;manateelazycat/instant-rename-tag\u0026#34;)) (package! js-doc) (package! js-react-redux-yasnippets) (package! jest) (package! phpactor) (package! prettier-js) (package! ob-typescript) (package! web-beautify) ;; (package! ts-comint) (package! dash-at-point :recipe (:host github :repo \u0026#34;waymondo/dash-at-point\u0026#34;))        F\u0026amp;D   File and directory management packages.\n1 2 3 4 5  (package! crux) (package! deft) (package! autoinsert) (package! ranger) (package! sudo-edit)      Window   Window management packages.\n1 2  (package! popper :recipe (:host github :repo \u0026#34;waymondo/popper\u0026#34;) :disable t)      Funny  1 2  (package! selectric-mode :pin \u0026#34;1840de71f7414b7cd6ce425747c8e26a413233aa\u0026#34;)      MacOS  1 2 3 4 5 6 7 8  (package! osx-lib) (package! emacs-everywhere :recipe (:host github :repo \u0026#34;tecosaur/emacs-everywhere\u0026#34;)) (package! systemd :pin \u0026#34;b6ae63a236605b1c5e1069f7d3afe06ae32a7bae\u0026#34;) (package! counsel-osx-app) (package! prodigy)      Markdown   Network  1 2 3 4 5 6  (package! counsel-tramp) (package! net-utils) (package! engine-mode) ;; (package! server) (package! verb) (package! httprepl)      Org  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29  (package! counsel-org-clock) (package! doct :recipe (:host github :repo \u0026#34;progfolio/doct\u0026#34;)) ;; hightlight latex export results (package! engrave-faces :recipe (:host github :repo \u0026#34;tecosaur/engrave-faces\u0026#34;)) (package! org-appear) (package! org-chef) (package! org-fancy-priorities) (package! org-fragtog) (package! graphviz-dot-mode) (package! org-pandoc-import :recipe (:host github :repo \u0026#34;tecosaur/org-pandoc-import\u0026#34; :files (\u0026#34;*.el\u0026#34; \u0026#34;filters\u0026#34; \u0026#34;preprocessors\u0026#34;))) (package! org-super-agenda) (package! ox-gfm) (package! org-ol-tree :recipe (:host github :repo \u0026#34;Townk/org-ol-tree\u0026#34;)) (package! org-sort-tasks :recipe (:host github :repo \u0026#34;felipelalli/org-sort-tasks\u0026#34;)) (package! org-preview-html :disable t) (package! org-download) (package! org-roam) ;; (package! mathpix.el ;; :recipe ((:host github :repo \u0026#34;jethrokuan/mathpix.el\u0026#34;))) (package! lsp-latex)      PDF   Projectile  1 2 3 4 5  (package! bm) (package! imenu-list) (package! git-gutter) (package! projector) (package! yasnippet-snippets)      Search  1 2 3 4 5 6 7  (package! anzu) (package! deadgrep) (package! color-rg :recipe (:host github :repo \u0026#34;manateelazycat/color-rg\u0026#34;)) (package! visual-regexp) (package! visual-regexp-steriods :recipe (:host github :repo \u0026#34;benma/visual-regexp-steroids.el\u0026#34;)) (package! youdao-dictionary)      Text Operation  1 2 3 4 5 6 7 8 9 10 11 12 13  (package! cycle-quotes) (package! delsel) (package! hungry-delete) (package! move-text) (package! pangu-spacing) (package! pandoc-mode) (package! parrot) (package! string-inflection) (package! maple-iedit :recipe (:host github :repo \u0026#34;honmaple/emacs-maple-iedit\u0026#34;)) (package! vmd-mode) (package! vimrc-mode)      EAF  1 2 3 4 5 6 7 8  ;; (when (package! eaf :recipe (:host github ;; :repo \u0026#34;manateelazycat/emacs-application-framework\u0026#34; ;; :files (\u0026#34;*.el\u0026#34; \u0026#34;*.py\u0026#34; \u0026#34;app\u0026#34; \u0026#34;core\u0026#34;) ;; :build (:not compile))) ;; (package! ctable :recipe (:host github :repo \u0026#34;kiwanami/emacs-ctable\u0026#34;)) ;; (package! deferred :recipe (:host github :repo \u0026#34;kiwanami/emacs-deferred\u0026#34;)) ;; (package! epc :recipe (:host github :repo \u0026#34;kiwanami/emacs-epc\u0026#34;)))      Disabled  1  (disable-packages! bookmark tide eldoc valign grip-mode)        Practices  Evil-mode   常用的按键练习 1️⃣ 2️⃣ 3️⃣ 🏃‍♂️ 。\n 可以重写的键值，用处不大：\n g _, g ^, g a, g A, g e/E, g i/I, g J, g l/L, g m, g n/N\n g o/O, g u/U, g v/V, g y/Y\n g [x]    函数头尾跳转\n g [, beginning-of-defun\n g ], end-of-defun\n  注释前后一行\n g c -\u0026gt; [n] j/k, nc-comment-operator, [n] 可以输入数字来说明将要被注释的行数\n  查找并打开文件\n g f, +lookup/file, 支持链接\n g F, evil-find-file-at-point-with-line, 打开文件并跳到对应的行\n 如： ~/github/tmp/test/a.js:10 按下 g f/F 后会直接在当前窗口内打开该\n 文件并且跳转到第 10 行。\n  跳到标题位置\n g h, org-up-element, 当前的标题处\n g H, org-top, 当前的一级标题处, 比如在这里按会跳到 Practices\n g j, org-forward-element, 下一个同级元素(标题，段，行，等)\n g k, org-backward-element, 上一个同级元素(标题，段，行，等)\n  imenu\n g O, imenu\n  粘贴替换\n g p, /alt-paste , 选中状态，按下后将粘贴板上的内容替换选中的内容\n  填充文本\n g w/W, evil-fill\n g q, fill-and-move, 将持中内容变成一行？\n g Q, org-fill-paragraph\n 实用案例，如：\ntest1 test2 test3 test4 test5 test6 test7 test8 test9   选中上面的 test1-9 按下 g q 后变成：\ntest1 test2 test3 test4 test5 test6 test7 test8 test9   这对文本格式化挺有用的。\n  执行代码\n g r, +eval:region, 执行选中区域代码\n g R, +eval/buffer, 执行整个 Buffer\n  切换工作区\n g t/T, +workspace:switch-next/previous 切换工作区\n  交换，需要先选中\n g x/X, evil-exchange\n 如： aaa - bbb\n -\u0026gt; 选中 aaa -\u0026gt; gx -\u0026gt; 选中 bbb -\u0026gt; gx\n 结果： bbb - aaa\n    g s, 搜索定位   通过按下组合键之后，根据显示的字符来将光标定位到输入的字符位置。\n  所有窗口\n gs -\u0026gt; SPC, closure\n  块，前半部分\n gs -\u0026gt; [[, backward-section-begin, 定位当前位置前半部分块首\n gs -\u0026gt; [], backward-section-end, 定位当前位置前半部分块尾\n  块，后半部分\n gs -\u0026gt; ][, forward-section-begin, 定位当前位置后半部分块首\n gs -\u0026gt; ]], forward-section-end, 定位当前位置后半部分块尾\n  search\n gs -\u0026gt; #, search-word-backward\n gs -\u0026gt; *, search-word-forward\n  非空行\n gs -\u0026gt; -, previous-line-first-non-blank, 向前\n gs -\u0026gt; +, next-line-first-non-blank, 向后\n  avy\n gs -\u0026gt; /,, avy-goto-char-timer\n gs -\u0026gt; l, avy-goto-char-0, 零字符搜索\n gs -\u0026gt; s, avy-goto-char-2, 两个字符搜索\n  单词开始和结束\n gs -\u0026gt; b/B, backward-word|WORD-begin, 向后\n gs -\u0026gt; [g] e/E, backward-word|WORD-end, 向后\n gs -\u0026gt; w/W, forward-word|WORD-begin, 向前\n  查找字符\n gs -\u0026gt; f, find-char, 向前\n gs -\u0026gt; F, find-char-backward, 向后\n gs -\u0026gt; t, find-char-to\n gs -\u0026gt; T, find-char-to-backward\n  可视行, 即忽略折叠的行\n gs -\u0026gt; gj, next-visual-line\n gs -\u0026gt; gk, previous-visual-line\n  上下行\n gs -\u0026gt; j, next-line\n gs -\u0026gt; k, previous-line\n      Embrace(,e)   practices place…\nembrach-add(,ea)   embrach-change(,ec)   embrach-delete(,ed)     Emms     ","permalink":"https://www.cheng92.com/emacs/doom-emacs-with-org/","tags":null,"title":"Doom Emacs Configuration"},{"categories":null,"contents":"","permalink":"https://www.cheng92.com/search/","tags":null,"title":"Search Results"}]