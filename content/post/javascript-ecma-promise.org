#+TITLE: JavaScript - Promise 实现(0-1)
#+DATE: <2020-10-12 23:26:38>
#+TAGS[]: javascript, es6, promise
#+CATEGORIES[]: javascript
#+LANGUAGE: zh-cn
#+STARTUP: indent

#+begin_export html
<script src="/js/promise.js"></script>
#+end_export

#+begin_quote
源码参考链接：https://github.com/stefanpenner/es6-promise
#+end_quote

@@html:<kbd>@@
[[/js/promise.js][完整的 promise.js 链接]]
@@html:</kbd>@@ 

* 完整脑图

持续更新至完成...

[[/img/es/es6-promise.svg]]

* 构造函数 Promise
  1. 三个状态: ~PENDING~, ~FULFILL~, ~REJECT~ 。
  2. PID 记录 promise id 属性
  3. ~_state~ 当前 promise 的状态(pending/fulfill/reject)
  4. ~_result~ 当前 promise 任务执行的结果值
  5. ~_subs~ 当前 promise 的订阅者(then 时注册的 resolver/rejection)
  6. 构造函数中立即执行 resolver 根据任务执行情况由使用者决定是调用
     resolvePromise 还是 rejectPromise
  
  #+begin_src js
    var PID = Math.random().toString(36).substring(2);
    var PENDING = 0;
    var FULFILL = 1;
    var REJECT = 2;
    var i = 0;
    var proto = MyPromise.prototype;
    var noop = function () {};

    function MyPromise(resolver) {
      this[PID] = i++;
      this._state = PENDING;
      this._result = undefined;
      this._subs = [];

      if (!this instanceof Promise) {
        throw new TypeError("只能通过new 构造 Promise 实例。");
      }

      var _this = this;
      try {
        resolver(
          function resolvePromise(value) {
            resolve(_this, value);
          },
          function rejectPromise(reason) {
            reject(_this, reason);
          }
        );
      } catch (e) {
        reject(this, e);
      }
    }
    MyPromise.prototype.then = then;

    function resolve(val) {
      console.log(val, 'resolve')
    }
    function reject() {}
  #+end_src

  测试：

  #+begin_src js
    const { MyPromise, Util} = require(`${process.env.PWD}/../../static/js/promise.js`)
    const p = new MyPromise(function (resolve, reject) {
      Util.delay(() => resolve(100), 1000)
    })
  #+end_src

  #+RESULTS:
  : 100 resolve

* resolve 和 reject 函数
  
这两个函数至关重要，他们负责改变 promise 的状态值，也是整个 Promise 实现过程中唯
一能改变状态值的地方。

他们的执行会触发所有回调的执行(~promise._subs~)。

#+begin_src js
  function resolve(promise, value) {
    if (promise === value) {
      reject(promise, Util.error.returnSelfPromise());
    } else if (Util.isObjectOrFunction(value)) {
      // TODO
    } else {
      fulfill(promise, value);
    }
  }

  function reject(promise, reason) {
    if (promise._state !== PENDING) {
      return;
    }

    promise._state = REJECT;
    promise._result = reason;

    asap(function () {
      publish(promise);
    });
  }
#+end_src

* asap 函数

#+begin_src js
  // 将所有任务添加到一个队列，根据平台决定调用那个异步函数
  var queue = new Array(1000);
  var qlen = 0;
  function asap(callback) {
    queue[qlen] = callback;

    qlen++;

    if (qlen === 1) {
      // 这里是通过第一次入列操作来触发 flush 队列操作
      // 因为 flush 是异步执行，所以在它还没之前之前有可能有新的任务入列
      // 这个时候 qlen > 1 ，直到 flush 执行，通过 qlen 遍 queue 确保在执行的时刻
      // 可以将这之前的所有入列的任务都得到执行
      setTimeout(flush());
    }
  }

  function flush() {
    for (var i = 0; i < qlen; i++) {
      var callback = queue[i];
      if (callback) callback();

      // 清空已执行的任务
      queue[i] = undefined;
    }

    // 在此刻至 Flush之前入列的任务都得到了执行，重置重新接受新的任务
    qlen = 0;
  }
#+end_src

按照 Promise 的定义，被 Promise 定义的任务不论代码是异步的还是同步的，都会被当做
异步任务来执行，比如：

#+begin_src js
  new Promise((resolve)=> {
    resolve(100)
  }).then(val => console.log(100))
  console.log(200)
#+end_src

#+RESULTS:
: 200
: 100

结果显示 200 先输出，后输出 100，但是其实我们在 ~new Promise()~ 的时候传入的函数
里面其实都是同步代码，经过 Promise 封装置后都成了异步的了。

因此这里的 asap 就是这个作用，当任务就算是同步代码的时候，依然将其变成异步任务去
执行。

并且这里使用了一个队列 ~queue~ 来管理这些任务，针对原作者的代码做了一些改动，去
掉了平台有关的代码，并将任务直接二次封装成了一个函数，所以这里是 ~qlen++~ 而不是
~qlen +=2~ 。

这里如果不仔细思考可能还不太好理解原作者为什么这么做？？？

1. 为什么 ~qlen === 1~ 的时候触发 ~flush~ ?

   #+begin_quote
   *答* ：其实想明白了也简单，就是为了只要队列是空的时候一旦有新的任务进来就立即触发任务
    出列 flush 掉队列中所有的任务，并且是顺序执行，顺序执行，顺序执行，重要的事
    情说三遍嘛，想象下如果没有这个机制，一旦有 promise settled 了，就调用一个
    setTimeout ? 
    
    有了这个机制之后，在 当前的 setTimeout flush 之前，会尽可能的让当前队列承载
    更多的 promise 任务，直到 flush 结束，重启另一个 setTimeout。
   #+end_quote
2. 为什么不直接使用 queue 数组的长度来控制 ?

* then 函数实现
*** then 功能说明：

1. 收集 pending 状态 promise 的 callback(存放到 =_subs= 中)

   因为 promise 任务如果异步的，调用 ~then(resolve,reject)~ 的时候，resolve 和
   reject 是不应该立即执行的，必须等异步任务结束之后再执行，否则就不符合了 promise
   原则(异步任务同步化)。
   
   所以当 promise 任务是异步情况下，then 函数的功能应该是用来收集 resolve/reject
   的，等待任务结束后调用。
   
2. 作为 then 链式调用的桥梁，即这个桥梁必须是在这个函数里面去完成的。


既然有了收集，那必然就有触发动作，触发也必须等待任务执行完成才会触发，也就是说这
个动作必须是在 ~resolve()~ 里面完成，因为 Promise 使用者会根据自己任务情况去在适
当的位置调用 resolve 和 reject。

*** 需要完成的函数： 

- [-] ~fulfill(promise, value)~ ，任务成功完成

  #+begin_src js

    function fulfill(promise, result) {
      if (promise._state !== PENDING) {
        // 状态已经完成不能再改变状态
        return;
      }

      promise._state = FULFILL;
      promise._result = result;

      if (promise._subs.length > 0) {
        asap(function () {
          publish(promise);
        });
      }
    }
  #+end_src
  
- [-] ~publish(promise)~ 
  
  任务完成之后 flush 掉所有回调(then pending 阶段收集的 =_subs[]=)
  
  #+begin_src js

    function publish(promise) {
      var subs = promise._subs;

      var child,
          callback,
          result = promise.result;
      for (var i = 0; i < subs.length; i += 3) {
        child = subs[i];
        callback = subs[i + promise._state];

        if (child) {
          // TODO 异步任务
        } else {
          callback(result);
        }
      }

      subs.length = 0;
    }
  #+end_src
  
- [-] ~subscribe(parent, child, onFulfillment, onRejection)~

  如果任务是个异步任务就不会立即执行，要等到任务结束才能执行回调，所以就必须要有
  个地方能将这些回调收集到当前的 *promise* 实例中，等待调用。
  
  #+begin_src js

    function subscribe(parent, child, onFulfillment, onRejection) {
      var subs = parent._subs;
      var len = subs.length;
      // PENDING
      subs[len] = child;
      subs[len + FULFILL] = onFulfillment;
      subs[len + REJECT] = onRejection;

      // parent promise 状态如果完成了，立即触发当前 child 的 promise
      // 可能执行到这里的时候任务刚好完成了???
      if (len === 0 && parent._state) {
        asap(function () {
          publish(parent);
        });
      }
    }
  #+end_src

- [-] ~then(onFulfillment, onRejection)~  
 
  这里要区分两种情况，一种是 pending 状态和非 pending 状态的处理，pending 说明可
  能是异步任务还没结束，不能立即 settled，调用 subscribe() 去收集回调。

  一种是非 pending 状态，在调用 then 之后只有一种情况会使得 promise 状态改变了，
  那就是任务立即执行，调用了 *resolve* 或 *reject* 设置了 ~promise._state~ 改变
  了状态，因为只有这两个函数才会改变 promise 状态值。
  #+begin_src js

    function then(onFulfillment, onRejection) {
      var parent = this;
      // 创建一个新的 promise，用来衔接后面的 then
      var child = new this.constructor(noop);
      var _state = this._state;
      // 根据状态决定执行哪个回调
      var callback = arguments[_state - 1];

      if (_state) {
        // 状态已经改变，任务已经完成了，直接执行回调
        invokeCallback(_state, child, callback, parent._result);
      } else {
        // 订阅所有回调
        subscribe(parent, child, onFulfillment, onRejection);
      }

      return child;
    }
  #+end_src

- [-] ~invokeCallback(settled, promise, callback, detail)~

  这个函数承载了当前 then promise1 的回调执行并解析结果(异常处理)，然后将值传递
  给下一个 then promise2(then 里面 ~new this.constructor(noop)~ 出来的)，调用
  ~resolve(child)~或 ~reject(child)~ 去触发 promise2 的回调。
  #+begin_src js

    function invokeCallback(settled, promise, callback, detail) {
      var value; // 记录 callback 执行的结果
      var hasCallback = typeof callback === "function";
      var succeeded = true; // callback 可能执行失败
      var error;

      if (hasCallback) {
        // 开始执行 callback, 即 then(resolve, reject) 的 Resolve/Reject
        try {
          // 将上一个 promise 结果作为参数传递到 then 回调
          value = callback(detail);
        } catch (e) {
          // 回调执行失败，有错误或者异常
          error = e;
          succeeded = false;
        }

        if (promise === value) {
          reject(promise, Util.error.returnSelfPromise());
          return;
        }
      } else {
        // 没有回调的时候 then() ???
        value = detail;
      }

      // 这里要检测下一个新 new 的 promise 状态
      // 下面的动作都是为了下一个 then 做准备的，这里的promise
      // 是在上一个 then 里面的new 出来的 promise 衔接下一个 then 用
      if (promise._state !== PENDING) {
        // noop 状态完成了的 promise
      } else if (hasCallback && succeeded) {
        // 执行成功， resolve
        resolve(promise, value);
      } else if (succeeded === false) {
        // then 中的回调执行失败了
        reject(promise, error);
      } else if (settled === FULFILL) {
        fulfill(promise, value);
      } else if (settled === REJECT) {
        reject(promise, value);
      }
    }
  #+end_src
  
测试：
#+begin_src js
  const { MyPromise, Util} = require(`${process.env.PWD}/../../static/js/promise.js`)

  const p = new MyPromise((resolve, reject) => {
    Util.delay(() => resolve(100))
  }).then(val => {
    Util.log(val, 'then 1 resolve')
  })
#+end_src


+RESULTS 实现 invokeCallback 之前:
: undefined

这里没任何输出，因为还没实现 ~invokeCallback(settled, promise, callback,
detail)~ 这里面会针对 then 的 resolve 或 reject 执行结果做出相应的处理。

实现关键点： 
1. callback 实际上是 ~then(resolve, reject)~ 中的 resolve/reject ，根据上一个
   promise 状态 ~settled~ 决定的。
   
2. 使用 try...catch 捕获 callback 执行异常，确保 then 回调也能受 Promise 规则约
   束。
   
3. 几种情况决定调用 resolve 还是 reject 进入下一个链式回调(*then*)。

+RESULTS 实现 invokeCallback 之后:
: 100 then 1 resolve

此时的 promise._subs 如下：
#+begin_example
[
  MyPromise {
    '8st4da5md17': 1,
    _state: 0,
    _result: undefined,
    _subs: [] // 这是那个 child promise
  },
  [Function (anonymous)], // 这里是 then resolver
  undefined // 这里是 then rejection 因为没传所以是 undefined
]
#+end_example

*** then 链式调用：

#+begin_src js
  const { MyPromise, Util} = require(`${process.env.PWD}/../../static/js/promise.js`)

  const p = new MyPromise((resolve, reject) => {
    Util.delay(() => resolve(100))
  }).then(val => { /* p1 */
    Util.log(val, 'then 1 resolve')
    return 200
  }, /* p2 */).then(val => {/* p3 */
    Util.log(val, 'then 2 resolve')
    return 300
  }, /* p4 */)
#+end_src

#+RESULTS:
: 100 then 1 resolve
: 200 then 2 resolve
