#+TITLE: JavaScript - Promise 实现(0-1)
#+DATE: <2020-10-12 23:26:38>
#+TAGS[]: javascript, es6, promise
#+CATEGORIES[]: javascript
#+LANGUAGE: zh-cn
#+STARTUP: indent

#+begin_export html
<script src="/js/promise.js"></script>
#+end_export

#+begin_quote
源码参考链接：https://github.com/stefanpenner/es6-promise
#+end_quote

* 构造函数 Promise
  1. 三个状态: ~PENDING~, ~FULFILL~, ~REJECT~ 。
  2. PID 记录 promise id 属性
  3. ~_state~ 当前 promise 的状态(pending/fulfill/reject)
  4. ~_result~ 当前 promise 任务执行的结果值
  5. ~_subs~ 当前 promise 的订阅者(then 时注册的 resolver/rejection)
  6. 构造函数中立即执行 resolver 根据任务执行情况由使用者决定是调用
     resolvePromise 还是 rejectPromise
  
  #+begin_src js
    var PID = Math.random().toString(36).substring(2);
    var PENDING = 0;
    var FULFILL = 1;
    var REJECT = 2;
    var i = 0;
    var proto = MyPromise.prototype;

    function MyPromise(resolver) {
      this[PID] = i++;
      this._state = PENDING;
      this._result = undefined;
      this._subs = [];

      if (!this instanceof Promise) {
        throw new TypeError("只能通过new 构造 Promise 实例。");
      }

      var _this = this;
      try {
        resolver(
          function resolvePromise(value) {
            resolve(_this, value);
          },
          function rejectPromise(reason) {
            reject(_this, reason);
          }
        );
      } catch (e) {
        reject(this, e);
      }
    }

    function resolve(promise, value) {
      console.log(value, "resolve");
    }

    function reject(promise, reject) {
      console.log(value, "reject");
    }
  #+end_src

  测试：

  #+begin_src js
    const { MyPromise, Util} = require(`${process.env.PWD}/../../static/js/promise.js`)
    const p = new MyPromise(function (resolve, reject) {
      Util.delay(() => resolve(100), 1000)
    })
  #+end_src

  #+RESULTS:
  : 100 resolve

* then 函数实现

then 功能：

1. 收集 pending 状态 promise 的 callback(存放到 =_subs= 中)

   因为 promise 任务如果异步的，调用 ~then(resolve,reject)~ 的时候，resolve 和
   reject 是不应该立即执行的，必须等异步任务结束之后再执行，否则就不符合了 promise
   原则(异步任务同步化)。
   
   所以当 promise 任务是异步情况下，then 函数的功能应该是用来收集 resolve/reject
   的，等待任务结束后调用。
   
2. 作为 then 链式调用的桥梁，即这个桥梁必须是在这个函数里面去完成的。


既然有了收集，那必然就有触发动作，触发也必须等待任务执行完成才会触发，也就是说这
个动作必须是在 ~resolve()~ 里面完成，因为 Promise 使用者会根据自己任务情况去在适
当的位置调用 resolve 和 reject。

需要完成的函数： 

- [-] ~fulfill(promise, value)~ ，任务成功完成

  #+begin_src js
    function fulfill(promise, result) {
      if (promise._state !== PENDING) {
        // 状态已经完成不能再改变状态
        return;
      }

      promise._state = FULFILL;
      promise._result = result;

      if (promise._subs.length > 0) {
        publish(promise);
      }
    }
  #+end_src
  
- [-] ~publish(promise)~ 
  
  任务完成之后 flush 掉所有回调(then pending 阶段收集的 =_subs[]=)
  
  #+begin_src js

    function publish(promise) {
      var subs = promise._subs;

      var child,
          callback,
          result = promise.result;
      for (var i = 0; i < subs.length; i += 3) {
        child = subs[i];
        callback = subs[i + promise._state];

        if (child) {
          // TODO 异步任务
        } else {
          callback(result);
        }
      }

      subs.length = 0;
    }
  #+end_src
  
- [-] ~subscribe(parent, child, onFulfillment, onRejection)~

  如果任务是个异步任务就不会立即执行，要等到任务结束才能执行回调，所以就必须要有
  个地方能将这些回调收集到当前的 *promise* 实例中，等待调用。
  
  #+begin_src js

    function subscribe(parent, child, onFulfillment, onRejection) {
      var len = parent._subs.length;
      // PENDING
      subs[len] = child;
      subs[len + FULFILL] = onFulfillment;
      subs[len + REJECT] = onRejection;
    }
  #+end_src

- [-] ~then(onFulfillment, onRejection)~  
 
  这里要区分两种情况，一种是 pending 状态和非 pending 状态的处理，pending 说明可
  能是异步任务还没结束，不能立即 settled，调用 subscribe() 去收集回调。

  一种是非 pending 状态，在调用 then 之后只有一种情况会使得 promise 状态改变了，
  那就是任务立即执行，调用了 *resolve* 或 *reject* 设置了 ~promise._state~ 改变
  了状态，因为只有这两个函数才会改变 promise 状态值。
  #+begin_src js

    function then(onFulfillment, onRejection) {
      var parent = this;
      // 创建一个新的 promise，用来衔接后面的 then
      var child = new this.constructor(noop);
      var _state = this._state;
      // 根据状态决定执行哪个回调
      var callback = arguments[_state - 1];

      if (_state) {
        // 状态已经改变，任务已经完成了，直接执行回调
        invokeCallback(_state, child, callback, parent._result);
      } else {
        // 订阅所有回调
        subscribe(parent, child, onFulfillment, onRejection);
      }

      return child;
    }
  #+end_src

  
测试：
#+begin_src js
  const { MyPromise, Util} = require(`${process.env.PWD}/../../static/js/promise.js`)

  const p = new MyPromise((resolve, reject) => {
    Util.delay(() => resolve(100))
  }).then(val => {
    Util.log(val, 'then 1 resolve')
  })
#+end_src

+RESULTS 实现 invokeCallback 之前:
: undefined

这里没任何输出，因为还没实现 ~invokeCallback(settled, promise, callback,
detail)~ 这里面会针对 then 的 resolve 或 reject 执行结果做出相应的处理。


- [-] ~invokeCallback(settled, promise, callback, detail)~

  #+begin_src js

    function invokeCallback(settled, promise, callback, detail) {
      var value; // 记录 callback 执行的结果
      var hasCallback = typeof callback === "function";
      var succeeded = true; // callback 可能执行失败
      var error;

      if (hasCallback) {
        // 开始执行 callback, 即 then(resolve, reject) 的 Resolve/Reject
        try {
          // 将上一个 promise 结果作为参数传递到 then 回调
          value = callback(detail);
        } catch (e) {
          // 回调执行失败，有错误或者异常
          error = e;
          succeeded = false;
        }

        if (promise === value) {
          reject(promise, Util.error.returnSelfPromise());
          return;
        }
      } else {
        // 没有回调的时候 then() ???
        value = detail;
      }

      if (settled !== PENDING) {
        // noop 状态完成了的 promise
      } else if (hasCallback && succeeded) {
        // 执行成功， resolve
        resolve(promise, value);
      } else if (succeeded === false) {
        // then 中的回调执行失败了
        reject(promise, error);
      } else if (settled === FULFILL) {
        fulfill(promise, value);
      } else if (settled === REJECT) {
        reject(promise, value);
      }
    }
  #+end_src

  
实现关键点： 
1. callback 实际上是 ~then(resolve, reject)~ 中的 resolve/reject ，根据上一个
   promise 状态 ~settled~ 决定的。
   
2. 使用 try...catch 捕获 callback 执行异常，确保 then 回调也能受 Promise 规则约
   束。
   
3. 几种情况决定调用 resolve 还是 reject 进入下一个链式回调(*then*)。

+RESULTS 实现 invokeCallback 之后:
: 100 then 1 resolve

此时的 promise._subs 如下：
#+begin_example
[
  MyPromise {
    '8st4da5md17': 1,
    _state: 0,
    _result: undefined,
    _subs: [] // 这是那个 child promise
  },
  [Function (anonymous)], // 这里是 then resolver
  undefined // 这里是 then rejection 因为没传所以是 undefined
]
#+end_example
