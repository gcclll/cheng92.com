#+TITLE: Algorithm On Leetcode 1 (Easy Level)
#+DATE: <2020-08-27 15:34:19>
#+TAGS[]: algorithm, leetcode, programming, javascript
#+CATEGORIES[]: algorithm
#+LANGUAGE: zh-cn
#+OPTIONS: ^:{} _:{}

#+BEGIN_EXPORT html
基于 leetcode 的算法学习记录文章，使用语言主要是 JavaScript，可能会有少于 C/Python 实现，在没标明的情况下默认都是 JavaScript 实现。<br><br>
约定 ：<br>

1. 有<sup><font color="red" size="2">每日</font></sup> 角标的标识是每日一题的题目 <br>
2. 有<sup><font color="red" size="2">leetcode</font></sup>角标的标识是该方案是Leetcode 网站上的题解 <br>

#+END_EXPORT

* 数组分类
** [[https://leetcode-cn.com/problems/shu-zu-zhong-zhong-fu-de-shu-zi-lcof/][01. 数组中重复的数字]]
*** 方案一： reduce + Object.keys + map + filter
    下面这种方案适合于将所有重复的数字都找出来的案例，如果只需要找到第一个，该方案有多余的处理步骤，不建议使用。
    #+begin_src js
      /**
       ,* @param {number[]} nums
       ,* @return {number}
       ,*/
      var findRepeatNumber = function (nums) {
        if (!Array.isArray(nums)) return []

        // 通过 reduce 得到 { val: times } 结果
        // 如果重复出现过 times > 0 否则 times === 0
        let res = nums.reduce((acc, num) => {
          const k = num + ""
          let v = acc[num + ""] || 0
          if (acc.hasOwnProperty(k)) {
            acc[k] = ++v
          } else {
            acc[k] = 0
          }
          return acc
        }, {})

        // 然后通过 keys, map 整理结果 times > 0 的值
        // 最后 filter 过滤掉 0 值得到的数组就是源数组中重复的数集合
        const found = +Object.keys(res)
              .map(k => (res[k] ? k : 0))
              .filter(Boolean)[0]

        return found !== found ? -1 : found
      }

      console.log(findRepeatNumber([2, 3, 1, 0, 2, 5, 3]))
    #+end_src

    #+RESULTS:
    : 2
    : undefined

    *执行结果：*

    @@html:<font color="red">@@执行用时：152 ms, 在所有 JavaScript 提交中击败了 24.41%的用户@@html:</font>@@

    内存消耗：51.9 MB, 在所有 JavaScript 提交中击败了 100.00%的用户

    | 提交时间 | 提交结果 | 运行时间 | 内存消耗 | 语言       |
    |----------+----------+----------+----------+------------|
    | 几秒前   | 通过     | 152 ms   | 51.9 MB  | Javascript |

*** 方案二: for
    使用 for 语法，明显会比使用 reduce 快，因为它只要遇到重复的立即退出函数，而
    reduce 版本无论什么时候都需要将数组所有元素遍历完，方案一更适合于查找

    #+begin_src js

      var findRepeatNumber = function (nums) {
        if (!Array.isArray(nums)) return -1

        let res = {}
        for (let i = 0, len = nums.length; i < len; i++) {
          let k = nums[i] + "",
              v = res[k]

          if (res.hasOwnProperty(k)) {
            return k
          } else {
            res[k] = 0
          }
        }

        return -1
      }
    #+end_src

    *提交结果* ：

    执行用时：88 ms, 在所有 JavaScript 提交中击败了 57.41%的用户

    内存消耗：43.1 MB, 在所有 JavaScript 提交中击败了 100.00%的用户

    | 提交时间 | 提交结果 | 运行时间                       | 内存消耗 | 语言       |
    |----------+----------+--------------------------------+----------+------------|
    | 几秒前   | 通过     | <font color="red">88 ms</font> | 43.1 MB  | Javascript |
    | 3 分钟前 | 通过     | 104 ms                         | 43 MB    | Javascript |
    | 1 天前   | 通过     | 152 ms                         | 51.9 MB  | Javascript |

*** 方案三: 递归
*** 方案四：二分 for
*** 其他方案(leetcoders)
** [[https://leetcode-cn.com/problems/two-sum-ii-input-array-is-sorted/][02. 两数之和 II - 输入有序数组]]
*** 方案一：两个 for，O(n^{2})
*** 方案二: 排除 + 二分(*O(n^{2}), O(1)*)
*** 方案三：计算，存储差值方式(*O(n), O(n)*)
*** 方案四: 对撞双指针
*** 二分查找(O(nlogn), O(1)) @@html:<sup><font color="red">@@leetcode@@html:</font></sup>@@
*** 对撞双指针法(O(n), O(1)) @@html:<sup><font color="red">@@leetcode@@html:</font></sup>@@
** [[https://leetcode-cn.com/problems/xuan-zhuan-shu-zu-de-zui-xiao-shu-zi-lcof/][03. 剑指 Offer 11. 旋转数组的最小数字@@html:<sup><font color="red">@@每日@@html:</font></sup>@@]]
*** 方案一：for 循环直接遍历查找(O(n), O(1))
*** 方案二 @@html:<sup><font color="red">@@leetcode@@html:</font></sup>@@ ：二分法(O(logn))
** [[https://leetcode-cn.com/problems/two-sum/][04. 两数之和]]
* 字符串分类
** 删除字符串中重复的字符
*** *while* 循环版本
*** 正则递归版本(尾调用未优化)
*** 正则递归版本(尾调用优化)
