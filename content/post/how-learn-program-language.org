#+TITLE: 如何快速学习一门语言？
#+DATE: <2021-09-04 22:32:25>
#+EMAIL: Lee ZhiCheng<gccll.love@gmail.com>
#+TAGS[]: JavaScript, Python, Golang, C, Shell
#+CATEGORIES[]: web
#+LANGUAGE: zh-cn
#+STARTUP: indent

#+begin_quote
所有语言都有许多共同点，每次学习都需要去学习一遍这些共同点，但是又很容易忘记。那
如果将学习这些语言的时候将共同的地方概况起来，然后将不同点区分出来是不是更容易学
习呢？
#+end_quote

该文主要是为了辅助 how-learn-a-program-language.xmind 而生，主要是包含了与之相关
的所有测试代码和简要说明。

如果采用使用单个文件方式来测试可能比较繁琐，比如当你需要测试的时候你可能需要创建
~a.c~, ~a.js~, ~a.py~, ~a.go~, ~a.sh~ 想想都会崩溃吧！！！

因此 org file 就很好的解决问题。

费话不多说，开始学习吧~~~~~~~~

学习一门语言，基本会遵循这样的步骤：

基本类型系统 -> 变量 -> 函数 -> 控制流程 -> 复杂类型系统 -> 内置库(包) -> 异步/
延迟编程 -> 错误处理 -> 测试 -> 搞项目

基本都是这样的一个大概的流程，尤其前五个是一门语言最最基础的东西。

#+begin_quote
Go 官方博客： https://go.dev/blog/all
#+end_quote


* 变量
:PROPERTIES:
:COLUMNS:  %CUSTOM_ID[(Custom Id)]
:CUSTOM_ID: var
:END:

Golang 的变量声明和一般的声明方式有点大不一样，订好体现在它的类型是放在变量名的
后面(~var n int = 100~)，像 C 是在前(~int n = 10~)，可能就是为了和 C 区别一下吧？

** 变量声明
:PROPERTIES:
:COLUMNS:  %CUSTOM_ID[(Custom Id)]
:CUSTOM_ID: var-declare
:END:

*** Golang 变量声明
:PROPERTIES:
:COLUMNS:  %CUSTOM_ID[(Custom Id)]
:CUSTOM_ID: var-declare-go
:END:

#+begin_src go
import "fmt"

func main() {
	var bVal bool = true
	var iCount int32 = 100
	var sName string = "Tom"
	var fPi float32 = 3.14159
	val := false
	count := 200
	name := "Lily"
	pi := 3.1415
	fmt.Println(
		bVal, iCount, sName, fPi,
		val, count, name, pi
	)
}
#+end_src

#+RESULTS:
: true 100 Tom 3.14159

*** JavaScript 变量声明
:PROPERTIES:
:COLUMNS:  %CUSTOM_ID[(Custom Id)]
:CUSTOM_ID: var-declare-js
:END:

#+begin_src js
var bVal = false, iCount = 100,
    sName = "Tom", fPi = 3.14159
let val = false, count = 100
const pi = 3.14159, name = "Lily"
console.log(bVal, iCount, sName, fPi)
#+end_src

#+RESULTS:
: false 100 Tom 3.14159
: undefined
** 变量分类
:PROPERTIES:
:COLUMNS:  %CUSTOM_ID[(Custom Id)]
:CUSTOM_ID: var-category
:END:

*** 作用域分类(全局、局部变量)
:PROPERTIES:
:COLUMNS:  %CUSTOM_ID[(Custom Id)]
:CUSTOM_ID: var-cate-scope
:END:

**** Golang
:PROPERTIES:
:COLUMNS:  %CUSTOM_ID[(Custom Id)]
:CUSTOM_ID: var-cate-go
:END:

#+begin_src go
import "fmt"

var gCount int32 = 100 // 全局变量
func iCanVisitGCount() (int16) {
	var iCount int16 = 1000
	fmt.Printf("我能访问全局变量 gCount: %d\n", gCount)
	fmt.Printf("我能访问局部变量 iCount: %d\n", iCount)
	if true {
		var bVal bool = false
		fmt.Printf("我能访问 if 块中的局部变量 bVal: %t\n", bVal)
	}
	// fmt.Printf("我不能访问 if 块中的局部变量 bVal: %t\n", bVal) // #1
	return iCount
}
func main() {
	fmt.Printf("我也能访问全局变量 gCount: %d\n", gCount)
	iCanVisitGCount()
	// if err {
	// 	fmt.Println("iCanVisitGCount 执行异常： ", err)
	// }
	// fmt.Printf("我不能访问局部变量 iCount: %d\n", iCount) // #2
}
#+end_src

注释 *#1*, *#2* 执行结果
#+RESULTS:
: 我也能访问全局变量 gCount: 100
: 我能访问全局变量 gCount: 100
: 我能访问局部变量 iCount: 1000
: 我能访问 if 块中的局部变量 bVal: false

放开 *#1*, *#2* 执行结果：
#+begin_example
/var/folders/1n/xw58p9v90tn42m87q527fvgr0000gn/T/babel-lcR0GY/go-src-T6z2DN.go:14:67: undefined: bVal
/var/folders/1n/xw58p9v90tn42m87q527fvgr0000gn/T/babel-lcR0GY/go-src-T6z2DN.go:23:56: undefined: iCount
#+end_example

**** JavaScript
:PROPERTIES:
:COLUMNS:  %CUSTOM_ID[(Custom Id)]
:CUSTOM_ID: var-cate-js
:END:

JavaScript 自从有了 es6 之后就有了块作用域的概念，比如：if 中使用 let 和 var 是
完全不一样的结果，var 在 if 声明的变量会被提升到函数顶部，等同于是函数级的局部变
量，在函数内都可以访问，而 let/const 则只能在 if 块作用域中访问

#+begin_src js
var gVal = 100 // 全局变量
function test() {
  var bVal = false
  if (true) {
    var iCount = 300
    let n = 1
    console.log('in if, iCount = ' + iCount)
    console.log('in if, n = ' + n)
  }
  console.log('out if, iCount = ' + iCount)
  console.log('out if, n = ' + typeof n)
  console.log('in test function, bVal = ' + bVal)
  console.log('in test function, gVal = ' + gVal)
}
test()
console.log('out test function, bVal = ' + typeof bVal)
console.log('out test function, gVal = ' + gVal)
#+end_src

#+RESULTS:
: in if, iCount = 300
: in if, n = 1
: out if, iCount = 300
: out if, n = undefined
: in test function, bVal = false
: in test function, gVal = 100
: out test function, bVal = undefined
: out test function, gVal = 100
: undefined
*** 值类型(值，引用)

值类型：变量本身存储的就是该变量的具体值。

引用类型：变量本身存储的是一个指针(或地址)，该指针指向了内存中一块区域，该区域中
存放的是具体的值。

最能体现值和引用类型区别的地方就是作为函数的参数了。
**** Golang

#+begin_src go
import "fmt"
type Dog struct {
	Name string
}

func test(dog Dog, pDog *Dog) {
	fmt.Println(dog, pDog, *pDog)
	dog.Name = "value dog"
	pDog.Name = "pointer dog"
}

func main() {
	dog1 := Dog{Name: "dog1"}
	dog2 := Dog{Name: "dog2"}

	var a int = 100
	var pt *int // 未初始化时，指针是 nil
	fmt.Println("pt = ", pt)
	// * 星号是取值，这里是往 pt 指向的内存中在放一个 100 的整型值
	pt = &a
	fmt.Println("pt = ", pt)

	test(dog1, &dog2)
	fmt.Println(dog1, dog2)
}
#+end_src

#+RESULTS:
: pt =  <nil>
: pt =  0xc00001a0b8
: {dog1} &{dog2} {dog2}
: {dog1} {pointer dog}

观查上面的结果会发现 dog1.Name 还是 "dog1", 而 dog2.Name 却发生了改变。

这就是值传递和引用传递的区别：

值传递：只是将原始数据的拷贝传递给了函数。

引用传递：是将原始数据在内存中的地址传递给了函数，因此修改 pDog 的值等于是修改了
这个指针指向的内存位置的值，所以让原始的 dog2 也发生了变化。
**** JavaScript

#+begin_src js

function test(dog, pDog, dogVal) {
  console.log(dog, pDog)
  dog.Name = 'value dog'
  pDog.Name = 'pointer dog'
  dogVal = 'dog value'
}

var dog1 = { Name: 'dog1' }
var dog2 = { Name: 'dog2' }
var dog3 = 'dog3'
test(dog1, dog2, dog3)
console.log(dog1, dog2, dog3)
#+end_src

#+RESULTS:
: { Name: 'dog1' } { Name: 'dog2' }
: { Name: 'value dog' } { Name: 'pointer dog' } dog3
: undefined

对于 JavaScript 而言是没有所谓指针的概念的，但对于对象类型都属于引用传递，普通类
型都是值的传递，如： dog1, dog2 是对象所以为引用传递值会被改变， dog3 是字符串为
普通类型是值传递所以函数内的操作对外部是没有任何影响的。
* 函数/方法
** 函数

*** JavaScript

~function name(a, b) {}~

*** Golang

~func name(a, b, int) int {}~

~func name(a string, b int) (string, int) {]~, 返回两个值

~func name(a, b int) (x, y int)~, 指定返回的变量，此时可不需要显式 ~return x, y~, 如：

#+begin_src go
import "fmt"

func test(a, b int) (x, y int) {
	// 这里不能用 := 因为 x, y 在函数声明中已经声明了
	// 即 (x, y int) 此时等于是声明了两 int 变量
	x = a + b
	y = a - b


// 必须要加上这个 return
	return
}

func main() {
	x, y := test(10, 2)
	fmt.Println(x, y)
}
#+end_src

#+RESULTS:
: 12 8
** 方法

*** JavaScript

原型上的函数可视为方法，如：

#+begin_src js
function Test() {}
Test.prototype.test = () => console.log('test...')
const t = new Test()
t.test()
#+end_src

#+RESULTS:
: test...
: undefined

*** Golang

Go 中的方法使用在模块中的结构体中，且和函数的定义非常相似，保需要在函数名前面加
上(~t *Test~)就会变成该结构体的方法，如：

#+begin_src go
import "fmt"

type Test struct {
	Name string
}

func (t *Test) test() {
	fmt.Println(t.Name)
}

func main() {
	t := Test{Name: "test..."}
	t.test()
}
#+end_src

#+RESULTS:
: test...
* 基础类型
:PROPERTIES:
:COLUMNS:  %CUSTOM_ID[(Custom Id)]
:CUSTOM_ID: basic-dt
:END:


JavaScript 为弱类型语言，声明时不需要指定变量类型。

Golang 为强类型语言，声明时需要指定变量类型。

** JavaScript
:PROPERTIES:
:COLUMNS:  %CUSTOM_ID[(Custom Id)]
:CUSTOM_ID: dt-js
:END:

JavaScript 基础类型有： ~string~, ~number~, ~boolean~

*** 类型转换
:PROPERTIES:
:COLUMNS:  %CUSTOM_ID[(Custom Id)]
:CUSTOM_ID: dt-js-t
:END:


#+begin_src js
console.log('string/boolean -> number: ', +"100", Number("100"), +false, +true, Number(false), Number(true))
console.log('string/number -> boolean: ', !!"0", Boolean("0"), !!"", Boolean(""), !!0, !!1, Boolean(0), Boolean(1))
console.log('boolean/number -> string: ', typeof ('' + 0), typeof String(0),typeof ('' + false), typeof String(false))
#+end_src

#+RESULTS:
: string/boolean -> number:  100 100 0 1 0 1
: string/number -> boolean:  true true false false false true false true
: boolean/number -> string:  string string string string
: undefined

** Golang
:PROPERTIES:
:COLUMNS:  %CUSTOM_ID[(Custom Id)]
:CUSTOM_ID: dt-go
:END:

Golang 基础类型从大的分类来说有： ~string~, ~bool~, ~int~, ~float~, ~complex~

其中 int 整型有： ~int~, ~int8~, ~int16~, ~int32~, ~int64~

float 浮点型有： ~float32~, ~float63~

complex 复数型有： ~complex64~, ~complex128~, 且复数 = 一个对应的 int + 一个虚数

另外基础类型还有 ~rune~, ~byte~

~rune~ 是 ~int32~ 的一个别名类型，用来表示一个 UNICODE 字符的编码值。

~byte~ 是 ~uInt8~ 的一个别名类型。

测试各个类型的大小:

#+begin_src go
import (
	"fmt"
	"unsafe"
	"math/cmplx"
)

func main() {
	fmt.Println("> 输出字节数: ")
	var s string = "string"
	fmt.Println("string, len(string)         :",
		unsafe.Sizeof(s), len(s))

	var i int = -100
	var i8 int8 = 100
	var i16 int16 = 100
	var i32 int32 = 100
	// 64 位系统 int 类型输出是 8 = 8*8byte = 64bits
	fmt.Println("int, int8, int16, int32     :",
		unsafe.Sizeof(i), unsafe.Sizeof(i8), unsafe.Sizeof(i16), unsafe.Sizeof(i32))

    var ui uint = 100
	var ui8 uint8 = 100
	var ui16 uint16 = 100
	var ui32 uint32 = 100
	// 64 位系统 int 类型输出是 8 = 8*8byte = 64bits
	fmt.Println("uint, uint8, uint16, uint32 :",
		unsafe.Sizeof(ui), unsafe.Sizeof(ui8), unsafe.Sizeof(ui16), unsafe.Sizeof(ui32))


	var f32 float32 = 100.0
	var f64 float64 = 100.0
	fmt.Println("float32, float64            :",
		unsafe.Sizeof(f32), unsafe.Sizeof(f64))

	var r rune = 32
	fmt.Println("rune                        :", unsafe.Sizeof(r))

	var b byte = 0
	fmt.Println("byte                        :", unsafe.Sizeof(b))

	var c64 complex64 = 0
	var c128 complex128 = cmplx.Sqrt(-5 + 12i)
	fmt.Println("complex64, complex128       :", unsafe.Sizeof(c64), unsafe.Sizeof(c128), c64, c128)
}
#+end_src

#+RESULTS:
: > 输出字节数:
: string, len(string)         : 16 6
: int, int8, int16, int32     : 8 1 2 4
: uint, uint8, uint16, uint32 : 8 1 2 4
: float32, float64            : 4 8
: rune                        : 4
: byte                        : 1
: complex64, complex128       : 8 16 (0+0i) (2+3i)

*** 类型转换
:PROPERTIES:
:COLUMNS:  %CUSTOM_ID[(Custom Id)]
:CUSTOM_ID: dt-go-t
:END:

#+begin_src go
import (
	"fmt"
	"unsafe"
)
func main() {
	var f32 float32 = 100.01
	var f64 float64 = 1002324324.0111111111
	fmt.Println(int(f32), int64(f64))
}
#+end_src

#+RESULTS:
: 100 1002324324
* 控制流程

大多数语言中的控制流程的语法基本都差不多，可能各个语言为了区别开有一些特殊的地方，
比如 Golang 中对于条件就不需要 ~()~ 。

** for
:PROPERTIES:
:COLUMNS:  %CUSTOM_ID[(Custom Id)]
:CUSTOM_ID: for
:END:

*** JavaScript
:PROPERTIES:
:COLUMNS:  %CUSTOM_ID[(Custom Id)]
:CUSTOM_ID: for-js
:END:


#+begin_src js
for (let i = 0; i < 5; i++) {
  console.log(i)
}
#+end_src

#+RESULTS:
: 0
: 1
: 2
: 3
: 4
: undefined

省略初始化和递增语句，只保留条件语句(其实只不过是将两者提取到 for 之外去了，本质
并没变)：

#+begin_src js
let i = 0
for (; i < 5; ) {
  console.log(i++)
}
#+end_src

#+RESULTS:
: 0
: 1
: 2
: 3
: 4
: undefined

*** Golang
:PROPERTIES:
:COLUMNS:  %CUSTOM_ID[(Custom Id)]
:CUSTOM_ID: for-go
:END:


#+begin_src go
import ("fmt")
func main() {
	for i := 0; i < 5; i++ {
		fmt.Println(i)
	}
}
#+end_src

#+RESULTS:
: i =  0
: i =  1
: i =  2
: i =  3
: i =  4

省略初始化和递增语句，只保留条件语句(其实只不过是将两者提取到 for 之外去了，本质
并没变)：

#+begin_src go
import ("fmt")
func main() {
	i := 0
	for ; i < 5 ; {
		fmt.Println(i)
		i++
	}
}
#+end_src

#+RESULTS:
: 0
: 1
: 2
: 3
: 4

** if, else if, else
:PROPERTIES:
:COLUMNS:  %CUSTOM_ID[(Custom Id)]
:CUSTOM_ID: if-else
:END:

*** JavaScript
:PROPERTIES:
:COLUMNS:  %CUSTOM_ID[(Custom Id)]
:CUSTOM_ID: if-else-js
:END:

#+begin_src js
const val = 100
if (val > 0) {
  console.log('val > 0')
} else if (val < 0 ) {
  console.log('val < 0')
} else {
  console.log('val === 0')
}
#+end_src

#+RESULTS:
: val > 0
: undefined

*** Golang
:PROPERTIES:
:COLUMNS:  %CUSTOM_ID[(Custom Id)]
:CUSTOM_ID: if-else-go
:END:

#+begin_src go
import ("fmt")
func main() {
	val := 100
	if val > 0 {
		fmt.Println("val > 0")
	} else if val < 0 {
		fmt.Println("val < 0")
	} else {
		fmt.Println("val = 0")
	}
}
#+end_src

#+RESULTS:
: val > 0

还可以在 if 条件中加入其它更多的语句：

#+begin_src go
import (
	"fmt"
	"math"
)

func pow(x, n, lim float64) float64 {
	if v := math.Pow(x, n); v < lim {
		return v
	}
	return lim
}

func main() {
	fmt.Println(pow(3,2,10), pow(3,3,20))
}
#+end_src

#+RESULTS:
: 9 20

** switch...case
:PROPERTIES:
:COLUMNS:  %CUSTOM_ID[(Custom Id)]
:CUSTOM_ID: switch
:END:

switch...case 在 golang 中不需要 break 来结束一个 case，它默认每个 case 都自结束
的。

*** JavaScript
:PROPERTIES:
:COLUMNS:  %CUSTOM_ID[(Custom Id)]
:CUSTOM_ID: switch-js
:END:

#+begin_src js
let val = 0, timer
function printVal() {
  switch (val) {
    case 0:
    case 1:
      console.log(`val = ${val} in 0 ~ 1`)
      break
    case 2:
    case 3:
    case 4:
    case 5:
      console.log(`val = ${val} in 2 ~ 4`)
      break
    case 10:
      console.log('val = 10, end...')
      clearInterval(timer)
      break
    default:
      console.log(`val = ${val} in 6 ~ 9`)
      break
  }
  val++
}

timer = setInterval(printVal, 100)
#+end_src

#+RESULTS:
#+begin_example
val = 0 in 0 ~ 1
val = 1 in 0 ~ 1
val = 2 in 2 ~ 4
val = 3 in 2 ~ 4
val = 4 in 2 ~ 4
val = 5 in 2 ~ 4
val = 6 in 6 ~ 9
val = 7 in 6 ~ 9
val = 8 in 6 ~ 9
val = 9 in 6 ~ 9
val = 10, end...
#+end_example

*** Golang
:PROPERTIES:
:COLUMNS:  %CUSTOM_ID[(Custom Id)]
:CUSTOM_ID: switch-go
:END:

#+begin_src go
import (
	"fmt"
)

func test(val int) {
	// 可以包含简单语句
	switch i := val * val; i {
		case 0: // none
		case 1: fmt.Println("val =", val)
		case 4: fmt.Println("val =", val)
		case 9: fmt.Println("val =", val)
		default: fmt.Println("default:", val)
	}
}
func main() {
	test(0)
	test(1)
	test(2)
	test(3)
}
#+end_src

#+RESULTS:
: val = 1
: val = 2
: val = 3

可以看到 ~case 0~ 并没有像 JavaScript 那样走到了 ~case 1~ 执行，而是自己结束了，因此
没有任何输出。

** while
:PROPERTIES:
:COLUMNS:  %CUSTOM_ID[(Custom Id)]
:CUSTOM_ID: while
:END:

*** JavaScript
:PROPERTIES:
:COLUMNS:  %CUSTOM_ID[(Custom Id)]
:CUSTOM_ID: while-js
:END:

#+begin_src js

let i = 0
while (i++ < 5) {
  console.log('while: ', i)
}

do {
  console.log('do...while', i++)
} while (i > 5 && i < 10)
#+end_src

#+RESULTS:
#+begin_example
while:  1
while:  2
while:  3
while:  4
while:  5
do...while 6
do...while 7
do...while 8
do...while 9
undefined
#+end_example

*** Golang
:PROPERTIES:
:COLUMNS:  %CUSTOM_ID[(Custom Id)]
:CUSTOM_ID: while-go
:END:

Golang 中没有 while 但是可以用 for 语句来代替。

#+begin_src go
import "fmt"

func main() {
	i := 0
	for i < 5 {
		fmt.Println(i)
		i++
	}
}
#+end_src

#+RESULTS:
: 0
: 1
: 2
: 3
: 4

如果要无限循环可以连条件语句都省略掉： ~for {...}~
* 异步或延迟

** JavaScript
:PROPERTIES:
:COLUMNS:  %CUSTOM_ID[(Custom Id)]
:CUSTOM_ID: async-js
:END:

JavaScript 中延迟执行有:

~setTimeout~: 多少时间后执行回调函数

~setInterval~: 每间隔多少时间执行一次回调函数

#+begin_src js
let i = 0
setTimeout(() => {
  console.log('我在 setTimeout 中，1 秒后被执行, i = ', i, '当前时钟秒数：', new Date().getSeconds())
}, 1000)

let timer = setInterval(() => {
  console.log('我在 setInterval 中，每隔一秒会执行一次, i = ', i++, '当前时钟秒数：', new Date().getSeconds())
  if (i > 3) {
    clearInterval(timer)
  }
}, 1000)
#+end_src

#+RESULTS:
: 我在 setTimeout 中，1 秒后被执行, i =  0 当前时钟秒数： 17
: 我在 setInterval 中，每隔一秒会执行一次, i =  0 当前时钟秒数： 17
: 我在 setInterval 中，每隔一秒会执行一次, i =  1 当前时钟秒数： 18
: 我在 setInterval 中，每隔一秒会执行一次, i =  2 当前时钟秒数： 19
: 我在 setInterval 中，每隔一秒会执行一次, i =  3 当前时钟秒数： 20

异步执行主要体现在 ajax 请求中，在 es6 之后新增了 Promise 以及后面的
aways...await 语法糖，让写异步代码更加流畅。

*Promise*: 一个 promise 实例会有三种状态(~PENDING~, ~FULFILLED~, ~REJECTED~)

且状态的变化只能是从 ~PENDING~ 到 ~FULFILLED~ 或 ~REJECTED~ 转变，且一旦转变之后就不可
逆。
#+begin_src js
const p = new Promise((resolve, reject) => {
  setTimeout(() => {
    resolve(100)
  }, 2000)
})

console.log('p  ->', p)
var p1 = p.then(val => console.log(val))
console.log('p1 ->', p1)
var p2 = Promise.resolve(100)
console.log('p2 ->', p2)
var p3 = Promise.reject()
console.log('p3 ->', p3)
#+end_src

#+RESULTS:
: p  -> Promise { <pending> }
: p1 -> Promise { <pending> }
: p2 -> Promise { 100 }
: p3 -> Promise { <rejected> undefined }
: undefined100

** Golang
:PROPERTIES:
:COLUMNS:  %CUSTOM_ID[(Custom Id)]
:CUSTOM_ID: async-go
:END:

*** defer
:PROPERTIES:
:COLUMNS:  %CUSTOM_ID[(Custom Id)]
:CUSTOM_ID: async-go-defer
:END:

Go 中可以用 *defer* 来将代码延迟执行，它会在所在的函数返回之后被执行，所以常用来做
一些函数的清理工作。

Defer 相关文章： https://go.dev/blog/defer-panic-and-recover

#+begin_src go
import "fmt"

func main() {
	defer fmt.Println("world")
	fmt.Println("hello")
}
#+end_src

#+RESULTS:
: hello
: world

defer 多条语句，它会将所有的函数调用放到一个调用栈中，当函数返回后，会将栈中的函
数按照 LIFO(后进先出) 顺序执行。

#+begin_src go
import "fmt"

func main() {
	fmt.Println("counting...")
	for i := 0; i < 5; i++ {
		defer fmt.Println(i)
	}
	fmt.Println("done")
 }
#+end_src

#+RESULTS:
: counting...
: done
: 4
: 3
: 2
: 1
: 0

善后工作，比如：将一个文件的内容拷贝到另一个文件中，比如要将

#+begin_src sh :results output
cat /Users/simon/github/tmp/test/a.js
#+end_src

#+RESULTS:
: function test() {
:   console.log('hello world')
: }

拷贝到

#+begin_src sh :results output
cat /Users/simon/github/tmp/test/a12.js
#+end_src

#+RESULTS:
: function a12() {
:   console.log('hello world')
: }

#+begin_src go
import (
	"fmt"
	"os"
	"io"
)
func CopyFile(dstName, srcName string) (written int64, err error) {
	src, err := os.Open(srcName)
	if err != nil {
		return
	}

	dst, err := os.Create(dstName)
	if err != nil {
		return
	}

	written, err = io.Copy(dst, src)
	dst.Close()
	src.Close()
	return
}

func main() {
	written, err := CopyFile("/Users/simon/github/tmp/test/a12.js", "/Users/simon/github/tmp/test/a.js")
	if err != nil {
		fmt.Println(err)
	}
	fmt.Println("write content: ", written)
}
#+end_src

#+RESULTS:
: write content:  49

执行上面的代码之后再查看下 ~a12.js~ 内容：
#+begin_src sh :results output
cat /Users/simon/github/tmp/test/a12.js
#+end_src

#+RESULTS:
: function test() {
:   console.log('hello world')
: }

会发现拷贝成功了。

那如果 dst 文件 a12.js 就不存在的时候会导致异常在第一个 return 处就结束了 CopyFile
这样会导致 a.js 并没有被关闭 (~src.Close()~)，这是不正常的操作的，也是不可取的，但
是错误又是不可避免的。

所以这里就可以用到 defer 的特性来完善 ~CopyFile~:

#+begin_src go
import (
	"fmt"
	"os"
	"io"
)
func CopyFile(dstName, srcName string) (written int64, err error) {
	src, err := os.Open(srcName)
	if err != nil {
		return
	}
	defer src.Close()

	dst, err := os.Create(dstName)
	if err != nil {
		return
	}
	defer dst.Close()

	return io.Copy(dst, src)
}

func main() {
	written, err := CopyFile("/Users/simon/github/tmxxxp/test/a123.js", "/Users/simon/github/tmp/test/a.js")
	if err != nil {
		fmt.Println(err)
	}
	fmt.Println("write content: ", written)
}
#+end_src

#+RESULTS:
: open /Users/simon/github/tmxxxp/test/a123.js: no such file or directory
: write content:  0

经过上面的改造之后，虽然 ~tmxxxp~ 目录不存在，会导致第一个在创建 dstName 的时候报
错了，但是由于有 ~defer src.Close()~ 的存在， srcName 对应被打开的文件依然会在
~CopyFile~ 退出之后被关闭。

defer 语句的行为是非常直观且是可预测的，它们的行为遵循以下几个原则：

1. defer 后面的函数的参数会在 defer 语句执行的时候立即执行

   也就是说，函数参数的值就是当前 defer 语句所在位置的实时的值，比如：

   #+begin_src go
import "fmt"
func main() {
	i := 0
	defer fmt.Println(i) // i = 0
	i++
	return
}
   #+end_src

   #+RESULTS:
   : 0

   看到没，结果是 ~0~, 而并不是 ~i++~ 执行之后的 ~1~ ，拿 JavaScript 来说，相当于使用
   闭包的时候值被传递进了闭包而得到正确的实时值([[#js-bibao][JS 中典型的闭包问题]])

2. defer 有多条语句的时候会依据 FILO(先进后出)的顺序去执行，调用栈中的语句

   #+begin_src go
import "fmt"
func main() {
	for i := 0; i < 3; i++ {
		defer fmt.Println(i)
	}
}
   #+end_src

   #+RESULTS:
   : 2
   : 1
   : 0

3. defer 后面的语句或函数可以访问甚至修改命名返回值变量

   #+begin_src go
import "fmt"
func test() (i int) {
	defer func() { i++ }()
	return 1
}

func main() {
	i := test()
	fmt.Println(i)
}
   #+end_src

   #+RESULTS:
   : 2

   为什么结果是 2 ？

   首先可以尝试将 ~return 1~ 改成 ~return~ 会得到结果 1，这是因为 ~int~ 类型默认值是 0，
   所以当 ~return~ 时其实是 ~return i~ 也就是 ~return 0~ 。

   当使用 ~return 1~ 时候也就是将 i 的值修改成了 1 再返回出去，所以在执行 defer 语
   句之前 i 的值就是 1.

   然而 ~test()~ 中有个 ~defer func() { i++ }()~ 这个语句会让 ~i+1~ 最后 test() 返回值
   变成了 2.

   从这个例子可以得出

   #+begin_info
   @@html:<p><strong>INFO</strong></p>@@

   defer 语句虽然是在函数返回之后执行，但是对于命名返回值的变量依旧有修改和访问
   且会影响其结果的能力。
   #+end_info
*** panic(恐慌)
:PROPERTIES:
:COLUMNS:  %CUSTOM_ID[(Custom Id)]
:CUSTOM_ID: async-go-panic
:END:

Go 中内置的一个函数，可以用来停止控制流程的代码执行，并且产生恐慌。

当一个函数内调用了 panic 时， 这个函数的正常代码会停止执行，但是不会影响 defer
语句，也就是即使一个函数内调用了 panic，其中的 defer 语句依旧会被执行。

先看个简单的例子

#+begin_src go
import "fmt"
func test(i int) {

	if (i > 0) {
		fmt.Println("in if", i)
		panic(100)
	}
	defer fmt.Println("Defer in test", i)
	fmt.Println("out if", i)
}
func main() {
	defer func() {
		r := recover()
		if r != nil {
			fmt.Println("Recovered in f", r)
		}
	}()
	test(1)
	// test(-1)
}
#+end_src

#+RESULTS:
: in if 1
: Recovered in f 100

如上面的例子，如果将 main 中的 ~test(1)~ 移到 defer func() ... 前面，则会和没有
defer 一样报错：
#+begin_example
panic: 100

goroutine 1 [running]:
main.test(0x1)
	/var/folders/1n/xw58p9v90tn42m87q527fvgr0000gn/T/babel-lcR0GY/go-src-12TVSu.go:8 +0x249
main.main()
	/var/folders/1n/xw58p9v90tn42m87q527fvgr0000gn/T/babel-lcR0GY/go-src-12TVSu.go:14 +0x3b
exit status 2
#+end_example

但是只要放在 defer func() ... 后面就可以正常执行得到下面的结果：
#+RESULTS:
: in if 1
: Recovered in f 100

这实际并不是 defer 语句的问题而是 defer 中调用了 ~recover()~ 的缘故，假如不用
defer 直接调用 ~recover()~ 呢？

经过测试会发现结果和 test(1) 放在 defer func() ... 一样会报同样的错误，这可能是
因为放在 defer 中会在函数返回之后拦截了这个函数因 panic 导致的错误。

#+begin_tip
@@html:<p><strong>TIP</strong></p>@@

是不是也就意味着，如果要使用 panic 而不会因为错误而中断程序执行，需要用到
defer + ~recover()~ 来捕获 panic 的状态信息(~recover()~ 执行得到的结果，也是调用
panic 时传递给它的参数值)做进一步的处理。
#+end_tip

有了上面的大概了解后，再来看下 [[https://go.dev/blog/defer-panic-and-recover][go 官博]]中的示例进行分析
@@html:<span id="panic-test-01"></span>@@

#+begin_src go
package main

import "fmt"

func main() {
    f()
    fmt.Println("Returned normally from f.")
}

func f() {
    defer func() {
        if r := recover(); r != nil {
            fmt.Println("Recovered in f", r)
        }
    }()
    fmt.Println("Calling g.")
    g(0)
    fmt.Println("Returned normally from g.")
}

func g(i int) {
    if i > 3 {
        fmt.Println("Panicking!")
        panic(fmt.Sprintf("%v", i))
    }
    defer fmt.Println("Defer in g", i)
    fmt.Println("Printing in g", i)
    g(i + 1)
}
#+end_src

#+RESULTS:
#+begin_example
Calling g.
Printing in g 0
Printing in g 1
Printing in g 2
Printing in g 3
Panicking!
Defer in g 3
Defer in g 2
Defer in g 1
Defer in g 0
Recovered in f 4
Returned normally from f.
#+end_example

代码分析流程图：

[[/img/go/go-panic-01.svg]]
* 数据结构
:PROPERTIES:
:COLUMNS:  %CUSTOM_ID[(Custom Id)]
:CUSTOM_ID: high-dt
:END:

这部分描述的是非基础类型，而是一些对象类型的数据结构。

** Golang
:PROPERTIES:
:COLUMNS:  %CUSTOM_ID[(Custom Id)]
:CUSTOM_ID: high-dt-go
:END:

*** Pointers(指针类型)
:PROPERTIES:
:COLUMNS:  %CUSTOM_ID[(Custom Id)]
:CUSTOM_ID: dt-go-pointers
:END:

#+begin_src go
import "fmt"
func main() {
	i, j := 42, 2781

	p := &i // 指向 i 的一个指针

	fmt.Println(*p) // *p 是取 p 指针指向的内存中的数据值
	,*p = 21 // 给 p 指向的内存赋值，这里其实就是改变 i 的值
	fmt.Println(i)

	p = &j
	,*p = *p / 37
	fmt.Println(j)
}
#+end_src

#+RESULTS:
: 42
: 21
: 75
*** Struct(结构体类型)
:PROPERTIES:
:COLUMNS:  %CUSTOM_ID[(Custom Id)]
:CUSTOM_ID: dt-go-struct
:END:

#+begin_src go
import "fmt"

type Animal struct {
	Name string
	Age int
}

func main() {
	cat := Animal{Name: "猫", Age: 100}
	dog := Animal{"狗", 101}

	fmt.Println("1.", cat, dog)

	// 结构体指针
	pCat := &cat
	var pDog *Animal = &dog

	pCat.Age = 200
	pDog.Age = 201

	fmt.Println("2.", cat, dog)
	fmt.Println(pCat, pDog, *pCat, *pDog)
}
#+end_src

#+RESULTS:
: 1. {猫 100} {狗 101}
: 2. {猫 200} {狗 201}
: &{猫 200} &{狗 201} {猫 200} {狗 201}

结构体字面量：

#+begin_src go
import "fmt"

type Vertex struct {
	X, Y int
}

var (
	v1 = Vertex{1, 2}
	v2 = Vertex{X: 1} // Y:0 int 类型默认值
	v3 = Vertex{} // X:0, Y:0, int 类型默认值
	p = &Vertex{1, 2} // Vertex 结构体指针
)

func main() {
	fmt.Println(v1, p, v2, v3)
}
#+end_src

#+RESULTS:
: {1 2} &{1 2} {1 0} {0 0}
*** Array(数组)
:PROPERTIES:
:COLUMNS:  %CUSTOM_ID[(Custom Id)]
:CUSTOM_ID: dt-go-array
:END:

Go 中的数组和 JavaScript 不一样，它声明的时候必须指定长度，且一旦确定了长度之后
就不能再变化。

#+begin_comment
即: 不能添加也不能删除元素。
#+end_comment

#+begin_src go
import "fmt"

func main() {
	var a [2]string
	a[0] = "hello"
	a[1] = "world"
	fmt.Println(a[0], a[1])
	fmt.Println(a)

	primes := [6]int{2,3,5,7,11,13}
	fmt.Println(primes)
}
#+end_src

#+RESULTS:
: hello world
: [hello world]
: [2 3 5 7 11 13]
*** Slice(切片)
:PROPERTIES:
:COLUMNS:  %CUSTOM_ID[(Custom Id)]
:CUSTOM_ID: dt-go-slice
:END:

切片和数组类似，但是它支持元素的添加和删除。

#+begin_src go
import "fmt"

func main() {
	names := [4]string{
		"张三",
		"李四",
		"王五",
		"赵六",
	}

	fmt.Println(names)

	a := names[0:2]
	b := names[1:3]
	fmt.Println(a, b)

	b[0] = "XXX"
	fmt.Println(a, b)
	fmt.Println(names)
}
#+end_src
@@html:<span id="test-slice-01"></span>@@

#+RESULTS:
: [张三 李四 王五 赵六]
: [张三 李四] [李四 王五]
: [张三 XXX] [XXX 王五]
: [张三 XXX 王五 赵六]

*切片字面量* ：
@@html:<span id="test-slice-02"></span>@@
#+begin_src go
import "fmt"
func main() {
	q := []int{2,3,5,7,11,13}
	fmt.Println(q)

	r := []bool{true, false, true, false}
	fmt.Println(r)

	s := []struct{
		i int
		b bool
	}{
		{2, true},
		{3, false},
		{5, true},
		{7, true},
		{11, false},
		{13, true},
	}
	fmt.Println(s)
}
#+end_src

#+RESULTS:
: [2 3 5 7 11 13]
: [true false true false]
: [{2 true} {3 false} {5 true} {7 true} {11 false} {13 true}]

*切片索引默认值*(~arr[start:end]~), start 默认是 0, end 默认是数组或切片的长度，切片时结果
不含 end 索引位置的值。
@@html:<span id="test-slice-03"></span>@@

#+begin_src go
import "fmt"
func main() {
	s := []int{2,3,5,7,11,13}

	a := s[1:4]
	fmt.Println(a)

	b := s[:2]
	fmt.Println(b)

	c := s[1:]
	fmt.Println(c)

	d := s[:]
	fmt.Println(d)

	a[0] = 22
	fmt.Println(s)

	b[0] = 33
	fmt.Println(s)

	c[0] = 44
	fmt.Println(s)

	d[0] = 55
	fmt.Println(s)
}
#+end_src

#+RESULTS:
: [3 5 7]
: [2 3]
: [3 5 7 11 13]
: [2 3 5 7 11 13]
: [2 22 5 7 11 13]
: [33 22 5 7 11 13]
: [33 44 5 7 11 13]
: [55 44 5 7 11 13]
