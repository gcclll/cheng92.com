#+TITLE: Vue + Vite + TS(Vitesse) 脚手架使用记录
#+DATE: <2022-02-08 10:02:11>
#+EMAIL: Lee ZhiCheng<gccll.love@gmail.com>
#+TAGS[]: vue, vite, vitesse
#+CATEGORIES[]: vue
#+LANGUAGE: zh-cn
#+STARTUP: indent

#+begin_export html
<link href="https://fonts.goo~gleapis.com/cs~s2?family=ZCOOL+XiaoWei&display=swap" rel="stylesheet">
<kbd>
<font color="blue" size="3" style="font-family: 'ZCOOL XiaoWei', serif;">
  诗号：六道同坠，魔劫万千，引渡如来。
</font>
</kbd><br><br>
<script src="/js/utils.js"></script>
#+end_export

[[/img/bdx/yiyeshu-001.jpg]]

该脚手架详情请查看官方文档： [[https://github.com/gcclll/vitesse][gcclll/vitesse: 🏕 Opinionated Vite Starter Template]]

本文是使用和学习过程中的一些笔记！

项目目录结构：

#+begin_src sh
 vitesse git:(main) ✗ tree -I "node_modules|dist"
.
├── cypress
│   ├── integration
│   │   └── basic.spec.ts
│   └── tsconfig.json
├── cypress.json
├── index.html # 模板文件
├── locales # 多语言国际化
│   ├── README.md
│   └── zh-CN.yml
├── netlify.toml
├── package.json
├── pnpm-lock.yaml
├── public
│   ├── _headers
│   ├── favicon.svg
│   ├── pwa-192x192.png
│   ├── pwa-512x512.png
│   ├── robots.txt
│   └── safari-pinned-tab.svg
├── src
│   ├── App.vue
│   ├── auto-imports.d.ts # 自动引入声明，该文件中声明，在项目中可以直接使用而不需要通过 import 引入
│   ├── components # 组件目录，该目录下的组件也可以直接使用而不需要 import 引入
│   │   ├── Counter.vue
│   │   ├── Footer.vue
│   │   └── README.md
│   ├── components.d.ts
│   ├── composables # 多主题
│   │   ├── dark.ts
│   │   └── index.ts
│   ├── layouts # 页面布局
│   │   ├── 404.vue
│   │   ├── README.md
│   │   ├── default.vue
│   │   └── home.vue
│   ├── main.ts
│   ├── modules # 项目中使用到了一些插件模块化
│   │   ├── README.md
│   │   ├── i18n.ts
│   │   ├── nprogress.ts
│   │   ├── pinia.ts
│   │   └── pwa.ts
│   ├── pages # 页面目录，自动路由化，会根据目录结构和文件名称生成对应的路由
│   │   ├── README.md
│   │   ├── [...all].vue
│   │   ├── about.md # 如： /about 加载这个
│   │   ├── hi
│   │   │   └── [name].vue # 如： /hi/100 加载这个页面
│   │   └── index.vue
│   ├── shims.d.ts
│   ├── stores # pinia 状态管理插件
│   │   └── user.ts
│   ├── styles # 全局样式
│   │   ├── main.css
│   │   └── markdown.css
│   └── types.ts # ts类型声明
├── test
│   ├── __snapshots__
│   │   └── component.test.ts.snap
│   ├── basic.test.ts
│   └── component.test.ts
├── tsconfig.json
├── vite.config.ts # vite 配置
└── windi.config.ts # windi css 框架配置
#+end_src

特性(来自官方)，下面会对每个特性使用到的插件进行分析：

- ⚡️ +Vue 3, Vite 2, pnpm, ESBuild - born with fastness+

- 🗂 File based routing

  基于文件结构的路由系统，使用插件 [[https://github.com/hannoeru/vite-plugin-pages][hannoeru/vite-plugin-pages: File system based route generator for ⚡️Vite]]

  代码入口： [[https://github.com/hannoeru/vite-plugin-pages/blob/main/src/index.ts][vite-plugin-pages/index.ts at main · hannoeru/vite-plugin-pages]]

  #+begin_src typescript
  async load(id) {
    if (id !== MODULE_ID_VIRTUAL)
       return

       return ctx.resolveRoutes()
  },
  #+end_src

  =resolveRoutes()= 解析 =src/pages= 路由：[[https://github.com/hannoeru/vite-plugin-pages/blob/771e956fd41589d8c9012c05016503e227d15b21/src/context.ts#L129][vite-plugin-pages/context.ts at 771e956fd41589d8c9012c05016503e227d15b21 · hannoeru/vite-plugin-pages]]

  #+begin_src typescript
  async resolveRoutes() {
    if (this.options.resolver === 'vue')
      return await resolveVueRoutes(this)
    if (this.options.resolver === 'react')
      return await resolveReactRoutes(this)
  }
  #+end_src

  -> =resolveVueRoutes(this)= [[https://github.com/hannoeru/vite-plugin-pages/blob/771e956fd41589d8c9012c05016503e227d15b21/src/resolvers/vue.ts#L58][vite-plugin-pages/vue.ts at 771e956fd41589d8c9012c05016503e227d15b21 · hannoeru/vite-plugin-pages]]

  #+begin_src typescript
export async function resolveVueRoutes(ctx: PageContext) {
  const { nuxtStyle, caseSensitive } = ctx.options

  // ctx.pageRouteMap 这个应该就是 src/pages/* 下所有文件解析出来的结构
  const pageRoutes = [...ctx.pageRouteMap.values()]
    // sort routes for HMR
    .sort((a, b) => countSlash(a.route) - countSlash(b.route))

  const routes: Route[] = []

  pageRoutes.forEach((page) => {
    const pathNodes = page.route.split('/')

    // add leading slash to component path if not already there
    const component = page.path.replace(ctx.root, '')
    const customBlock = ctx.customBlockMap.get(page.path)

    const route: Route = {
      name: '',
      path: '',
      component,
      customBlock,
      rawRoute: page.route,
    }

    let parentRoutes = routes

    for (let i = 0; i < pathNodes.length; i++) {
      // ..., 将 pathNode 解析成 Route 结构
    }
    parentRoutes.push(route)
  })

  let finalRoutes = prepareRoutes(ctx, routes)

  finalRoutes = (await ctx.options.onRoutesGenerated?.(finalRoutes)) || finalRoutes

  let client = generateClientCode(finalRoutes, ctx.options)
  client = (await ctx.options.onClientGenerated?.(client)) || client
  return client
}
  #+end_src

  =PageContext= 通过 =setupViteServer= 借用 vite 起的服务来监听(=setupWatcher=)目录文
  件的变化(=unlink,add,change=)，执行对应的操作(=removePage, addPage,
  checkCustomBlockChange=) 目的都是为了更新 =pageRouteMap= 这个结构。

  =searchGlob= 会扫描 ~options.dirs~ 指定的目录(默认是 =src/pages=)，找出符合条件的页
  面解析成路由。

  #+begin_quote
  简单来说 [[https://github.com/hannoeru/vite-plugin-pages][vite-plugin-pages]] 就是通过借用 =vite= 起的服务去监听 =src/pages= 目录的变
  化，如果有文件变化就将其根据其路径和文件名解析成对应的路由对象。
  #+end_quote

- 📦 Components auto importing
  @@html:<span id="cai"></span>@@

  使用的插件：[[https://github.com/antfu/unplugin-vue-components][antfu/unplugin-vue-components: 📲 On-demand components auto importing for Vue]]

  _src/index.ts_ -> _src/core/unplugin.ts_

  给 vite 服务增加 watcher : ~ctx.setupWatcher(chokidar.watch(ctx.options.globs))~

  transform 转换函数：
  #+begin_src typescript
  async transform(code, id) {
  // ...
        const result = await ctx.transform(code, id)
        ctx.generateDeclaration()
        return result
  // ...
  },
  #+end_src

  可以转换的时候进行转换，然后生成声明，即 ~src/components.d.ts~ 中的内容。

  =Context= 中同样也是通过 vite server 监听文件 unlink,add 变化，执行
  ~removeComponents~ 或 ~addCompnents~, 以 ~addComponents~ 为例：

  #+begin_src typescript
addComponents(paths: string | string[]) {
  debug.components('add', paths)

  const size = this._componentPaths.size
  toArray(paths).forEach(p => this._componentPaths.add(p))
  if (this._componentPaths.size !== size) {
    this.updateComponentNameMap()
    return true
  }
  return false
}
  #+end_src

  -> =updateComponentNameMap()= 更新的是 =componentNameMap= 这个对象，它会被

  [[https://github.com/antfu/unplugin-vue-components/blob/40fb687990071e485a11ddb73b8e1beec1694249/src/core/declaration.ts#L13][unplugin-vue-components/declaration.ts at 40fb687990071e485a11ddb73b8e1beec1694249 · antfu/unplugin-vue-components]]

  中的 =generateDeclaration= 函数解析最后生成对应的代码写入(~await
  fs.writeFile(filepath, code, 'utf-8')~)到 =src/components.d.ts= 中

- 🍍 State Management via Pinia

- 📑 Layout system

- 📲 PWA

- 🎨 Windi CSS - next generation utility-first CSS framework

- 😃 Use icons from any icon sets, with no compromise

  [[https://github.com/antfu/unplugin-icons][antfu/unplugin-icons: 🤹 Access thousands of icons as components on-demand universally.]]

  代码入口 =src/index.ts= loader 函数 -> =generateComponentFromPath()= ：

  [[https://github.com/antfu/unplugin-icons/blob/4fde686174e0d054eac180c179dbae820afefba1/src/core/loader.ts#L112][unplugin-icons/loader.ts at 4fde686174e0d054eac180c179dbae820afefba1 · antfu/unplugin-icons]]
  #+begin_src typescript
export async function generateComponentFromPath(path: string, options: ResolvedOptions) {
  const resolved = resolveIconsPath(path)
  if (!resolved)
    return null
  return generateComponent(resolved, options)
}
  #+end_src

  loadCollection -> ~`@iconify-json/${name}/icons.json`~ -> install ~await tryInstallPkg(`@iconify-json/${name}`)~

  #+begin_src typescript

export async function tryInstallPkg(name: string) {
  if (pending)
    await pending

  if (!tasks[name]) {
    // eslint-disable-next-line no-console
    console.log(cyan(`Installing ${name}...`))
    tasks[name] = pending = installPackage(name, { dev: true, preferOffline: true })
      .then(() => sleep(300))
      .catch((e) => {
        warnOnce(`Failed to install ${name}`)
        console.error(e)
      })
      .finally(() => {
        pending = undefined
      })
  }

  return tasks[name]!
}
  #+end_src

  使用 [[https://github.com/antfu/install-pkg][antfu/install-pkg: Install package programmatically.]] 下载安装 icon, 执行：
  #+begin_src typescript
  execa(
    agent,
    [
      agent === 'yarn'
        ? 'add'
        : 'install',
      options.dev ? '-D' : '',
      ...args,
      ...names,
    ].filter(Boolean),
    {
      stdio: options.silent ? 'ignore' : 'inherit',
      cwd: options.cwd,
    },
  )
  #+end_src

  等于是 =yarn add -D @iconify-json/icon-name= 安装。

  根据解析出来的路径 =resolved= 去下载 icon =let svg = await getIcon(collection,
  icon, query, options)= 下载成功后转成 svg
  #+begin_src typescript
  return await mergeIconProps(
    `<svg>${body}</svg>`,
    collection,
    id,
    query,
    () => attributes,
    options,
  )
  #+end_src

- 🌍 I18n ready

- 🗒 Markdown Support

- 🔥 +Use the new <script setup> syntax+

- 📥 APIs auto importing - use Composition API and others directly

  [[https://github.com/antfu/unplugin-auto-import][antfu/unplugin-auto-import: Auto import APIs on-demand for Vite, Webpack and Rollup]]

  引入 [[https://github.com/antfu/unplugin-auto-import][unplugin-auto-import]] 然后在 vite.config.ts 中增加:
  #+begin_src js
  plugins: ]
    AutoImport({
      imports: [
        'vue',
        'vue-router',
        'vue-i18n',
        '@vueuse/head',
        '@vueuse/core',
      ],
      dts: 'src/auto-imports.d.ts',
    }),
  ]
  #+end_src

  其实和 @@html:<a href="#cai">:link: components auto import</a>@@ 原理差不多，
  差异在这个是直接通过 vite.config.ts 中的配置中获取需要自动导入的插件。

  代码： =src/index.ts= -> transform -> =generateConfigFiles()=
  #+begin_src typescript

  const generateConfigFiles = throttle(500, false, () => {
    if (resolved.dts)
      fs.writeFile(resolved.dts, generateDeclaration(resolved.imports, resolved.resolvedImports), 'utf-8')

    const { eslintrc } = resolved
    if (eslintrc.enabled && eslintrc.filepath)
      fs.writeFile(eslintrc.filepath, generateESLintConfigs(resolved.imports, resolved.resolvedImports, eslintrc), 'utf-8')
  })
  #+end_src

  根据 ~resolved.imports~ 配置，生成声明代码写入到 ~resolved.dts~ 指定的文件。后面是
  将自动引入的文件加入 eslint 的配置文件。

  最后生成类似下面的代码：
  #+begin_src typescript
declare global {
  const asyncComputed: typeof import('@vueuse/core')['asyncComputed']
  // ...
}
  #+end_src

- 🖨 Static-site generation (SSG) via vite-ssg

- 🦔 Critical CSS via critters

- 🦾 TypeScript, of course

- ⚙️ Unit Testing with Vitest, E2E Testing with Cypress on GitHub Actions

- ☁️ Deploy on Netlify, zero-config
