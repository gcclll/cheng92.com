#+TITLE: Vue3 更新日志 02 - 3.2
#+DATE: <2021-08-10 08:30:07>
#+TAGS[]: vue3, vue-next,
#+CATEGORIES[]: vue
#+LANGUAGE: zh-cn
#+STARTUP: indent

#+begin_export html
<link href="https://fonts.goo~gleapis.com/cs~s2?family=ZCOOL+XiaoWei&display=swap" rel="stylesheet">
<link href="/js/vue/formatters-styles/style.css" rel="stylesheet">
<link href="/js/vue/formatters-styles/annotated.css" rel="stylesheet">
<link href="/js/vue/formatters-styles/html.css" rel="stylesheet">
<kbd>
<font color="blue" size="3" style="font-family: 'ZCOOL XiaoWei', serif;">
诗号：六道同坠，魔劫万千，引渡如来。
</font>
</kbd><br><br>
<script src="/js/utils.js"></script>
<!-- <script src="/js/vue/vue-next.js"></script> -->
<script src="https://unpkg.com/vue@next"></script>
<script>
insertCssLink("https://unpkg.com/element-plus/lib/theme-chalk/index.css");
</script>
<script src="https://unpkg.com/element-plus/lib/index.full.js"></script>
<script type='text/javascript' src="https://cdn.jsdelivr.net/npm/jsondiffpatch/dist/jsondiffpatch.umd.min.js"></script>
<script src="/js/vue/tests/common.js"></script>
#+end_export

[[/img/bdx/yiyeshu-001.jpg]]

#+begin_quote
3.2.x 更新日志。
#+end_quote

https://github.com/vuejs/vue-next/blob/master/CHANGELOG.md

* Important Changes
** ReactiveEffect 从函数变成了一个 class
:PROPERTIES:
:COLUMNS:  %CUSTOM_ID[(Custom Id)]
:CUSTOM_ID: ReactiveEffect2Object
:END:

#+begin_src typescript
export class ReactiveEffect<T = any> {
  active = true
  deps: Dep[] = []

  // can be attached after creation
  computed?: boolean
  allowRecurse?: boolean
  onStop?: () => void
  // dev only
  onTrack?: (event: DebuggerEvent) => void
  // dev only
  onTrigger?: (event: DebuggerEvent) => void

  constructor(
    public fn: () => T,
    public scheduler: EffectScheduler | null = null,
    scope?: EffectScope | null
  ) {
    recordEffectScope(this, scope)
  }

  run() {
    if (!this.active) {
      return this.fn()
    }
    if (!effectStack.includes(this)) {
      try {
        effectStack.push((activeEffect = this))
        enableTracking()

        trackOpBit = 1 << ++effectTrackDepth

        if (effectTrackDepth <= maxMarkerBits) {
          initDepMarkers(this)
        } else {
          cleanupEffect(this)
        }
        return this.fn()
      } finally {
        if (effectTrackDepth <= maxMarkerBits) {
          finalizeDepMarkers(this)
        }

        trackOpBit = 1 << --effectTrackDepth

        resetTracking()
        effectStack.pop()
        const n = effectStack.length
        activeEffect = n > 0 ? effectStack[n - 1] : undefined
      }
    }
  }

  stop() {
    if (this.active) {
      cleanupEffect(this)
      if (this.onStop) {
        this.onStop()
      }
      this.active = false
    }
  }
}
#+end_src

依赖收集的时候：

#+begin_src typescript
export function effect<T = any>(
  fn: () => T,
  options?: ReactiveEffectOptions
): ReactiveEffectRunner {
  if ((fn as ReactiveEffectRunner).effect) {
    fn = (fn as ReactiveEffectRunner).effect.fn
  }

  // 1. new instance
  const _effect = new ReactiveEffect(fn)
  if (options) {
    extend(_effect, options)
    if (options.scope) recordEffectScope(_effect, options.scope)
  }
  if (!options || !options.lazy) {
    // 2. run
    _effect.run()
  }
  const runner = _effect.run.bind(_effect) as ReactiveEffectRunner
  runner.effect = _effect
  return runner
}
#+end_src
* TODO 3.2.0 (2021-08-09)
** Compatibility Notes

#+begin_comment
This release contains no public API breakage. However, there are a few compatibility related notes:

没有 API 的破坏更新。

Due to usage of new runtime helpers, code generated by the template compiler in
>= 3.2 will not be compatible with runtime < 3.2.

3.2 之后模板编译与之前的不兼容。

This only affects cases where there is a version mismatch between the compiler
and the runtime. The most common case is libraries that ship pre-compiled Vue
components. If you are a library author and ship code pre-compiled by Vue >=
3.2, your library will be only compatible Vue >= 3.2.

This release ships TypeScript typings that rely on Template Literal Types and
requires TS >= 4.1.
#+end_comment

** Features
*** SFC [0/5]
- [-] remove experimental status of <script setup> (27104ea) (Docs) (RFC)
- [-] remove experimental status for sfc <style> v-bind (3b38c9a) (Docs) (RFC)
- [-] support non-explicit type imports in <script setup> by avoiding exposing unused imports to template during dev (5a3ccfd), closes #3183
- [-] support namespaced component tags when using <script setup> (e5a4412)
- [-] (experimental) new ref sugar (562bddb) (RFC)
*** Custom Elements [0/1]
- [-] defineCustomElement (8610e1c) (Docs)
*** Reactivity [0/2]
- [-] new effectScope API (#2195) (f5617fc) (RFC)
- [-] support onTrack/onTrigger debug options for computed (5cea9a1)
*** SSR [0/1]
- [-] server-renderer: decouple esm build from Node + improve stream API (0867222), closes #3467 #3111 #3460 (Docs)
*** Generic [0/6]
- [-] New v-memo directive (3b64508) (Docs)
- [-] support v-bind .prop & .attr modifiers (1c7d737) (Docs)
- [-] add watchPostEffect API (42ace95) (Docs)
- [-] add watchSyncEffect API (d87d059) (Docs)
- [-] unwrap refs in toDisplayString (f994b97)
- [-] allow compilerOptions.comments to affect comment inclusion in dev (#4115) (dd0f9d1), closes #3392 #3395
*** Types [0/1]
- [-] map declared emits to onXXX props in inferred prop types (#3926) (69344ff)
** Performance Improvements [0/7]
- [-] reactivity: improve reactive effect memory usage (#4001) (87f69fd), closes #2345
- [-] reactivity: ref-specific track/trigger and miscellaneous optimizations (#3995) (6431040)
- [-] reactivity: use bitwise dep markers to optimize re-tracking (#4017) (6cf2377)
- [-] compiler-core/runtime-core: improve VNode creation performance with compiler hints (#3334) (ceff899)
- [-] compiler-core: also hoist all-static children array (b7ea7c1)
- [-] compiler-core: hoist dynamic props lists (02339b6)
- [-] compiler-sfc: ignore empty blocks (#3520) (b771fdb)
** Bug Fixes [0/1]
- [-] Please refer to changelogs of previous beta releases for bug fixes included in this release.
* TODO 3.2.0-beta.8 (2021-08-07)
** Bug Fixes [0/0]
- [-] compiler-core: detected forwarded slots in nested components (#4268) (abb3a81), closes #4244
- [-] compiler-sfc: fix ref sugar rewrite for identifiers in ts casting expressions (865b84b), closes #4254
- [-] core: typing of key in VNodeProps (#4242) (d045055), closes #4240
- [-] runtime-core: component effect scopes should be detached (6aa871e)
- [-] runtime-dom: fix shadowRoot instanceof check in unsupported browsers (#4238) (bc7dd93)
- [-] types: remove explicit return type annotation requirement for this inference in computed options (#4221) (d3d5ad2)
- [-] v-memo: ensure track block when returning cached vnode (#4270) (a211e27), closes #4253
- [-] v-memo: should work on v-for with constant expression (#4272) (3b60358), closes #4246
** Features [0/0]
- [-] runtime-dom: support async component in defineCustomElement (c421fb9), closes #4261
* TODO 3.2.0-beta.7 (2021-07-29)
** Bug Fixes [0/4]
- [-] reactivity: dereference nested effect scopes on manual stop (1867591)
- [-] sfc/style-vars: improve ignore style variable bindings in comments (#4202) (771635b)
- [-] shared: support custom .toString() in text interpolation again (#4210) (9d5fd33), closes #3944
- [-] suspense: fix dynamicChildren tracking when suspense root is a block itself (51ee84f), closes #4183 #4198
** Features [0/2]
- [-] server-renderer: decouple esm build from Node + improve stream API (0867222), closes #3467 #3111 #3460
- [-] sfc: remove experimental status for sfc style v-bind (3b38c9a)
* TODO 3.2.0-beta.6 (2021-07-27)
** Bug Fixes [0/0]
- [-] inject: should auto unwrap injected refs (561e210), closes #4196
- [-] runtime-core: expose ssrUtils in esm-bundler build (ee4cbae), closes #4199
- [-] sfc/style-vars: should ignore style variable bindings in comments (#4188) (3a75d5d), closes #4185
** Features [0/0]
- [-] unwrap refs in toDisplayString (f994b97)
* TODO 3.2.0-beta.5 (2021-07-23)
** Important [0/0]
** Bug Fixes [0/4]
- [-] hmr: fix custom elements hmr edge cases (bff4ea7)
- [-] hmr: fix hmr when global mixins are used (db3f57a), closes #4174
- [-] types: fix types for readonly ref (2581cfb), closes #4180
- [-] v-model: avoid resetting value of in-focus & lazy input (ac74e1d), closes #4182
** Features [0/4]
- [-] compiler-sfc: avoid exposing imports not used in template (5a3ccfd), closes #3183
- [-] runtime-dom: hmr for custom elements (7a7e1d8)
- [-] runtime-dom: support passing initial props to custom element constructor (5b76843)
- [-] runtime-dom: support specifying shadow dom styles in defineCustomElement (a7fa4ac)
* TODO 3.2.0-beta.4 (2021-07-21)
** Important [0/0]
** Bug Fixes [0/2]
- [-] runtime-core: ensure setupContext.attrs reactivity when used in child slots (8560005), closes #4161
- [-] runtime-dom: defer setting value (ff-1c810), closes #2325 #4024
** Performance Improvements [0/1]
- [-] skip patch on same vnode (d13774b)
* TODO 3.2.0-beta.3 (2021-07-20)
** Important [0/0]
** Bug Fixes [0/4]
- [-] reactivity: revert computed scheduler change (33c2fbf), closes #4157
- [-] runtime-core: fix v-bind class/style merging regression (2bdee50), closes #4155
- [-] sfc-playground: Transform named default exports without altering scope (#4154) (acb2a4d)
- [-] watch: ensure watchers respect detached scope (bc7f976), closes #4158
** Features [0/2]
- [-] reactivity: deferredComputed (14ca881)
- [-] runtime-core: watchSyncEffect (d87d059)
* TODO 3.2.0-beta.2 (2021-07-19)
** Important [0/0]
** Bug Fixes [0/11]
- [-] compiler-core: fix self-closing tags with v-pre (a21ca3d)
- [-] compiler-sfc: defineProps infer TSParenthesizedType (#4147) (f7607d3)
- [-] compiler-sfc: expose correct range for empty blocks (b274b08)
- [-] compiler-sfc: fix whitespace preservation when block contains single self-closing tag (ec6abe8)
- [-] compiler-sfc: support const enum (93a950d)
- [-] reactivity: computed should not trigger scheduler if stopped (6eb47f0), closes #4149
- [-] runtime-core: fix null type in required + multi-type prop declarations (bbf6ca9), closes #4146 #4147
- [-] scheduler: fix insertion for id-less job (d810a1a), closes #4148
- [-] shared: normalizeStyle should handle strings (a8c3a8a), closes #4138
- [-] ssr: update initial old value to watch callback in ssr usage (#4103) (20b6619)
- [-] v-model: properly detect input type=number (3056e9b), closes #3813
** Features [0/3]
- [-] compiler: allow 'comments' option to affect comment inclusion in dev (#4115) (dd0f9d1), closes #3392 #3395
- [-] compiler-sfc: add ignoreEmpty option for sfc parse method (8dbecfc)
- [-] types: map declared emits to onXXX props in inferred prop types (#3926) (69344ff)
** Performance Improvements [0/1]
- [-] compiler-sfc: ignore empty blocks (#3520) (b771fdb)
* TODO 3.2.0-beta.1 (2021-07-16)
** Important
1. *ADD*: ~defineCustomElement~ 结合 ~window.customElements~ 来定义元素 @@html:<a href="#dce">:link: </a>@@
2. *ADD*: ~v-memo~ 指令可以指定哪些条件下组件需要更新 @@html:<a href="#v-memo">:link: </a>@@
3. *ADD*: ~watchPostEffect~ 等价于 ~doWatch(effect, null/*cb*/, { flush: 'post' })~ @@html:<a href="#wpe">:link: </a>@@
4. *ADD*: ~effectScope~  @@html:<a href="/vue/vue-teardown-15-effect-scope">:link: </a>@@
** Code Refactoring(代码重构) [0/1]
- [-] remove deprecated scopeId codegen (f596e00)
** Bug Fixes [0/4]
- [-] sfc/style-vars: properly re-apply style vars on component root elements
  change ([[https://github.com/vuejs/vue-next/commit/49dc2dd1e4a56d0d2ad28003240c99e99ef469e4][49dc2dd]]), closes [[https://github.com/vuejs/vue-next/issues/3894][#3894]]

  在使用 ~<transition>~ 和 ~v-if~ 时， ~SFC <style>~ 中的 ~v-bind(color)~ 没起作用？

  #+begin_src diff
// packages/runtime-dom/src/helpers/useCssVars.ts
// @@ -27,8 +27,12 @@ export function useCssVars(getter: (ctx: any) => Record<string, string>) {
  const setVars = () =>
    setVarsOnVNode(instance.subTree, getter(instance.proxy!))
-  onMounted(() => watchEffect(setVars, { flush: 'post' }))
-  onUpdated(setVars)
+  watchPostEffect(setVars)
+  onMounted(() => {
+    const ob = new MutationObserver(setVars)
+    ob.observe(instance.subTree.el!.parentNode, { childList: true })
+    onUnmounted(() => ob.disconnect())
+  })
}
  #+end_src

  涉及函数： ~watchPostEffect(setVars)~ 和 ~MutationObserver(setVars)~ 的使用。

  watchPostEffect 是监听 instance.subTree 状态的变化时执行 ~setVars -> setVarsOnVNode~

  MutationObserver 是 JavaScript 的原生 API ，详情可查看此文。


- [-] ensure customElements API ssr compatibility (de32cfa), closes #4129
- [-] runtime-core: fix default shapeFlag for fragments (2a310df)
- [-] ignore .prop/.attr modifiers in ssr (29732c2)
** Features [10/10]
- [X] [[/vue/vue-update-3.2/#new-ref-sugar][sfc: (experimental) new ref sugar]] ([[https://github.com/vuejs/vue-next/commit/562bddb3ce76a0e98e499e199e96fa4271e5d1b4][562bddb]])
  @@html:<span id="sfc-ref-sugar"></span>@@
- [X] sfc: support namespaced component tags when using <script setup> ([[https://github.com/vuejs/vue-next/commit/e5a4412764f6db255afe01b8a7e6e40ebf707412][e5a4412]])
- [X] custom element reflection, casting and edge cases ([[https://github.com/vuejs/vue-next/commit/00f0b3c46552626cd7c5ec73ffd0a918c3e1a5fb][00f0b3c]])
  @@html:<span id="custom-element-refection"></span>@@
- [X] remove experimental status of <script setup> ([[https://github.com/vuejs/vue-next/commit/00f0b3c46552626cd7c5ec73ffd0a918c3e1a5fb][27104ea]])

  正式发布 ~<script setup>~
- [X] [[/vue/vue-teardown-16-prop-and-attrs-modifiers/][support v-bind .prop & .attr modifiers]] ([[https://github.com/vuejs/vue-next/commit/8610e1c9e23a4316f76fb35eebbab4ad48566fbf][1c7d737]])
- [X] runtime-dom: defineCustomElement ([[https://github.com/vuejs/vue-next/commit/8610e1c9e23a4316f76fb35eebbab4ad48566fbf][8610e1c]])
  @@html:<span id="dce"></span>@@

  [[https://github.com/vuejs/vue-next/tree/master/packages/runtime-core/src/component.ts][runtime-core/src/component.ts:]]
  #+begin_src typescript
export interface ComponentInternalInstance {
  /**
   ,* is custom element?
   ,*/
  isCE?: boolean
  // ...
}

export function createComponentInstance(/*...*/) {
  // ...
  // 交给 vnode.ce 去处理
  // apply custom element special handling
  if (vnode.ce) {
    vnode.ce(instance)
  }
}
  #+end_src

  [[https://github.com/vuejs/vue-next/tree/master/packages/runtime-core/src/helpers/renderSlot.ts][runtime-core/src/helpers/renderSlot.ts]]
  #+begin_src typescript
export function renderSlot(/*...*/) {
  if (currentRenderingInstance!.isCE) {
    return createVNode(
      'slot',
      name === 'default' ? null : { name },
      fallback && fallback()
    )
  }
  // ...
}
  #+end_src

  #+begin_export html
  <div>测试结果 <button onclick="showCode('rhBIQi');">查看源码</button></div>
  <div id="rhBIQi" class="comment-block"></div>
<script id="s_rhBIQi">
const p_rhBIQi = document.getElementById('rhBIQi')
const cr = document.createElement('div')
p_rhBIQi.appendChild(cr)
const E = Vue.defineCustomElement({
  render: () => Vue.h('div', 'hello')
})
customElements.define('my-element', E)
cr.innerHTML = "<my-element></my-element>"
const e = cr.childNodes[0]
console.log(e, e instanceof E)
console.log(e._instance)
console.log(e.shadowRoot.innerHTML)
</script>
  #+end_export
- [X] [[/vue/vue-teardown-5-directives/#v-memo][v-memo 可以指定什么条件下组件会被重新渲染，否则使用缓存结果]] ([[https://github.com/vuejs/vue-next/commit/3b64508e3b2d648e346cbf34e1641f4022be61b6][3b64508]])
  @@html:<span id="v-memo"></span>@@

  [[https://github.com/vuejs/vue-next/tree/master/packages/compiler-core/src/transforms/vFor.ts][compiler-core/src/transforms/vFor.ts]] 中增加的核心代码：

  #+begin_src typescript
// v-memo
if (memo) {
  const loop = createFunctionExpression(
    createForLoopParams(forNode.parseResult, [
      createSimpleExpression(`_cached`)
    ])
  )
  loop.body = createBlockStatement([
    createCompoundExpression([`const _memo = (`, memo.exp!, `)`]),
    createCompoundExpression([
      `if (_cached`,
      ...(keyExp ? [` && _cached.key === `, keyExp] : []),
      ` && ${context.helperString(
IS_MEMO_SAME
)}(_cached.memo, _memo)) return _cached`
    ]),
    createCompoundExpression([`const _item = `, childBlock as any]),
    createSimpleExpression(`_item.memo = _memo`),
    createSimpleExpression(`return _item`)
  ])
  renderExp.arguments.push(
    loop as ForIteratorExpression,
    createSimpleExpression(`_cache`),
    createSimpleExpression(String(context.cached++))
  )
} else {
  renderExp.arguments.push(createFunctionExpression(
    createForLoopParams(forNode.parseResult),
    childBlock,
    true /* force newline */
  ) as ForIteratorExpression)
}
  #+end_src

  如：
  #+begin_src js :results value code
const url = process.env.VNEXT_PKG_RC +'/../compiler-core/dist/compiler-core.cjs.js'
const value = require(url.replace('stb-', ''))
const { baseCompile } = value

const compile = c => baseCompile(`<div>${c}</div>`, {
  mode: "module",
  prefixIdentifiers: true
}).code

function test(title, code, options) {
  console.log('// > ' + title)
  console.log(compile(code))
}

console.log('// > on root element')
console.log(  baseCompile(`<div v-memo="[x]"></div>`, {
  mode: 'module',
  prefixIdentifiers: true
}).code)

test('on normal element', `<div v-memo="[x]"></div>`)
test('on template v-for', `<template v-for="{ x, y } in list" :key="x" v-memo="[x, y === z]">
          <span>foobar</span>
        </template>`)
return 0
  #+end_src

  #+RESULTS:
  #+begin_src js
  // > on root element
  import { openBlock as _openBlock, createElementBlock as _createElementBlock, withMemo as _withMemo } from "vue"

  export function render(_ctx, _cache) {
    return _withMemo([_ctx.x], () => (_openBlock(), _createElementBlock("div")), _cache, 0)
  }
  // > on normal element
  import { openBlock as _openBlock, createElementBlock as _createElementBlock, withMemo as _withMemo } from "vue"

  export function render(_ctx, _cache) {
    return (_openBlock(), _createElementBlock("div", null, [
      _withMemo([_ctx.x], () => (_openBlock(), _createElementBlock("div")), _cache, 0)
    ]))
  }
  // > on template v-for
  import { renderList as _renderList, Fragment as _Fragment, openBlock as _openBlock, createElementBlock as _createElementBlock, isMemoSame as _isMemoSame, withMemo as _withMemo } from "vue"

  export function render(_ctx, _cache) {
    return (_openBlock(), _createElementBlock("div", null, [
      (_openBlock(true), _createElementBlock(_Fragment, null, _renderList(_ctx.list, ({ x, y }, __, ___, _cached) => {
        const _memo = ([x, y === z])
        if (_cached && _cached.key === x && _isMemoSame(_cached, _memo)) return _cached
        const _item = (_openBlock(), _createElementBlock("span", { key: x }, "foobar"))
        _item.memo = _memo
        return _item
      }, _cache, 0), 128 /* KEYED_FRAGMENT */))
    ]))
  }
  0
  #+end_src

  _withMemo -> [[https://github.com/vuejs/vue-next/tree/master/packages/runtime-core/src/helpers/withMemo.ts][runtime-core/src/helpers/withMemo.ts:withMemo]]

  #+begin_src typescript
export function withMemo(
  memo: any[],
  render: () => VNode<any, any>,
  cache: any[],
  index: number
) {
  const cached = cache[index] as VNode | undefined
  if (cached && isMemoSame(cached, memo)) {
    return cached
  }
  const ret = render()

  // shallow clone
  ret.memo = memo.slice()
  return (cache[index] = ret)
}
  #+end_src

  判断不重新渲染条件(memo 长度和元素的值必须一致)：
  #+begin_src typescript
export function isMemoSame(cached: VNode, memo: any[]) {
  const prev: any[] = cached.memo!
  if (prev.length != memo.length) {
    return false
  }
  for (let i = 0; i < prev.length; i++) {
    if (prev[i] !== memo[i]) {
      return false
    }
  }

  // make sure to let parent block track it when returning cached
  if (isBlockTreeEnabled > 0 && currentBlock) {
    currentBlock.push(cached)
  }
  return true
}
  #+end_src
- [X] watchPostEffect ([[https://github.com/vuejs/vue-next/commit/42ace9577da49477ff189950a83d6eead73d0efe][42ace95]])
  @@html:<span id="wpe"></span>@@

  #+begin_src typescript
export function watchPostEffect(
  effect: WatchEffect,
  options?: DebuggerOptions
) {
  return doWatch(effect, null, (__DEV__
    ? Object.assign(options || {}, { flush: 'post' })
    : { flush: 'post' }) as WatchOptionsBase)
}
  #+end_src

  测试：
  #+begin_src js
(async function () {
  const url = process.env.VNEXT_PKG_RC +'/../runtime-test/dist/runtime-test.cjs.js'
  const value = require(url.replace('stb-', ''))
  const { render, ref,
          reactive, nextTick, serializeInner, h, nodeOps,
          watchPostEffect
        } = value

  const count = ref(0)
  let result, n = 0
  const assertion = count => {
    result = serializeInner(root) === `${count}`
    n++
  }

  const Comp = {
    setup() {
      watchPostEffect(() => assertion(count.value))
      return () => count.value
    }
  }

  const root = nodeOps.createElement('div')
  try {
    render(h(Comp), root)
  } catch(e) {
    console.log(e.message);
  }
  console.log('1. result = ' + result + ', n = ' + n)

  count.value++

  await nextTick()
  console.log('\n2. result = ' + result + ', n = ' + n)
}());
return ''
  #+end_src

  #+RESULTS:
  : 1. result = true, n = 1
  : ''
  : 2. result = true, n = 2
- [X] [[/vue/vue-teardown-15-effect-scope][reactivity: new effectScope API]] ([[https://github.com/vuejs/vue-next/issues/2195][#2195]]) ([[https://github.com/vuejs/vue-next/commit/f5617fc3bb8fd33927b2567622ac4f8b43f9b5d5][f5617fc]])

  RFC: [[https://github.com/vuejs/rfcs/pull/212][vuejs/rfcs#212]]

  新增的 APIs
  1. EffectScope (class)
  2. getCurrentScope
  3. onScopeDispose
- [X] reactivity: support onTrack/onTrigger debug options for computed ([[https://github.com/vuejs/vue-next/commit/5cea9a1d4e846f60515ef76ebab4800228645601][5cea9a1]])

  支持 *DEV* 模式下分别在 track 和 trigger 的时候调用 onTrack 和 onTrigger。

 onTrack -> effect.ts:trackEffects:
 #+begin_src typescript
if (shouldTrack) {
  dep.add(activeEffect!)
  activeEffect!.deps.push(dep)
  if (__DEV__ && activeEffect!.onTrack) {
    activeEffect!.onTrack(
      Object.assign(
        {
          effect: activeEffect!
        },
        debuggerEventExtraInfo
      )
    )
  }
}
 #+end_src

 onTrigger -> effect.ts:triggerEffects:
 #+begin_src typescript
for (const effect of isArray(dep) ? dep : [...dep]) {
  if (effect !== activeEffect || effect.allowRecurse) {
    if (__DEV__ && effect.onTrigger) {
      effect.onTrigger(extend({ effect }, debuggerEventExtraInfo))
    }
    if (effect.scheduler) {
      effect.scheduler()
    } else {
      effect.run()
    }
  }
}

// onTrigger 参数： { effect } & DebuggerEventExtraInfo
export type DebuggerEventExtraInfo = {
  target: object
  type: TrackOpTypes | TriggerOpTypes
  key: any
  newValue?: any
  oldValue?: any
  oldTarget?: Map<any, any> | Set<any>
}
 #+end_src

 使用：
 #+begin_src js
const url = process.env.VNEXT_PKG_RC +'/../reactivity/dist/reactivity.cjs.js'
const value = require(url.replace('stb-', ''))
const { reactive, effect, computed } = value

const obj = reactive({ foo: 1 })
function onTrack(eventInfo) {
  console.log('TrackEventArg=', eventInfo);
}
function onTrigger(eventInfo) {
  console.log('TriggerEventArg=', eventInfo);
}
const c = computed(() => obj.foo, { onTrigger, onTrack })

c.value;
obj.foo++
console.log('c.value = ' + c.value)
return obj
 #+end_src

 #+RESULTS:
 #+begin_example
 TrackEventArg= {
   effect: ReactiveEffect {
     fn: [Function (anonymous)],
     scheduler: [Function (anonymous)],
     active: true,
     deps: [ [Set] ],
     onTrack: [Function: onTrack],
     onTrigger: [Function: onTrigger]
   },
   target: { foo: 1 },
   type: 'get',
   key: 'foo'
 }
 TriggerEventArg= {
   effect: ReactiveEffect {
     fn: [Function (anonymous)],
     scheduler: [Function (anonymous)],
     active: true,
     deps: [ [Set] ],
     onTrack: [Function: onTrack],
     onTrigger: [Function: onTrigger]
   },
   target: { foo: 2 },
   type: 'set',
   key: 'foo',
   newValue: 2,
   oldValue: 1,
   oldTarget: undefined
 }
 c.value = 2
 { foo: 2 }
 #+end_example

** Performance improvements [7/7]
- [X] also hoist all-static children array ([[https://github.com/vuejs/vue-next/commit/b7ea7c148552874e8bce399eec9fbe565efa2f4d][b7ea7c1]])
  如果 children 里面都是静态节点直接将整个 children 数组提升:
  #+begin_src diff
const _hoisted_1 = /*#__PURE__*/_createElementVNode(\\"div\\", { key: \\"foo\\" }, null, -1 /* HOISTED */)
+ const _hoisted_2 = [
+  _hoisted_1
+ ]

return function render(_ctx, _cache) {
  with (_ctx) {
    const { createElementVNode: _createElementVNode, openBlock: _openBlock, createElementBlock: _createElementBlock } = _Vue

-    return (_openBlock(), _createElementBlock(\\"div\\", null, [
-      _hoisted_1
-    ]))
+    return (_openBlock(), _createElementBlock(\\"div\\", null, _hoisted_2))
  }
}"
  #+end_src
- [X] hoist dynamic props lists ([[https://github.com/vuejs/vue-next/commit/02339b67d8c6fab6ee701a7c4f2773139ed007f5][02339b6]])
  动态属性名列表提升：
  #+begin_src diff
-      _createElementVNode(\\"div\\", { id: foo }, null, 8 /* PROPS */, [\\"id\\"])
+      _createElementVNode(\\"div\\", { id: foo }, null, 8 /* PROPS */, _hoisted_1)
  #+end_src
- [X] reactivity: avoid triggering re-render if computed value did not change ([[https://github.com/vuejs/vue-next/commit/ebaac9a56d82d266e333d077b6457543d7cab9ae][ebaac9a]])
  trigger computed value 之前先检查下值有没改变。

  #+begin_src typescript
if (this._dirty) {
  this._dirty = false
  const newValue = this.effect.run()!
  if (this._value !== newValue) {
    this._value = newValue
    triggerRefValue(this)
  }
} else {
  triggerRefValue(this)
}
  #+end_src
- [X] reactivity: improve reactive effect memory usage ([[https://github.com/vuejs/vue-next/issues/4001][#4001]]) ([[https://github.com/vuejs/vue-next/commit/87f69fd0bb67508337fb95cb98135fd5d6ebca7d][87f69fd]]), closes [[https://github.com/vuejs/vue-next/issues/2345][#2345]]

  改动点：

  1) ReactiveEffect 改用 class 来实现(stop, run 都在这个 class 里面实现)

     #+begin_src typescript
export class ReactiveEffect<T = any> {
  active = true
  deps: Dep[] = []

  // can be attached after creation
  computed?: boolean
  allowRecurse?: boolean
  onStop?: () => void
  // dev only
  onTrack?: (event: DebuggerEvent) => void
  // dev only
  onTrigger?: (event: DebuggerEvent) => void

  constructor(
    public fn: () => T,
    public scheduler: EffectScheduler | null = null,
    scope?: EffectScope | null
  ) {
    recordEffectScope(this, scope)
  }

  run() {
    if (!this.active) {
      return this.fn()
    }
    if (!effectStack.includes(this)) {
      try {
        effectStack.push((activeEffect = this))
        enableTracking()

        trackOpBit = 1 << ++effectTrackDepth

        if (effectTrackDepth <= maxMarkerBits) {
          initDepMarkers(this)
        } else {
          cleanupEffect(this)
        }
        return this.fn()
      } finally {
        if (effectTrackDepth <= maxMarkerBits) {
          finalizeDepMarkers(this)
        }

        trackOpBit = 1 << --effectTrackDepth

        resetTracking()
        effectStack.pop()
        const n = effectStack.length
        activeEffect = n > 0 ? effectStack[n - 1] : undefined
      }
    }
  }

  stop() {
    if (this.active) {
      cleanupEffect(this)
      if (this.onStop) {
        this.onStop()
      }
      this.active = false
    }
  }
}
     #+end_src

  2) effect 通过 ~new ReactiveEffect()~ 创建, 收集的依赖通过 ~_effect.run()~ 执行。
- [X] reactivity: ref-specific track/trigger and miscellaneous optimizations ([[https://github.com/vuejs/vue-next/issues/3995][#3995]]) ([[https://github.com/vuejs/vue-next/commit/64310405acaccabc24985ade95fb1b5c9c06ef76][6431040]])
- [X] reactivity: use bitwise dep markers to optimize re-tracking ([[https://github.com/vuejs/vue-next/issues/4017][#4017]]) ([[https://github.com/vuejs/vue-next/commit/6cf2377cd49d24814bdff136bf78c77d50d5b41a][6cf2377]])

  #+begin_src js
const url = process.env.VNEXT_PKG_RC +'/../reactivity/dist/reactivity.cjs.js'
const value = require(url.replace('stb-', ''))
const { reactive, effect, targetMap, toRaw } = value


console.log('> should handle deep effect recursion using cleanup fallback');
const results = reactive([0])
const effects = []
for (let i = 1; i < 40;i++) {
  ;(index => {
    const fx = effect(() => {
      results[index] = results[index - 1] * 2
    })
    effects.push({ fx, index })
  })(i)
}

// targetMap.forEach((key, value) => console.log({ key, value }))
// console.log(toRaw(results).join(','), targetMap.get(toRaw(results)), 'xx');
console.log(('results[39] = ' + results[39]));
const deps = targetMap.get(toRaw(results))
for (let i = 0; i < 40; i++) {
  const dep = deps.get('' + i)
  // dep && console.log(i + 1 + ": " + "n(newTracked): " + dep.n +', w(wasTracked): ' + dep.w);
}
results[0] = 1
console.log(('results[39] = 2^39, ' + (results[39] === Math.pow(2, 39))));

return 0
  #+end_src

  #+RESULTS:
  : > should handle deep effect recursion using cleanup fallback
  : results[39] = 0
  : results[39] = 2^39, true
  : 0
- [X] improve VNode creation performance with compiler hints ([[https://github.com/vuejs/vue-next/issues/3334][#3334]]) ([[https://github.com/vuejs/vue-next/commit/ceff89905b05381d3d73c480e08c7aff9271b074][ceff899]])

  区分 element 和 component 创建过程，新增两个针对性的函数，分别用来创建
  element(~createElementVNode~) 和 component(~createComponentVNode~)，减少部分检查的
  工作，总的来说优化创建 element 和 component 的过程。

  compiler-core:codegen 阶段 element 由 ~_createVNode~ 改成 ~_createElementVNode~,
  ~_createBlock~ 改成 ~_createElementBlock~

  增加的 helpers: ~CREATE_VNODE~ -> ~CREATE_ELEMENT_VNODE~

  #+begin_src typescript
export const CREATE_ELEMENT_BLOCK = Symbol(__DEV__ ? `createElementBlock` : ``)
export const CREATE_ELEMENT_VNODE = Symbol(__DEV__ ? `createElementVNode` : ``)
export const NORMALIZE_CLASS = Symbol(__DEV__ ? `normalizeClass` : ``)
export const NORMALIZE_STYLE = Symbol(__DEV__ ? `normalizeStyle` : ``)
export const NORMALIZE_PROPS = Symbol(__DEV__ ? `normalizeProps` : ``)
export const GUARD_REACTIVE_PROPS = Symbol(__DEV__ ? `guardReactiveProps` : ``)

// compiler-core/src/utils.ts
export function getVNodeHelper(ssr: boolean, isComponent: boolean) {
  return ssr || isComponent ? CREATE_VNODE : CREATE_ELEMENT_VNODE
}

export function getVNodeBlockHelper(ssr: boolean, isComponent: boolean) {
  return ssr || isComponent ? CREATE_BLOCK : CREATE_ELEMENT_BLOCK
}

// runtime-core/src/vnode.ts
export function guardReactiveProps(props: (Data & VNodeProps) | null) {
  if (!props) return null
  return isProxy(props) || InternalObjectKey in props
    ? extend({}, props)
    : props
}

// shared/src/normalizeProp.ts
export function normalizeProps(props: Record<string, any> | null) {
  if (!props) return null
  let { class: klass, style } = props
  if (klass && !isString(klass)) {
    props.class = normalizeClass(klass)
  }
  if (style) {
    props.style = normalizeStyle(style)
  }
  return props
}
  #+end_src

  测试：

  #+begin_src js
const url = process.env.VNEXT_PKG_RC +'/../compiler-core/dist/compiler-core.cjs.js'
const value = require(url.replace('stb-', ''))
const { generate, createSimpleExpression, locStub,
        createVNodeCall, createObjectExpression,
        createObjectProperty,
        createCompoundExpression,
        createArrayExpression
      } = value

function createRoot(options) {
  return {
    type: 0/* ROOT */,
    children: [],
    helpers: [],
    components: [],
    directives: [],
    imports: [],
    hoists: [],
    cached: 0,
    temps: 0,
    codegenNode: createSimpleExpression(`null`, false),
    loc: locStub,
    ...options
  }
}

function genCode(node) {
  return generate(
    createRoot({
      codegenNode: node
    })
  ).code.match(/with \(_ctx\) \{\s+([^]+)\s+\}\s+\}$/)[1]
}

const mockChildren = createCompoundExpression(['children'])
const mockDirs = createArrayExpression([
  createArrayExpression([`foo`, createSimpleExpression(`bar`, false)])
])

const mockProps = createObjectExpression([
  createObjectProperty(`foo`, createSimpleExpression(`bar`, true))
])

const test = (title, ...args) => console.log('> ' + title + '\n', "'" + genCode( createVNodeCall(...args) ) + "'")

test('tag only', null, '"div"')
test('with props', null, '"div"', mockProps)
test('with children, no props', null, '"div"', undefined, mockChildren)
test('with children + props', null, '"div"', mockProps, mockChildren)
test('as block', null, '"dv"', mockProps, mockChildren, undefined, undefined, undefined, true)
return 0
  #+end_src

  #+RESULTS:
  #+begin_example
  > tag only
   'return _createElementVNode("div")
   '
  > with props
   'return _createElementVNode("div", { foo: "bar" })
   '
  > with children, no props
   'return _createElementVNode("div", null, children)
   '
  > with children + props
   'return _createElementVNode("div", { foo: "bar" }, children)
   '
  > as block
   'return (_openBlock(), _createElementBlock("dv", { foo: "bar" }, children))
   '
  0
  #+end_example

** Breaking Changes [0/1]
- [-] Output of SFC using <style scoped> generated by 3.2+ will be incompatible
  w/ runtime < 3.2.

 
* Something todos

1. [[#custom-element-reflection][custom element reflection, casting and edge cases]] ([[https://github.com/vuejs/vue-next/commit/00f0b3c46552626cd7c5ec73ffd0a918c3e1a5fb][00f0b3c]])
