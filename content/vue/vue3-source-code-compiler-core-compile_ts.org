#+TITLE: Vue3.0 æºç ç³»åˆ—ï¼ˆäºŒï¼‰ç¼–è¯‘å™¨æ ¸å¿ƒ - Compiler core 3: compile.ts
#+DATE: <2020-08-31 22:11:55>
#+TAGS[]: vue, vue3, vuenext, compiler
#+CATEGORIES[]: vue
#+LANGUAGE: zh-cn
#+STARTUP: indent

#+begin_quote
è¯¥ç³»åˆ—æ–‡ç« ï¼Œå‡ä»¥æµ‹è¯•ç”¨ä¾‹é€šè¿‡ä¸ºåŸºå‡†ä¸€æ­¥æ­¥å®ç°ä¸€ä¸ª vue3 æºç å‰¯æœ¬(å­¦ä¹ )ã€‚
#+end_quote

@@html:<kbd>@@æ–‡å­—æ¯”è¾ƒé•¿ï¼Œå¦‚æœä¸æƒ³çœ‹æ–‡å­—å¯ç›´æ¥è½¬åˆ°[[/vue/vue-mind-map-house/][è¿™é‡Œ]]çœ‹è„‘å›¾@@html:</kbd>@@

@@html:<kbd>@@
*ç”±äº compile å’Œ transform å…³è”æ€§æ¯”è¾ƒå¼ºè¿™é‡Œå°†æ”¾åœ¨ä¸€èµ·å»å®Œæˆã€‚*
@@html:</kbd>@@ 

* å‡†å¤‡å·¥ä½œ
è¦å®Œæˆè¿™ä¸€éƒ¨åˆ†ï¼Œé¦–å…ˆè¦äº†è§£å®ƒçš„ä½œç”¨æ˜¯ä»€ä¹ˆï¼Ÿ

åœ¨ [[/vue/vue3-source-code-compiler-core-parse_ts/][parse.ts]] æ–‡ä¸­æˆ‘ä»¬å®Œæˆäº†è§£æå™¨çš„éƒ¨åˆ†ï¼Œä½œç”¨æ˜¯å°†æ¨¡æ¿è§£ææˆ AST å¯¹è±¡ã€‚

åœ¨è¿™é‡Œ compile.ts ä½œç”¨å°±æ˜¯å°†è¿™äº› AST å¦‚ä½•ç¿»è¯‘æˆ render å‡½æ•°ã€‚

ä¸ºäº†æ›´ç›´è§‚çš„ä½“éªŒ compile çš„ä½œç”¨ï¼Œåœ¨ vue æºç é‡Œé¢æœ‰ä¸€ä¸ªæ‰“åŒ…ä¹‹åçš„ç›®å½•ï¼š

*/vue-next/packages/vue/dist/vue.global.js*

ç„¶åæˆ‘ä»¬ä½¿ç”¨ç¬¬ä¸€ä¸ªæµ‹è¯•ç”¨ä¾‹çš„æ¨¡æ¿ï¼Œå»ç¼–è¯‘ä¸‹çœ‹çœ‹ç»“æœï¼š

#+begin_src js
  const source = `
  <div id="foo" :class="bar.baz">
    {{ world.burn() }}
    <div v-if="ok">yes</div>
    <template v-else>no</template>
    <div v-for="(value, index) in list"><span>{{ value + index }}</span></div>
  </div>
       `.trim(),
#+end_src

è¿›è¡Œç¼–è¯‘(å®Œæ•´ç¤ºä¾‹)ï¼š

#+begin_src html
  <script src="./vue.global.js"></script>
  <script>
    console.log(Vue, "00");
    const { compile } = Vue;
    const result = compile(
    `
    <div id="foo" :class="bar.baz">
      {{ world.burn() }}
      <div v-if="ok">yes</div>
      <template v-else>no</template>
      <div v-for="(value, index) in list"><span>{{ value + index }}</span></div>
    </div>
    `.trim(),
    { sourceMap: true, filename: "foo.vue" }
    );
    console.log(result, "xx");
  </script>
#+end_src

è¿è¡Œä¹‹å result ç»“æœï¼š

#+begin_src js
  (function anonymous() {
    const _Vue = Vue;
    const {
      createVNode: _createVNode,
      createCommentVNode: _createCommentVNode,
      createTextVNode: _createTextVNode,
    } = _Vue;

    const _hoisted_1 = { key: 0 };
    // è¿™é‡Œ v-if ... else é‡Œé¢çš„ <template>no</template> ï¼Ÿ
    // åˆ›å»ºæ–‡æœ¬è™šæ‹ŸèŠ‚ç‚¹ï¼Œè¿™é‡Œä¸ºä»€ä¹ˆç›´æ¥åœ¨ render å¤–å°±æ‰§è¡Œäº†ï¼Ÿï¼Ÿï¼Ÿ
    // åˆæ˜¯æ€ä¹ˆåšåˆ°çš„ï¼Ÿï¼Ÿï¼Ÿ
    const _hoisted_2 = _createTextVNode("no");

    // ç¥çº§å‡½æ•° >>> render
    return function render(_ctx, _cache) {
      with (_ctx) {
        const {
          toDisplayString: _toDisplayString,
          createVNode: _createVNode,
          openBlock: _openBlock,
          createBlock: _createBlock,
          createCommentVNode: _createCommentVNode,
          createTextVNode: _createTextVNode,
          Fragment: _Fragment,
          renderList: _renderList,
        } = _Vue;

        return (
          _openBlock(),
          _createBlock(
            "div",
            {
              // è§£æå‡ºæ¥çš„ div å±æ€§ï¼Œ id å’Œ class
              // parseAttribute çš„ç»“æœ
              id: "foo", // æ³¨æ„è¿™é‡Œæ˜¯å­—ç¬¦ä¸²
              class: bar.baz, // è¿™é‡Œæ˜¯å˜é‡å½¢å¼å­˜åœ¨ï¼Œå› ä¸ºç”¨åˆ°äº† :class å±äºæŒ‡ä»¤è§£æ
            },
            [
              // è¿™é‡Œæ˜¯å­©å­èŠ‚ç‚¹ä»¬
              // 1. ç¬¬ä¸€ä¸ªå­©å­èŠ‚ç‚¹ï¼Œæ’å€¼
              _createTextVNode(
                // æ’å€¼é‡Œé¢çš„å†…å®¹è°ƒç”¨è½¬æ¢æˆæ–‡æœ¬
                _toDisplayString(world.burn()) + " ",
                1 /* TEXT */
              ),
              // 2. ç¬¬äºŒä¸ªå­©å­èŠ‚ç‚¹ v-if...v-else
              // v-if æŒ‡ä»¤ï¼Œå‚æ•°æ˜¯ ok
              // ç„¶åè¿™é‡Œåˆæ˜¯æ€ä¹ˆåšåˆ° ok ? ... : ...
              // æŒ‡ä»¤è§£æçš„æ—¶å€™ v-if çš„å¤„ç†åˆæ˜¯æ€ä¹ˆåšçš„ï¼Œtransform/vIf ???
              // ç›¸é‚»çš„ä¸‹ä¸€ä¸ªèŠ‚ç‚¹æ£€æµ‹æ˜¯å¦æ˜¯ v-if æŒ‡ä»¤ç°‡ï¼Ÿï¼Ÿï¼Ÿ
              // åˆ°åº•çœŸç›¸å¦‚ä½• ???

              ok
              // åˆ›å»º div
                ? (_openBlock(), _createBlock("div", _hoisted_1, "yes"))
              // åˆ›å»º template
                : (_openBlock(),
                   _createBlock(
                     _Fragment,
                     { key: 1 },
                     // æå‰è¢«è§£æå‡ºæ¥çš„ template -> no æ–‡æœ¬èŠ‚ç‚¹
                     // éš¾é“æ˜¯æå‰éå†ï¼Ÿï¼Ÿï¼Ÿå°†æ‰€æœ‰çš„ template å¦‚æœæ˜¯
                     // é™æ€çš„å°±å…ˆå…¨éƒ¨åˆ›å»ºå‡ºæ¥ï¼Ÿï¼Ÿï¼Ÿ
                     [_hoisted_2],
                     64 /* STABLE_FRAGMENT */
                   )),
              // 3. ç¬¬ä¸‰ä¸ªå­©å­èŠ‚ç‚¹ï¼Œdiv v-for
              (_openBlock(true),
               _createBlock(
                 _Fragment,
                 null,
                 // æ¸²æŸ“åˆ—è¡¨
                 _renderList(list, (value, index) => {
                   return (
                     _openBlock(),
                     _createBlock("div", null, [
                       _createVNode(
                         "span",
                         null,
                         _toDisplayString(value + index),
                         1 /* TEXT */
                       ),
                     ])
                   );
                 }),
                 256 /* UNKEYED_FRAGMENT */
               )),
            ],
            2 /* CLASS */
          )
        );
      }
    };
  });
#+end_src

è¯¸å¤šçš„ç–‘é—®ç­‰ç€å»è§£ç­”ï¼ï¼ï¼

ä½†è‡³å°‘æœ‰ä¸€ç‚¹å¾ˆæ¸…æ™°çš„çŸ¥é“ï¼Œcompile å°±æ˜¯å°† AST ç¼–è¯‘æˆ render å‡½æ•°ç”¨çš„ã€‚

çŸ¥é“äº†æœ€ç»ˆç›®çš„ï¼Œæ¥ä¸‹æ¥å°±æ˜¯æ¼«é•¿çš„æ¢ç´¢ä¹‹è·¯äº† :running: :running: :running:

æ„é€ æ•°æ®ï¼Œè§‚å¯Ÿæœ€ç»ˆç”Ÿæˆçš„ VNode ç»“æ„(ä¸Šé¢ä»£ç æ‰§è¡Œä¹‹åç»“æœè¿”å›ç»™ resultï¼Œå…¶å®å°±
æ˜¯ render å‡½æ•°):

#+begin_src js
  result({
    list: [1,2,3],
    ok: true,
    bar: {
      baz: 'xx'
    },
    world: {
      burn() {}
    }
  })
#+end_src

ä¼ é€’ä¸€äº›å‚æ•°è°ƒç”¨ä¹‹åç»“æœï¼š

#+begin_example
  {_isVNode: true, type: "div", props: {â€¦}, key: null, ref: null, â€¦}
    anchor: null
    appContext: null
    // ä¸‰ä¸ªå­©å­èŠ‚ç‚¹
    children: Array(3)
      0: {_isVNode: true, type: Symbol(Text), props: null, key: null, ref: null, â€¦}
      1: {_isVNode: true, type: "div", props: {â€¦}, key: 0, ref: null, â€¦}
      2: {_isVNode: true, type: Symbol(Fragment), props: null, key: null, ref: null, â€¦}
      length: 3
    component: null
    dirs: null
    // ä¸‰ä¸ªåŠ¨æ€å­©å­èŠ‚ç‚¹
    dynamicChildren: Array(3)
      0: {_isVNode: true, type: Symbol(Text), props: null, key: null, ref: null, â€¦}
      1: {_isVNode: true, type: "div", props: {â€¦}, key: 0, ref: null, â€¦}
      2: {_isVNode: true, type: Symbol(Fragment), props: null, key: null, ref: null, â€¦}
      length: 3
    dynamicProps: null
    el: null
    key: null
    patchFlag: 2
    // å±æ€§
    props: {id: "foo", class: "xx"}
    ref: null
    scopeId: null
    shapeFlag: 17
    suspense: null
    target: null
    targetAnchor: null
    transition: null
    // æ ‡ç­¾
    type: "div"
    // æ ‡è¯†ä¸ºè™šæ‹ŸèŠ‚ç‚¹
    _isVNode: true
#+end_example

* compile.spec.ts
ç”±äº compile.spec.ts åŸæ¥åªæœ‰ä¸€ä¸ªç”¨ä¾‹ï¼Œç›¸å¯¹æ˜¯æ¯”è¾ƒå¤æ‚çš„ï¼Œä¸åˆ©äºå­¦ä¹ ã€‚

è¿™é‡Œå°†æ ¹æ® [[/vue/vue3-source-code-compiler-core-parse_ts/#parse.spec.ts][parse.spec.ts]] å¾ªåºæ¸è¿›çš„å»å®ç° compile + transform çš„åŠŸèƒ½ã€‚

ä¸‹é¢æ‰€æœ‰çš„æµ‹è¯•ç”¨ä¾‹å‡ä»¥ vue.global.js æ‰“åŒ…ä¹‹åçš„æ–‡ä»¶ï¼Œè¿è¡Œç»“æœä¸ºå‰æï¼š

#+begin_src js
  const test = `simple text`;

  const result = compile(test.trim(), {
    sourceMap: true,
    filename: "foo.vue",
  });
  console.log(result, "xx");
#+end_src

é€šè¿‡ä¿®æ”¹ test å€¼æ¥å¾—åˆ°çœŸå®çš„ render å‡½æ•°ã€‚

*** 01-simple text
:PROPERTIES:
:COLUMNS: %CUSTOM_ID[(Custom Id)]
:CUSTOM_ID: test-text-01
:END: 

compiledï¼š
#+begin_src js
  (function anonymous(
  ) {

    return function render(_ctx, _cache) {
      with (_ctx) {
        return "simple text"
      }
    }
  })
#+end_src

ä¹Ÿå°±æ˜¯è¯´ *"simple text"* æœ€åè½¬å˜æˆçš„ render å‡½æ•°å¦‚ä¸Šæ‰€ç¤ºã€‚

æˆ‘ä»¬çš„ç¬¬ä¸€æ­¥å°±æ˜¯å¦‚ä½•æ¥å®ç° compile å’Œ transform èƒ½å¾—åˆ°è¿™æ ·çš„ç»“æœï¼Œè¿™å°†æ˜¯è¯¥æ¨¡å—å®Œ
æˆç¬¬ä¸€æ­¥ ğŸ†™ ğŸ†™ ğŸ†™ ğŸ†™ ğŸ†™ ğŸ†™ ğŸ†™ ğŸ†™ ğŸ†™ ğŸ†™

parse ä¹‹åçš„ ast:
#+begin_src js
  {type: 0, children: Array(1), loc: {â€¦}, helpers: Array(0), components: Array(0), â€¦}
    cached: 0
    children: Array(1)
      0:
      content: "simple text"
      loc: {start: {â€¦}, end: {â€¦}, source: "simple text"}
      type: 2
    length: 1
    codegenNode: undefined
    components: []
    directives: []
    helpers: []
    hoists: []
    imports: []
    loc: {start: {â€¦}, end: {â€¦}, source: "simple text"}
    temps: 0
    type: 0
#+end_src


åœ¨å®Œæˆ [[#transform-transformtext][transformText]] ä¹‹åï¼Œå‘ç° result.code æ˜¯ç©ºçš„ï¼Œè¿˜ä»¥ä¸ºæ˜¯è¿™é‡Œé¢å®ç°é—®é¢˜çš„ï¼Œå…¶
å®æ˜¯ [[#codegen-generate][generate]] å‡½æ•°è¿˜æ²¡å®ç°çš„åŸå› ã€‚

* å‡½æ•°åˆ—è¡¨
** compile.ts
*** baseCompile(template, options)
:PROPERTIES:
:COLUMNS:  %CUSTOM_ID[(Custom Id)]
:CUSTOM_ID: compile-basecompile
:END:

å°† template è§£ææˆ render å‡½æ•°ï¼Œé‡ç‚¹æ­¥éª¤:

1. [[vue/vue3-source-code-compiler-core-parse_ts/][baseParse(template, options)]] å°†å­—ç¬¦ä¸²æ¨¡æ¿è§£ææˆ AST å¯¹è±¡ã€‚
2. [[#transform-transform][transform(ast, ...)]] å°† AST è¿›ä¸€æ­¥è½¬æ¢å¤„ç†
3. å°†è½¬æ¢åçš„ ast è°ƒç”¨ codegen çš„ generate æ–¹æ³•ç”Ÿæˆ render ã€‚

#+begin_src js
  export function baseCompile(template, options) {
    const isModuleMode = options.mode === "module";

    // ... ç•¥å»é”™è¯¯âå¤„ç†
    const prefixIdentifiers =
      !__BROWSER__ && (options.prefixIdentifiers === true || isModuleMode);

    // 1. baseParse å¾—åˆ° AST å¯¹è±¡ï¼Œä¸¤ç§æƒ…å†µï¼š1. æœªè§£æçš„æ¨¡æ¿ï¼Œ2. ä»¥è§£æä¹‹åçš„ ast å¯¹è±¡
    const ast =
      typeof template === "string" ? baseParse(template, options) : template;

    // 2. å–å‡ºæ‰€æœ‰ node å’Œ directive çš„ transforms
    const [nodeTransforms, directiveTransforms] = getBaseTransformPreset(
      prefixIdentifiers
    );

    // 3. è¿›è¡Œè½¬æ¢ï¼Œè°ƒç”¨ transform
    transform(ast, {
      // åˆå¹¶é€‰é¡¹
      ...options, // è°ƒç”¨ baseCompile æ—¶å€™çš„ç¬¬äºŒä¸ªå‚æ•°
      prefixIdentifiers, // è¿˜ä¸çŸ¥é“æ˜¯å¹²å•¥çš„???
      // èŠ‚ç‚¹è½¬æ¢å™¨åˆå¹¶ï¼Œå¤–éƒ¨è½¬æ¢å™¨ä¼˜å…ˆï¼Œå³ä½¿ç”¨è€…å¯è‡ªå®šä¹‰è‡ªå·±çš„è½¬æ¢å™¨
      nodeTransforms: [...nodeTransforms, ...(options.nodeTransforms || {})],
      // æŒ‡ä»¤è½¬æ¢å™¨ï¼ŒåŒä¸Šã€‚
      directiveTransforms: [
        ...directiveTransforms,
        ...(options.directiveTransforms || {}),
      ],
    });

    // 4. è°ƒç”¨ generate ç”Ÿæˆ render å‡½æ•°çš„ codegen å¹¶è¿”å›ï¼Œè¿™å°±æ˜¯æˆ‘ä»¬éœ€è¦çš„ç»„ä»¶æ¸²
    // æŸ“å‡½æ•°
    return generate(ast, {
      ...options,
      prefixIdentifiers,
    });
  }
#+end_src

è¿™ä¹Ÿæ˜¯é™¤äº†é”™è¯¯å¤„ç†ä¹‹åçš„å®Œæ•´çš„ baseCompile å‡½æ•°å®ç°ã€‚
*** getBaseTransformPreset(prefixIdentifiers: boolean)
:PROPERTIES:
:COLUMNS: %CUSTOM_ID[(Custom Id)]
:CUSTOM_ID: compile_getbasetransformpreset
:END: 

åˆå¹¶æ‰€æœ‰ transformï¼Œè¿”å›ä¸€ä¸ª ~TransformPreset~ ç±»å‹çš„æ•°ç»„

stage-1: ç¬¬ä¸€é˜¶æ®µæˆ‘ä»¬åªéœ€è¦æ–‡æœ¬è½¬æ¢ï¼Œé€šè¿‡ [[#test-text-01][ç”¨ä¾‹ä¸€]] å³å¯ï¼Œæ‰€ä»¥è¿™é‡Œå°±åªä¿ç•™
[[transform-transformtext][transformText]] å°±å¯ä»¥äº†ï¼Œå‰©ä¸‹çš„å°±æ˜¯å»å®ç°å®ƒã€‚
#+begin_src js
  export function getBaseTransformPreset(prefixIdentifiers) {
    return [
      [
        // ... çœç•¥å…¶ä»–ï¼Œç¬¬ä¸€é˜¶æ®µæˆ‘ä»¬åº”è¯¥åªéœ€è¦æ–‡æœ¬è½¬æ¢
        transformText,
      ],
      {
        // ...çœç•¥æŒ‡ä»¤
      },
    ];
  }
#+end_src

** tranform.ts
*** transformText(node, context)
:PROPERTIES:
:COLUMNS: %CUSTOM_ID[(Custom Id)]
:CUSTOM_ID: transform-transformtext
:END: 

è¯¥å‡½æ•°ä¼šè¿”å›ä¸€ä¸ªç”¨æ¥è½¬æ¢æ–‡æœ¬èŠ‚ç‚¹ç±»å‹(~NodeTransform~)çš„å‡½æ•°ã€‚

è¿”å›å‡½æ•°åˆ†æ(~return () => { ... }~)ï¼Œä¸»è¦ç”±ä¸‰ä¸ª for æ„æˆï¼š

1. ç¬¬ä¸€ä¸ª for åµŒå¥—ç¬¬äºŒä¸ª for æ„æˆåŒé‡å¾ªç¯ï¼Œç”¨æ¥åˆå¹¶ node.children é‡Œé¢ç›¸é‚»çš„æ–‡æœ¬
   èŠ‚ç‚¹
   
   ç¬¬ä¸€ä¸ª For é‡Œé¢ä½¿ç”¨çš„æ˜¯ children.length åŠ¨æ€è·å–å½“å‰æ•°ç»„çš„é•¿åº¦ï¼Œç»“åˆä»£ç ä¸­çš„
   splice å’Œ j--ã€‚ä»è€Œå®Œæˆåˆå¹¶æ“ä½œã€‚
   
   #+begin_src js
     // 1. åŸæ¥çš„ child è¢«é‡å†™
     // 2. child, ` + `, next åˆå¹¶åˆ°äº†æ–° child.children é‡Œé¢
     currentContainer.children.push(` + `, next);
     // åˆ é™¤è¢«åˆå¹¶çš„æ–‡æœ¬èŠ‚ç‚¹
     children.splice(j, 1);
     j--; // -1 æ˜¯å› ä¸ºä¸Šé¢åˆ é™¤äº†å½“å‰å…ƒç´ ï¼Œfor å¾ªç¯è¿‡ç¨‹ä¸­é•¿åº¦æ˜¯åŠ¨æ€è·å–çš„
   #+end_src
   
2. ç¬¬ä¸‰ä¸ª for éå†ç¬¬ä¸€æ­¥ä¹‹åçš„ childrenï¼Œå¯¹æ¯ä¸ª child è¿›è¡Œé‡å®šä¹‰ï¼Œç±»å‹æ”¹å˜æˆ
   ~NodeTyeps.TEXT_CALL~ ç±»å‹ï¼Œå¢åŠ  codegenNode å±æ€§ã€‚
   

ä»£ç å®Œæ•´ç‰ˆï¼š
#+begin_src js

  export const transformText = (node, context) => {
    // æ–‡æœ¬è½¬æ¢åªèƒ½æ˜¯ä¸‹é¢å››ç§ç±»å‹
    const validTypes = [
      NodeTypes.ROOT,
      NodeTypes.ELEMENT,
      NodeTypes.FOR,
      NodeTypes.IF_BRANCH,
    ];

    // åˆæ³•ç±»å‹æ£€æµ‹
    if (validTypes.indexOf(node.type)) {
      // è¿”å›ä¸€ä¸ªå¯æ‰§è¡Œå‡½æ•°ï¼Œè®°å¾—åœ¨ transformNode å—ï¼Œè¿™ä¸ªè¿”å›çš„å‡½æ•°
      // å°†ä¼šè¢«å®ƒåœ¨ while ä¸­ æ‰§è¡Œ æ‰ã€‚
      return () => {
        const children = node.children;

        let currentContainer = undefined;
        let hasText = false;

        // åŒé‡å¾ªç¯ï¼Œåˆå¹¶æ‰€æœ‰ç›¸é‚»çš„æ–‡æœ¬èŠ‚ç‚¹
        // å¦‚ï¼š[text1, text2, element, text3, ele, text4, text5]
        // text1 å’Œ text2 ä¼šåˆå¹¶åˆ°text1
        // text3 ä¸ä¼šåˆå¹¶
        // text4 å’Œ text5 ä¼šè¢«åˆå¹¶
        for (let i = 0; i < children.length; i++) {
          const child = children[i];

          if (isText(child)) {
            // TODO æ–‡æœ¬èŠ‚ç‚¹æ‰è¿›è¡Œè§£æ
            hasText = true;
            // åˆå¹¶ç›¸é‚»çš„æ–‡æœ¬èŠ‚ç‚¹ï¼Œ text1 + text2
            for (let j = i + 1; j < children.length; j++) {
              const next = children[j];
              // ä¸‹ä¸€ä¸ªä¹Ÿæ˜¯æ–‡æœ¬èŠ‚ç‚¹çš„æ—¶å€™ï¼Œè¦å°†ä¸¤è€…åˆå¹¶
              if (isText(next)) {
                if (!currentContainer) {
                  // è¿™é‡Œç­‰äºé‡å†™äº† child çš„å¼•ç”¨ï¼Œå°†è‡ªèº« push åˆ°äº†
                  // æ–°ç»“æ„ä¸­çš„ children
                  currentContainer = children[i] = {
                    type: NodeTypes.COMPOUND_EXPRESSION,
                    loc: child.loc,
                    children: [child],
                  };
                }

                // 1. åŸæ¥çš„ child è¢«é‡å†™
                // 2. child, ` + `, next åˆå¹¶åˆ°äº†æ–° child.children é‡Œé¢
                currentContainer.children.push(` + `, next);
                // åˆ é™¤è¢«åˆå¹¶çš„æ–‡æœ¬èŠ‚ç‚¹
                children.splice(j, 1);
                j--; // -1 æ˜¯å› ä¸ºä¸Šé¢åˆ é™¤äº†å½“å‰å…ƒç´ ï¼Œfor å¾ªç¯è¿‡ç¨‹ä¸­é•¿åº¦æ˜¯åŠ¨æ€è·å–çš„
              } else {
                currentContainer = undefined;
                break;
              }
            }
          }
        }

        // é›†ä¸­ä¸æ»¡è¶³è½¬æ¢æ¡ä»¶çš„æƒ…å†µ
        if (
          // 1. æ²¡æœ‰æ–‡æœ¬å†…å®¹
          // 2. åªæœ‰ä¸€ä¸ªå­©å­èŠ‚ç‚¹
          //   2.1 ç»„ä»¶æ ¹èŠ‚ç‚¹
          //   2.2 <element> å…ƒç´ èŠ‚ç‚¹
          !hasText ||
          (children.length === 1 &&
            (node.type === NodeTypes.ROOT ||
              (node.type === NodeTypes.ELEMENT &&
                node.tagType === ElementTypes.ELEMENT)))
        ) {
          return;
        }

        // å¼€å§‹è½¬æ¢
        for (let i = 0; i < children.length; i++) {
          const chld = children[i];
          if (isText(child) || child.type === NodeTypes.COMPOUND_EXPRESSION) {
            const callArgs = [];

            // éæ–‡æœ¬èŠ‚ç‚¹ï¼Œç›´æ¥ push æ‰ï¼Œè¿™é‡Œ child.content !== ' ' çš„åŸå› åœ¨äº
            // parseChildren é‡Œé¢ while å¾ªç¯æœ€åæœ‰ä¸ªremove whitespace æ“ä½œ
            // ä¼šå°†æœ‰æ•ˆçš„ç©ºèŠ‚ç‚¹è½¬æˆä¸€ä¸ªç©ºæ ¼çš„å­—ç¬¦ä¸²ã€‚
            // createTextVNode é»˜è®¤æ˜¯ä¸€ä¸ªå•ç©ºæ ¼
            if (child.type !== NodeTypes.TEXT || child.content !== " ") {
              callArgs.push(child);
            }

            // éæœåŠ¡ç«¯æ¸²æŸ“ï¼Œä¸”éæ–‡æœ¬èŠ‚ç‚¹
            if (!context.ssr && child.type !== NodeTypes.TEXT) {
              callArgs.push(
                // TODO è¿™ä¸ªæ˜¯å¹²å˜›çš„ï¼Ÿï¼Ÿï¼Ÿ
                `${PatchFlags.TEXT} /* ${PatchFlagNames[PatchFlags.TEXT]} */`
              );
            }

            children[i] = {
              type: NodeTypes.TEXT_CALL, // æ–‡æœ¬å‡½æ•°
              content: child,
              loc: child.loc,
              codegenNode: createCallExpression(
                context.helper(CREATE_TEXT),
                callArgs
              ),
            };
          }
        }
      };
    }
  }
#+end_src

ä½¿ç”¨åˆ°çš„å¤–é¢å‡½æ•°å’Œå±æ€§ï¼š

1. CREATE_TEXTï¼š ä¸€ä¸ªç¬¦å·å±æ€§ ~export const CREATE_TEXT = Symbol(__DEV__ ? `createTextVNode` : ``);~
2. [[#ast_createcallexpression][createCallExpression(callee, args, loc)]] è¿”å› JS_CALL_EXPRESSION ç±»å‹å¯¹è±¡ã€‚
3. PatchFlags å’Œ PatchFlagNames ä¸€ä¸ªåå­—æ˜ å°„
4. isText æ–‡æœ¬èŠ‚ç‚¹ç±»å‹(æ’å€¼å’Œ text)

   #+begin_src js
     export function isText(node) {
       // æ’å€¼æˆ– text å‡è§†ä¸ºæ–‡æœ¬
       return node.type === NodeTypes.INTERPOLATION || node.type === NodeTypes.TEXT;
     }
   #+end_src

   
*å¯¹åº”çš„è™šæ‹ŸèŠ‚ç‚¹åˆ›å»ºå‡½æ•°ï¼š createTextVNode*
*** transform(root, options)
:PROPERTIES:
:COLUMNS: %CUSTOM_ID[(Custom Id)]
:CUSTOM_ID: transform-transform
:END: 

è°ƒç”¨çš„å‡½æ•°ï¼š
1. [[#transform_createtransformcontext][createTransformContext(root, options)]] åˆ›å»º transform è½¬æ¢å™¨ç±»å‹çš„ä¸Šä¸‹æ–‡å¯¹è±¡
2. [[#transform-traversenode][traverseNode(root, context)]] éå†æ‰€æœ‰èŠ‚ç‚¹
3. ssr æœåŠ¡ç«¯æ¸²æŸ“å¤„ç†
4. åˆå§‹åŒ– root æ ¹èŠ‚ç‚¹ä¸Šçš„ä¸€äº›å±æ€§

stage-1: [[#test-text-01][01 simple text]]
#+begin_src js

  export function transform(root, options) {
    const context = createTransformContext(root, options);

    traverseNode(root, context);

    if (options.hoistStatic) {
      hoistStatic(root, context);
    }

    // ... ssr å¤„ç†

    // root å±æ€§åˆå¹¶ï¼Œåˆå§‹åŒ–
    root.helpers = [...context.helpers];
    root.components = [...context.components];
    root.directives = [...context.directives];
    root.imports = [...context.imports];
    root.hoists = context.hoists;
    root.temps = context.temps;
    root.cached = context.cached;
  }
#+end_src
*** createTransformContext(root, options)
:PROPERTIES:
:COLUMNS: %CUSTOM_ID[(Custom Id)]
:CUSTOM_ID: transform-createtransformcontext
:END: 

å•çº¯çš„æ„å»ºå’Œåˆå§‹åŒ– transform è½¬æ¢å™¨ä¸Šä¸‹æ–‡å¯¹è±¡ã€‚

#+begin_src js
  export function createTransformContext(
    root,
    {
      prefixIdentifiers = false,
      hoistStatic = false,
      cacheHandlers = false,
      nodeTransforms = [],
      directiveTransforms = {},
      transformHoist = null,
      isBuiltInComponent = NOOP,
      expressionPlugins = [],
      scopeId = null,
      ssr = false,
      onError = defaultOnError,
    }
  ) {
    const context = {
      // options
      prefixIdentifiers,
      hoistStatic,
      cacheHandlers,
      nodeTransforms,
      directiveTransforms,
      transformHoist,
      isBuiltInComponent,
      expressionPlugins,
      scopeId,
      ssr,
      onError,

      // state
      root,
      helpers: new Set(),
      components: new Set(),
      directives: new Set(),
      hoists: [],
      imports: new Set(),
      temps: 0,
      cached: 0,
      identifiers: {},
      scopes: {
        vFor: 0,
        vSlot: 0,
        vPre: 0,
        vOnce: 0,
      },
      parent: null,
      currentNode: root,
      childIndex: 0,

      // methods
      helper(name) {},
      helperString(name) {},
      replaceNode(node) {},
      removeNode(node) {},
      onNodeRemoved: () => {},
      addIdentifiers(exp) {},
      removeIdentifiers(exp) {},
      hoist(exp) {},
      cache(exp, isVNode = false) {},
    };

    function addId(id) {}

    function removeId(id) {}

    return context;
  }
#+end_src
*** traverseNode(node, context)
:PROPERTIES:
:COLUMNS: %CUSTOM_ID[(Custom Id)]
:CUSTOM_ID: transform-traversenode
:END: 

stage-1: [[#test-text-01][01 simple text]] çœç•¥ switch é‡Œé¢çš„ä¸Šçº¿ï¼Œå› ä¸ºè¿™é‡Œåªæ˜¯çº¯æ–‡æœ¬ä¸å† case èŒƒå›´ã€‚
#+begin_src js

  export function traverseNode(node, context) {
    context.currentNode = node;

    const { nodeTransforms } = context;

    for (let i = 0; i < nodeTransforms.length; i++) {
      // è°ƒç”¨è¯¸å¦‚  transformText çš„å‡½æ•°
      const onExit = nodeTransforms[i](node, context);
      if (onExit) {
        const fns = Array.isArray(onExit) ? onExit : [onExit];
        exitFns.push(...fns);
      }

      if (!context.currentNode) {
        // å¯èƒ½è¢«ç§»é™¤äº†
        return;
      } else {
        // èŠ‚ç‚¹å¯èƒ½è¢«æ›¿æ¢è¿‡ï¼Œé‡æ–°å»ºç«‹å¼•ç”¨
        node = context.currentNode;
      }
    }

    // ... çœç•¥ switch

    let i = exitFns.length;
    // æ‰§è¡Œæ‰€æœ‰è½¬æ¢
    while (--i) {
      exitFns[i]();
    }
  }
#+end_src
** codegen.ts
*** generate()
:PROPERTIES:
:COLUMNS: %CUSTOM_ID[(Custom Id)]
:CUSTOM_ID: codegen_generate
:END: 

generate å‡½æ•°é›å½¢ï¼š

#+begin_src js
  export function generate(ast, options) {
    return {
      ast,
      code: "",
      map: "",
    };
  }

#+end_src

å‡½æ•°çš„ç›®çš„æ˜¯ï¼šé€šè¿‡ ast æ¥ç”Ÿæˆ codeï¼Œè¿™ä¸ª code å°†æ¥ä¼šè¢« compileToFunction è°ƒç”¨ ~new
Function(code)~ ç”Ÿæˆ render å‡½æ•°çš„ã€‚
** è™šæ‹ŸèŠ‚ç‚¹åˆ›å»ºå‡½æ•°

| name              | transform     | desc             |
|-------------------+---------------+------------------|
| ~createTextVNode~ | [[#transform-transformtext][transformText]] | åˆ›å»ºæ–‡æœ¬è™šæ‹ŸèŠ‚ç‚¹ |
|                   |               |                  |

* é—®é¢˜åˆ—è¡¨

1. compile.js:37 Uncaught TypeError: object is not iterable (cannot read
   property Symbol(Symbol.iterator))

   åŸå› æ˜¯ï¼šåœ¨æ•°ç»„é‡Œé¢ä½¿ç”¨å±•å¼€ç¬¦çš„æ—¶å€™ [], {} æ··ç”¨äº†

   #+begin_src js
     transform(ast, {
       // åˆå¹¶é€‰é¡¹
       ...options, // è°ƒç”¨ baseCompile æ—¶å€™çš„ç¬¬äºŒä¸ªå‚æ•°
       prefixIdentifiers, // è¿˜ä¸çŸ¥é“æ˜¯å¹²å•¥çš„???
       // èŠ‚ç‚¹è½¬æ¢å™¨åˆå¹¶ï¼Œå¤–éƒ¨è½¬æ¢å™¨ä¼˜å…ˆï¼Œå³ä½¿ç”¨è€…å¯è‡ªå®šä¹‰è‡ªå·±çš„è½¬æ¢å™¨
       // nodeTransforms: [...nodeTransforms, ...(options.nodeTransforms || {})], // FIX: è¿™é‡Œç”¨æ³•æœ‰é—®é¢˜ä¿®æ”¹å‰
       nodeTransforms: [...nodeTransforms, ...(options.nodeTransforms || [])], // FIX: ä¿®æ”¹å
       // æŒ‡ä»¤è½¬æ¢å™¨ï¼ŒåŒä¸Šã€‚
       directiveTransforms: {
         ...directiveTransforms,
         ...(options.directiveTransforms || {}),
       },
     });

   #+end_src
