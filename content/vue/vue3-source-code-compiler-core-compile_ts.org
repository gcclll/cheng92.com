#+TITLE: Vue3.0 源码系列（二）编译器核心 - Compiler core 3: compile.ts
#+DATE: <2020-08-31 22:11:55>
#+TAGS[]: vue, vue3, vuenext, compiler
#+CATEGORIES[]: vue
#+LANGUAGE: zh-cn
#+STARTUP: indent

#+begin_quote
该系列文章，均以测试用例通过为基准一步步实现一个 vue3 源码副本(学习)。
#+end_quote

@@html:<kbd>@@文字比较长，如果不想看文字可直接转到[[/vue/vue-mind-map-house/][这里]]看脑图@@html:</kbd>@@

@@html:<kbd>@@
*由于 compile 和 transform 关联性比较强这里将放在一起去完成。*
@@html:</kbd>@@

* 准备工作
要完成这一部分，首先要了解它的作用是什么？

在 [[/vue/vue3-source-code-compiler-core-parse_ts/][parse.ts]] 文中我们完成了解析器的部分，作用是将模板解析成 AST 对象。

在这里 compile.ts 作用就是将这些 AST 如何翻译成 render 函数。

为了更直观的体验 compile 的作用，在 vue 源码里面有一个打包之后的目录：

*/vue-next/packages/vue/dist/vue.global.js*

然后我们使用第一个测试用例的模板，去编译下看看结果：

#+begin_src js
  const source = `
  <div id="foo" :class="bar.baz">
    {{ world.burn() }}
    <div v-if="ok">yes</div>
    <template v-else>no</template>
    <div v-for="(value, index) in list"><span>{{ value + index }}</span></div>
  </div>
       `.trim(),
#+end_src

进行编译(完整示例)：

#+begin_src html
  <script src="./vue.global.js"></script>
  <script>
    console.log(Vue, "00");
    const { compile } = Vue;
    const result = compile(
    `
    <div id="foo" :class="bar.baz">
      {{ world.burn() }}
      <div v-if="ok">yes</div>
      <template v-else>no</template>
      <div v-for="(value, index) in list"><span>{{ value + index }}</span></div>
    </div>
    `.trim(),
    { sourceMap: true, filename: "foo.vue" }
    );
    console.log(result, "xx");
  </script>
#+end_src

运行之后 result 结果：

#+begin_src js
  (function anonymous() {
    const _Vue = Vue;
    const {
      createVNode: _createVNode,
      createCommentVNode: _createCommentVNode,
      createTextVNode: _createTextVNode,
    } = _Vue;

    const _hoisted_1 = { key: 0 };
    // 这里 v-if ... else 里面的 <template>no</template> ？
    // 创建文本虚拟节点，这里为什么直接在 render 外就执行了？？？
    // 又是怎么做到的？？？
    const _hoisted_2 = _createTextVNode("no");

    // 神级函数 >>> render
    return function render(_ctx, _cache) {
      with (_ctx) {
        const {
          toDisplayString: _toDisplayString,
          createVNode: _createVNode,
          openBlock: _openBlock,
          createBlock: _createBlock,
          createCommentVNode: _createCommentVNode,
          createTextVNode: _createTextVNode,
          Fragment: _Fragment,
          renderList: _renderList,
        } = _Vue;

        return (
          _openBlock(),
          _createBlock(
            "div",
            {
              // 解析出来的 div 属性， id 和 class
              // parseAttribute 的结果
              id: "foo", // 注意这里是字符串
              class: bar.baz, // 这里是变量形式存在，因为用到了 :class 属于指令解析
            },
            [
              // 这里是孩子节点们
              // 1. 第一个孩子节点，插值
              _createTextVNode(
                // 插值里面的内容调用转换成文本
                _toDisplayString(world.burn()) + " ",
                1 /* TEXT */
              ),
              // 2. 第二个孩子节点 v-if...v-else
              // v-if 指令，参数是 ok
              // 然后这里又是怎么做到 ok ? ... : ...
              // 指令解析的时候 v-if 的处理又是怎么做的，transform/vIf ???
              // 相邻的下一个节点检测是否是 v-if 指令簇？？？
              // 到底真相如何 ???

              ok
              // 创建 div
                ? (_openBlock(), _createBlock("div", _hoisted_1, "yes"))
              // 创建 template
                : (_openBlock(),
                   _createBlock(
                     _Fragment,
                     { key: 1 },
                     // 提前被解析出来的 template -> no 文本节点
                     // 难道是提前遍历？？？将所有的 template 如果是
                     // 静态的就先全部创建出来？？？
                     [_hoisted_2],
                     64 /* STABLE_FRAGMENT */
                   )),
              // 3. 第三个孩子节点，div v-for
              (_openBlock(true),
               _createBlock(
                 _Fragment,
                 null,
                 // 渲染列表
                 _renderList(list, (value, index) => {
                   return (
                     _openBlock(),
                     _createBlock("div", null, [
                       _createVNode(
                         "span",
                         null,
                         _toDisplayString(value + index),
                         1 /* TEXT */
                       ),
                     ])
                   );
                 }),
                 256 /* UNKEYED_FRAGMENT */
               )),
            ],
            2 /* CLASS */
          )
        );
      }
    };
  });
#+end_src

诸多的疑问等着去解答！！！

但至少有一点很清晰的知道，compile 就是将 AST 编译成 render 函数用的。

知道了最终目的，接下来就是漫长的探索之路了 :running: :running: :running:

构造数据，观察最终生成的 VNode 结构(上面代码执行之后结果返回给 result，其实就
是 render 函数):

#+begin_src js
  result({
    list: [1,2,3],
    ok: true,
    bar: {
      baz: 'xx'
    },
    world: {
      burn() {}
    }
  })
#+end_src

传递一些参数调用之后结果：

#+begin_example
  {_isVNode: true, type: "div", props: {…}, key: null, ref: null, …}
    anchor: null
    appContext: null
    // 三个孩子节点
    children: Array(3)
      0: {_isVNode: true, type: Symbol(Text), props: null, key: null, ref: null, …}
      1: {_isVNode: true, type: "div", props: {…}, key: 0, ref: null, …}
      2: {_isVNode: true, type: Symbol(Fragment), props: null, key: null, ref: null, …}
      length: 3
    component: null
    dirs: null
    // 三个动态孩子节点
    dynamicChildren: Array(3)
      0: {_isVNode: true, type: Symbol(Text), props: null, key: null, ref: null, …}
      1: {_isVNode: true, type: "div", props: {…}, key: 0, ref: null, …}
      2: {_isVNode: true, type: Symbol(Fragment), props: null, key: null, ref: null, …}
      length: 3
    dynamicProps: null
    el: null
    key: null
    patchFlag: 2
    // 属性
    props: {id: "foo", class: "xx"}
    ref: null
    scopeId: null
    shapeFlag: 17
    suspense: null
    target: null
    targetAnchor: null
    transition: null
    // 标签
    type: "div"
    // 标识为虚拟节点
    _isVNode: true
#+end_example

* compile.spec.ts
由于 compile.spec.ts 原来只有一个用例，相对是比较复杂的，不利于学习。

这里将根据 [[/vue/vue3-source-code-compiler-core-parse_ts/#parse.spec.ts][parse.spec.ts]] 循序渐进的去实现 compile + transform 的功能。

下面所有的测试用例均以 vue.global.js 打包之后的文件，运行结果为前提：

#+begin_src js
  const test = `simple text`;

  const result = compile(test.trim(), {
    sourceMap: true,
    filename: "foo.vue",
  });
  console.log(result, "xx");
#+end_src

通过修改 test 值来得到真实的 render 函数。

完成了 01-simple text 用例之后发现按照 parse.spec.ts 可能不太理想，毕竟 parse 部
分的用例有点多，如果按照那个来这部分也将会很漫长，思考良久应该还是按照
compile.spec.ts 中的用例进行拆分之后右简入难式去通过该用例。

完整用例：

#+begin_src js
  const source = `
  <div id="foo" :class="bar.baz">
    {{ world.burn() }}
    <div v-if="ok">yes</div>
    <template v-else>no</template>
    <div v-for="(value, index) in list"><span>{{ value + index }}</span></div>
  </div>
  `.trim()
#+end_src

** 02-pure interpolation 第一个孩子节点
:PROPERTIES:
:COLUMNS:  %CUSTOM_ID[(Custom Id)]
:CUSTOM_ID: test-02-worldburn
:END:

~{{ world.burn() }}~

测试：
#+begin_src js
  const test01 = `{{ world.burn() }}`;

  const result = compile(test01.trim(), {
    sourceMap: true,
    filename: "foo.vue",
  });
  console.log(result, "xx");
#+end_src

vue.global 结果：
#+begin_src js
  ƒ render(_ctx, _cache) {
    with (_ctx) {
      const { toDisplayString: _toDisplayString } = _Vue

      return _toDisplayString(world.burn())
    }
  }
#+end_src

[[#test-text-01][01-simple text]] 阶段代码返回的结果:

#+begin_src js
  ƒ render(_ctx, _cache) {
    with (_ctx) {
      return  // 这里没任何东西
    }
  }
#+end_src

通过[[#test-text-01][用例 01]] 大概的完成了一个比较完整的编译过程，要通过该用例应该只需要在这过程中增
加对插值的处理即可。

处理步骤(通过用例 01 总结出的步骤)：

[[#compile-basecompile][baseCompile]] -> [[/vue/vue3-source-code-compiler-core-parse_ts/#parse-baseparse][baseParse]] -> [[#compile-getbasetransformpreset][getBaseTransformPreset]] 得到 transform 函数 ->
[[#transform-transform][transform]] -> [[#codegen-generate][generate]]

1. [[/vue/vue3-source-code-compiler-core-parse_ts/#parse-baseparse][baseParse]] -> ast
2. [[#compile-getbasetransformpreset][getBaseTransformPreset]] -> 这里并没有什么 transformInterpolation，插值并没有
   对应的 transform 函数，而是直接在 generate 中结合 ~ast.helpers~ 处理。
3. [[#transform-transform][transform]] -> [[#transform-createtransformcontext][createTransformContext]] -> [[#transform-traversenode][traverseNode]] -> [[#transform-createrootcodegen][createRootCodegen]] -> ...

   这一步需要处理的应该只有 [[#transform-traversenode][traverseNode]] 需要修改，在 switch 里增加
   INTERPOLATION 分支，因为 [[#codegen-createrootcodegen][createRootCodegen]] 里面 root 如果只有一个孩子的情况
   下会和[[#test-text-01][用例 01]] 一样直接赋值 ~context.codegenNode = root.children[0]~

4. [[#codegen-generate][generate]] -> [[#codegen-createcodegencontext][createCodegenContext]] -> [[#codegen-genfunctionpreamble][genFunctionPreamble]] 默认是 function 模
   式 -> push ~function render(_ctx, _cache) {~ -> push ~with (_ctx)~ -> ...
   -> [[#codegen-gennode][genNode(ast.codegenNode, context)]]

   这里需要修改的点应该只有 genNode 里面，也是增加 INTERPOLATION switch 分支，
   处理插值部分的代码。


有了上面的初步分析，这里可以比较明确的知道需要修改的点：

1. DONE  *traverseNode* 中增加 INTERPOLATION 分支
2. DONE  *genNode* 中增加 INTERPOLATION 分支
3. DONE  *genNode* 中增加 SIMPLE_EXPRESSION 分支处理插值内的表达式


+修正：事实上并没有 transformInterpolation+ :facepalm::facepalm::facepalm::facepalm:

修改完之后报错：
#+begin_example
transform.js:184 Uncaught TypeError: Cannot read property 'length' of undefined
    at traverseChildren (transform.js:184)
    at traverseNode (transform.js:119)
    at traverseChildren (transform.js:192)
    at traverseNode (transform.js:119)
    at transform (transform.js:133)
    at baseCompile (compile.js:37)
    at compile.html:12
#+end_example

根据报错定位到，在解析 root.children[0] 的时候经过 [[#transform-traversechildren][traverseChildren]] 里面时候的
parent.children 值为 undefined。

原因是 traverseNode 里面的 NodeTypes.INTERPOLATION 分支没有加 break 导致的，加上
之后：

#+begin_src js
  ƒ render(_ctx, _cache) {
    with (_ctx) {
      const { toDisplayString : _toDisplayString } = _Vue

      return
    }
  } "compiled"
#+end_src

和正确结果相比少了点东西 ~return _toDisplayString(world.burn())~

1. with 内的解构来源：

   #+begin_src js
     function generate() {
       // ...
       if (hasHelpers) {
         // 比如：插值处理时用到 TO_DISPLAY_STRING helper
         // 为了避免命名冲突，这里都需要将他们重命名

         // traverseNode 里面 context.help(helper)
         push(
           `const { ${ast.helpers
               .map((s) => `${helperNameMap[s]} : _${helperNameMap[s]}`)
               .join(", ")} } = _Vue`
         );

         push("\n");
         newline();
       }
       // ...
     }
   #+end_src

2. 缺少的 ~return _toDisplayString(world.burn())~

   - [[#codegen-generate][generate]] 中最后 push `return `

   - 执行 [[#codegen-gennode][genNode(ast.codgenNode, context)]] 处理缺少的部分

     #+begin_src js
       {type: 5, content: {…}, loc: {…}}
       content:
       content: "world.burn()"
       isConstant: false
       isStatic: false
       loc: {start: {…}, end: {…}, source: "world.burn()"}
       type: 4 // SIMPLE_EXPRESSION，第二步
       loc: {start: {…}, end: {…}, source: "{{ world.burn() }}"}
       type: 5 // INTERPOLATION，第一步
     #+end_src

     1) node 类型首先是 INTERPOLATION ，进入 [[#codegen-geniinterpolation][genInterpolation(node, context)]]

        #+begin_src js
          function genInterpolation(node, context) {
            const { push, helper, pure } = context;

            if (pure) push(PURE_ANNOTATION);

            // 这里从 helpers 里面取出 toDisplayString
            push(`${helper(TO_DISPLAY_STRING)}(`);

            // 这里生成 `world.burn()` SIMPLE_EXPRESSION 类型
            genNode(node.content, context);
            push(`)`);
          }
        #+end_src

     2) 取 node.content 调用 [[#codegen-gennode][genNode(node.content, context)]] 生成 `world.burn()`
        表达式。

        进入 ~switch node.type === NodeTypes.SIMPLE_EXPRESSION~ 分支，调用
        [[#codegen-genexpression][genExpression(node, context)]]

:sunflower: Perfect: 最后结果：

#+begin_src js
  ƒ render(_ctx, _cache) { // generate
    with (_ctx) { // useWithBlock
      const { toDisplayString : _toDisplayString } = _Vue // ast.helpers

      return _toDisplayString(world.burn()) // genNode -> genInterpolation -> genExpression
    }
  } // "compiled"
#+end_src

完整流程图([[http://qiniu.ii6g.com/img/compiler-pure-interpolation.png][七牛链接]])：

[[http://img.cheng92.com/vue3/compiler-core/compiler/compiler-pure-interpolation.png]]

** 01-simple text
:PROPERTIES:
:COLUMNS:  %CUSTOM_ID[(Custom Id)]
:CUSTOM_ID: test-text-01
:END:

compiled：
#+begin_src js
  (function anonymous(
  ) {

    return function render(_ctx, _cache) {
      with (_ctx) {
        return "simple text"
      }
    }
  })
#+end_src

也就是说 *"simple text"* 最后转变成的 render 函数如上所示。

我们的第一步就是如何来实现 compile 和 transform 能得到这样的结果，这将是该模块完
成第一步 🆙 🆙 🆙 🆙 🆙 🆙 🆙 🆙 🆙 🆙

parse 之后的 ast:
#+begin_src js
  {type: 0, children: Array(1), loc: {…}, helpers: Array(0), components: Array(0), …}
  cached: 0
  children: Array(1)
  0:
  content: "simple text"
  loc: {start: {…}, end: {…}, source: "simple text"}
  type: 2
  length: 1
  codegenNode: undefined
  components: []
  directives: []
  helpers: []
  hoists: []
  imports: []
  loc: {start: {…}, end: {…}, source: "simple text"}
  temps: 0
  type: 0
#+end_src


在完成 [[#transform-transformtext][transformText]] 之后，发现 result.code 是空的，还以为是这里面实现问题的，其
实是 [[#codegen-generate][generate]] 函数还没实现的原因。

所有需要支持的函数都完成之后：

#+begin_example
{ast: {…}, code: "function render(_ctx, _cache) {↵ with (_ctx) {↵  return "simple text"}}", map: ""}
  ast: {type: 0, children: Array(1), loc: {…}, helpers: Array(0), components: Array(0), …}
    code: "function render(_ctx, _cache) {↵ with (_ctx) {↵  return "simple text"}}"
    map: ""
#+end_example

会发现最终的 code 即我们想要的 render 函数，和用 vue.global.js 生成的一致。

如果需要将转成函数，这个需要用到 compileToFunction 这个不在我们这个讨论范围，其
实里面也很简单，直接调用 ~new Function(code)~ 就行了，来看下：

#+begin_src js
  import { baseCompile as compile } from "../compile.js";

  const source = `simple text`.trim();

  const result = compile(source, {
    sourceMap: true,
    filename: `foo.vue`,
  });
  const render = new Function(result.code);
  console.log(render, "compiled");
#+end_src

输出：
#+begin_example
ƒ anonymous(
) {
function render(_ctx, _cache) {
 with (_ctx) {
  return "simple text"}}
} "compiled"
#+end_example

然后会发现结果好像不太对，首先 render 会被一个匿名函数包起来，这个是没问题的，但
是貌似匿名函数没有结束的 *}* 这个我想问题肯定处在了 [[#codegen-generate][generate]] 里面。

其实是因为 [[#codegen-createcodgencontext][createCodgenContext]] 里面的 函数没有实现，另外这样是不对的，因为 ~new
Function(code)~ 会将 code 用一个匿名函数来包裹起来，因此想要得到 render 函数，必
须是以 return 形式返回，因此这里还有个遗漏的地方: [[#codegen-genfunctionpreamble][genFunctionPreamble]] 需要去实
现，这里面最后会 push 一个 return 到 code 开头。

更新后输出：
#+begin_src js
  ƒ anonymous(
  ) {

    return function render(_ctx, _cache) {
      with (_ctx) {
        return "simple text"
      }
    }
  }
#+end_src

在实现 genFunctionPreamble 之后，至此完成了一个得到 render 函数的完整过程。

下面将使用流程图方式进行回顾，分析整个过程。

[[http://qiniu.ii6g.com/img/compiler-simple-text.png][七牛图片链接]]

[[http://img.cheng92.com/vue3/compiler-core/compiler/compiler-simple-text.png]]
* 函数列表
** compile.ts
*** baseCompile(template, options)
:PROPERTIES:
:COLUMNS:  %CUSTOM_ID[(Custom Id)]
:CUSTOM_ID: compile-basecompile
:END:

将 template 解析成 render 函数，重点步骤:

1. [[vue/vue3-source-code-compiler-core-parse_ts/][baseParse(template, options)]] 将字符串模板解析成 AST 对象。
2. [[#transform-transform][transform(ast, ...)]] 将 AST 进一步转换处理
3. 将转换后的 ast 调用 codegen 的 generate 方法生成 render 。

#+begin_src js
  export function baseCompile(template, options) {
    const isModuleMode = options.mode === "module";

    // ... 略去错误❎处理
    const prefixIdentifiers =
          !__BROWSER__ && (options.prefixIdentifiers === true || isModuleMode);

    // 1. baseParse 得到 AST 对象，两种情况：1. 未解析的模板，2. 以解析之后的 ast 对象
    const ast =
          typeof template === "string" ? baseParse(template, options) : template;

    // 2. 取出所有 node 和 directive 的 transforms
    const [nodeTransforms, directiveTransforms] = getBaseTransformPreset(
      prefixIdentifiers
    );

    // 3. 进行转换，调用 transform
    transform(ast, {
      // 合并选项
      ...options, // 调用 baseCompile 时候的第二个参数
      prefixIdentifiers, // 还不知道是干啥的???
      // 节点转换器合并，外部转换器优先，即使用者可自定义自己的转换器
      nodeTransforms: [...nodeTransforms, ...(options.nodeTransforms || {})],
      // 指令转换器，同上。
      directiveTransforms: [
        ...directiveTransforms,
        ...(options.directiveTransforms || {}),
      ],
    });

    // 4. 调用 generate 生成 render 函数的 codegen 并返回，这就是我们需要的组件渲
    // 染函数
    return generate(ast, {
      ...options,
      prefixIdentifiers,
    });
  }
#+end_src

这也是除了错误处理之后的完整的 baseCompile 函数实现。
*** getBaseTransformPreset(prefixIdentifiers: boolean)
:PROPERTIES:
:COLUMNS:  %CUSTOM_ID[(Custom Id)]
:CUSTOM_ID: compile_getbasetransformpreset
:END:

合并所有 transform，返回一个 ~TransformPreset~ 类型的数组

stage-1: 第一阶段我们只需要文本转换，通过 [[#test-text-01][用例一]] 即可，所以这里就只保留
[[transform-transformtext][transformText]] 就可以了，剩下的就是去实现它。
#+begin_src js
  export function getBaseTransformPreset(prefixIdentifiers) {
    return [
      [
        // ... 省略其他，第一阶段我们应该只需要文本转换
        transformText,
      ],
      {
        // ...省略指令
      },
    ];
  }
#+end_src

** tranform.ts
*** transformExpression(node, context)
:PROPERTIES:
:COLUMNS:  %CUSTOM_ID[(Custom Id)]
:CUSTOM_ID: transform-transformexpression
:END:
*** transformText(node, context)
:PROPERTIES:
:COLUMNS:  %CUSTOM_ID[(Custom Id)]
:CUSTOM_ID: transform-transformtext
:END:

该函数会返回一个用来转换文本节点类型(~NodeTransform~)的函数。

返回函数分析(~return () => { ... }~)，主要由三个 for 构成：

1. 第一个 for 嵌套第二个 for 构成双重循环，用来合并 node.children 里面相邻的文本
   节点

   第一个 For 里面使用的是 children.length 动态获取当前数组的长度，结合代码中的
   splice 和 j--。从而完成合并操作。

   #+begin_src js
     // 1. 原来的 child 被重写
     // 2. child, ` + `, next 合并到了新 child.children 里面
     currentContainer.children.push(` + `, next);
     // 删除被合并的文本节点
     children.splice(j, 1);
     j--; // -1 是因为上面删除了当前元素，for 循环过程中长度是动态获取的
   #+end_src

2. 第三个 for 遍历第一步之后的 children，对每个 child 进行重定义，类型改变成
   ~NodeTyeps.TEXT_CALL~ 类型，增加 codegenNode 属性。


代码完整版：
#+begin_src js

  export const transformText = (node, context) => {
    // 文本转换只能是下面四种类型
    const validTypes = [
      NodeTypes.ROOT,
      NodeTypes.ELEMENT,
      NodeTypes.FOR,
      NodeTypes.IF_BRANCH,
    ];

    // 合法类型检测
    if (validTypes.indexOf(node.type)) {
      // 返回一个可执行函数，记得在 transformNode 吗，这个返回的函数
      // 将会被它在 while 中 执行 掉。
      return () => {
        const children = node.children;

        let currentContainer = undefined;
        let hasText = false;

        // 双重循环，合并所有相邻的文本节点
        // 如：[text1, text2, element, text3, ele, text4, text5]
        // text1 和 text2 会合并到text1
        // text3 不会合并
        // text4 和 text5 会被合并
        for (let i = 0; i < children.length; i++) {
          const child = children[i];

          if (isText(child)) {
            // TODO 文本节点才进行解析
            hasText = true;
            // 合并相邻的文本节点， text1 + text2
            for (let j = i + 1; j < children.length; j++) {
              const next = children[j];
              // 下一个也是文本节点的时候，要将两者合并
              if (isText(next)) {
                if (!currentContainer) {
                  // 这里等于重写了 child 的引用，将自身 push 到了
                  // 新结构中的 children
                  currentContainer = children[i] = {
                    type: NodeTypes.COMPOUND_EXPRESSION,
                    loc: child.loc,
                    children: [child],
                  };
                }

                // 1. 原来的 child 被重写
                // 2. child, ` + `, next 合并到了新 child.children 里面
                currentContainer.children.push(` + `, next);
                // 删除被合并的文本节点
                children.splice(j, 1);
                j--; // -1 是因为上面删除了当前元素，for 循环过程中长度是动态获取的
              } else {
                currentContainer = undefined;
                break;
              }
            }
          }
        }

        // 集中不满足转换条件的情况
        if (
          // 1. 没有文本内容
          // 2. 只有一个孩子节点
          //   2.1 组件根节点
          //   2.2 <element> 元素节点
          !hasText ||
            (children.length === 1 &&
             (node.type === NodeTypes.ROOT ||
              (node.type === NodeTypes.ELEMENT &&
               node.tagType === ElementTypes.ELEMENT)))
        ) {
          return;
        }

        // 开始转换
        for (let i = 0; i < children.length; i++) {
          const chld = children[i];
          if (isText(child) || child.type === NodeTypes.COMPOUND_EXPRESSION) {
            const callArgs = [];

            // 非文本节点，直接 push 掉，这里 child.content !== ' ' 的原因在于
            // parseChildren 里面 while 循环最后有个remove whitespace 操作
            // 会将有效的空节点转成一个空格的字符串。
            // createTextVNode 默认是一个单空格
            if (child.type !== NodeTypes.TEXT || child.content !== " ") {
              callArgs.push(child);
            }

            // 非服务端渲染，且非文本节点
            if (!context.ssr && child.type !== NodeTypes.TEXT) {
              callArgs.push(
                // TODO 这个是干嘛的？？？
                `${PatchFlags.TEXT} /* ${PatchFlagNames[PatchFlags.TEXT]} */`
              );
            }

            children[i] = {
              type: NodeTypes.TEXT_CALL, // 文本函数
              content: child,
              loc: child.loc,
              codegenNode: createCallExpression(
                context.helper(CREATE_TEXT),
                callArgs
              ),
            };
          }
        }
      };
    }
  }
#+end_src

使用到的外面函数和属性：

1. CREATE_TEXT： 一个符号属性 ~export const CREATE_TEXT = Symbol(__DEV__ ? `createTextVNode` : ``);~
2. [[#ast-createcallexpression][createCallExpression(callee, args, loc)]] 返回 JS_CALL_EXPRESSION 类型对象。
3. PatchFlags 和 PatchFlagNames 一个名字映射
4. isText 文本节点类型(插值和 text)

   #+begin_src js
     export function isText(node) {
       // 插值或 text 均视为文本
       return node.type === NodeTypes.INTERPOLATION || node.type === NodeTypes.TEXT;
     }
   #+end_src


*对应的虚拟节点创建函数： createTextVNode*
*** transform(root, options)
:PROPERTIES:
:COLUMNS:  %CUSTOM_ID[(Custom Id)]
:CUSTOM_ID: transform-transform
:END:

调用的函数：
1. [[#transform-createtransformcontext][createTransformContext(root, options)]] 创建 transform 转换器类型的上下文对象
2. [[#transform-traversenode][traverseNode(root, context)]] 遍历所有节点
3. ssr 服务端渲染处理
4. 初始化 root 根节点上的一些属性

stage-1: [[#test-text-01][01 simple text]]
#+begin_src js

  export function transform(root, options) {
    const context = createTransformContext(root, options);

    traverseNode(root, context);

    if (options.hoistStatic) {
      hoistStatic(root, context);
    }

    // ... ssr 处理

    // root 属性合并，初始化
    root.helpers = [...context.helpers];
    root.components = [...context.components];
    root.directives = [...context.directives];
    root.imports = [...context.imports];
    root.hoists = context.hoists;
    root.temps = context.temps;
    root.cached = context.cached;
  }
#+end_src
*** createTransformContext(root, options)
:PROPERTIES:
:COLUMNS:  %CUSTOM_ID[(Custom Id)]
:CUSTOM_ID: transform-createtransformcontext
:END:

单纯的构建和初始化 transform 转换器上下文对象。

**** stage-1: [[#test-text-01][01 simple text]]

一些初始化的工作，并不需要具体实现什么，纯文本并没有用到。

#+begin_src js
  export function createTransformContext(
    root,
    {
      prefixIdentifiers = false,
      hoistStatic = false,
      cacheHandlers = false,
      nodeTransforms = [],
      directiveTransforms = {},
      transformHoist = null,
      isBuiltInComponent = NOOP,
      expressionPlugins = [],
      scopeId = null,
      ssr = false,
      onError = defaultOnError,
    }
  ) {
    const context = {
      // options
      prefixIdentifiers,
      hoistStatic,
      cacheHandlers,
      nodeTransforms,
      directiveTransforms,
      transformHoist,
      isBuiltInComponent,
      expressionPlugins,
      scopeId,
      ssr,
      onError,

      // state
      root,
      helpers: new Set(),
      components: new Set(),
      directives: new Set(),
      hoists: [],
      imports: new Set(),
      temps: 0,
      cached: 0,
      identifiers: {},
      scopes: {
        vFor: 0,
        vSlot: 0,
        vPre: 0,
        vOnce: 0,
      },
      parent: null,
      currentNode: root,
      childIndex: 0,

      // methods
      helper(name) {},
      helperString(name) {},
      replaceNode(node) {},
      removeNode(node) {},
      onNodeRemoved: () => {},
      addIdentifiers(exp) {},
      removeIdentifiers(exp) {},
      hoist(exp) {},
      cache(exp, isVNode = false) {},
    };

    function addId(id) {}

    function removeId(id) {}

    return context;
  }
#+end_src

**** stage-2: [[#test-02-worldburn][02 pure interpolation]] 插值节点的编译

#+begin_src js

  export function createTransformContext(
    root,
    { ... }
  ) {
    const context = {
      // ...
      helpers: new Set(),

      // ...

      // 新增 helper 实现
      helper(name) {
        context.helpers.add(name);
        return name;
      },

      // ...
    };

    function addId(id) {}

    function removeId(id) {}

    return context;
  }
#+end_src
*** createRootCodegen(root, context)
:PROPERTIES:
:COLUMNS:  %CUSTOM_ID[(Custom Id)]
:CUSTOM_ID: transform-createrootcodegen
:END:

创建 root 节点上的 codegenNode 值，这也是将来用来编译成 render 函数的源码字符串。

**** stage-1: [[#test-text-01][01 simple text]]
#+begin_src js

  function createRootCodegen(root, context) {
    // TODO  helper
    const { children } = root;
    const child = children[0];

    if (children.length === 1) {
      // 只有一个孩子节点

      // 且孩子节点是一个元素 element 类型，将它放在一个代码块钟返回
      // 如： { code }
      if (isSingleElementRoot(root, child) && child.codegenNode) {
        // TODO
      } else {
        root.codegenNode = child;
      }
    } else if (children.length > 1) {
    } else {
      // 没有孩子节点， codegen 返回 null，看到没
      // 01 simple text 返回 null 问题找到根源了
    }
  }
#+end_src

实现完这个之后发现，generate 里面的 [[#codegen-gennode][genNode]] 还没实现，真实丢三落四~~~~。
*** traverseNode(node, context)
:PROPERTIES:
:COLUMNS:  %CUSTOM_ID[(Custom Id)]
:CUSTOM_ID: transform-traversenode
:END:

**** stage-1: [[#test-text-01][01 simple text]] 省略 switch 里面的上线，因为这里只是纯文本不再 case 范围。
:PROPERTIES:
:COLUMNS:  %CUSTOM_ID[(Custom Id)]
:CUSTOM_ID: transform-traversenode-stage1
:END:

#+begin_src js

  export function traverseNode(node, context) {
    context.currentNode = node;

    const { nodeTransforms } = context;
    const exitFns = [];

    for (let i = 0; i < nodeTransforms.length; i++) {
      // 调用诸如  transformText 的函数
      const onExit = nodeTransforms[i](node, context);
      if (onExit) {
        const fns = Array.isArray(onExit) ? onExit : [onExit];
        exitFns.push(...fns);
      }

      if (!context.currentNode) {
        // 可能被移除了
        return;
      } else {
        // 节点可能被替换过，重新建立引用
        node = context.currentNode;
      }
    }

    switch (node.type) {
        // ... 省略
      case NodeTypes.ROOT:
        traverseChildren(node, context);
        break;
    }

    let i = exitFns.length;
    // 执行所有转换
    while (i--) {
      exitFns[i]();
    }
  }
#+end_src
**** stage-2: [[#test-02-worldburn][02 pure interpolation]] 插值节点的编译
:PROPERTIES:
:COLUMNS:  %CUSTOM_ID[(Custom Id)]
:CUSTOM_ID: transform-traversenode-stage2
:END:

增加 INTERPOLATION 类型节点分支处理。

#+begin_src js

  export function traverseNode(node, context) {
    // ...

    switch (node.type) {
        // ...

        // 新增：对插值类型节点处理
      case NodeTypes.INTERPOLATION:
        if (!context.ssr) {
          // 这个函数来自上下文处理中的 helper(name)
          context.helper(TO_DISPLAY_STRING);
        }
        break

        // ...
    }

    // ...
  }
#+end_src

修改之后代码：

#+begin_src js

  export function traverseNode(node, context) {
    context.currentNode = node;

    const { nodeTransforms } = context;
    const exitFns = [];

    for (let i = 0; i < nodeTransforms.length; i++) {
      // 调用诸如  transformText 的函数
      const onExit = nodeTransforms[i](node, context);
      if (onExit) {
        const fns = Array.isArray(onExit) ? onExit : [onExit];
        exitFns.push(...fns);
      }

      if (!context.currentNode) {
        // 可能被移除了
        return;
      } else {
        // 节点可能被替换过，重新建立引用
        node = context.currentNode;
      }
    }

    switch (node.type) {
        // ... 省略
      case NodeTypes.INTERPOLATION:
        if (!context.ssr) {
          // 这个函数来自上下文处理中的 helper(name)
          context.helper(TO_DISPLAY_STRING);
        }
        break;
      case NodeTypes.ROOT:
        traverseChildren(node, context);
        break;
    }

    let i = exitFns.length;
    // 执行所有转换
    while (i--) {
      exitFns[i]();
    }
  }
#+end_src
*** traverseChildren(parent, context)
:PROPERTIES:
:COLUMNS:  %CUSTOM_ID[(Custom Id)]
:CUSTOM_ID: transform-traversechildren
:END:

处理 node.children 孩子节点。

#+begin_src js

  export function traverseChildren(parent, context) {
    let i = 0;
    const nodeRemoved = () => {
      i--;
    };

    for (; i < parent.children.length; i++) {
      const child = parent.children[i];
      // 过略掉字符串，只处理 ast child
      if (typeof child === "string") continue;

      context.parent = parent;
      context.childIndex = i;
      context.onNodeRemoved = nodeRemoved;
      traverseNode(child, context);
    }
  }
#+end_src
** codegen.ts
*** createCodgenContext(ast, context)
:PROPERTIES:
:COLUMNS:  %CUSTOM_ID[(Custom Id)]
:CUSTOM_ID: codegen-createcodegencontext
:END:

**** stage-1: [[#test-text-01][01 simple text]]

#+begin_src js

  // 构建 condegen 上下文对象
  function createCodegenContext(
    ast,
    {
      mode = "function",
      prefixIdentifiers = mode === "module",
      sourceMap = false,
      filename = `template.vue.html`,
      scopeId = null,
      optimizeBindings = false,
      runtimeGlobalName = `Vue`,
      runtimeModuleName = `vue`,
      ssr = false,
    }
  ) {
    const context = {
      mode,
      prefixIdentifiers,
      sourceMap,
      filename,
      scopeId,
      optimizeBindings,
      runtimeGlobalName,
      runtimeModuleName,
      ssr,
      source: ast.loc.source,
      code: ``,
      column: 1,
      line: 1,
      offset: 0,
      indentLevel: 0,
      pure: false,
      map: undefined,
      helper(key) {},
      push(code, node) {
        context.code += code;
        // TODO 非浏览器环境处理，node 环境
      },
      indent() {
        // 新行缩进
        newline(++context.indentLevel);
      },
      deindent(withoutNewLine = false) {
        if (withoutNewLine) {
          --context.indentLevel;
        } else {
          newline(--context.indentLevel);
        }
      },
      newline() {
        newline(context.indentLevel);
      },
    };

    function newline(n) {
      context.push("\n" + ` `.repeat(n));
    }

    function addMapping(loc, name) {}

    return context;
  }
#+end_src
*** generate()
:PROPERTIES:
:COLUMNS:  %CUSTOM_ID[(Custom Id)]
:CUSTOM_ID: codegen_generate
:END:

generate 函数雏形：

#+begin_src js
  export function generate(ast, options) {
    return {
      ast,
      code: "",
      map: "",
    };
  }

#+end_src

函数的目的是：通过 ast 来生成 code，这个 code 将来会被 compileToFunction 调用 ~new
Function(code)~ 生成 render 函数的。

**** stage-1: [[#test-text-01][01 simple text]]
:PROPERTIES:
:COLUMNS:  %CUSTOM_ID[(Custom Id)]
:CUSTOM_ID: codegen-generate-stage1
:END:

#+begin_src js

  export function generate(ast, options = {}) {
    const context = createCodegenContext(ast, options);
    const {
      mode,
      push,
      prefixIdentifiers,
      indent,
      deindent,
      newline,
      scopeId,
      ssr,
    } = context;

    const hasHelpers = ast.helpers.length > 0;
    const useWithBlock = !prefixIdentifiers && mode !== "module";
    const genScopeId = !__BROWSER__ && scopeId != null && mode === "module";

    // TODO preambles
    if (!__BROWSER__ && mode === "module") {
      // TODO genModulePreamble(ast, context, genScopeId)
    } else {
      genFunctionPreamble(ast, context);
    }

    if (genScopeId && !ssr) {
      push(`const render = ${PURE_ANNOTATION}_withId(`);
    }

    if (!ssr) {
      // 函数声明
      push(`function render(_ctx, _cache) {`);
    } else {
      // TODO ssr render
    }

    indent();

    if (useWithBlock) {
      // use with(_ctx) { ...}
      push(`with (_ctx) {`);
      indent();

      // TODO hasHelpers
    }

    // TODO ast.components 组件处理

    // TODO ast.directives 指令处理

    // TODO ast.temps 临时变量处理

    // TODO 换行

    if (!ssr) {
      push(`return `);
    }

    // 生成代码片段
    if (ast.codegenNode) {
      genNode(ast.codegenNode, context);
    } else {
      push(`null`);
    }

    if (useWithBlock) {
      deindent();
      push(`}`);
    }

    deindent();
    push(`}`);

    if (genScopeId && !ssr) {
      push(`)`);
    }

    return {
      ast,
      code: context.code,
      map: "",
    };
  }
#+end_src

代码中只包含文本解析需要的内容。但是结果显示：

#+begin_example
ast: {type: 0, children: Array(1), loc: {…}, helpers: Array(0), components: Array(0), …}
  code: "function render(_ctx, _cache) {↵ with (_ctx) {↵  return null}}"
  map: ""
#+end_example

即： ~ast.codegenNode~ 是空值，最后并没有 执行 ~genNode(ast.codgenNode, context)~
。

因此问题还在 [[#transform-transformtext][transformText]] 里面，但是纯文本会直接在第一个 for 后的 if 判断中直接
~return~ 了，那么问题出在哪？？？

进过往上追溯，发现在 traverseNode 实现中有一部分 switch 代码被我们省略，而里面就
有个 case 是文本节点会走到的，即： ~NodeTypes.ROOT~ 因为这个用例文本是直接挂在根
节点下面的，那么就得实现 [[#transform-traversechildren][traverseChildren]] 了。

然后，实现完 traverseChildren 之后并没解决问题，因为这里面根本没有处理赋值
codgenNode 的操作。

那么只能用最笨拙的方法了，直接搜索 ~codegen*~ 然后又发现新大陆(transform 里面有
个 [[#transform-createrootcodegen][createRootCodgen(...)]] 并没有实现)， :runner: go ->

**** stage-2: [[#test-02-worldburn][02 pure interpolation]]
:PROPERTIES:
:COLUMNS:  %CUSTOM_ID[(Custom Id)]
:CUSTOM_ID: codegen-generate-stage2
:END:

这里新增了 ~push ast.helpers.map(...)~ 处理，比如 traverseNode stage-2 中新增的
INTERPOLATION 分支中的处理是 ~context.helper(TO_DISPLAY_STRING)~ 就是给上下文的
helpers 增加了 ~Symbol('toDisplayString')~ 。

#+begin_src js

  export function generate(ast, options = {}) {
    // ...

    const hasHelpers = ast.helpers.length > 0;

    // ...

    if (useWithBlock) {
      // use with(_ctx) { ...}
      push(`with (_ctx) {`);
      indent();

      // 新增： hasHelpers
      if (hasHelpers) {
        // 比如：插值处理时用到 TO_DISPLAY_STRING helper
        // 为了避免命名冲突，这里都需要将他们重命名

        push(
          `const { ${ast.helpers
            .map((s) => `${helperNameMap[s]} : _${helperNameMap[s]}`)
            .join(", ")} } = _Vue`
        );

        push("\n");
        newline();
      }
    }

    // ...
  }
#+end_src

正好在这里会检测 ~context.helpers~ 进行相应的处理。

[[#transform-traversenode][traverseNode]] 的 switch 中插值 INTERPOLATION 分支处理中增加了一个
TO_DISPLAY_STRING 符号类型值到 ~context.helpers: Set~ 中，这其实就是个 ~_Vue~
实例中的一个函数名称，在这里会遍历 ~context.helpers~ 将需要用到的函数从实例中解
构出来。

*** genNode(node, context)
:PROPERTIES:
:COLUMNS:  %CUSTOM_ID[(Custom Id)]
:CUSTOM_ID: codegen-gennode
:END:

**** stage-1: [[#test-text-01][01 simple text]]
:PROPERTIES:
:COLUMNS: %CUSTOM_ID[(Custom Id)]
:CUSTOM_ID: codegen-gennode-stage1
:END: 

这里我们只处理文本节点的情况：
#+begin_src js

  function genNode(node, context) {
    if (typeof node === "string") {
      context.push(node);
      return;
    }

    // TODO is symbol

    switch (node.type) {
        // ... 省略
      case NodeTypes.TEXT:
        genText(node, context);
        break;
    }
  }
#+end_src

然后就是实现 case 的 [[#codegen-gentext][genText(node, context)]]

**** stage-2: [[#test-02-worldburn][02 pure interpolation]]
:PROPERTIES:
:COLUMNS: %CUSTOM_ID[(Custom Id)]
:CUSTOM_ID: codegen-gennode-stage2
:END: 

这个阶段需要支持插值的解析，而插值在 ast 中数据结构为：

#+begin_src json
  {
    "type":5, // INTERPOLATION
    "content":{
      "type":4, // SIMPLE_EXPRESSION
      "isStatic":false,
      "isConstant":false,
      "content":"world.burn()",
      "loc":{
        // ... ,
        "source":"world.burn()"
      }
    },
    "loc":{
      // ...,
      "source":"{{ world.burn() }}"
    }
  }
#+end_src

这里需要经过两次递归调用 genNode 分别去解析 ~type=5 // INTERPOLATION~ 和 ~type=4
// SIMPLE_EXPRESSION~ 两种类型，且前后形同父子关系。

那么就有：

#+begin_src js
  function genNode(node, context) {
    if (typeof node === "string") {
      context.push(node);
      return;
    }

    // TODO is symbol

    switch (node.type) {
        // ... 省略
      case NodeTypes.TEXT:
        genText(node, context);
        break;
      case NodeTypes.SIMPLE_EXPRESSION:
        // 如：插值内容，属性值
        genExpression(node, context);
        break;
      case NodeTypes.INTERPOLATION:
        console.log(node, "interpolation");
        genInterpolation(node, context);
        break;
    }
  }
#+end_src

1. 先经过 INTERPOLATION 分支调用 [[#codegen-geninterpolation][genInterpolation(node, context)]] 去解析插值节点
*** genText(node, context)
:PROPERTIES:
:COLUMNS:  %CUSTOM_ID[(Custom Id)]
:CUSTOM_ID: codegen-gentext
:END:

这里没什么阶段性的，就是一句很简单的字符串化文本节点内容。

#+begin_src js
  function genText(node, context) {
    // 文本直接字符串化
    context.push(JSON.stringify(node.content), node);
  }

#+end_src

*** genFunctionPreamble(ast, context)
:PROPERTIES:
:COLUMNS:  %CUSTOM_ID[(Custom Id)]
:CUSTOM_ID: codegen-genfunctionpreamble
:END:

**** stage-1: [[#test-text-01][01 simple text]]
对于纯文本这里不需要更多的处理，只需要最后的 ~`return `~

#+begin_src js

  function genFunctionPreamble(ast, context) {
    const { push, newline } = context;

    // TODO ...

    newline()
    push(`return `);
  }
#+end_src
*** genInterpolation(node, context)
:PROPERTIES:
:COLUMNS: %CUSTOM_ID[(Custom Id)]
:CUSTOM_ID: codegen-geninterpolation
:END: 

#+begin_src js
  function genInterpolation(node, context) {
    const { push, helper, pure } = context;

    if (pure) push(PURE_ANNOTATION);

    push(`${helper(TO_DISPLAY_STRING)}(`);
    // 调用 genNode 解析插值的内容，表达式节点类型，NodeTypes.SIMPLE_EXPRESSION
    genNode(node.content, context);
    push(`)`);
  }
#+end_src

~context.helper(TO_DISPLAY_STRING)~ 是从 helpersMap 中取出 TO_DISPLAY_STRING 对
应的函数名称(下划线重命名之后的名称)，看 ~context.helper~ 实现:
#+begin_src js
  helper(key) {
    return `_${helperNameMap[key]}`;
  }
#+end_src

别名操作在 [[#codegen-generate][generate]] 的 useWithBlock 判断中生成。

*** genExpression(node, context)
:PROPERTIES:
:COLUMNS: %CUSTOM_ID[(Custom Id)]
:CUSTOM_ID: codegen-genexpression
:END: 

#+begin_src js
  function genExpression(node, context) {
    const { content, isStatic } = node;
    context.push(isStatic ? JSON.stringify(content) : content, node);
  }
#+end_src

表达式的值可以是静态的，也可以是动态的，

1. TODO 如果是静态直接字符串化？？？

2. DONE 如果是动态的直接 push content 变成变量直接从上下文去取变量值

   如 [[test-02-worldburn][02 pure interpolation]] 中的 ~world.burn()~ 会直接被塞到 ~context.code~ 结合
   成 ~return _toDisplayString(world.burn());~ 生成函数之后相当于这样调
   用： ~_ctx.world.burn()~  。
   
** 虚拟节点创建函数

| name              | transform     | desc             |
|-------------------+---------------+------------------|
| ~createTextVNode~ | [[#transform-transformtext][transformText]] | 创建文本虚拟节点 |
|                   |               |                  |

* 问题列表

1. compile.js:37 Uncaught TypeError: object is not iterable (cannot read
   property Symbol(Symbol.iterator))

   原因是：在数组里面使用展开符的时候 [], {} 混用了

   #+begin_src js
     transform(ast, {
       // 合并选项
       ...options, // 调用 baseCompile 时候的第二个参数
       prefixIdentifiers, // 还不知道是干啥的???
       // 节点转换器合并，外部转换器优先，即使用者可自定义自己的转换器
       // nodeTransforms: [...nodeTransforms, ...(options.nodeTransforms || {})], // FIX: 这里用法有问题修改前
       nodeTransforms: [...nodeTransforms, ...(options.nodeTransforms || [])], // FIX: 修改后
       // 指令转换器，同上。
       directiveTransforms: {
         ...directiveTransforms,
         ...(options.directiveTransforms || {}),
       },
     });

   #+end_src
