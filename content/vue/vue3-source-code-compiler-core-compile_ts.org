#+TITLE: Vue3.0 æºç ç³»åˆ—ï¼ˆäºŒï¼‰ç¼–è¯‘å™¨æ ¸å¿ƒ - Compiler core 3: compile.ts
#+DATE: <2020-08-31 22:11:55>
#+TAGS[]: vue, vue3, vuenext, compiler
#+CATEGORIES[]: vue
#+LANGUAGE: zh-cn
#+STARTUP: indent


#+begin_export html
<script>
window.g_need_fold = 1
</script>
#+end_export

#+begin_quote
è¯¥ç³»åˆ—æ–‡ç« ï¼Œå‡ä»¥æµ‹è¯•ç”¨ä¾‹é€šè¿‡ä¸ºåŸºå‡†ä¸€æ­¥æ­¥å®ç°ä¸€ä¸ª vue3 æºç å‰¯æœ¬(å­¦ä¹ )ã€‚
#+end_quote

@@html:<kbd>@@æ–‡å­—æ¯”è¾ƒé•¿ï¼Œå¦‚æœä¸æƒ³çœ‹æ–‡å­—å¯ç›´æ¥è½¬åˆ°[[/vue/vue-mind-map-house/][è¿™é‡Œ]]çœ‹è„‘å›¾@@html:</kbd>@@

@@html:<kbd>@@
*ç”±äº compile å’Œ transform å…³è”æ€§æ¯”è¾ƒå¼ºè¿™é‡Œå°†æ”¾åœ¨ä¸€èµ·å»å®Œæˆã€‚*
@@html:</kbd>@@

* å‡†å¤‡å·¥ä½œ
è¦å®Œæˆè¿™ä¸€éƒ¨åˆ†ï¼Œé¦–å…ˆè¦äº†è§£å®ƒçš„ä½œç”¨æ˜¯ä»€ä¹ˆï¼Ÿ

åœ¨ [[/vue/vue3-source-code-compiler-core-parse_ts/][parse.ts]] æ–‡ä¸­æˆ‘ä»¬å®Œæˆäº†è§£æå™¨çš„éƒ¨åˆ†ï¼Œä½œç”¨æ˜¯å°†æ¨¡æ¿è§£ææˆ AST å¯¹è±¡ã€‚

åœ¨è¿™é‡Œ compile.ts ä½œç”¨å°±æ˜¯å°†è¿™äº› AST å¦‚ä½•ç¿»è¯‘æˆ render å‡½æ•°ã€‚

ä¸ºäº†æ›´ç›´è§‚çš„ä½“éªŒ compile çš„ä½œç”¨ï¼Œåœ¨ vue æºç é‡Œé¢æœ‰ä¸€ä¸ªæ‰“åŒ…ä¹‹åçš„ç›®å½•ï¼š

*/vue-next/packages/vue/dist/vue.global.js*

ç„¶åæˆ‘ä»¬ä½¿ç”¨ç¬¬ä¸€ä¸ªæµ‹è¯•ç”¨ä¾‹çš„æ¨¡æ¿ï¼Œå»ç¼–è¯‘ä¸‹çœ‹çœ‹ç»“æœï¼š

#+begin_src js
  const source = `
  <div id="foo" :class="bar.baz">
    {{ world.burn() }}
    <div v-if="ok">yes</div>
    <template v-else>no</template>
    <div v-for="(value, index) in list"><span>{{ value + index }}</span></div>
  </div>
       `.trim(),
#+end_src

è¿›è¡Œç¼–è¯‘(å®Œæ•´ç¤ºä¾‹)ï¼š

#+begin_src html
  <script src="./vue.global.js"></script>
  <script>
    console.log(Vue, "00");
    const { compile } = Vue;
    const result = compile(
    `
    <div id="foo" :class="bar.baz">
      {{ world.burn() }}
      <div v-if="ok">yes</div>
      <template v-else>no</template>
      <div v-for="(value, index) in list"><span>{{ value + index }}</span></div>
    </div>
    `.trim(),
    { sourceMap: true, filename: "foo.vue" }
    );
    console.log(result, "xx");
  </script>
#+end_src

è¿è¡Œä¹‹å result ç»“æœï¼š

#+begin_src js
  (function anonymous() {
    const _Vue = Vue;
    const {
      createVNode: _createVNode,
      createCommentVNode: _createCommentVNode,
      createTextVNode: _createTextVNode,
    } = _Vue;

    const _hoisted_1 = { key: 0 };
    // è¿™é‡Œ v-if ... else é‡Œé¢çš„ <template>no</template> ï¼Ÿ
    // åˆ›å»ºæ–‡æœ¬è™šæ‹ŸèŠ‚ç‚¹ï¼Œè¿™é‡Œä¸ºä»€ä¹ˆç›´æ¥åœ¨ render å¤–å°±æ‰§è¡Œäº†ï¼Ÿï¼Ÿï¼Ÿ
    // åˆæ˜¯æ€ä¹ˆåšåˆ°çš„ï¼Ÿï¼Ÿï¼Ÿ
    const _hoisted_2 = _createTextVNode("no");

    // ç¥çº§å‡½æ•° >>> render
    return function render(_ctx, _cache) {
      with (_ctx) {
        const {
          toDisplayString: _toDisplayString,
          createVNode: _createVNode,
          openBlock: _openBlock,
          createBlock: _createBlock,
          createCommentVNode: _createCommentVNode,
          createTextVNode: _createTextVNode,
          Fragment: _Fragment,
          renderList: _renderList,
        } = _Vue;

        return (
          _openBlock(),
          _createBlock(
            "div",
            {
              // è§£æå‡ºæ¥çš„ div å±æ€§ï¼Œ id å’Œ class
              // parseAttribute çš„ç»“æœ
              id: "foo", // æ³¨æ„è¿™é‡Œæ˜¯å­—ç¬¦ä¸²
              class: bar.baz, // è¿™é‡Œæ˜¯å˜é‡å½¢å¼å­˜åœ¨ï¼Œå› ä¸ºç”¨åˆ°äº† :class å±äºæŒ‡ä»¤è§£æ
            },
            [
              // è¿™é‡Œæ˜¯å­©å­èŠ‚ç‚¹ä»¬
              // 1. ç¬¬ä¸€ä¸ªå­©å­èŠ‚ç‚¹ï¼Œæ’å€¼
              _createTextVNode(
                // æ’å€¼é‡Œé¢çš„å†…å®¹è°ƒç”¨è½¬æ¢æˆæ–‡æœ¬
                _toDisplayString(world.burn()) + " ",
                1 /* TEXT */
              ),
              // 2. ç¬¬äºŒä¸ªå­©å­èŠ‚ç‚¹ v-if...v-else
              // v-if æŒ‡ä»¤ï¼Œå‚æ•°æ˜¯ ok
              // ç„¶åè¿™é‡Œåˆæ˜¯æ€ä¹ˆåšåˆ° ok ? ... : ...
              // æŒ‡ä»¤è§£æçš„æ—¶å€™ v-if çš„å¤„ç†åˆæ˜¯æ€ä¹ˆåšçš„ï¼Œtransform/vIf ???
              // ç›¸é‚»çš„ä¸‹ä¸€ä¸ªèŠ‚ç‚¹æ£€æµ‹æ˜¯å¦æ˜¯ v-if æŒ‡ä»¤ç°‡ï¼Ÿï¼Ÿï¼Ÿ
              // åˆ°åº•çœŸç›¸å¦‚ä½• ???

              ok
              // åˆ›å»º div
                ? (_openBlock(), _createBlock("div", _hoisted_1, "yes"))
              // åˆ›å»º template
                : (_openBlock(),
                   _createBlock(
                     _Fragment,
                     { key: 1 },
                     // æå‰è¢«è§£æå‡ºæ¥çš„ template -> no æ–‡æœ¬èŠ‚ç‚¹
                     // éš¾é“æ˜¯æå‰éå†ï¼Ÿï¼Ÿï¼Ÿå°†æ‰€æœ‰çš„ template å¦‚æœæ˜¯
                     // é™æ€çš„å°±å…ˆå…¨éƒ¨åˆ›å»ºå‡ºæ¥ï¼Ÿï¼Ÿï¼Ÿ
                     [_hoisted_2],
                     64 /* STABLE_FRAGMENT */
                   )),
              // 3. ç¬¬ä¸‰ä¸ªå­©å­èŠ‚ç‚¹ï¼Œdiv v-for
              (_openBlock(true),
               _createBlock(
                 _Fragment,
                 null,
                 // æ¸²æŸ“åˆ—è¡¨
                 _renderList(list, (value, index) => {
                   return (
                     _openBlock(),
                     _createBlock("div", null, [
                       _createVNode(
                         "span",
                         null,
                         _toDisplayString(value + index),
                         1 /* TEXT */
                       ),
                     ])
                   );
                 }),
                 256 /* UNKEYED_FRAGMENT */
               )),
            ],
            2 /* CLASS */
          )
        );
      }
    };
  });
#+end_src

è¯¸å¤šçš„ç–‘é—®ç­‰ç€å»è§£ç­”ï¼ï¼ï¼

ä½†è‡³å°‘æœ‰ä¸€ç‚¹å¾ˆæ¸…æ™°çš„çŸ¥é“ï¼Œcompile å°±æ˜¯å°† AST ç¼–è¯‘æˆ render å‡½æ•°ç”¨çš„ã€‚

çŸ¥é“äº†æœ€ç»ˆç›®çš„ï¼Œæ¥ä¸‹æ¥å°±æ˜¯æ¼«é•¿çš„æ¢ç´¢ä¹‹è·¯äº† :running: :running: :running:

æ„é€ æ•°æ®ï¼Œè§‚å¯Ÿæœ€ç»ˆç”Ÿæˆçš„ VNode ç»“æ„(ä¸Šé¢ä»£ç æ‰§è¡Œä¹‹åç»“æœè¿”å›ç»™ resultï¼Œå…¶å®å°±
æ˜¯ render å‡½æ•°):

#+begin_src js
  result({
    list: [1,2,3],
    ok: true,
    bar: {
      baz: 'xx'
    },
    world: {
      burn() {}
    }
  })
#+end_src

ä¼ é€’ä¸€äº›å‚æ•°è°ƒç”¨ä¹‹åç»“æœï¼š

#+begin_src js
  {_isVNode: true, type: "div", props: {â€¦}, key: null, ref: null, â€¦}
  anchor: null
  appContext: null
  // ä¸‰ä¸ªå­©å­èŠ‚ç‚¹
  children: Array(3)
  0: {_isVNode: true, type: Symbol(Text), props: null, key: null, ref: null, â€¦}
  1: {_isVNode: true, type: "div", props: {â€¦}, key: 0, ref: null, â€¦}
  2: {_isVNode: true, type: Symbol(Fragment), props: null, key: null, ref: null, â€¦}
  length: 3
  component: null
  dirs: null
  // ä¸‰ä¸ªåŠ¨æ€å­©å­èŠ‚ç‚¹
  dynamicChildren: Array(3)
  0: {_isVNode: true, type: Symbol(Text), props: null, key: null, ref: null, â€¦}
  1: {_isVNode: true, type: "div", props: {â€¦}, key: 0, ref: null, â€¦}
  2: {_isVNode: true, type: Symbol(Fragment), props: null, key: null, ref: null, â€¦}
  length: 3
  dynamicProps: null
  el: null
  key: null
  patchFlag: 2
  // å±æ€§
  props: {id: "foo", class: "xx"}
  ref: null
  scopeId: null
  shapeFlag: 17
  suspense: null
  target: null
  targetAnchor: null
  transition: null
  // æ ‡ç­¾
  type: "div"
  // æ ‡è¯†ä¸ºè™šæ‹ŸèŠ‚ç‚¹
  _isVNode: true

#+end_src

* compile.spec.ts
ç”±äº compile.spec.ts åŸæ¥åªæœ‰ä¸€ä¸ªç”¨ä¾‹ï¼Œç›¸å¯¹æ˜¯æ¯”è¾ƒå¤æ‚çš„ï¼Œä¸åˆ©äºå­¦ä¹ ã€‚

è¿™é‡Œå°†æ ¹æ® [[/vue/vue3-source-code-compiler-core-parse_ts/#parse.spec.ts][parse.spec.ts]] å¾ªåºæ¸è¿›çš„å»å®ç° compile + transform çš„åŠŸèƒ½ã€‚

ä¸‹é¢æ‰€æœ‰çš„æµ‹è¯•ç”¨ä¾‹å‡ä»¥ vue.global.js æ‰“åŒ…ä¹‹åçš„æ–‡ä»¶ï¼Œè¿è¡Œç»“æœä¸ºå‰æï¼š

#+begin_src js
  const test = `simple text`;

  const result = compile(test.trim(), {
    sourceMap: true,
    filename: "foo.vue",
  });
  console.log(result, "xx");
#+end_src

é€šè¿‡ä¿®æ”¹ test å€¼æ¥å¾—åˆ°çœŸå®çš„ render å‡½æ•°ã€‚

å®Œæˆäº† 01-simple text ç”¨ä¾‹ä¹‹åå‘ç°æŒ‰ç…§ parse.spec.ts å¯èƒ½ä¸å¤ªç†æƒ³ï¼Œæ¯•ç«Ÿ parse éƒ¨
åˆ†çš„ç”¨ä¾‹æœ‰ç‚¹å¤šï¼Œå¦‚æœæŒ‰ç…§é‚£ä¸ªæ¥è¿™éƒ¨åˆ†ä¹Ÿå°†ä¼šå¾ˆæ¼«é•¿ï¼Œæ€è€ƒè‰¯ä¹…åº”è¯¥è¿˜æ˜¯æŒ‰ç…§
compile.spec.ts ä¸­çš„ç”¨ä¾‹è¿›è¡Œæ‹†åˆ†ä¹‹åå³ç®€å…¥éš¾å¼å»é€šè¿‡è¯¥ç”¨ä¾‹ã€‚

å®Œæ•´ç”¨ä¾‹ï¼š

#+begin_src js
  const source = `
  <div id="foo" :class="bar.baz">
    {{ world.burn() }}
    <div v-if="ok">yes</div>
    <template v-else>no</template>
    <div v-for="(value, index) in list"><span>{{ value + index }}</span></div>
  </div>
  `.trim()
#+end_src

** 05-interpolation, v-if, props
:PROPERTIES:
:COLUMNS:  %CUSTOM_ID[(Custom Id)]
:CUSTOM_ID: test-cc-05
:END:

#+begin_src js
  code = `
  <div id="foo" :class="bar.baz">
  {{ world.burn() }}
  <div v-if="ok">yes</div>
  </div>`
#+end_src

å¢åŠ äº† ~<div v-if="ok"></div>~

ast: åœ¨ç»è¿‡ parse.ts ä¹‹ååº”è¯¥å…·å¤‡çœ‹åˆ°æ¨¡æ¿èƒ½å¤Ÿåˆ†æå‡º ast ç»“æ„èƒ½åŠ›ã€‚
#+begin_src js
  {
    type: 0, // ROOT
    children: [
      { // div#foo
        type: 1, // ELEMENT
        tag: 'div',
        tagType: 0, // Start
        props: [
          { // id
            type: 6, // ATTRIBUTE
            name: 'id',
            value: {
              type: 2, // TEXT
              content: 'foo'
            }
          },
          { // :class
            type: 7, // DIRECTIVE
            name: 'bind',
            arg: {
              type: 4, // SIMPLE_EXPRESSION
              content: 'class',
              isStatic: true, // é™æ€å‚æ•°å
              isConstant: true
            }, // å‚æ•°å class
            exp: {
              type: 4, // SIMPLE_EXPRESSION
              content: "bar.baz",
              isStatic: false,
              isConstant: false
            }, // è¡¨è¾¾å¼ bar.baz
            modifiers: [], // ä¿®é¥°ç¬¦
          }
        ],
        children: [
          { // world.burn
            type: 5, // INTERPOLATION
            content: {
              content: "world.burn()",
              isStatic: false,
              isConstant: false,
              type: 4, // SIMPLE_EXPRESSION
            },
          },
          { // " " ç©º
            type: 2, // TEXT
            content: ' '
          },
          { // div v-if
            type: 1, // ELEMENT
            tag: 'div',
            tagType: 0, // Start
            children: [
              { // yes
                type: 2, // TEXT
                content: "yes"
              }
            ],
            props: [
              {
                type: 7, // DIRECTIVE
                name: 'if',
                exp: {
                  type: 4,
                  content: "ok",
                  isStatic: false,
                  isConstant: false
                },
                modifiers: []
              }
            ]
          }
        ]
      }, // div#foo
    ],
    codegenNode: undefined
  }
#+end_src

vue.global ç»“æœï¼š
#+begin_src js
  (function anonymous() {
    const _Vue = Vue;
    const {
      createVNode: _createVNode,
      createCommentVNode: _createCommentVNode,
      createTextVNode: _createTextVNode,
    } = _Vue;

    const _hoisted_1 = { key: 0 };

    return function render(_ctx, _cache) {
      with (_ctx) {
        const {
          toDisplayString: _toDisplayString,
          createVNode: _createVNode,
          openBlock: _openBlock,
          createBlock: _createBlock,
          createCommentVNode: _createCommentVNode,
          createTextVNode: _createTextVNode,
        } = _Vue;

        return (
          _openBlock(),
          _createBlock(
            "div",
            {
              id: "foo",
              class: bar.baz,
            },
            [
              _createTextVNode(
                _toDisplayString(world.burn()) + " ",
                1 /* TEXT */
              ),
              ok
                ? (_openBlock(), _createBlock("div", _hoisted_1, "yes"))
                : _createCommentVNode("v-if", true),
            ],
            2 /* CLASS */
          )
        );
      }
    };
  });
#+end_src

è¿™é‡Œæœ‰å‡ ä¸ªä¸åŒç‚¹ï¼š

1. _createBlock ç¬¬ä¸‰ä¸ªå‚æ•° children å˜æˆäº†æ•°ç»„ï¼Œä¸”ä½¿ç”¨äº† _createTextVNode() åˆ›å»º
   è™šæ‹ŸèŠ‚ç‚¹
2. å°±æ˜¯å¤šäº†ä¸ªæ–°å¢çš„é‚£ä¸ª ~div v-if~ èŠ‚ç‚¹
3. patchFlag çš„å˜åŒ–


å…ˆçœ‹ä¸‹ä¿®æ”¹ä¹‹å‰çš„ç»“æœï¼š

#+begin_src js
  (function anonymous() {
    return function render(_ctx, _cache) {
      with (_ctx) {
        const {
          toDisplayString: _toDisplayString,
          createVNode: _createVNode,
          camelize: _camelize,
          createTextVNode: _createTextVNode,
          openBlock: _openBlock,
          createBlock: _createBlock,
        } = _Vue;

        return (
          _openBlock(),
          _createBlock(
            "div",
            {
              id: "foo",
              class: bar.baz,
              [_camelize(prop_name)]: bar.bax,
            },
            [, _createVNode("div", null, "yes")]
          )
        );
      }
    };
  });
#+end_src

å·®å¼‚ç‚¹ï¼š

1. æ²¡æœ‰ render å‡½æ•°å¤–çš„è§£æ„
2. æ²¡æœ‰ render å‡½æ•°å¤–çš„ ~const _hoisted_1 = { key: 0 };~
3. æ²¡æœ‰ ~_createCommentVNode~
4. children é‡Œé¢çš„å·®å€¼èŠ‚ç‚¹ä¸¢å¤±äº†
5. div v-if èŠ‚ç‚¹å¤„ç†é”™è¯¯

å…ˆè§£å†³å·®å€¼é—®é¢˜(ç¬¬ 4 ç‚¹)ï¼Œè¿™é‡Œæ’å€¼èŠ‚ç‚¹ä¸ºä»€ä¹ˆä¼šä¸¢å¤±ï¼Ÿ

è¡¥æ¼ï¼š
1. å®ç° [[#transform-transformif][transformIf]]

   [[#transform-createstructuraldirectivetransform][createStructuralDirectiveTransform]] åˆ›å»ºæŒ‡ä»¤(å¦‚ï¼šv-if, v-else ç­‰)ç›¸å…³çš„
   transform å‡½æ•°ï¼Œæ³¨æ„è¿™é‡Œçš„æ­£åˆ™ï¼š ~/^(if|else|else-if)$/~

   ç”±äºæŒ‡ä»¤æ˜¯å­˜åœ¨ ~node.props~ å±æ€§é‡Œé¢çš„ï¼Œè¿™é‡Œä¼šç›´æ¥éå†æ‰€æœ‰çš„å±æ€§ï¼Œæ‰¾å‡ºæ»¡è¶³æ¡ä»¶
   ~type:DIRECTIVE~ ä¸” ~prop.name~ åŒ¹é…ä¸Šé¢çš„æ­£åˆ™çš„æŒ‡ä»¤ã€‚
   
   å› ä¸ºè¿™é‡Œè¦å°†æ‰€æœ‰çš„æŒ‡ä»¤è½¬æˆåˆ†æ”¯ç±»å‹çš„ç»“æ„ã€‚

   #+begin_src js
     {
       type: 9, // IF
       branches: [{
         children: [{ /* è¿™é‡Œä¿å­˜äº†è½¬æ¢ä¹‹å‰çš„ v-if èŠ‚ç‚¹ */}]
         condition: {
           content: 'ok',
           // ...
           type: 4, // SIMPLE_EXPRESSION
         }
         // branch
         type: 10, // IF_BRANCH
       }]
     }
   #+end_src
   
   æœ€åå¤„ç†ä¹‹åå¾—åˆ°çš„ ifNode åŒ…å«æ‰€æœ‰åˆ†æ”¯ ~ifNode.branches~ ï¼Œ branch å³å½“å‰è¦å¤„
   ç†çš„åˆ†æ”¯äº¤ç»™è¿”å›çš„é‚£ä¸ª transform å‡½æ•°å¾…é€’å½’å®Œæˆä¹‹åå–å¤„ç†å¾—åˆ°è¯¥åˆ†æ”¯èŠ‚ç‚¹çš„ ~codegenNode~
   
   ç„¶åç»è¿‡é€’å½’ä¹‹åï¼Œå›æº¯è¿‡ç¨‹ä¸­ä¼šæ‰§è¡Œè¿”å›çš„é‚£ä¸ªå‡½æ•°(*transform if*) è¿›å…¥
   [[#transform-createcodegennodeforbranch][createCodegenNodeForBranch]] -> [[#transform-createchildrencodegennode][createChildrenCodegenNode]] ->
   ~createCallExpression~ åˆ›å»ºåˆ†æ”¯èŠ‚ç‚¹ codegenã€‚

2. å®ç° [[#transform-traversenode-stage3][traverseNode]] ä¸­çš„ ~IF(9)~ å’Œ ~IF_BRANCH(10)~ åˆ†æ”¯

3. å®ç° [[#codegen-generate][generate]] é˜¶æ®µçš„ if èŠ‚ç‚¹å¤„ç†

** 04-interpolation in div with props
:PROPERTIES:
:COLUMNS:  %CUSTOM_ID[(Custom Id)]
:CUSTOM_ID: test-cc-04
:END:

code: ~`<div id="foo" :class="bar.baz">{{ world.burn() }}</div>`~

è¿™ä¸ªç”¨ä¾‹å’Œ [[#test-cc-03][ç”¨ä¾‹3]] åªæœ‰ä¸€ä¸ªå±æ€§çš„å·®åˆ«ï¼Œæ‰€ä»¥è¿™é‡Œåªè¦å‚è€ƒ test 03 æ¥å®ç° div å±æ€§çš„
è§£æå’Œç¼–è¯‘å³å¯ï¼Œæ‰€æœ‰æµç¨‹å’Œæµç¨‹å›¾å¯å‚è€ƒ 03 æ¥å®ç°ã€‚

è¿˜æ˜¯è€æ–¹æ³•ï¼Œæ ¹æ®è·Ÿè¸ª vue.global debugger è¿‡ç¨‹æ¥åˆ†ææ•´ä¸ªè¿‡ç¨‹ã€‚
æœŸå¾…ç»“æœï¼š
#+begin_src js
  (function anonymous(
  ) {
    const _Vue = Vue

    return function render(_ctx, _cache) {
      with (_ctx) {
        const { toDisplayString: _toDisplayString, createVNode: _createVNode, openBlock: _openBlock, createBlock: _createBlock } = _Vue

        return (_openBlock(), _createBlock("div", {
          id: "foo",
          class: bar.baz
        }, _toDisplayString(world.burn()), 3 /* TEXT, CLASS */))
      }
    }
  })
#+end_src

[[#transform-createstructuraldirectivetransform][createStructuralDirectiveTransform(name, fn)]] å¦‚æœå­˜åœ¨å±æ€§ï¼Œéƒ½ä¼šç»è¿‡è¿™ä¸ªå‡½æ•°æ˜¯å› 
ä¸º ~if,else-if,else,for~ çš„ transform éƒ½æ˜¯é€šè¿‡è¿™ä¸ªåˆ›å»ºçš„ï¼Œæ‰€ä»¥åœ¨ç»è¿‡
[[#transform-traversenode][traverseNode]] ä¸­çš„ exitFns æ”¶é›†è¿‡ç¨‹ä¸­ä¼šæ‰§è¡Œåˆ°è¿™é‡Œã€‚

ç„¶åè¿™ä¸ªç”¨ä¾‹ä¸­å¹¶æ²¡æœ‰ v-if, v-for ç±»ä¼¼çš„åˆ†æ”¯æŒ‡ä»¤ï¼Œæ‰€ä»¥è¿™äº› transform* ä¸ä¼šè¢«æ”¶é›†
åˆ°ã€‚

~root.children[0]: div~ æ”¶é›† [[#transform-transformelement][transformElement]] ï¼ŒELEMENT ç±»å‹éœ€è¦æ”¶é›†æ¥è§£æå‡º codegenNodeã€‚

[[/img/vue3/compiler-core/compiler-test-interpolation-in-div-with-props.svg]]

æµç¨‹å›¾åˆ†æï¼šè¿™é‡Œå’Œ [[#test-cc-03][03]] å¯¹æ¯”å¤šäº†ä¸¤éƒ¨åˆ†å¤„ç†
1. transform é˜¶æ®µçš„ *props è§£æ*

   è¿™ä¸€é˜¶æ®µçš„å¤„ç†å‘ç”Ÿåœ¨ transformElement ä¸­å¯¹ props å±æ€§çš„æ£€æµ‹ï¼Œä¸€æ—¦æ£€æµ‹åˆ°æœ‰å±æ€§
   åˆ—è¡¨ï¼Œéœ€è¦ç»è¿‡ [[#transform-buildprops][buildProps]] è§£æå‡ºæ–°çš„å±æ€§å¯¹è±¡:

   buildProps ä¹‹å‰çš„ props
   #+begin_src js
     props: Array(2)
     0: // å±æ€§ id
     loc: {..., source: "id="foo""}
     name: "id"
     type: 6 // ATTRIBUTE
     value:
     content: "foo"
     loc: {..., source: ""foo""}
     type: 2 // TEXT
     1: // å±æ€§ :class
     arg:
     content: "class"
     isConstant: true
     isStatic: true
     loc: {..., source: "class"}
     type: 4 // SIMPLE_EXPRESSION
     exp:
     content: "bar.baz"
     isConstant: false
     isStatic: false
     loc: {..., source: "bar.baz"}
     type: 4 // SIMPLE_EXPRESSION
     loc: {..., source: ":class="bar.baz""}
     modifiers: []
     name: "bind"
     type: 7 // DIRECTIVE
   #+end_src

   buildProps è§£æä¹‹åï¼š

   #+begin_src js
     Return value: Object
     directives: []
     dynamicPropNames: []
     patchFlag: 2 // CLASS
     props:
     properties: Array(2)
     0:
     key: {type: 4, isConstant: false, content: "id", isStatic: true}
     type: 16 // JS_ARRAY_EXPRESSION
     value: {type: 4, isConstant: false, content: "foo", isStatic: true}
     1:
     key: {type: 4, content: "class", isStatic: true, isConstant: true}}
     type: 16
     value: {type: 4, content: "bar.baz", isStatic: false, isConstant: false,
             type: 15 // JS_PROPERTY
   #+end_src

   è¿™é‡Œé¢çš„å¤„ç†åˆ†ä¸ºä¸¤ç§ç±»å‹ï¼š 1. *ATTRIBUTE<6>* ç±»å‹ï¼Œ 2. *DIRECTIVE<7>* æŒ‡ä»¤ç±»å‹æ˜¯
   åˆ†å¼€å¤„ç†çš„ï¼Œæ™®é€šå±æ€§è°ƒç”¨ ~createObjectProperty(key, value)~ æ„å»ºæ–°çš„å¯¹è±¡ï¼ŒæŒ‡
   ä»¤å±æ€§é€šè¿‡æŒ‡ä»¤åç§°ä» ~context.directiveTransforms~ å¯¹è±¡ä¸­å–å‡ºå¯¹åº”çš„å‡½æ•°è¿›è¡Œå¤„
   ç†ï¼Œæ¯”å¦‚ ~v-bind~ å¯¹åº”å‡½æ•° [[#transform-transformbind][transformBind(prop, node, context)]] å¤„ç†ã€‚

   æ¯”å¦‚ï¼š ~id="foo"~ å¤„ç†ä¹‹åçš„
   #+begin_src js
     Return value: Object
     key: // å±æ€§å
     content: "id"
     isConstant: false
     isStatic: true
     loc: {source: "id"}
     type: 4 // SIMPLE_EXPRESSION
     type: 16 // JS_PROPERTY
     value: // å±æ€§å€¼
     content: "foo"
     isConstant: false
     isStatic: true
     loc: {source: ""foo""}
     type: 4 // SIMPLE_EXPRESSION

     // åŒ…å« key, type, value ä¸‰ä¸ªå±æ€§å€¼
   #+end_src

   æ¯”å¦‚ï¼š ~:class="bar.baz"~ å¤„ç†ä¹‹åçš„

   #+begin_src js
     Return value: Object
     props: Array(1)
     0:
     key:
     content: "class"
     isConstant: true
     isStatic: true
     type: 4 // SIMPLE_EXPRESSION
     type: 16 // JS_ARRAY_EXPRESSION
     value:
     content: "bar.baz"
     isConstant: false
     isStatic: false
     type: 4

     // åŒ…å« key, type, valueï¼Œå’Œæ™®é€šå±æ€§ç±»å‹ä¸ä¸€æ ·
     // è¿™é‡Œæ˜¯ JS_ARRAY_EXPRESSION
   #+end_src

2. generate é˜¶æ®µçš„ *props è§£æ*

   render å‡½æ•°ç”Ÿæˆé˜¶æ®µï¼Œ [[#ast-genvnodecall][genVNodeCall]] è§£æ ~codegenNode~, å…¶ä¸­æœ‰ä¸€ä¸ª
   [[#ast-gennodelist][genNodeList(nodes, ...)]] è¿™é‡Œçš„ nodes æ˜¯ ~[tag, props, children, patchFlag,
   ...]~ è¯¥ç”¨ä¾‹ä¸­ç›¸æ¯”[[#test-cc-03][ç”¨ä¾‹03]] è¿™é‡Œçš„ props ä¸æ˜¯ null ï¼Œæ‰€ä»¥åœ¨ ~genNodeList~ ä¸­ ~i = 1~
   çš„æ—¶å€™ä¼šè¿›å…¥åˆ° [[#ast-gennode][genNode(props, context)]] å»è§£æå±æ€§åˆ—è¡¨ã€‚

   è¿›å…¥ä¹‹å‰ props å€¼ï¼š
   #+begin_src js
     loc: {source: "<div id="foo" :class="bar.baz">{{ world.burn() }}</div>"}
     properties: (2) [{â€¦}, {â€¦}] // è¿™é‡Œæ˜¯ id, class ä¸¤ä¸ªå±æ€§
     type: 15 // JS_OBJECT_EXPRESSION
   #+end_src

   ç±»å‹ä¸º *JS_OBJECT_EXPRESSION<15>* åœ¨ ~genNode~ é‡Œé¢ä¼šè¿›å…¥ [[#ast-genobjectexpression][genObjectExpression(node,
   context)]] åˆ†æ”¯å°†å±æ€§è§£ææˆå¯¹è±¡ï¼Œå¦‚ï¼š ~{id: "foo", class: bar.baz}~ ã€‚

   ~genObjectExpression~ é‡Œé¢å¯¹å±æ€§çš„å¤„ç†ä¸»è¦åˆ†ä¸¤æ­¥ï¼Œå…ˆè°ƒç”¨
   [[#ast-genexpressionaspropertykey][genExpressionAsPropertyKey(node, context)]] å»å¤„ç†å±æ€§å key nodeï¼Œå®Œæˆä¹‹åï¼Œå†è°ƒ
   ç”¨ [[#ast-gennode][genNode(value, context)]] å»å¤„ç†å€¼ value node(æœ€åè¿›å…¥ [[#ast-genexpression][genExpression(node,
   context)]], å› ä¸ºç±»å‹ä¸º *SIMPLE_EXPRESSION<4>*)ã€‚

   æœ€åå¾—åˆ° ~{id: "foo", class: bar.baz}~ ä½œä¸º ~createBlock('div', ...)~ çš„ç¬¬äºŒä¸ªå‚æ•°ã€‚

ä¿®æ”¹å®Œä¹‹åè¿è¡Œç»“æœï¼š
#+begin_src js
  (function anonymous(
  ) {

    return function render(_ctx, _cache) {
      with (_ctx) {
        const { toDisplayString : _toDisplayString, createVNode : _createVNode, openBlock : _openBlock, createBlock : _createBlock } = _Vue

        return (_openBlock(), _createBlock("div", { id: "foo" }, _toDisplayString(world.burn()), 1 /* TEXT */))
      }
    }
  })
#+end_src

ç»“æœä¸æ­£ç¡®ç»“æœåˆä¸¤ç‚¹ç¼ºé™·ï¼š
1. å±æ€§æ¼æ‰äº† ~class~
2. patchFlag é‚£é‡Œä¸å¯¹ï¼Œæ­£ç¡®åº”è¯¥æ˜¯ ~3 /* TEXT, CLASS */~

æ²¡æœ‰æŠ¥é”™èƒ½èµ°é€šè¯´æ˜è‡³å°‘é€»è¾‘æ˜¯é€šçš„å‡ºç°ä¸Šé¢ä¸¤ä¸ªé—®é¢˜åŸå› ï¼Œæº¯æºèµ·æ¥ä¹Ÿå¾ˆæ¸…æ™°ï¼Œå› ä¸ºæˆ‘ä»¬
çŸ¥é“ props åœ¨ transform é˜¶æ®µæ˜¯ [[#transform-transformelement][transformElement]] é‡Œé¢ï¼Œgenerate é˜¶æ®µæ˜¯åœ¨
[[#codegen-genobjectexpression][genObjectExpression()]] ä¸­, è€Œ patchFlag ä¹Ÿæ˜¯åœ¨ ~transformElement~ å¤„ç†çš„ã€‚

é€šè¿‡åœ¨ [[#codegen-genobjectexpression][genObjectExpression()]] for å¾ªç¯ä¸­å¢åŠ æ‰“å°ï¼Œæ˜¾ç¤º properties ä¸­åªæœ‰ä¸€ä¸ª id
å±æ€§ï¼Œé‚£ä¹ˆå±æ€§è§£ææœ€åæ˜¯åœ¨ [[#transform-buildprops][buildProps]] é‡Œé¢çš„ï¼Œ bingo!!! æ²¡æœ‰å®ç° [[#transform-transformbind][transformBind]] ã€‚

é‚£ä¹ˆä¿®æ”¹ç‚¹æœ‰äºŒï¼š
1. åœ¨ compile.ts çš„ [[#compile-getbasetransformpreset][getBaseTransformPreset]] å¢åŠ æŒ‡ä»¤ transform å‡½æ•° [[#transform-transformbind][transformBind]]
2. å®ç° ~transformBind~

ä¿®æ”¹ä¹‹åï¼š
#+begin_src js
  (function anonymous(
  ) {

    return function render(_ctx, _cache) {
      with (_ctx) {
        const { toDisplayString : _toDisplayString, createVNode : _createVNode, openBlock : _openBlock, createBlock : _createBlock } = _Vue

        return (_openBlock(), _createBlock("div", {
          id: "foo",
          class: bar.baz
        }, _toDisplayString(world.burn()), 3 /* TEXT, CLASS */))
      }
    }
  })
#+end_src

*** æ‰©å±• 1ï¼šå¢åŠ  ~camel~ ä¿®é¥°ç¬¦

code: ~`<div id="foo" :class="bar.baz" :test-prop.camel="bar.bax">{{ world.burn() }}</div>`~

ç»“æœï¼š
#+begin_src js
  (function anonymous(
  ) {

    return function render(_ctx, _cache) {
      with (_ctx) {
        const { toDisplayString : _toDisplayString, createVNode : _createVNode, openBlock : _openBlock, createBlock : _createBlock } = _Vue

        return (_openBlock(), _createBlock("div", {
          id: "foo",
          class: bar.baz,
          testName: bar.bax
        }, _toDisplayString(world.burn()), 3 /* TEXT, CLASS */))
      }
    }
  })
#+end_src

å› ä¸º transformBind ä¸­æœ‰æ£€æµ‹ä¿®é¥°ç¬¦ä¸­æ˜¯å¦åŒ…å« ~camel~ ï¼Œå¦‚æœæœ‰åˆ™ä¼šè¿›è¡Œé©¼å³°è½¬æ¢ï¼Œå¦
åˆ™ä¸ä¼šè½¬è€Œæ˜¯å°† *test-prop* ç”¨å¼•å·åŒ…èµ·æ¥ï¼š ~"test-prop"~ ã€‚
*** æ‰©å±• 2ï¼šåŠ¨æ€å±æ€§ä¸”æœ‰ ~camel~ ä¿®é¥°ç¬¦

code: ~`<div id="foo" :class="bar.baz" :[prop_name].camel="bar.bax">{{ world.burn() }}</div>`~

è¿™ä¸ªæ—¶å€™éœ€è¦å®ç° transform.js ä¸­ [[#transform-createtransformcontext][createTransformContext]] ä¸­ ~context.helperString~

#+begin_src js
  helperString(name) {
    return `_${helperNameMap[context.helper(name)]}`;
  }
#+end_src

ç»“æœï¼š
#+begin_src js
  (function anonymous(
  ) {

    return function render(_ctx, _cache) {
      with (_ctx) {
        const { toDisplayString : _toDisplayString, camelize : _camelize, createVNode : _createVNode, openBlock : _openBlock, createBlock : _createBlock } = _Vue

        return (_openBlock(), _createBlock("div", {
          id: "foo",
          class: bar.baz,
          [_camelize(prop_name)]: bar.bax
        }, _toDisplayString(world.burn()), 1 /* TEXT */))
      }
    }
  })
#+end_src

ä¼šå‘ç°è¿™é‡Œå¤šè§£æ„äº†ä¸ª ~_camelize~ å‡½æ•°å‡ºæ¥ï¼Œé€šè¿‡å‡½æ•°è°ƒç”¨æ–¹å¼å»å¤„ç†åŠ¨æ€å±æ€§åã€‚
** 03-inerpolation in pure div
:PROPERTIES:
:COLUMNS:  %CUSTOM_ID[(Custom Id)]
:CUSTOM_ID: test-cc-03
:END:

test:
#+begin_src js
  const source = `<div>{{ world.burn() }}</div>`.trim();

  const result = compile(source, {
    sourceMap: true,
    filename: `foo.vue`,
  });
#+end_src

vue.global:
#+begin_src js
  (function anonymous(
  ) {
    const _Vue = Vue

    return function render(_ctx, _cache) {
      with (_ctx) {
        const { toDisplayString: _toDisplayString, createVNode: _createVNode, openBlock: _openBlock, createBlock: _createBlock } = _Vue

        return (_openBlock(), _createBlock("div", null, _toDisplayString(world.burn()), 1 /* TEXT */))
      }
    }
  })
#+end_src

å…ˆé˜¶æ®µçš„ç»“æœï¼š
#+begin_src js
  Æ’ render(_ctx, _cache) {
    with (_ctx) {
      return
    }
  } "compiled"
#+end_src

æµç¨‹å›¾ï¼š
[[/img/vue3/compiler-core/compiler-test-interpolation-in-div.svg]]

æµç¨‹åˆ†æï¼š

1. [[/vue/vue3-source-code-compiler-core-parse_ts/#parse-baseparse][baseParse(template, options)]] è§£æå‡º ast
2. [[/vue/vue3-source-code-compiler-core-compile_ts/#transform-transform][transform(ast, ...)]] é€’å½’éå†å¤„ç† root.children ç”Ÿæˆå„èŠ‚ç‚¹çš„ codegenNode

   1) [[/vue/vue3-source-code-compiler-core-compile_ts/#transform-traversenode][traverseNode(root, context)]] æ ¸å¿ƒå‡½æ•°ï¼Œç»“åˆ traverseChildren é€šè¿‡éå†+é€’å½’
      å¤„ç†æ‰€æœ‰èŠ‚ç‚¹ï¼Œæ”¶é›†å¯¹åº”çš„ transform* å‡½æ•°ï¼Œåœ¨ç»“æŸé€’å½’ä¹‹åå›æº¯è¿‡ç¨‹ä¸­æ‰§è¡Œè¿™äº›
      transform* æ¥æ”¶é›†èŠ‚ç‚¹å¯¹åº”çš„ codegenNode

      - éå†æ‰€æœ‰çš„ ~nodeTrasforms[]~ æ¥æ”¶é›†å½“å‰èŠ‚ç‚¹æ»¡è¶³æ¡ä»¶çš„ transform* å‡½æ•°
        åˆ° ~exitFns[]~ ä¸­ï¼Œæ¯”å¦‚ï¼š è¿™é‡Œçš„ ELEMENT ç±»å‹(~<div></div>~)ä¼šæ”¶é›†åˆ°
        [[/vue/vue3-source-code-compiler-core-compile_ts/#transform-transformelement][transformElement]] å’Œ [[/vue/vue3-source-code-compiler-core-compile_ts/#transform-transformtext][transformText]] ã€‚
      - ~NodeTypes.ROOT~ è¿›å…¥ [[/vue/vue3-source-code-compiler-core-compile_ts/#transform-traversechildren][traverseChildren(node, context)]] ç»§ç»­å¤„ç†
        ~root.children~ ï¼Œè¿™é‡ŒåŒæ—¶ä¼šè®°å½•æ¯ä¸ªèŠ‚ç‚¹çš„ *parent* å€¼ï¼ŒROOT ç±»å‹æ”¶é›† *transformText* ã€‚
      - ~NodeTypes.ELEMENT~ ä¹Ÿä¼šè¿›å…¥åˆ° ~traverseChildren(node, context)~ å¤„ç†
        ~node.children~ ï¼Œèµ‹å€¼ *parent*, æ”¶é›† ~transformText~ å’Œ ~transformElement~ ã€‚
      - ~NodeTypes.INTERPOLATION~ å¯¹äºæ’å€¼èŠ‚ç‚¹ï¼Œä¸ä¼šè¿›å…¥ ~traverseChildren~ è€Œæ˜¯åœ¨
        switch åˆ†æ”¯ä¸­è°ƒç”¨ ~context.helper()~ å»æ›´æ–° ~context.helpers~ ç”¨æ¥ä» ~Vue~ ä¸­
        è§£æ„å‡ºéœ€è¦çš„å‡½æ•°ã€‚
   2) TODO hoistStatic(root, context) é™æ€æå‡ç”¨çš„ï¼Œé’ˆå¯¹é™æ€èŠ‚ç‚¹æå‡åˆ°å‡½æ•°å¤–é¢(è¿™é‡Œæš‚
      æ—¶æœªæ·±å…¥ï¼Œæ²¡ç”¨åˆ°)
   3) [[/vue/vue3-source-code-compiler-core-compile_ts/#transform-createrootcodegen][createRootCodegen(root, context)]] ç”Ÿæˆ root.codegenNode ï¼Œæœ‰å¯èƒ½æ˜¯æ¥è‡ªç¬¬ä¸€
      ä¸ªä¸”å”¯ä¸€ä¸€ä¸ªå­©å­èŠ‚ç‚¹ï¼Œåˆ†ä¸ºä¸¤ä¸ªåˆ†æ”¯å…·ä½“ç»†èŠ‚ç‚¹å‡»å‡½æ•°é“¾æ¥ã€‚

   ç»è¿‡ *transform* å¤„ç†ä¹‹åçš„ ~ast~ å¯¹è±¡
   #+begin_src js
     { // å»æ‰ä¸é‡è¦çš„éƒ¨åˆ†
       "type":0, // ROOT ç±»å‹
       "children":[
         {
           "type":1, // ELEMENT ç±»å‹
           "tag":"div",
           "tagType":0, // Start
           "children":[
             {
               "type":5, // INTERPOLATION
               "content":{
                 "type":4, // SIMPLE_EXPRESSION
                 "isStatic":false,
                 "isConstant":false,
                 "content":"world.burn()",
               },
             }
           ],
           "codegenNode":{
             // è¿™é‡Œå®é™…ä¸Šæ˜¯ root.children[0] ç»è¿‡ transformElement ä¹‹åçš„ç»“æœ
             // å˜æˆäº†VNODE_CALL åœ¨ codegen-generate å¤„ç†éƒ¨åˆ†ä¼šç”¨åˆ°
             "type":13, // VNODE_CALL
             "tag":""div"",
             "children":{
               "type":5, // INTERPOLATION
               "content":{
                 "type":4, // SIMPLE_EXPRESSION
                 "isStatic":false,
                 "isConstant":false,
                 "content":"world.burn()",
               },
             },
             "patchFlag":"1 /* TEXT */", // è¿™ä¸ªç›®å‰ä¸çŸ¥é“å¹²å•¥çš„
             "isBlock":true, // å†³å®šä½¿ç”¨ openBlock/createBlock, è¿˜æ˜¯ createVNode
             "isForBlock":false,
           }
         }
       ],
       "codegenNode":{ // root æ ¹èŠ‚ç‚¹çš„
         // åœ¨ createRootCodegen ä¸­æœ‰ä¸ªå¤„ç†æ˜¯ï¼Œå¦‚æœroot.children æœ‰ä¸”åªæœ‰ä¸€ä¸ª
         // ELEMENT ç±»å‹çš„èŠ‚ç‚¹çš„æ—¶å€™ï¼Œroot.codegenNode ä¼šè¢«è¿™ä¸ªèŠ‚ç‚¹çš„ codegenNode
         // è¦†ç›–ï¼Œå³root ä½¿ç”¨å®ƒå”¯ä¸€çš„å­©å­èŠ‚ç‚¹çš„ codegenNode
         "type":13, // VNODE_CALL
         "tag":""div"",
         "children":{
           "type":5,
           "content":{
             "type":4,
             "isStatic":false,
             "isConstant":false,
             "content":"world.burn()",
           },
         },
         "patchFlag":"1 /* TEXT */",
         "isBlock":true,
         "isForBlock":false,
       },
     }
   #+end_src

3. [[/vue/vue3-source-code-compiler-core-compile_ts/#codegen_generate][generate(ast, ...)]] ç”Ÿæˆä»£ç ç‰‡æ®µ -> ~new Function(context.code)~

   1) [[/vue/vue3-source-code-compiler-core-compile_ts/#codegen-genfunctionpreamble][genFunctionPreamble(ast, context)]] ä¸»è¦ä½¿ç”¨æ¥æ£€æµ‹ç¯å¢ƒä»è€Œå¯¼å…¥ Vue å®ä¾‹
      (å¦‚ï¼š~const _Vue = Vue~)ï¼Œæœ€å render å‡½æ•°çš„ ~`return `~ ä¹Ÿæ˜¯è¿™é‡Œç”Ÿæˆçš„ã€‚
   2) [[/vue/vue3-source-code-compiler-core-compile_ts/#codegen-gennode][genNode(ast.codegenNode, context)]] å¯¹æ¯ä¸ª ast èŠ‚ç‚¹ç»“æ„è¿›è¡Œå¤„ç†ï¼Œç”Ÿæˆå¯¹åº”çš„
      Render å‡½æ•°ç›¸å…³éƒ¨ä»¶ã€‚
   3) [[eww:/vue/vue3-source-code-compiler-core-compile_ts/#headline-39][genVNodeCall(node, context)]] ç”ŸæˆèŠ‚ç‚¹çš„å‚æ•°ï¼Œè°ƒç”¨å‡½æ•°ä¹‹ç±»çš„ï¼Œå¦‚ï¼š
      ~openBlock()~ , ~createBlock(...)~ åŠå‚æ•°åˆ—è¡¨ ~createBlock(tag, props,
      children, patchFlag, ...)~ ï¼ŒæŒ‡ä»¤ç­‰éƒ¨ä»¶ã€‚
   4) patchFlag æ˜¯åœ¨ [[/vue/vue3-source-code-compiler-core-compile_ts/#transform-transformelement][transformElement]] é‡Œé¢å¤„ç†å€¼çš„ã€‚

      ç»è¿‡ *generate* ä¹‹åç”Ÿæˆçš„ ~render~ å‡½æ•°ï¼š

      #+begin_src js
        (function anonymous(
        ) {
          const _Vue = Vue

          return function render(_ctx, _cache) {
            with (_ctx) {
              const { toDisplayString: _toDisplayString, createVNode: _createVNode, openBlock: _openBlock, createBlock: _createBlock } = _Vue

              return (_openBlock(), _createBlock("div", null, _toDisplayString(world.burn()), 1 /* TEXT */))
            }
          }
        })
      #+end_src

      ~render({ world: { burn() { return `burn the world !` }}})~ æ‰§è¡Œä¹‹åå¾—åˆ°çš„
      VNode èŠ‚ç‚¹ï¼š

      #+begin_src js
        {
          "_isVNode":true,
          "type":"div",
          "props":null,
          "key":null,
          "ref":null,
          "scopeId":null,
          "children":"burn the world !",
          "component":null,
          "suspense":null,
          "dirs":null,
          "transition":null,
          "el":null,
          "anchor":null,
          "target":null,
          "targetAnchor":null,
          "shapeFlag":9,
          "patchFlag":1,
          "dynamicProps":null,
          "dynamicChildren":[

          ],
          "appContext":null
        }
      #+end_src
** 02-pure interpolation ç¬¬ä¸€ä¸ªå­©å­èŠ‚ç‚¹
:PROPERTIES:
:COLUMNS:  %CUSTOM_ID[(Custom Id)]
:CUSTOM_ID: test-cc-02
:END:

~{{ world.burn() }}~

æµ‹è¯•ï¼š
#+begin_src js
  const test01 = `{{ world.burn() }}`;

  const result = compile(test01.trim(), {
    sourceMap: true,
    filename: "foo.vue",
  });
  console.log(result, "xx");
#+end_src

vue.global ç»“æœï¼š
#+begin_src js
  Æ’ render(_ctx, _cache) {
    with (_ctx) {
      const { toDisplayString: _toDisplayString } = _Vue

      return _toDisplayString(world.burn())
    }
  }
#+end_src

[[#test-cc-01][01-simple text]] é˜¶æ®µä»£ç è¿”å›çš„ç»“æœ:

#+begin_src js
  Æ’ render(_ctx, _cache) {
    with (_ctx) {
      return  // è¿™é‡Œæ²¡ä»»ä½•ä¸œè¥¿
    }
  }
#+end_src

é€šè¿‡[[#test-cc-01][ç”¨ä¾‹ 01]] å¤§æ¦‚çš„å®Œæˆäº†ä¸€ä¸ªæ¯”è¾ƒå®Œæ•´çš„ç¼–è¯‘è¿‡ç¨‹ï¼Œè¦é€šè¿‡è¯¥ç”¨ä¾‹åº”è¯¥åªéœ€è¦åœ¨è¿™è¿‡ç¨‹ä¸­å¢
åŠ å¯¹æ’å€¼çš„å¤„ç†å³å¯ã€‚

å¤„ç†æ­¥éª¤(é€šè¿‡ç”¨ä¾‹ 01 æ€»ç»“å‡ºçš„æ­¥éª¤)ï¼š

[[#compile-basecompile][baseCompile]] -> [[/vue/vue3-source-code-compiler-core-parse_ts/#parse-baseparse][baseParse]] -> [[#compile-getbasetransformpreset][getBaseTransformPreset]] å¾—åˆ° transform å‡½æ•° ->
[[#transform-transform][transform]] -> [[#codegen-generate][generate]]

1. [[/vue/vue3-source-code-compiler-core-parse_ts/#parse-baseparse][baseParse]] -> ast
2. [[#compile-getbasetransformpreset][getBaseTransformPreset]] -> è¿™é‡Œå¹¶æ²¡æœ‰ä»€ä¹ˆ transformInterpolationï¼Œæ’å€¼å¹¶æ²¡æœ‰
   å¯¹åº”çš„ transform å‡½æ•°ï¼Œè€Œæ˜¯ç›´æ¥åœ¨ generate ä¸­ç»“åˆ ~ast.helpers~ å¤„ç†ã€‚
3. [[#transform-transform][transform]] -> [[#transform-createtransformcontext][createTransformContext]] -> [[#transform-traversenode][traverseNode]] -> [[#transform-createrootcodegen][createRootCodegen]] -> ...

   è¿™ä¸€æ­¥éœ€è¦å¤„ç†çš„åº”è¯¥åªæœ‰ [[#transform-traversenode][traverseNode]] éœ€è¦ä¿®æ”¹ï¼Œåœ¨ switch é‡Œå¢åŠ 
   INTERPOLATION åˆ†æ”¯ï¼Œå› ä¸º [[#codegen-createrootcodegen][createRootCodegen]] é‡Œé¢ root å¦‚æœåªæœ‰ä¸€ä¸ªå­©å­çš„æƒ…å†µ
   ä¸‹ä¼šå’Œ[[#test-cc-01][ç”¨ä¾‹ 01]] ä¸€æ ·ç›´æ¥èµ‹å€¼ ~context.codegenNode = root.children[0]~

4. [[#codegen-generate][generate]] -> [[#codegen-createcodegencontext][createCodegenContext]] -> [[#codegen-genfunctionpreamble][genFunctionPreamble]] é»˜è®¤æ˜¯ function æ¨¡
   å¼ -> push ~function render(_ctx, _cache) {~ -> push ~with (_ctx)~ -> ...
   -> [[#codegen-gennode][genNode(ast.codegenNode, context)]]

   è¿™é‡Œéœ€è¦ä¿®æ”¹çš„ç‚¹åº”è¯¥åªæœ‰ genNode é‡Œé¢ï¼Œä¹Ÿæ˜¯å¢åŠ  INTERPOLATION switch åˆ†æ”¯ï¼Œ
   å¤„ç†æ’å€¼éƒ¨åˆ†çš„ä»£ç ã€‚


æœ‰äº†ä¸Šé¢çš„åˆæ­¥åˆ†æï¼Œè¿™é‡Œå¯ä»¥æ¯”è¾ƒæ˜ç¡®çš„çŸ¥é“éœ€è¦ä¿®æ”¹çš„ç‚¹ï¼š

1. DONE  *traverseNode* ä¸­å¢åŠ  INTERPOLATION åˆ†æ”¯
2. DONE  *genNode* ä¸­å¢åŠ  INTERPOLATION åˆ†æ”¯
3. DONE  *genNode* ä¸­å¢åŠ  SIMPLE_EXPRESSION åˆ†æ”¯å¤„ç†æ’å€¼å†…çš„è¡¨è¾¾å¼


+ä¿®æ­£ï¼šäº‹å®ä¸Šå¹¶æ²¡æœ‰ transformInterpolation+ :facepalm::facepalm::facepalm::facepalm:

ä¿®æ”¹å®Œä¹‹åæŠ¥é”™ï¼š
#+begin_example
transform.js:184 Uncaught TypeError: Cannot read property 'length' of undefined
    at traverseChildren (transform.js:184)
    at traverseNode (transform.js:119)
    at traverseChildren (transform.js:192)
    at traverseNode (transform.js:119)
    at transform (transform.js:133)
    at baseCompile (compile.js:37)
    at compile.html:12
#+end_example

æ ¹æ®æŠ¥é”™å®šä½åˆ°ï¼Œåœ¨è§£æ root.children[0] çš„æ—¶å€™ç»è¿‡ [[#transform-traversechildren][traverseChildren]] é‡Œé¢æ—¶å€™çš„
parent.children å€¼ä¸º undefinedã€‚

åŸå› æ˜¯ traverseNode é‡Œé¢çš„ NodeTypes.INTERPOLATION åˆ†æ”¯æ²¡æœ‰åŠ  break å¯¼è‡´çš„ï¼ŒåŠ ä¸Š
ä¹‹åï¼š

#+begin_src js
  Æ’ render(_ctx, _cache) {
    with (_ctx) {
      const { toDisplayString : _toDisplayString } = _Vue

      return
    }
  } "compiled"
#+end_src

å’Œæ­£ç¡®ç»“æœç›¸æ¯”å°‘äº†ç‚¹ä¸œè¥¿ ~return _toDisplayString(world.burn())~

1. with å†…çš„è§£æ„æ¥æºï¼š

   #+begin_src js
     function generate() {
       // ...
       if (hasHelpers) {
         // æ¯”å¦‚ï¼šæ’å€¼å¤„ç†æ—¶ç”¨åˆ° TO_DISPLAY_STRING helper
         // ä¸ºäº†é¿å…å‘½åå†²çªï¼Œè¿™é‡Œéƒ½éœ€è¦å°†ä»–ä»¬é‡å‘½å

         // traverseNode é‡Œé¢ context.help(helper)
         push(
           `const { ${ast.helpers
               .map((s) => `${helperNameMap[s]} : _${helperNameMap[s]}`)
               .join(", ")} } = _Vue`
         );

         push("\n");
         newline();
       }
       // ...
     }
   #+end_src

2. ç¼ºå°‘çš„ ~return _toDisplayString(world.burn())~

   - [[#codegen-generate][generate]] ä¸­æœ€å push `return `

   - æ‰§è¡Œ [[#codegen-gennode][genNode(ast.codgenNode, context)]] å¤„ç†ç¼ºå°‘çš„éƒ¨åˆ†

     #+begin_src js
       {type: 5, content: {â€¦}, loc: {â€¦}}
       content:
       content: "world.burn()"
       isConstant: false
       isStatic: false
       loc: {start: {â€¦}, end: {â€¦}, source: "world.burn()"}
       type: 4 // SIMPLE_EXPRESSIONï¼Œç¬¬äºŒæ­¥
       loc: {start: {â€¦}, end: {â€¦}, source: "{{ world.burn() }}"}
       type: 5 // INTERPOLATIONï¼Œç¬¬ä¸€æ­¥
     #+end_src

     1) node ç±»å‹é¦–å…ˆæ˜¯ INTERPOLATION ï¼Œè¿›å…¥ [[#codegen-geniinterpolation][genInterpolation(node, context)]]

        #+begin_src js
          function genInterpolation(node, context) {
            const { push, helper, pure } = context;

            if (pure) push(PURE_ANNOTATION);

            // è¿™é‡Œä» helpers é‡Œé¢å–å‡º toDisplayString
            push(`${helper(TO_DISPLAY_STRING)}(`);

            // è¿™é‡Œç”Ÿæˆ `world.burn()` SIMPLE_EXPRESSION ç±»å‹
            genNode(node.content, context);
            push(`)`);
          }
        #+end_src

     2) å– node.content è°ƒç”¨ [[#codegen-gennode][genNode(node.content, context)]] ç”Ÿæˆ `world.burn()`
        è¡¨è¾¾å¼ã€‚

        è¿›å…¥ ~switch node.type === NodeTypes.SIMPLE_EXPRESSION~ åˆ†æ”¯ï¼Œè°ƒç”¨
        [[#codegen-genexpression][genExpression(node, context)]]

:sunflower: Perfect: æœ€åç»“æœï¼š

#+begin_src js
  Æ’ render(_ctx, _cache) { // generate
    with (_ctx) { // useWithBlock
      const { toDisplayString : _toDisplayString } = _Vue // ast.helpers

      return _toDisplayString(world.burn()) // genNode -> genInterpolation -> genExpression
    }
  } // "compiled"
#+end_src

å®Œæ•´æµç¨‹å›¾ï¼š

[[/img/vue3/compiler-core/compiler-test-pure-interpolation.png]]

** 01-simple text
:PROPERTIES:
:COLUMNS:  %CUSTOM_ID[(Custom Id)]
:CUSTOM_ID: test-cc-01
:END:

compiledï¼š
#+begin_src js
  (function anonymous(
  ) {

    return function render(_ctx, _cache) {
      with (_ctx) {
        return "simple text"
      }
    }
  })
#+end_src

ä¹Ÿå°±æ˜¯è¯´ *"simple text"* æœ€åè½¬å˜æˆçš„ render å‡½æ•°å¦‚ä¸Šæ‰€ç¤ºã€‚

æˆ‘ä»¬çš„ç¬¬ä¸€æ­¥å°±æ˜¯å¦‚ä½•æ¥å®ç° compile å’Œ transform èƒ½å¾—åˆ°è¿™æ ·çš„ç»“æœï¼Œè¿™å°†æ˜¯è¯¥æ¨¡å—å®Œ
æˆç¬¬ä¸€æ­¥ ğŸ†™ ğŸ†™ ğŸ†™ ğŸ†™ ğŸ†™ ğŸ†™ ğŸ†™ ğŸ†™ ğŸ†™ ğŸ†™

parse ä¹‹åçš„ ast:
#+begin_src js
  {type: 0, children: Array(1), loc: {â€¦}, helpers: Array(0), components: Array(0), â€¦}
  cached: 0
  children: Array(1)
  0:
  content: "simple text"
  loc: {start: {â€¦}, end: {â€¦}, source: "simple text"}
  type: 2
  length: 1
  codegenNode: undefined
  components: []
  directives: []
  helpers: []
  hoists: []
  imports: []
  loc: {start: {â€¦}, end: {â€¦}, source: "simple text"}
  temps: 0
  type: 0
#+end_src


åœ¨å®Œæˆ [[#transform-transformtext][transformText]] ä¹‹åï¼Œå‘ç° result.code æ˜¯ç©ºçš„ï¼Œè¿˜ä»¥ä¸ºæ˜¯è¿™é‡Œé¢å®ç°é—®é¢˜çš„ï¼Œå…¶
å®æ˜¯ [[#codegen-generate][generate]] å‡½æ•°è¿˜æ²¡å®ç°çš„åŸå› ã€‚

æ‰€æœ‰éœ€è¦æ”¯æŒçš„å‡½æ•°éƒ½å®Œæˆä¹‹åï¼š

#+begin_example
{ast: {â€¦}, code: "function render(_ctx, _cache) {â†µ with (_ctx) {â†µ  return "simple text"}}", map: ""}
  ast: {type: 0, children: Array(1), loc: {â€¦}, helpers: Array(0), components: Array(0), â€¦}
    code: "function render(_ctx, _cache) {â†µ with (_ctx) {â†µ  return "simple text"}}"
    map: ""
#+end_example

ä¼šå‘ç°æœ€ç»ˆçš„ code å³æˆ‘ä»¬æƒ³è¦çš„ render å‡½æ•°ï¼Œå’Œç”¨ vue.global.js ç”Ÿæˆçš„ä¸€è‡´ã€‚

å¦‚æœéœ€è¦å°†è½¬æˆå‡½æ•°ï¼Œè¿™ä¸ªéœ€è¦ç”¨åˆ° compileToFunction è¿™ä¸ªä¸åœ¨æˆ‘ä»¬è¿™ä¸ªè®¨è®ºèŒƒå›´ï¼Œå…¶
å®é‡Œé¢ä¹Ÿå¾ˆç®€å•ï¼Œç›´æ¥è°ƒç”¨ ~new Function(code)~ å°±è¡Œäº†ï¼Œæ¥çœ‹ä¸‹ï¼š

#+begin_src js
  import { baseCompile as compile } from "../compile.js";

  const source = `simple text`.trim();

  const result = compile(source, {
    sourceMap: true,
    filename: `foo.vue`,
  });
  const render = new Function(result.code);
  console.log(render, "compiled");
#+end_src

è¾“å‡ºï¼š
#+begin_example
Æ’ anonymous(
) {
function render(_ctx, _cache) {
 with (_ctx) {
  return "simple text"}}
} "compiled"
#+end_example

ç„¶åä¼šå‘ç°ç»“æœå¥½åƒä¸å¤ªå¯¹ï¼Œé¦–å…ˆ render ä¼šè¢«ä¸€ä¸ªåŒ¿åå‡½æ•°åŒ…èµ·æ¥ï¼Œè¿™ä¸ªæ˜¯æ²¡é—®é¢˜çš„ï¼Œä½†
æ˜¯è²Œä¼¼åŒ¿åå‡½æ•°æ²¡æœ‰ç»“æŸçš„ *}* è¿™ä¸ªæˆ‘æƒ³é—®é¢˜è‚¯å®šå¤„åœ¨äº† [[#codegen-generate][generate]] é‡Œé¢ã€‚

å…¶å®æ˜¯å› ä¸º [[#codegen-createcodgencontext][createCodgenContext]] é‡Œé¢çš„ å‡½æ•°æ²¡æœ‰å®ç°ï¼Œå¦å¤–è¿™æ ·æ˜¯ä¸å¯¹çš„ï¼Œå› ä¸º ~new
Function(code)~ ä¼šå°† code ç”¨ä¸€ä¸ªåŒ¿åå‡½æ•°æ¥åŒ…è£¹èµ·æ¥ï¼Œå› æ­¤æƒ³è¦å¾—åˆ° render å‡½æ•°ï¼Œå¿…
é¡»æ˜¯ä»¥ return å½¢å¼è¿”å›ï¼Œå› æ­¤è¿™é‡Œè¿˜æœ‰ä¸ªé—æ¼çš„åœ°æ–¹: [[#codegen-genfunctionpreamble][genFunctionPreamble]] éœ€è¦å»å®
ç°ï¼Œè¿™é‡Œé¢æœ€åä¼š push ä¸€ä¸ª return åˆ° code å¼€å¤´ã€‚

æ›´æ–°åè¾“å‡ºï¼š
#+begin_src js
  Æ’ anonymous(
  ) {

    return function render(_ctx, _cache) {
      with (_ctx) {
        return "simple text"
      }
    }
  }
#+end_src

åœ¨å®ç° genFunctionPreamble ä¹‹åï¼Œè‡³æ­¤å®Œæˆäº†ä¸€ä¸ªå¾—åˆ° render å‡½æ•°çš„å®Œæ•´è¿‡ç¨‹ã€‚

ä¸‹é¢å°†ä½¿ç”¨æµç¨‹å›¾æ–¹å¼è¿›è¡Œå›é¡¾ï¼Œåˆ†ææ•´ä¸ªè¿‡ç¨‹ã€‚

[[/img/vue3/compiler-core/compiler-test-simple-text.png]]

* å‡½æ•°åˆ—è¡¨
** compile.ts
*** baseCompile(template, options)
:PROPERTIES:
:COLUMNS:  %CUSTOM_ID[(Custom Id)]
:CUSTOM_ID: compile-basecompile
:END:

å°† template è§£ææˆ render å‡½æ•°ï¼Œé‡ç‚¹æ­¥éª¤:

1. [[vue/vue3-source-code-compiler-core-parse_ts/][baseParse(template, options)]] å°†å­—ç¬¦ä¸²æ¨¡æ¿è§£ææˆ AST å¯¹è±¡ã€‚
2. [[#transform-transform][transform(ast, ...)]] å°† AST è¿›ä¸€æ­¥è½¬æ¢å¤„ç†
3. å°†è½¬æ¢åçš„ ast è°ƒç”¨ codegen çš„ generate æ–¹æ³•ç”Ÿæˆ render ã€‚

#+begin_src js
  export function baseCompile(template, options) {
    const isModuleMode = options.mode === "module";

    // ... ç•¥å»é”™è¯¯âå¤„ç†
    const prefixIdentifiers =
          !__BROWSER__ && (options.prefixIdentifiers === true || isModuleMode);

    // 1. baseParse å¾—åˆ° AST å¯¹è±¡ï¼Œä¸¤ç§æƒ…å†µï¼š1. æœªè§£æçš„æ¨¡æ¿ï¼Œ2. ä»¥è§£æä¹‹åçš„ ast å¯¹è±¡
    const ast =
          typeof template === "string" ? baseParse(template, options) : template;

    // 2. å–å‡ºæ‰€æœ‰ node å’Œ directive çš„ transforms
    const [nodeTransforms, directiveTransforms] = getBaseTransformPreset(
      prefixIdentifiers
    );

    // 3. è¿›è¡Œè½¬æ¢ï¼Œè°ƒç”¨ transform
    transform(ast, {
      // åˆå¹¶é€‰é¡¹
      ...options, // è°ƒç”¨ baseCompile æ—¶å€™çš„ç¬¬äºŒä¸ªå‚æ•°
      prefixIdentifiers, // è¿˜ä¸çŸ¥é“æ˜¯å¹²å•¥çš„???
      // èŠ‚ç‚¹è½¬æ¢å™¨åˆå¹¶ï¼Œå¤–éƒ¨è½¬æ¢å™¨ä¼˜å…ˆï¼Œå³ä½¿ç”¨è€…å¯è‡ªå®šä¹‰è‡ªå·±çš„è½¬æ¢å™¨
      nodeTransforms: [...nodeTransforms, ...(options.nodeTransforms || {})],
      // æŒ‡ä»¤è½¬æ¢å™¨ï¼ŒåŒä¸Šã€‚
      directiveTransforms: [
        ...directiveTransforms,
        ...(options.directiveTransforms || {}),
      ],
    });

    // 4. è°ƒç”¨ generate ç”Ÿæˆ render å‡½æ•°çš„ codegen å¹¶è¿”å›ï¼Œè¿™å°±æ˜¯æˆ‘ä»¬éœ€è¦çš„ç»„ä»¶æ¸²
    // æŸ“å‡½æ•°
    return generate(ast, {
      ...options,
      prefixIdentifiers,
    });
  }
#+end_src

è¿™ä¹Ÿæ˜¯é™¤äº†é”™è¯¯å¤„ç†ä¹‹åçš„å®Œæ•´çš„ baseCompile å‡½æ•°å®ç°ã€‚
*** getBaseTransformPreset(prefixIdentifiers: boolean)
:PROPERTIES:
:COLUMNS:  %CUSTOM_ID[(Custom Id)]
:CUSTOM_ID: compile-getbasetransformpreset
:END:

åˆå¹¶æ‰€æœ‰ transformï¼Œè¿”å›ä¸€ä¸ª ~TransformPreset~ ç±»å‹çš„æ•°ç»„

**** stage-2:
:PROPERTIES:
:COLUMNS:  %CUSTOM_ID[(Custom Id)]
:CUSTOM_ID: compile-getbasetransformpreset-stage-2
:END:

å¢åŠ  transformBind æŒ‡ä»¤å¤„ç†ï¼Œå¤„ç† ~:class = "bar.baz"~ çš„æ—¶å€™éœ€è¦ç”¨åˆ°
#+begin_src js

  export function getBaseTransformPreset(prefixIdentifiers) {
    return [
      [
        // ... çœç•¥å…¶ä»–ï¼Œç¬¬ä¸€é˜¶æ®µæˆ‘ä»¬åº”è¯¥åªéœ€è¦æ–‡æœ¬è½¬æ¢
        transformText,
        ...(!__BROWSER__ && prefixIdentifiers ? [transformExpression] : []),
        transformElement,
      ],
      {
        // ...çœç•¥æŒ‡ä»¤
        bind: transformBind,
      },
    ];
  }
#+end_src
**** stage-1: [[#test-cc-01][01-simple text]]
:PROPERTIES:
:COLUMNS:  %CUSTOM_ID[(Custom Id)]
:CUSTOM_ID: compile-getbasetransformpreset-stage-1
:END:

ç¬¬ä¸€é˜¶æ®µæˆ‘ä»¬åªéœ€è¦æ–‡æœ¬è½¬æ¢ï¼Œé€šè¿‡ [[#test-cc-01][ç”¨ä¾‹ä¸€]] å³å¯ï¼Œæ‰€ä»¥è¿™é‡Œå°±åªä¿ç•™
[[transform-transformtext][transformText]] å°±å¯ä»¥äº†ï¼Œå‰©ä¸‹çš„å°±æ˜¯å»å®ç°å®ƒã€‚

#+begin_src js
  export function getBaseTransformPreset(prefixIdentifiers) {
    return [
      [
        // ... çœç•¥å…¶ä»–ï¼Œç¬¬ä¸€é˜¶æ®µæˆ‘ä»¬åº”è¯¥åªéœ€è¦æ–‡æœ¬è½¬æ¢
        transformText,
      ],
      {
        // ...çœç•¥æŒ‡ä»¤
      },
    ];
  }
#+end_src

** tranform.ts
*** transformExpression(node, context)
:PROPERTIES:
:COLUMNS:  %CUSTOM_ID[(Custom Id)]
:CUSTOM_ID: transform-transformexpression
:END:
*** transformText(node, context)
:PROPERTIES:
:COLUMNS:  %CUSTOM_ID[(Custom Id)]
:CUSTOM_ID: transform-transformtext
:END:

è¯¥å‡½æ•°ä¼šè¿”å›ä¸€ä¸ªç”¨æ¥è½¬æ¢æ–‡æœ¬èŠ‚ç‚¹ç±»å‹(~NodeTransform~)çš„å‡½æ•°ã€‚

è¿”å›å‡½æ•°åˆ†æ(~return () => { ... }~)ï¼Œä¸»è¦ç”±ä¸‰ä¸ª for æ„æˆï¼š

1. ç¬¬ä¸€ä¸ª for åµŒå¥—ç¬¬äºŒä¸ª for æ„æˆåŒé‡å¾ªç¯ï¼Œç”¨æ¥åˆå¹¶ node.children é‡Œé¢ç›¸é‚»çš„æ–‡æœ¬
   èŠ‚ç‚¹

   ç¬¬ä¸€ä¸ª For é‡Œé¢ä½¿ç”¨çš„æ˜¯ children.length åŠ¨æ€è·å–å½“å‰æ•°ç»„çš„é•¿åº¦ï¼Œç»“åˆä»£ç ä¸­çš„
   splice å’Œ j--ã€‚ä»è€Œå®Œæˆåˆå¹¶æ“ä½œã€‚

   #+begin_src js
     // 1. åŸæ¥çš„ child è¢«é‡å†™
     // 2. child, ` + `, next åˆå¹¶åˆ°äº†æ–° child.children é‡Œé¢
     currentContainer.children.push(` + `, next);
     // åˆ é™¤è¢«åˆå¹¶çš„æ–‡æœ¬èŠ‚ç‚¹
     children.splice(j, 1);
     j--; // -1 æ˜¯å› ä¸ºä¸Šé¢åˆ é™¤äº†å½“å‰å…ƒç´ ï¼Œfor å¾ªç¯è¿‡ç¨‹ä¸­é•¿åº¦æ˜¯åŠ¨æ€è·å–çš„
   #+end_src

2. ç¬¬ä¸‰ä¸ª for éå†ç¬¬ä¸€æ­¥ä¹‹åçš„ childrenï¼Œå¯¹æ¯ä¸ª child è¿›è¡Œé‡å®šä¹‰ï¼Œç±»å‹æ”¹å˜æˆ
   ~NodeTyeps.TEXT_CALL~ ç±»å‹ï¼Œå¢åŠ  codegenNode å±æ€§ã€‚


ä»£ç å®Œæ•´ç‰ˆï¼š
#+begin_src js

  export const transformText = (node, context) => {
    // æ–‡æœ¬è½¬æ¢åªèƒ½æ˜¯ä¸‹é¢å››ç§ç±»å‹
    const validTypes = [
      NodeTypes.ROOT,
      NodeTypes.ELEMENT,
      NodeTypes.FOR,
      NodeTypes.IF_BRANCH,
    ];

    // åˆæ³•ç±»å‹æ£€æµ‹
    if (validTypes.indexOf(node.type)) {
      // è¿”å›ä¸€ä¸ªå¯æ‰§è¡Œå‡½æ•°ï¼Œè®°å¾—åœ¨ transformNode å—ï¼Œè¿™ä¸ªè¿”å›çš„å‡½æ•°
      // å°†ä¼šè¢«å®ƒåœ¨ while ä¸­ æ‰§è¡Œ æ‰ã€‚
      return () => {
        const children = node.children;

        let currentContainer = undefined;
        let hasText = false;

        // åŒé‡å¾ªç¯ï¼Œåˆå¹¶æ‰€æœ‰ç›¸é‚»çš„æ–‡æœ¬èŠ‚ç‚¹
        // å¦‚ï¼š[text1, text2, element, text3, ele, text4, text5]
        // text1 å’Œ text2 ä¼šåˆå¹¶åˆ°text1
        // text3 ä¸ä¼šåˆå¹¶
        // text4 å’Œ text5 ä¼šè¢«åˆå¹¶
        for (let i = 0; i < children.length; i++) {
          const child = children[i];

          if (isText(child)) {
            // TODO æ–‡æœ¬èŠ‚ç‚¹æ‰è¿›è¡Œè§£æ
            hasText = true;
            // åˆå¹¶ç›¸é‚»çš„æ–‡æœ¬èŠ‚ç‚¹ï¼Œ text1 + text2
            for (let j = i + 1; j < children.length; j++) {
              const next = children[j];
              // ä¸‹ä¸€ä¸ªä¹Ÿæ˜¯æ–‡æœ¬èŠ‚ç‚¹çš„æ—¶å€™ï¼Œè¦å°†ä¸¤è€…åˆå¹¶
              if (isText(next)) {
                if (!currentContainer) {
                  // è¿™é‡Œç­‰äºé‡å†™äº† child çš„å¼•ç”¨ï¼Œå°†è‡ªèº« push åˆ°äº†
                  // æ–°ç»“æ„ä¸­çš„ children
                  currentContainer = children[i] = {
                    type: NodeTypes.COMPOUND_EXPRESSION,
                    loc: child.loc,
                    children: [child],
                  };
                }

                // 1. åŸæ¥çš„ child è¢«é‡å†™
                // 2. child, ` + `, next åˆå¹¶åˆ°äº†æ–° child.children é‡Œé¢
                currentContainer.children.push(` + `, next);
                // åˆ é™¤è¢«åˆå¹¶çš„æ–‡æœ¬èŠ‚ç‚¹
                children.splice(j, 1);
                j--; // -1 æ˜¯å› ä¸ºä¸Šé¢åˆ é™¤äº†å½“å‰å…ƒç´ ï¼Œfor å¾ªç¯è¿‡ç¨‹ä¸­é•¿åº¦æ˜¯åŠ¨æ€è·å–çš„
              } else {
                currentContainer = undefined;
                break;
              }
            }
          }
        }

        // é›†ä¸­ä¸æ»¡è¶³è½¬æ¢æ¡ä»¶çš„æƒ…å†µ
        if (
          // 1. æ²¡æœ‰æ–‡æœ¬å†…å®¹
          // 2. åªæœ‰ä¸€ä¸ªå­©å­èŠ‚ç‚¹
          //   2.1 ç»„ä»¶æ ¹èŠ‚ç‚¹
          //   2.2 <element> å…ƒç´ èŠ‚ç‚¹
          !hasText ||
            (children.length === 1 &&
             (node.type === NodeTypes.ROOT ||
              (node.type === NodeTypes.ELEMENT &&
               node.tagType === ElementTypes.ELEMENT)))
        ) {
          return;
        }

        // å¼€å§‹è½¬æ¢
        for (let i = 0; i < children.length; i++) {
          const chld = children[i];
          if (isText(child) || child.type === NodeTypes.COMPOUND_EXPRESSION) {
            const callArgs = [];

            // éæ–‡æœ¬èŠ‚ç‚¹ï¼Œç›´æ¥ push æ‰ï¼Œè¿™é‡Œ child.content !== ' ' çš„åŸå› åœ¨äº
            // parseChildren é‡Œé¢ while å¾ªç¯æœ€åæœ‰ä¸ªremove whitespace æ“ä½œ
            // ä¼šå°†æœ‰æ•ˆçš„ç©ºèŠ‚ç‚¹è½¬æˆä¸€ä¸ªç©ºæ ¼çš„å­—ç¬¦ä¸²ã€‚
            // createTextVNode é»˜è®¤æ˜¯ä¸€ä¸ªå•ç©ºæ ¼
            if (child.type !== NodeTypes.TEXT || child.content !== " ") {
              callArgs.push(child);
            }

            // éæœåŠ¡ç«¯æ¸²æŸ“ï¼Œä¸”éæ–‡æœ¬èŠ‚ç‚¹
            if (!context.ssr && child.type !== NodeTypes.TEXT) {
              callArgs.push(
                // TODO è¿™ä¸ªæ˜¯å¹²å˜›çš„ï¼Ÿï¼Ÿï¼Ÿ
                `${PatchFlags.TEXT} /* ${PatchFlagNames[PatchFlags.TEXT]} */`
              );
            }

            children[i] = {
              type: NodeTypes.TEXT_CALL, // æ–‡æœ¬å‡½æ•°
              content: child,
              loc: child.loc,
              codegenNode: createCallExpression(
                context.helper(CREATE_TEXT),
                callArgs
              ),
            };
          }
        }
      };
    }
  }
#+end_src

ä½¿ç”¨åˆ°çš„å¤–é¢å‡½æ•°å’Œå±æ€§ï¼š

1. CREATE_TEXTï¼š ä¸€ä¸ªç¬¦å·å±æ€§ ~export const CREATE_TEXT = Symbol(__DEV__ ? `createTextVNode` : ``);~
2. [[#ast-createcallexpression][createCallExpression(callee, args, loc)]] è¿”å› JS_CALL_EXPRESSION ç±»å‹å¯¹è±¡ã€‚
3. PatchFlags å’Œ PatchFlagNames ä¸€ä¸ªåå­—æ˜ å°„
4. isText æ–‡æœ¬èŠ‚ç‚¹ç±»å‹(æ’å€¼å’Œ text)

   #+begin_src js
     export function isText(node) {
       // æ’å€¼æˆ– text å‡è§†ä¸ºæ–‡æœ¬
       return node.type === NodeTypes.INTERPOLATION || node.type === NodeTypes.TEXT;
     }
   #+end_src


*å¯¹åº”çš„è™šæ‹ŸèŠ‚ç‚¹åˆ›å»ºå‡½æ•°ï¼š createTextVNode*
*** transform(root, options)
:PROPERTIES:
:COLUMNS:  %CUSTOM_ID[(Custom Id)]
:CUSTOM_ID: transform-transform
:END:

è°ƒç”¨çš„å‡½æ•°ï¼š
1. [[#transform-createtransformcontext][createTransformContext(root, options)]] åˆ›å»º transform è½¬æ¢å™¨ç±»å‹çš„ä¸Šä¸‹æ–‡å¯¹è±¡
2. [[#transform-traversenode][traverseNode(root, context)]] éå†æ‰€æœ‰èŠ‚ç‚¹
3. ssr æœåŠ¡ç«¯æ¸²æŸ“å¤„ç†
4. åˆå§‹åŒ– root æ ¹èŠ‚ç‚¹ä¸Šçš„ä¸€äº›å±æ€§

#+begin_src js

  export function transform(root, options) {
    const context = createTransformContext(root, options);

    traverseNode(root, context);

    if (options.hoistStatic) {
      hoistStatic(root, context);
    }

    // ... ssr å¤„ç†

    // root å±æ€§åˆå¹¶ï¼Œåˆå§‹åŒ–
    root.helpers = [...context.helpers];
    root.components = [...context.components];
    root.directives = [...context.directives];
    root.imports = [...context.imports];
    root.hoists = context.hoists;
    root.temps = context.temps;
    root.cached = context.cached;
  }
#+end_src
*** transformElement(node, context)
:PROPERTIES:
:COLUMNS:  %CUSTOM_ID[(Custom Id)]
:CUSTOM_ID: transform-transformelement
:END:

**** stage-2
**** stage-1 [[#test-cc-03][03-inerpolation in pure div]]

#+begin_src js

  export const transformElement = (node, context) => {
    if (
      !(
        // é¦–å…ˆå¿…é¡»æ˜¯ ELEMENT ç±»å‹
        (
          node.type === NodeTypes.ELEMENT &&
            // ç„¶åæ˜¯æ ‡ç­¾ç±»å‹ä¸º element æˆ–è€…æ˜¯ component ç»„ä»¶
          (node.tagType === ElementTypes.ELEMENT ||
           node.tagType === ElementTypes.COMPONENT)
        )
      )
    ) {
      return;
    }

    return function postTransformElement() {
      const { tag, props } = node;
      const isComponent = node.tagType === ElementTypes.COMPONENT;

      // è™šæ‹ŸèŠ‚ç‚¹çš„ tag ç±»å‹ï¼Œtest-03 ç›´æ¥è¿”å› `div`
      const vnodeTag = isComponent
            ? resolveComponentType(node, context)
            : `"${tag}"`;

      // æ˜¯ä¸æ˜¯åŠ¨æ€ç»„ä»¶
      const isDynamicComponent =
            typeof vnodeTag === "object" &&
            vnodeTag.callee === RESOLVE_DYNAMIC_COMPONENT;

      // TODO ... å£°æ˜ä¸€äº›å˜é‡
      let vnodeProps;
      let vnodeChildren;
      let vnodePatchFlag;
      let patchFlag = 0;
      let vnodeDynamicProps;
      let dynamicPropNames;
      let vnodeDirectives;

      // TODO shouldUseBlock
      let shouldUseBlock = false;

      if (props.length > 0) {
        // TODO
      }

      if (node.children.length > 0) {
        if (vnodeTag === KEEP_ALIVE) {
          // TODO KeepAlive
        }

        const shouldBuildAsSlots =
              isComponent &&
              // Teleport å¹¶éçœŸå®çš„ç»„ä»¶ï¼Œä¸”ä¸“ç”¨äºè¿è¡Œæ—¶å¤„ç†
              vnodeTag !== TELEPORT &&
              vnodeTag !== KEEP_ALIVE;

        // è¿™æ®µ if...else if ...else ç›®çš„æ˜¯å¾—åˆ° vnodeChildren
        if (shouldBuildAsSlots) {
          // TODO
        } else if (node.children.length === 1 && vnodeTag !== TELEPORT) {
          const child = node.children[0];
          const type = child.type;

          // åŠ¨æ€æ–‡æœ¬å­©å­èŠ‚ç‚¹æ£€æµ‹
          const hasDynamicTextChild =
                type === NodeTypes.INTERPOLATION ||
                type === NodeTypes.COMPOUND_EXPRESSION;

          if (hasDynamicTextChild && !getStaticType(child)) {
            patchFlag |= PatchFlags.TEXT;
          }

          if (hasDynamicTextChild || type === NodeTypes.TEXT) {
            vnodeChildren = child;
          } else {
            vnodeChildren = node.children;
          }
        } else {
          vnodeChildren = node.children;
        }
      }

      // TODO patchFlag & dynamicPropNames

      node.codegenNode = createVNodeCall(
        context,
        vnodeTag,
        vnodeProps,
        vnodeChildren,
        vnodePatchFlag,
        vnodeDynamicProps,
        vnodeDirectives,
        !!shouldUseBlock,
        false /* isForBlack */,
        node.loc
      );
    };
  }
#+end_src

è¿›å…¥ [[/vue/vue3-source-code-compiler-core-ast_ts/#ast-createvnodecall][createVNodeCall]] æ—¶çš„å‚æ•°å€¼ï¼š

[[http://qiniu.ii6g.com/img/20200911152142.png]]

è¿™é‡Œä¼šå°†ä¸€äº›éœ€è¦ç”¨åˆ°çš„å‡½æ•°æ·»åŠ åˆ° ~context.helpers:Set~ ä¸­ç­‰å¾…è§£æ„ï¼š

è¯¥ç”¨ä¾‹ä¸­ä¼šæœ‰ ~CREATE_VNODE~ è¢«è§£æ„å‡ºæ¥ã€‚

*** transformBind(prop, node, context)
:PROPERTIES:
:COLUMNS:  %CUSTOM_ID[(Custom Id)]
:CUSTOM_ID: transform-transformbind
:END:

æŒ‡ä»¤ä¹Ÿå±äºå±æ€§ä¸€ç§ï¼Œæ‰€ä»¥å®ƒçš„å¤„ç†æºå¤´æ˜¯åœ¨ [[#transform-transformelement][transformElement]] é‡Œé¢ã€‚

è¿™é‡Œåªä¸è¿‡æ˜¯æä¾›äº† v-bind å¤„ç†æ–¹å¼ã€‚

#+begin_src js
  export const transformBind = (dir, node, context) => {
    const { exp, modifiers, loc } = dir;

    const arg = dir.arg;

    // TODO é”™è¯¯å¤„ç†

    if (modifiers.includes("camel")) {
      if (arg.type === NodeTypes.SIMPLE_EXPRESSION) {
        if (arg.isStatic) {
          // æ¨ªçº¿ è½¬é©¼å³°å¼
          arg.content = camelize(arg.content);
        } else {
          arg.content = `${context.helperString(CAMELIZE)}(${arg.content})`;
        }
      } else {
        arg.children.unshift(`${context.helperString(CAMELIZE)}(`);
        arg.children.push(`)`);
      }
    }

    return {
      props: [
        createObjectProperty(arg, exp || createSimpleExpression("", true, loc)),
      ],
    };
  };

#+end_src
*** transformIf()
:PROPERTIES:
:COLUMNS: %CUSTOM_ID[(Custom Id)]
:CUSTOM_ID: transform-transformif
:END: 

è¿™ä¸ªå‡½æ•°æ˜¯ç”±ä¸€ç³»åˆ—çš„æ“ä½œä¹‹åæ‰è¿”å›çš„ä¸€ä¸ªå‡½æ•°ï¼Œç”¨æ¥å¤„ç† ~/^(if|else|else-if)$/~
æŒ‡ä»¤ï¼Œç”Ÿæˆå¯¹åº”åˆ†æ”¯èŠ‚ç‚¹çš„  ~codegenNode~ ã€‚

#+begin_src js
  export const transformIf = createStructuralDirectiveTransform(
    /^(if|else|else-if)$/,
    (node, dir, context) => {
      return processIf(node, dir, context, (ifNode, branch, isRoot) => {
        // èƒ½åˆ°è¿™é‡Œè¯´æ˜ v-if ä¸‹æ‰€æœ‰çš„ child éƒ½å·²ç»å¤„ç†å®Œæ¯•ï¼Œå¯ä»¥è¿”å›å¤„ç†
        // codegenNode çš„å‡½æ•°äº†
        return () => {
          console.log({ dir, isRoot });
          if (isRoot) {
            ifNode.codegenNode = createCodegenNodeForBranch(branch, 0, context);
          } else {
            // TODO
          }
        };
      });
    }
  );
#+end_src

*** createCodegenNodeForBranch(branch, index, context)
:PROPERTIES:
:COLUMNS: %CUSTOM_ID[(Custom Id)]
:CUSTOM_ID: transform-createcodegennodeforbranch
:END: 

**** stage-1 [[#test-cc-05][05-interpolation, v-if, props]]

#+begin_src js

  function createCodegenNodeForBranch(branch, index, context) {
    if (branch.condition) {
      return createConditionalExpression(
        branch.condition,
        createChildrenCodegenNode(branch, index, context),
        createCallExpression(context.helper(CREATE_COMMENT), [
          __DEV__ ? "v-if" : '""',
          "true",
        ])
      );
    } else {
      // TODO no condition
    }
  }
#+end_src
*** createChildrenCodegenNode(branch, index, context) 
:PROPERTIES:
:COLUMNS: %CUSTOM_ID[(Custom Id)]
:CUSTOM_ID: transform-createchildrencodegennode
:END: 

**** stage-1 [[#test-cc-05][05-interpolation, v-if, props]]

è¯¥é˜¶æ®µåªå®Œæˆä¸€ä¸ªå­©å­èŠ‚ç‚¹ä¸”æ˜¯ ELEMENT ç±»å‹çš„æ—¶å€™å¤„ç†ï¼Œå¦‚æœä¸æ˜¯è¿™ç§æƒ…å†µæ˜¯éœ€è¦ç”¨
fragment å°†è¿™äº› children åŒ…èµ·æ¥çš„ã€‚
#+begin_src js

  // åˆ›å»º v-if åˆ†æ”¯çš„å­©å­èŠ‚ç‚¹ï¼ŒåŒæ—¶åŠ ä¸Š key å±æ€§
  function createChildrenCodegenNode(branch, index, context) {
    const { helper } = context;
    const keyProperty = createObjectProperty(
      `key`,
      createSimpleExpression(index + ``, false)
    );

    const { children } = branch;
    const firstChild = children[0];
    // å¤šä¸ªèŠ‚ç‚¹çš„æƒ…å†µä¸‹ç”¨ fragment åŒ…èµ·æ¥
    const needFragmentWrapper =
          children.length !== 1 || firstChild.type !== NodeTypes.ELEMENT;

    if (needFragmentWrapper) {
      // TODO
    } else {
      // åªæœ‰ä¸€ä¸ªå­©å­èŠ‚ç‚¹ä¸”æ˜¯ ELEMENT
      const vnodeCall = firstChild.codegenNode;

      if (
        vnodeCall.type === NodeTypes.VNODE_CALL &&
          // ç»„ä»¶çš„ vnodes æ€»æ˜¯è¢«è¿½è¸ªä¸”å®ƒçš„å­©å­ä»¬ä¼šè¢«ç¼–è¯‘è¿›
        // slots å› æ­¤æ²¡å¿…è¦å°†å®ƒå˜æˆä¸€ä¸ª block
        (firstChild.tagType !== ElementTypes.COMPONENT ||
         vnodeCall.tag === TELEPORT)
      ) {
        // TODO
        vnodeCall.isBlock = true;
        helper(OPEN_BLOCK);
        helper(CREATE_BLOCK);
      }

      injectProp(vnodeCall, keyProperty, context);
      return vnodeCall;
    }
  }
#+end_src
*** createTransformContext(root, options)
:PROPERTIES:
:COLUMNS:  %CUSTOM_ID[(Custom Id)]
:CUSTOM_ID: transform-createtransformcontext
:END:

å•çº¯çš„æ„å»ºå’Œåˆå§‹åŒ– transform è½¬æ¢å™¨ä¸Šä¸‹æ–‡å¯¹è±¡ã€‚

**** stage-1: [[#test-cc-01][01 simple text]]

ä¸€äº›åˆå§‹åŒ–çš„å·¥ä½œï¼Œå¹¶ä¸éœ€è¦å…·ä½“å®ç°ä»€ä¹ˆï¼Œçº¯æ–‡æœ¬å¹¶æ²¡æœ‰ç”¨åˆ°ã€‚

#+begin_src js
  export function createTransformContext(
    root,
    {
      prefixIdentifiers = false,
      hoistStatic = false,
      cacheHandlers = false,
      nodeTransforms = [],
      directiveTransforms = {},
      transformHoist = null,
      isBuiltInComponent = NOOP,
      expressionPlugins = [],
      scopeId = null,
      ssr = false,
      onError = defaultOnError,
    }
  ) {
    const context = {
      // options
      prefixIdentifiers,
      hoistStatic,
      cacheHandlers,
      nodeTransforms,
      directiveTransforms,
      transformHoist,
      isBuiltInComponent,
      expressionPlugins,
      scopeId,
      ssr,
      onError,

      // state
      root,
      helpers: new Set(),
      components: new Set(),
      directives: new Set(),
      hoists: [],
      imports: new Set(),
      temps: 0,
      cached: 0,
      identifiers: {},
      scopes: {
        vFor: 0,
        vSlot: 0,
        vPre: 0,
        vOnce: 0,
      },
      parent: null,
      currentNode: root,
      childIndex: 0,

      // methods
      helper(name) {},
      helperString(name) {},
      replaceNode(node) {},
      removeNode(node) {},
      onNodeRemoved: () => {},
      addIdentifiers(exp) {},
      removeIdentifiers(exp) {},
      hoist(exp) {},
      cache(exp, isVNode = false) {},
    };

    function addId(id) {}

    function removeId(id) {}

    return context;
  }
#+end_src

**** stage-2: [[#test-cc-02][02 pure interpolation]] æ’å€¼èŠ‚ç‚¹çš„ç¼–è¯‘

#+begin_src js

  export function createTransformContext(
    root,
    { ... }
  ) {
    const context = {
      // ...
      helpers: new Set(),

      // ...

      // æ–°å¢ helper å®ç°
      helper(name) {
        context.helpers.add(name);
        return name;
      },

      // ...
    };

    function addId(id) {}

    function removeId(id) {}

    return context;
  }
#+end_src
*** createRootCodegen(root, context)
:PROPERTIES:
:COLUMNS:  %CUSTOM_ID[(Custom Id)]
:CUSTOM_ID: transform-createrootcodegen
:END:

åˆ›å»º root èŠ‚ç‚¹ä¸Šçš„ codegenNode å€¼ï¼Œè¿™ä¹Ÿæ˜¯å°†æ¥ç”¨æ¥ç¼–è¯‘æˆ render å‡½æ•°çš„æºç å­—ç¬¦ä¸²ã€‚

**** stage-1: [[#test-cc-01][01 simple text]]
#+begin_src js

  function createRootCodegen(root, context) {
    // TODO  helper
    const { children } = root;
    const child = children[0];

    if (children.length === 1) {
      // åªæœ‰ä¸€ä¸ªå­©å­èŠ‚ç‚¹

      // ä¸”å­©å­èŠ‚ç‚¹æ˜¯ä¸€ä¸ªå…ƒç´  element ç±»å‹ï¼Œå°†å®ƒæ”¾åœ¨ä¸€ä¸ªä»£ç å—é’Ÿè¿”å›
      // å¦‚ï¼š { code }
      if (isSingleElementRoot(root, child) && child.codegenNode) {
        // TODO
      } else {
        root.codegenNode = child;
      }
    } else if (children.length > 1) {
    } else {
      // æ²¡æœ‰å­©å­èŠ‚ç‚¹ï¼Œ codegen è¿”å› nullï¼Œçœ‹åˆ°æ²¡
      // 01 simple text è¿”å› null é—®é¢˜æ‰¾åˆ°æ ¹æºäº†
    }
  }
#+end_src

å®ç°å®Œè¿™ä¸ªä¹‹åå‘ç°ï¼Œgenerate é‡Œé¢çš„ [[#codegen-gennode][genNode]] è¿˜æ²¡å®ç°ï¼ŒçœŸå®ä¸¢ä¸‰è½å››~~~~ã€‚
*** createStructuralDirectiveTransform(name, fn)
:PROPERTIES:
:COLUMNS:  %CUSTOM_ID[(Custom Id)]
:CUSTOM_ID: transform-createstructuraldirectivetransform
:END:

#+begin_src js
  function createStructuralDirectiveTransform(name, fn) {
    const matches = isString(name) ? (n) => n === name : (n) => name.test(n);
    return (node, context) => {
      if (node.type === 1 /* ELEMENT */) {
        const { props } = node;
        // structural directive transforms are not concerned with slots
        // as they are handled separately in vSlot.ts
        if (node.tagType === 3 /* TEMPLATE */ && props.some(isVSlot)) {
          return;
        }
        const exitFns = [];
        for (let i = 0; i < props.length; i++) {
          const prop = props[i];
          if (prop.type === 7 /* DIRECTIVE */ && matches(prop.name)) {
            // structural directives are removed to avoid infinite recursion
            // also we remove them *before* applying so that it can further
            // traverse itself in case it moves the node around
            props.splice(i, 1);
            i--;
            const onExit = fn(node, prop, context);
            if (onExit) exitFns.push(onExit);
          }
        }
        return exitFns;
      }
    };
  }
#+end_src
*** traverseNode(node, context)
:PROPERTIES:
:COLUMNS:  %CUSTOM_ID[(Custom Id)]
:CUSTOM_ID: transform-traversenode
:END:

**** stage-1: [[#test-cc-01][01 simple text]] çœç•¥ switch é‡Œé¢çš„ä¸Šçº¿ï¼Œå› ä¸ºè¿™é‡Œåªæ˜¯çº¯æ–‡æœ¬ä¸å† case èŒƒå›´ã€‚
:PROPERTIES:
:COLUMNS:  %CUSTOM_ID[(Custom Id)]
:CUSTOM_ID: transform-traversenode-stage1
:END:

#+begin_src js

  export function traverseNode(node, context) {
    context.currentNode = node;

    const { nodeTransforms } = context;
    const exitFns = [];

    for (let i = 0; i < nodeTransforms.length; i++) {
      // è°ƒç”¨è¯¸å¦‚  transformText çš„å‡½æ•°
      const onExit = nodeTransforms[i](node, context);
      if (onExit) {
        const fns = Array.isArray(onExit) ? onExit : [onExit];
        exitFns.push(...fns);
      }

      if (!context.currentNode) {
        // å¯èƒ½è¢«ç§»é™¤äº†
        return;
      } else {
        // èŠ‚ç‚¹å¯èƒ½è¢«æ›¿æ¢è¿‡ï¼Œé‡æ–°å»ºç«‹å¼•ç”¨
        node = context.currentNode;
      }
    }

    switch (node.type) {
        // ... çœç•¥
      case NodeTypes.ROOT:
        traverseChildren(node, context);
        break;
    }

    let i = exitFns.length;
    // æ‰§è¡Œæ‰€æœ‰è½¬æ¢
    while (i--) {
      exitFns[i]();
    }
  }
#+end_src
**** stage-2: [[#test-cc-02][02 pure interpolation]] æ’å€¼èŠ‚ç‚¹çš„ç¼–è¯‘
:PROPERTIES:
:COLUMNS:  %CUSTOM_ID[(Custom Id)]
:CUSTOM_ID: transform-traversenode-stage2
:END:

å¢åŠ  INTERPOLATION ç±»å‹èŠ‚ç‚¹åˆ†æ”¯å¤„ç†ã€‚

#+begin_src js

  export function traverseNode(node, context) {
    // ...

    switch (node.type) {
        // ...

        // æ–°å¢ï¼šå¯¹æ’å€¼ç±»å‹èŠ‚ç‚¹å¤„ç†
      case NodeTypes.INTERPOLATION:
        if (!context.ssr) {
          // è¿™ä¸ªå‡½æ•°æ¥è‡ªä¸Šä¸‹æ–‡å¤„ç†ä¸­çš„ helper(name)
          context.helper(TO_DISPLAY_STRING);
        }
        break

        // ...
    }

    // ...
  }
#+end_src

ä¿®æ”¹ä¹‹åä»£ç ï¼š

#+begin_src js

  export function traverseNode(node, context) {
    context.currentNode = node;

    const { nodeTransforms } = context;
    const exitFns = [];

    for (let i = 0; i < nodeTransforms.length; i++) {
      // è°ƒç”¨è¯¸å¦‚  transformText çš„å‡½æ•°
      const onExit = nodeTransforms[i](node, context);
      if (onExit) {
        const fns = Array.isArray(onExit) ? onExit : [onExit];
        exitFns.push(...fns);
      }

      if (!context.currentNode) {
        // å¯èƒ½è¢«ç§»é™¤äº†
        return;
      } else {
        // èŠ‚ç‚¹å¯èƒ½è¢«æ›¿æ¢è¿‡ï¼Œé‡æ–°å»ºç«‹å¼•ç”¨
        node = context.currentNode;
      }
    }

    switch (node.type) {
        // ... çœç•¥
      case NodeTypes.INTERPOLATION:
        if (!context.ssr) {
          // è¿™ä¸ªå‡½æ•°æ¥è‡ªä¸Šä¸‹æ–‡å¤„ç†ä¸­çš„ helper(name)
          context.helper(TO_DISPLAY_STRING);
        }
        break;
      case NodeTypes.ROOT:
        traverseChildren(node, context);
        break;
    }

    let i = exitFns.length;
    // æ‰§è¡Œæ‰€æœ‰è½¬æ¢
    while (i--) {
      exitFns[i]();
    }
  }
#+end_src
**** stage-3: [[#test-cc-05][05-interpolation, v-if, props]]
:PROPERTIES:
:COLUMNS: %CUSTOM_ID[(Custom Id)]
:CUSTOM_ID: transform-traversenode-stage3
:END: 

å¢åŠ  IF å’Œ IF_BRANCH åˆ†æ”¯å¤„ç†ï¼š
#+begin_src js

  export function traverseNode(node, context) {
    context.currentNode = node;

    const { nodeTransforms } = context;
    const exitFns = [];

    for (let i = 0; i < nodeTransforms.length; i++) {
      // è°ƒç”¨è¯¸å¦‚  transformText çš„å‡½æ•°
      const onExit = nodeTransforms[i](node, context);
      if (onExit) {
        const fns = Array.isArray(onExit) ? onExit : [onExit];
        exitFns.push(...fns);
      }

      if (!context.currentNode) {
        // å¯èƒ½è¢«ç§»é™¤äº†
        return;
      } else {
        // èŠ‚ç‚¹å¯èƒ½è¢«æ›¿æ¢è¿‡ï¼Œé‡æ–°å»ºç«‹å¼•ç”¨
        node = context.currentNode;
      }
    }

    switch (node.type) {
      // ... çœç•¥
      case NodeTypes.INTERPOLATION:
        if (!context.ssr) {
          // è¿™ä¸ªå‡½æ•°æ¥è‡ªä¸Šä¸‹æ–‡å¤„ç†ä¸­çš„ helper(name)
          context.helper(TO_DISPLAY_STRING);
        }
        break;
      case NodeTypes.IF:
        for (let i = 0; i < node.branches.length; i++) {
          traverseNode(node.branches[i], context);
        }
        break;
      case NodeTypes.IF_BRANCH:
      case NodeTypes.ELEMENT:
      case NodeTypes.ROOT:
        traverseChildren(node, context);
        break;
    }

    let i = exitFns.length;
    // æ‰§è¡Œæ‰€æœ‰è½¬æ¢
    while (i--) {
      exitFns[i]();
    }
  }
#+end_src
*** traverseChildren(parent, context)
:PROPERTIES:
:COLUMNS:  %CUSTOM_ID[(Custom Id)]
:CUSTOM_ID: transform-traversechildren
:END:

å¤„ç† node.children å­©å­èŠ‚ç‚¹ã€‚

#+begin_src js

  export function traverseChildren(parent, context) {
    let i = 0;
    const nodeRemoved = () => {
      i--;
    };

    for (; i < parent.children.length; i++) {
      const child = parent.children[i];
      // è¿‡ç•¥æ‰å­—ç¬¦ä¸²ï¼Œåªå¤„ç† ast child
      if (typeof child === "string") continue;

      context.parent = parent;
      context.childIndex = i;
      context.onNodeRemoved = nodeRemoved;
      traverseNode(child, context);
    }
  }
#+end_src

1. éå†æ‰€æœ‰ ast ï¼Œè®©æ¯ä¸ªèŠ‚ç‚¹æŒæœ‰è‡ªçˆ¶çº§å¼•ç”¨ã€‚
2. éå†æ‰€æœ‰èŠ‚ç‚¹ï¼Œè¿›è¡Œ [[#transform-traversenode][traverseNode]]ï¼Œè§£æå‡º codegenNode å€¼

*** buildProps()
:PROPERTIES:
:COLUMNS:  %CUSTOM_ID[(Custom Id)]
:CUSTOM_ID: transform-buildprops
:END:
** codegen.ts
*** createCodgenContext(ast, context)
:PROPERTIES:
:COLUMNS:  %CUSTOM_ID[(Custom Id)]
:CUSTOM_ID: codegen-createcodegencontext
:END:
**** stage-1: [[#test-cc-01][01 simple text]]

#+begin_src js

  // æ„å»º condegen ä¸Šä¸‹æ–‡å¯¹è±¡
  function createCodegenContext(
    ast,
    {
      mode = "function",
      prefixIdentifiers = mode === "module",
      sourceMap = false,
      filename = `template.vue.html`,
      scopeId = null,
      optimizeBindings = false,
      runtimeGlobalName = `Vue`,
      runtimeModuleName = `vue`,
      ssr = false,
    }
  ) {
    const context = {
      mode,
      prefixIdentifiers,
      sourceMap,
      filename,
      scopeId,
      optimizeBindings,
      runtimeGlobalName,
      runtimeModuleName,
      ssr,
      source: ast.loc.source,
      code: ``,
      column: 1,
      line: 1,
      offset: 0,
      indentLevel: 0,
      pure: false,
      map: undefined,
      helper(key) {},
      push(code, node) {
        context.code += code;
        // TODO éæµè§ˆå™¨ç¯å¢ƒå¤„ç†ï¼Œnode ç¯å¢ƒ
      },
      indent() {
        // æ–°è¡Œç¼©è¿›
        newline(++context.indentLevel);
      },
      deindent(withoutNewLine = false) {
        if (withoutNewLine) {
          --context.indentLevel;
        } else {
          newline(--context.indentLevel);
        }
      },
      newline() {
        newline(context.indentLevel);
      },
    };

    function newline(n) {
      context.push("\n" + ` `.repeat(n));
    }

    function addMapping(loc, name) {}

    return context;
  }
#+end_src
*** generate()
:PROPERTIES:
:COLUMNS:  %CUSTOM_ID[(Custom Id)]
:CUSTOM_ID: codegen_generate
:END:

generate å‡½æ•°é›å½¢ï¼š

#+begin_src js
  export function generate(ast, options) {
    return {
      ast,
      code: "",
      map: "",
    };
  }

#+end_src

å‡½æ•°çš„ç›®çš„æ˜¯ï¼šé€šè¿‡ ast æ¥ç”Ÿæˆ codeï¼Œè¿™ä¸ª code å°†æ¥ä¼šè¢« compileToFunction è°ƒç”¨ ~new
Function(code)~ ç”Ÿæˆ render å‡½æ•°çš„ã€‚

**** stage-1: [[#test-cc-01][01 simple text]]
:PROPERTIES:
:COLUMNS:  %CUSTOM_ID[(Custom Id)]
:CUSTOM_ID: codegen-generate-stage1
:END:

#+begin_src js

  export function generate(ast, options = {}) {
    const context = createCodegenContext(ast, options);
    const {
      mode,
      push,
      prefixIdentifiers,
      indent,
      deindent,
      newline,
      scopeId,
      ssr,
    } = context;

    const hasHelpers = ast.helpers.length > 0;
    const useWithBlock = !prefixIdentifiers && mode !== "module";
    const genScopeId = !__BROWSER__ && scopeId != null && mode === "module";

    // TODO preambles
    if (!__BROWSER__ && mode === "module") {
      // TODO genModulePreamble(ast, context, genScopeId)
    } else {
      genFunctionPreamble(ast, context);
    }

    if (genScopeId && !ssr) {
      push(`const render = ${PURE_ANNOTATION}_withId(`);
    }

    if (!ssr) {
      // å‡½æ•°å£°æ˜
      push(`function render(_ctx, _cache) {`);
    } else {
      // TODO ssr render
    }

    indent();

    if (useWithBlock) {
      // use with(_ctx) { ...}
      push(`with (_ctx) {`);
      indent();

      // TODO hasHelpers
    }

    // TODO ast.components ç»„ä»¶å¤„ç†

    // TODO ast.directives æŒ‡ä»¤å¤„ç†

    // TODO ast.temps ä¸´æ—¶å˜é‡å¤„ç†

    // TODO æ¢è¡Œ

    if (!ssr) {
      push(`return `);
    }

    // ç”Ÿæˆä»£ç ç‰‡æ®µ
    if (ast.codegenNode) {
      genNode(ast.codegenNode, context);
    } else {
      push(`null`);
    }

    if (useWithBlock) {
      deindent();
      push(`}`);
    }

    deindent();
    push(`}`);

    if (genScopeId && !ssr) {
      push(`)`);
    }

    return {
      ast,
      code: context.code,
      map: "",
    };
  }
#+end_src

ä»£ç ä¸­åªåŒ…å«æ–‡æœ¬è§£æéœ€è¦çš„å†…å®¹ã€‚ä½†æ˜¯ç»“æœæ˜¾ç¤ºï¼š

#+begin_example
ast: {type: 0, children: Array(1), loc: {â€¦}, helpers: Array(0), components: Array(0), â€¦}
  code: "function render(_ctx, _cache) {â†µ with (_ctx) {â†µ  return null}}"
  map: ""
#+end_example

å³ï¼š ~ast.codegenNode~ æ˜¯ç©ºå€¼ï¼Œæœ€åå¹¶æ²¡æœ‰ æ‰§è¡Œ ~genNode(ast.codgenNode, context)~
ã€‚

å› æ­¤é—®é¢˜è¿˜åœ¨ [[#transform-transformtext][transformText]] é‡Œé¢ï¼Œä½†æ˜¯çº¯æ–‡æœ¬ä¼šç›´æ¥åœ¨ç¬¬ä¸€ä¸ª for åçš„ if åˆ¤æ–­ä¸­ç›´æ¥
~return~ äº†ï¼Œé‚£ä¹ˆé—®é¢˜å‡ºåœ¨å“ªï¼Ÿï¼Ÿï¼Ÿ

è¿›è¿‡å¾€ä¸Šè¿½æº¯ï¼Œå‘ç°åœ¨ traverseNode å®ç°ä¸­æœ‰ä¸€éƒ¨åˆ† switch ä»£ç è¢«æˆ‘ä»¬çœç•¥ï¼Œè€Œé‡Œé¢å°±
æœ‰ä¸ª case æ˜¯æ–‡æœ¬èŠ‚ç‚¹ä¼šèµ°åˆ°çš„ï¼Œå³ï¼š ~NodeTypes.ROOT~ å› ä¸ºè¿™ä¸ªç”¨ä¾‹æ–‡æœ¬æ˜¯ç›´æ¥æŒ‚åœ¨æ ¹
èŠ‚ç‚¹ä¸‹é¢çš„ï¼Œé‚£ä¹ˆå°±å¾—å®ç° [[#transform-traversechildren][traverseChildren]] äº†ã€‚

ç„¶åï¼Œå®ç°å®Œ traverseChildren ä¹‹åå¹¶æ²¡è§£å†³é—®é¢˜ï¼Œå› ä¸ºè¿™é‡Œé¢æ ¹æœ¬æ²¡æœ‰å¤„ç†èµ‹å€¼
codgenNode çš„æ“ä½œã€‚

é‚£ä¹ˆåªèƒ½ç”¨æœ€ç¬¨æ‹™çš„æ–¹æ³•äº†ï¼Œç›´æ¥æœç´¢ ~codegen*~ ç„¶ååˆå‘ç°æ–°å¤§é™†(transform é‡Œé¢æœ‰
ä¸ª [[#transform-createrootcodegen][createRootCodgen(...)]] å¹¶æ²¡æœ‰å®ç°)ï¼Œ :runner: go ->

**** stage-2: [[#test-cc-02][02 pure interpolation]]
:PROPERTIES:
:COLUMNS:  %CUSTOM_ID[(Custom Id)]
:CUSTOM_ID: codegen-generate-stage2
:END:

è¿™é‡Œæ–°å¢äº† ~push ast.helpers.map(...)~ å¤„ç†ï¼Œæ¯”å¦‚ traverseNode stage-2 ä¸­æ–°å¢çš„
INTERPOLATION åˆ†æ”¯ä¸­çš„å¤„ç†æ˜¯ ~context.helper(TO_DISPLAY_STRING)~ å°±æ˜¯ç»™ä¸Šä¸‹æ–‡çš„
helpers å¢åŠ äº† ~Symbol('toDisplayString')~ ã€‚

#+begin_src js

  export function generate(ast, options = {}) {
    // ...

    const hasHelpers = ast.helpers.length > 0;

    // ...

    if (useWithBlock) {
      // use with(_ctx) { ...}
      push(`with (_ctx) {`);
      indent();

      // æ–°å¢ï¼š hasHelpers
      if (hasHelpers) {
        // æ¯”å¦‚ï¼šæ’å€¼å¤„ç†æ—¶ç”¨åˆ° TO_DISPLAY_STRING helper
        // ä¸ºäº†é¿å…å‘½åå†²çªï¼Œè¿™é‡Œéƒ½éœ€è¦å°†ä»–ä»¬é‡å‘½å

        push(
          `const { ${ast.helpers
            .map((s) => `${helperNameMap[s]} : _${helperNameMap[s]}`)
            .join(", ")} } = _Vue`
        );

        push("\n");
        newline();
      }
    }

    // ...
  }
#+end_src

æ­£å¥½åœ¨è¿™é‡Œä¼šæ£€æµ‹ ~context.helpers~ è¿›è¡Œç›¸åº”çš„å¤„ç†ã€‚

[[#transform-traversenode][traverseNode]] çš„ switch ä¸­æ’å€¼ INTERPOLATION åˆ†æ”¯å¤„ç†ä¸­å¢åŠ äº†ä¸€ä¸ª
TO_DISPLAY_STRING ç¬¦å·ç±»å‹å€¼åˆ° ~context.helpers: Set~ ä¸­ï¼Œè¿™å…¶å®å°±æ˜¯ä¸ª ~_Vue~
å®ä¾‹ä¸­çš„ä¸€ä¸ªå‡½æ•°åç§°ï¼Œåœ¨è¿™é‡Œä¼šéå† ~context.helpers~ å°†éœ€è¦ç”¨åˆ°çš„å‡½æ•°ä»å®ä¾‹ä¸­è§£
æ„å‡ºæ¥ã€‚

*** genNode(node, context)
:PROPERTIES:
:COLUMNS:  %CUSTOM_ID[(Custom Id)]
:CUSTOM_ID: codegen-gennode
:END:

**** stage-3: [[#test-cc-04][04-interpolation in div with props]]
:PROPERTIES:
:COLUMNS:  %CUSTOM_ID[(Custom Id)]
:CUSTOM_ID: codegen-gennode-stage3
:END:

è¿™ä¸ªç”¨ä¾‹ä¸­éœ€è¦è§£æ ~props[{ id }, { class }]~ è¿™ä¸¤ä¸ªå±æ€§ç»è¿‡ buildProps å¤„ç†ä¹‹å
ä¼šå˜æˆä¸€ä¸ªå¯¹è±¡ç»“æ„ï¼š

~{ type: 15 /* JS_OBJECT_EXPRESSION */, properties: [{id}, {class}], ...}~

#+begin_src js
  0:
  key: {type: 4 /*SIMPLE_EXPRESSION*/, loc: {â€¦}, isConstant: false, content: "id", isStatic: true}
  type: 16 // JS_PROPERTY
  value: {type: 4, loc: {â€¦}, isConstant: false, content: "foo", isStatic: true}
  1:
  key: {type: 4, content: "class", isStatic: true, isConstant: true, loc: {â€¦}}
  type: 16 // JS_PROPERTY
  value: {type: 4, content: "bar.baz", isStatic: false, isConstant: false, loc: {â€¦}}
#+end_src

æ‰€ä»¥è¿™é‡Œé¦–å…ˆéœ€è¦å¢åŠ ä¸€ä¸ª ~JS_OBJECT_EXPRESSION~ åˆ†æ”¯å¤„ç†è¿™ä¸¤ä¸ªå±æ€§ï¼Œè§£ææˆå±æ€§å¯¹
è±¡ä¼ é€’ç»™ ~_createBlock('div', props, ...)~


#+begin_src js

  function genNode(node, context) {
    if (typeof node === "string") {
      context.push(node);
      return;
    }

    // TODO is symbol

    switch (node.type) {
        // ... çœç•¥
      case NodeTypes.ELEMENT:
        genNode(node.codegenNode, context);
        break;
      case NodeTypes.TEXT:
        genText(node, context);
        break;
      case NodeTypes.SIMPLE_EXPRESSION:
        // å¦‚ï¼šæ’å€¼å†…å®¹ï¼Œå±æ€§å€¼
        genExpression(node, context);
        break;
      case NodeTypes.INTERPOLATION:
        console.log(node, "interpolation");
        genInterpolation(node, context);
        break;
      case NodeTypes.VNODE_CALL:
        genVNodeCall(node, context);
        break;
      case NodeTypes.JS_OBJECT_EXPRESSION: // æ–°å¢å±æ€§ propertieså¤„ç†
        genObjectExpression(node, context);
        break;
    }
#+end_src

**** stage-2: [[#test-cc-02][02 pure interpolation]]
:PROPERTIES:
:COLUMNS:  %CUSTOM_ID[(Custom Id)]
:CUSTOM_ID: codegen-gennode-stage2
:END:

è¿™ä¸ªé˜¶æ®µéœ€è¦æ”¯æŒæ’å€¼çš„è§£æï¼Œè€Œæ’å€¼åœ¨ ast ä¸­æ•°æ®ç»“æ„ä¸ºï¼š

#+begin_src json
  {
    "type":5, // INTERPOLATION
    "content":{
      "type":4, // SIMPLE_EXPRESSION
      "isStatic":false,
      "isConstant":false,
      "content":"world.burn()",
      "loc":{
        // ... ,
        "source":"world.burn()"
      }
    },
    "loc":{
      // ...,
      "source":"{{ world.burn() }}"
    }
  }
#+end_src

è¿™é‡Œéœ€è¦ç»è¿‡ä¸¤æ¬¡é€’å½’è°ƒç”¨ genNode åˆ†åˆ«å»è§£æ ~type=5 // INTERPOLATION~ å’Œ ~type=4
// SIMPLE_EXPRESSION~ ä¸¤ç§ç±»å‹ï¼Œä¸”å‰åå½¢åŒçˆ¶å­å…³ç³»ã€‚

é‚£ä¹ˆå°±æœ‰ï¼š

#+begin_src js
  function genNode(node, context) {
    if (typeof node === "string") {
      context.push(node);
      return;
    }

    // TODO is symbol

    switch (node.type) {
        // ... çœç•¥
      case NodeTypes.TEXT:
        genText(node, context);
        break;
      case NodeTypes.SIMPLE_EXPRESSION:
        // å¦‚ï¼šæ’å€¼å†…å®¹ï¼Œå±æ€§å€¼
        genExpression(node, context);
        break;
      case NodeTypes.INTERPOLATION:
        console.log(node, "interpolation");
        genInterpolation(node, context);
        break;
    }
  }
#+end_src

1. å…ˆç»è¿‡ INTERPOLATION åˆ†æ”¯è°ƒç”¨ [[#codegen-geninterpolation][genInterpolation(node, context)]] å»è§£ææ’å€¼èŠ‚ç‚¹
**** stage-1: [[#test-cc-01][01 simple text]]
:PROPERTIES:
:COLUMNS:  %CUSTOM_ID[(Custom Id)]
:CUSTOM_ID: codegen-gennode-stage1
:END:

è¿™é‡Œæˆ‘ä»¬åªå¤„ç†æ–‡æœ¬èŠ‚ç‚¹çš„æƒ…å†µï¼š
#+begin_src js

  function genNode(node, context) {
    if (typeof node === "string") {
      context.push(node);
      return;
    }

    // TODO is symbol

    switch (node.type) {
        // ... çœç•¥
      case NodeTypes.TEXT:
        genText(node, context);
        break;
    }
  }
#+end_src

ç„¶åå°±æ˜¯å®ç° case çš„ [[#codegen-gentext][genText(node, context)]]

*** genNodeList(nodes, context, multilines=false, comma=true)
:PROPERTIES:
:COLUMNS:  %CUSTOM_ID[(Custom Id)]
:CUSTOM_ID: codegen-gennodelist
:END:

ç”Ÿæˆ _createBlock(tag, props, children, ...) å‡½æ•°çš„å‚æ•°åˆ—è¡¨ã€‚

#+begin_src js

  function genNodeList(nodes, context, multilines = false, comma = true) {
    const { push, newline } = context;
    for (let i = 0; i < nodes.length; i++) {
      const node = nodes[i];
      if (typeof node === "string") {
        push(node);
      } else if (Array.isArray(node)) {
        genNodeListAsArray(node, context);
      } else {
        // nodes[1], props è¿›å…¥è¿™é‡Œå¤„ç†
        genNode(node, context);
      }

      if (i < nodes.length - 1) {
        if (multilines) {
          comma && push(",");
          newline();
        } else {
          comma && push(", ");
        }
      }
    }
  }
#+end_src
*** genNodeListAsArray(nodes, context)
:PROPERTIES:
:COLUMNS:  %CUSTOM_ID[(Custom Id)]
:CUSTOM_ID: codegen-gennodelistasarray
:END:

å°†å‚æ•°åˆ—è¡¨è½¬æˆæ•°ç»„ï¼Œ ~nodes: [tag, props, chldren, ...]~ -> ~['div', {}, ...}]~

#+begin_src js

  // å°†å‚æ•°ä»¬å˜æˆæ•°ç»„
  function genNodeListAsArray(nodes, context) {
    const multilines =
          nodes.length > 3 ||
          ((!__BROWSER__ || __DEV__) &&
           nodes.some((n) => Array.isArray(n) || !isText(n)));

    context.push(`[`);
    multilines && context.indent();
    genNodeList(nodes, context, multilines);
    multilines && context.deindent();
    context.push(`]`);
  }
#+end_src

*** genNullableArgs(args)
:PROPERTIES:
:COLUMNS:  %CUSTOM_ID[(Custom Id)]
:CUSTOM_ID: codegen-gennullableargs
:END:

è¿‡æ»¤æ‰å‚æ•°åˆ—è¡¨å°¾éƒ¨å€¼ä¸º *å‡å€¼* çš„å‚æ•°ã€‚

#+begin_src js

  // è¿‡æ»¤å°¾éƒ¨ nullable çš„å€¼
  function genNullableArgs(args) {
    let i = args.length;
    while (i--) {
      if (args[i] != null) break;
    }

    // ä¸­é—´çš„ nullable å€¼ è½¬æˆ null
    return args.slice(0, i + 1).map((arg) => arg || `null`);
  }
#+end_src

*** genObjectExpression(node, context)
:PROPERTIES:
:COLUMNS:  %CUSTOM_ID[(Custom Id)]
:CUSTOM_ID: codegen-genobjectexpression
:END:

1. ç©ºå±æ€§åˆ—è¡¨ï¼Œè¿”å› ~{}~
2. å…ˆ [[#codegen-genexpressionaspropertykey][genExpressionAsPropertyKey(node, context)]] è§£æå±æ€§å

#+begin_src js
  // ç”Ÿæˆå¯¹è±¡è¡¨è¾¾å¼ï¼Œç”¨æ¥å¤„ç† properties
  function genObjectExpression(node, context) {
    const { push, indent, deindent, newline } = context;
    const { properties } = node;
    if (!properties.length) {
      push(`{}`, node);
      return;
    }

    const multilines =
          properties.length > 1 ||
          ((!__BROWSER__ || __DEV__) &&
           properties.some((p) => p.value.type !== NodeTypes.SIMPLE_EXPRESSION));

    push(multilines ? `{` : `{ `);
    multilines && indent();
    for (let i = 0; i < properties.length; i++) {
      const { key, value } = properties[i];
      // key å¤„ç†ï¼Œå±æ€§å
      genExpressionAsPropertyKey(key, context);
      push(`: `);
      // value å¤„ç†ï¼Œå±æ€§å€¼ï¼Œå¦‚æœæ˜¯é™æ€çš„å­—ç¬¦ä¸²åŒ–ï¼Œå¦‚æœæ˜¯åŠ¨æ€çš„ç›´æ¥å˜é‡æ–¹å¼
      // å¦‚ï¼š id="foo" -> id: "foo"
      // å¦‚ï¼š :class="bar.baz" -> class: bar.baz
      // è¿™é‡Œ bar æ˜¯å¯¹è±¡ï¼Œbaz æ˜¯ barå¯¹è±¡çš„å±æ€§
      genNode(value, context);
      if (i < properties.length - 1) {
        push(`,`);
        newline();
      }
    }
    multilines && deindent();
    push(multilines ? `}` : ` }`);
  }
#+end_src
*** genExpressionAsPropertyKey(node, context)
:PROPERTIES:
:COLUMNS:  %CUSTOM_ID[(Custom Id)]
:CUSTOM_ID: codegen-genexpressionaspropertykey
:END:

ç”Ÿæˆå¯¹è±¡å±æ€§åï¼š

1. å±æ€§åç”±ç»„åˆè¡¨è¾¾å¼åŠ¨æ€ç”Ÿæˆï¼Œå¦‚ï¼š ~{ [prefix + '_' + name]: 'value' }~
2. é™æ€å±æ€§ï¼Œåˆåˆ†æ ‡å‡†æ ‡è¯†ç¬¦å’Œéæ ‡å‡†çš„(éœ€è¦ç”¨å¼•å·åŒ…èµ·æ¥çš„)ï¼Œå¦‚ï¼š ~{ foo: 'value'
   }~ æˆ– ~{ '23adf34': 'value' }~
3. ç®€å•çš„åŠ¨æ€å±æ€§ï¼Œå¦‚ï¼š ~{ [foo]: 'value' }~

#+begin_src js

  function genExpressionAsPropertyKey(node, context) {
    const { push } = context;
    if (node.type === NodeTypes.COMPOUND_EXPRESSION) {
      push(`[`);
      genCompoundExpression(node, context);
      push(`]`);
    } else if (node.isStatic) {
      // é™æ€å±æ€§
      const text = isSimpleIdentifier(node.content)
            ? node.content
            : JSON.stringify(node.content);

      push(text, node);
    } else {
      // åŠ¨æ€å±æ€§
      push(`[${node.content}]`, node);
    }
  }
#+end_src
*** genCompoundExpression(node, context)
:PROPERTIES:
:COLUMNS:  %CUSTOM_ID[(Custom Id)]
:CUSTOM_ID: codegen-gencompoundexpression
:END:

#+begin_src js
  function genCompoundExpression(node, context) {
    for (let i = 0; i < node.children.length; i++) {
      const child = node.children[i];
      if (typeof child === "string") {
        context.push(child);
      } else {
        genNode(child, context);
      }
    }
  }
#+end_src
*** genText(node, context)
:PROPERTIES:
:COLUMNS:  %CUSTOM_ID[(Custom Id)]
:CUSTOM_ID: codegen-gentext
:END:

è¿™é‡Œæ²¡ä»€ä¹ˆé˜¶æ®µæ€§çš„ï¼Œå°±æ˜¯ä¸€å¥å¾ˆç®€å•çš„å­—ç¬¦ä¸²åŒ–æ–‡æœ¬èŠ‚ç‚¹å†…å®¹ã€‚

#+begin_src js
  function genText(node, context) {
    // æ–‡æœ¬ç›´æ¥å­—ç¬¦ä¸²åŒ–
    context.push(JSON.stringify(node.content), node);
  }

#+end_src

*** genFunctionPreamble(ast, context)
:PROPERTIES:
:COLUMNS:  %CUSTOM_ID[(Custom Id)]
:CUSTOM_ID: codegen-genfunctionpreamble
:END:

**** stage-1: [[#test-cc-01][01 simple text]]
å¯¹äºçº¯æ–‡æœ¬è¿™é‡Œä¸éœ€è¦æ›´å¤šçš„å¤„ç†ï¼Œåªéœ€è¦æœ€åçš„ ~`return `~

#+begin_src js

  function genFunctionPreamble(ast, context) {
    const { push, newline } = context;

    // TODO ...

    newline()
    push(`return `);
  }
#+end_src
*** genInterpolation(node, context)
:PROPERTIES:
:COLUMNS:  %CUSTOM_ID[(Custom Id)]
:CUSTOM_ID: codegen-geninterpolation
:END:

#+begin_src js
  function genInterpolation(node, context) {
    const { push, helper, pure } = context;

    if (pure) push(PURE_ANNOTATION);

    push(`${helper(TO_DISPLAY_STRING)}(`);
    // è°ƒç”¨ genNode è§£ææ’å€¼çš„å†…å®¹ï¼Œè¡¨è¾¾å¼èŠ‚ç‚¹ç±»å‹ï¼ŒNodeTypes.SIMPLE_EXPRESSION
    genNode(node.content, context);
    push(`)`);
  }
#+end_src

~context.helper(TO_DISPLAY_STRING)~ æ˜¯ä» helpersMap ä¸­å–å‡º TO_DISPLAY_STRING å¯¹
åº”çš„å‡½æ•°åç§°(ä¸‹åˆ’çº¿é‡å‘½åä¹‹åçš„åç§°)ï¼Œçœ‹ ~context.helper~ å®ç°:
#+begin_src js
  helper(key) {
    return `_${helperNameMap[key]}`;
  }
#+end_src

åˆ«åæ“ä½œåœ¨ [[#codegen-generate][generate]] çš„ useWithBlock åˆ¤æ–­ä¸­ç”Ÿæˆã€‚

*** genExpression(node, context)
:PROPERTIES:
:COLUMNS:  %CUSTOM_ID[(Custom Id)]
:CUSTOM_ID: codegen-genexpression
:END:

#+begin_src js
  function genExpression(node, context) {
    const { content, isStatic } = node;
    context.push(isStatic ? JSON.stringify(content) : content, node);
  }
#+end_src

è¡¨è¾¾å¼çš„å€¼å¯ä»¥æ˜¯é™æ€çš„ï¼Œä¹Ÿå¯ä»¥æ˜¯åŠ¨æ€çš„ï¼Œ

1. TODO å¦‚æœæ˜¯é™æ€ç›´æ¥å­—ç¬¦ä¸²åŒ–ï¼Ÿï¼Ÿï¼Ÿ

2. DONE å¦‚æœæ˜¯åŠ¨æ€çš„ç›´æ¥ push content å˜æˆå˜é‡ç›´æ¥ä»ä¸Šä¸‹æ–‡å»å–å˜é‡å€¼

   å¦‚ [[test-cc-02][02 pure interpolation]] ä¸­çš„ ~world.burn()~ ä¼šç›´æ¥è¢«å¡åˆ° ~context.code~ ç»“åˆ
   æˆ ~return _toDisplayString(world.burn());~ ç”Ÿæˆå‡½æ•°ä¹‹åç›¸å½“äºè¿™æ ·è°ƒ
   ç”¨ï¼š ~_ctx.world.burn()~  ã€‚

*** genVNodeCall(node, context)

**** stage-1 [[#test-cc-03][03-inerpolation in pure div]]

å¢åŠ  ~createVNode~ helper
#+begin_src js

  function genVNodeCall(node, context) {
    const { push, helper, pure } = context;

    const {
      tag,
      props,
      children,
      patchFlag,
      dynamicProps,
      directives,
      isBlock,
      isForBlock,
    } = node;

    // TODO directives start

    // TODO isblock start

    if (pure) {
      push(PURE_ANNOTATION);
    }

    push(helper(isBlock ? CREATE_BLOCK : CREATE_VNODE) + `(`, node);

    // TODO genNodeList

    push(`)`);

    // TODO isblock end

    // TODO directives end
  }
#+end_src
** è™šæ‹ŸèŠ‚ç‚¹åˆ›å»ºå‡½æ•°

| name              | transform     | desc             |
|-------------------+---------------+------------------|
| ~createTextVNode~ | [[#transform-transformtext][transformText]] | åˆ›å»ºæ–‡æœ¬è™šæ‹ŸèŠ‚ç‚¹ |
|                   |               |                  |

* é—®é¢˜åˆ—è¡¨

1. compile.js:37 Uncaught TypeError: object is not iterable (cannot read
   property Symbol(Symbol.iterator))

   åŸå› æ˜¯ï¼šåœ¨æ•°ç»„é‡Œé¢ä½¿ç”¨å±•å¼€ç¬¦çš„æ—¶å€™ [], {} æ··ç”¨äº†

   #+begin_src js
     transform(ast, {
       // åˆå¹¶é€‰é¡¹
       ...options, // è°ƒç”¨ baseCompile æ—¶å€™çš„ç¬¬äºŒä¸ªå‚æ•°
       prefixIdentifiers, // è¿˜ä¸çŸ¥é“æ˜¯å¹²å•¥çš„???
       // èŠ‚ç‚¹è½¬æ¢å™¨åˆå¹¶ï¼Œå¤–éƒ¨è½¬æ¢å™¨ä¼˜å…ˆï¼Œå³ä½¿ç”¨è€…å¯è‡ªå®šä¹‰è‡ªå·±çš„è½¬æ¢å™¨
       // nodeTransforms: [...nodeTransforms, ...(options.nodeTransforms || {})], // FIX: è¿™é‡Œç”¨æ³•æœ‰é—®é¢˜ä¿®æ”¹å‰
       nodeTransforms: [...nodeTransforms, ...(options.nodeTransforms || [])], // FIX: ä¿®æ”¹å
       // æŒ‡ä»¤è½¬æ¢å™¨ï¼ŒåŒä¸Šã€‚
       directiveTransforms: {
         ...directiveTransforms,
         ...(options.directiveTransforms || {}),
       },
     });

   #+end_src
