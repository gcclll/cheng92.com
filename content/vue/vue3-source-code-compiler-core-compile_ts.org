#+TITLE: Vue3.0 æºç ç³»åˆ—ï¼ˆäºŒï¼‰ç¼–è¯‘å™¨æ ¸å¿ƒ - Compiler core 3: compile.ts
#+DATE: <2020-08-31 22:11:55>
#+TAGS[]: vue, vue3, vuenext, compiler
#+CATEGORIES[]: vue
#+LANGUAGE: zh-cn
#+STARTUP: indent

#+begin_quote
è¯¥ç³»åˆ—æ–‡ç« ï¼Œå‡ä»¥æµ‹è¯•ç”¨ä¾‹é€šè¿‡ä¸ºåŸºå‡†ä¸€æ­¥æ­¥å®ç°ä¸€ä¸ª vue3 æºç å‰¯æœ¬(å­¦ä¹ )ã€‚
#+end_quote

@@html:<kbd>@@æ–‡å­—æ¯”è¾ƒé•¿ï¼Œå¦‚æœä¸æƒ³çœ‹æ–‡å­—å¯ç›´æ¥è½¬åˆ°[[/vue/vue-mind-map-house/][è¿™é‡Œ]]çœ‹è„‘å›¾@@html:</kbd>@@

@@html:<kbd>@@
*ç”±äº compile å’Œ transform å…³è”æ€§æ¯”è¾ƒå¼ºè¿™é‡Œå°†æ”¾åœ¨ä¸€èµ·å»å®Œæˆã€‚*
@@html:</kbd>@@

* å‡†å¤‡å·¥ä½œ
è¦å®Œæˆè¿™ä¸€éƒ¨åˆ†ï¼Œé¦–å…ˆè¦äº†è§£å®ƒçš„ä½œç”¨æ˜¯ä»€ä¹ˆï¼Ÿ

åœ¨ [[/vue/vue3-source-code-compiler-core-parse_ts/][parse.ts]] æ–‡ä¸­æˆ‘ä»¬å®Œæˆäº†è§£æå™¨çš„éƒ¨åˆ†ï¼Œä½œç”¨æ˜¯å°†æ¨¡æ¿è§£ææˆ AST å¯¹è±¡ã€‚

åœ¨è¿™é‡Œ compile.ts ä½œç”¨å°±æ˜¯å°†è¿™äº› AST å¦‚ä½•ç¿»è¯‘æˆ render å‡½æ•°ã€‚

ä¸ºäº†æ›´ç›´è§‚çš„ä½“éªŒ compile çš„ä½œç”¨ï¼Œåœ¨ vue æºç é‡Œé¢æœ‰ä¸€ä¸ªæ‰“åŒ…ä¹‹åçš„ç›®å½•ï¼š

*/vue-next/packages/vue/dist/vue.global.js*

ç„¶åæˆ‘ä»¬ä½¿ç”¨ç¬¬ä¸€ä¸ªæµ‹è¯•ç”¨ä¾‹çš„æ¨¡æ¿ï¼Œå»ç¼–è¯‘ä¸‹çœ‹çœ‹ç»“æœï¼š

#+begin_src js
  const source = `
  <div id="foo" :class="bar.baz">
    {{ world.burn() }}
    <div v-if="ok">yes</div>
    <template v-else>no</template>
    <div v-for="(value, index) in list"><span>{{ value + index }}</span></div>
  </div>
       `.trim(),
#+end_src

è¿›è¡Œç¼–è¯‘(å®Œæ•´ç¤ºä¾‹)ï¼š

#+begin_src html
  <script src="./vue.global.js"></script>
  <script>
    console.log(Vue, "00");
    const { compile } = Vue;
    const result = compile(
    `
    <div id="foo" :class="bar.baz">
      {{ world.burn() }}
      <div v-if="ok">yes</div>
      <template v-else>no</template>
      <div v-for="(value, index) in list"><span>{{ value + index }}</span></div>
    </div>
    `.trim(),
    { sourceMap: true, filename: "foo.vue" }
    );
    console.log(result, "xx");
  </script>
#+end_src

è¿è¡Œä¹‹å result ç»“æœï¼š

#+begin_src js
  (function anonymous() {
    const _Vue = Vue;
    const {
      createVNode: _createVNode,
      createCommentVNode: _createCommentVNode,
      createTextVNode: _createTextVNode,
    } = _Vue;

    const _hoisted_1 = { key: 0 };
    // è¿™é‡Œ v-if ... else é‡Œé¢çš„ <template>no</template> ï¼Ÿ
    // åˆ›å»ºæ–‡æœ¬è™šæ‹ŸèŠ‚ç‚¹ï¼Œè¿™é‡Œä¸ºä»€ä¹ˆç›´æ¥åœ¨ render å¤–å°±æ‰§è¡Œäº†ï¼Ÿï¼Ÿï¼Ÿ
    // åˆæ˜¯æ€ä¹ˆåšåˆ°çš„ï¼Ÿï¼Ÿï¼Ÿ
    const _hoisted_2 = _createTextVNode("no");

    // ç¥çº§å‡½æ•° >>> render
    return function render(_ctx, _cache) {
      with (_ctx) {
        const {
          toDisplayString: _toDisplayString,
          createVNode: _createVNode,
          openBlock: _openBlock,
          createBlock: _createBlock,
          createCommentVNode: _createCommentVNode,
          createTextVNode: _createTextVNode,
          Fragment: _Fragment,
          renderList: _renderList,
        } = _Vue;

        return (
          _openBlock(),
          _createBlock(
            "div",
            {
              // è§£æå‡ºæ¥çš„ div å±æ€§ï¼Œ id å’Œ class
              // parseAttribute çš„ç»“æœ
              id: "foo", // æ³¨æ„è¿™é‡Œæ˜¯å­—ç¬¦ä¸²
              class: bar.baz, // è¿™é‡Œæ˜¯å˜é‡å½¢å¼å­˜åœ¨ï¼Œå› ä¸ºç”¨åˆ°äº† :class å±äºæŒ‡ä»¤è§£æ
            },
            [
              // è¿™é‡Œæ˜¯å­©å­èŠ‚ç‚¹ä»¬
              // 1. ç¬¬ä¸€ä¸ªå­©å­èŠ‚ç‚¹ï¼Œæ’å€¼
              _createTextVNode(
                // æ’å€¼é‡Œé¢çš„å†…å®¹è°ƒç”¨è½¬æ¢æˆæ–‡æœ¬
                _toDisplayString(world.burn()) + " ",
                1 /* TEXT */
              ),
              // 2. ç¬¬äºŒä¸ªå­©å­èŠ‚ç‚¹ v-if...v-else
              // v-if æŒ‡ä»¤ï¼Œå‚æ•°æ˜¯ ok
              // ç„¶åè¿™é‡Œåˆæ˜¯æ€ä¹ˆåšåˆ° ok ? ... : ...
              // æŒ‡ä»¤è§£æçš„æ—¶å€™ v-if çš„å¤„ç†åˆæ˜¯æ€ä¹ˆåšçš„ï¼Œtransform/vIf ???
              // ç›¸é‚»çš„ä¸‹ä¸€ä¸ªèŠ‚ç‚¹æ£€æµ‹æ˜¯å¦æ˜¯ v-if æŒ‡ä»¤ç°‡ï¼Ÿï¼Ÿï¼Ÿ
              // åˆ°åº•çœŸç›¸å¦‚ä½• ???

              ok
              // åˆ›å»º div
                ? (_openBlock(), _createBlock("div", _hoisted_1, "yes"))
              // åˆ›å»º template
                : (_openBlock(),
                   _createBlock(
                     _Fragment,
                     { key: 1 },
                     // æå‰è¢«è§£æå‡ºæ¥çš„ template -> no æ–‡æœ¬èŠ‚ç‚¹
                     // éš¾é“æ˜¯æå‰éå†ï¼Ÿï¼Ÿï¼Ÿå°†æ‰€æœ‰çš„ template å¦‚æœæ˜¯
                     // é™æ€çš„å°±å…ˆå…¨éƒ¨åˆ›å»ºå‡ºæ¥ï¼Ÿï¼Ÿï¼Ÿ
                     [_hoisted_2],
                     64 /* STABLE_FRAGMENT */
                   )),
              // 3. ç¬¬ä¸‰ä¸ªå­©å­èŠ‚ç‚¹ï¼Œdiv v-for
              (_openBlock(true),
               _createBlock(
                 _Fragment,
                 null,
                 // æ¸²æŸ“åˆ—è¡¨
                 _renderList(list, (value, index) => {
                   return (
                     _openBlock(),
                     _createBlock("div", null, [
                       _createVNode(
                         "span",
                         null,
                         _toDisplayString(value + index),
                         1 /* TEXT */
                       ),
                     ])
                   );
                 }),
                 256 /* UNKEYED_FRAGMENT */
               )),
            ],
            2 /* CLASS */
          )
        );
      }
    };
  });
#+end_src

è¯¸å¤šçš„ç–‘é—®ç­‰ç€å»è§£ç­”ï¼ï¼ï¼

ä½†è‡³å°‘æœ‰ä¸€ç‚¹å¾ˆæ¸…æ™°çš„çŸ¥é“ï¼Œcompile å°±æ˜¯å°† AST ç¼–è¯‘æˆ render å‡½æ•°ç”¨çš„ã€‚

çŸ¥é“äº†æœ€ç»ˆç›®çš„ï¼Œæ¥ä¸‹æ¥å°±æ˜¯æ¼«é•¿çš„æ¢ç´¢ä¹‹è·¯äº† :running: :running: :running:

æ„é€ æ•°æ®ï¼Œè§‚å¯Ÿæœ€ç»ˆç”Ÿæˆçš„ VNode ç»“æ„(ä¸Šé¢ä»£ç æ‰§è¡Œä¹‹åç»“æœè¿”å›ç»™ resultï¼Œå…¶å®å°±
æ˜¯ render å‡½æ•°):

#+begin_src js
  result({
    list: [1,2,3],
    ok: true,
    bar: {
      baz: 'xx'
    },
    world: {
      burn() {}
    }
  })
#+end_src

ä¼ é€’ä¸€äº›å‚æ•°è°ƒç”¨ä¹‹åç»“æœï¼š

#+begin_example
  {_isVNode: true, type: "div", props: {â€¦}, key: null, ref: null, â€¦}
    anchor: null
    appContext: null
    // ä¸‰ä¸ªå­©å­èŠ‚ç‚¹
    children: Array(3)
      0: {_isVNode: true, type: Symbol(Text), props: null, key: null, ref: null, â€¦}
      1: {_isVNode: true, type: "div", props: {â€¦}, key: 0, ref: null, â€¦}
      2: {_isVNode: true, type: Symbol(Fragment), props: null, key: null, ref: null, â€¦}
      length: 3
    component: null
    dirs: null
    // ä¸‰ä¸ªåŠ¨æ€å­©å­èŠ‚ç‚¹
    dynamicChildren: Array(3)
      0: {_isVNode: true, type: Symbol(Text), props: null, key: null, ref: null, â€¦}
      1: {_isVNode: true, type: "div", props: {â€¦}, key: 0, ref: null, â€¦}
      2: {_isVNode: true, type: Symbol(Fragment), props: null, key: null, ref: null, â€¦}
      length: 3
    dynamicProps: null
    el: null
    key: null
    patchFlag: 2
    // å±æ€§
    props: {id: "foo", class: "xx"}
    ref: null
    scopeId: null
    shapeFlag: 17
    suspense: null
    target: null
    targetAnchor: null
    transition: null
    // æ ‡ç­¾
    type: "div"
    // æ ‡è¯†ä¸ºè™šæ‹ŸèŠ‚ç‚¹
    _isVNode: true
#+end_example

* compile.spec.ts
ç”±äº compile.spec.ts åŸæ¥åªæœ‰ä¸€ä¸ªç”¨ä¾‹ï¼Œç›¸å¯¹æ˜¯æ¯”è¾ƒå¤æ‚çš„ï¼Œä¸åˆ©äºå­¦ä¹ ã€‚

è¿™é‡Œå°†æ ¹æ® [[/vue/vue3-source-code-compiler-core-parse_ts/#parse.spec.ts][parse.spec.ts]] å¾ªåºæ¸è¿›çš„å»å®ç° compile + transform çš„åŠŸèƒ½ã€‚

ä¸‹é¢æ‰€æœ‰çš„æµ‹è¯•ç”¨ä¾‹å‡ä»¥ vue.global.js æ‰“åŒ…ä¹‹åçš„æ–‡ä»¶ï¼Œè¿è¡Œç»“æœä¸ºå‰æï¼š

#+begin_src js
  const test = `simple text`;

  const result = compile(test.trim(), {
    sourceMap: true,
    filename: "foo.vue",
  });
  console.log(result, "xx");
#+end_src

é€šè¿‡ä¿®æ”¹ test å€¼æ¥å¾—åˆ°çœŸå®çš„ render å‡½æ•°ã€‚

å®Œæˆäº† 01-simple text ç”¨ä¾‹ä¹‹åå‘ç°æŒ‰ç…§ parse.spec.ts å¯èƒ½ä¸å¤ªç†æƒ³ï¼Œæ¯•ç«Ÿ parse éƒ¨
åˆ†çš„ç”¨ä¾‹æœ‰ç‚¹å¤šï¼Œå¦‚æœæŒ‰ç…§é‚£ä¸ªæ¥è¿™éƒ¨åˆ†ä¹Ÿå°†ä¼šå¾ˆæ¼«é•¿ï¼Œæ€è€ƒè‰¯ä¹…åº”è¯¥è¿˜æ˜¯æŒ‰ç…§
compile.spec.ts ä¸­çš„ç”¨ä¾‹è¿›è¡Œæ‹†åˆ†ä¹‹åå³ç®€å…¥éš¾å¼å»é€šè¿‡è¯¥ç”¨ä¾‹ã€‚

å®Œæ•´ç”¨ä¾‹ï¼š

#+begin_src js
  const source = `
  <div id="foo" :class="bar.baz">
    {{ world.burn() }}
    <div v-if="ok">yes</div>
    <template v-else>no</template>
    <div v-for="(value, index) in list"><span>{{ value + index }}</span></div>
  </div>
  `.trim()
#+end_src

** 02-pure interpolation ç¬¬ä¸€ä¸ªå­©å­èŠ‚ç‚¹
:PROPERTIES:
:COLUMNS:  %CUSTOM_ID[(Custom Id)]
:CUSTOM_ID: test-02-worldburn
:END:

~{{ world.burn() }}~

æµ‹è¯•ï¼š
#+begin_src js
  const test01 = `{{ world.burn() }}`;

  const result = compile(test01.trim(), {
    sourceMap: true,
    filename: "foo.vue",
  });
  console.log(result, "xx");
#+end_src

vue.global ç»“æœï¼š
#+begin_src js
  Æ’ render(_ctx, _cache) {
    with (_ctx) {
      const { toDisplayString: _toDisplayString } = _Vue

      return _toDisplayString(world.burn())
    }
  }
#+end_src

[[#test-text-01][01-simple text]] é˜¶æ®µä»£ç è¿”å›çš„ç»“æœ:

#+begin_src js
  Æ’ render(_ctx, _cache) {
    with (_ctx) {
      return  // è¿™é‡Œæ²¡ä»»ä½•ä¸œè¥¿
    }
  }
#+end_src

é€šè¿‡[[#test-text-01][ç”¨ä¾‹ 01]] å¤§æ¦‚çš„å®Œæˆäº†ä¸€ä¸ªæ¯”è¾ƒå®Œæ•´çš„ç¼–è¯‘è¿‡ç¨‹ï¼Œè¦é€šè¿‡è¯¥ç”¨ä¾‹åº”è¯¥åªéœ€è¦åœ¨è¿™è¿‡ç¨‹ä¸­å¢
åŠ å¯¹æ’å€¼çš„å¤„ç†å³å¯ã€‚

å¤„ç†æ­¥éª¤(é€šè¿‡ç”¨ä¾‹ 01 æ€»ç»“å‡ºçš„æ­¥éª¤)ï¼š

[[#compile-basecompile][baseCompile]] -> [[/vue/vue3-source-code-compiler-core-parse_ts/#parse-baseparse][baseParse]] -> [[#compile-getbasetransformpreset][getBaseTransformPreset]] å¾—åˆ° transform å‡½æ•° ->
[[#transform-transform][transform]] -> [[#codegen-generate][generate]]

1. [[/vue/vue3-source-code-compiler-core-parse_ts/#parse-baseparse][baseParse]] -> ast
2. [[#compile-getbasetransformpreset][getBaseTransformPreset]] -> è¿™é‡Œå¹¶æ²¡æœ‰ä»€ä¹ˆ transformInterpolationï¼Œæ’å€¼å¹¶æ²¡æœ‰
   å¯¹åº”çš„ transform å‡½æ•°ï¼Œè€Œæ˜¯ç›´æ¥åœ¨ generate ä¸­ç»“åˆ ~ast.helpers~ å¤„ç†ã€‚
3. [[#transform-transform][transform]] -> [[#transform-createtransformcontext][createTransformContext]] -> [[#transform-traversenode][traverseNode]] -> [[#transform-createrootcodegen][createRootCodegen]] -> ...

   è¿™ä¸€æ­¥éœ€è¦å¤„ç†çš„åº”è¯¥åªæœ‰ [[#transform-traversenode][traverseNode]] éœ€è¦ä¿®æ”¹ï¼Œåœ¨ switch é‡Œå¢åŠ 
   INTERPOLATION åˆ†æ”¯ï¼Œå› ä¸º [[#codegen-createrootcodegen][createRootCodegen]] é‡Œé¢ root å¦‚æœåªæœ‰ä¸€ä¸ªå­©å­çš„æƒ…å†µ
   ä¸‹ä¼šå’Œ[[#test-text-01][ç”¨ä¾‹ 01]] ä¸€æ ·ç›´æ¥èµ‹å€¼ ~context.codegenNode = root.children[0]~

4. [[#codegen-generate][generate]] -> [[#codegen-createcodegencontext][createCodegenContext]] -> [[#codegen-genfunctionpreamble][genFunctionPreamble]] é»˜è®¤æ˜¯ function æ¨¡
   å¼ -> push ~function render(_ctx, _cache) {~ -> push ~with (_ctx)~ -> ...
   -> [[#codegen-gennode][genNode(ast.codegenNode, context)]]

   è¿™é‡Œéœ€è¦ä¿®æ”¹çš„ç‚¹åº”è¯¥åªæœ‰ genNode é‡Œé¢ï¼Œä¹Ÿæ˜¯å¢åŠ  INTERPOLATION switch åˆ†æ”¯ï¼Œ
   å¤„ç†æ’å€¼éƒ¨åˆ†çš„ä»£ç ã€‚


æœ‰äº†ä¸Šé¢çš„åˆæ­¥åˆ†æï¼Œè¿™é‡Œå¯ä»¥æ¯”è¾ƒæ˜ç¡®çš„çŸ¥é“éœ€è¦ä¿®æ”¹çš„ç‚¹ï¼š

1. DONE  *traverseNode* ä¸­å¢åŠ  INTERPOLATION åˆ†æ”¯
2. DONE  *genNode* ä¸­å¢åŠ  INTERPOLATION åˆ†æ”¯
3. DONE  *genNode* ä¸­å¢åŠ  SIMPLE_EXPRESSION åˆ†æ”¯å¤„ç†æ’å€¼å†…çš„è¡¨è¾¾å¼


+ä¿®æ­£ï¼šäº‹å®ä¸Šå¹¶æ²¡æœ‰ transformInterpolation+ :facepalm::facepalm::facepalm::facepalm:

ä¿®æ”¹å®Œä¹‹åæŠ¥é”™ï¼š
#+begin_example
transform.js:184 Uncaught TypeError: Cannot read property 'length' of undefined
    at traverseChildren (transform.js:184)
    at traverseNode (transform.js:119)
    at traverseChildren (transform.js:192)
    at traverseNode (transform.js:119)
    at transform (transform.js:133)
    at baseCompile (compile.js:37)
    at compile.html:12
#+end_example

æ ¹æ®æŠ¥é”™å®šä½åˆ°ï¼Œåœ¨è§£æ root.children[0] çš„æ—¶å€™ç»è¿‡ [[#transform-traversechildren][traverseChildren]] é‡Œé¢æ—¶å€™çš„
parent.children å€¼ä¸º undefinedã€‚

åŸå› æ˜¯ traverseNode é‡Œé¢çš„ NodeTypes.INTERPOLATION åˆ†æ”¯æ²¡æœ‰åŠ  break å¯¼è‡´çš„ï¼ŒåŠ ä¸Š
ä¹‹åï¼š

#+begin_src js
  Æ’ render(_ctx, _cache) {
    with (_ctx) {
      const { toDisplayString : _toDisplayString } = _Vue

      return
    }
  } "compiled"
#+end_src

å’Œæ­£ç¡®ç»“æœç›¸æ¯”å°‘äº†ç‚¹ä¸œè¥¿ ~return _toDisplayString(world.burn())~

1. with å†…çš„è§£æ„æ¥æºï¼š

   #+begin_src js
     function generate() {
       // ...
       if (hasHelpers) {
         // æ¯”å¦‚ï¼šæ’å€¼å¤„ç†æ—¶ç”¨åˆ° TO_DISPLAY_STRING helper
         // ä¸ºäº†é¿å…å‘½åå†²çªï¼Œè¿™é‡Œéƒ½éœ€è¦å°†ä»–ä»¬é‡å‘½å

         // traverseNode é‡Œé¢ context.help(helper)
         push(
           `const { ${ast.helpers
               .map((s) => `${helperNameMap[s]} : _${helperNameMap[s]}`)
               .join(", ")} } = _Vue`
         );

         push("\n");
         newline();
       }
       // ...
     }
   #+end_src

2. ç¼ºå°‘çš„ ~return _toDisplayString(world.burn())~

   - [[#codegen-generate][generate]] ä¸­æœ€å push `return `

   - æ‰§è¡Œ [[#codegen-gennode][genNode(ast.codgenNode, context)]] å¤„ç†ç¼ºå°‘çš„éƒ¨åˆ†

     #+begin_src js
       {type: 5, content: {â€¦}, loc: {â€¦}}
       content:
       content: "world.burn()"
       isConstant: false
       isStatic: false
       loc: {start: {â€¦}, end: {â€¦}, source: "world.burn()"}
       type: 4 // SIMPLE_EXPRESSIONï¼Œç¬¬äºŒæ­¥
       loc: {start: {â€¦}, end: {â€¦}, source: "{{ world.burn() }}"}
       type: 5 // INTERPOLATIONï¼Œç¬¬ä¸€æ­¥
     #+end_src

     1) node ç±»å‹é¦–å…ˆæ˜¯ INTERPOLATION ï¼Œè¿›å…¥ [[#codegen-geniinterpolation][genInterpolation(node, context)]]

        #+begin_src js
          function genInterpolation(node, context) {
            const { push, helper, pure } = context;

            if (pure) push(PURE_ANNOTATION);

            // è¿™é‡Œä» helpers é‡Œé¢å–å‡º toDisplayString
            push(`${helper(TO_DISPLAY_STRING)}(`);

            // è¿™é‡Œç”Ÿæˆ `world.burn()` SIMPLE_EXPRESSION ç±»å‹
            genNode(node.content, context);
            push(`)`);
          }
        #+end_src

     2) å– node.content è°ƒç”¨ [[#codegen-gennode][genNode(node.content, context)]] ç”Ÿæˆ `world.burn()`
        è¡¨è¾¾å¼ã€‚

        è¿›å…¥ ~switch node.type === NodeTypes.SIMPLE_EXPRESSION~ åˆ†æ”¯ï¼Œè°ƒç”¨
        [[#codegen-genexpression][genExpression(node, context)]]

:sunflower: Perfect: æœ€åç»“æœï¼š

#+begin_src js
  Æ’ render(_ctx, _cache) { // generate
    with (_ctx) { // useWithBlock
      const { toDisplayString : _toDisplayString } = _Vue // ast.helpers

      return _toDisplayString(world.burn()) // genNode -> genInterpolation -> genExpression
    }
  } // "compiled"
#+end_src

å®Œæ•´æµç¨‹å›¾([[http://qiniu.ii6g.com/img/compiler-pure-interpolation.png][ä¸ƒç‰›é“¾æ¥]])ï¼š

[[http://img.cheng92.com/vue3/compiler-core/compiler/compiler-pure-interpolation.png]]

** 01-simple text
:PROPERTIES:
:COLUMNS:  %CUSTOM_ID[(Custom Id)]
:CUSTOM_ID: test-text-01
:END:

compiledï¼š
#+begin_src js
  (function anonymous(
  ) {

    return function render(_ctx, _cache) {
      with (_ctx) {
        return "simple text"
      }
    }
  })
#+end_src

ä¹Ÿå°±æ˜¯è¯´ *"simple text"* æœ€åè½¬å˜æˆçš„ render å‡½æ•°å¦‚ä¸Šæ‰€ç¤ºã€‚

æˆ‘ä»¬çš„ç¬¬ä¸€æ­¥å°±æ˜¯å¦‚ä½•æ¥å®ç° compile å’Œ transform èƒ½å¾—åˆ°è¿™æ ·çš„ç»“æœï¼Œè¿™å°†æ˜¯è¯¥æ¨¡å—å®Œ
æˆç¬¬ä¸€æ­¥ ğŸ†™ ğŸ†™ ğŸ†™ ğŸ†™ ğŸ†™ ğŸ†™ ğŸ†™ ğŸ†™ ğŸ†™ ğŸ†™

parse ä¹‹åçš„ ast:
#+begin_src js
  {type: 0, children: Array(1), loc: {â€¦}, helpers: Array(0), components: Array(0), â€¦}
  cached: 0
  children: Array(1)
  0:
  content: "simple text"
  loc: {start: {â€¦}, end: {â€¦}, source: "simple text"}
  type: 2
  length: 1
  codegenNode: undefined
  components: []
  directives: []
  helpers: []
  hoists: []
  imports: []
  loc: {start: {â€¦}, end: {â€¦}, source: "simple text"}
  temps: 0
  type: 0
#+end_src


åœ¨å®Œæˆ [[#transform-transformtext][transformText]] ä¹‹åï¼Œå‘ç° result.code æ˜¯ç©ºçš„ï¼Œè¿˜ä»¥ä¸ºæ˜¯è¿™é‡Œé¢å®ç°é—®é¢˜çš„ï¼Œå…¶
å®æ˜¯ [[#codegen-generate][generate]] å‡½æ•°è¿˜æ²¡å®ç°çš„åŸå› ã€‚

æ‰€æœ‰éœ€è¦æ”¯æŒçš„å‡½æ•°éƒ½å®Œæˆä¹‹åï¼š

#+begin_example
{ast: {â€¦}, code: "function render(_ctx, _cache) {â†µ with (_ctx) {â†µ  return "simple text"}}", map: ""}
  ast: {type: 0, children: Array(1), loc: {â€¦}, helpers: Array(0), components: Array(0), â€¦}
    code: "function render(_ctx, _cache) {â†µ with (_ctx) {â†µ  return "simple text"}}"
    map: ""
#+end_example

ä¼šå‘ç°æœ€ç»ˆçš„ code å³æˆ‘ä»¬æƒ³è¦çš„ render å‡½æ•°ï¼Œå’Œç”¨ vue.global.js ç”Ÿæˆçš„ä¸€è‡´ã€‚

å¦‚æœéœ€è¦å°†è½¬æˆå‡½æ•°ï¼Œè¿™ä¸ªéœ€è¦ç”¨åˆ° compileToFunction è¿™ä¸ªä¸åœ¨æˆ‘ä»¬è¿™ä¸ªè®¨è®ºèŒƒå›´ï¼Œå…¶
å®é‡Œé¢ä¹Ÿå¾ˆç®€å•ï¼Œç›´æ¥è°ƒç”¨ ~new Function(code)~ å°±è¡Œäº†ï¼Œæ¥çœ‹ä¸‹ï¼š

#+begin_src js
  import { baseCompile as compile } from "../compile.js";

  const source = `simple text`.trim();

  const result = compile(source, {
    sourceMap: true,
    filename: `foo.vue`,
  });
  const render = new Function(result.code);
  console.log(render, "compiled");
#+end_src

è¾“å‡ºï¼š
#+begin_example
Æ’ anonymous(
) {
function render(_ctx, _cache) {
 with (_ctx) {
  return "simple text"}}
} "compiled"
#+end_example

ç„¶åä¼šå‘ç°ç»“æœå¥½åƒä¸å¤ªå¯¹ï¼Œé¦–å…ˆ render ä¼šè¢«ä¸€ä¸ªåŒ¿åå‡½æ•°åŒ…èµ·æ¥ï¼Œè¿™ä¸ªæ˜¯æ²¡é—®é¢˜çš„ï¼Œä½†
æ˜¯è²Œä¼¼åŒ¿åå‡½æ•°æ²¡æœ‰ç»“æŸçš„ *}* è¿™ä¸ªæˆ‘æƒ³é—®é¢˜è‚¯å®šå¤„åœ¨äº† [[#codegen-generate][generate]] é‡Œé¢ã€‚

å…¶å®æ˜¯å› ä¸º [[#codegen-createcodgencontext][createCodgenContext]] é‡Œé¢çš„ å‡½æ•°æ²¡æœ‰å®ç°ï¼Œå¦å¤–è¿™æ ·æ˜¯ä¸å¯¹çš„ï¼Œå› ä¸º ~new
Function(code)~ ä¼šå°† code ç”¨ä¸€ä¸ªåŒ¿åå‡½æ•°æ¥åŒ…è£¹èµ·æ¥ï¼Œå› æ­¤æƒ³è¦å¾—åˆ° render å‡½æ•°ï¼Œå¿…
é¡»æ˜¯ä»¥ return å½¢å¼è¿”å›ï¼Œå› æ­¤è¿™é‡Œè¿˜æœ‰ä¸ªé—æ¼çš„åœ°æ–¹: [[#codegen-genfunctionpreamble][genFunctionPreamble]] éœ€è¦å»å®
ç°ï¼Œè¿™é‡Œé¢æœ€åä¼š push ä¸€ä¸ª return åˆ° code å¼€å¤´ã€‚

æ›´æ–°åè¾“å‡ºï¼š
#+begin_src js
  Æ’ anonymous(
  ) {

    return function render(_ctx, _cache) {
      with (_ctx) {
        return "simple text"
      }
    }
  }
#+end_src

åœ¨å®ç° genFunctionPreamble ä¹‹åï¼Œè‡³æ­¤å®Œæˆäº†ä¸€ä¸ªå¾—åˆ° render å‡½æ•°çš„å®Œæ•´è¿‡ç¨‹ã€‚

ä¸‹é¢å°†ä½¿ç”¨æµç¨‹å›¾æ–¹å¼è¿›è¡Œå›é¡¾ï¼Œåˆ†ææ•´ä¸ªè¿‡ç¨‹ã€‚

[[http://qiniu.ii6g.com/img/compiler-simple-text.png][ä¸ƒç‰›å›¾ç‰‡é“¾æ¥]]

[[http://img.cheng92.com/vue3/compiler-core/compiler/compiler-simple-text.png]]
* å‡½æ•°åˆ—è¡¨
** compile.ts
*** baseCompile(template, options)
:PROPERTIES:
:COLUMNS:  %CUSTOM_ID[(Custom Id)]
:CUSTOM_ID: compile-basecompile
:END:

å°† template è§£ææˆ render å‡½æ•°ï¼Œé‡ç‚¹æ­¥éª¤:

1. [[vue/vue3-source-code-compiler-core-parse_ts/][baseParse(template, options)]] å°†å­—ç¬¦ä¸²æ¨¡æ¿è§£ææˆ AST å¯¹è±¡ã€‚
2. [[#transform-transform][transform(ast, ...)]] å°† AST è¿›ä¸€æ­¥è½¬æ¢å¤„ç†
3. å°†è½¬æ¢åçš„ ast è°ƒç”¨ codegen çš„ generate æ–¹æ³•ç”Ÿæˆ render ã€‚

#+begin_src js
  export function baseCompile(template, options) {
    const isModuleMode = options.mode === "module";

    // ... ç•¥å»é”™è¯¯âå¤„ç†
    const prefixIdentifiers =
          !__BROWSER__ && (options.prefixIdentifiers === true || isModuleMode);

    // 1. baseParse å¾—åˆ° AST å¯¹è±¡ï¼Œä¸¤ç§æƒ…å†µï¼š1. æœªè§£æçš„æ¨¡æ¿ï¼Œ2. ä»¥è§£æä¹‹åçš„ ast å¯¹è±¡
    const ast =
          typeof template === "string" ? baseParse(template, options) : template;

    // 2. å–å‡ºæ‰€æœ‰ node å’Œ directive çš„ transforms
    const [nodeTransforms, directiveTransforms] = getBaseTransformPreset(
      prefixIdentifiers
    );

    // 3. è¿›è¡Œè½¬æ¢ï¼Œè°ƒç”¨ transform
    transform(ast, {
      // åˆå¹¶é€‰é¡¹
      ...options, // è°ƒç”¨ baseCompile æ—¶å€™çš„ç¬¬äºŒä¸ªå‚æ•°
      prefixIdentifiers, // è¿˜ä¸çŸ¥é“æ˜¯å¹²å•¥çš„???
      // èŠ‚ç‚¹è½¬æ¢å™¨åˆå¹¶ï¼Œå¤–éƒ¨è½¬æ¢å™¨ä¼˜å…ˆï¼Œå³ä½¿ç”¨è€…å¯è‡ªå®šä¹‰è‡ªå·±çš„è½¬æ¢å™¨
      nodeTransforms: [...nodeTransforms, ...(options.nodeTransforms || {})],
      // æŒ‡ä»¤è½¬æ¢å™¨ï¼ŒåŒä¸Šã€‚
      directiveTransforms: [
        ...directiveTransforms,
        ...(options.directiveTransforms || {}),
      ],
    });

    // 4. è°ƒç”¨ generate ç”Ÿæˆ render å‡½æ•°çš„ codegen å¹¶è¿”å›ï¼Œè¿™å°±æ˜¯æˆ‘ä»¬éœ€è¦çš„ç»„ä»¶æ¸²
    // æŸ“å‡½æ•°
    return generate(ast, {
      ...options,
      prefixIdentifiers,
    });
  }
#+end_src

è¿™ä¹Ÿæ˜¯é™¤äº†é”™è¯¯å¤„ç†ä¹‹åçš„å®Œæ•´çš„ baseCompile å‡½æ•°å®ç°ã€‚
*** getBaseTransformPreset(prefixIdentifiers: boolean)
:PROPERTIES:
:COLUMNS:  %CUSTOM_ID[(Custom Id)]
:CUSTOM_ID: compile_getbasetransformpreset
:END:

åˆå¹¶æ‰€æœ‰ transformï¼Œè¿”å›ä¸€ä¸ª ~TransformPreset~ ç±»å‹çš„æ•°ç»„

stage-1: ç¬¬ä¸€é˜¶æ®µæˆ‘ä»¬åªéœ€è¦æ–‡æœ¬è½¬æ¢ï¼Œé€šè¿‡ [[#test-text-01][ç”¨ä¾‹ä¸€]] å³å¯ï¼Œæ‰€ä»¥è¿™é‡Œå°±åªä¿ç•™
[[transform-transformtext][transformText]] å°±å¯ä»¥äº†ï¼Œå‰©ä¸‹çš„å°±æ˜¯å»å®ç°å®ƒã€‚
#+begin_src js
  export function getBaseTransformPreset(prefixIdentifiers) {
    return [
      [
        // ... çœç•¥å…¶ä»–ï¼Œç¬¬ä¸€é˜¶æ®µæˆ‘ä»¬åº”è¯¥åªéœ€è¦æ–‡æœ¬è½¬æ¢
        transformText,
      ],
      {
        // ...çœç•¥æŒ‡ä»¤
      },
    ];
  }
#+end_src

** tranform.ts
*** transformExpression(node, context)
:PROPERTIES:
:COLUMNS:  %CUSTOM_ID[(Custom Id)]
:CUSTOM_ID: transform-transformexpression
:END:
*** transformText(node, context)
:PROPERTIES:
:COLUMNS:  %CUSTOM_ID[(Custom Id)]
:CUSTOM_ID: transform-transformtext
:END:

è¯¥å‡½æ•°ä¼šè¿”å›ä¸€ä¸ªç”¨æ¥è½¬æ¢æ–‡æœ¬èŠ‚ç‚¹ç±»å‹(~NodeTransform~)çš„å‡½æ•°ã€‚

è¿”å›å‡½æ•°åˆ†æ(~return () => { ... }~)ï¼Œä¸»è¦ç”±ä¸‰ä¸ª for æ„æˆï¼š

1. ç¬¬ä¸€ä¸ª for åµŒå¥—ç¬¬äºŒä¸ª for æ„æˆåŒé‡å¾ªç¯ï¼Œç”¨æ¥åˆå¹¶ node.children é‡Œé¢ç›¸é‚»çš„æ–‡æœ¬
   èŠ‚ç‚¹

   ç¬¬ä¸€ä¸ª For é‡Œé¢ä½¿ç”¨çš„æ˜¯ children.length åŠ¨æ€è·å–å½“å‰æ•°ç»„çš„é•¿åº¦ï¼Œç»“åˆä»£ç ä¸­çš„
   splice å’Œ j--ã€‚ä»è€Œå®Œæˆåˆå¹¶æ“ä½œã€‚

   #+begin_src js
     // 1. åŸæ¥çš„ child è¢«é‡å†™
     // 2. child, ` + `, next åˆå¹¶åˆ°äº†æ–° child.children é‡Œé¢
     currentContainer.children.push(` + `, next);
     // åˆ é™¤è¢«åˆå¹¶çš„æ–‡æœ¬èŠ‚ç‚¹
     children.splice(j, 1);
     j--; // -1 æ˜¯å› ä¸ºä¸Šé¢åˆ é™¤äº†å½“å‰å…ƒç´ ï¼Œfor å¾ªç¯è¿‡ç¨‹ä¸­é•¿åº¦æ˜¯åŠ¨æ€è·å–çš„
   #+end_src

2. ç¬¬ä¸‰ä¸ª for éå†ç¬¬ä¸€æ­¥ä¹‹åçš„ childrenï¼Œå¯¹æ¯ä¸ª child è¿›è¡Œé‡å®šä¹‰ï¼Œç±»å‹æ”¹å˜æˆ
   ~NodeTyeps.TEXT_CALL~ ç±»å‹ï¼Œå¢åŠ  codegenNode å±æ€§ã€‚


ä»£ç å®Œæ•´ç‰ˆï¼š
#+begin_src js

  export const transformText = (node, context) => {
    // æ–‡æœ¬è½¬æ¢åªèƒ½æ˜¯ä¸‹é¢å››ç§ç±»å‹
    const validTypes = [
      NodeTypes.ROOT,
      NodeTypes.ELEMENT,
      NodeTypes.FOR,
      NodeTypes.IF_BRANCH,
    ];

    // åˆæ³•ç±»å‹æ£€æµ‹
    if (validTypes.indexOf(node.type)) {
      // è¿”å›ä¸€ä¸ªå¯æ‰§è¡Œå‡½æ•°ï¼Œè®°å¾—åœ¨ transformNode å—ï¼Œè¿™ä¸ªè¿”å›çš„å‡½æ•°
      // å°†ä¼šè¢«å®ƒåœ¨ while ä¸­ æ‰§è¡Œ æ‰ã€‚
      return () => {
        const children = node.children;

        let currentContainer = undefined;
        let hasText = false;

        // åŒé‡å¾ªç¯ï¼Œåˆå¹¶æ‰€æœ‰ç›¸é‚»çš„æ–‡æœ¬èŠ‚ç‚¹
        // å¦‚ï¼š[text1, text2, element, text3, ele, text4, text5]
        // text1 å’Œ text2 ä¼šåˆå¹¶åˆ°text1
        // text3 ä¸ä¼šåˆå¹¶
        // text4 å’Œ text5 ä¼šè¢«åˆå¹¶
        for (let i = 0; i < children.length; i++) {
          const child = children[i];

          if (isText(child)) {
            // TODO æ–‡æœ¬èŠ‚ç‚¹æ‰è¿›è¡Œè§£æ
            hasText = true;
            // åˆå¹¶ç›¸é‚»çš„æ–‡æœ¬èŠ‚ç‚¹ï¼Œ text1 + text2
            for (let j = i + 1; j < children.length; j++) {
              const next = children[j];
              // ä¸‹ä¸€ä¸ªä¹Ÿæ˜¯æ–‡æœ¬èŠ‚ç‚¹çš„æ—¶å€™ï¼Œè¦å°†ä¸¤è€…åˆå¹¶
              if (isText(next)) {
                if (!currentContainer) {
                  // è¿™é‡Œç­‰äºé‡å†™äº† child çš„å¼•ç”¨ï¼Œå°†è‡ªèº« push åˆ°äº†
                  // æ–°ç»“æ„ä¸­çš„ children
                  currentContainer = children[i] = {
                    type: NodeTypes.COMPOUND_EXPRESSION,
                    loc: child.loc,
                    children: [child],
                  };
                }

                // 1. åŸæ¥çš„ child è¢«é‡å†™
                // 2. child, ` + `, next åˆå¹¶åˆ°äº†æ–° child.children é‡Œé¢
                currentContainer.children.push(` + `, next);
                // åˆ é™¤è¢«åˆå¹¶çš„æ–‡æœ¬èŠ‚ç‚¹
                children.splice(j, 1);
                j--; // -1 æ˜¯å› ä¸ºä¸Šé¢åˆ é™¤äº†å½“å‰å…ƒç´ ï¼Œfor å¾ªç¯è¿‡ç¨‹ä¸­é•¿åº¦æ˜¯åŠ¨æ€è·å–çš„
              } else {
                currentContainer = undefined;
                break;
              }
            }
          }
        }

        // é›†ä¸­ä¸æ»¡è¶³è½¬æ¢æ¡ä»¶çš„æƒ…å†µ
        if (
          // 1. æ²¡æœ‰æ–‡æœ¬å†…å®¹
          // 2. åªæœ‰ä¸€ä¸ªå­©å­èŠ‚ç‚¹
          //   2.1 ç»„ä»¶æ ¹èŠ‚ç‚¹
          //   2.2 <element> å…ƒç´ èŠ‚ç‚¹
          !hasText ||
            (children.length === 1 &&
             (node.type === NodeTypes.ROOT ||
              (node.type === NodeTypes.ELEMENT &&
               node.tagType === ElementTypes.ELEMENT)))
        ) {
          return;
        }

        // å¼€å§‹è½¬æ¢
        for (let i = 0; i < children.length; i++) {
          const chld = children[i];
          if (isText(child) || child.type === NodeTypes.COMPOUND_EXPRESSION) {
            const callArgs = [];

            // éæ–‡æœ¬èŠ‚ç‚¹ï¼Œç›´æ¥ push æ‰ï¼Œè¿™é‡Œ child.content !== ' ' çš„åŸå› åœ¨äº
            // parseChildren é‡Œé¢ while å¾ªç¯æœ€åæœ‰ä¸ªremove whitespace æ“ä½œ
            // ä¼šå°†æœ‰æ•ˆçš„ç©ºèŠ‚ç‚¹è½¬æˆä¸€ä¸ªç©ºæ ¼çš„å­—ç¬¦ä¸²ã€‚
            // createTextVNode é»˜è®¤æ˜¯ä¸€ä¸ªå•ç©ºæ ¼
            if (child.type !== NodeTypes.TEXT || child.content !== " ") {
              callArgs.push(child);
            }

            // éæœåŠ¡ç«¯æ¸²æŸ“ï¼Œä¸”éæ–‡æœ¬èŠ‚ç‚¹
            if (!context.ssr && child.type !== NodeTypes.TEXT) {
              callArgs.push(
                // TODO è¿™ä¸ªæ˜¯å¹²å˜›çš„ï¼Ÿï¼Ÿï¼Ÿ
                `${PatchFlags.TEXT} /* ${PatchFlagNames[PatchFlags.TEXT]} */`
              );
            }

            children[i] = {
              type: NodeTypes.TEXT_CALL, // æ–‡æœ¬å‡½æ•°
              content: child,
              loc: child.loc,
              codegenNode: createCallExpression(
                context.helper(CREATE_TEXT),
                callArgs
              ),
            };
          }
        }
      };
    }
  }
#+end_src

ä½¿ç”¨åˆ°çš„å¤–é¢å‡½æ•°å’Œå±æ€§ï¼š

1. CREATE_TEXTï¼š ä¸€ä¸ªç¬¦å·å±æ€§ ~export const CREATE_TEXT = Symbol(__DEV__ ? `createTextVNode` : ``);~
2. [[#ast-createcallexpression][createCallExpression(callee, args, loc)]] è¿”å› JS_CALL_EXPRESSION ç±»å‹å¯¹è±¡ã€‚
3. PatchFlags å’Œ PatchFlagNames ä¸€ä¸ªåå­—æ˜ å°„
4. isText æ–‡æœ¬èŠ‚ç‚¹ç±»å‹(æ’å€¼å’Œ text)

   #+begin_src js
     export function isText(node) {
       // æ’å€¼æˆ– text å‡è§†ä¸ºæ–‡æœ¬
       return node.type === NodeTypes.INTERPOLATION || node.type === NodeTypes.TEXT;
     }
   #+end_src


*å¯¹åº”çš„è™šæ‹ŸèŠ‚ç‚¹åˆ›å»ºå‡½æ•°ï¼š createTextVNode*
*** transform(root, options)
:PROPERTIES:
:COLUMNS:  %CUSTOM_ID[(Custom Id)]
:CUSTOM_ID: transform-transform
:END:

è°ƒç”¨çš„å‡½æ•°ï¼š
1. [[#transform-createtransformcontext][createTransformContext(root, options)]] åˆ›å»º transform è½¬æ¢å™¨ç±»å‹çš„ä¸Šä¸‹æ–‡å¯¹è±¡
2. [[#transform-traversenode][traverseNode(root, context)]] éå†æ‰€æœ‰èŠ‚ç‚¹
3. ssr æœåŠ¡ç«¯æ¸²æŸ“å¤„ç†
4. åˆå§‹åŒ– root æ ¹èŠ‚ç‚¹ä¸Šçš„ä¸€äº›å±æ€§

stage-1: [[#test-text-01][01 simple text]]
#+begin_src js

  export function transform(root, options) {
    const context = createTransformContext(root, options);

    traverseNode(root, context);

    if (options.hoistStatic) {
      hoistStatic(root, context);
    }

    // ... ssr å¤„ç†

    // root å±æ€§åˆå¹¶ï¼Œåˆå§‹åŒ–
    root.helpers = [...context.helpers];
    root.components = [...context.components];
    root.directives = [...context.directives];
    root.imports = [...context.imports];
    root.hoists = context.hoists;
    root.temps = context.temps;
    root.cached = context.cached;
  }
#+end_src
*** createTransformContext(root, options)
:PROPERTIES:
:COLUMNS:  %CUSTOM_ID[(Custom Id)]
:CUSTOM_ID: transform-createtransformcontext
:END:

å•çº¯çš„æ„å»ºå’Œåˆå§‹åŒ– transform è½¬æ¢å™¨ä¸Šä¸‹æ–‡å¯¹è±¡ã€‚

**** stage-1: [[#test-text-01][01 simple text]]

ä¸€äº›åˆå§‹åŒ–çš„å·¥ä½œï¼Œå¹¶ä¸éœ€è¦å…·ä½“å®ç°ä»€ä¹ˆï¼Œçº¯æ–‡æœ¬å¹¶æ²¡æœ‰ç”¨åˆ°ã€‚

#+begin_src js
  export function createTransformContext(
    root,
    {
      prefixIdentifiers = false,
      hoistStatic = false,
      cacheHandlers = false,
      nodeTransforms = [],
      directiveTransforms = {},
      transformHoist = null,
      isBuiltInComponent = NOOP,
      expressionPlugins = [],
      scopeId = null,
      ssr = false,
      onError = defaultOnError,
    }
  ) {
    const context = {
      // options
      prefixIdentifiers,
      hoistStatic,
      cacheHandlers,
      nodeTransforms,
      directiveTransforms,
      transformHoist,
      isBuiltInComponent,
      expressionPlugins,
      scopeId,
      ssr,
      onError,

      // state
      root,
      helpers: new Set(),
      components: new Set(),
      directives: new Set(),
      hoists: [],
      imports: new Set(),
      temps: 0,
      cached: 0,
      identifiers: {},
      scopes: {
        vFor: 0,
        vSlot: 0,
        vPre: 0,
        vOnce: 0,
      },
      parent: null,
      currentNode: root,
      childIndex: 0,

      // methods
      helper(name) {},
      helperString(name) {},
      replaceNode(node) {},
      removeNode(node) {},
      onNodeRemoved: () => {},
      addIdentifiers(exp) {},
      removeIdentifiers(exp) {},
      hoist(exp) {},
      cache(exp, isVNode = false) {},
    };

    function addId(id) {}

    function removeId(id) {}

    return context;
  }
#+end_src

**** stage-2: [[#test-02-worldburn][02 pure interpolation]] æ’å€¼èŠ‚ç‚¹çš„ç¼–è¯‘

#+begin_src js

  export function createTransformContext(
    root,
    { ... }
  ) {
    const context = {
      // ...
      helpers: new Set(),

      // ...

      // æ–°å¢ helper å®ç°
      helper(name) {
        context.helpers.add(name);
        return name;
      },

      // ...
    };

    function addId(id) {}

    function removeId(id) {}

    return context;
  }
#+end_src
*** createRootCodegen(root, context)
:PROPERTIES:
:COLUMNS:  %CUSTOM_ID[(Custom Id)]
:CUSTOM_ID: transform-createrootcodegen
:END:

åˆ›å»º root èŠ‚ç‚¹ä¸Šçš„ codegenNode å€¼ï¼Œè¿™ä¹Ÿæ˜¯å°†æ¥ç”¨æ¥ç¼–è¯‘æˆ render å‡½æ•°çš„æºç å­—ç¬¦ä¸²ã€‚

**** stage-1: [[#test-text-01][01 simple text]]
#+begin_src js

  function createRootCodegen(root, context) {
    // TODO  helper
    const { children } = root;
    const child = children[0];

    if (children.length === 1) {
      // åªæœ‰ä¸€ä¸ªå­©å­èŠ‚ç‚¹

      // ä¸”å­©å­èŠ‚ç‚¹æ˜¯ä¸€ä¸ªå…ƒç´  element ç±»å‹ï¼Œå°†å®ƒæ”¾åœ¨ä¸€ä¸ªä»£ç å—é’Ÿè¿”å›
      // å¦‚ï¼š { code }
      if (isSingleElementRoot(root, child) && child.codegenNode) {
        // TODO
      } else {
        root.codegenNode = child;
      }
    } else if (children.length > 1) {
    } else {
      // æ²¡æœ‰å­©å­èŠ‚ç‚¹ï¼Œ codegen è¿”å› nullï¼Œçœ‹åˆ°æ²¡
      // 01 simple text è¿”å› null é—®é¢˜æ‰¾åˆ°æ ¹æºäº†
    }
  }
#+end_src

å®ç°å®Œè¿™ä¸ªä¹‹åå‘ç°ï¼Œgenerate é‡Œé¢çš„ [[#codegen-gennode][genNode]] è¿˜æ²¡å®ç°ï¼ŒçœŸå®ä¸¢ä¸‰è½å››~~~~ã€‚
*** traverseNode(node, context)
:PROPERTIES:
:COLUMNS:  %CUSTOM_ID[(Custom Id)]
:CUSTOM_ID: transform-traversenode
:END:

**** stage-1: [[#test-text-01][01 simple text]] çœç•¥ switch é‡Œé¢çš„ä¸Šçº¿ï¼Œå› ä¸ºè¿™é‡Œåªæ˜¯çº¯æ–‡æœ¬ä¸å† case èŒƒå›´ã€‚
:PROPERTIES:
:COLUMNS:  %CUSTOM_ID[(Custom Id)]
:CUSTOM_ID: transform-traversenode-stage1
:END:

#+begin_src js

  export function traverseNode(node, context) {
    context.currentNode = node;

    const { nodeTransforms } = context;
    const exitFns = [];

    for (let i = 0; i < nodeTransforms.length; i++) {
      // è°ƒç”¨è¯¸å¦‚  transformText çš„å‡½æ•°
      const onExit = nodeTransforms[i](node, context);
      if (onExit) {
        const fns = Array.isArray(onExit) ? onExit : [onExit];
        exitFns.push(...fns);
      }

      if (!context.currentNode) {
        // å¯èƒ½è¢«ç§»é™¤äº†
        return;
      } else {
        // èŠ‚ç‚¹å¯èƒ½è¢«æ›¿æ¢è¿‡ï¼Œé‡æ–°å»ºç«‹å¼•ç”¨
        node = context.currentNode;
      }
    }

    switch (node.type) {
        // ... çœç•¥
      case NodeTypes.ROOT:
        traverseChildren(node, context);
        break;
    }

    let i = exitFns.length;
    // æ‰§è¡Œæ‰€æœ‰è½¬æ¢
    while (i--) {
      exitFns[i]();
    }
  }
#+end_src
**** stage-2: [[#test-02-worldburn][02 pure interpolation]] æ’å€¼èŠ‚ç‚¹çš„ç¼–è¯‘
:PROPERTIES:
:COLUMNS:  %CUSTOM_ID[(Custom Id)]
:CUSTOM_ID: transform-traversenode-stage2
:END:

å¢åŠ  INTERPOLATION ç±»å‹èŠ‚ç‚¹åˆ†æ”¯å¤„ç†ã€‚

#+begin_src js

  export function traverseNode(node, context) {
    // ...

    switch (node.type) {
        // ...

        // æ–°å¢ï¼šå¯¹æ’å€¼ç±»å‹èŠ‚ç‚¹å¤„ç†
      case NodeTypes.INTERPOLATION:
        if (!context.ssr) {
          // è¿™ä¸ªå‡½æ•°æ¥è‡ªä¸Šä¸‹æ–‡å¤„ç†ä¸­çš„ helper(name)
          context.helper(TO_DISPLAY_STRING);
        }
        break

        // ...
    }

    // ...
  }
#+end_src

ä¿®æ”¹ä¹‹åä»£ç ï¼š

#+begin_src js

  export function traverseNode(node, context) {
    context.currentNode = node;

    const { nodeTransforms } = context;
    const exitFns = [];

    for (let i = 0; i < nodeTransforms.length; i++) {
      // è°ƒç”¨è¯¸å¦‚  transformText çš„å‡½æ•°
      const onExit = nodeTransforms[i](node, context);
      if (onExit) {
        const fns = Array.isArray(onExit) ? onExit : [onExit];
        exitFns.push(...fns);
      }

      if (!context.currentNode) {
        // å¯èƒ½è¢«ç§»é™¤äº†
        return;
      } else {
        // èŠ‚ç‚¹å¯èƒ½è¢«æ›¿æ¢è¿‡ï¼Œé‡æ–°å»ºç«‹å¼•ç”¨
        node = context.currentNode;
      }
    }

    switch (node.type) {
        // ... çœç•¥
      case NodeTypes.INTERPOLATION:
        if (!context.ssr) {
          // è¿™ä¸ªå‡½æ•°æ¥è‡ªä¸Šä¸‹æ–‡å¤„ç†ä¸­çš„ helper(name)
          context.helper(TO_DISPLAY_STRING);
        }
        break;
      case NodeTypes.ROOT:
        traverseChildren(node, context);
        break;
    }

    let i = exitFns.length;
    // æ‰§è¡Œæ‰€æœ‰è½¬æ¢
    while (i--) {
      exitFns[i]();
    }
  }
#+end_src
*** traverseChildren(parent, context)
:PROPERTIES:
:COLUMNS:  %CUSTOM_ID[(Custom Id)]
:CUSTOM_ID: transform-traversechildren
:END:

å¤„ç† node.children å­©å­èŠ‚ç‚¹ã€‚

#+begin_src js

  export function traverseChildren(parent, context) {
    let i = 0;
    const nodeRemoved = () => {
      i--;
    };

    for (; i < parent.children.length; i++) {
      const child = parent.children[i];
      // è¿‡ç•¥æ‰å­—ç¬¦ä¸²ï¼Œåªå¤„ç† ast child
      if (typeof child === "string") continue;

      context.parent = parent;
      context.childIndex = i;
      context.onNodeRemoved = nodeRemoved;
      traverseNode(child, context);
    }
  }
#+end_src
** codegen.ts
*** createCodgenContext(ast, context)
:PROPERTIES:
:COLUMNS:  %CUSTOM_ID[(Custom Id)]
:CUSTOM_ID: codegen-createcodegencontext
:END:

**** stage-1: [[#test-text-01][01 simple text]]

#+begin_src js

  // æ„å»º condegen ä¸Šä¸‹æ–‡å¯¹è±¡
  function createCodegenContext(
    ast,
    {
      mode = "function",
      prefixIdentifiers = mode === "module",
      sourceMap = false,
      filename = `template.vue.html`,
      scopeId = null,
      optimizeBindings = false,
      runtimeGlobalName = `Vue`,
      runtimeModuleName = `vue`,
      ssr = false,
    }
  ) {
    const context = {
      mode,
      prefixIdentifiers,
      sourceMap,
      filename,
      scopeId,
      optimizeBindings,
      runtimeGlobalName,
      runtimeModuleName,
      ssr,
      source: ast.loc.source,
      code: ``,
      column: 1,
      line: 1,
      offset: 0,
      indentLevel: 0,
      pure: false,
      map: undefined,
      helper(key) {},
      push(code, node) {
        context.code += code;
        // TODO éæµè§ˆå™¨ç¯å¢ƒå¤„ç†ï¼Œnode ç¯å¢ƒ
      },
      indent() {
        // æ–°è¡Œç¼©è¿›
        newline(++context.indentLevel);
      },
      deindent(withoutNewLine = false) {
        if (withoutNewLine) {
          --context.indentLevel;
        } else {
          newline(--context.indentLevel);
        }
      },
      newline() {
        newline(context.indentLevel);
      },
    };

    function newline(n) {
      context.push("\n" + ` `.repeat(n));
    }

    function addMapping(loc, name) {}

    return context;
  }
#+end_src
*** generate()
:PROPERTIES:
:COLUMNS:  %CUSTOM_ID[(Custom Id)]
:CUSTOM_ID: codegen_generate
:END:

generate å‡½æ•°é›å½¢ï¼š

#+begin_src js
  export function generate(ast, options) {
    return {
      ast,
      code: "",
      map: "",
    };
  }

#+end_src

å‡½æ•°çš„ç›®çš„æ˜¯ï¼šé€šè¿‡ ast æ¥ç”Ÿæˆ codeï¼Œè¿™ä¸ª code å°†æ¥ä¼šè¢« compileToFunction è°ƒç”¨ ~new
Function(code)~ ç”Ÿæˆ render å‡½æ•°çš„ã€‚

**** stage-1: [[#test-text-01][01 simple text]]
:PROPERTIES:
:COLUMNS:  %CUSTOM_ID[(Custom Id)]
:CUSTOM_ID: codegen-generate-stage1
:END:

#+begin_src js

  export function generate(ast, options = {}) {
    const context = createCodegenContext(ast, options);
    const {
      mode,
      push,
      prefixIdentifiers,
      indent,
      deindent,
      newline,
      scopeId,
      ssr,
    } = context;

    const hasHelpers = ast.helpers.length > 0;
    const useWithBlock = !prefixIdentifiers && mode !== "module";
    const genScopeId = !__BROWSER__ && scopeId != null && mode === "module";

    // TODO preambles
    if (!__BROWSER__ && mode === "module") {
      // TODO genModulePreamble(ast, context, genScopeId)
    } else {
      genFunctionPreamble(ast, context);
    }

    if (genScopeId && !ssr) {
      push(`const render = ${PURE_ANNOTATION}_withId(`);
    }

    if (!ssr) {
      // å‡½æ•°å£°æ˜
      push(`function render(_ctx, _cache) {`);
    } else {
      // TODO ssr render
    }

    indent();

    if (useWithBlock) {
      // use with(_ctx) { ...}
      push(`with (_ctx) {`);
      indent();

      // TODO hasHelpers
    }

    // TODO ast.components ç»„ä»¶å¤„ç†

    // TODO ast.directives æŒ‡ä»¤å¤„ç†

    // TODO ast.temps ä¸´æ—¶å˜é‡å¤„ç†

    // TODO æ¢è¡Œ

    if (!ssr) {
      push(`return `);
    }

    // ç”Ÿæˆä»£ç ç‰‡æ®µ
    if (ast.codegenNode) {
      genNode(ast.codegenNode, context);
    } else {
      push(`null`);
    }

    if (useWithBlock) {
      deindent();
      push(`}`);
    }

    deindent();
    push(`}`);

    if (genScopeId && !ssr) {
      push(`)`);
    }

    return {
      ast,
      code: context.code,
      map: "",
    };
  }
#+end_src

ä»£ç ä¸­åªåŒ…å«æ–‡æœ¬è§£æéœ€è¦çš„å†…å®¹ã€‚ä½†æ˜¯ç»“æœæ˜¾ç¤ºï¼š

#+begin_example
ast: {type: 0, children: Array(1), loc: {â€¦}, helpers: Array(0), components: Array(0), â€¦}
  code: "function render(_ctx, _cache) {â†µ with (_ctx) {â†µ  return null}}"
  map: ""
#+end_example

å³ï¼š ~ast.codegenNode~ æ˜¯ç©ºå€¼ï¼Œæœ€åå¹¶æ²¡æœ‰ æ‰§è¡Œ ~genNode(ast.codgenNode, context)~
ã€‚

å› æ­¤é—®é¢˜è¿˜åœ¨ [[#transform-transformtext][transformText]] é‡Œé¢ï¼Œä½†æ˜¯çº¯æ–‡æœ¬ä¼šç›´æ¥åœ¨ç¬¬ä¸€ä¸ª for åçš„ if åˆ¤æ–­ä¸­ç›´æ¥
~return~ äº†ï¼Œé‚£ä¹ˆé—®é¢˜å‡ºåœ¨å“ªï¼Ÿï¼Ÿï¼Ÿ

è¿›è¿‡å¾€ä¸Šè¿½æº¯ï¼Œå‘ç°åœ¨ traverseNode å®ç°ä¸­æœ‰ä¸€éƒ¨åˆ† switch ä»£ç è¢«æˆ‘ä»¬çœç•¥ï¼Œè€Œé‡Œé¢å°±
æœ‰ä¸ª case æ˜¯æ–‡æœ¬èŠ‚ç‚¹ä¼šèµ°åˆ°çš„ï¼Œå³ï¼š ~NodeTypes.ROOT~ å› ä¸ºè¿™ä¸ªç”¨ä¾‹æ–‡æœ¬æ˜¯ç›´æ¥æŒ‚åœ¨æ ¹
èŠ‚ç‚¹ä¸‹é¢çš„ï¼Œé‚£ä¹ˆå°±å¾—å®ç° [[#transform-traversechildren][traverseChildren]] äº†ã€‚

ç„¶åï¼Œå®ç°å®Œ traverseChildren ä¹‹åå¹¶æ²¡è§£å†³é—®é¢˜ï¼Œå› ä¸ºè¿™é‡Œé¢æ ¹æœ¬æ²¡æœ‰å¤„ç†èµ‹å€¼
codgenNode çš„æ“ä½œã€‚

é‚£ä¹ˆåªèƒ½ç”¨æœ€ç¬¨æ‹™çš„æ–¹æ³•äº†ï¼Œç›´æ¥æœç´¢ ~codegen*~ ç„¶ååˆå‘ç°æ–°å¤§é™†(transform é‡Œé¢æœ‰
ä¸ª [[#transform-createrootcodegen][createRootCodgen(...)]] å¹¶æ²¡æœ‰å®ç°)ï¼Œ :runner: go ->

**** stage-2: [[#test-02-worldburn][02 pure interpolation]]
:PROPERTIES:
:COLUMNS:  %CUSTOM_ID[(Custom Id)]
:CUSTOM_ID: codegen-generate-stage2
:END:

è¿™é‡Œæ–°å¢äº† ~push ast.helpers.map(...)~ å¤„ç†ï¼Œæ¯”å¦‚ traverseNode stage-2 ä¸­æ–°å¢çš„
INTERPOLATION åˆ†æ”¯ä¸­çš„å¤„ç†æ˜¯ ~context.helper(TO_DISPLAY_STRING)~ å°±æ˜¯ç»™ä¸Šä¸‹æ–‡çš„
helpers å¢åŠ äº† ~Symbol('toDisplayString')~ ã€‚

#+begin_src js

  export function generate(ast, options = {}) {
    // ...

    const hasHelpers = ast.helpers.length > 0;

    // ...

    if (useWithBlock) {
      // use with(_ctx) { ...}
      push(`with (_ctx) {`);
      indent();

      // æ–°å¢ï¼š hasHelpers
      if (hasHelpers) {
        // æ¯”å¦‚ï¼šæ’å€¼å¤„ç†æ—¶ç”¨åˆ° TO_DISPLAY_STRING helper
        // ä¸ºäº†é¿å…å‘½åå†²çªï¼Œè¿™é‡Œéƒ½éœ€è¦å°†ä»–ä»¬é‡å‘½å

        push(
          `const { ${ast.helpers
            .map((s) => `${helperNameMap[s]} : _${helperNameMap[s]}`)
            .join(", ")} } = _Vue`
        );

        push("\n");
        newline();
      }
    }

    // ...
  }
#+end_src

æ­£å¥½åœ¨è¿™é‡Œä¼šæ£€æµ‹ ~context.helpers~ è¿›è¡Œç›¸åº”çš„å¤„ç†ã€‚

[[#transform-traversenode][traverseNode]] çš„ switch ä¸­æ’å€¼ INTERPOLATION åˆ†æ”¯å¤„ç†ä¸­å¢åŠ äº†ä¸€ä¸ª
TO_DISPLAY_STRING ç¬¦å·ç±»å‹å€¼åˆ° ~context.helpers: Set~ ä¸­ï¼Œè¿™å…¶å®å°±æ˜¯ä¸ª ~_Vue~
å®ä¾‹ä¸­çš„ä¸€ä¸ªå‡½æ•°åç§°ï¼Œåœ¨è¿™é‡Œä¼šéå† ~context.helpers~ å°†éœ€è¦ç”¨åˆ°çš„å‡½æ•°ä»å®ä¾‹ä¸­è§£
æ„å‡ºæ¥ã€‚

*** genNode(node, context)
:PROPERTIES:
:COLUMNS:  %CUSTOM_ID[(Custom Id)]
:CUSTOM_ID: codegen-gennode
:END:

**** stage-1: [[#test-text-01][01 simple text]]
:PROPERTIES:
:COLUMNS: %CUSTOM_ID[(Custom Id)]
:CUSTOM_ID: codegen-gennode-stage1
:END: 

è¿™é‡Œæˆ‘ä»¬åªå¤„ç†æ–‡æœ¬èŠ‚ç‚¹çš„æƒ…å†µï¼š
#+begin_src js

  function genNode(node, context) {
    if (typeof node === "string") {
      context.push(node);
      return;
    }

    // TODO is symbol

    switch (node.type) {
        // ... çœç•¥
      case NodeTypes.TEXT:
        genText(node, context);
        break;
    }
  }
#+end_src

ç„¶åå°±æ˜¯å®ç° case çš„ [[#codegen-gentext][genText(node, context)]]

**** stage-2: [[#test-02-worldburn][02 pure interpolation]]
:PROPERTIES:
:COLUMNS: %CUSTOM_ID[(Custom Id)]
:CUSTOM_ID: codegen-gennode-stage2
:END: 

è¿™ä¸ªé˜¶æ®µéœ€è¦æ”¯æŒæ’å€¼çš„è§£æï¼Œè€Œæ’å€¼åœ¨ ast ä¸­æ•°æ®ç»“æ„ä¸ºï¼š

#+begin_src json
  {
    "type":5, // INTERPOLATION
    "content":{
      "type":4, // SIMPLE_EXPRESSION
      "isStatic":false,
      "isConstant":false,
      "content":"world.burn()",
      "loc":{
        // ... ,
        "source":"world.burn()"
      }
    },
    "loc":{
      // ...,
      "source":"{{ world.burn() }}"
    }
  }
#+end_src

è¿™é‡Œéœ€è¦ç»è¿‡ä¸¤æ¬¡é€’å½’è°ƒç”¨ genNode åˆ†åˆ«å»è§£æ ~type=5 // INTERPOLATION~ å’Œ ~type=4
// SIMPLE_EXPRESSION~ ä¸¤ç§ç±»å‹ï¼Œä¸”å‰åå½¢åŒçˆ¶å­å…³ç³»ã€‚

é‚£ä¹ˆå°±æœ‰ï¼š

#+begin_src js
  function genNode(node, context) {
    if (typeof node === "string") {
      context.push(node);
      return;
    }

    // TODO is symbol

    switch (node.type) {
        // ... çœç•¥
      case NodeTypes.TEXT:
        genText(node, context);
        break;
      case NodeTypes.SIMPLE_EXPRESSION:
        // å¦‚ï¼šæ’å€¼å†…å®¹ï¼Œå±æ€§å€¼
        genExpression(node, context);
        break;
      case NodeTypes.INTERPOLATION:
        console.log(node, "interpolation");
        genInterpolation(node, context);
        break;
    }
  }
#+end_src

1. å…ˆç»è¿‡ INTERPOLATION åˆ†æ”¯è°ƒç”¨ [[#codegen-geninterpolation][genInterpolation(node, context)]] å»è§£ææ’å€¼èŠ‚ç‚¹
*** genText(node, context)
:PROPERTIES:
:COLUMNS:  %CUSTOM_ID[(Custom Id)]
:CUSTOM_ID: codegen-gentext
:END:

è¿™é‡Œæ²¡ä»€ä¹ˆé˜¶æ®µæ€§çš„ï¼Œå°±æ˜¯ä¸€å¥å¾ˆç®€å•çš„å­—ç¬¦ä¸²åŒ–æ–‡æœ¬èŠ‚ç‚¹å†…å®¹ã€‚

#+begin_src js
  function genText(node, context) {
    // æ–‡æœ¬ç›´æ¥å­—ç¬¦ä¸²åŒ–
    context.push(JSON.stringify(node.content), node);
  }

#+end_src

*** genFunctionPreamble(ast, context)
:PROPERTIES:
:COLUMNS:  %CUSTOM_ID[(Custom Id)]
:CUSTOM_ID: codegen-genfunctionpreamble
:END:

**** stage-1: [[#test-text-01][01 simple text]]
å¯¹äºçº¯æ–‡æœ¬è¿™é‡Œä¸éœ€è¦æ›´å¤šçš„å¤„ç†ï¼Œåªéœ€è¦æœ€åçš„ ~`return `~

#+begin_src js

  function genFunctionPreamble(ast, context) {
    const { push, newline } = context;

    // TODO ...

    newline()
    push(`return `);
  }
#+end_src
*** genInterpolation(node, context)
:PROPERTIES:
:COLUMNS: %CUSTOM_ID[(Custom Id)]
:CUSTOM_ID: codegen-geninterpolation
:END: 

#+begin_src js
  function genInterpolation(node, context) {
    const { push, helper, pure } = context;

    if (pure) push(PURE_ANNOTATION);

    push(`${helper(TO_DISPLAY_STRING)}(`);
    // è°ƒç”¨ genNode è§£ææ’å€¼çš„å†…å®¹ï¼Œè¡¨è¾¾å¼èŠ‚ç‚¹ç±»å‹ï¼ŒNodeTypes.SIMPLE_EXPRESSION
    genNode(node.content, context);
    push(`)`);
  }
#+end_src

~context.helper(TO_DISPLAY_STRING)~ æ˜¯ä» helpersMap ä¸­å–å‡º TO_DISPLAY_STRING å¯¹
åº”çš„å‡½æ•°åç§°(ä¸‹åˆ’çº¿é‡å‘½åä¹‹åçš„åç§°)ï¼Œçœ‹ ~context.helper~ å®ç°:
#+begin_src js
  helper(key) {
    return `_${helperNameMap[key]}`;
  }
#+end_src

åˆ«åæ“ä½œåœ¨ [[#codegen-generate][generate]] çš„ useWithBlock åˆ¤æ–­ä¸­ç”Ÿæˆã€‚

*** genExpression(node, context)
:PROPERTIES:
:COLUMNS: %CUSTOM_ID[(Custom Id)]
:CUSTOM_ID: codegen-genexpression
:END: 

#+begin_src js
  function genExpression(node, context) {
    const { content, isStatic } = node;
    context.push(isStatic ? JSON.stringify(content) : content, node);
  }
#+end_src

è¡¨è¾¾å¼çš„å€¼å¯ä»¥æ˜¯é™æ€çš„ï¼Œä¹Ÿå¯ä»¥æ˜¯åŠ¨æ€çš„ï¼Œ

1. TODO å¦‚æœæ˜¯é™æ€ç›´æ¥å­—ç¬¦ä¸²åŒ–ï¼Ÿï¼Ÿï¼Ÿ

2. DONE å¦‚æœæ˜¯åŠ¨æ€çš„ç›´æ¥ push content å˜æˆå˜é‡ç›´æ¥ä»ä¸Šä¸‹æ–‡å»å–å˜é‡å€¼

   å¦‚ [[test-02-worldburn][02 pure interpolation]] ä¸­çš„ ~world.burn()~ ä¼šç›´æ¥è¢«å¡åˆ° ~context.code~ ç»“åˆ
   æˆ ~return _toDisplayString(world.burn());~ ç”Ÿæˆå‡½æ•°ä¹‹åç›¸å½“äºè¿™æ ·è°ƒ
   ç”¨ï¼š ~_ctx.world.burn()~  ã€‚
   
** è™šæ‹ŸèŠ‚ç‚¹åˆ›å»ºå‡½æ•°

| name              | transform     | desc             |
|-------------------+---------------+------------------|
| ~createTextVNode~ | [[#transform-transformtext][transformText]] | åˆ›å»ºæ–‡æœ¬è™šæ‹ŸèŠ‚ç‚¹ |
|                   |               |                  |

* é—®é¢˜åˆ—è¡¨

1. compile.js:37 Uncaught TypeError: object is not iterable (cannot read
   property Symbol(Symbol.iterator))

   åŸå› æ˜¯ï¼šåœ¨æ•°ç»„é‡Œé¢ä½¿ç”¨å±•å¼€ç¬¦çš„æ—¶å€™ [], {} æ··ç”¨äº†

   #+begin_src js
     transform(ast, {
       // åˆå¹¶é€‰é¡¹
       ...options, // è°ƒç”¨ baseCompile æ—¶å€™çš„ç¬¬äºŒä¸ªå‚æ•°
       prefixIdentifiers, // è¿˜ä¸çŸ¥é“æ˜¯å¹²å•¥çš„???
       // èŠ‚ç‚¹è½¬æ¢å™¨åˆå¹¶ï¼Œå¤–éƒ¨è½¬æ¢å™¨ä¼˜å…ˆï¼Œå³ä½¿ç”¨è€…å¯è‡ªå®šä¹‰è‡ªå·±çš„è½¬æ¢å™¨
       // nodeTransforms: [...nodeTransforms, ...(options.nodeTransforms || {})], // FIX: è¿™é‡Œç”¨æ³•æœ‰é—®é¢˜ä¿®æ”¹å‰
       nodeTransforms: [...nodeTransforms, ...(options.nodeTransforms || [])], // FIX: ä¿®æ”¹å
       // æŒ‡ä»¤è½¬æ¢å™¨ï¼ŒåŒä¸Šã€‚
       directiveTransforms: {
         ...directiveTransforms,
         ...(options.directiveTransforms || {}),
       },
     });

   #+end_src
