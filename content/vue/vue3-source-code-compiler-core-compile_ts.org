#+TITLE: Vue3.0 源码系列（二）编译器核心 - Compiler core 3: compile.ts
#+DATE: <2020-08-31 22:11:55>
#+TAGS[]: vue, vue3, vuenext, compiler
#+CATEGORIES[]: vue
#+LANGUAGE: zh-cn
#+STARTUP: indent


#+begin_export html
<script>
window.g_need_fold = 1
</script>
#+end_export

#+begin_quote
该系列文章，均以测试用例通过为基准一步步实现一个 vue3 源码副本(学习)。
#+end_quote

@@html:<kbd>@@文字比较长，如果不想看文字可直接转到[[/vue/vue-mind-map-house/][这里]]看脑图@@html:</kbd>@@

@@html:<kbd>@@
*由于 compile 和 transform 关联性比较强这里将放在一起去完成。*
@@html:</kbd>@@

* 准备工作
要完成这一部分，首先要了解它的作用是什么？

在 [[/vue/vue3-source-code-compiler-core-parse_ts/][parse.ts]] 文中我们完成了解析器的部分，作用是将模板解析成 AST 对象。

在这里 compile.ts 作用就是将这些 AST 如何翻译成 render 函数。

为了更直观的体验 compile 的作用，在 vue 源码里面有一个打包之后的目录：

*/vue-next/packages/vue/dist/vue.global.js*

然后我们使用第一个测试用例的模板，去编译下看看结果：

#+begin_src js
  const source = `
  <div id="foo" :class="bar.baz">
    {{ world.burn() }}
    <div v-if="ok">yes</div>
    <template v-else>no</template>
    <div v-for="(value, index) in list"><span>{{ value + index }}</span></div>
  </div>
       `.trim(),
#+end_src

进行编译(完整示例)：

#+begin_src html
  <script src="./vue.global.js"></script>
  <script>
    console.log(Vue, "00");
    const { compile } = Vue;
    const result = compile(
    `
    <div id="foo" :class="bar.baz">
      {{ world.burn() }}
      <div v-if="ok">yes</div>
      <template v-else>no</template>
      <div v-for="(value, index) in list"><span>{{ value + index }}</span></div>
    </div>
    `.trim(),
    { sourceMap: true, filename: "foo.vue" }
    );
    console.log(result, "xx");
  </script>
#+end_src

运行之后 result 结果：

#+begin_src js
  (function anonymous() {
    const _Vue = Vue;
    const {
      createVNode: _createVNode,
      createCommentVNode: _createCommentVNode,
      createTextVNode: _createTextVNode,
    } = _Vue;

    const _hoisted_1 = { key: 0 };
    // 这里 v-if ... else 里面的 <template>no</template> ？
    // 创建文本虚拟节点，这里为什么直接在 render 外就执行了？？？
    // 又是怎么做到的？？？
    const _hoisted_2 = _createTextVNode("no");

    // 神级函数 >>> render
    return function render(_ctx, _cache) {
      with (_ctx) {
        const {
          toDisplayString: _toDisplayString,
          createVNode: _createVNode,
          openBlock: _openBlock,
          createBlock: _createBlock,
          createCommentVNode: _createCommentVNode,
          createTextVNode: _createTextVNode,
          Fragment: _Fragment,
          renderList: _renderList,
        } = _Vue;

        return (
          _openBlock(),
          _createBlock(
            "div",
            {
              // 解析出来的 div 属性， id 和 class
              // parseAttribute 的结果
              id: "foo", // 注意这里是字符串
              class: bar.baz, // 这里是变量形式存在，因为用到了 :class 属于指令解析
            },
            [
              // 这里是孩子节点们
              // 1. 第一个孩子节点，插值
              _createTextVNode(
                // 插值里面的内容调用转换成文本
                _toDisplayString(world.burn()) + " ",
                1 /* TEXT */
              ),
              // 2. 第二个孩子节点 v-if...v-else
              // v-if 指令，参数是 ok
              // 然后这里又是怎么做到 ok ? ... : ...
              // 指令解析的时候 v-if 的处理又是怎么做的，transform/vIf ???
              // 相邻的下一个节点检测是否是 v-if 指令簇？？？
              // 到底真相如何 ???

              ok
              // 创建 div
                ? (_openBlock(), _createBlock("div", _hoisted_1, "yes"))
              // 创建 template
                : (_openBlock(),
                   _createBlock(
                     _Fragment,
                     { key: 1 },
                     // 提前被解析出来的 template -> no 文本节点
                     // 难道是提前遍历？？？将所有的 template 如果是
                     // 静态的就先全部创建出来？？？
                     [_hoisted_2],
                     64 /* STABLE_FRAGMENT */
                   )),
              // 3. 第三个孩子节点，div v-for
              (_openBlock(true),
               _createBlock(
                 _Fragment,
                 null,
                 // 渲染列表
                 _renderList(list, (value, index) => {
                   return (
                     _openBlock(),
                     _createBlock("div", null, [
                       _createVNode(
                         "span",
                         null,
                         _toDisplayString(value + index),
                         1 /* TEXT */
                       ),
                     ])
                   );
                 }),
                 256 /* UNKEYED_FRAGMENT */
               )),
            ],
            2 /* CLASS */
          )
        );
      }
    };
  });
#+end_src

诸多的疑问等着去解答！！！

但至少有一点很清晰的知道，compile 就是将 AST 编译成 render 函数用的。

知道了最终目的，接下来就是漫长的探索之路了 :running: :running: :running:

构造数据，观察最终生成的 VNode 结构(上面代码执行之后结果返回给 result，其实就
是 render 函数):

#+begin_src js
  result({
    list: [1,2,3],
    ok: true,
    bar: {
      baz: 'xx'
    },
    world: {
      burn() {}
    }
  })
#+end_src

传递一些参数调用之后结果：

#+begin_src js
  {_isVNode: true, type: "div", props: {…}, key: null, ref: null, …}
  anchor: null
  appContext: null
  // 三个孩子节点
  children: Array(3)
  0: {_isVNode: true, type: Symbol(Text), props: null, key: null, ref: null, …}
  1: {_isVNode: true, type: "div", props: {…}, key: 0, ref: null, …}
  2: {_isVNode: true, type: Symbol(Fragment), props: null, key: null, ref: null, …}
  length: 3
  component: null
  dirs: null
  // 三个动态孩子节点
  dynamicChildren: Array(3)
  0: {_isVNode: true, type: Symbol(Text), props: null, key: null, ref: null, …}
  1: {_isVNode: true, type: "div", props: {…}, key: 0, ref: null, …}
  2: {_isVNode: true, type: Symbol(Fragment), props: null, key: null, ref: null, …}
  length: 3
  dynamicProps: null
  el: null
  key: null
  patchFlag: 2
  // 属性
  props: {id: "foo", class: "xx"}
  ref: null
  scopeId: null
  shapeFlag: 17
  suspense: null
  target: null
  targetAnchor: null
  transition: null
  // 标签
  type: "div"
  // 标识为虚拟节点
  _isVNode: true

#+end_src

* compile.spec.ts
由于 compile.spec.ts 原来只有一个用例，相对是比较复杂的，不利于学习。

这里将根据 [[/vue/vue3-source-code-compiler-core-parse_ts/#parse.spec.ts][parse.spec.ts]] 循序渐进的去实现 compile + transform 的功能。

下面所有的测试用例均以 vue.global.js 打包之后的文件，运行结果为前提：

#+begin_src js
  const test = `simple text`;

  const result = compile(test.trim(), {
    sourceMap: true,
    filename: "foo.vue",
  });
  console.log(result, "xx");
#+end_src

通过修改 test 值来得到真实的 render 函数。

完成了 01-simple text 用例之后发现按照 parse.spec.ts 可能不太理想，毕竟 parse 部
分的用例有点多，如果按照那个来这部分也将会很漫长，思考良久应该还是按照
compile.spec.ts 中的用例进行拆分之后右简入难式去通过该用例。

完整用例：

#+begin_src js
  const source = `
  <div id="foo" :class="bar.baz">
    {{ world.burn() }}
    <div v-if="ok">yes</div>
    <template v-else>no</template>
    <div v-for="(value, index) in list"><span>{{ value + index }}</span></div>
  </div>
  `.trim()
#+end_src

** 05-interpolation, v-if, props
:PROPERTIES:
:COLUMNS:  %CUSTOM_ID[(Custom Id)]
:CUSTOM_ID: test-cc-05
:END:

#+begin_src js
  code = `
  <div id="foo" :class="bar.baz">
  {{ world.burn() }}
  <div v-if="ok">yes</div>
  </div>`
#+end_src

增加了 ~<div v-if="ok"></div>~

ast: 在经过 parse.ts 之后应该具备看到模板能够分析出 ast 结构能力。
#+begin_src js
  {
    type: 0, // ROOT
    children: [
      { // div#foo
        type: 1, // ELEMENT
        tag: 'div',
        tagType: 0, // Start
        props: [
          { // id
            type: 6, // ATTRIBUTE
            name: 'id',
            value: {
              type: 2, // TEXT
              content: 'foo'
            }
          },
          { // :class
            type: 7, // DIRECTIVE
            name: 'bind',
            arg: {
              type: 4, // SIMPLE_EXPRESSION
              content: 'class',
              isStatic: true, // 静态参数名
              isConstant: true
            }, // 参数名 class
            exp: {
              type: 4, // SIMPLE_EXPRESSION
              content: "bar.baz",
              isStatic: false,
              isConstant: false
            }, // 表达式 bar.baz
            modifiers: [], // 修饰符
          }
        ],
        children: [
          { // world.burn
            type: 5, // INTERPOLATION
            content: {
              content: "world.burn()",
              isStatic: false,
              isConstant: false,
              type: 4, // SIMPLE_EXPRESSION
            },
          },
          { // " " 空
            type: 2, // TEXT
            content: ' '
          },
          { // div v-if
            type: 1, // ELEMENT
            tag: 'div',
            tagType: 0, // Start
            children: [
              { // yes
                type: 2, // TEXT
                content: "yes"
              }
            ],
            props: [
              {
                type: 7, // DIRECTIVE
                name: 'if',
                exp: {
                  type: 4,
                  content: "ok",
                  isStatic: false,
                  isConstant: false
                },
                modifiers: []
              }
            ]
          }
        ]
      }, // div#foo
    ],
    codegenNode: undefined
  }
#+end_src

vue.global 结果：
#+begin_src js
  (function anonymous() {
    const _Vue = Vue;
    const {
      createVNode: _createVNode,
      createCommentVNode: _createCommentVNode,
      createTextVNode: _createTextVNode,
    } = _Vue;

    const _hoisted_1 = { key: 0 };

    return function render(_ctx, _cache) {
      with (_ctx) {
        const {
          toDisplayString: _toDisplayString,
          createVNode: _createVNode,
          openBlock: _openBlock,
          createBlock: _createBlock,
          createCommentVNode: _createCommentVNode,
          createTextVNode: _createTextVNode,
        } = _Vue;

        return (
          _openBlock(),
          _createBlock(
            "div",
            {
              id: "foo",
              class: bar.baz,
            },
            [
              _createTextVNode(
                _toDisplayString(world.burn()) + " ",
                1 /* TEXT */
              ),
              ok
                ? (_openBlock(), _createBlock("div", _hoisted_1, "yes"))
                : _createCommentVNode("v-if", true),
            ],
            2 /* CLASS */
          )
        );
      }
    };
  });
#+end_src

这里有几个不同点：

1. _createBlock 第三个参数 children 变成了数组，且使用了 _createTextVNode() 创建
   虚拟节点
2. 就是多了个新增的那个 ~div v-if~ 节点
3. patchFlag 的变化


先看下修改之前的结果：

#+begin_src js
  (function anonymous() {
    return function render(_ctx, _cache) {
      with (_ctx) {
        const {
          toDisplayString: _toDisplayString,
          createVNode: _createVNode,
          camelize: _camelize,
          createTextVNode: _createTextVNode,
          openBlock: _openBlock,
          createBlock: _createBlock,
        } = _Vue;

        return (
          _openBlock(),
          _createBlock(
            "div",
            {
              id: "foo",
              class: bar.baz,
              [_camelize(prop_name)]: bar.bax,
            },
            [, _createVNode("div", null, "yes")]
          )
        );
      }
    };
  });
#+end_src

差异点：

1. 没有 render 函数外的解构
2. 没有 render 函数外的 ~const _hoisted_1 = { key: 0 };~
3. 没有 ~_createCommentVNode~
4. children 里面的差值节点丢失了
5. div v-if 节点处理错误

先解决差值问题(第 4 点)，这里插值节点为什么会丢失？

补漏：
1. 实现 [[#transform-transformif][transformIf]]

   [[#transform-createstructuraldirectivetransform][createStructuralDirectiveTransform]] 创建指令(如：v-if, v-else 等)相关的
   transform 函数，注意这里的正则： ~/^(if|else|else-if)$/~

   由于指令是存在 ~node.props~ 属性里面的，这里会直接遍历所有的属性，找出满足条件
   ~type:DIRECTIVE~ 且 ~prop.name~ 匹配上面的正则的指令。
   
   因为这里要将所有的指令转成分支类型的结构。

   #+begin_src js
     {
       type: 9, // IF
       branches: [{
         children: [{ /* 这里保存了转换之前的 v-if 节点 */}]
         condition: {
           content: 'ok',
           // ...
           type: 4, // SIMPLE_EXPRESSION
         }
         // branch
         type: 10, // IF_BRANCH
       }]
     }
   #+end_src
   
   最后处理之后得到的 ifNode 包含所有分支 ~ifNode.branches~ ， branch 即当前要处
   理的分支交给返回的那个 transform 函数待递归完成之后取处理得到该分支节点的 ~codegenNode~
   
   然后经过递归之后，回溯过程中会执行返回的那个函数(*transform if*) 进入
   [[#transform-createcodegennodeforbranch][createCodegenNodeForBranch]] -> [[#transform-createchildrencodegennode][createChildrenCodegenNode]] ->
   ~createCallExpression~ 创建分支节点 codegen。

2. 实现 [[#transform-traversenode-stage3][traverseNode]] 中的 ~IF(9)~ 和 ~IF_BRANCH(10)~ 分支

3. 实现 [[#codegen-generate][generate]] 阶段的 if 节点处理

** 04-interpolation in div with props
:PROPERTIES:
:COLUMNS:  %CUSTOM_ID[(Custom Id)]
:CUSTOM_ID: test-cc-04
:END:

code: ~`<div id="foo" :class="bar.baz">{{ world.burn() }}</div>`~

这个用例和 [[#test-cc-03][用例3]] 只有一个属性的差别，所以这里只要参考 test 03 来实现 div 属性的
解析和编译即可，所有流程和流程图可参考 03 来实现。

还是老方法，根据跟踪 vue.global debugger 过程来分析整个过程。
期待结果：
#+begin_src js
  (function anonymous(
  ) {
    const _Vue = Vue

    return function render(_ctx, _cache) {
      with (_ctx) {
        const { toDisplayString: _toDisplayString, createVNode: _createVNode, openBlock: _openBlock, createBlock: _createBlock } = _Vue

        return (_openBlock(), _createBlock("div", {
          id: "foo",
          class: bar.baz
        }, _toDisplayString(world.burn()), 3 /* TEXT, CLASS */))
      }
    }
  })
#+end_src

[[#transform-createstructuraldirectivetransform][createStructuralDirectiveTransform(name, fn)]] 如果存在属性，都会经过这个函数是因
为 ~if,else-if,else,for~ 的 transform 都是通过这个创建的，所以在经过
[[#transform-traversenode][traverseNode]] 中的 exitFns 收集过程中会执行到这里。

然后这个用例中并没有 v-if, v-for 类似的分支指令，所以这些 transform* 不会被收集
到。

~root.children[0]: div~ 收集 [[#transform-transformelement][transformElement]] ，ELEMENT 类型需要收集来解析出 codegenNode。

[[/img/vue3/compiler-core/compiler-test-interpolation-in-div-with-props.svg]]

流程图分析：这里和 [[#test-cc-03][03]] 对比多了两部分处理
1. transform 阶段的 *props 解析*

   这一阶段的处理发生在 transformElement 中对 props 属性的检测，一旦检测到有属性
   列表，需要经过 [[#transform-buildprops][buildProps]] 解析出新的属性对象:

   buildProps 之前的 props
   #+begin_src js
     props: Array(2)
     0: // 属性 id
     loc: {..., source: "id="foo""}
     name: "id"
     type: 6 // ATTRIBUTE
     value:
     content: "foo"
     loc: {..., source: ""foo""}
     type: 2 // TEXT
     1: // 属性 :class
     arg:
     content: "class"
     isConstant: true
     isStatic: true
     loc: {..., source: "class"}
     type: 4 // SIMPLE_EXPRESSION
     exp:
     content: "bar.baz"
     isConstant: false
     isStatic: false
     loc: {..., source: "bar.baz"}
     type: 4 // SIMPLE_EXPRESSION
     loc: {..., source: ":class="bar.baz""}
     modifiers: []
     name: "bind"
     type: 7 // DIRECTIVE
   #+end_src

   buildProps 解析之后：

   #+begin_src js
     Return value: Object
     directives: []
     dynamicPropNames: []
     patchFlag: 2 // CLASS
     props:
     properties: Array(2)
     0:
     key: {type: 4, isConstant: false, content: "id", isStatic: true}
     type: 16 // JS_ARRAY_EXPRESSION
     value: {type: 4, isConstant: false, content: "foo", isStatic: true}
     1:
     key: {type: 4, content: "class", isStatic: true, isConstant: true}}
     type: 16
     value: {type: 4, content: "bar.baz", isStatic: false, isConstant: false,
             type: 15 // JS_PROPERTY
   #+end_src

   这里面的处理分为两种类型： 1. *ATTRIBUTE<6>* 类型， 2. *DIRECTIVE<7>* 指令类型是
   分开处理的，普通属性调用 ~createObjectProperty(key, value)~ 构建新的对象，指
   令属性通过指令名称从 ~context.directiveTransforms~ 对象中取出对应的函数进行处
   理，比如 ~v-bind~ 对应函数 [[#transform-transformbind][transformBind(prop, node, context)]] 处理。

   比如： ~id="foo"~ 处理之后的
   #+begin_src js
     Return value: Object
     key: // 属性名
     content: "id"
     isConstant: false
     isStatic: true
     loc: {source: "id"}
     type: 4 // SIMPLE_EXPRESSION
     type: 16 // JS_PROPERTY
     value: // 属性值
     content: "foo"
     isConstant: false
     isStatic: true
     loc: {source: ""foo""}
     type: 4 // SIMPLE_EXPRESSION

     // 包含 key, type, value 三个属性值
   #+end_src

   比如： ~:class="bar.baz"~ 处理之后的

   #+begin_src js
     Return value: Object
     props: Array(1)
     0:
     key:
     content: "class"
     isConstant: true
     isStatic: true
     type: 4 // SIMPLE_EXPRESSION
     type: 16 // JS_ARRAY_EXPRESSION
     value:
     content: "bar.baz"
     isConstant: false
     isStatic: false
     type: 4

     // 包含 key, type, value，和普通属性类型不一样
     // 这里是 JS_ARRAY_EXPRESSION
   #+end_src

2. generate 阶段的 *props 解析*

   render 函数生成阶段， [[#ast-genvnodecall][genVNodeCall]] 解析 ~codegenNode~, 其中有一个
   [[#ast-gennodelist][genNodeList(nodes, ...)]] 这里的 nodes 是 ~[tag, props, children, patchFlag,
   ...]~ 该用例中相比[[#test-cc-03][用例03]] 这里的 props 不是 null ，所以在 ~genNodeList~ 中 ~i = 1~
   的时候会进入到 [[#ast-gennode][genNode(props, context)]] 去解析属性列表。

   进入之前 props 值：
   #+begin_src js
     loc: {source: "<div id="foo" :class="bar.baz">{{ world.burn() }}</div>"}
     properties: (2) [{…}, {…}] // 这里是 id, class 两个属性
     type: 15 // JS_OBJECT_EXPRESSION
   #+end_src

   类型为 *JS_OBJECT_EXPRESSION<15>* 在 ~genNode~ 里面会进入 [[#ast-genobjectexpression][genObjectExpression(node,
   context)]] 分支将属性解析成对象，如： ~{id: "foo", class: bar.baz}~ 。

   ~genObjectExpression~ 里面对属性的处理主要分两步，先调用
   [[#ast-genexpressionaspropertykey][genExpressionAsPropertyKey(node, context)]] 去处理属性名 key node，完成之后，再调
   用 [[#ast-gennode][genNode(value, context)]] 去处理值 value node(最后进入 [[#ast-genexpression][genExpression(node,
   context)]], 因为类型为 *SIMPLE_EXPRESSION<4>*)。

   最后得到 ~{id: "foo", class: bar.baz}~ 作为 ~createBlock('div', ...)~ 的第二个参数。

修改完之后运行结果：
#+begin_src js
  (function anonymous(
  ) {

    return function render(_ctx, _cache) {
      with (_ctx) {
        const { toDisplayString : _toDisplayString, createVNode : _createVNode, openBlock : _openBlock, createBlock : _createBlock } = _Vue

        return (_openBlock(), _createBlock("div", { id: "foo" }, _toDisplayString(world.burn()), 1 /* TEXT */))
      }
    }
  })
#+end_src

结果与正确结果又两点缺陷：
1. 属性漏掉了 ~class~
2. patchFlag 那里不对，正确应该是 ~3 /* TEXT, CLASS */~

没有报错能走通说明至少逻辑是通的出现上面两个问题原因，溯源起来也很清晰，因为我们
知道 props 在 transform 阶段是 [[#transform-transformelement][transformElement]] 里面，generate 阶段是在
[[#codegen-genobjectexpression][genObjectExpression()]] 中, 而 patchFlag 也是在 ~transformElement~ 处理的。

通过在 [[#codegen-genobjectexpression][genObjectExpression()]] for 循环中增加打印，显示 properties 中只有一个 id
属性，那么属性解析最后是在 [[#transform-buildprops][buildProps]] 里面的， bingo!!! 没有实现 [[#transform-transformbind][transformBind]] 。

那么修改点有二：
1. 在 compile.ts 的 [[#compile-getbasetransformpreset][getBaseTransformPreset]] 增加指令 transform 函数 [[#transform-transformbind][transformBind]]
2. 实现 ~transformBind~

修改之后：
#+begin_src js
  (function anonymous(
  ) {

    return function render(_ctx, _cache) {
      with (_ctx) {
        const { toDisplayString : _toDisplayString, createVNode : _createVNode, openBlock : _openBlock, createBlock : _createBlock } = _Vue

        return (_openBlock(), _createBlock("div", {
          id: "foo",
          class: bar.baz
        }, _toDisplayString(world.burn()), 3 /* TEXT, CLASS */))
      }
    }
  })
#+end_src

*** 扩展 1：增加 ~camel~ 修饰符

code: ~`<div id="foo" :class="bar.baz" :test-prop.camel="bar.bax">{{ world.burn() }}</div>`~

结果：
#+begin_src js
  (function anonymous(
  ) {

    return function render(_ctx, _cache) {
      with (_ctx) {
        const { toDisplayString : _toDisplayString, createVNode : _createVNode, openBlock : _openBlock, createBlock : _createBlock } = _Vue

        return (_openBlock(), _createBlock("div", {
          id: "foo",
          class: bar.baz,
          testName: bar.bax
        }, _toDisplayString(world.burn()), 3 /* TEXT, CLASS */))
      }
    }
  })
#+end_src

因为 transformBind 中有检测修饰符中是否包含 ~camel~ ，如果有则会进行驼峰转换，否
则不会转而是将 *test-prop* 用引号包起来： ~"test-prop"~ 。
*** 扩展 2：动态属性且有 ~camel~ 修饰符

code: ~`<div id="foo" :class="bar.baz" :[prop_name].camel="bar.bax">{{ world.burn() }}</div>`~

这个时候需要实现 transform.js 中 [[#transform-createtransformcontext][createTransformContext]] 中 ~context.helperString~

#+begin_src js
  helperString(name) {
    return `_${helperNameMap[context.helper(name)]}`;
  }
#+end_src

结果：
#+begin_src js
  (function anonymous(
  ) {

    return function render(_ctx, _cache) {
      with (_ctx) {
        const { toDisplayString : _toDisplayString, camelize : _camelize, createVNode : _createVNode, openBlock : _openBlock, createBlock : _createBlock } = _Vue

        return (_openBlock(), _createBlock("div", {
          id: "foo",
          class: bar.baz,
          [_camelize(prop_name)]: bar.bax
        }, _toDisplayString(world.burn()), 1 /* TEXT */))
      }
    }
  })
#+end_src

会发现这里多解构了个 ~_camelize~ 函数出来，通过函数调用方式去处理动态属性名。
** 03-inerpolation in pure div
:PROPERTIES:
:COLUMNS:  %CUSTOM_ID[(Custom Id)]
:CUSTOM_ID: test-cc-03
:END:

test:
#+begin_src js
  const source = `<div>{{ world.burn() }}</div>`.trim();

  const result = compile(source, {
    sourceMap: true,
    filename: `foo.vue`,
  });
#+end_src

vue.global:
#+begin_src js
  (function anonymous(
  ) {
    const _Vue = Vue

    return function render(_ctx, _cache) {
      with (_ctx) {
        const { toDisplayString: _toDisplayString, createVNode: _createVNode, openBlock: _openBlock, createBlock: _createBlock } = _Vue

        return (_openBlock(), _createBlock("div", null, _toDisplayString(world.burn()), 1 /* TEXT */))
      }
    }
  })
#+end_src

先阶段的结果：
#+begin_src js
  ƒ render(_ctx, _cache) {
    with (_ctx) {
      return
    }
  } "compiled"
#+end_src

流程图：
[[/img/vue3/compiler-core/compiler-test-interpolation-in-div.svg]]

流程分析：

1. [[/vue/vue3-source-code-compiler-core-parse_ts/#parse-baseparse][baseParse(template, options)]] 解析出 ast
2. [[/vue/vue3-source-code-compiler-core-compile_ts/#transform-transform][transform(ast, ...)]] 递归遍历处理 root.children 生成各节点的 codegenNode

   1) [[/vue/vue3-source-code-compiler-core-compile_ts/#transform-traversenode][traverseNode(root, context)]] 核心函数，结合 traverseChildren 通过遍历+递归
      处理所有节点，收集对应的 transform* 函数，在结束递归之后回溯过程中执行这些
      transform* 来收集节点对应的 codegenNode

      - 遍历所有的 ~nodeTrasforms[]~ 来收集当前节点满足条件的 transform* 函数
        到 ~exitFns[]~ 中，比如： 这里的 ELEMENT 类型(~<div></div>~)会收集到
        [[/vue/vue3-source-code-compiler-core-compile_ts/#transform-transformelement][transformElement]] 和 [[/vue/vue3-source-code-compiler-core-compile_ts/#transform-transformtext][transformText]] 。
      - ~NodeTypes.ROOT~ 进入 [[/vue/vue3-source-code-compiler-core-compile_ts/#transform-traversechildren][traverseChildren(node, context)]] 继续处理
        ~root.children~ ，这里同时会记录每个节点的 *parent* 值，ROOT 类型收集 *transformText* 。
      - ~NodeTypes.ELEMENT~ 也会进入到 ~traverseChildren(node, context)~ 处理
        ~node.children~ ，赋值 *parent*, 收集 ~transformText~ 和 ~transformElement~ 。
      - ~NodeTypes.INTERPOLATION~ 对于插值节点，不会进入 ~traverseChildren~ 而是在
        switch 分支中调用 ~context.helper()~ 去更新 ~context.helpers~ 用来从 ~Vue~ 中
        解构出需要的函数。
   2) TODO hoistStatic(root, context) 静态提升用的，针对静态节点提升到函数外面(这里暂
      时未深入，没用到)
   3) [[/vue/vue3-source-code-compiler-core-compile_ts/#transform-createrootcodegen][createRootCodegen(root, context)]] 生成 root.codegenNode ，有可能是来自第一
      个且唯一一个孩子节点，分为两个分支具体细节点击函数链接。

   经过 *transform* 处理之后的 ~ast~ 对象
   #+begin_src js
     { // 去掉不重要的部分
       "type":0, // ROOT 类型
       "children":[
         {
           "type":1, // ELEMENT 类型
           "tag":"div",
           "tagType":0, // Start
           "children":[
             {
               "type":5, // INTERPOLATION
               "content":{
                 "type":4, // SIMPLE_EXPRESSION
                 "isStatic":false,
                 "isConstant":false,
                 "content":"world.burn()",
               },
             }
           ],
           "codegenNode":{
             // 这里实际上是 root.children[0] 经过 transformElement 之后的结果
             // 变成了VNODE_CALL 在 codegen-generate 处理部分会用到
             "type":13, // VNODE_CALL
             "tag":""div"",
             "children":{
               "type":5, // INTERPOLATION
               "content":{
                 "type":4, // SIMPLE_EXPRESSION
                 "isStatic":false,
                 "isConstant":false,
                 "content":"world.burn()",
               },
             },
             "patchFlag":"1 /* TEXT */", // 这个目前不知道干啥的
             "isBlock":true, // 决定使用 openBlock/createBlock, 还是 createVNode
             "isForBlock":false,
           }
         }
       ],
       "codegenNode":{ // root 根节点的
         // 在 createRootCodegen 中有个处理是，如果root.children 有且只有一个
         // ELEMENT 类型的节点的时候，root.codegenNode 会被这个节点的 codegenNode
         // 覆盖，即root 使用它唯一的孩子节点的 codegenNode
         "type":13, // VNODE_CALL
         "tag":""div"",
         "children":{
           "type":5,
           "content":{
             "type":4,
             "isStatic":false,
             "isConstant":false,
             "content":"world.burn()",
           },
         },
         "patchFlag":"1 /* TEXT */",
         "isBlock":true,
         "isForBlock":false,
       },
     }
   #+end_src

3. [[/vue/vue3-source-code-compiler-core-compile_ts/#codegen_generate][generate(ast, ...)]] 生成代码片段 -> ~new Function(context.code)~

   1) [[/vue/vue3-source-code-compiler-core-compile_ts/#codegen-genfunctionpreamble][genFunctionPreamble(ast, context)]] 主要使用来检测环境从而导入 Vue 实例
      (如：~const _Vue = Vue~)，最后 render 函数的 ~`return `~ 也是这里生成的。
   2) [[/vue/vue3-source-code-compiler-core-compile_ts/#codegen-gennode][genNode(ast.codegenNode, context)]] 对每个 ast 节点结构进行处理，生成对应的
      Render 函数相关部件。
   3) [[eww:/vue/vue3-source-code-compiler-core-compile_ts/#headline-39][genVNodeCall(node, context)]] 生成节点的参数，调用函数之类的，如：
      ~openBlock()~ , ~createBlock(...)~ 及参数列表 ~createBlock(tag, props,
      children, patchFlag, ...)~ ，指令等部件。
   4) patchFlag 是在 [[/vue/vue3-source-code-compiler-core-compile_ts/#transform-transformelement][transformElement]] 里面处理值的。

      经过 *generate* 之后生成的 ~render~ 函数：

      #+begin_src js
        (function anonymous(
        ) {
          const _Vue = Vue

          return function render(_ctx, _cache) {
            with (_ctx) {
              const { toDisplayString: _toDisplayString, createVNode: _createVNode, openBlock: _openBlock, createBlock: _createBlock } = _Vue

              return (_openBlock(), _createBlock("div", null, _toDisplayString(world.burn()), 1 /* TEXT */))
            }
          }
        })
      #+end_src

      ~render({ world: { burn() { return `burn the world !` }}})~ 执行之后得到的
      VNode 节点：

      #+begin_src js
        {
          "_isVNode":true,
          "type":"div",
          "props":null,
          "key":null,
          "ref":null,
          "scopeId":null,
          "children":"burn the world !",
          "component":null,
          "suspense":null,
          "dirs":null,
          "transition":null,
          "el":null,
          "anchor":null,
          "target":null,
          "targetAnchor":null,
          "shapeFlag":9,
          "patchFlag":1,
          "dynamicProps":null,
          "dynamicChildren":[

          ],
          "appContext":null
        }
      #+end_src
** 02-pure interpolation 第一个孩子节点
:PROPERTIES:
:COLUMNS:  %CUSTOM_ID[(Custom Id)]
:CUSTOM_ID: test-cc-02
:END:

~{{ world.burn() }}~

测试：
#+begin_src js
  const test01 = `{{ world.burn() }}`;

  const result = compile(test01.trim(), {
    sourceMap: true,
    filename: "foo.vue",
  });
  console.log(result, "xx");
#+end_src

vue.global 结果：
#+begin_src js
  ƒ render(_ctx, _cache) {
    with (_ctx) {
      const { toDisplayString: _toDisplayString } = _Vue

      return _toDisplayString(world.burn())
    }
  }
#+end_src

[[#test-cc-01][01-simple text]] 阶段代码返回的结果:

#+begin_src js
  ƒ render(_ctx, _cache) {
    with (_ctx) {
      return  // 这里没任何东西
    }
  }
#+end_src

通过[[#test-cc-01][用例 01]] 大概的完成了一个比较完整的编译过程，要通过该用例应该只需要在这过程中增
加对插值的处理即可。

处理步骤(通过用例 01 总结出的步骤)：

[[#compile-basecompile][baseCompile]] -> [[/vue/vue3-source-code-compiler-core-parse_ts/#parse-baseparse][baseParse]] -> [[#compile-getbasetransformpreset][getBaseTransformPreset]] 得到 transform 函数 ->
[[#transform-transform][transform]] -> [[#codegen-generate][generate]]

1. [[/vue/vue3-source-code-compiler-core-parse_ts/#parse-baseparse][baseParse]] -> ast
2. [[#compile-getbasetransformpreset][getBaseTransformPreset]] -> 这里并没有什么 transformInterpolation，插值并没有
   对应的 transform 函数，而是直接在 generate 中结合 ~ast.helpers~ 处理。
3. [[#transform-transform][transform]] -> [[#transform-createtransformcontext][createTransformContext]] -> [[#transform-traversenode][traverseNode]] -> [[#transform-createrootcodegen][createRootCodegen]] -> ...

   这一步需要处理的应该只有 [[#transform-traversenode][traverseNode]] 需要修改，在 switch 里增加
   INTERPOLATION 分支，因为 [[#codegen-createrootcodegen][createRootCodegen]] 里面 root 如果只有一个孩子的情况
   下会和[[#test-cc-01][用例 01]] 一样直接赋值 ~context.codegenNode = root.children[0]~

4. [[#codegen-generate][generate]] -> [[#codegen-createcodegencontext][createCodegenContext]] -> [[#codegen-genfunctionpreamble][genFunctionPreamble]] 默认是 function 模
   式 -> push ~function render(_ctx, _cache) {~ -> push ~with (_ctx)~ -> ...
   -> [[#codegen-gennode][genNode(ast.codegenNode, context)]]

   这里需要修改的点应该只有 genNode 里面，也是增加 INTERPOLATION switch 分支，
   处理插值部分的代码。


有了上面的初步分析，这里可以比较明确的知道需要修改的点：

1. DONE  *traverseNode* 中增加 INTERPOLATION 分支
2. DONE  *genNode* 中增加 INTERPOLATION 分支
3. DONE  *genNode* 中增加 SIMPLE_EXPRESSION 分支处理插值内的表达式


+修正：事实上并没有 transformInterpolation+ :facepalm::facepalm::facepalm::facepalm:

修改完之后报错：
#+begin_example
transform.js:184 Uncaught TypeError: Cannot read property 'length' of undefined
    at traverseChildren (transform.js:184)
    at traverseNode (transform.js:119)
    at traverseChildren (transform.js:192)
    at traverseNode (transform.js:119)
    at transform (transform.js:133)
    at baseCompile (compile.js:37)
    at compile.html:12
#+end_example

根据报错定位到，在解析 root.children[0] 的时候经过 [[#transform-traversechildren][traverseChildren]] 里面时候的
parent.children 值为 undefined。

原因是 traverseNode 里面的 NodeTypes.INTERPOLATION 分支没有加 break 导致的，加上
之后：

#+begin_src js
  ƒ render(_ctx, _cache) {
    with (_ctx) {
      const { toDisplayString : _toDisplayString } = _Vue

      return
    }
  } "compiled"
#+end_src

和正确结果相比少了点东西 ~return _toDisplayString(world.burn())~

1. with 内的解构来源：

   #+begin_src js
     function generate() {
       // ...
       if (hasHelpers) {
         // 比如：插值处理时用到 TO_DISPLAY_STRING helper
         // 为了避免命名冲突，这里都需要将他们重命名

         // traverseNode 里面 context.help(helper)
         push(
           `const { ${ast.helpers
               .map((s) => `${helperNameMap[s]} : _${helperNameMap[s]}`)
               .join(", ")} } = _Vue`
         );

         push("\n");
         newline();
       }
       // ...
     }
   #+end_src

2. 缺少的 ~return _toDisplayString(world.burn())~

   - [[#codegen-generate][generate]] 中最后 push `return `

   - 执行 [[#codegen-gennode][genNode(ast.codgenNode, context)]] 处理缺少的部分

     #+begin_src js
       {type: 5, content: {…}, loc: {…}}
       content:
       content: "world.burn()"
       isConstant: false
       isStatic: false
       loc: {start: {…}, end: {…}, source: "world.burn()"}
       type: 4 // SIMPLE_EXPRESSION，第二步
       loc: {start: {…}, end: {…}, source: "{{ world.burn() }}"}
       type: 5 // INTERPOLATION，第一步
     #+end_src

     1) node 类型首先是 INTERPOLATION ，进入 [[#codegen-geniinterpolation][genInterpolation(node, context)]]

        #+begin_src js
          function genInterpolation(node, context) {
            const { push, helper, pure } = context;

            if (pure) push(PURE_ANNOTATION);

            // 这里从 helpers 里面取出 toDisplayString
            push(`${helper(TO_DISPLAY_STRING)}(`);

            // 这里生成 `world.burn()` SIMPLE_EXPRESSION 类型
            genNode(node.content, context);
            push(`)`);
          }
        #+end_src

     2) 取 node.content 调用 [[#codegen-gennode][genNode(node.content, context)]] 生成 `world.burn()`
        表达式。

        进入 ~switch node.type === NodeTypes.SIMPLE_EXPRESSION~ 分支，调用
        [[#codegen-genexpression][genExpression(node, context)]]

:sunflower: Perfect: 最后结果：

#+begin_src js
  ƒ render(_ctx, _cache) { // generate
    with (_ctx) { // useWithBlock
      const { toDisplayString : _toDisplayString } = _Vue // ast.helpers

      return _toDisplayString(world.burn()) // genNode -> genInterpolation -> genExpression
    }
  } // "compiled"
#+end_src

完整流程图：

[[/img/vue3/compiler-core/compiler-test-pure-interpolation.png]]

** 01-simple text
:PROPERTIES:
:COLUMNS:  %CUSTOM_ID[(Custom Id)]
:CUSTOM_ID: test-cc-01
:END:

compiled：
#+begin_src js
  (function anonymous(
  ) {

    return function render(_ctx, _cache) {
      with (_ctx) {
        return "simple text"
      }
    }
  })
#+end_src

也就是说 *"simple text"* 最后转变成的 render 函数如上所示。

我们的第一步就是如何来实现 compile 和 transform 能得到这样的结果，这将是该模块完
成第一步 🆙 🆙 🆙 🆙 🆙 🆙 🆙 🆙 🆙 🆙

parse 之后的 ast:
#+begin_src js
  {type: 0, children: Array(1), loc: {…}, helpers: Array(0), components: Array(0), …}
  cached: 0
  children: Array(1)
  0:
  content: "simple text"
  loc: {start: {…}, end: {…}, source: "simple text"}
  type: 2
  length: 1
  codegenNode: undefined
  components: []
  directives: []
  helpers: []
  hoists: []
  imports: []
  loc: {start: {…}, end: {…}, source: "simple text"}
  temps: 0
  type: 0
#+end_src


在完成 [[#transform-transformtext][transformText]] 之后，发现 result.code 是空的，还以为是这里面实现问题的，其
实是 [[#codegen-generate][generate]] 函数还没实现的原因。

所有需要支持的函数都完成之后：

#+begin_example
{ast: {…}, code: "function render(_ctx, _cache) {↵ with (_ctx) {↵  return "simple text"}}", map: ""}
  ast: {type: 0, children: Array(1), loc: {…}, helpers: Array(0), components: Array(0), …}
    code: "function render(_ctx, _cache) {↵ with (_ctx) {↵  return "simple text"}}"
    map: ""
#+end_example

会发现最终的 code 即我们想要的 render 函数，和用 vue.global.js 生成的一致。

如果需要将转成函数，这个需要用到 compileToFunction 这个不在我们这个讨论范围，其
实里面也很简单，直接调用 ~new Function(code)~ 就行了，来看下：

#+begin_src js
  import { baseCompile as compile } from "../compile.js";

  const source = `simple text`.trim();

  const result = compile(source, {
    sourceMap: true,
    filename: `foo.vue`,
  });
  const render = new Function(result.code);
  console.log(render, "compiled");
#+end_src

输出：
#+begin_example
ƒ anonymous(
) {
function render(_ctx, _cache) {
 with (_ctx) {
  return "simple text"}}
} "compiled"
#+end_example

然后会发现结果好像不太对，首先 render 会被一个匿名函数包起来，这个是没问题的，但
是貌似匿名函数没有结束的 *}* 这个我想问题肯定处在了 [[#codegen-generate][generate]] 里面。

其实是因为 [[#codegen-createcodgencontext][createCodgenContext]] 里面的 函数没有实现，另外这样是不对的，因为 ~new
Function(code)~ 会将 code 用一个匿名函数来包裹起来，因此想要得到 render 函数，必
须是以 return 形式返回，因此这里还有个遗漏的地方: [[#codegen-genfunctionpreamble][genFunctionPreamble]] 需要去实
现，这里面最后会 push 一个 return 到 code 开头。

更新后输出：
#+begin_src js
  ƒ anonymous(
  ) {

    return function render(_ctx, _cache) {
      with (_ctx) {
        return "simple text"
      }
    }
  }
#+end_src

在实现 genFunctionPreamble 之后，至此完成了一个得到 render 函数的完整过程。

下面将使用流程图方式进行回顾，分析整个过程。

[[/img/vue3/compiler-core/compiler-test-simple-text.png]]

* 函数列表
** compile.ts
*** baseCompile(template, options)
:PROPERTIES:
:COLUMNS:  %CUSTOM_ID[(Custom Id)]
:CUSTOM_ID: compile-basecompile
:END:

将 template 解析成 render 函数，重点步骤:

1. [[vue/vue3-source-code-compiler-core-parse_ts/][baseParse(template, options)]] 将字符串模板解析成 AST 对象。
2. [[#transform-transform][transform(ast, ...)]] 将 AST 进一步转换处理
3. 将转换后的 ast 调用 codegen 的 generate 方法生成 render 。

#+begin_src js
  export function baseCompile(template, options) {
    const isModuleMode = options.mode === "module";

    // ... 略去错误❎处理
    const prefixIdentifiers =
          !__BROWSER__ && (options.prefixIdentifiers === true || isModuleMode);

    // 1. baseParse 得到 AST 对象，两种情况：1. 未解析的模板，2. 以解析之后的 ast 对象
    const ast =
          typeof template === "string" ? baseParse(template, options) : template;

    // 2. 取出所有 node 和 directive 的 transforms
    const [nodeTransforms, directiveTransforms] = getBaseTransformPreset(
      prefixIdentifiers
    );

    // 3. 进行转换，调用 transform
    transform(ast, {
      // 合并选项
      ...options, // 调用 baseCompile 时候的第二个参数
      prefixIdentifiers, // 还不知道是干啥的???
      // 节点转换器合并，外部转换器优先，即使用者可自定义自己的转换器
      nodeTransforms: [...nodeTransforms, ...(options.nodeTransforms || {})],
      // 指令转换器，同上。
      directiveTransforms: [
        ...directiveTransforms,
        ...(options.directiveTransforms || {}),
      ],
    });

    // 4. 调用 generate 生成 render 函数的 codegen 并返回，这就是我们需要的组件渲
    // 染函数
    return generate(ast, {
      ...options,
      prefixIdentifiers,
    });
  }
#+end_src

这也是除了错误处理之后的完整的 baseCompile 函数实现。
*** getBaseTransformPreset(prefixIdentifiers: boolean)
:PROPERTIES:
:COLUMNS:  %CUSTOM_ID[(Custom Id)]
:CUSTOM_ID: compile-getbasetransformpreset
:END:

合并所有 transform，返回一个 ~TransformPreset~ 类型的数组

**** stage-2:
:PROPERTIES:
:COLUMNS:  %CUSTOM_ID[(Custom Id)]
:CUSTOM_ID: compile-getbasetransformpreset-stage-2
:END:

增加 transformBind 指令处理，处理 ~:class = "bar.baz"~ 的时候需要用到
#+begin_src js

  export function getBaseTransformPreset(prefixIdentifiers) {
    return [
      [
        // ... 省略其他，第一阶段我们应该只需要文本转换
        transformText,
        ...(!__BROWSER__ && prefixIdentifiers ? [transformExpression] : []),
        transformElement,
      ],
      {
        // ...省略指令
        bind: transformBind,
      },
    ];
  }
#+end_src
**** stage-1: [[#test-cc-01][01-simple text]]
:PROPERTIES:
:COLUMNS:  %CUSTOM_ID[(Custom Id)]
:CUSTOM_ID: compile-getbasetransformpreset-stage-1
:END:

第一阶段我们只需要文本转换，通过 [[#test-cc-01][用例一]] 即可，所以这里就只保留
[[transform-transformtext][transformText]] 就可以了，剩下的就是去实现它。

#+begin_src js
  export function getBaseTransformPreset(prefixIdentifiers) {
    return [
      [
        // ... 省略其他，第一阶段我们应该只需要文本转换
        transformText,
      ],
      {
        // ...省略指令
      },
    ];
  }
#+end_src

** tranform.ts
*** transformExpression(node, context)
:PROPERTIES:
:COLUMNS:  %CUSTOM_ID[(Custom Id)]
:CUSTOM_ID: transform-transformexpression
:END:
*** transformText(node, context)
:PROPERTIES:
:COLUMNS:  %CUSTOM_ID[(Custom Id)]
:CUSTOM_ID: transform-transformtext
:END:

该函数会返回一个用来转换文本节点类型(~NodeTransform~)的函数。

返回函数分析(~return () => { ... }~)，主要由三个 for 构成：

1. 第一个 for 嵌套第二个 for 构成双重循环，用来合并 node.children 里面相邻的文本
   节点

   第一个 For 里面使用的是 children.length 动态获取当前数组的长度，结合代码中的
   splice 和 j--。从而完成合并操作。

   #+begin_src js
     // 1. 原来的 child 被重写
     // 2. child, ` + `, next 合并到了新 child.children 里面
     currentContainer.children.push(` + `, next);
     // 删除被合并的文本节点
     children.splice(j, 1);
     j--; // -1 是因为上面删除了当前元素，for 循环过程中长度是动态获取的
   #+end_src

2. 第三个 for 遍历第一步之后的 children，对每个 child 进行重定义，类型改变成
   ~NodeTyeps.TEXT_CALL~ 类型，增加 codegenNode 属性。


代码完整版：
#+begin_src js

  export const transformText = (node, context) => {
    // 文本转换只能是下面四种类型
    const validTypes = [
      NodeTypes.ROOT,
      NodeTypes.ELEMENT,
      NodeTypes.FOR,
      NodeTypes.IF_BRANCH,
    ];

    // 合法类型检测
    if (validTypes.indexOf(node.type)) {
      // 返回一个可执行函数，记得在 transformNode 吗，这个返回的函数
      // 将会被它在 while 中 执行 掉。
      return () => {
        const children = node.children;

        let currentContainer = undefined;
        let hasText = false;

        // 双重循环，合并所有相邻的文本节点
        // 如：[text1, text2, element, text3, ele, text4, text5]
        // text1 和 text2 会合并到text1
        // text3 不会合并
        // text4 和 text5 会被合并
        for (let i = 0; i < children.length; i++) {
          const child = children[i];

          if (isText(child)) {
            // TODO 文本节点才进行解析
            hasText = true;
            // 合并相邻的文本节点， text1 + text2
            for (let j = i + 1; j < children.length; j++) {
              const next = children[j];
              // 下一个也是文本节点的时候，要将两者合并
              if (isText(next)) {
                if (!currentContainer) {
                  // 这里等于重写了 child 的引用，将自身 push 到了
                  // 新结构中的 children
                  currentContainer = children[i] = {
                    type: NodeTypes.COMPOUND_EXPRESSION,
                    loc: child.loc,
                    children: [child],
                  };
                }

                // 1. 原来的 child 被重写
                // 2. child, ` + `, next 合并到了新 child.children 里面
                currentContainer.children.push(` + `, next);
                // 删除被合并的文本节点
                children.splice(j, 1);
                j--; // -1 是因为上面删除了当前元素，for 循环过程中长度是动态获取的
              } else {
                currentContainer = undefined;
                break;
              }
            }
          }
        }

        // 集中不满足转换条件的情况
        if (
          // 1. 没有文本内容
          // 2. 只有一个孩子节点
          //   2.1 组件根节点
          //   2.2 <element> 元素节点
          !hasText ||
            (children.length === 1 &&
             (node.type === NodeTypes.ROOT ||
              (node.type === NodeTypes.ELEMENT &&
               node.tagType === ElementTypes.ELEMENT)))
        ) {
          return;
        }

        // 开始转换
        for (let i = 0; i < children.length; i++) {
          const chld = children[i];
          if (isText(child) || child.type === NodeTypes.COMPOUND_EXPRESSION) {
            const callArgs = [];

            // 非文本节点，直接 push 掉，这里 child.content !== ' ' 的原因在于
            // parseChildren 里面 while 循环最后有个remove whitespace 操作
            // 会将有效的空节点转成一个空格的字符串。
            // createTextVNode 默认是一个单空格
            if (child.type !== NodeTypes.TEXT || child.content !== " ") {
              callArgs.push(child);
            }

            // 非服务端渲染，且非文本节点
            if (!context.ssr && child.type !== NodeTypes.TEXT) {
              callArgs.push(
                // TODO 这个是干嘛的？？？
                `${PatchFlags.TEXT} /* ${PatchFlagNames[PatchFlags.TEXT]} */`
              );
            }

            children[i] = {
              type: NodeTypes.TEXT_CALL, // 文本函数
              content: child,
              loc: child.loc,
              codegenNode: createCallExpression(
                context.helper(CREATE_TEXT),
                callArgs
              ),
            };
          }
        }
      };
    }
  }
#+end_src

使用到的外面函数和属性：

1. CREATE_TEXT： 一个符号属性 ~export const CREATE_TEXT = Symbol(__DEV__ ? `createTextVNode` : ``);~
2. [[#ast-createcallexpression][createCallExpression(callee, args, loc)]] 返回 JS_CALL_EXPRESSION 类型对象。
3. PatchFlags 和 PatchFlagNames 一个名字映射
4. isText 文本节点类型(插值和 text)

   #+begin_src js
     export function isText(node) {
       // 插值或 text 均视为文本
       return node.type === NodeTypes.INTERPOLATION || node.type === NodeTypes.TEXT;
     }
   #+end_src


*对应的虚拟节点创建函数： createTextVNode*
*** transform(root, options)
:PROPERTIES:
:COLUMNS:  %CUSTOM_ID[(Custom Id)]
:CUSTOM_ID: transform-transform
:END:

调用的函数：
1. [[#transform-createtransformcontext][createTransformContext(root, options)]] 创建 transform 转换器类型的上下文对象
2. [[#transform-traversenode][traverseNode(root, context)]] 遍历所有节点
3. ssr 服务端渲染处理
4. 初始化 root 根节点上的一些属性

#+begin_src js

  export function transform(root, options) {
    const context = createTransformContext(root, options);

    traverseNode(root, context);

    if (options.hoistStatic) {
      hoistStatic(root, context);
    }

    // ... ssr 处理

    // root 属性合并，初始化
    root.helpers = [...context.helpers];
    root.components = [...context.components];
    root.directives = [...context.directives];
    root.imports = [...context.imports];
    root.hoists = context.hoists;
    root.temps = context.temps;
    root.cached = context.cached;
  }
#+end_src
*** transformElement(node, context)
:PROPERTIES:
:COLUMNS:  %CUSTOM_ID[(Custom Id)]
:CUSTOM_ID: transform-transformelement
:END:

**** stage-2
**** stage-1 [[#test-cc-03][03-inerpolation in pure div]]

#+begin_src js

  export const transformElement = (node, context) => {
    if (
      !(
        // 首先必须是 ELEMENT 类型
        (
          node.type === NodeTypes.ELEMENT &&
            // 然后是标签类型为 element 或者是 component 组件
          (node.tagType === ElementTypes.ELEMENT ||
           node.tagType === ElementTypes.COMPONENT)
        )
      )
    ) {
      return;
    }

    return function postTransformElement() {
      const { tag, props } = node;
      const isComponent = node.tagType === ElementTypes.COMPONENT;

      // 虚拟节点的 tag 类型，test-03 直接返回 `div`
      const vnodeTag = isComponent
            ? resolveComponentType(node, context)
            : `"${tag}"`;

      // 是不是动态组件
      const isDynamicComponent =
            typeof vnodeTag === "object" &&
            vnodeTag.callee === RESOLVE_DYNAMIC_COMPONENT;

      // TODO ... 声明一些变量
      let vnodeProps;
      let vnodeChildren;
      let vnodePatchFlag;
      let patchFlag = 0;
      let vnodeDynamicProps;
      let dynamicPropNames;
      let vnodeDirectives;

      // TODO shouldUseBlock
      let shouldUseBlock = false;

      if (props.length > 0) {
        // TODO
      }

      if (node.children.length > 0) {
        if (vnodeTag === KEEP_ALIVE) {
          // TODO KeepAlive
        }

        const shouldBuildAsSlots =
              isComponent &&
              // Teleport 并非真实的组件，且专用于运行时处理
              vnodeTag !== TELEPORT &&
              vnodeTag !== KEEP_ALIVE;

        // 这段 if...else if ...else 目的是得到 vnodeChildren
        if (shouldBuildAsSlots) {
          // TODO
        } else if (node.children.length === 1 && vnodeTag !== TELEPORT) {
          const child = node.children[0];
          const type = child.type;

          // 动态文本孩子节点检测
          const hasDynamicTextChild =
                type === NodeTypes.INTERPOLATION ||
                type === NodeTypes.COMPOUND_EXPRESSION;

          if (hasDynamicTextChild && !getStaticType(child)) {
            patchFlag |= PatchFlags.TEXT;
          }

          if (hasDynamicTextChild || type === NodeTypes.TEXT) {
            vnodeChildren = child;
          } else {
            vnodeChildren = node.children;
          }
        } else {
          vnodeChildren = node.children;
        }
      }

      // TODO patchFlag & dynamicPropNames

      node.codegenNode = createVNodeCall(
        context,
        vnodeTag,
        vnodeProps,
        vnodeChildren,
        vnodePatchFlag,
        vnodeDynamicProps,
        vnodeDirectives,
        !!shouldUseBlock,
        false /* isForBlack */,
        node.loc
      );
    };
  }
#+end_src

进入 [[/vue/vue3-source-code-compiler-core-ast_ts/#ast-createvnodecall][createVNodeCall]] 时的参数值：

[[http://qiniu.ii6g.com/img/20200911152142.png]]

这里会将一些需要用到的函数添加到 ~context.helpers:Set~ 中等待解构：

该用例中会有 ~CREATE_VNODE~ 被解构出来。

*** transformBind(prop, node, context)
:PROPERTIES:
:COLUMNS:  %CUSTOM_ID[(Custom Id)]
:CUSTOM_ID: transform-transformbind
:END:

指令也属于属性一种，所以它的处理源头是在 [[#transform-transformelement][transformElement]] 里面。

这里只不过是提供了 v-bind 处理方式。

#+begin_src js
  export const transformBind = (dir, node, context) => {
    const { exp, modifiers, loc } = dir;

    const arg = dir.arg;

    // TODO 错误处理

    if (modifiers.includes("camel")) {
      if (arg.type === NodeTypes.SIMPLE_EXPRESSION) {
        if (arg.isStatic) {
          // 横线 转驼峰式
          arg.content = camelize(arg.content);
        } else {
          arg.content = `${context.helperString(CAMELIZE)}(${arg.content})`;
        }
      } else {
        arg.children.unshift(`${context.helperString(CAMELIZE)}(`);
        arg.children.push(`)`);
      }
    }

    return {
      props: [
        createObjectProperty(arg, exp || createSimpleExpression("", true, loc)),
      ],
    };
  };

#+end_src
*** transformIf()
:PROPERTIES:
:COLUMNS: %CUSTOM_ID[(Custom Id)]
:CUSTOM_ID: transform-transformif
:END: 

这个函数是由一系列的操作之后才返回的一个函数，用来处理 ~/^(if|else|else-if)$/~
指令，生成对应分支节点的  ~codegenNode~ 。

#+begin_src js
  export const transformIf = createStructuralDirectiveTransform(
    /^(if|else|else-if)$/,
    (node, dir, context) => {
      return processIf(node, dir, context, (ifNode, branch, isRoot) => {
        // 能到这里说明 v-if 下所有的 child 都已经处理完毕，可以返回处理
        // codegenNode 的函数了
        return () => {
          console.log({ dir, isRoot });
          if (isRoot) {
            ifNode.codegenNode = createCodegenNodeForBranch(branch, 0, context);
          } else {
            // TODO
          }
        };
      });
    }
  );
#+end_src

*** createCodegenNodeForBranch(branch, index, context)
:PROPERTIES:
:COLUMNS: %CUSTOM_ID[(Custom Id)]
:CUSTOM_ID: transform-createcodegennodeforbranch
:END: 

**** stage-1 [[#test-cc-05][05-interpolation, v-if, props]]

#+begin_src js

  function createCodegenNodeForBranch(branch, index, context) {
    if (branch.condition) {
      return createConditionalExpression(
        branch.condition,
        createChildrenCodegenNode(branch, index, context),
        createCallExpression(context.helper(CREATE_COMMENT), [
          __DEV__ ? "v-if" : '""',
          "true",
        ])
      );
    } else {
      // TODO no condition
    }
  }
#+end_src
*** createChildrenCodegenNode(branch, index, context) 
:PROPERTIES:
:COLUMNS: %CUSTOM_ID[(Custom Id)]
:CUSTOM_ID: transform-createchildrencodegennode
:END: 

**** stage-1 [[#test-cc-05][05-interpolation, v-if, props]]

该阶段只完成一个孩子节点且是 ELEMENT 类型的时候处理，如果不是这种情况是需要用
fragment 将这些 children 包起来的。
#+begin_src js

  // 创建 v-if 分支的孩子节点，同时加上 key 属性
  function createChildrenCodegenNode(branch, index, context) {
    const { helper } = context;
    const keyProperty = createObjectProperty(
      `key`,
      createSimpleExpression(index + ``, false)
    );

    const { children } = branch;
    const firstChild = children[0];
    // 多个节点的情况下用 fragment 包起来
    const needFragmentWrapper =
          children.length !== 1 || firstChild.type !== NodeTypes.ELEMENT;

    if (needFragmentWrapper) {
      // TODO
    } else {
      // 只有一个孩子节点且是 ELEMENT
      const vnodeCall = firstChild.codegenNode;

      if (
        vnodeCall.type === NodeTypes.VNODE_CALL &&
          // 组件的 vnodes 总是被追踪且它的孩子们会被编译进
        // slots 因此没必要将它变成一个 block
        (firstChild.tagType !== ElementTypes.COMPONENT ||
         vnodeCall.tag === TELEPORT)
      ) {
        // TODO
        vnodeCall.isBlock = true;
        helper(OPEN_BLOCK);
        helper(CREATE_BLOCK);
      }

      injectProp(vnodeCall, keyProperty, context);
      return vnodeCall;
    }
  }
#+end_src
*** createTransformContext(root, options)
:PROPERTIES:
:COLUMNS:  %CUSTOM_ID[(Custom Id)]
:CUSTOM_ID: transform-createtransformcontext
:END:

单纯的构建和初始化 transform 转换器上下文对象。

**** stage-1: [[#test-cc-01][01 simple text]]

一些初始化的工作，并不需要具体实现什么，纯文本并没有用到。

#+begin_src js
  export function createTransformContext(
    root,
    {
      prefixIdentifiers = false,
      hoistStatic = false,
      cacheHandlers = false,
      nodeTransforms = [],
      directiveTransforms = {},
      transformHoist = null,
      isBuiltInComponent = NOOP,
      expressionPlugins = [],
      scopeId = null,
      ssr = false,
      onError = defaultOnError,
    }
  ) {
    const context = {
      // options
      prefixIdentifiers,
      hoistStatic,
      cacheHandlers,
      nodeTransforms,
      directiveTransforms,
      transformHoist,
      isBuiltInComponent,
      expressionPlugins,
      scopeId,
      ssr,
      onError,

      // state
      root,
      helpers: new Set(),
      components: new Set(),
      directives: new Set(),
      hoists: [],
      imports: new Set(),
      temps: 0,
      cached: 0,
      identifiers: {},
      scopes: {
        vFor: 0,
        vSlot: 0,
        vPre: 0,
        vOnce: 0,
      },
      parent: null,
      currentNode: root,
      childIndex: 0,

      // methods
      helper(name) {},
      helperString(name) {},
      replaceNode(node) {},
      removeNode(node) {},
      onNodeRemoved: () => {},
      addIdentifiers(exp) {},
      removeIdentifiers(exp) {},
      hoist(exp) {},
      cache(exp, isVNode = false) {},
    };

    function addId(id) {}

    function removeId(id) {}

    return context;
  }
#+end_src

**** stage-2: [[#test-cc-02][02 pure interpolation]] 插值节点的编译

#+begin_src js

  export function createTransformContext(
    root,
    { ... }
  ) {
    const context = {
      // ...
      helpers: new Set(),

      // ...

      // 新增 helper 实现
      helper(name) {
        context.helpers.add(name);
        return name;
      },

      // ...
    };

    function addId(id) {}

    function removeId(id) {}

    return context;
  }
#+end_src
*** createRootCodegen(root, context)
:PROPERTIES:
:COLUMNS:  %CUSTOM_ID[(Custom Id)]
:CUSTOM_ID: transform-createrootcodegen
:END:

创建 root 节点上的 codegenNode 值，这也是将来用来编译成 render 函数的源码字符串。

**** stage-1: [[#test-cc-01][01 simple text]]
#+begin_src js

  function createRootCodegen(root, context) {
    // TODO  helper
    const { children } = root;
    const child = children[0];

    if (children.length === 1) {
      // 只有一个孩子节点

      // 且孩子节点是一个元素 element 类型，将它放在一个代码块钟返回
      // 如： { code }
      if (isSingleElementRoot(root, child) && child.codegenNode) {
        // TODO
      } else {
        root.codegenNode = child;
      }
    } else if (children.length > 1) {
    } else {
      // 没有孩子节点， codegen 返回 null，看到没
      // 01 simple text 返回 null 问题找到根源了
    }
  }
#+end_src

实现完这个之后发现，generate 里面的 [[#codegen-gennode][genNode]] 还没实现，真实丢三落四~~~~。
*** createStructuralDirectiveTransform(name, fn)
:PROPERTIES:
:COLUMNS:  %CUSTOM_ID[(Custom Id)]
:CUSTOM_ID: transform-createstructuraldirectivetransform
:END:

#+begin_src js
  function createStructuralDirectiveTransform(name, fn) {
    const matches = isString(name) ? (n) => n === name : (n) => name.test(n);
    return (node, context) => {
      if (node.type === 1 /* ELEMENT */) {
        const { props } = node;
        // structural directive transforms are not concerned with slots
        // as they are handled separately in vSlot.ts
        if (node.tagType === 3 /* TEMPLATE */ && props.some(isVSlot)) {
          return;
        }
        const exitFns = [];
        for (let i = 0; i < props.length; i++) {
          const prop = props[i];
          if (prop.type === 7 /* DIRECTIVE */ && matches(prop.name)) {
            // structural directives are removed to avoid infinite recursion
            // also we remove them *before* applying so that it can further
            // traverse itself in case it moves the node around
            props.splice(i, 1);
            i--;
            const onExit = fn(node, prop, context);
            if (onExit) exitFns.push(onExit);
          }
        }
        return exitFns;
      }
    };
  }
#+end_src
*** traverseNode(node, context)
:PROPERTIES:
:COLUMNS:  %CUSTOM_ID[(Custom Id)]
:CUSTOM_ID: transform-traversenode
:END:

**** stage-1: [[#test-cc-01][01 simple text]] 省略 switch 里面的上线，因为这里只是纯文本不再 case 范围。
:PROPERTIES:
:COLUMNS:  %CUSTOM_ID[(Custom Id)]
:CUSTOM_ID: transform-traversenode-stage1
:END:

#+begin_src js

  export function traverseNode(node, context) {
    context.currentNode = node;

    const { nodeTransforms } = context;
    const exitFns = [];

    for (let i = 0; i < nodeTransforms.length; i++) {
      // 调用诸如  transformText 的函数
      const onExit = nodeTransforms[i](node, context);
      if (onExit) {
        const fns = Array.isArray(onExit) ? onExit : [onExit];
        exitFns.push(...fns);
      }

      if (!context.currentNode) {
        // 可能被移除了
        return;
      } else {
        // 节点可能被替换过，重新建立引用
        node = context.currentNode;
      }
    }

    switch (node.type) {
        // ... 省略
      case NodeTypes.ROOT:
        traverseChildren(node, context);
        break;
    }

    let i = exitFns.length;
    // 执行所有转换
    while (i--) {
      exitFns[i]();
    }
  }
#+end_src
**** stage-2: [[#test-cc-02][02 pure interpolation]] 插值节点的编译
:PROPERTIES:
:COLUMNS:  %CUSTOM_ID[(Custom Id)]
:CUSTOM_ID: transform-traversenode-stage2
:END:

增加 INTERPOLATION 类型节点分支处理。

#+begin_src js

  export function traverseNode(node, context) {
    // ...

    switch (node.type) {
        // ...

        // 新增：对插值类型节点处理
      case NodeTypes.INTERPOLATION:
        if (!context.ssr) {
          // 这个函数来自上下文处理中的 helper(name)
          context.helper(TO_DISPLAY_STRING);
        }
        break

        // ...
    }

    // ...
  }
#+end_src

修改之后代码：

#+begin_src js

  export function traverseNode(node, context) {
    context.currentNode = node;

    const { nodeTransforms } = context;
    const exitFns = [];

    for (let i = 0; i < nodeTransforms.length; i++) {
      // 调用诸如  transformText 的函数
      const onExit = nodeTransforms[i](node, context);
      if (onExit) {
        const fns = Array.isArray(onExit) ? onExit : [onExit];
        exitFns.push(...fns);
      }

      if (!context.currentNode) {
        // 可能被移除了
        return;
      } else {
        // 节点可能被替换过，重新建立引用
        node = context.currentNode;
      }
    }

    switch (node.type) {
        // ... 省略
      case NodeTypes.INTERPOLATION:
        if (!context.ssr) {
          // 这个函数来自上下文处理中的 helper(name)
          context.helper(TO_DISPLAY_STRING);
        }
        break;
      case NodeTypes.ROOT:
        traverseChildren(node, context);
        break;
    }

    let i = exitFns.length;
    // 执行所有转换
    while (i--) {
      exitFns[i]();
    }
  }
#+end_src
**** stage-3: [[#test-cc-05][05-interpolation, v-if, props]]
:PROPERTIES:
:COLUMNS: %CUSTOM_ID[(Custom Id)]
:CUSTOM_ID: transform-traversenode-stage3
:END: 

增加 IF 和 IF_BRANCH 分支处理：
#+begin_src js

  export function traverseNode(node, context) {
    context.currentNode = node;

    const { nodeTransforms } = context;
    const exitFns = [];

    for (let i = 0; i < nodeTransforms.length; i++) {
      // 调用诸如  transformText 的函数
      const onExit = nodeTransforms[i](node, context);
      if (onExit) {
        const fns = Array.isArray(onExit) ? onExit : [onExit];
        exitFns.push(...fns);
      }

      if (!context.currentNode) {
        // 可能被移除了
        return;
      } else {
        // 节点可能被替换过，重新建立引用
        node = context.currentNode;
      }
    }

    switch (node.type) {
      // ... 省略
      case NodeTypes.INTERPOLATION:
        if (!context.ssr) {
          // 这个函数来自上下文处理中的 helper(name)
          context.helper(TO_DISPLAY_STRING);
        }
        break;
      case NodeTypes.IF:
        for (let i = 0; i < node.branches.length; i++) {
          traverseNode(node.branches[i], context);
        }
        break;
      case NodeTypes.IF_BRANCH:
      case NodeTypes.ELEMENT:
      case NodeTypes.ROOT:
        traverseChildren(node, context);
        break;
    }

    let i = exitFns.length;
    // 执行所有转换
    while (i--) {
      exitFns[i]();
    }
  }
#+end_src
*** traverseChildren(parent, context)
:PROPERTIES:
:COLUMNS:  %CUSTOM_ID[(Custom Id)]
:CUSTOM_ID: transform-traversechildren
:END:

处理 node.children 孩子节点。

#+begin_src js

  export function traverseChildren(parent, context) {
    let i = 0;
    const nodeRemoved = () => {
      i--;
    };

    for (; i < parent.children.length; i++) {
      const child = parent.children[i];
      // 过略掉字符串，只处理 ast child
      if (typeof child === "string") continue;

      context.parent = parent;
      context.childIndex = i;
      context.onNodeRemoved = nodeRemoved;
      traverseNode(child, context);
    }
  }
#+end_src

1. 遍历所有 ast ，让每个节点持有自父级引用。
2. 遍历所有节点，进行 [[#transform-traversenode][traverseNode]]，解析出 codegenNode 值

*** buildProps()
:PROPERTIES:
:COLUMNS:  %CUSTOM_ID[(Custom Id)]
:CUSTOM_ID: transform-buildprops
:END:
** codegen.ts
*** createCodgenContext(ast, context)
:PROPERTIES:
:COLUMNS:  %CUSTOM_ID[(Custom Id)]
:CUSTOM_ID: codegen-createcodegencontext
:END:
**** stage-1: [[#test-cc-01][01 simple text]]

#+begin_src js

  // 构建 condegen 上下文对象
  function createCodegenContext(
    ast,
    {
      mode = "function",
      prefixIdentifiers = mode === "module",
      sourceMap = false,
      filename = `template.vue.html`,
      scopeId = null,
      optimizeBindings = false,
      runtimeGlobalName = `Vue`,
      runtimeModuleName = `vue`,
      ssr = false,
    }
  ) {
    const context = {
      mode,
      prefixIdentifiers,
      sourceMap,
      filename,
      scopeId,
      optimizeBindings,
      runtimeGlobalName,
      runtimeModuleName,
      ssr,
      source: ast.loc.source,
      code: ``,
      column: 1,
      line: 1,
      offset: 0,
      indentLevel: 0,
      pure: false,
      map: undefined,
      helper(key) {},
      push(code, node) {
        context.code += code;
        // TODO 非浏览器环境处理，node 环境
      },
      indent() {
        // 新行缩进
        newline(++context.indentLevel);
      },
      deindent(withoutNewLine = false) {
        if (withoutNewLine) {
          --context.indentLevel;
        } else {
          newline(--context.indentLevel);
        }
      },
      newline() {
        newline(context.indentLevel);
      },
    };

    function newline(n) {
      context.push("\n" + ` `.repeat(n));
    }

    function addMapping(loc, name) {}

    return context;
  }
#+end_src
*** generate()
:PROPERTIES:
:COLUMNS:  %CUSTOM_ID[(Custom Id)]
:CUSTOM_ID: codegen_generate
:END:

generate 函数雏形：

#+begin_src js
  export function generate(ast, options) {
    return {
      ast,
      code: "",
      map: "",
    };
  }

#+end_src

函数的目的是：通过 ast 来生成 code，这个 code 将来会被 compileToFunction 调用 ~new
Function(code)~ 生成 render 函数的。

**** stage-1: [[#test-cc-01][01 simple text]]
:PROPERTIES:
:COLUMNS:  %CUSTOM_ID[(Custom Id)]
:CUSTOM_ID: codegen-generate-stage1
:END:

#+begin_src js

  export function generate(ast, options = {}) {
    const context = createCodegenContext(ast, options);
    const {
      mode,
      push,
      prefixIdentifiers,
      indent,
      deindent,
      newline,
      scopeId,
      ssr,
    } = context;

    const hasHelpers = ast.helpers.length > 0;
    const useWithBlock = !prefixIdentifiers && mode !== "module";
    const genScopeId = !__BROWSER__ && scopeId != null && mode === "module";

    // TODO preambles
    if (!__BROWSER__ && mode === "module") {
      // TODO genModulePreamble(ast, context, genScopeId)
    } else {
      genFunctionPreamble(ast, context);
    }

    if (genScopeId && !ssr) {
      push(`const render = ${PURE_ANNOTATION}_withId(`);
    }

    if (!ssr) {
      // 函数声明
      push(`function render(_ctx, _cache) {`);
    } else {
      // TODO ssr render
    }

    indent();

    if (useWithBlock) {
      // use with(_ctx) { ...}
      push(`with (_ctx) {`);
      indent();

      // TODO hasHelpers
    }

    // TODO ast.components 组件处理

    // TODO ast.directives 指令处理

    // TODO ast.temps 临时变量处理

    // TODO 换行

    if (!ssr) {
      push(`return `);
    }

    // 生成代码片段
    if (ast.codegenNode) {
      genNode(ast.codegenNode, context);
    } else {
      push(`null`);
    }

    if (useWithBlock) {
      deindent();
      push(`}`);
    }

    deindent();
    push(`}`);

    if (genScopeId && !ssr) {
      push(`)`);
    }

    return {
      ast,
      code: context.code,
      map: "",
    };
  }
#+end_src

代码中只包含文本解析需要的内容。但是结果显示：

#+begin_example
ast: {type: 0, children: Array(1), loc: {…}, helpers: Array(0), components: Array(0), …}
  code: "function render(_ctx, _cache) {↵ with (_ctx) {↵  return null}}"
  map: ""
#+end_example

即： ~ast.codegenNode~ 是空值，最后并没有 执行 ~genNode(ast.codgenNode, context)~
。

因此问题还在 [[#transform-transformtext][transformText]] 里面，但是纯文本会直接在第一个 for 后的 if 判断中直接
~return~ 了，那么问题出在哪？？？

进过往上追溯，发现在 traverseNode 实现中有一部分 switch 代码被我们省略，而里面就
有个 case 是文本节点会走到的，即： ~NodeTypes.ROOT~ 因为这个用例文本是直接挂在根
节点下面的，那么就得实现 [[#transform-traversechildren][traverseChildren]] 了。

然后，实现完 traverseChildren 之后并没解决问题，因为这里面根本没有处理赋值
codgenNode 的操作。

那么只能用最笨拙的方法了，直接搜索 ~codegen*~ 然后又发现新大陆(transform 里面有
个 [[#transform-createrootcodegen][createRootCodgen(...)]] 并没有实现)， :runner: go ->

**** stage-2: [[#test-cc-02][02 pure interpolation]]
:PROPERTIES:
:COLUMNS:  %CUSTOM_ID[(Custom Id)]
:CUSTOM_ID: codegen-generate-stage2
:END:

这里新增了 ~push ast.helpers.map(...)~ 处理，比如 traverseNode stage-2 中新增的
INTERPOLATION 分支中的处理是 ~context.helper(TO_DISPLAY_STRING)~ 就是给上下文的
helpers 增加了 ~Symbol('toDisplayString')~ 。

#+begin_src js

  export function generate(ast, options = {}) {
    // ...

    const hasHelpers = ast.helpers.length > 0;

    // ...

    if (useWithBlock) {
      // use with(_ctx) { ...}
      push(`with (_ctx) {`);
      indent();

      // 新增： hasHelpers
      if (hasHelpers) {
        // 比如：插值处理时用到 TO_DISPLAY_STRING helper
        // 为了避免命名冲突，这里都需要将他们重命名

        push(
          `const { ${ast.helpers
            .map((s) => `${helperNameMap[s]} : _${helperNameMap[s]}`)
            .join(", ")} } = _Vue`
        );

        push("\n");
        newline();
      }
    }

    // ...
  }
#+end_src

正好在这里会检测 ~context.helpers~ 进行相应的处理。

[[#transform-traversenode][traverseNode]] 的 switch 中插值 INTERPOLATION 分支处理中增加了一个
TO_DISPLAY_STRING 符号类型值到 ~context.helpers: Set~ 中，这其实就是个 ~_Vue~
实例中的一个函数名称，在这里会遍历 ~context.helpers~ 将需要用到的函数从实例中解
构出来。

*** genNode(node, context)
:PROPERTIES:
:COLUMNS:  %CUSTOM_ID[(Custom Id)]
:CUSTOM_ID: codegen-gennode
:END:

**** stage-3: [[#test-cc-04][04-interpolation in div with props]]
:PROPERTIES:
:COLUMNS:  %CUSTOM_ID[(Custom Id)]
:CUSTOM_ID: codegen-gennode-stage3
:END:

这个用例中需要解析 ~props[{ id }, { class }]~ 这两个属性经过 buildProps 处理之后
会变成一个对象结构：

~{ type: 15 /* JS_OBJECT_EXPRESSION */, properties: [{id}, {class}], ...}~

#+begin_src js
  0:
  key: {type: 4 /*SIMPLE_EXPRESSION*/, loc: {…}, isConstant: false, content: "id", isStatic: true}
  type: 16 // JS_PROPERTY
  value: {type: 4, loc: {…}, isConstant: false, content: "foo", isStatic: true}
  1:
  key: {type: 4, content: "class", isStatic: true, isConstant: true, loc: {…}}
  type: 16 // JS_PROPERTY
  value: {type: 4, content: "bar.baz", isStatic: false, isConstant: false, loc: {…}}
#+end_src

所以这里首先需要增加一个 ~JS_OBJECT_EXPRESSION~ 分支处理这两个属性，解析成属性对
象传递给 ~_createBlock('div', props, ...)~


#+begin_src js

  function genNode(node, context) {
    if (typeof node === "string") {
      context.push(node);
      return;
    }

    // TODO is symbol

    switch (node.type) {
        // ... 省略
      case NodeTypes.ELEMENT:
        genNode(node.codegenNode, context);
        break;
      case NodeTypes.TEXT:
        genText(node, context);
        break;
      case NodeTypes.SIMPLE_EXPRESSION:
        // 如：插值内容，属性值
        genExpression(node, context);
        break;
      case NodeTypes.INTERPOLATION:
        console.log(node, "interpolation");
        genInterpolation(node, context);
        break;
      case NodeTypes.VNODE_CALL:
        genVNodeCall(node, context);
        break;
      case NodeTypes.JS_OBJECT_EXPRESSION: // 新增属性 properties处理
        genObjectExpression(node, context);
        break;
    }
#+end_src

**** stage-2: [[#test-cc-02][02 pure interpolation]]
:PROPERTIES:
:COLUMNS:  %CUSTOM_ID[(Custom Id)]
:CUSTOM_ID: codegen-gennode-stage2
:END:

这个阶段需要支持插值的解析，而插值在 ast 中数据结构为：

#+begin_src json
  {
    "type":5, // INTERPOLATION
    "content":{
      "type":4, // SIMPLE_EXPRESSION
      "isStatic":false,
      "isConstant":false,
      "content":"world.burn()",
      "loc":{
        // ... ,
        "source":"world.burn()"
      }
    },
    "loc":{
      // ...,
      "source":"{{ world.burn() }}"
    }
  }
#+end_src

这里需要经过两次递归调用 genNode 分别去解析 ~type=5 // INTERPOLATION~ 和 ~type=4
// SIMPLE_EXPRESSION~ 两种类型，且前后形同父子关系。

那么就有：

#+begin_src js
  function genNode(node, context) {
    if (typeof node === "string") {
      context.push(node);
      return;
    }

    // TODO is symbol

    switch (node.type) {
        // ... 省略
      case NodeTypes.TEXT:
        genText(node, context);
        break;
      case NodeTypes.SIMPLE_EXPRESSION:
        // 如：插值内容，属性值
        genExpression(node, context);
        break;
      case NodeTypes.INTERPOLATION:
        console.log(node, "interpolation");
        genInterpolation(node, context);
        break;
    }
  }
#+end_src

1. 先经过 INTERPOLATION 分支调用 [[#codegen-geninterpolation][genInterpolation(node, context)]] 去解析插值节点
**** stage-1: [[#test-cc-01][01 simple text]]
:PROPERTIES:
:COLUMNS:  %CUSTOM_ID[(Custom Id)]
:CUSTOM_ID: codegen-gennode-stage1
:END:

这里我们只处理文本节点的情况：
#+begin_src js

  function genNode(node, context) {
    if (typeof node === "string") {
      context.push(node);
      return;
    }

    // TODO is symbol

    switch (node.type) {
        // ... 省略
      case NodeTypes.TEXT:
        genText(node, context);
        break;
    }
  }
#+end_src

然后就是实现 case 的 [[#codegen-gentext][genText(node, context)]]

*** genNodeList(nodes, context, multilines=false, comma=true)
:PROPERTIES:
:COLUMNS:  %CUSTOM_ID[(Custom Id)]
:CUSTOM_ID: codegen-gennodelist
:END:

生成 _createBlock(tag, props, children, ...) 函数的参数列表。

#+begin_src js

  function genNodeList(nodes, context, multilines = false, comma = true) {
    const { push, newline } = context;
    for (let i = 0; i < nodes.length; i++) {
      const node = nodes[i];
      if (typeof node === "string") {
        push(node);
      } else if (Array.isArray(node)) {
        genNodeListAsArray(node, context);
      } else {
        // nodes[1], props 进入这里处理
        genNode(node, context);
      }

      if (i < nodes.length - 1) {
        if (multilines) {
          comma && push(",");
          newline();
        } else {
          comma && push(", ");
        }
      }
    }
  }
#+end_src
*** genNodeListAsArray(nodes, context)
:PROPERTIES:
:COLUMNS:  %CUSTOM_ID[(Custom Id)]
:CUSTOM_ID: codegen-gennodelistasarray
:END:

将参数列表转成数组， ~nodes: [tag, props, chldren, ...]~ -> ~['div', {}, ...}]~

#+begin_src js

  // 将参数们变成数组
  function genNodeListAsArray(nodes, context) {
    const multilines =
          nodes.length > 3 ||
          ((!__BROWSER__ || __DEV__) &&
           nodes.some((n) => Array.isArray(n) || !isText(n)));

    context.push(`[`);
    multilines && context.indent();
    genNodeList(nodes, context, multilines);
    multilines && context.deindent();
    context.push(`]`);
  }
#+end_src

*** genNullableArgs(args)
:PROPERTIES:
:COLUMNS:  %CUSTOM_ID[(Custom Id)]
:CUSTOM_ID: codegen-gennullableargs
:END:

过滤掉参数列表尾部值为 *假值* 的参数。

#+begin_src js

  // 过滤尾部 nullable 的值
  function genNullableArgs(args) {
    let i = args.length;
    while (i--) {
      if (args[i] != null) break;
    }

    // 中间的 nullable 值 转成 null
    return args.slice(0, i + 1).map((arg) => arg || `null`);
  }
#+end_src

*** genObjectExpression(node, context)
:PROPERTIES:
:COLUMNS:  %CUSTOM_ID[(Custom Id)]
:CUSTOM_ID: codegen-genobjectexpression
:END:

1. 空属性列表，返回 ~{}~
2. 先 [[#codegen-genexpressionaspropertykey][genExpressionAsPropertyKey(node, context)]] 解析属性名

#+begin_src js
  // 生成对象表达式，用来处理 properties
  function genObjectExpression(node, context) {
    const { push, indent, deindent, newline } = context;
    const { properties } = node;
    if (!properties.length) {
      push(`{}`, node);
      return;
    }

    const multilines =
          properties.length > 1 ||
          ((!__BROWSER__ || __DEV__) &&
           properties.some((p) => p.value.type !== NodeTypes.SIMPLE_EXPRESSION));

    push(multilines ? `{` : `{ `);
    multilines && indent();
    for (let i = 0; i < properties.length; i++) {
      const { key, value } = properties[i];
      // key 处理，属性名
      genExpressionAsPropertyKey(key, context);
      push(`: `);
      // value 处理，属性值，如果是静态的字符串化，如果是动态的直接变量方式
      // 如： id="foo" -> id: "foo"
      // 如： :class="bar.baz" -> class: bar.baz
      // 这里 bar 是对象，baz 是 bar对象的属性
      genNode(value, context);
      if (i < properties.length - 1) {
        push(`,`);
        newline();
      }
    }
    multilines && deindent();
    push(multilines ? `}` : ` }`);
  }
#+end_src
*** genExpressionAsPropertyKey(node, context)
:PROPERTIES:
:COLUMNS:  %CUSTOM_ID[(Custom Id)]
:CUSTOM_ID: codegen-genexpressionaspropertykey
:END:

生成对象属性名：

1. 属性名由组合表达式动态生成，如： ~{ [prefix + '_' + name]: 'value' }~
2. 静态属性，又分标准标识符和非标准的(需要用引号包起来的)，如： ~{ foo: 'value'
   }~ 或 ~{ '23adf34': 'value' }~
3. 简单的动态属性，如： ~{ [foo]: 'value' }~

#+begin_src js

  function genExpressionAsPropertyKey(node, context) {
    const { push } = context;
    if (node.type === NodeTypes.COMPOUND_EXPRESSION) {
      push(`[`);
      genCompoundExpression(node, context);
      push(`]`);
    } else if (node.isStatic) {
      // 静态属性
      const text = isSimpleIdentifier(node.content)
            ? node.content
            : JSON.stringify(node.content);

      push(text, node);
    } else {
      // 动态属性
      push(`[${node.content}]`, node);
    }
  }
#+end_src
*** genCompoundExpression(node, context)
:PROPERTIES:
:COLUMNS:  %CUSTOM_ID[(Custom Id)]
:CUSTOM_ID: codegen-gencompoundexpression
:END:

#+begin_src js
  function genCompoundExpression(node, context) {
    for (let i = 0; i < node.children.length; i++) {
      const child = node.children[i];
      if (typeof child === "string") {
        context.push(child);
      } else {
        genNode(child, context);
      }
    }
  }
#+end_src
*** genText(node, context)
:PROPERTIES:
:COLUMNS:  %CUSTOM_ID[(Custom Id)]
:CUSTOM_ID: codegen-gentext
:END:

这里没什么阶段性的，就是一句很简单的字符串化文本节点内容。

#+begin_src js
  function genText(node, context) {
    // 文本直接字符串化
    context.push(JSON.stringify(node.content), node);
  }

#+end_src

*** genFunctionPreamble(ast, context)
:PROPERTIES:
:COLUMNS:  %CUSTOM_ID[(Custom Id)]
:CUSTOM_ID: codegen-genfunctionpreamble
:END:

**** stage-1: [[#test-cc-01][01 simple text]]
对于纯文本这里不需要更多的处理，只需要最后的 ~`return `~

#+begin_src js

  function genFunctionPreamble(ast, context) {
    const { push, newline } = context;

    // TODO ...

    newline()
    push(`return `);
  }
#+end_src
*** genInterpolation(node, context)
:PROPERTIES:
:COLUMNS:  %CUSTOM_ID[(Custom Id)]
:CUSTOM_ID: codegen-geninterpolation
:END:

#+begin_src js
  function genInterpolation(node, context) {
    const { push, helper, pure } = context;

    if (pure) push(PURE_ANNOTATION);

    push(`${helper(TO_DISPLAY_STRING)}(`);
    // 调用 genNode 解析插值的内容，表达式节点类型，NodeTypes.SIMPLE_EXPRESSION
    genNode(node.content, context);
    push(`)`);
  }
#+end_src

~context.helper(TO_DISPLAY_STRING)~ 是从 helpersMap 中取出 TO_DISPLAY_STRING 对
应的函数名称(下划线重命名之后的名称)，看 ~context.helper~ 实现:
#+begin_src js
  helper(key) {
    return `_${helperNameMap[key]}`;
  }
#+end_src

别名操作在 [[#codegen-generate][generate]] 的 useWithBlock 判断中生成。

*** genExpression(node, context)
:PROPERTIES:
:COLUMNS:  %CUSTOM_ID[(Custom Id)]
:CUSTOM_ID: codegen-genexpression
:END:

#+begin_src js
  function genExpression(node, context) {
    const { content, isStatic } = node;
    context.push(isStatic ? JSON.stringify(content) : content, node);
  }
#+end_src

表达式的值可以是静态的，也可以是动态的，

1. TODO 如果是静态直接字符串化？？？

2. DONE 如果是动态的直接 push content 变成变量直接从上下文去取变量值

   如 [[test-cc-02][02 pure interpolation]] 中的 ~world.burn()~ 会直接被塞到 ~context.code~ 结合
   成 ~return _toDisplayString(world.burn());~ 生成函数之后相当于这样调
   用： ~_ctx.world.burn()~  。

*** genVNodeCall(node, context)

**** stage-1 [[#test-cc-03][03-inerpolation in pure div]]

增加 ~createVNode~ helper
#+begin_src js

  function genVNodeCall(node, context) {
    const { push, helper, pure } = context;

    const {
      tag,
      props,
      children,
      patchFlag,
      dynamicProps,
      directives,
      isBlock,
      isForBlock,
    } = node;

    // TODO directives start

    // TODO isblock start

    if (pure) {
      push(PURE_ANNOTATION);
    }

    push(helper(isBlock ? CREATE_BLOCK : CREATE_VNODE) + `(`, node);

    // TODO genNodeList

    push(`)`);

    // TODO isblock end

    // TODO directives end
  }
#+end_src
** 虚拟节点创建函数

| name              | transform     | desc             |
|-------------------+---------------+------------------|
| ~createTextVNode~ | [[#transform-transformtext][transformText]] | 创建文本虚拟节点 |
|                   |               |                  |

* 问题列表

1. compile.js:37 Uncaught TypeError: object is not iterable (cannot read
   property Symbol(Symbol.iterator))

   原因是：在数组里面使用展开符的时候 [], {} 混用了

   #+begin_src js
     transform(ast, {
       // 合并选项
       ...options, // 调用 baseCompile 时候的第二个参数
       prefixIdentifiers, // 还不知道是干啥的???
       // 节点转换器合并，外部转换器优先，即使用者可自定义自己的转换器
       // nodeTransforms: [...nodeTransforms, ...(options.nodeTransforms || {})], // FIX: 这里用法有问题修改前
       nodeTransforms: [...nodeTransforms, ...(options.nodeTransforms || [])], // FIX: 修改后
       // 指令转换器，同上。
       directiveTransforms: {
         ...directiveTransforms,
         ...(options.directiveTransforms || {}),
       },
     });

   #+end_src
