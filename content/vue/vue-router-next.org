#+TITLE: vue-router-next for vue3 æºç åˆ†æ(é™„.è„‘å›¾)
#+DATE: <2021-03-05 19:01:36>
#+TAGS[]: vue, vue3, vue-router-next
#+CATEGORIES[]: vue
#+LANGUAGE: zh-cn
#+STARTUP: indent

#+begin_export html
<link href="https://fonts.goo~gleapis.com/cs~s2?family=ZCOOL+XiaoWei&display=swap" rel="stylesheet">
<kbd>
<font color="blue" size="3" style="font-family: 'ZCOOL XiaoWei', serif;">
  è¯—å·ï¼šå…­é“åŒå ï¼Œé­”åŠ«ä¸‡åƒï¼Œå¼•æ¸¡å¦‚æ¥ã€‚
</font>
</kbd><br><br>
<script src="/js/utils.js"></script>
#+end_export

[[/img/bdx/yiyeshu-001.jpg]]

#+begin_quote
*æ…å…¥ğŸ˜¢*

vue-router-next æºç åˆ†ææµç¨‹å›¾ï¼Œæ­¤æ–‡é‡ç‚¹åœ¨å›¾ï¼Œé™„å¸¦ä¸€äº›æ€»ç»“æ€§çš„æ–‡å­—åˆ†
æå†…å®¹(å›¾ä¸€èˆ¬æ¯”è¾ƒå¤§ï¼Œåªä¿è¯è‡ªå·±èƒ½çœ‹æ‡‚ç³»åˆ—~~~~)ï¼Œå­¦ä¹ è¿‡ç¨‹ä¸­ä¸€äº›é›¶ç¢çš„ç¬”è®°ã€‚
#+end_quote

* vue-router-next
:PROPERTIES:
:COLUMNS: %CUSTOM_ID[(Custom Id)]
:CUSTOM_ID: vue-router
:END:

è„‘å›¾ï¼š
[[/img/vue3/vue-router/vue-router-next-start.svg]]

ç®€è¦åˆ†æï¼š

vue-router å®ç°ä»ä½¿ç”¨ä¸Šæ¥è¯´æœ‰ä¸‰ä¸ªéƒ¨åˆ†ï¼š

1. è·¯ç”±æ³¨å†Œåˆå§‹åŒ–ï¼Œä»¥ ~VueRouter.createRoute({history, routes})~ ä¸ºæ‰§è¡Œå…¥å£

   - åˆ›å»ºåŒ¹é…å™¨ matcher è·¯ç”±çš„ä¸€äº›åŒ¹é…ã€æ·»åŠ ã€æŸ¥æ‰¾å•Šä»€ä¹ˆçš„æ“ä½œéƒ½æ˜¯æœ‰è¿™ä¸ª matcher æ¥å®ç°çš„

      #+begin_src typescript
      export interface RouterMatcher {
        addRoute: (record: RouteRecordRaw, parent?: RouteRecordMatcher) => () => void;
        removeRoute: {
          (matcher: RouteRecordMatcher): void;
          (name: RouteRecordName): void;
        };
        getRoutes: () => RouteRecordMatcher[];
        getRecordMatcher: (name: RouteRecordName) => RouteRecordMatcher | undefined;

        resolve;
      }
      #+end_src

      è€Œä¸Šé¢çš„æ¥å£æ“ä½œçš„æ— éå°±æ˜¯ä¸¤ä¸ªè·¯ç”±ä»“åº“ï¼š

      #+begin_src typescript
      // è¿™ä¸ªæ— è®ºæœ‰æ²¡æœ‰åå­—çš„è·¯ç”±è®°å½•éƒ½ä¼šè¢«å­˜å‚¨åˆ°è¿™ä¸ªæ•°ç»„ä¸­
      const matchers: RouteRecordMatcher[] = [];
      // è¿™ä¸ªå­˜å‚¨çš„æ˜¯å¸¦ name å­—æ®µçš„è·¯ç”± <name, record> ç»“æ„
      // æ–¹ä¾¿ç›´æ¥å¯ä»¥é€šè¿‡ map.get(name) å°±å¯ä»¥å»åˆ°è·¯ç”±è®°å½•ï¼Œå‡å°‘æ•°ç»„æŸ¥æ‰¾æ¶ˆè€—
      const matcherMap = new Map<RouteRecordName, RouteRecordMatcher>();
      #+end_src

   - åˆå§‹åŒ–è·¯ç”±å®ˆå«å­˜å‚¨å™¨ï¼Œå…¶å®å°±æ˜¯ä¸ªåŒ…å« ~{list,add,result}~ çš„ä¸€ä¸ªå¯¹è±¡

      #+begin_src typescript
       // è¿›å…¥ä¹‹å‰çš„çš„å›è°ƒåˆ—è¡¨
       const beforeGuards = useCallbacks<NavigationGuardWithThis<undefined>>();
       // è§£æè·¯ç”±ä¹‹å‰çš„å›è°ƒåˆ—è¡¨
       const beforeResolveGuards = useCallbacks<NavigationGuardWithThis<undefined>>();
       // è¿›å…¥ä¹‹åçš„å›è°ƒåˆ—è¡¨
       const afterGuards = useCallbacks<NavigationHookAfter>();

       export function useCallbacks<T>() {
         let handlers: T[] = [];
         function add(handler: T): () => void {}
         function reset() {
           handlers = [];
         }
         return {
           add,
           list: () => handlers,
           reset,
         };
       }
      #+end_src

   - *currentRoute* é‡è¦å˜é‡ï¼Œæ˜¯ä¸ª shallow ref å“åº”å¼ç±»å‹çš„å€¼ï¼Œä¸
      ~<router-view/>~ å½“å‰æ˜¾ç¤ºçš„è·¯ç”±æ¯æ¯ç›¸å…³ï¼Œæˆ–è€…è¯´å°±æ˜¯å®ƒï¼Œå› ä¸º ~RouterView~
      ç»„ä»¶ä¸­æœ‰é—´æ¥çš„ç›‘å¬è¿™ä¸ªå€¼ã€‚

      #+begin_src typescript
       // RouterView.ts
       // å°±æ˜¯è¿™é‡Œçš„ matchedRouteRef
       watch(
         () => [viewRef.value, matchedRouteRef.value, props.name] as const,
         ([instance, to, name], [oldInstance, from, oldName]) => {
           // ...
         }
       );

       // RouterView.ts > ä¸ºä»€ä¹ˆè¯´æ˜¯é—´æ¥å‘¢ï¼Ÿçœ‹ä¸‹é¢  matchedRouteRef çš„ç”±æ¥
       const injectedRoute = inject(routerViewLocationKey)!;
       const routeToDisplay = computed(() => props.route || injectedRoute.value);
       const depth = inject(viewDepthKey, 0);
       const matchedRouteRef = computed<RouteLocationMatched | undefined>(
         () => routeToDisplay.value.matched[depth]
       );

       // router.ts > routerViewLocationKey ???  ä¸è®°å¾—äº†å—? router.install... å•Š
       app.provide(routerKey, router);
       app.provide(routeLocationKey, reactive(reactiveRoute));
       app.provide(routerViewLocationKey, currentRoute);

       // çœ‹åˆ°æ²¡ï¼Œå…³è”ä¸Šäº†å§!!!
       // app.provide -> currentRoute ->
       // injectedRoute -> routeToDisplay ->
       // routeToDisplay.value.matched[depth]

       /*
        å¹¶ä¸”æ³¨æ„çœ‹ ~RouterView~ ç»„ä»¶ä¸­ setupæœ€åè¿”å›çš„å€¼æ˜¯ä¸ªå‡½æ•°ï¼Œè¿™ä¸ªå‡½æ•°ä¸­æœ‰å¯¹
        routeToDisplay, matchedRouteRefè¿›è¡Œå¼•ç”¨ä¹Ÿå°±æ˜¯åœ¨æ‰§è¡Œçš„æ—¶å€™ä¼šè§¦å‘ track æ“
        ä½œå°†å®ƒæ”¶é›†åˆ°è¿™å†™å€¼çš„ä¾èµ–åˆ—è¡¨ä¸­ï¼Œåªè¦è¿™äº›å€¼å‘ç”Ÿå˜æ›´å°±ä¼š triggerè¿™ä¸ª setup
        æ‰§è¡Œï¼Œæ¥æ›´æ–° ~<router-view/>~
       ,*/
      #+end_src

   - åˆå§‹åŒ– router å®ä¾‹

      åŒ…å«ä¸€äº› api :

      è·¯ç”±çš„å¢åˆ æ”¹æŸ¥ä¸»è¦æ¥æº matcherï¼š ~{addRoute, currentRoute, removeRoute, hasRoute, getRoutes, resolv}~

      è·¯ç”±çš„è·³è½¬è¡Œä¸ºï¼š ~{push, replace, go, back: () => go(-1), forward: () =>
      go(1)}~, è¿™é‡Œçš„ push, replace å‡½æ•°æœ€ç»ˆè°ƒç”¨çš„éƒ½æ˜¯ ~finalizeNavigation()~ è€Œ
      è¿™é‡Œé¢ä¸»è¦æœ‰ä¸¤ä¸ªå…³é”®åœ°æ–¹ï¼Œä¸€æ˜¯ ~routerHistory.push/replace~, äºŒæ˜¯æ›´æ–°äº†
      ~currentRoute.value~ è€Œæ­£æ˜¯è¿™ä¸ªæ›´æ–°ä¼šè§¦å‘ ~<router-view/>~ ç»„ä»¶çš„æ›´æ–°ã€‚go æ˜¯ç›´æ¥ä½¿ç”¨äº† ~routerHistory.go(delta)~ æ¥å£

      #+begin_quote
      å¯ä»¥çœ‹åˆ°ï¼Œä¸ç®¡æ˜¯ push/replace è¿˜æ˜¯ go æœ€åéƒ½æ˜¯ä½¿ç”¨äº† history çš„ api ã€‚
      #+end_quote

      è·¯ç”±æ’ä»¶çš„å®‰è£…å‡½æ•° ~install(app/* vue app */)~, è¿™é‡Œéœ€è¦æ³¨æ„å®ƒåšäº†å‡ ä»¶äº‹æƒ…ï¼š

      | æ³¨å†Œ ~RouterLink~, ~RouterView~ ä¸¤ä¸ª vue ç»„ä»¶                                        |
      | å®šä¹‰äº†å…¨å±€å±æ€§ ~$route~ æŒ‡å‘ ~currentRoute~                                          |
      | provide routerKey -> router å½“å‰ router å®ä¾‹                                         |
      | provide routeLocationKey -> reactiveRoute location ç›¸å…³ä¿¡æ¯                          |
      | provide routerViewLocationKey -> currentRoute å½“å‰è·¯ç”±è®°å½•                           |
      | é‡å†™ vue ç»„ä»¶çš„ unmount å‡½æ•°ï¼Œæ‰§è¡Œè·¯ç”±çš„æ¸…ç†å·¥ä½œï¼Œæ¯”å¦‚ï¼šç§»é™¤äº‹ä»¶ç›‘å¬ï¼Œé‡ç½®è·¯ç”±å±æ€§ç­‰ |

2. ~<router-view/>~ ç»„ä»¶çš„å®ç°åŸç†ï¼Œé€šè¿‡ ~<router-link to/>~ æˆ–
   ~router.push/replace/go~ api è§¦å‘è·¯ç”±è·³è½¬åŠ¨ä½œå®ç°
3. history çš„å®ç°åŸç†(ç»“åˆ Ref + history hash/H5api)ï¼Œè¿™ä¸ªå¯¹ç”¨æˆ·æ˜¯ä¸å¯è§çš„


vue-router ç®€è¦å›¾ï¼š

[[/img/vue3/vue-router/vue-router-next.svg]]

* TODO å®ˆå«å‡½æ•°å®Œæ•´æ‰§è¡Œæµç¨‹
:PROPERTIES:
:COLUMNS: %CUSTOM_ID[(Custom Id)]
:CUSTOM_ID: flow
:END:

[[/img/vue3/vue-router/vue-router-next-parse-flow.svg]]

* HTML5 history api
:PROPERTIES:
:COLUMNS: %CUSTOM_ID[(Custom Id)]
:CUSTOM_ID: h5-history
:END:

| api                               | æè¿°                                                                                                                                                   |
|-----------------------------------+--------------------------------------------------------------------------------------------------------------------------------------------------------|
| ~pushState(state, title, url)~    | å‘å†å²è®°å½•ä¸­å¢åŠ ä¸€æ¡è®°å½•                                                                                                                               |
| ~replaceState(state, title, url)~ | æ›¿æ¢å½“å‰è®°å½•ï¼Œä¸æ–°å¢è®°å½•                                                                                                                               |
| ~back()~                          | è¿”å›ä¸Šä¸€æ¡è®°å½•ï¼Œç­‰ä»·äº ~go(-1)~                                                                                                                        |
| ~go(n)~                           | è·³è½¬åˆ°ç¬¬ n æ¡è®°å½•                                                                                                                                      |
| ~forward()~                       | ç­‰ä»·äº ~go(1)~                                                                                                                                         |
| ~onpopstate~                      | äº‹ä»¶ï¼Œå½“ä¸”æ‰§è¡Œ ~history.back()~ æˆ– ~history.forward()~ æˆ– ~history.go(n)~ çš„æ—¶å€™è§¦å‘                                                                   |
| ~state~                           | è®°å½•å½“å‰é¡µé¢çš„çŠ¶æ€ä¿¡æ¯ï¼Œåœ¨æ‰§è¡Œ pushState æˆ– replaceState ä¹‹å‰ä¸º null ï¼Œä¹‹åä¸ºç¬¬ä¸€ä¸ªä¼ å…¥çš„å‚æ•°ï¼Œå¯ä»¥åœ¨ ~onpopstate~ å›è°ƒä¸­é€šè¿‡ ~event.state~ å–åˆ°è¯¥ä¿¡æ¯ |

#+begin_export html
<h1> changeLocation() æµ‹è¯•ã€‚ã€‚ã€‚ï¼Œ</h1>
<b>ç‚¹å‡»ä¸‹é¢çš„æŒ‰é’®ï¼Œæ³¨æ„è§‚å¯Ÿ location å˜åŒ–å’Œ history.length é•¿åº¦å˜åŒ–ï¼</b>
<div class="c9OCH7YQX9g">
<button class="pushq">push ?q=1</button>
<button class="pushp">push ?p=2</button>
<button class="replace">replace ?r=3</button>
<button class="clear">clear</button>
<button class="forward">forward</button>
<button class="go">éšæœºè·³è½¬</button>
<button class="back">back</button>
<div class="debug"></div>
</div>
<script src="/js/vue/router/c9OCH7YQX9g.js"></script>
#+end_export

-----
#+begin_quote
é’ˆå¯¹ ~onpopstate~ åªæœ‰åœ¨æ‰§è¡Œå®é™…è·³è½¬åŠ¨ä½œçš„æ—¶å€™æ‰ä¼šè§¦å‘ï¼Œä»€ä¹ˆæ˜¯å®é™…è·³è½¬åŠ¨ä½œï¼Ÿ

æ¯”å¦‚ï¼šæµè§ˆå™¨çš„åå°å‰è¿›æŒ‰é’®ï¼Œæˆ–è€…ç›´æ¥æ‰‹åŠ¨è°ƒç”¨ ~history.back()~, ~history.go(n)~,
~history.forward()~ æ–¹æ³•è§¦å‘ã€‚
#+end_quote

_ç„¶å vue-router ä¸­æ˜¯å¦‚ä½•ä½¿ç”¨ history å®ç°è·¯ç”±åŠŸèƒ½çš„ï¼Ÿ_
* createWebHistory
:PROPERTIES:
:COLUMNS: %CUSTOM_ID[(Custom Id)]
:CUSTOM_ID: web-history
:END:

H5 çš„ history api å°è£…ï¼Œè¿”å›çš„ç»“æ„ï¼š ~RouterHistory~ åŒ…å«ä»¥ä¸‹æˆå‘˜

| æˆå‘˜å                         | æè¿°                            | -                                                               |
|--------------------------------+---------------------------------+-----------------------------------------------------------------|
| ~base~                         | ç«™åŸºåœ°å€ï¼Œä¼šæ·»åŠ åˆ°æ¯ä¸ª url å‰é¢ | å¦‚ï¼š a.com/sub é‚£ä¹ˆ base æ˜¯ /sub                                |
| ~loation~                      | å½“å‰ history location           | éåŸç”Ÿçš„ location, å°è£…ä¹‹åçš„ï¼š ~{value: location}~             |
| ~state~                        | å½“å‰çš„ history state            | éåŸç”Ÿ history state ï¼Œåˆå§‹å€¼æ˜¯è¿™ä¸ªï¼Œä½†åç»­çš„å€¼éœ€è¦å‡½æ•°æ‰‹åŠ¨ç®¡ç† |
| ~push(to,data?)~               | å¯¹åº” pushState æ“ä½œ             | ä¸ä¼šè§¦å‘ popstate                                               |
| ~replace(to,data?)~            | å¯¹åº” replaceState æ“ä½œ          | ä¸ä¼šè§¦å‘ popstate                                               |
| ~go(delta, triggerListeners?)~ | è°ƒç”¨ ~history.go(delta)~        | ä¼šè§¦å‘ popstate äº‹ä»¶                                            |
| ~listen(callback)~             | ç”¨æˆ·è°ƒç”¨æ·»åŠ çš„ç›‘å¬å‡½æ•°          | popstate è§¦å‘æœŸé—´æ‰§è¡Œ                                           |
| ~createHref(location)~         | æ„å»º href åœ°å€                  | -                                                               |
| ~destory()~                    | æ³¨é”€ listen() æ³¨å†Œçš„äº‹ä»¶        | -                                                               |


#+begin_quote
Router ä¸­çš„ ~back()~ å’Œ ~forward()~ åˆ†åˆ«æ˜¯è°ƒç”¨è¿™é‡Œçš„ ~go(-1)~ å’Œ ~go(1)~ å®ç°ã€‚
#+end_quote

#+begin_src typescript
export function createWebHistory(base?: string): RouterHistory {
  base = normalizeBase(base)

  const historyNavigation = useHistoryStateNavigation(base)
  const historyListeners = useHistoryListeners(
    base,
    historyNavigation.state,
    historyNavigation.location,
    historyNavigation.replace
  )
  function go(delta: number, triggerListeners = true) {
    if (!triggerListeners) historyListeners.pauseListeners()
    history.go(delta)
  }

  const routerHistory: RouterHistory = assign(
    {
      // it's overridden right after
      location: '',
      base,
      go,
      createHref: createHref.bind(null, base),
    },

    historyNavigation,
    historyListeners
  )

  Object.defineProperty(routerHistory, 'location', {
    get: () => historyNavigation.location.value,
  })

  Object.defineProperty(routerHistory, 'state', {
    get: () => historyNavigation.state.value,
  })

  return routerHistory
}
#+end_src

1. ~base = normalizeBase(base)~

   è§£æç½‘ç«™åŸºè·¯å¾„

   ~!base~

   ? æ— è‡ªå®šä¹‰åœ°å€é¦–å…ˆå– ~<base href="http://ip:port/path/to" />~ çš„ hrefï¼Œ
   å–å‡º ~/path/to~ éƒ¨åˆ†ä½œä¸º base

   \: æœ‰è‡ªå®šä¹‰çš„æ—¶å€™ï¼ŒåŠ ä¸Šå¼€å¤´ ~/~ å’Œå»æ‰å°¾éƒ¨ ~/~ ï¼Œå¦‚ï¼š ~path/to~ å˜æˆ
   ~/path/to~ , æˆ– ~/path/to/~ å˜æˆ ~/path/to~

2. ~const historyNavigation = useHistoryStateNavigation(base)~

   å°† ~window.location~ å’Œ ~window.history~ è¿›è¡Œå°è£…ï¼Œè¿”å›

   ~{location, state, push, replace}~ å¯¹è±¡ï¼Œæ‰€ä»¥è¿™é‡Œé‡ç‚¹å°±æ˜¯è¿™ä¸ªå‡½æ•°ã€‚

3. ~const historyListeners = useHistoryListeners(...)~

   history å˜æ›´ç›‘å¬å™¨ã€‚

4. ~go(delta, triggerListeners)~ å‡½æ•°

   åœ¨è°ƒç”¨ ~history.go(delta)~ ä¹‹å‰æ£€æµ‹æ˜¯å¦æš‚åœ history listeners

5. ç»„è£… ~routerHistory~

   åˆå¹¶ ~{ location: '', base, go, createHref }~ å’Œ historyNavigation, historyListeners

6. åœ¨ routerHistory ä¸Šå®šä¹‰ä¸¤ä¸ª getter å±æ€§ ~location~ & ~state~

7. è¿”å› routerHistory è¿™ä¸ªå°†æ¥ä¼šè¢« ~createRouter({ history })~ ç”¨åˆ°



#+begin_export html
<script>
insertFrame('', '2.js', '/js/vue/router/')
</script>
#+end_export

** useHistoryStateNavigation(base: string)
:PROPERTIES:
:COLUMNS: %CUSTOM_ID[(Custom Id)]
:CUSTOM_ID: use-h5-history
:END:

è§£æ„ window.history, window.location ç»„è£… ~{location, state, push, replace}~ ç»“
æ„è¿”å›ã€‚

#+begin_src typescript
function useHistoryStateNavigation(base: string) {
  const { history, location } = window;

  // private variables
  let currentLocation: ValueContainer<HistoryLocation> = {
    value: createCurrentLocation(base, location),
  };
  let historyState: ValueContainer<StateEntry> = { value: history.state };
  // build current history entry as this is a fresh navigation
  if (!historyState.value) {
    changeLocation(
      currentLocation.value,
      {
        back: null,
        current: currentLocation.value,
        forward: null,
        // the length is off by one, we need to decrease it
        position: history.length - 1,
        replaced: true,
        // don't add a scroll as the user may have an anchor and we want
        // scrollBehavior to be triggered without a saved position
        scroll: null,
      },
      true
    );
  }

  function changeLocation(
    to: HistoryLocation,
    state: StateEntry,
    replace: boolean
  ): void {
    // ...
  }

  function replace(to: HistoryLocation, data?: HistoryState) {
    // ...
  }

  function push(to: HistoryLocation, data?: HistoryState) {
    //...
  }

  return {
    location: currentLocation,
    state: historyState,

    push,
    replace,
  };
}
#+end_src

1. è§£æ location { pathname, search, hash } è¿”å›ä¸å¸¦åŸŸåçš„çš„ path

   å¦‚ï¼š

   ~http://ip:port/ui/#/a/b/?limit=10&page=1~ -> base: ~/ui/#~ -> ~/a/b~

   ~http://ip:port/ui/a/b/?limit=10&page=1~ -> base: ~/ui~ -> ~/a/b~

   ~http://ip:port/a/ui/b/?limit=10&page=1~ -> base: ~/ui~ -> ~/a/ui/b~

   ç»“æ„ï¼š ~{value: url}~

2. ~historyState = { value: history.state }~

   å¦‚æœ ~historyState.value~ ä¸ºç©ºï¼Œéœ€è¦è¿›è¡Œåˆå§‹åŒ– -> ~changeLocation()~

3. ~changeLocation(to, state, replace)~ å‡½æ•°

4. ~replace(to, data?)~ å‡½æ•°

5. ~push(to, data?)~ å‡½æ•°

6. æœ€åè¿”å›ç»“æ„ ~{location: currentLocation, state: historyState, push, replace}~

*** createCurrentLocation(base: string,location: Location)

å¯¹ ~location { pathname, search, hash }~ åŠ å·¥è¿”å›æ–°çš„ url

#+begin_src typescript
function createCurrentLocation(
  base: string,
  location: Location
): HistoryLocation {
  const { pathname, search, hash } = location
  // allows hash based url
  const hashPos = base.indexOf('#')
  if (hashPos > -1) {
    // prepend the starting slash to hash so the url starts with /#
    let pathFromHash = hash.slice(1)
    if (pathFromHash[0] !== '/') pathFromHash = '/' + pathFromHash
    return stripBase(pathFromHash, '')
  }
  const path = stripBase(pathname, base)
  return path + search + hash
}
#+end_src

å‡½æ•°ä½œç”¨ï¼š base ä¸­å«æœ‰ ~#~ æ—¶ï¼Œç›´æ¥ä» location.hash ä¸­è§£æå‡º pathã€‚

æ¯”å¦‚ï¼š

~base=/ui/#/~

~url=https://ip:port/ui/#/base/industry/grouping?limit=10&page=1&tradeId=19&times=1614652347338~

æœ€åè§£æå‡ºæ¥çš„

~path=/base/industry/grouping?limit=10&page=1&tradeId=19&times=1614652347338~

å¦‚æœ base ä¸å« ~#~ ç›´æ¥å–å‡º path ä¸­å»æ‰ base éƒ¨åˆ†çš„ urlï¼Œå¦‚ï¼š

~base=/ui/~ -> ~url=http://ip:port/ui/path/to...~ å¾—åˆ° ~/path/to~

å¦‚æœ base åœ¨ url pathname çš„ä¸­é—´ï¼Œç›´æ¥è¿”å› pathname å› ä¸ºè¿™ç§æƒ…å†µé base æƒ…å†µ
~http://ip:port/path/ui/to~ ç›´æ¥è¿”å› ~/path/ui/to~
*** changeLocation(to,state,replace)

#+begin_src typescript
function changeLocation(
  to: HistoryLocation,
  state: StateEntry,
  replace: boolean
): void {
  //
  const hashIndex = base.indexOf("#");
  // to:list -> /base/#/ui/ -> /ui/list
  const url =
    hashIndex > -1
      ? (location.host && document.querySelector("base")
          ? base
          : base.slice(hashIndex)) + to
  // http://ip:port + base + to
      : createBaseLocation() + base + to;
  try {
    // BROWSER QUIRK
    // NOTE: Safari throws a SecurityError when calling this function 100 times in 30 seconds
    history[replace ? "replaceState" : "pushState"](state, "", url);
    historyState.value = state;
  } catch (err) {
    if (__DEV__) {
      warn("Error with push/replace State", err);
    } else {
      console.error(err);
    }
    // Force the navigation, this also resets the call count
    location[replace ? "replace" : "assign"](url);
  }
}
#+end_src

å»æ‰ base hash éƒ¨åˆ†å°† ~to~ è·¯ç”±ç»„åˆæˆ url è°ƒç”¨ ~history.replace|pushState(state,
title, url)~ æ”¹å˜
urlï¼ŒåŒæ—¶ä¿®æ”¹ historyState.value å€¼ã€‚
*** replace(to, data?)

#+begin_src typescript
function replace(to: HistoryLocation, data?: HistoryState) {
  const state: StateEntry = assign(
    {},
    history.state,
    buildState(
      historyState.value.back,
      // keep back and forward entries but override current position
      to,
      historyState.value.forward,
      true
    ),
    data,
    // æ›¿æ¢æ“ä½œï¼Œä½¿ç”¨è€çš„ position æ›¿ä»£æ–°çš„
    // è¿™ä¸ªä¼šåœ¨ changeLocation ä¸­ç”¨æ¥è®¡ç®— delta åç§»é‡
    { position: historyState.value.position }
  );

  // æ‰§è¡Œ replaceState
  // å– old historyState ç„¶åè®¾ç½® new historyState
  changeLocation(to, state, true);
  currentLocation.value = to;
}
#+end_src
*** push(to, data?)

#+begin_src typescript
function push(to: HistoryLocation, data?: HistoryState) {
  // Add to current entry the information of where we are going
  // as well as saving the current position
  const currentState = assign(
    {},
    // use current history state to gracefully handle a wrong call to
    // history.replaceState
    // https://github.com/vuejs/vue-router-next/issues/366
    historyState.value,
    history.state as Partial<StateEntry> | null,
    {
      forward: to,
      scroll: computeScrollPosition(),
    }
  );

  // ...

  // æ‰§è¡Œ pushState, è®°å½• old/new historyState
  changeLocation(currentState.current, currentState, true);

  const state: StateEntry = assign(
    {},
    buildState(currentLocation.value, to, null),
    { position: currentState.position + 1 },
    data
  );

  changeLocation(to, state, false);
  currentLocation.value = to;
}
#+end_src
** useHistoryListeners()

#+begin_src typescript
function useHistoryListeners(
  base: string,
  historyState: ValueContainer<StateEntry>,
  currentLocation: ValueContainer<HistoryLocation>,
  replace: RouterHistory["replace"]
) {
  // 1. popstate äº‹ä»¶å¤„ç†å¥æŸ„
  // 2. pause listeners
  // 3. listen(callback)
  // 4. beforeUnloadListener()
  // 5. destory()
  // 6. add event listenner: popstate + beforeunload
  // setup the listeners and prepare teardown callbacks
  window.addEventListener("popstate", popStateHandler);
  window.addEventListener("beforeunload", beforeUnloadListener);

  // 7. return { pauseListeners, listn, destory }
}
#+end_src

*** popStateHandler({ state })

å› ä¸º history.state ä¿å­˜äº†æ‰§è¡Œè·³è½¬æ˜¯ pushState/replaceState ä¼ å…¥çš„ç¬¬ä¸€ä¸ªå‚æ•°å€¼ï¼Œ
æ‰€ä»¥å¯ä»¥é€šè¿‡  to/from ä¸Šçš„ state è¿›è¡Œå¯¹æ¯”å¾—åˆ°è·³è½¬çš„æ–¹å‘æ˜¯ forward è¿˜æ˜¯ backã€‚

ä½†æ˜¯ history.state æ˜¯å®æ—¶çš„ï¼Œæ‰§è¡Œå®Œ push/replace å°±ä¼šå‘ç”Ÿæ”¹å˜ï¼Œè¿™é‡Œæ€ä¹ˆå¤„ç†è¿™ä¸ª
é—®é¢˜å‘¢ï¼Œèƒ½è®© to&from çŠ¶æ€å¾—ä»¥ä¿å­˜ï¼Ÿ

#+begin_quote
ç­”. å› ä¸ºä½¿ç”¨ historyState = { value: history.state } åšäº†ä¸ªä¸­ä»‹ï¼Œ
è™½ç„¶ history.state å®æ—¶å˜åŒ–ï¼Œä½†æ˜¯è¿™ä¸ª historyState æ˜¯ä¸ä¼šçš„ï¼Œæ‰‹åŠ¨ç”¨å®ƒæ¥ç®¡ç† to &
from çš„å‰åçŠ¶æ€ã€‚
#+end_quote


#+begin_src typescript
const popStateHandler: PopStateListener = ({
    state,
  }: {
    state: StateEntry | null
  }) => {
    const to = createCurrentLocation(base, location)
    const from: HistoryLocation = currentLocation.value
    // è¿™é‡Œæ‹¿åˆ°çš„æ˜¯è·³è½¬ä¹‹å‰çš„ state
    const fromState: StateEntry = historyState.value
    let delta = 0

    if (state) {
      currentLocation.value = to
      // è¿™é‡Œ state æ˜¯æ‰§è¡Œè·¯ç”±è·³è½¬ä¹‹åè§¦å‘äº† popstate äº‹ä»¶
      // å»å¾—åˆ°çš„æœ€æ–°çŠ¶æ€ï¼Œå¯¹åº” to æ›´æ–°è€çŠ¶æ€å€¼
      historyState.value = state

      // ignore the popstate and reset the pauseState
      // æš‚åœï¼Ÿå¿½ç•¥äº‹ä»¶é‡ç½® pauseState ?
      if (pauseState && pauseState === from) {
        pauseState = null
        return
      }
      // æ ¹æ® to & from state è®¡ç®—å‡ºè¦æ‰§è¡Œè·³è½¬çš„æ–¹å‘æˆ–åç§»
      delta = fromState ? state.position - fromState.position : 0
    } else {
      // æ²¡æœ‰æ–°çŠ¶æ€ï¼Œç›´æ¥æ›¿æ¢å†å²è®°å½•
      replace(to)
    }

    // console.log({ deltaFromCurrent })
    // Here we could also revert the navigation by calling history.go(-delta)
    // this listener will have to be adapted to not trigger again and to wait for the url
    // to be updated before triggering the listeners. Some kind of validation function would also
    // need to be passed to the listeners so the navigation can be accepted
    // call all listeners
    listeners.forEach(listener => {
      listener(currentLocation.value, from, {
        delta,
        type: NavigationType.pop,
        direction: delta
          ? delta > 0
            ? NavigationDirection.forward
            : NavigationDirection.back
          : NavigationDirection.unknown,
      })
    })
  }
#+end_src

*** pauseListeners()

#+begin_src typescript
function pauseListeners() {
  pauseState = currentLocation.value;
}
#+end_src
*** listen(callback)

çº¯ç²¹çš„ add æ“ä½œï¼Œæ›´æ–° ~listeners[]~ å’Œå¯¹åº”çš„ç§»é™¤å‡½æ•°åˆ—è¡¨ ~teardowns[]~

#+begin_src typescript
// æ·»åŠ ç›‘å¬å‡½æ•°ï¼Œè¿”å›å¯¹åº”çš„ teardown å‡½æ•°
  function listen(callback: NavigationCallback) {
    // setup the listener and prepare teardown callbacks
    listeners.push(callback)

    const teardown = () => {
      const index = listeners.indexOf(callback)
      if (index > -1) listeners.splice(index, 1)
    }

    teardowns.push(teardown)
    return teardown
  }
#+end_src
*** beforeUnloadListener()

æ•´ä¸ªé¡µé¢æ‰§è¡Œå¸è½½ä¹‹å‰çš„äº‹ä»¶ï¼Œå‘ç”Ÿåœ¨ ~unload~ ä¹‹å‰ã€‚

#+begin_src typescript
function beforeUnloadListener() {
    const { history } = window
    if (!history.state) return
    history.replaceState(
      assign({}, history.state, { scroll: computeScrollPosition() }),
      ''
    )
  }

#+end_src
*** destroy() æ³¨é”€äº‹ä»¶

#+begin_src typescript
function destroy() {
  for (const teardown of teardowns) teardown();
  teardowns = [];
  window.removeEventListener("popstate", popStateHandler);
  window.removeEventListener("beforeunload", beforeUnloadListener);
}
#+end_src
* createWebHashHistory
:PROPERTIES:
:COLUMNS: %CUSTOM_ID[(Custom Id)]
:CUSTOM_ID: web-hash
:END:

_/vue-router-next/src/history/hash.ts_

ä»æºç å¯ä»¥çœ‹å‡ºï¼Œè¯¥å‡½æ•°æ˜¯åŸºäº ~createWebHistory(base)~ å®Œæˆçš„ï¼Œä¹Ÿå°±æ˜¯è¯´è¿™ä¸ªä¹Ÿæ˜¯åŸº
äº history api å®Œæˆï¼Œåªä¸è¿‡åœ¨è¿™ä¸ªåŸºç¡€ä¸Šå¯¹ hash å€¼è¿›è¡Œäº†æƒ…å†µåˆ†æå’Œæ£€æµ‹ï¼Œåšäº†è¿›ä¸€
æ­¥ä¼˜åŒ–å¤„ç†ã€‚

#+begin_quote
å‚æ•° baseï¼Œå¯ä»¥å‡½æ•°è°ƒç”¨æ—¶æä¾›ï¼Œå¦‚æœå­˜åœ¨ ~<base href/>~ æ ‡ç­¾ä¼šä¼˜å…ˆå–è¿™ä¸ªæ ‡ç­¾çš„
href å€¼è§£æå‡º base å€¼ã€‚
#+end_quote

å¦‚ï¼Œå‡½æ•°æ³¨é‡Šï¼Œæœ‰ä»¥ä¸‹å‡ ç§å¯èƒ½æƒ…å†µ(å¦‚ï¼š ~base=https://example.com/folder~)

1. ~createWebHashHistory()~ æ— å‚æ•°

   ç»“æœï¼š https://example.com/folder#

2. ~createWebHashHistory('/folder/')~

   åŒ¹é… ~/folder~ æˆåŠŸï¼Œç»“æœï¼š https://example.com/folder/#

3. ~createWebHashHistory('/folder/#/app')~

   ä¸­é—´æœ‰ ~#~ ç¬¦å·çš„ï¼š

   åŒ¹é… ~/folder~ æˆåŠŸï¼Œç»“æœï¼š https://example.com/folder/#/app

4. +createWebHashHistory('/other-folder/')+

   åŒ¹é…å¤±è´¥ï¼Œä¼šç›´æ¥æ›¿æ¢ï¼Œç»“æœï¼š https://example.com/other-folder/#

   ä¸æ¨èè¿™ç§ï¼Œå› ä¸ºå®ƒä¼šæ”¹å˜æ ¹è·¯å¾„ã€‚

5. æ— ä¸»æœºçš„åœ°å€ï¼Œæ¯”å¦‚æœ¬åœ°æ–‡ä»¶è®¿é—®ï¼š file:///usr/etc/folder/index.html

   ~createWebHashHistory('/iAmIgnored')~

   ç»“æœï¼š file:///usr/etc/folder/index.html#

   æä¾›çš„ base ä¼šè¢«å¿½ç•¥ã€‚


#+begin_src typescript
export function createWebHashHistory(base?: string): RouterHistory {
  // Make sure this implementation is fine in terms of encoding, specially for IE11
  // for `file://`, directly use the pathname and ignore the base
  // location.pathname contains an initial `/` even at the root: `https://example.com`
  base = location.host ? base || location.pathname + location.search : ''
  // allow the user to provide a `#` in the middle: `/base/#/app`
  if (base.indexOf('#') < 0) base += '#'

  if (__DEV__ && !base.endsWith('#/') && !base.endsWith('#')) {
    warn(
      `A hash base must end with a "#":\n"${base}" should be "${base.replace(
        /#.*$/,
        '#'
      )}".`
    )
  }
  return createWebHistory(base)
}
#+end_src


æ›´å¤šè¯·æŸ¥çœ‹ [[#web-history][createWebHistory]] ã€‚
* TODO createMemoryHistory
:PROPERTIES:
:COLUMNS: %CUSTOM_ID[(Custom Id)]
:CUSTOM_ID: mem-his
:END:

é€šè¿‡ä¸€ä¸ªé˜Ÿåˆ—æ¥ç®¡ç†è·¯ç”±ã€‚

#+begin_src typescript
export function createMemoryHistory(base: string = ''): RouterHistory {
  let listeners: NavigationCallback[] = []
  let queue: HistoryLocation[] = [START]
  let position: number = 0

  function setLocation(location: HistoryLocation) {
    position++
    if (position === queue.length) {
      // we are at the end, we can simply append a new entry
      queue.push(location)
    } else {
      // we are in the middle, we remove everything from here in the queue
      queue.splice(position)
      queue.push(location)
    }
  }

  function triggerListeners(
    to: HistoryLocation,
    from: HistoryLocation,
    { direction, delta }: Pick<NavigationInformation, 'direction' | 'delta'>
  ): void {
    const info: NavigationInformation = {
      direction,
      delta,
      type: NavigationType.pop,
    }
    for (let callback of listeners) {
      callback(to, from, info)
    }
  }

  const routerHistory: RouterHistory = {
    // rewritten by Object.defineProperty
    location: START,
    state: {},
    base,
    createHref: createHref.bind(null, base),

    replace(to) {
      // remove current entry and decrement position
      queue.splice(position--, 1)
      setLocation(to)
    },

    push(to, data?: HistoryState) {
      setLocation(to)
    },

    listen(callback) {
      listeners.push(callback)
      return () => {
        const index = listeners.indexOf(callback)
        if (index > -1) listeners.splice(index, 1)
      }
    },
    destroy() {
      listeners = []
    },

    go(delta, shouldTrigger = true) {
      const from = this.location
      const direction: NavigationDirection =
        // we are considering delta === 0 going forward, but in abstract mode
        // using 0 for the delta doesn't make sense like it does in html5 where
        // it reloads the page
        delta < 0 ? NavigationDirection.back : NavigationDirection.forward
      position = Math.max(0, Math.min(position + delta, queue.length - 1))
      if (shouldTrigger) {
        triggerListeners(this.location, from, {
          direction,
          delta,
        })
      }
    },
  }

  Object.defineProperty(routerHistory, 'location', {
    get: () => queue[position],
  })

  return routerHistory
}
#+end_src
