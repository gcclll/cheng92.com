#+TITLE: Vue3 åŠŸèƒ½æ‹†è§£â‘¥ directives äº‹ä»¶ç»‘å®šæœºåˆ¶
#+DATE: <2021-06-28 09:28:23>
#+TAGS[]: vue3, vue-next, component, directives
#+CATEGORIES[]: vue
#+LANGUAGE: zh-cn
#+STARTUP: indent

#+begin_export html
<link href="https://fonts.goo~gleapis.com/cs~s2?family=ZCOOL+XiaoWei&display=swap" rel="stylesheet">
<link href="/js/vue/formatters-styles/style.css" rel="stylesheet">
<link href="/js/vue/formatters-styles/annotated.css" rel="stylesheet">
<link href="/js/vue/formatters-styles/html.css" rel="stylesheet">
<kbd>
<font color="blue" size="3" style="font-family: 'ZCOOL XiaoWei', serif;">
  è¯—å·ï¼šå…­é“åŒå ï¼Œé­”åŠ«ä¸‡åƒï¼Œå¼•æ¸¡å¦‚æ¥ã€‚
</font>
</kbd><br><br>
<script src="/js/utils.js"></script>
<script src="/js/vue/vue-next.js"></script>
<!--<script src="https://unpkg.com/vue@next"></script>-->
<script>
insertCssLink("https://unpkg.com/element-plus/lib/theme-chalk/index.css");
</script>
<script src="https://unpkg.com/element-plus/lib/index.full.js"></script>
<script type='text/javascript' src="https://cdn.jsdelivr.net/npm/jsondiffpatch/dist/jsondiffpatch.umd.min.js"></script>
<script src="/js/vue/tests/common.js"></script>
#+end_export

[[/img/bdx/yiyeshu-001.jpg]]

#+begin_quote
æœ¬æ–‡ä»æºç è§’åº¦è®²è§£äº†vueä¸­çš„äº‹ä»¶æ³¨å†Œæœºåˆ¶(v-on æŒ‡ä»¤)ã€‚
#+end_quote

è¯¥æ–‡åˆ†æçš„ç›¸å…³ä»£ç åœ¨ packages/runtime-dom åŒ…ä¸­ï¼Œä¸»è¦é’ˆå¯¹ v-on çš„äº‹ä»¶æ³¨å†Œæœºåˆ¶åŸç†
è¿›è¡Œåˆ†æä¸€ç¯‡æ–‡ç« ï¼Œç›¸å…³ä»£ç å¹¶ä¸å¤šï¼Œç†è§£èµ·æ¥ä¹Ÿä¸ä¼šæœ‰ä»€ä¹ˆå›°éš¾ã€‚

props å±æ€§ patch å…¥å£ï¼š [[https://github.com/vuejs/vue-next/blob/master/packages/runtime-dom/src/patchProp.ts][runtime-dom/src/patchProp.ts]]

é’ˆå¯¹ v-on å¤„ç†çš„ä»£ç åˆ†æ”¯ï¼š


#+begin_src typescript

export const patchProp: DOMRendererOptions['patchProp'] = (
  el,
  key,
  prevValue,
  nextValue,
  isSVG = false,
  prevChildren,
  parentComponent,
  parentSuspense,
  unmountChildren
) => {
  switch (key) {
      // ... class, style å±æ€§çš„å¤„ç†ï¼Œä¸»è¦æ˜¯è¿›è¡Œåˆå¹¶æ“ä½œ
    default:
      if (isOn(key)) {
        // ignore v-model listeners
        // v-on äº‹ä»¶å±æ€§å¤„ç†é€»è¾‘
        if (!isModelListener(key)) {
          patchEvent(el, key, prevValue, nextValue, parentComponent)
        }
      } else if (shouldSetAsProp(el, key, nextValue, isSVG)) {
        // ... dom åŸç”Ÿå±æ€§å¤„ç†
      } else {
        // ...
      }
      break
  }
}
#+end_src

æ‰€ä»¥é‡ç‚¹ä»£ç åœ¨

~patchEvent(el, key, prevValue, nextValue, parentComponent)~

ä¹Ÿå°±æ˜¯ _runtime-dom/src/modules/events.ts_ ä¸­

#+begin_src typescript
export function patchEvent(
  el: Element & { _vei?: Record<string, Invoker | undefined> },
  rawName: string,
  prevValue: EventValue | null,
  nextValue: EventValue | null,
  instance: ComponentInternalInstance | null = null
) {
  // vei = vue event invokers
  const invokers = el._vei || (el._vei = {})
  const existingInvoker = invokers[rawName]
  if (nextValue && existingInvoker) {
    // patch
    existingInvoker.value = nextValue
  } else {
    const [name, options] = parseName(rawName)
    if (nextValue) {
      // add
      const invoker = (invokers[rawName] = createInvoker(nextValue, instance))
      addEventListener(el, name, invoker, options)
    } else if (existingInvoker) {
      // remove
      removeEventListener(el, name, existingInvoker, options)
      invokers[rawName] = undefined
    }
  }
}
#+end_src

å¯ä»¥çœ‹åˆ°è¿™é‡Œå®ç°æ˜¯ä¸€ç§ç‰¹æ®Šå¤„ç†æ–¹å¼ï¼Œè€Œä¸æ˜¯ç®€å•çš„ç›´æ¥è°ƒç”¨ addEventListener å’Œ
removeEventListener ç›´æ¥å°†æ‰€æœ‰äº‹ä»¶å¥æŸ„æ³¨å†Œåˆ° element ä¸Šã€‚

#+begin_src typescript
  const invokers = el._vei || (el._vei = {})
  const existingInvoker = invokers[rawName]
#+end_src

*el._vei => vue event invokers*


å‚æ•°è¯´æ˜ï¼š

| name      | desc                                  |
|-----------+---------------------------------------|
| el        | äº‹ä»¶çš„ç›®æ ‡å…ƒç´                         |
| rawName   | äº‹ä»¶åç§°                              |
| prevValue | ç»‘å®šåœ¨ el ä¸Š rawName å¯¹åº”äº‹ä»¶çš„è€å¥æŸ„ |
| nextValue | ç»‘å®šåœ¨ el ä¸Š rawName å¯¹åº”äº‹ä»¶çš„æ–°å¥æŸ„ |
| instance  | å½“å‰ç»„ä»¶çš„å®ä¾‹                        |

å‚æ•°é‡ç‚¹åœ¨äº  prevValue & nextValue è¿™ä¸¤ä¸ªåˆ†åˆ«å¯¹åº”äº†äº‹ä»¶çš„å¤„ç†æ–°æ—§å‡½æ•°ã€‚

å¯¹äºæ‰€æœ‰çš„ prevValue & nextValue å¯¹åº”çš„äº‹ä»¶å¤„ç†å‡½æ•°éƒ½ä¸ä¼šæ˜¯ç›´æ¥è¢«æ³¨å†Œï¼Œè€Œæ˜¯ä¼šè¢«
å°è£…æˆä¸€ä¸ª Invoker å½¢å¼å­˜åœ¨ã€‚

è€Œ Invoker æ¥è‡ª createInvoker(nextValue):

ä¸€ä¸ªäºŒæ¬¡å°è£…å‡½æ•°ï¼š

#+begin_src typescript
function createInvoker(
  initialValue: EventValue,
  instance: ComponentInternalInstance | null
) {
  const invoker: Invoker = (e: Event) => {
    // async edge case #6566: inner click event triggers patch, event handler
    // attached to outer element during patch, and triggered again. This
    // happens because browsers fire microtask ticks between event propagation.
    // the solution is simple: we save the timestamp when a handler is attached,
    // and the handler would only fire if the event passed to it was fired
    // AFTER it was attached.
    const timeStamp = e.timeStamp || _getNow()
    if (timeStamp >= invoker.attached - 1) {
      callWithAsyncErrorHandling(
        patchStopImmediatePropagation(e, invoker.value),
        instance,
        ErrorCodes.NATIVE_EVENT_HANDLER,
        [e]
      )
    }
  }
  invoker.value = initialValue
  invoker.attached = getNow()
  return invoker
}
#+end_src

è¿”å›ä¸€ä¸ª
#+begin_src typescript
interface Invoker extends EventListener {
  value: EventValue
  attached: number
}
#+end_src

å°è£…è¿‡ç¨‹é‡ç‚¹åšäº†å‡ ä»¶äº‹æƒ…ï¼š

1. invoker é‡Œé¢ ~callWithAsyncErrorHandling()~ æ–¹å¼æ‰§è¡Œäº†äº‹ä»¶å¥æŸ„å‡½æ•°

   æ‹¦æˆªäº‹ä»¶å¤„ç†å‡½æ•°æ‰§è¡Œè¿‡ç¨‹ä¸­å·®ç”Ÿçš„é”™è¯¯å¼‚å¸¸ï¼Œè¿™äº›å¼‚å¸¸å¯ä»¥é€šè¿‡ vue çš„å…¨å±€é…ç½®æ¥æ•
   è·ï¼š

   #+begin_src js
   const instance = createApp(App)
   instance.config.errorHandler = function(err, vm, info) {
     // å¤„ç†é”™è¯¯å¼‚å¸¸
   }
   #+end_src

2. æ‰§è¡Œå‰ææ˜¯ ~timeStamp >= invoker.attached - 1~

   æ³¨é‡Šå†…å®¹ï¼š
   #+begin_quote
   async edge case #6566: inner click event triggers patch, event handler
    attached to outer element during patch, and triggered again. This happens
    because browsers fire microtask ticks between event propagation. the
    solution is simple: we save the timestamp when a handler is attached, and the handler would only fire if the event passed to it was fired AFTER it was attached.
   #+end_quote

   ä¸ªäººç¿»è¯‘ç†è§£ï¼š _äº‹ä»¶æ³¨å†ŒæœŸé—´ä¼šåŒæ—¶æ³¨å†Œåˆ° outer element ä¸Šï¼Œè¿™æ˜¯å› ä¸ºæµè§ˆå™¨ä¼šåœ¨
   äº‹ä»¶å†’æ³¡æœŸé—´è§¦å‘å¾®ä»»åŠ¡ ticksï¼Œä»è€Œå¯¼è‡´ä¼šè¢«é‡å¤è§¦å‘äº‹ä»¶ã€‚_

   è§£å†³æ–¹æ¡ˆå°±æ˜¯è®°å½•äº‹ä»¶æ³¨å†Œå®Œæˆæ—¶çš„æ—¶é—´æˆ³ï¼Œåœ¨æ‰§è¡Œçš„æ—¶å€™æ£€æµ‹æ˜¯ä¸æ˜¯è¿‡äº†è¯¥æ—¶é—´ï¼Œåª
   æœ‰è¿‡äº†è¯¥æ—¶é—´è§¦å‘çš„æ‰ä¼šå»æ‰§è¡Œã€‚

3. è®°å½•æ—¶é—´æˆ³

   #+begin_src js
   invoker.value = initialValue
   invoker.attached = getNow()
   #+end_src


#+begin_tip
@@html:<p><strong>TIP</strong></p>@@

æ³¨æ„åœ¨ invoker å‡½æ•°ä¸­æœ‰ä¸ªç‰¹æ®Šæ­¥éª¤ï¼š

~patchStopImmediatePropagation(e, invoker.value)~ è¿™æ˜¯åšä»€ä¹ˆçš„ï¼Ÿï¼Ÿï¼Ÿ

ç¨åå†è®²~~
#+end_tip

å›å¤´åœ¨çœ‹ [[https://github.com/vuejs/vue-next/blob/master/packages/runtime-dom/src/patchProp.ts][patchProp()]]

~el._vei~ ä¸Šä¿å­˜äº†æ‰€æœ‰çš„ <eventName, fns> äº‹ä»¶å’Œäº‹ä»¶å¥æŸ„çš„æ˜ å°„å…³ç³»ã€‚

å½“å‘ç°æ–°äº‹ä»¶æ¥åˆ°æ—¶ï¼Œé¦–å…ˆæ£€æµ‹çš„æ˜¯å½“å‰äº‹ä»¶åæ˜¯ä¸æ˜¯æ›¾ç»æ³¨å†Œè¿‡äº‹ä»¶å¥æŸ„ï¼Œå¦‚æœæ³¨å†Œè¿‡å°±
ç»§ç»­å¤ç”¨å¹¶ä¸”ç›´æ¥è¦†ç›–ä¹‹å‰çš„æ³¨å†Œçš„äº‹ä»¶å¥æŸ„:

#+begin_src typescript
if (nextValue && existingInvoker) {
  // patch
 existingInvoker.value = nextValue
}
#+end_src

ä½†æ˜¯è¯·æ³¨æ„ï¼Œè¿™é‡Œçš„è¦†ç›–å¹¶éæ˜¯ç›´æ¥å°±å°† element ä¸Šçš„ listener åˆ é™¤äº†å†èµ‹å€¼
(~addEventListener~)çš„æ“ä½œã€‚

#+begin_warn
@@html:<p><strong>WARNING</strong></p>@@

æ—¶åˆ»æ³¨æ„ï¼Œç»‘å®šåˆ° element ä¸Šçš„ event listener æ°¸è¿œéƒ½æ˜¯ä¸€ä¸ª Invokerï¼Œä¸”ä¸€æ—¦ç¬¬ä¸€æ¬¡
æ³¨å†Œäº†ä¹‹åè¿™ä¸ª Invoker å°±ä¼šä¸€ç›´ä½œä¸ºè¯¥ element ä¸Š event name å¯¹åº”çš„ event listener
å­˜åœ¨ã€‚ä¹‹åçš„æ‰€æœ‰å˜æ›´éƒ½æ˜¯å‘ç”Ÿåœ¨å°è£…ä¹‹åçš„ Invoker ä¸Šçš„ï¼Œå¦‚ä¸Šé¢çš„èµ‹å€¼æ“ä½œï¼Œæ”¹å˜çš„
åªæ˜¯ invoker.value ã€‚
#+end_warn

è€Œå¯¹äºè¿™ä¸ª value å€¼æ˜¯ä¸ª  ~type EventValue = Function | Function[]~ ç±»å‹ï¼Œè¿™ä¸ªå€¼
çš„å¤„ç†å‘ç”Ÿåœ¨ [[/vue/vue-mind-map-compiler-core-transform-generate/#headline-28][compiler-core]] å’Œ [[/vue/vue-mind-map-compiler-dom/#v-on][compiler-dom]] é˜¶æ®µçš„ vOn.ts ä¸­ï¼Œè¿™é‡Œå°±ä¸å¤šåšèµ˜è¿°äº†ï¼Œ
æœ‰å…´è¶£çš„å¯ä»¥é€šè¿‡é“¾æ¥æŸ¥çœ‹ä¹‹å‰ç›¸å…³çš„åˆ†æ(compiler-core é‡ç‚¹åœ¨äºæ¨¡æŒ‡ä»¤çš„è§£æï¼Œ
compiler-dom é˜¶æ®µé‡ç‚¹åœ¨äºä¿®é¥°ç¬¦çš„å¤„ç†ä¸Š)ã€‚

ç»§ç»­çœ‹ patchEvent :

#+begin_src typescript
if (nextValue && existingInvoker) {
    // patch
    existingInvoker.value = nextValue
} else {
  const [name, options] = parseName(rawName)
  if (nextValue) {
    // add
    const invoker = (invokers[rawName] = createInvoker(nextValue, instance))
    addEventListener(el, name, invoker, options)
  } else if (existingInvoker) {
      // remove
    removeEventListener(el, name, existingInvoker, options)
      invokers[rawName] = undefined
  }
}
#+end_src

ä¸¤ä¸ª if...elseï¼Œè¿™æ®µä»£ç å¾ˆå®¹æ˜“ç†è§£ä¸æ˜¯ï¼ï¼ï¼

éœ€è¦æ³¨æ„çš„æ˜¯æœ€åçš„ä¸€ä¸ª ~else if (existingInvoker)~ åˆ°è¿™é‡Œçš„æ—¶å€™ä¼šå°†äº‹ä»¶å¥æŸ„ç»™ç§»
é™¤ã€‚

æ¯”å¦‚ï¼š

~<div @click="null" />~
~<div @click="" />~
~<div @click="false" />~

ç­‰ç­‰ï¼Œäº‹ä»¶å¥æŸ„æ˜¯ä¸€äº›ç©ºå€¼çš„æ—¶å€™ä¼šå½“ä½œæ˜¯ç§»é™¤æ“ä½œã€‚

é‚£ä¹ˆåˆ°è¿™é‡ŒåŸºæœ¬ä¹Ÿå®Œæˆäº†äº‹ä»¶çš„ã€å°è£…-æ³¨å†Œ-ç§»é™¤ã€éƒ¨åˆ†ä»£ç ã€‚

- å°è£…ï¼š ~Invoker~ è®°å½• attach æ—¶é—´æˆ³é˜²æ­¢é‡å¤è§¦å‘ï¼Œæ•è·å¼‚å¸¸
- æ³¨å†Œï¼šä¸€ä¸ªäº‹ä»¶ååªä¼šæ³¨å†Œä¸€ä¸ª ~Invoker~ åç»­æ“ä½œéƒ½æ˜¯é’ˆå¯¹è¿™ä¸ª invoker è€Œè¨€
- ç§»é™¤ï¼šä½¿ç”¨ v-on æœ€åè§£æå¾—åˆ°çš„å€¼å¦‚æœæ˜¯ç©ºå€¼æ—¶ä¼šè¢«è§†ä¸ºç§»é™¤æ“ä½œ

é‚£ä¹ˆä¹‹å‰è¯´åˆ°çš„ ~patchStopImmediatePropagation(e, invoker.value)~ åˆæ˜¯ä»€ä¹ˆæ“ä½œï¼Ÿ

å¯¹äºåŸç”Ÿçš„äº‹ä»¶æœ‰ä¸ªåŸç”Ÿçš„å‡½æ•° ~event.stopImmediatePropagation()~ è¿™ä¸ªå‡½æ•°çš„å«ä¹‰ï¼š
å®ƒå¯ä»¥åœ¨ä»»æ„ä¸€ä¸ªäº‹ä»¶å¥æŸ„å‡½æ•°ä¸­è°ƒç”¨ï¼Œæ¥é˜»æ­¢åé¢çš„äº‹ä»¶è¢«è°ƒç”¨ã€‚

æ¯”å¦‚ï¼š
#+begin_src js
const a = () => {
  // log a
}
const b = (e) => {
  // log b
  e.stopImmediatePropagation()
}
const c = () => {
  // log c
}
const d = () => {
  // log d
}

el.addEventListener('click', a)
el.addEventListener('click', b)
el.addEventListener('click', c)
el.addEventListener('click', d)

// å®Œäº†ä¹‹åè§¦å‘ click ä¼šå¾—åˆ°ç»“æœ
// log a
// log b

// c/d ä¸ä¼šè¢«æ‰§è¡Œï¼Œè¿™å°±æ˜¯ stopImmediatePropagation çš„ä½œç”¨ã€‚
#+end_src

å› æ­¤ vue events.ts ä¸­çš„ ~patchStopImmediatePropagation(e: Event, value:
EventValue)~ å°±æ˜¯ä¸ºäº†æ¨¡æ‹Ÿè¿™ä¸ªä½œç”¨ï¼Œæ¥è®©è¿™ä¸ªåŸç”ŸåŠŸèƒ½ç”Ÿæ•ˆï¼Œå› ä¸º events.ts ä¸­å¯¹äº‹ä»¶
çš„ç»‘å®šä¸Šé¢è¯´è¿‡äº†ï¼Œé’ˆå¯¹elementä¸ŠåŒä¸€äº‹ä»¶åçš„äº‹ä»¶åªä¼šæœ‰ä¸€ä¸ªå¥æŸ„ Invoker å‡½æ•°ï¼Œæ‰€ä»¥
åŸç”Ÿçš„ stopImmediatePropagation åŠŸèƒ½å°±ä¼šå¤±æ•ˆã€‚

åŠŸèƒ½æ¨¡æ‹Ÿï¼šåªæœ‰ invoker.value æ˜¯ä¸ªæ•°ç»„æ—¶æ‰ä¼šç”Ÿæ•ˆã€‚

#+begin_src typescript
function patchStopImmediatePropagation(
  e: Event,
  value: EventValue
): EventValue {
  if (isArray(value)) {
    const originalStop = e.stopImmediatePropagation
    e.stopImmediatePropagation = () => {
      originalStop.call(e)
      ;(e as any)._stopped = true
    }
    return value.map(fn => (e: Event) => !(e as any)._stopped && fn(e))
  } else {
    return value
  }
}
#+end_src

å…¶å®å°±æ˜¯é‡å†™äº† e.stopImmediatePropagation ç»™äº‹ä»¶æ³¨å†Œä¸€ä¸ª ~_stopped~ å±æ€§ï¼Œç„¶åå°†
value ä¸­æ‰€æœ‰çš„ fn è¿›ä¸€æ­¥è¿›è¡Œå°è£…è¿”å›ä¸€ä¸ªå…¨æ–°çš„ fn:

~(e: Event) => !(e as any)._stopped && fn(e)~

é€šè¿‡æ£€æµ‹ _stoppped æ ‡è®°æ¥è¾¾åˆ°é˜»æ­¢åç»­å‡½æ•°çš„æ‰§è¡Œçš„ç›®çš„ã€‚

æœ€åï¼Œè¿™é‡Œè¿˜æœ‰ä¸ªé’ˆå¯¹ä¸‰ä¸ªä¿®é¥°ç¬¦çš„å¤„ç†(~/(?:Once|Passive|Capture)$/~)ï¼Œå› ä¸ºåœ¨
compiler-dom é˜¶æ®µï¼Œè¿™ä¸‰ä¸ªä¿®é¥°ç¬¦ä¼šè¢«å•ç‹¬è§£æï¼Œæ¯”å¦‚ï¼š

~<div @click.once=.../>~

æœ€åè¢«è§£ææˆ ~onClickOnce~ ä¾æ­¤ç±»æ¨ï¼š ~onClickPassive~, ~onClickCapture~ æ‰€ä»¥è¿™
é‡Œè¦è¿›è¡Œæ‹†åˆ†ä¸€ä¸‹ï¼Œç­‰äºæ˜¯æ‹†åˆ†å‡ºï¼š

~{once: true, passive: true, capture: true}~ çš„ç»“æ„ã€‚

æºç ï¼š
#+begin_src typescript
const optionsModifierRE = /(?:Once|Passive|Capture)$/

function parseName(name: string): [string, EventListenerOptions | undefined] {
  let options: EventListenerOptions | undefined
  if (optionsModifierRE.test(name)) {
    options = {}
    let m
    while ((m = name.match(optionsModifierRE))) {
      name = name.slice(0, name.length - m[0].length)
      ;(options as any)[m[0].toLowerCase()] = true
      options
    }
  }
  return [name.slice(2).toLowerCase(), options]
}
#+end_src

#+begin_warn
@@html:<p><strong>WARNING</strong></p>@@

*å°ç»“*ï¼š

æœ‰ç‚¹æ¹Šç¯‡å¹…çš„å«Œç–‘ ğŸ˜ª

å†…å®¹å…¶å®å¾ˆç®€å•ï¼Œå››ä¸ªå‡½æ•°ï¼Œä¸¤æ¬¡å°è£…ã€‚

1. createInvoker å°è£…äº‹ä»¶å¥æŸ„å‡½æ•° Invoker
2. patchEvent æ£€æµ‹ el._vei æ³¨å†Œ invoker.value
3. patchStopImmediatePropagation é€šè¿‡æ·»åŠ  event._stopped æ¨¡æ‹ŸåŸç”ŸåŠŸèƒ½ï¼Œæ‹¦æˆªåé¢
   çš„å‡½æ•°æ‰§è¡Œ
4. parseName ä¸‰ä¸ªä¿®é¥°ç¬¦çš„å¤„ç†å·¥ä½œ ~once/passive/capture~
#+end_warn
