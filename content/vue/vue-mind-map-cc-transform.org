#+TITLE: Vue3 源码头脑风暴之 3 ☞compiler-core - transform + codegen
#+DATE: <2020-11-30 10:07:11>
#+TAGS[]: vue, vue3, compiler-core, parser, compiler, transform
#+CATEGORIES[]: vue
#+LANGUAGE: zh-cn
#+STARTUP: indent shrink

#+begin_export html
<link href="https://fonts.goo~gleapis.com/cs~s2?family=ZCOOL+XiaoWei&display=swap" rel="stylesheet">
<kbd>
<font color="blue" size="3" style="font-family: 'ZCOOL XiaoWei', serif;">
  诗号：六道同坠，魔劫万千，引渡如来。
</font>
</kbd><br><br>
#+end_export

[[/img/bdx/yiyeshu-001.jpg]]

@@html:<kbd>@@
*[[https://github.com/gcclll/stb-vue-next][stb-vue-next]] 完全拷贝于 [[https://github.com/vuejs/vue-next][vue-next]] ，主要目的学习及尝试应用于机顶盒环境。*
@@html:</kbd>@@

@@html:<kbd>@@ *本文依据 commit 进程进行记录，只要跟着下面的进程走，你将能完整实
现 vue ast transform 和 codegen generate 最后生成 render 函数 💃🏼💃🏼💃🏼* @@html:</kbd>@@

#+begin_quote
声明：该篇为 ts 源码(/commit/)版本，之前做过一遍完整的 js 版本，更详细，也可参考

[[https://www.cheng92.com/vue/vue3-source-code-compiler-core-compile_ts/][Vue3.0 源码系列（二）编译器核心 - Compiler core 3: compile.ts - 若叶知秋]]

由于 transform 阶段直接测试不太好直观的看出结果，因此这里会结合 codegen 来一起实
现，即该文包含 compiler-core 三大阶段的最后两个阶段(transform + generate)
#+end_quote

#+begin_export html
<script src="/js/vue/compiler-core.global.js"></script>
<script>
let i = 0, j = 0
const l1 = x => (j = 0, console.log(`%c >>> ${++i} ${x}`, 'background: #222; color: #bada55'))
const l2 = x => console.log(`%c > ${i}.${j++} ${x}`, 'background: #222; color: #bada55')
const log = (args) => console.log.apply(console, Array.isArray(args) ? args : [args])
log.blue = x => log([`%c ${x}`, `color: blue`])
log.red = x => log([`%c ${x}`, `color: red`])
const { baseCompile } = VueCompilerCore
const compile = (tpl, title, logAst = false) => {
    l2(title)
    if (!tpl) return null
    const { code, ast } = baseCompile(tpl, {
        onError: (e) => console.warn(e.message),
        hoistStatic: true,
        ...( compile.options || {} )
    })

    log([code])
    logAst && log(typeof logAst === 'function' ? logAst(ast) : ast)
    return ast
}
const c = (tpl, desc) => compile(tpl, desc, ast => ast.codegenNode.props)

</script>
#+end_export


* 关键知识点

1. [[#element-transform][🔗]] root.children.length = 1 且类型是 ELEMENT的时候将 ~CREATE_VNODE~ 改成
   ~CREATE_BLOCK~   
2. [[#v-bind][🔗]] 动态属性为表达式时，中间不能有空格

   如： ~<div :[first + second]="third" ...~ 是非法的。

   因为 ~parseAttribute()~ 中的正则是不支持中间有空格的：

   取参数名的正则： ~/^[^\t\r\n\f />][^\t\r\n\f />=]*/~
3. [[#v-bind][🔗]] v-bind 指令的几种用法 ->
4. [[#slot-usage][🔗]] 用户组件 -> 插槽处理 -> v-slot 使用方法
* 脑图

# [[/img/vue3/compiler-core/compiler-core-parser.svg]]

* e03a03c init transform module

[[https://github.com/gcclll/stb-vue-next/commit/e03a03c5d775ff9315cc027d88b0669a775cf590][feat(init): transform section · gcclll/stb-vue-next@e03a03c]]

初始化函数。

#+begin_src typescript
export function createTransformContext(
  root: RootNode,
  {
    prefixIdentifiers = false,
    hoistStatic = false,
    cacheHandlers = false,
    nodeTransforms = [],
    directiveTransforms = {},
    transformHoist = null,
    isBuiltInComponent = NOOP,
    isCustomElement = NOOP,
    expressionPlugins = [],
    scopeId = null,
    ssr = false,
    ssrCssVars = ``,
    bindingMetadata = {},
    onError = defaultOnError
  }: TransformOptions
): TransformContext {
  const context: TransformContext = {

    // ...

    // methods
    helper(name) {
      context.helpers.add(name)
      return name
    },
    helperString(name) {
      return ``
    },
    replaceNode(node) {},
    removeNode(node) {},
    onNodeRemoved: () => {},
    addIdentifiers(exp) {
      // TODO
    },
    removeIdentifiers(exp) {
      // TODO
    },
    hoist(exp) {
      // TODO
      return {} as any
    },
    cache(exp, isVNode = false) {
      // TODO
      return {} as any
    }
  }

  return context
}

export function transform(root: RootNode, options: TransformOptions) {
  // TODO
}

// TODO
// createRootCodegen

export function traverseChildren(
  parent: ParentNode,
  context: TransformContext
) {
  // TODO
}

export function traverseNode(
  node: RootNode | TemplateChildNode,
  context: TransformContext
) {}

export function createStructuralDirectiveTransform(
  name: string | RegExp,
  fn: StructuralDirectiveTransform
): NodeTransform {
  return {} as any
}
#+end_src

* fc6f1f1 add transform function

[[https://github.com/gcclll/stb-vue-next/commit/fc6f1f112ae0e98b7e2e9a432d3dca1d6420307a][feat: transform function · gcclll/stb-vue-next@fc6f1f1]]

1. create transform context
2. traverse nodes, 递归遍历所有节点，构造器 codegenNode
3. hoist static, 静态节点提升，复用
4. ssr render, 不需要创建根节点 codegenNode
5. 复制 context 属性到 -> root


[[http://qiniu.ii6g.com/img/20201130231832.png]]

transform 作用就是通过 ~traverseNode()~ 递归遍历所有节点，解析，构造对应的节点
codegenNode 。
* b0d72da add compile.ts>compile()

[[https://github.com/gcclll/stb-vue-next/commit/b0d72dac2738fd270b0ea7fe0bb33f47597a233b][feat(add): compile function · gcclll/stb-vue-next@b0d72da]]

对外的 compile 函数，执行分为三个阶段：

- ast(~baseParse()~) -> 解析出 ast 结构
- transform(~transform()~) -> 解析 ast 得到 codegenNode
- codegen(~generate()~) -> 将 codegenNode 解析成 Render 函数


这是后面测试的基础，所以得提前实现了。

#+begin_src typescript

export function baseCompile(
  template: string | RootNode,
  options: CompilerOptions = {}
): CodegenResult {
  // const onError = options.onError || defaultOnError
  const isModuleMode = options.mode === 'module'

  const prefixIdentifiers =
    !__BROWSER__ && (options.prefixIdentifiers === true || isModuleMode)

  // TODO errors
  const ast = isString(template) ? baseParse(template, options) : template
  const [nodeTransforms, directiveTransforms] = getBaseTransformPreset(
    prefixIdentifiers
  )

  transform(
    ast,
    extend({}, options, {
      prefixIdentifiers,
      nodeTransforms: [
        ...nodeTransforms,
        ...(options.nodeTransforms || []) // user transforms
      ],
      directiveTransforms: extend(
        {},
        directiveTransforms,
        options.directiveTransforms || {}
      )
    })
  )

  return generate(
    ast,
    extend({}, options, {
      prefixIdentifiers
    })
  )
}
#+end_src

* 35248ce add exports maybe needs

[[https://github.com/gcclll/stb-vue-next/commit/35248ceece1aa8650b65f7f7ce13612660a65397][feat(add): compiler-core exports · gcclll/stb-vue-next@35248ce]]

增加 compiler-core 模块的导出(~export~)内容
* 05a223b add transform pure text
:PROPERTIES:
:COLUMNS: %CUSTOM_ID[(Custom Id)]
:CUSTOM_ID: pure-text
:END: 

[[https://github.com/gcclll/stb-vue-next/commit/05a223b7b1eb2ab877aec3b11feace484a7dde82][feat(add): transform pure text · gcclll/stb-vue-next@05a223b]]

#+begin_src typescript
export function traverseNode(
  node: RootNode | TemplateChildNode,
  context: TransformContext
) {
  // 保存当前被处理的 节点
  context.currentNode = node
  // 应用 transform 插件
  const { nodeTransforms } = context
  // 针对每个节点会收集到一个或多个 transformXxx 函数，用来解析它的 ast
  // 得到 codegenNode ，这些函数会在当前的节点树被递归遍历完之后调用
  const exitFns = []
  for (let i = 0; i < nodeTransforms.length; i++) {
    const onExit = nodeTransforms[i](node, context)
    if (onExit) {
      if (isArray(onExit)) {
        exitFns.push(...onExit)
      } else {
        exitFns.push(onExit)
      }
    }

    if (!context.currentNode) {
      // 节点可能被删除了，比如： v-else-if, v-else 会合并到 v-if 的 branches[] 中
      return
    } else {
      // 节点可能会替换了，需要更新
      node = context.currentNode
    }
  }

  switch (
    node.type
    // TODO
  ) {
  }

  context.currentNode = node
  let i = exitFns.length
  while (i--) {
    exitFns[i]()
  }
}
#+end_src

transform 阶段代码毕竟的三个阶段

1. 收集 transformXxx 函数到 exitFns
2. 根据 ast节点类型递归遍历子孙节点
3. 按照收集时相反的顺序执行 exitFns，解析出 codegenNode


为了方便测试，在 ~generate()~ 中直接返回 ast :
[[https://github.com/gcclll/stb-vue-next/commit/999d8d6b611443f8fd04282786d4a67f018d6319][test: generate return ast for test · gcclll/stb-vue-next@999d8d6]]
#+begin_src js
const {
  baseCompile
} = require(process.env.PWD + '/../../static/js/vue/compiler-core.global.js')

const res = baseCompile(`pure text`)
console.log(res.children[0])
#+end_src

+RESULTS:
#+begin_example
{
  type: 2,
  content: 'pure text',
  loc: {
    start: { column: 1, line: 1, offset: 0 },
    end: { column: 10, line: 1, offset: 9 },
    source: 'pure text'
  }
}
#+end_example

结果显示并没有 codegenNode 因为在transformText 中满足条件

~children.length === 1 && node.type === NodeTypes.ROOT~ 而直接退出了。

至于 ~root.codegenNode = undefined~ 需要实现 ~createRootCodegen()~

*** 61ce406 add createRootCodegen() to create root.codegenNode

[[https://github.com/gcclll/stb-vue-next/commit/61ce4066c9b49e11399da0b499220f426da444a0][feat: createRootCodegen() for pure text · gcclll/stb-vue-next@61ce406]]

只增加了针对非 ELEMENT 类型或者孩子节点没有 codegenNode 的情况实现(当前 commit
最简化)。

当 root.children 只有一个孩子节点且该节点没有自己的 codegenNode 时候：
#+begin_src typescript
function createRootCodegen(root: RootNode, context: TransformContext) {
  // const { helper } = context
  const { children } = root
  if (children.length === 1) {
    // 只有一个孩子节点，直接取该孩子节点 的 codegenNode
    const child = children[0]
    if (isSingleElementRoot(root, child) && child.codegenNode) {
      // 当 root 节点下只有一个 element 元素的孩子节点时，不进行提升
    } else {
      // - single <slot/>, IfNode, ForNode: already blocks.
      // - single text node: always patched.
      // root codegen falls through via genNode()

      root.codegenNode = child
    }
  } else if (children.length > 1) {
    // TODO
  } else {
    // no children = noop, codegen will return null.
  }
}
#+end_src

测试
#+begin_src js
const {
  baseCompile
} = require(process.env.PWD + '/../../static/js/vue/compiler-core.global.js')

const res = baseCompile(`pure text`)
console.log(res)
#+end_src

#+RESULTS:
#+begin_example
{
  type: 0,
  children: [ { type: 2, content: 'pure text', loc: [Object] } ],
  helpers: [],
  components: [],
  directives: [],
  hoists: [],
  imports: [],
  cached: 0,
  temps: 0,
  codegenNode: {
    type: 2,
    content: 'pure text',
    loc: { start: [Object], end: [Object], source: 'pure text' }
  },
  loc: {
    start: { column: 1, line: 1, offset: 0 },
    end: { column: 10, line: 1, offset: 9 },
    source: 'pure text'
  }
}
#+end_example

注意 codegenNode 其实就是 ~root.children[0]~ 节点本身。
*** b9f3cb7 add transform text

[[https://github.com/gcclll/stb-vue-next/commit/b9f3cb762e36e7f7090987db9cba77948845cdaf][feat: transformText function · gcclll/stb-vue-next@b9f3cb7]]

[[http://qiniu.ii6g.com/img/20201130150054.png]]

1. 必须是文本节点或者类型是组合表达式类型(~COMPOUND_EXPRESSION~)
2. patch flag 处理
3. 构造 TEXT_CALL 类型节点
4. codegenNode -> createCallExpression
*** f6d5271 add generate text codegen

codegen 阶段目的是将 codegenNode 解析成 Render 函数的一部分。

1. /f6d5271/ add ~createCodegenContext()~

   [[https://github.com/gcclll/stb-vue-next/commit/f6d52713ae8154d438c2ed94641525fa3c05edef][feat(add): codegen context creator · gcclll/stb-vue-next@f6d5271]]

   上下文对象创建函数，重点方法有两个(~push(code, node)~ 和 ~helper(key)~)。

   FIX1: lint errors, [[https://github.com/gcclll/stb-vue-next/commit/0ac8c2f4b6b5022caa0f83a7f850226c30a99d33][fix: f6d5271 lint errors · gcclll/stb-vue-next@0ac8c2f]]

2. /2ef2699/ 增加 text codegen generator 实现

   [[https://github.com/gcclll/stb-vue-next/commit/2ef2699b95457be4456b736b70467b98bf240ddd][feat: generate text codegen · gcclll/stb-vue-next@2ef2699]]

   该部分涉及到一个较为完整的 codegen generator 流程，所以增加内容较多，因此这里
   不直接贴代码了，请点击上面 commit 链接查看实际增加的源码。

   处理流程：

   - preamble 处理，如果是 Node 环境需要通过 ~import { ...} from 'vue'~ 语法，如
     果是浏览器环境使用 ~const { ... } = Vue~ 解构语法。

   - 是否使用 ~with() {}~ 作用域语法，默认是使用的

   - ~return ...~ 返回实际 render 函数返回结果，这里将返回最后被渲染的 DOM 结构。

   - ~genNode()~ 递归处理 ast 生成 render 函数的对应部分代码

3. /6b901f9/ 增加 node 环境或 module 环境处理(~genModulePreamble~)

   [[https://github.com/gcclll/stb-vue-next/commit/6b901f9f3d8af3dc415d31a6c5027d8e262fa74f][feat: module preamble · gcclll/stb-vue-next@6b901f9]]
   modue preamble : ~export { ... } from 'vue'~
   function preamble: ~const { ... } = Vue~


重点增加的 genXxx 函数 ~genText(node, context)~ 专门用来处理文本节点的。

#+begin_src typescript
function genText(
  node: TextNode | SimpleExpressionNode,
  context: CodegenContext
) {
  context.push(JSON.stringify(node.content), node)
}
#+end_src
*** 测试

测试将分为两个部分，
**** function preamble 形式(作为全局 ~Vue~ 对象引入)

#+begin_src js
const {
  baseCompile
} = require(process.env.PWD + '/../../static/js/vue/compiler-core.global.js')

const res = baseCompile(`pure text`)
console.log(res.code)
#+end_src

#+RESULTS:
:
: return function render(_ctx, _cache) {
:   with (_ctx) {
:     return "pure text"
:   }
: }
: undefined

[[https://github.com/gcclll/stb-vue-next/commit/6b3bd2e4c20dc7a325ff7c0575c127595da91b42][fix: less the last } paren · gcclll/stb-vue-next@6b3bd2e]]

**** module preamble 形式(*es6* 模块化导出导入)

#+begin_src js
const {
  baseParse,
  baseCompile
} = require(process.env.PWD + '/../../static/js/vue/compiler-core.global.js')

const res = baseCompile(`pure text`, { mode: 'module' })
console.log(res.code)
#+end_src

#+RESULTS:
:
: return function render(_ctx, _cache) {
:   return "pure text"
: }
: undefined

这里好像看不出啥区别，后面再说吧。
* 2f749b2 add interpolation generator
:PROPERTIES:
:COLUMNS: %CUSTOM_ID[(Custom Id)]
:CUSTOM_ID: interpolation
:END: 

[[https://github.com/gcclll/stb-vue-next/commit/2f749b2a5d0872713704a52943bb18b550c559c0][feat(add): transform -> generate interpolation · gcclll/stb-vue-next@2f749b2]]

#+begin_src js
const {
  baseParse,
  baseCompile
} = require(process.env.PWD + '/../../static/js/vue/compiler-core.global.js')

const res = baseCompile(`{{ a > b }}`)
console.log(res.code)
console.log(res.ast.children[0])
#+end_src

这里实现分几个部分：

*transform*: traverseNode() 增加对插值的处理，后面增加了 traverseChildren 处理，因为所有的
ast 都是挂在 ~root.children~ 中的，所以最开始解析的是 ~ROOT~ 节点，因此这里必须
要增加 ~ROOT~ 类型的解析，调用 ~traverseChildren(node, ctx)~ 去递归解析 ~root.children~

#+begin_quote
transform() -> traverseNode(): ROOT 解析 -> traverseChildren() ->
traverseNode(): INTERPOLATION
#+end_quote

新增核心函数：遍历所有 ~children[]~ 调用 ~traverseNode()~ 
#+begin_src typescript
export function traverseChildren(
  parent: ParentNode,
  context: TransformContext
) {
  // TODO	  let i = 0
  const nodeRemoved = () => {
    i--
  }

  for (; i < parent.children.length; i++) {
    const child = parent.children[i]
    if (isString(child)) continue
    context.parent = parent
    context.childIndex = i // 方便在 transformXxx 函数中能快速定位到当前节点
    context.onNodeRemoved = nodeRemoved
    traverseNode(child, context)
  }
}
#+end_src

[[http://qiniu.ii6g.com/img/20201201155917.png]]

*codegen*: ~genNode()~ 中新增 ~INTERPOLATION~ 和 ~SIMPLE_EXPRESSION~ 类型的处理，
 因为 INTERPOLATION 的 ast.content(如上面代码执行结果) 类型是 SIMPLE_EXPRESSION。

 #+begin_src typescript
function genExpression(node: SimpleExpressionNode, context: CodegenContext) {
  const { content, isStatic } = node
  context.push(isStatic ? JSON.stringify(content) : content, node)
}

function genInterpolation(node: InterpolationNode, context: CodegenContext) {
  const { push, helper, pure } = context
  if (pure) push(PURE_ANNOTATION)
  push(`${helper(TO_DISPLAY_STRING)}(`)
  genNode(node.content, context)
  push(')')
}
 #+end_src

-----

[[https://github.com/gcclll/stb-vue-next/commit/2d0e2a6f7610059f37aef798d37eaafdf8c43377][feat(add): comment generator · gcclll/stb-vue-next@2d0e2a6]]
 
拓展：add comment generator

#+begin_src js

const {
  baseParse,
  baseCompile
} = require(process.env.PWD + '/../../static/js/vue/compiler-core.global.js')

const res = baseCompile(`<!-- i'm a comment -->`)
console.log(res.code)
#+end_src

#+RESULTS:
#+begin_example
const _Vue = Vue

return function render(_ctx, _cache) {
  with (_ctx) {
    const { createCommentVNode : _createCommentVNode } = _Vue

    return _createCommentVNode(" i'm a comment ")
  }
}
undefined
#+end_example
* add element transfrom and generator
:PROPERTIES:
:COLUMNS: %CUSTOM_ID[(Custom Id)]
:CUSTOM_ID: element
:END: 

** 准备工作 ~compiler-core/src/utils.ts~

[[https://github.com/gcclll/stb-vue-next/commit/9436d8fe155767391a278807ae02a6ae9eff94a3][feat: utils for compiler-core · gcclll/stb-vue-next@9436d8f]]

相关正则： ~const memberExpRE = /^[A-Za-z_$][\w$]*(?:\s*\.\s*[A-Za-z_$][\w$]*|\[[^\]]+\])*$/~

[[http://qiniu.ii6g.com/img/image.png]]

[[https://github.com/gcclll/stb-vue-next/commit/2265e466e6daea95614d5fe96968b30ff11a2e19][feat(add): resolveComponentType · gcclll/stb-vue-next@2265e46]]

解析出组件的类型，大体分为四类：

1. 动态组件： ~<component is="xx">~ 或 ~<component v-is="xx">~
2. 内置组件： ~Teleport, Transition, KeepAlive, Suspense~
3. 用户组件： ~$setup[]~ 上的组件
4. 用户组件： ~context.components[]~ 上的组件

** 87339d2 add element transform
:PROPERTIES:
:COLUMNS: %CUSTOM_ID[(Custom Id)]
:CUSTOM_ID: element-transform
:END: 

[[https://github.com/gcclll/stb-vue-next/commit/87339d25f1fa43ed5e0a13dabc60fec9479451c1][feat(add): transformElement function · gcclll/stb-vue-next@87339d2]]

普通标签的 transform codegenNode阶段。

1. add ~createVNodeCall()~ 函数，创建基本的 ELEMENT 类型节点 codegenNode

  根据 ~isBlock~ 参数决定使用 BLOCK 函数还是 VNODE 函数。
   
  #+begin_src typescript
   export function createVNodeCall(
       context: TransformContext | null,
       tag: VNodeCall['tag'],
       props?: VNodeCall['props'],
       children?: VNodeCall['children'],
       patchFlag?: VNodeCall['patchFlag'],
       dynamicProps?: VNodeCall['dynamicProps'],
       directives?: VNodeCall['directives'],
       isBlock: VNodeCall['isBlock'] = false,
       disableTracking: VNodeCall['disableTracking'] = false,
       loc = locStub
   ): VNodeCall {
   if (context) {
       if (isBlock) {
           context.helper(OPEN_BLOCK)
           context.helper(CREATE_BLOCK)
       } else {
           context.helper(CREATE_VNODE)
       }
   }

   return {
       type: NodeTypes.VNODE_CALL,
       tag,
       props,
       children,
       patchFlag,
       dynamicProps,
       directives,
       isBlock,
       disableTracking,
       loc
   }
 }
 #+end_src

2. add ~createObjectExpression()~ 函数

   #+begin_src typescript
    export function createObjectExpression(
        properties: ObjectExpression['properties'],
        loc: SourceLocation = locStub
    ): ObjectExpression {
    return {
        type: NodeTypes.JS_OBJECT_EXPRESSION,
        loc,
        properties
    }
    }
   #+end_src

3. add ~getStaticType()~ 判断节点是否需要做静态提升处理

4. add ~transformElement: postTransformElement()~ 函数

5. add ~stringifyDynamicPropNames()~ 将属性转成数组结构


测试：
#+begin_src js
const {
  baseParse,
  baseCompile
} = require(process.env.PWD + '/../../static/js/vue/compiler-core.global.js')
 
const res = baseCompile(`<div></div>`)
console.log('root codegenNode: ', res.ast.codegenNode)
console.log(res.code)
#+end_src

#+RESULTS:
#+begin_example
root codegenNode:  undefined
const _Vue = Vue

return function render(_ctx, _cache) {
  with (_ctx) {
    const { createVNode : _createVNode } = _Vue

    return null
  }
}
undefined
#+end_example

正确结果：
#+begin_example
ƒ render(_ctx, _cache) {
  with (_ctx) {
    const { createVNode: _createVNode, openBlock: _openBlock, createBlock: _createBlock } = _Vue

    return (_openBlock(), _createBlock("div"))
  }
}
#+end_example

问题：
1. 根节点 codegenNode 为空
2. render 函数内没有 ~openBlock, createBlock~ 导出
3. return 后面没内容(这是 generator 范畴，此节不展开)


问题1，2都是在同一个地方处理的，因为当 ROOT 节点只有一个孩子节点的时候，不会用
CREATE_VNODE 创建，而是改用 CREATE_BLOCK，所以这两个问题一起处理

FIX 1,2: [[https://github.com/gcclll/stb-vue-next/commit/97cf290240fa937f167f8aadd6e6527744da4cbe][fix: no export open/create block function from Vue · gcclll/stb-vue-next@97cf290]]

修改： ~createRootCodegen(root: RootNode, context: TransformContext)~

** 2f58786 add element generator

[[https://github.com/gcclll/stb-vue-next/commit/2f58786c56986672c6b7cabdcd541363bf05b4dd][feat: element generator · gcclll/stb-vue-next@2f58786]]

路径：

1. ~VNODE_CALL~ ->

2. ~genVNodeCall()~ ->

3. ~genNodeList([], ctx)~ ->

    - string: ~push(node)~
    - array: ~genNodeListAsArray(node, ctx)~ 
    - other: ~genNode(node, ctx)~


测试:
#+begin_src js
const {
  baseParse,
  baseCompile
} = require(process.env.PWD + '/../../static/js/vue/compiler-core.global.js')
 
const res = baseCompile(`<div></div>`)
console.log('root codegenNode: ', res.ast.codegenNode)
console.log(res.code)
#+end_src

#+RESULTS:
#+begin_example
root codegenNode:  {
  type: 13,
  tag: '"div"',
  props: undefined,
  children: undefined,
  patchFlag: undefined,
  dynamicProps: undefined,
  directives: undefined,
  isBlock: true,
  disableTracking: false,
  loc: {
    start: { column: 1, line: 1, offset: 0 },
    end: { column: 12, line: 1, offset: 11 },
    source: '<div></div>'
  }
}
const _Vue = Vue

return function render(_ctx, _cache) {
  with (_ctx) {
    const { createVNode : _createVNode, openBlock : _openBlock, createBlock : _createBlock } = _Vue

    return (_openBlock(), _createBlock("div"))
  }
}
#+end_example
** 05ca2f8 root.children 有多个孩子

[[https://github.com/gcclll/stb-vue-next/commit/05ca2f8bedf21d146a01ad5694c727bbe776145c][feat: root.children has multi child · gcclll/stb-vue-next@05ca2f8 · GitHub]]

当有多个孩子节点的时候，会创建一个 ~fragment~ 将他们包起来。

[[http://qiniu.ii6g.com/img/20201201232048.png]]

FIX: 死循环， ~genNode(node.codegenNode, ctx)~

[[http://qiniu.ii6g.com/img/20201201232120.png]]

测试：

#+begin_src js

const {
  baseParse,
  baseCompile
} = require(process.env.PWD + '/../../static/js/vue/compiler-core.global.js')
 
const res = baseCompile(`<div></div><div></div>`)
console.log(res.code)
#+end_src

#+RESULTS:
#+begin_example
const _Vue = Vue

return function render(_ctx, _cache) {
  with (_ctx) {
    const { createVNode : _createVNode, Fragment : _Fragment, openBlock : _openBlock, createBlock : _createBlock } = _Vue

    return (_openBlock(), _createBlock(_Fragment,null,[
      _createVNode("div"),
      _createVNode("div")
    ],64 /* STABLE_FRAGMENT */))
  }
}
undefined
#+end_example

FIX: 参数之间少了空格([[https://github.com/gcclll/stb-vue-next/commit/05ca2f8bedf21d146a01ad5694c727bbe776145c?branch=05ca2f8bedf21d146a01ad5694c727bbe776145c&diff=split][feat: root.children has multi child · gcclll/stb-vue-next@05ca2f8]])

正解：
#+begin_example
const _Vue = Vue
const { createVNode: _createVNode } = _Vue

const _hoisted_1 = /*#__PURE__*/_createVNode("div", null, null, -1 /* HOISTED */)
const _hoisted_2 = /*#__PURE__*/_createVNode("div", null, null, -1 /* HOISTED */)

return function render(_ctx, _cache) {
  with (_ctx) {
    const { createVNode: _createVNode, Fragment: _Fragment, openBlock: _openBlock, createBlock: _createBlock } = _Vue

    return (_openBlock(), _createBlock(_Fragment, null, [
      _hoisted_1,
      _hoisted_2
    ], 64 /* STABLE_FRAGMENT */))
  }
}
#+end_example

正确答案中做了静态提升处理，代码在 ~transform()~ 函数中 ~hoistStatic(root,
context)~ 的调用，会从 ROOT 节点开始遍历，将需要提升的节点进行提升处理。
* 7cb3dbf add hoist static 静态提升

满足提升的三种情况：

1. tag 和 tagType 都是 ELEMENT 且整棵树都是静态
2. 包含动态孩子节点，但是有静态属性的，将属性提升
3. 纯文本节点


[[https://github.com/gcclll/stb-vue-next/commit/7d7dbd4e20198e73df5c93804dce122656252c8f][feat(add): hoist static · gcclll/stb-vue-next@7d7dbd4]]

transform() 中增加静态提升处理：

#+begin_src typescript
if (options.hoistStatic) {
  hoistStatic(root, context)
}
#+end_src

[[https://github.com/gcclll/stb-vue-next/commit/7cb3dbf94bd17c5af68dc55103a8031da28be55b][feat: hoist static · gcclll/stb-vue-next@7cb3dbf]]

1. 修改 ~genFunctionPreamble(ast: RootNode, context: CodegenContext)~ 解构出需要用到的函数(~_createVNode~)

   [[/img/commit/diff-hoist-decon-functions.png]]

2. 增加 ~genHoists()~ 函数，生成 ~ast.hoists~ 中需要提升的节点

    #+begin_src typescript
    function genHoists(hoists: (JSChildNode | null)[], context: CodegenContext) {
    if (!hoists.length) {
        return
    }

    context.pure = true
    const { push, newline, helper, scopeId, mode } = context
    const genScopeId = !__BROWSER__ && scopeId != null && mode !== 'function'
    newline()

    // push scope Id before initializing hoisted vnodes so that these vnodes
    // get the proper scopeId as well.
    if (genScopeId) {
        push(`${helper(PUSH_SCOPE_ID)}("${scopeId}")`)
        newline()
    }

    hoists.forEach((exp, i) => {
        if (exp) {
        push(`const _hoisted_${i + 1} = `)
        genNode(exp, context)
        newline()
        }
    })

    if (genScopeId) {
        push(`${helper(POP_SCOPE_ID)}()`)
        newline()
    }

    context.pure = false
    }
    #+end_src


测试：
#+begin_src js
const {
  baseParse,
  baseCompile
} = require(process.env.PWD + '/../../static/js/vue/compiler-core.global.js')
 
const res = baseCompile(`<div></div><div></div>`, { hoistStatic: true })
console.log(res.code)
#+end_src

#+RESULTS:
#+begin_example
const _Vue = Vue
const { createVNode: _createVNode } = _Vue

const _hoisted_1 = /*#__PURE__*/_createVNode("div", null, null, -1 /* HOISTED */)
const _hoisted_2 = /*#__PURE__*/_createVNode("div", null, null, -1 /* HOISTED */)

return function render(_ctx, _cache) {
  with (_ctx) {
    const { createVNode : _createVNode, Fragment : _Fragment, openBlock : _openBlock, createBlock : _createBlock } = _Vue

    return (_openBlock(), _createBlock(_Fragment, null, [
      _hoisted_1,
      _hoisted_2
    ], 64 /* STABLE_FRAGMENT */))
  }
}
undefined
#+end_example

#+begin_quote
PS: 静态属性提升 [[https://github.com/gcclll/stb-vue-next/commit/1e58eeb605b0dc88c90dac550b927f89dd18e07d][feat: props hoist static · gcclll/stb-vue-next@1e58eeb]]
#+end_quote

* prop transform and generator

在这之前我们完成了以下几个基本部分：

- [[#pure-text][文本]]
- [[#interpolation][插值]]
- [[#element][普通标签(一个和多个)]]


接下来需要完成属性的解析才能进行下一步，因为 ~v-if, v-for, v-slot, ...~ 都需要属
性解析。

属性转换这里异常复杂，需要慢慢展开来讲，并且涉及到各种指令，因此对于完整的测试需
要等所有指令 transform 完成之后再进行。

** 1792f93 props transform

*** buildProps

[[https://github.com/gcclll/stb-vue-next/commit/1792f93b26aff5d0db60d83b946a83fb0fa6e776][feat(add): transform props · gcclll/stb-vue-next@1792f93]]


- 将 ~codegenNode.props~ 构建成 如下结构：

  #+begin_src json
{
    "type":15,
    "properties":[
        {
            "type":16,
            "key":{
                "type":4,
                "isConstant":false,
                "content":"class",
                "isStatic":true
            },
            "value":{
                "type":4,
                "isConstant":false,
                "content":"second",
                "isStatic":true
            }
        },
        {
            "type":16,
            "key":{
                "type":4,
                "isConstant":false,
                "content":"onClick",
                "isStatic":true
            },
            "value":{
                "type":4,
                "content":"clickHandle",
                "isStatic":false,
                "isConstant":false,
            }
        }
    ]
}
  #+end_src

- v-bind,v-on 指令，没有参数，需要将 props 合并

*** transform props

[[https://github.com/gcclll/stb-vue-next/commit/20a5fa8bfefa9dd98a7965f78ff1f84de2591962][feat: transform props in codgenNode · gcclll/stb-vue-next@20a5fa8]]
** e4acc0d props generator

[[https://github.com/gcclll/stb-vue-next/commit/e4acc0dd5e33ceab3420f9e5ca8857f090bb536c][feat: props generator · gcclll/stb-vue-next@e4acc0d]]

修改点：

1. add ~genExpressionAsPropertyKey()~ 生成属性 key 函数

   三种可能的属性名

   - 静态属性名: ~<div class="value">~ -> ~{ class: "value" }~

   - 动态属性名: ~<div :[propName]="value"~ -> ~{ [propName]: "value"}~

   - 组合表达式属性名：TODO

    #+begin_src typescript
   // 生成对象的属性 key (可能是静态，动态)
   function genExpressionAsPropertyKey(
     node: ExpressionNode,
     context: CodegenContext
   ) {
     const { push } = context
     if (node.type === NodeTypes.COMPOUND_EXPRESSION) {
       // TODO 动态属性名或表达式
     } else if (node.isStatic) {
       // only quote key if necessary
       const text = isSimpleIdentifier(node.content)
         ? node.content
         : JSON.stringify(node.content)

       push(text, node)
     } else {
       push(`[${node.content}]`, node)
     }
   }
    #+end_src

2. add ~genObjectExpression()~ 将属性列表生成对象

   遍历节点的 ~node.properties~ 先生成 key(~genExpressionAsPropertyKey(key)~) 再生成 value(~genNode(value)~) 。


测试：
#+begin_src js

const {
  baseParse,
  baseCompile
} = require(process.env.PWD + '/../../static/js/vue/compiler-core.global.js')
 
const res = baseCompile(`<div class="first" name="div"></div>`, { hoistStatic: true })
console.log(res.code)
#+end_src

#+RESULTS:
#+begin_example
const _Vue = Vue
const { createVNode: _createVNode } = _Vue

const _hoisted_1 = {
  class: "first",
  name: "div"
}

return function render(_ctx, _cache) {
  with (_ctx) {
    const { createVNode : _createVNode, openBlock : _openBlock, createBlock : _createBlock } = _Vue

    return (_openBlock(), _createBlock("div", _hoisted_1))
  }
}
undefined
#+end_example

#+begin_quote
实例中最后是用的 ~createBlock()~ 是因为 root.children 只有一个 child 。
#+end_quote

** static props

修改函数： ~transforms/transformElement~

#+begin_src js

const {
  baseParse,
  baseCompile
} = require(process.env.PWD + '/../../static/js/vue/compiler-core.global.js')
 
const res = baseCompile(`<div class="first"></div><div class="second"></div>`, { hoistStatic: true })
console.log(res.ast.codegenNode.children[0].props[0])
#+end_src

#+RESULTS:
#+begin_example
{
  type: 6,
  name: 'class',
  value: {
    type: 2,
    content: 'first',
    loc: { start: [Object], end: [Object], source: '"first"' }
  },
  loc: {
    start: { column: 6, line: 1, offset: 5 },
    end: { column: 19, line: 1, offset: 18 },
    source: 'class="first"'
  }
}
undefined
#+end_example
** 6951dd1 merge props

[[https://github.com/gcclll/stb-vue-next/commit/6951dd1ff97da1ef803e97770162fe0293ef76cc][feat: merge props · gcclll/stb-vue-next@6951dd1]]

合并属性的条件：存在没有参数的指令，如： ~<div v-bind="{...}" v-on="{...}"~

FIX: [[https://github.com/gcclll/stb-vue-next/commit/12a66f0ebef241b282b4ccf746ddabc1a2f45ef1][fix: merge toHandlers props · gcclll/stb-vue-next@12a66f0]]

#+begin_src js

const {
  baseParse,
  baseCompile
} = require(process.env.PWD + '/../../static/js/vue/compiler-core.global.js')
const log = (code, title) => {
  console.log(`>>> ${title}`)
  const res = baseCompile(code)
  console.log(res.code)
}
 
log(`
<div class="first" v-on="{ click: clickHandle  }" v-bind="{ style: 'color:red' }"></div>`, '无参数的指令，合并所有属性')

log(`<div class="second" v-on:click="clickHandle" v-bind:style="color:red"></div>`, '有参数的指令，不合并')
#+end_src

#+RESULTS:
#+begin_example
>>> 无参数的指令，合并所有属性
const _Vue = Vue

return function render(_ctx, _cache) {
  with (_ctx) {
    const { toHandlers : _toHandlers, mergeProps : _mergeProps, createVNode : _createVNode, openBlock : _openBlock, createBlock : _createBlock } = _Vue

    return (_openBlock(), _createBlock("div", _mergeProps({ class: "first" }, _toHandlers({ click: clickHandle  }), { style: 'color:red' }), null, 16 /* FULL_PROPS */))
  }
}
>>> 有参数的指令，不合并
const _Vue = Vue

return function render(_ctx, _cache) {
  with (_ctx) {
    const { resolveDirective : _resolveDirective, createVNode : _createVNode, openBlock : _openBlock, createBlock : _createBlock } = _Vue

    return _withDirectives((_openBlock(), _createBlock("div", { class: "second" }, null, 512 /* NEED_PATCH */)), )
  }
}
undefined
#+end_example

有参数指令时，需要结合 ~v-on~ 指令解析，因此需要先实现了 transform 指令才能得到下面的正确结果。

不合并(~mergeProps()~) 的正解：

#+begin_src js
(function anonymous(
) {
const _Vue = Vue

return function render(_ctx, _cache) {
  with (_ctx) {
    const { createVNode: _createVNode, openBlock: _openBlock, createBlock: _createBlock } = _Vue

    return (_openBlock(), _createBlock("div", {
      class: "second",
      onClick: clickHandle,
      style: { color: 'red' }
    }, null, 12 /* STYLE, PROPS */, ["onClick"]))
  }
}
})
#+end_src

下面将继续完成指令相关的 transform
* 6c43451 add v-on transform

init: [[https://github.com/gcclll/stb-vue-next/commit/98dcc9653790a319c3bc04222322167db21546df][feat(init): v-on directive · gcclll/stb-vue-next@98dcc96]]

实现：[[https://github.com/gcclll/stb-vue-next/commit/6c4345156ffc86542120bb97deb438097b36efca][feat: v-on directive transform · gcclll/stb-vue-next@6c43451]]

#+begin_src js

const {
  baseParse,
  baseCompile
} = require(process.env.PWD + '/../../static/js/vue/compiler-core.global.js')
 
const res = baseCompile(`<div class="second" v-on:click="clickHandle" v-bind:style="color:red"></div>`)

console.log(res.code)
#+end_src

#+RESULTS:
#+begin_example
const _Vue = Vue

return function render(_ctx, _cache) {
  with (_ctx) {
    const { resolveDirective : _resolveDirective, createVNode : _createVNode, openBlock : _openBlock, createBlock : _createBlock } = _Vue

    return _withDirectives((_openBlock(), _createBlock("div", {
      class: "second",
      onClick: clickHandle
    }, null, 8 /* PROPS */, ["onClick"])), )
  }
}
undefined
#+end_example

问题： ~v-bind~ 没有被解析出来。

如果 v-on的 exp 是个简单的表达式，需要将其转成函数 ~$event => (i++)~

[[https://github.com/gcclll/stb-vue-next/commit/1542b412cef3a1c81e3099e52bb5f7aa1fee2abe][feat(add): v-on with simple expression as handler · gcclll/stb-vue-next@1542b41]]

判断是简单表达式的依据：

~const isInlineStatement = !(isMemberExp || fnExpRE.test(exp.content))~

即不是 member expression 也不是 function expression 。

member expression: ~/^[A-Za-z_$][\w$]*(?:\s*\.\s*[A-Za-z_$][\w$]*|\[[^\]]+\])*$/~
[[http://qiniu.ii6g.com/img/20201212163019.png]]

function expresstion: ~/^\s*([\w$_]+|\([^)]*?\))\s*=>|^\s*function(?:\s+[\w$]+)?\s*\(/~
[[http://qiniu.ii6g.com/img/20201212163123.png]]

测试：
#+begin_src js
const {
  baseParse,
  baseCompile
} = require(process.env.PWD + '/../../static/js/vue/compiler-core.global.js')
 
const { code, ast } = baseCompile(`<div v-on:click="i++"></div>`)
console.log(code)
console.log(`>>> event name`)
console.log(ast.codegenNode.props.properties[0].key)
console.log(`>>> event handler`)
console.log(ast.codegenNode.props.properties[0].value)
#+end_src

#+RESULTS:
#+begin_example
const _Vue = Vue

return function render(_ctx, _cache) {
  with (_ctx) {
    const { createVNode : _createVNode, openBlock : _openBlock, createBlock : _createBlock } = _Vue

    return (_openBlock(), _createBlock("div", {
      onClick: $event => (i++)
    }, null, 8 /* PROPS */, ["onClick"]))
  }
}
>>> event name
{
  type: 4,
  loc: {
    start: { column: 11, line: 1, offset: 10 },
    end: { column: 16, line: 1, offset: 15 },
    source: 'click'
  },
  content: 'onClick',
  isStatic: true,
  constType: 3
}
>>> event handler
{
  type: 8,
  loc: {
    source: '',
    start: { line: 1, column: 1, offset: 0 },
    end: { line: 1, column: 1, offset: 0 }
  },
  children: [
    '$event => (',
    {
      type: 4,
      content: 'i++',
      isStatic: false,
      constType: 0,
      loc: [Object]
    },
    ')'
  ]
}
undefined
#+end_example

#+begin_comment
更多测试用例(~<f12>~)打开控制台查看 ->> 。
#+end_comment

#+begin_export html
<script>
l1(`v-on 指令`)
c(`<div v-on:click="onClick"/>`, `v-on click`)
c(`<div v-on:[event]="handler"/>`, `v-on动态事件名`)
l2(`TODO 'dynamic arg with prefixing'`)
l2(`TODO dynamic arg with complex exp prefixing`)
c(`<div @click="i++"/>`, '如果 v-on 的exp 是个简单表达式，要用函数封装起来')
c(`<div @click="foo();bar()"/>`, `支持多个表达式`)
c(`<div @click="\nfoo();\nbar()\n"/>`, `支持多行表达式`)
c(`<div @click="foo($event)"/>`, `函数调用`)
c(`<div @click="foo($event);bar()"/>`, `函数调用加表达式混合`)
c(`<div @click="$event => foo($event)"/>`, `如果本身是函数不用多余处理`)
c(`<div @click="
      $event => {
        foo($event)
      }
    "/>`, `=> 如果表达式已经是函数原样输出就行`)
c(`<div @click="
      function($event) {
        foo($event)
      }
    "/>`, `function, 如果表达式已经是函数原样输出就行`)
c(`<div @click="a['b' + c]"/>`, `如果表达式是对象取值表达式，不用处理`)
c(`<div v-on:click />`, `如果没有表达式和修饰符，报错`)
c(`<div v-on:click.prevent />`, `如果没表达式但是有修饰符，不报错`)
c(`<div v-on:foo-bar="onMount"/>`, `事件名为 foo-bar 要转成驼峰 onFooBar`)
c(`<div v-on:vnode-mounted="onMount"/>`, 'case conversion for vnode hooks')
compile.options = { cacheHandlers: true }
c(`<div v-on:click.prevent />`, `empty handler`)
c(`<div v-on:click="foo" />`, 'member expression handler')
c(`<div v-on:click="foo.bar" />`, 'compound member expression handler')
c(`<comp v-on:click="foo" />`, 'bail on component member expression handler')
c(`<div v-on:click="() => foo()" />`, 'inline function expression handler')
c(`<div v-on:click="foo++" />`, 'inline statement handler')
</script>
#+end_export

~options.cacheHandlers~ 属性要配合 ~options.prefixIdentifiers~ 使用。

作用是缓存事件处理函数，原理是:
#+begin_src js
return function render(_ctx, _cache) {
  with (_ctx) {
    const { createVNode : _createVNode, openBlock : _openBlock, createBlock : _createBlock } = _Vue

    return (_openBlock(), _createBlock("div", {
      onClick: _cache[1] || (_cache[1] = () => {})
    }))
  }
}
#+end_src

缓存的附加条件： ~let shouldCache: boolean = context.cacheHandlers && !exp~

没有表达式值的情况下才缓存，因为此时会创建一个空的函数作为事件 handler，为了避免
创建过多的无意义的空函数，使用缓存是个不错的选择(+但，一般绑定了事件应该不至于不
给处理函数吧!!!+)。


* f805858 add v-bind transform
:PROPERTIES:
:COLUMNS: %CUSTOM_ID[(Custom Id)]
:CUSTOM_ID: v-bind
:END: 

[[https://github.com/gcclll/stb-vue-next/commit/f80585802218bcc75aad502880c571b642257ef0][feat(add): v-bind transform · gcclll/stb-vue-next@f805858]]

#+begin_src js
const {
  baseParse,
  baseCompile
} = require(process.env.PWD + '/../../static/js/vue/compiler-core.global.js')
 
const res = baseCompile(`
<div v-bind:name="test"
  :age="100"
  :[propName]="myName"
  :[first+second]="thrid"
  :no-need-camel-prop="noNeedCamelProp"
  :need-camel-prop.camel="needCamelProp"
  :no-exp-prop.camel
></div>`, {
  onError(e) {
    console.log(e.message)
  }
})
console.log(`>>> render function\n`)
console.log(res.code)
#+end_src

#+RESULTS:
#+begin_example
v-bind is missing expression.
>>> render function

const _Vue = Vue

return function render(_ctx, _cache) {
  with (_ctx) {
    const { createVNode : _createVNode, openBlock : _openBlock, createBlock : _createBlock } = _Vue

    return (_openBlock(), _createBlock("div", {
      name: test,
      age: 100,
      [propName || ""]: myName,
      [first+second || ""]: thrid,
      "no-need-camel-prop": noNeedCamelProp,
      needCamelProp: needCamelProp,
      noExpProp: ""
    }, null, 16 /* FULL_PROPS */, ["name","age","no-need-camel-prop","needCamelProp","noExpProp"]))
  }
}
undefined
#+end_example

v-bind 属性支持以下几种方式：

- ~v-bind:name="test"~ 无缩写属性，最普通的一种用法
- ~:age="100"~ 缩写形式
- ~:[propName]="myName"~ 普通动态属性名
- ~:[first+second]="third"~ 表达式动态属性名
- ~:no-need-camel-prop="noNeedCamelProp"~ 不需要转驼峰的属性名
- ~:need-camel-prop.camel="needCamelProp"~ 需要转成驼峰的属性名，需要制定
  ~.camel~ 修饰符
- ~no-exp-prop.camel~ 无属性值的属性，会给默认 ~""~ 值，同时给出警告，不建议使用。

#+begin_comment
更多测试用例(~<f12>~)打开控制台查看 ->> 。
#+end_comment

#+begin_export html
<script>
l1(`v-bind 指令 >>>>>`)
c(`<div v-bind:id="id"/>`, 'basic')
c(`<div v-bind:[id]="id"/>`, `dynamic arg`)
c(`<div v-bind:arg />`, `should error if no expression`)
c(`<div v-bind:foo-bar.camel="id"/>`, '.camel modifier')
c(`<div v-bind:[foo].camel="id"/>`, '.camel modifier w/ dynamic arg')
c(`<div v-bind:[foo(bar)].camel="id"/>`, '.camel modifier w/ dynamic arg + prefixIdentifiers')
</script>
#+end_export

* 0cc76f0 add v-model transform

[[https://github.com/gcclll/stb-vue-next/commit/0cc76f04112b1194e0a5cafae0a49bc399462ebf][feat(add): v-model transform · gcclll/stb-vue-next@0cc76f0]]

~<input v-model="model" />~

经过 ~transformModel~ 之后的 node.props:

#+begin_src json
[
    {
        "type":16, // JS_PROPERTY
        "key":{
            "type":4, // SIMPLE_EXPRESSION
            "content":"modelValue",
            "isStatic":true,
            "constType":3
        },
        "value":{
            "type":4,
            "content":"model",
            "isStatic":false,
            "constType":0,
        }
    },
    {
        "type":16,
        "key":{
            "type":4,
            "content":"onUpdate:modelValue",
            "isStatic":true,
            "constType":3
        },
        "value":{
            "type":8, // COMPOUND_EXPRESSION
            "children":[
                "$event => (",
                {
                    "type":4,
                    "content":"model",
                    "isStatic":false,
                    "constType":0,
                },
                " = $event)"
            ]
        }
    }
]
#+end_src

compiler-core 阶段的解析脑图：
[[/img/vue3/compiler-core/pcg/pcg-08-v-model-cc.svg]]

从图中可以看出， v-model 指令的解析也是在 buildProps 中完成的，关于这个函数的脑
图也可以查看 [[/vue/vue-mind-map-house-cc/#key-01-build-props][buildProps(node, context) 如何构建 props ?]]

vue/baseCompile 解析之后的结果：

#+begin_src js
const _Vue = Vue

return function render(_ctx, _cache) {
  with (_ctx) {
    const { createVNode: _createVNode, openBlock: _openBlock, createBlock: _createBlock } = _Vue

    return (_openBlock(), _createBlock("input", {
      modelValue: model,
      "onUpdate:modelValue": $event => (model = $event)
    }, null, 8 /* PROPS */, ["modelValue", "onUpdate:modelValue"]))
  }
}
#+end_src

vue/compile 经过 compile-dom package(/未完成/) 的 transformModel 之后的结果：

#+begin_src js
(function anonymous(
) {
const _Vue = Vue

return function render(_ctx, _cache) {
  with (_ctx) {
    const { vModelText: _vModelText, createVNode: _createVNode, withDirectives: _withDirectives, openBlock: _openBlock, createBlock: _createBlock } = _Vue

    return _withDirectives((_openBlock(), _createBlock("input", {
      "onUpdate:modelValue": $event => (model = $event)
    }, null, 8 /* PROPS */, ["onUpdate:modelValue"])), [
      [_vModelText, model]
    ])
  }
}
})
#+end_src

[[https://github.com/gcclll/stb-vue-next/commit/a537be0fc265243012032750a801b6e6582751d5][fix: v-model no value · gcclll/stb-vue-next@a537be0]]

修复之后(~genNode~ 没有实现 ~8,COMPOUND_EXPRESSION~ 类型)，测试

1. 不带参数的 ~v-model~

   #+begin_src js
    const {
        baseParse,
        baseCompile
    } = require(process.env.PWD + '/../../static/js/vue/compiler-core.global.js')

    const { code } = baseCompile(`<input v-model="model" />`)
    console.log(code)
    #+end_src

    #+RESULTS:
    #+begin_example
    const _Vue = Vue

    return function render(_ctx, _cache) {
      with (_ctx) {
        const { createVNode : _createVNode, openBlock : _openBlock, createBlock : _createBlock } = _Vue

        return (_openBlock(), _createBlock("input", {
          modelValue: model,
          "onUpdate:modelValue": $event => (model = $event)
        }, null, 8 /* PROPS */, ["modelValue","onUpdate:modelValue"]))
      }
    }
    #+end_example

2. 指令 ~{ prefixIdentifiers: true }~ 选项(需要 node 环境, *TODO*)

   #+begin_src js
    const {
        baseParse,
        baseCompile
    } = require(process.env.PWD + '/../../static/js/vue/compiler-core.global.js')

    const { code } = baseCompile(`<input v-model="model" />`, {
      prefixIdentifiers: true
    })
    console.log(code)
   #+end_src

   #+RESULTS:
   #+begin_example
   const _Vue = Vue

   return function render(_ctx, _cache) {
     with (_ctx) {
       const { createVNode : _createVNode, openBlock : _openBlock, createBlock : _createBlock } = _Vue

       return (_openBlock(), _createBlock("input", {
         modelValue: model,
         "onUpdate:modelValue": $event => (model = $event)
       }, null, 8 /* PROPS */, ["modelValue","onUpdate:modelValue"]))
     }
   }
   undefined
   #+end_example

3. 组合表达式(~8,COMPOUND_EXPRESSION~)

   #+begin_src js
const {
  baseParse,
  baseCompile
} = require(process.env.PWD + '/../../static/js/vue/compiler-core.global.js')

const { code } = baseCompile(`<input v-model="model[index]" />`)
console.log(code)
 
   #+end_src

   #+RESULTS:
   #+begin_example
   const _Vue = Vue

   return function render(_ctx, _cache) {
     with (_ctx) {
       const { createVNode : _createVNode, openBlock : _openBlock, createBlock : _createBlock } = _Vue

       return (_openBlock(), _createBlock("input", {
         modelValue: model[index],
         "onUpdate:modelValue": $event => (model[index] = $event)
       }, null, 8 /* PROPS */, ["modelValue","onUpdate:modelValue"]))
     }
   }
   undefined
   #+end_example

4. 带参数

   #+begin_src js

const {
  baseParse,
  baseCompile
} = require(process.env.PWD + '/../../static/js/vue/compiler-core.global.js')
 
const { code } = baseCompile(`<input v-model:value="model" />`)
console.log(code)
   #+end_src

   #+RESULTS:
   #+begin_example
   const _Vue = Vue

   return function render(_ctx, _cache) {
     with (_ctx) {
       const { createVNode : _createVNode, openBlock : _openBlock, createBlock : _createBlock } = _Vue

       return (_openBlock(), _createBlock("input", {
         value: model,
         "onUpdate:value": $event => (model = $event)
       }, null, 40 /* PROPS, HYDRATE_EVENTS */, ["value","onUpdate:value"]))
     }
   }
   undefined
   #+end_example

    不带参数的时候参数名会给一个默认值： ~modelValue~, 如果有自己的参数会直接使
   用提供的参数名。

5. 动态参数

   #+begin_src js

const {
  baseParse,
  baseCompile
} = require(process.env.PWD + '/../../static/js/vue/compiler-core.global.js')
 
const { code } = baseCompile(`<input v-model:[value]="model" />`)
console.log(code)
   #+end_src

   有问题结果：
   #+RESULTS:
   #+begin_example
   const _Vue = Vue

   return function render(_ctx, _cache) {
     with (_ctx) {
       const { createVNode : _createVNode, openBlock : _openBlock, createBlock : _createBlock } = _Vue

       return (_openBlock(), _createBlock("input", {
         [value]: model,
         : $event => (model = $event)
       }, null, 16 /* FULL_PROPS */))
     }
   }
   #+end_example

   结果显示，动态属性的事件名没有被解析出来 ~: $event => (model = $event)~ 。

   修复之后结果([[https://github.com/gcclll/stb-vue-next/commit/94a7a850d7e060e948c5672cdb170c47489feda9][fix: v-model dynamic arg generate · gcclll/stb-vue-next@94a7a85]])：
   #+RESULTS:
   #+begin_example
   const _Vue = Vue

   return function render(_ctx, _cache) {
     with (_ctx) {
       const { createVNode : _createVNode, openBlock : _openBlock, createBlock : _createBlock } = _Vue

       return (_openBlock(), _createBlock("input", {
         [value]: model,
         ["onUpdate:" + value]: $event => (model = $event)
       }, null, 16 /* FULL_PROPS */))
     }
   }
   #+end_example

6. 缓存事件回调函数(~cacheHandlers: true~, *TODO*)

   需要结合 ~prefixIdentifiers: true~ 使用。
* bf18a84 add v-once transform

[[https://github.com/gcclll/stb-vue-next/commit/bf18a84650adaf68004a0ce0977d33b1436a4587][feat(add): v-once · gcclll/stb-vue-next@bf18a84]]

#+begin_src typescript
const seen = new WeakSet()

export const transformOnce: NodeTransform = (node, context) => {
  if (node.type === NodeTypes.ELEMENT && findDir(node, 'once', true)) {
    // 缓存实现 v-once，就算有数据更新也不会重新生成 render 函数
    if (seen.has(node)) {
      return
    }
    seen.add(node)
    context.helper(SET_BLOCK_TRACKING)
    return () => {
      const cur = context.currentNode as ElementNode | IfNode | ForNode
      if (cur.codegenNode) {
        cur.codegenNode = context.cache(cur.codegenNode, true /* isVNode */)
      }
    }
  }
}
#+end_src

~v-once~ 指令的实现看似挺简单的，将解析后的 node 节点缓存到 ~seen: WeakSet~ 中，
下次使用的时候直接取缓存(~context.cache(...)~)，而不是重新生成 ~codegenNode~

~JS_CACHE_EXPRESSION~ 结构：

#+begin_src typescript
export function createCacheExpression(
  index: number,
  value: JSChildNode,
  isVNode: boolean = false
): CacheExpression {
  return {
    type: NodeTypes.JS_CACHE_EXPRESSION,
    index, // 在 context.cached 中的索引
    value, // v-once节点的 ast
    isVNode, // block 或 vnode ?
    loc: locStub
  }
}
#+end_src

generator 阶段实现：[[https://github.com/gcclll/stb-vue-next/commit/8bacf14f156f0ca357d4c0efdbc75dc2120a3ec5][feat(add): v-once generator · gcclll/stb-vue-next@8bacf14]]

在 ~genNode()~ 中增加 ~JS_CACHE_EXPRESSION~ 类型的分支处理。

#+begin_src typescript
function genCacheExpression(node: CacheExpression, context: CodegenContext) {
  const { push, helper, indent, deindent, newline } = context
  if (node.isVNode) {
    indent()
    push(`${helper(SET_BLOCK_TRACKING)}(-1),`)
    newline()
  }

  push(`_cache[${node.index}] = `)
  genNode(node.value, context)
  if (node.isVNode) {
    push(`,`)
    newline()
    push(`${helper(SET_BLOCK_TRACKING)}(1),`)
    newline()
    push(`_cache[${node.index}]`)
    deindent()
  }
  push(`)`)
}
#+end_src

测试：

#+begin_src js
const {
  baseParse,
  baseCompile
} = require(process.env.PWD + '/../../static/js/vue/compiler-core.global.js')
 
const c = ( tpl, desc ) => {
  console.log(desc)
  const { code } = baseCompile(tpl)
  console.log(code)
}

c(`<div :id="foo" v-once />`, `>>> <div :id="foo" v-once />`)
c(`<div><div :id="foo" v-once /></div>`, `>>> 标签中嵌套使用`)
c(`<div><Comp :id="foo" v-once /></div>`, `>>> 在自定义组件上`)
#+end_src

#+RESULTS:
#+begin_example
>>> <div :id="foo" v-once />
const _Vue = Vue

return function render(_ctx, _cache) {
  with (_ctx) {
    const { setBlockTracking : _setBlockTracking, createVNode : _createVNode } = _Vue

    return _cache[1] || (
      _setBlockTracking(-1),
      _cache[1] = _createVNode("div", { id: foo }, null, 8 /* PROPS */, ["id"]),
      _setBlockTracking(1),
      _cache[1]
    )
  }
}
>>> 标签中嵌套使用
const _Vue = Vue

return function render(_ctx, _cache) {
  with (_ctx) {
    const { setBlockTracking : _setBlockTracking, createVNode : _createVNode, openBlock : _openBlock, createBlock : _createBlock } = _Vue

    return (_openBlock(), _createBlock("div", null, [
      _cache[1] || (
        _setBlockTracking(-1),
        _cache[1] = _createVNode("div", { id: foo }, null, 8 /* PROPS */, ["id"]),
        _setBlockTracking(1),
        _cache[1]
      )
    ]))
  }
}
>>> 在自定义组件上
const _Vue = Vue

return function render(_ctx, _cache) {
  with (_ctx) {
    const { setBlockTracking : _setBlockTracking, resolveComponent : _resolveComponent, createVNode : _createVNode, openBlock : _openBlock, createBlock : _createBlock } = _Vue

    return (_openBlock(), _createBlock("div", null, [
      _cache[1] || (
        _setBlockTracking(-1),
        _cache[1] = _createVNode(_component_Comp, { id: foo }, null, 8 /* PROPS */, ["id"]),
        _setBlockTracking(1),
        _cache[1]
      )
    ]))
  }
}
undefined
#+end_example

TODO 缺少： ~const _component_Comp = _resolveComponent("Comp")~
* acdea14 add v-if transform

~v-if~ 指令源码脑图可参考： [[/vue/vue-mind-map-house-cc/#pcg-v-if][05 v-if 指令(git:0a591b6)]]

对于 ~v-if|else|else-if~ 指令在 transform 阶段，转换收集 transformXxx 函数过程中，
会先针对指令进行处理，比如： ~v-else, v-else-if~ 指令的组件会被解析到 ~v-if~ 节
点的 ~node.branches[]~ 分支数组里面之后被删除，这些都是在收集 transformXxx 之前需要完成的。

包括 ~v-for~ 指令都需要经过 ~createStructuralDirectiveTransform()~ 函数封装一层
之后，返回对应的 ~transformXxx~ 函数。

#+begin_src typescript

export function createStructuralDirectiveTransform(
  name: string | RegExp,
  fn: StructuralDirectiveTransform
): NodeTransform {
  const matches = isString(name)
    ? (n: string) => n === name
    : (n: string) => name.test(n)

  return (node, context) => {
    if (node.type === NodeTypes.ELEMENT) {
      const { props } = node
      // structural directive transforms are not concerned with slots
      // as they are handled separately in vSlot.ts
      if (node.tagType === ElementTypes.TEMPLATE && props.some(isVSlot)) {
        return
      }
      const exitFns = []
      for (let i = 0; i < props.length; i++) {
        const prop = props[i]
        if (prop.type === NodeTypes.DIRECTIVE && matches(prop.name)) {
          // structural directives are removed to avoid infinite recursion
          // also we remove them *before* applying so that it can further
          // traverse itself in case it moves the node around
          props.splice(i, 1)
          i--
          const onExit = fn(node, prop, context)
          if (onExit) exitFns.push(onExit)
        }
      }
      return exitFns
    }
  }
}
#+end_src

通过 ~for (...)~ 将所有 v-if/v-for 相关指令经过他们自己的处理函数(比如：
~processIf~ ) 之后得到最终的 ~onExit~ 收集到 ~exitFns~ 中，在处理过程中随时会出
现节点的删除操作(比如： ~v-else~ 节点会在解析完之后被删除)，在正常的 traverse 过
程中这些节点都不会再存在。

#+begin_quote
PS: 正确理解应该属于移动操作，因为原始的 AST 结构并没改变，只不过是在原有的 AST
数结构中移除到新的 AST 节点下面了。
#+end_quote

** acdea14 v-if transform init

[[https://github.com/gcclll/stb-vue-next/commit/acdea1419d0361a4566a5f2a53ffc8bb1f941878][feat(init): v-if transform · gcclll/stb-vue-next@acdea14]]

#+begin_src typescript
export const transformIf = createStructuralDirectiveTransform(
  /^(if|else|else-if)$/,
  (node, dir, context) => {
    return processIf(node, dir, context, (ifNode, branch, isRoot) => {
      // TODO
      console.log(ifNode, branch, isRoot)
      return () => {}
    })
  }
)

export function processIf(
  node: ElementNode,
  dir: DirectiveNode,
  context: TransformContext,
  processCodegen?: (
    node: IfNode,
    branch: IfBranchNode,
    isRoot: boolean
  ) => (() => void) | undefined
) {}
#+end_src

初始化 v-if process 函数， processIf 函数里面会针对 v-if 节点甚至它的兄弟节点做
一系列操作，比如将下一个是 ~v-else~ 的兄弟节点删除移到自己的 ~branches[]~ 里面。
** 9039a3e v-if transform processIf

[[https://github.com/gcclll/stb-vue-next/commit/9039a3e567260d33c0bc617d4c58639b14b66fec][feat: v-if processIf · gcclll/stb-vue-next@9039a3e]]

这里增加了两个函数的实现：

1. processIf, 解析 if，创建 ~IF,9~ 类型的结构，替换 v-if 原来的 ast

   #+begin_src typescript
    const ifNode: IfNode = {
      type: NodeTypes.IF,
      loc: node.loc,
      branches: [branch]
    }
   #+end_src

   其中 branches 保存着所有 v-else, v-else-if 分支节点，这里其实是创建了一个默认
   的分支节点，因为 ~v-if~ 系列指令在 ~render~ 函数中是以三元运算符(~?:~)形式存
   在的，所以 if 后面必须要有一个分支，即 ~condition ? node1 : node2~ 中的 node2
   必须是个有效的值，才能正常使用 ~?:~ 运算符。

   所以，如果只有 ~v-if~ 指令的时候三元符后面的值起始是个空值(好像是 ~null~)
   
2. createIfBranch, 创建 ~v-if~ 的分支节点的
   
   #+begin_src typescript
function createIfBranch(node: ElementNode, dir: DirectiveNode): IfBranchNode {
  return {
    type: NodeTypes.IF_BRANCH,
    loc: node.loc,
    // condition ? v-if node : v-else node
    condition: dir.name === 'else' ? undefined : dir.exp,
    // 如果用的是 <template v-if="condition" ... 就需要 node.children
    // 因为 template 本身是不该被渲染的
    children:
      node.tagType === ElementTypes.TEMPLATE && !findDir(node, 'for')
        ? node.children
        : [node],
    // 对于 v-for, v-if/... 都应该给它个 key, 这里是用户编写是的提供的唯一 key
    // 如果没有解析器会默认生成一个全局唯一的 key
    userKey: findProp(node, `key`)
  }
}
   #+end_src

    注意看最后一个属性， ~v-if~ 分支也是需要一个 ~key~ 属性的。
** 44985b4 v-if transform createIfBranch

[[https://github.com/gcclll/stb-vue-next/commit/44985b49e031752a7c84464b29adb769050cb1fb][feat: v-if createIfBranch · gcclll/stb-vue-next@44985b4]]

#+begin_src typescript
export function createConditionalExpression(
  test: ConditionalExpression['test'],
  consequent: ConditionalExpression['consequent'],
  alternate: ConditionalExpression['alternate'],
  newline = true
) {
  return {
    type: NodeTypes.JS_CONDITIONAL_EXPRESSION,
    test,
    consequent,
    alternate,
    newline,
    loc: locStub
  }
}
#+end_src

这里的结构(~v-if~)在 render 函数中的对应关系：

~test ? consequent : alternate~

如果有 v-else-if 时候， ~alternate~ 结构会是个完整的 ~JS_CONDITIONAL_EXPRESSION~
，即： ~alternate: { test, consequent, alternate, ...}~ 所以：

~test ? consequent : test1 ? consequent 1 : alternate~

[[https://github.com/gcclll/stb-vue-next/commit/1e24eb7a30588690a4e83f888623b97f0085e899][fix: no v-if transform · gcclll/stb-vue-next@1e24eb7]]

到这里 v-if 指令 transform 阶段已经完成，测试结果：

#+begin_src js
const {
  baseParse,
  baseCompile
} = require(process.env.PWD + '/../../static/js/vue/compiler-core.global.js')
 
const { code, ast } = baseCompile(`<div v-if="ok"/>`)
console.log(`>>> ast.codegenNode 结果`)
console.log(ast.codegenNode)
#+end_src

#+RESULTS:
#+begin_example
>>> ast.codegenNode 结果
{
  type: 9,
  loc: {
    start: { column: 1, line: 1, offset: 0 },
    end: { column: 17, line: 1, offset: 16 },
    source: '<div v-if="ok"/>'
  },
  branches: [
    {
      type: 10,
      loc: [Object],
      condition: [Object],
      children: [Array],
      userKey: undefined
    }
  ],
  codegenNode: {
    type: 19,
    test: {
      type: 4,
      content: 'ok',
      isStatic: false,
      isConstant: false,
      loc: [Object]
    },
    consequent: {
      type: 13,
      tag: '"div"',
      props: [Object],
      children: undefined,
      patchFlag: undefined,
      dynamicProps: undefined,
      directives: undefined,
      isBlock: true,
      disableTracking: false,
      loc: [Object]
    },
    alternate: {
      type: 14,
      loc: [Object],
      callee: Symbol(createCommentVNode),
      arguments: [Array]
    },
    newline: true,
    loc: { source: '', start: [Object], end: [Object] }
  }
}
undefined
#+end_example

+RESULTS: 错误结果
#+begin_example
const _Vue = Vue

return function render(_ctx, _cache) {
  with (_ctx) {
    const { createVNode : _createVNode, openBlock : _openBlock, createBlock : _createBlock, createCommentVNode : _createCommentVNode } = _Vue

    return (_openBlock(), _createBlock("div", { key: 0 }))
  }
}
>>> ast.codegenNode 结果
{
  type: 13,
  tag: '"div"',
  props: {
    type: 15,
    loc: { source: '', start: [Object], end: [Object] },
    properties: [ [Object] ]
  },
  children: undefined,
  patchFlag: undefined,
  dynamicProps: undefined,
  directives: undefined,
  isBlock: true,
  disableTracking: false,
  loc: {
    start: { column: 1, line: 1, offset: 0 },
    end: { column: 17, line: 1, offset: 16 },
    source: '<div v-if="ok"/>'
  }
}
undefined
#+end_example

结果显示是不对的，因为创建的 ~IF~ 结构没有替换 ast 🌲中原来的节点，追踪后发现是
漏掉了 ~context.replaceNode(node)~ 的实现。

[[https://github.com/gcclll/stb-vue-next/commit/47c30d296b2f42759aea8de4730ae1802dbb6e32][fix: v-if codegenNode is incorrect · gcclll/stb-vue-next@47c30d2]]

traverseNode 中需要增加 ~case 9,IF~ 分支处理，遍历所有的 ~branches[]~ 。

[[https://github.com/gcclll/stb-vue-next/commit/179f06f716687166b167f5d190073bfe65a9393f][fix: v-if branches no codegenNode · gcclll/stb-vue-next@179f06f]]
** 742757e v-if generator

[[https://github.com/gcclll/stb-vue-next/commit/742757ebe2c4d1faaadf32b6606d43cef2900934?branch=742757ebe2c4d1faaadf32b6606d43cef2900934&diff=split][feat: v-if generator · gcclll/stb-vue-next@742757e]]

genNode 增加 ~JS_CONDITIONAL_EXPRESSION~ 分支处理(~genConditionalExpression~)

#+begin_src typescript
function genConditionalExpression(
  node: ConditionalExpression,
  context: CodegenContext
) {
  const { test, consequent, alternate, newline: needNewline } = node
  const { push, indent, deindent, newline } = context
  if (test.type === NodeTypes.SIMPLE_EXPRESSION) {
    // 非简单的标识符需要用括号，可能是表达式，所以需要 (a + b) ? ... : ...
    const needsParams = !isSimpleIdentifier(test.content)
    needsParams && push(`(`)
    genExpression(test, context)
    needsParams && push(`)`)
  } else {
    push(`(`)
    genNode(test, context)
    push(`)`)
  }

  needNewline && indent()
  context.indentLevel++
  needNewline || push(` `)
  push(`? `)
  genNode(consequent, context)
  context.indentLevel--
  needNewline && newline()
  needNewline || push(` `)
  push(`: `)
  const isNested = alternate.type === NodeTypes.JS_CONDITIONAL_EXPRESSION
  if (!isNested) {
    // 不是嵌套
    context.indentLevel++
  }
  genNode(alternate, context)
  if (!isNested) {
    context.indentLevel--
  }

  needNewline && deindent(true /* without newline */)
}
#+end_src

~genConditionalExpression~ 处理分为三个部分

1. ~test~ 生成条件表达式，这里是: ~ok~ ，如果是表达式需要括号： ~(a + b)~
2. ~consequent~ 用来生成 ~?~ 后面的表达式，即 ~ok~ 结果为 truth 时执行
3. ~alternate~ 用来生成 ~:~ 后面的表达式，即 ~ok~ 结果为 falsy 时执行

   ~alternate~ 中的结构可能也是个 ~JS_CONDITIONAL_EXPRESSION~ 结构，代表可能有
   ~v-else-if~ 分支，如： ~(a + b) ? node1 : (c + d) ? node2 : othernode~ 。


测试：
#+begin_src js

const {
  baseParse,
  baseCompile
} = require(process.env.PWD + '/../../static/js/vue/compiler-core.global.js')
 
const c = ( tpl, desc ) => {
  console.log(`>>> ` + desc)
  const { code } = baseCompile(tpl, { hoistStatic: true })
  console.log(code)
}

c(`<div v-if="ok"/>`, 'basic v-if')
c(`<template v-if="ok"><div/>hello<p/></template>`, 'template v-if')
#+end_src

#+RESULTS:
#+begin_example
>>> basic v-if
const _Vue = Vue
const { createVNode: _createVNode, createCommentVNode: _createCommentVNode } = _Vue

const _hoisted_1 = { key: 0 }

return function render(_ctx, _cache) {
  with (_ctx) {
    const { createVNode : _createVNode, openBlock : _openBlock, createBlock : _createBlock, createCommentVNode : _createCommentVNode } = _Vue

    return ok
      ? (_openBlock(), _createBlock("div", _hoisted_1))
      : _createCommentVNode("v-if", true)
  }
}
>>> template v-if
const _Vue = Vue
const { createVNode: _createVNode, createCommentVNode: _createCommentVNode, createTextVNode: _createTextVNode } = _Vue

const _hoisted_1 = /*#__PURE__*/_createVNode("div", null, null, -1 /* HOISTED */)
const _hoisted_2 = /*#__PURE__*/_createTextVNode("hello")
const _hoisted_3 = /*#__PURE__*/_createVNode("p", null, null, -1 /* HOISTED */)

return function render(_ctx, _cache) {
  with (_ctx) {
    const { createVNode : _createVNode, createTextVNode : _createTextVNode, Fragment : _Fragment, openBlock : _openBlock, createBlock : _createBlock, createCommentVNode : _createCommentVNode } = _Vue

    return ok
      ? (_openBlock(), _createBlock(_Fragment, { key: 0 }, [
          _hoisted_1,
          _hoisted_2,
          _hoisted_3
        ], 64 /* STABLE_FRAGMENT */))
      : _createCommentVNode("v-if", true)
  }
}
undefined
#+end_example

BUG: 这里居然少了个 ~_hoisted_2~ ???

#+begin_src js
[
  _hoisted_1,
  ,
  _hoisted_3
]
#+end_src

答： ~genNode()~ 中缺少对 ~4,TEXT_CALL~ 纯文本类型处理。

解：[[https://github.com/gcclll/stb-vue-next/commit/2372b5fb793da98a8330aa843137e852d5c375c1][fix: v-if TEXT_CALL gen node · gcclll/stb-vue-next@2372b5f]]

#+begin_comment
更多测试用例(~<f12>~)打开控制台查看 ->> 。
#+end_comment

#+begin_export html
<script>
l1(`v-if 指令`)
compile(`<div v-if="ok"/>`, 'basic v-if')
compile(`<template v-if="ok"><div/>hello<p/></template>`, 'template v-if')
compile(`<Component v-if="ok"></Component>`, 'component v-if')
</script>
#+end_export
** fa77b51 v-else/v-else-if

[[https://github.com/gcclll/stb-vue-next/commit/fa77b5146f3a3af6c8372012cb6a4d8482adb0c6][feat(add): v-else · gcclll/stb-vue-next@fa77b51]]

修改点：

1. ~processCodegen()~ 函数里面增加分支处理

  [[http://qiniu.ii6g.com/img/20201209164845.png]] 
    这里有一个需要注意的点: ~getParentCondition()~ 会一直查找
   ~JS_CONDITIONAL_EXPRESSION~ 类型节点的 ~alternate~ ，如果它依旧是个
   ~JS_CONDITIONAL_EXPRESSION~ 类型，说明是多级的 ~if/else~ 条件语句，直到找到最
   后一个不是为止。

   相当于 ： ~c1 ? cons1 : c2 ? cons2 : c3 ? cons3 : alt~ 会一直从 ~c1~ 节点开始
   查找直到找到最后的那个 ~alt~ 节点为止，然后将新的分支挂到 ~alt~ 后面组织成新
   的分支:  ~c1 ? cons1 : c2 ? cons2 : c3 ? cons3 : c4 ? cons4 : newalt~

   #+begin_comment
    PS: c1, c2, c3, c4 分别代表分支节点的 ~test~ ，最后追加的 ~c4 ? cons4 :
    newalt~ 三个对象都属于新加的节点， ~{test -> c4, cons4 -> consequent,
    alternate -> newalt }~
   #+end_comment

2. ~processIf()~ 里增加分支处理

   新增代码里有个 ~while~ 循环去从当前的分支节点开始在它的兄弟节点里面往回找，直
   到找到第一个 ~9,IF~ 节点，这中间不允许出现其他有效节点(除注释，空文本节点外)，
   因为 ~v-if/else~ 指令节点必须紧靠着。

   找到之后，要将当前分支节点删除，并且同时要去手动 ~traverseNode(branch)~ 一次，
   因为他在原来的 ast 树种删除了，所以原来的 traverse 进程不会遍历它，因此需要手
   动执行 traverse 去处理它及其孩子节点生成对应的 codegenNode 。

   然后将其 push 到 ~9,IF~ 节点的 ~node.branches~ 里面作为分支。

3. ~isSameKey(a,b)~ 新增，检测两个 key 属性是不是相同

   几种判定为不相同的条件：
   1) key 类型不同 (~a.type !== b.type~)

   2) key 值不同 (~a.value.content !== b.value.content~)

   3) key 如果是指令类型，检测表达式类型，静态属性异同(~isStatic~)

4. ~getParentCondition()~ 新增，递归 ~9，IF~ 节点的
   ~node.alternate.alternate.alternate...~ 直到找到 ~alternate~ 不是
   ~JS_CONDITIONAL_EXPRESSION~ 的情况
      

FIX: [[https://github.com/gcclll/stb-vue-next/commit/464d6815adf49596065440001e0bc5397ad2aa69][fix: v-else current node dont removed · gcclll/stb-vue-next@464d681]]

测试：
#+begin_src js

const {
  baseParse,
  baseCompile
} = require(process.env.PWD + '/../../static/js/vue/compiler-core.global.js')
 
const { code } = baseCompile(`<div v-if="ok"/><p v-else/>`)
console.log(code)
#+end_src

#+RESULTS:
#+begin_example
const _Vue = Vue

return function render(_ctx, _cache) {
  with (_ctx) {
    const { createVNode : _createVNode, openBlock : _openBlock, createBlock : _createBlock, createCommentVNode : _createCommentVNode } = _Vue

    return ok
      ? (_openBlock(), _createBlock("div", { key: 0 }))
      : (_openBlock(), _createBlock("p", { key: 1 }))
  }
}
undefined
#+end_example

#+begin_comment
更多测试(~<f12>~)打开控制台查看 ->> 。
#+end_comment

#+begin_export html
<script>
compile(`<div v-if="ok"/><p v-else/>`, 'v-if + v-else')
compile(`<template v-if="ok"><div/>hello<p/></template>`, 'template v-if')
compile(`<div v-if="ok"/><p v-else-if="orNot"/>`, 'v-if + v-else-if')
compile(`<div v-if="ok"/><p v-else-if="orNot"/><template v-else>fine</template>`, 'v-if + v-else-if + v-else')
compile(`
        <div v-if="ok"/>
        <!--foo-->
        <p v-else-if="orNot"/>
        <!--bar-->
        <template v-else>fine</template>
      `, 'comment between branches')

l1(`with prefixIdentifiers ... TODO`)
l1(`errors`)
compile(`<div v-else/>`, `<div v-else/> 没有匹配的 v-if`)
compile(`<div v-else-if="foo"/>`, `<div v-else-if="foo"/>, 没有匹配的 v-if`)
compile(`<div v-if="ok" :key="a + 1" /><div v-else :key="a + 1" />`,
`<div v-if="ok" :key="a + 1" /><div v-else :key="a + 1" />, 相同的 key`
)
log.red(`不允许不同分支使用相似的 key，因为 key 是指令属性，因此会对比它的类型及表达式`)
l1(`v-on with v-if`)
compile(`<button v-on="{ click: clickEvent }" v-if="true">w/ v-if</button>`, 'v-if 上使用 v-on 指令')
log.blue(`因为这里用的是无参数的 v-on 所以会导致所有属性被合并(_mergeProps(...))。`)
</script>

#+end_export

BUG: v-else-if 被解析成了 ~else~ 因为 parser 阶段匹配正则不对。
[[https://github.com/gcclll/stb-vue-next/commit/5b83d1c12a8580638d7952e712f7c6776a099a50][fix: parser v-else-if failed · gcclll/stb-vue-next@5b83d1c]]
* 6c82066 add v-for transform

[[https://github.com/gcclll/stb-vue-next/commit/3a1662ecde9600525088a48420e526b6f9820931][feat(init): v-for · gcclll/stb-vue-next@3a1662e]]

[[https://github.com/gcclll/stb-vue-next/commit/6c8206676c5d5229c853fb21cb91aad1a9f1d4a2][feat: v-for directive · gcclll/stb-vue-next@6c82066]]

v-for 指令实现过程中需要用到的几个函数：

- ~transformFor()~ 最终生成的 tranformXxx 函数
- ~createStructuralDirectiveTransform()~ 同 ~v-if~ 指令
- ~processFor()~ 处理 ~v-for~ 指令入口
- ~processCodegen()~ 同 ~v-if~ 用来生成 ~codegenNode~ 的函数
- ~parseForExpression()~ 将 ~v-for="item in items"~ 表达式解析成
  ~ForParseResult{source, value, key, index}~ 类型 AST 。
- ~createAliasExpression()~ 给 ~value, key, index~ 创建 ~SIMPLE_EXPRESSION~ 类型
  结构。
- ~createForLoopParams()~ 创建 ~_renderList~ 函数回调的参数 ~[value, key,
  index]~ ，如果没有使用默认变量： ~_~ 或 ~__~ ，如： ~(_, __, index)~


其中 ~parseForExpression()~ 函数是解析 ~v-for~ 表达式的核心函数，里面使用了三个
正则，用来匹配指令表达式：

1. ~const forAliasRE = /([\s\S]*?)\s+(?:in|of)\s+([\s\S]*)/~

   [[http://qiniu.ii6g.com/img/20201210155617.png]]

   匹配 ~v-for="item in items"~ 中的值部分

   #+begin_src js
   const re = /([\s\S]*?)\s+(?:in|of)\s+([\s\S]*)/
   const log = (params) => console.log(params.map((p, i) => `${i}, ${p}`).join(`\n`))
   log.title = console.log

   log.title(`>>> 匹配 item in items`)
   log("item in items".match(re))
   log.title(`>>> 匹配 (item, key) in items`)
   log("( item, key ) in items".match(re))
   #+end_src

   #+RESULTS:
   : >>> 匹配 item in items
   : 0, item in items
   : 1, item
   : 2, items
   : >>> 匹配 (item, key) in items
   : 0, ( item, key ) in items
   : 1, ( item, key )
   : 2, items
   : undefined

2. ~const forIteratorRE = /,([^,\}\]]*)(?:,([^,\}\]]*))?$/~

   [[http://qiniu.ii6g.com/img/20201210161642.png]]

   这个正则表达式用来匹配 ~(item, key) in items~ 中的 ~item~ 和 ~key~

   #+begin_src js
   const re = /,([^,\}\]]*)(?:,([^,\}\]]*))?$/ 
   const log = (params) => console.log(params.map((p, i) => `${i}, ${p}`).join(`\n`))
   log.title = console.log

   log.title(`>>> 匹配 'item, key, index' 中的 key 和 index`)
   log("item, key, index".match(re))
   log.title(`>>> 匹配 "item, key" 中的 key`)
   log("item, key".match(re))
   #+end_src

   #+RESULTS:
   : >>> 匹配 'item, key, index' 中的 key 和 index
   : 0, , key, index
   : 1,  key
   : 2,  index
   : >>> 匹配 "item, key" 中的 key
   : 0, , key
   : 1,  key
   : 2, undefined
   : undefined

3. ~const stripParensRE = /^\(|\)$/g~ 这个用来匹配 ~(item, key, index)~ 前后括号


~parseForExpression()~ 核心实现：

1. ~source~ 数据源， ~forAliasRE~ 匹配后的 ~RHS~ 值
   
   #+begin_src json
   source: {
    type: 4, // SIMPLE_EXPRESSION
    loc: { source: 'obj', start: [Object], end: [Object] },
    isConstant: false,
    content: 'obj',
    isStatic: false
   }
   #+end_src
2. ~value~ 的取值，在 AST 中对应 ~valueAlias~

   ~valueContent = valueContent.replace(forIteratorRE,
   '').trim()~

   通过匹配 ~key, index~ 的正则，反向替换得到 ~value~
    #+begin_src js
    const re = /,([^,\}\]]*)(?:,([^,\}\]]*))?$/
    console.log(`item, key, index`.replace(re, '').trim())
    console.log(`>>> 支持解构`)
    console.log(`[ id, value ], key, index`.replace(re, '').trim())
    #+end_src

    #+RESULTS:
    : item
    : >>> 支持解构
    : [ id, value ]
    : undefined

    解析后的结构：
    #+begin_src json
    valueAlias: {
        type: 4, // SIMPLE_EXPRESSION
        loc: { source: 'value', start: [Object], end: [Object] },
        isConstant: false,
        content: 'value',
        isStatic: false
    }
    #+end_src
3. ~key~ 取值处理，在 AST 中对应 ~keyAlias~

   #+begin_src js
    keyAlias: {
        type: 4,
        loc: { source: 'key', start: [Object], end: [Object] },
        isConstant: false,
        content: 'key',
        isStatic: false
    }
   #+end_src
4. ~index~ 取值处理，在 AST中对应 ~objectIndexAlias~

   #+begin_src js
    objectIndexAlias: {
        type: 4,
        loc: { source: 'index', start: [Object], end: [Object] },
        isConstant: false,
        content: 'index',
        isStatic: false
    }
   #+end_src


测试：
#+begin_src js
const {
  baseParse,
  baseCompile
} = require(process.env.PWD + '/../../static/js/vue/compiler-core.global.js')
 
const { ast } = baseCompile(`<span v-for="(value, key, index) in obj" />`)
const { source, valueAlias, keyAlias, objectIndexAlias, type } = ast.codegenNode
console.log(`type: ${type}`)
console.log(`>>> 数据源`)
console.log(source)
console.log(`>>> value`)
console.log(valueAlias)
console.log(`>>> key`)
console.log(keyAlias)
console.log(`>>> index`)
console.log(objectIndexAlias)
console.log(`>>> _renderList(obj, (value, key, index) => {...}) 第二个参数`)
console.log(ast.codegenNode.codegenNode.children.arguments[1])
#+end_src

#+RESULTS:
#+begin_example
type: 11
>>> 数据源
{
  type: 4,
  loc: {
    source: 'obj',
    start: { column: 37, line: 1, offset: 36 },
    end: { column: 40, line: 1, offset: 39 }
  },
  isConstant: false,
  content: 'obj',
  isStatic: false
}
>>> value
{
  type: 4,
  loc: {
    source: 'value',
    start: { column: 15, line: 1, offset: 14 },
    end: { column: 20, line: 1, offset: 19 }
  },
  isConstant: false,
  content: 'value',
  isStatic: false
}
>>> key
{
  type: 4,
  loc: {
    source: 'key',
    start: { column: 22, line: 1, offset: 21 },
    end: { column: 25, line: 1, offset: 24 }
  },
  isConstant: false,
  content: 'key',
  isStatic: false
}
>>> index
{
  type: 4,
  loc: {
    source: 'index',
    start: { column: 27, line: 1, offset: 26 },
    end: { column: 32, line: 1, offset: 31 }
  },
  isConstant: false,
  content: 'index',
  isStatic: false
}
>>> _renderList(obj, (value, key, index) => {...}) 第二个参数
{
  type: 18, // JS_FUNCTION_EXPRESSION
  params: [
    {
      type: 4,
      loc: [Object],
      isConstant: false,
      content: 'value',
      isStatic: false
    },
    {
      type: 4,
      loc: [Object],
      isConstant: false,
      content: 'key',
      isStatic: false
    },
    {
      type: 4,
      loc: [Object],
      isConstant: false,
      content: 'index',
      isStatic: false
    }
  ],
  returns: {
    type: 13,
    tag: '"span"',
    props: undefined,
    children: undefined,
    patchFlag: undefined,
    dynamicProps: undefined,
    directives: undefined,
    isBlock: true,
    disableTracking: false,
    loc: {
      start: [Object],
      end: [Object],
      source: '<span v-for="(value, key, index) in obj" />'
    }
  },
  newline: true,
  isSlot: false,
  loc: {
    source: '',
    start: { line: 1, column: 1, offset: 0 },
    end: { line: 1, column: 1, offset: 0 }
  }
}
undefined
#+end_example
* 39a20fe add v-for generator

[[https://github.com/gcclll/stb-vue-next/commit/39a20fef0001cf22de6632f96df474c87a127a9d][feat(add): v-for generator · gcclll/stb-vue-next@39a20fe]]

codegen 阶段新增对应的实现： ~18,JS_FUNCTION_EXPRESSION~

这个主要是用来解析 ~_renderList(source, (value, key, index) => { ... })~ 函数的
第二个参数的，这是个用来 render 列表项的函数。

测试：

#+begin_src js
const {
  baseParse,
  baseCompile
} = require(process.env.PWD + '/../../static/js/vue/compiler-core.global.js')

const { code } = baseCompile('<span v-for="(item) in items" />')
console.log(code)
#+end_src

#+RESULTS:
#+begin_example
const _Vue = Vue

return function render(_ctx, _cache) {
  with (_ctx) {
    const { renderList : _renderList, Fragment : _Fragment, openBlock : _openBlock, createBlock : _createBlock, createVNode : _createVNode } = _Vue

    return (_openBlock(true), _createBlock(_Fragment, null, _renderList(items, (item) => {
      return (_openBlock(), _createBlock("span"))
    )), 256 /* UNKEYED_FRAGMENT */))
  }
}
undefined
#+end_example

#+begin_quote
更多测试用例请 ~<f12>~ 打开控制台查看。
#+end_quote

#+begin_export html
<script>
l1(`v-for directive`)
compile(`<span v-for="(item) in items" />`, `basic v-for`)
compile('<span v-for="(item, key, index) in items" />', 'value + key + index')
compile('<span v-for="(, key, index) in items" />', `skipped value`)
compile('<span v-for="(item,,index) in items" />', `skipped key`)
compile('<span v-for="(,,index) in items" />', `skipped value & key`)
compile('<p v-for="item in 10">{{item}}</p>', `v-for with constant expression`)
compile(`<template v-for="item in items">hello<span/></template>`, `template v-for`)
compile('<template v-for="item in items"><slot/></template>', `template v-for w/ <slot/>`)
log.red(`TODO <slot> 待完成......`)
compile('<template v-for="item in items" :key="item.id"><span :id="item.id" /></template>', `template v-for key injection with single child`)
compile('<slot v-for="item in items"></slot>', `v-for on <slot/>`)
log.red(`TODO <slot> 待完成......`)
compile('<span v-for="(item) in items" :key="item" />', `keyed v-for`)
compile('<template v-for="item in items" :key="item">hello<span/></template>', `keyed template v-for`)
compile(`<div v-if="ok" v-for="i in list"/>`, `v-if + v-for`)
compile(`<template v-if="ok" v-for="i in list"/>`, 'v-if + v-for on <template>')
compile('<div v-for="i in list" v-foo/>', `v-for on element with custom directive`)

</script>

#+end_export
* 7cb8908 add slot outlet transform

[[https://github.com/gcclll/stb-vue-next/commit/7cb8908700da1bf0c3888a2fcd6857263d09aedd][feat(add): v-slot transform · gcclll/stb-vue-next@7cb8908]]

transform ~<slot />~ 标签。

~<slot/>~ 在 render 函数中是以 ~_renderSlot($slot, name, props, children)~ 形式存在。

#+begin_comment
<slot> 上不允许自定义的指令存在？
#+end_comment


相关函数/参数：

1. ~transformSlotOutlet()~ 该阶段的 ~tranformXxx~ 函数
2. ~SlotOutletProcessResult~ 类型定义 ~{slotName, slotProps}~
3. ~processSlotOutlet()~, ~<slot/>~ 的处理过程

   首先是解析插槽名称(~name~ 属性)，该属性可以是动态(~<slot :name="myslot"/>~)也
   可以是静态的(~<slot name="myslot"/>~)。

   然后解析出插槽上定义的一些属性(静态)，除了 ~:name~ 之外插槽上 *不允许有其他的
   指令类型的属性存在* 。
4. ~children~ 参数

   ~<slot><div/><p/></slot>~

   在 ~<slot>~ 标签内的所有元素(~<div/><p/>~)会被解析成 ~_renderSlot~ 的第四个参数。

测试：
#+begin_src js
const {
  baseParse,
  baseCompile
} = require(process.env.PWD + '/../../static/js/vue/compiler-core.global.js')
 
const { ast } = baseCompile(`<slot/>`)
console.log(ast.codegenNode)
#+end_src

#+RESULTS:
#+begin_example
{
  type: 1,
  ns: 0,
  tag: 'slot',
  tagType: 2,
  props: [],
  isSelfClosing: true,
  children: [],
  loc: {
    start: { column: 1, line: 1, offset: 0 },
    end: { column: 8, line: 1, offset: 7 },
    source: '<slot/>'
  },
  codegenNode: {
    type: 14, // JS_CALL_EXPRESSION
    loc: { start: [Object], end: [Object], source: '<slot/>' },
    callee: Symbol(renderSlot),
    arguments: [ '$slots', '"default"' ]
  }
}
undefined
#+end_example

#+begin_quote
更多 codegenNode 结果请 ~<f12>~ 打开控制台查看。
#+end_quote

#+begin_export html
<script>
l1(`<slot/> 插槽 transform 阶段`)

const _a = ast => [`_renderSlot 参数列表：` , ast.children[0].codegenNode.arguments ]
const c = (tpl, desc, ast = _a) => compile.call(null, tpl, desc, ast)
c(`<slot/>`, `default slot outlet`)
c(`<slot name="foo" />`, `statically named slot outlet，含静态名字`)
c(`<slot :name="foo" />`, `dynamically named slot outlet, 含动态名字`)
c(null, `TODO dynamically named slot outlet w/ prefixIdentifiers: true`)
c(`<slot foo="bar" :baz="qux" />`, `default slot outlet with props，默认插槽+静动态属性`)
c(`<slot name="foo" foo="bar" :baz="qux" />`, `statically named slot outlet with props，静态具名插槽+其他静动态属性`)
c(`<slot :name="foo" foo="bar" :baz="qux" />`, `dynamically named slot outlet with props，动态具名插槽+其他静动态属性`)
c(`<slot><div/></slot>`, `default slot outlet with fallback`)
c(`<slot name="foo"><div/></slot>`, `named slot outlet with fallback`)
c(`<slot :foo="bar"><div/></slot>`, `default slot outlet with props & fallback`)
c(`<slot name="foo" :foo="bar"><div/></slot>`, `named slot outlet with props & fallback`)
c(`<slot v-foo />`, `error on unexpected custom directive on <slot>，不允许有自定义指令？`)
</script>
#+end_export

** ebdb1ed add track slot scopes

[[https://github.com/gcclll/stb-vue-next/commit/ebdb1edbfd23312d5fb079a3955917745cac2622][feat: add track slot scopes · gcclll/stb-vue-next@ebdb1ed]]

还不知道干吗的❓ 

#+begin_src typescript
// A NodeTransform that:
// 1. Tracks scope identifiers for scoped slots so that they don't get prefixed
//    by transformExpression. This is only applied in non-browser builds with
//    { prefixIdentifiers: true }.
// 2. Track v-slot depths so that we know a slot is inside another slot.
//    Note the exit callback is executed before buildSlots() on the same node,
//    so only nested slots see positive numbers.
export const trackSlotScopes: NodeTransform = (node, context) => {
  // <component> or <template>
  if (
    node.type === NodeTypes.ELEMENT &&
    (node.tagType === ElementTypes.COMPONENT ||
      node.tagType === ElementTypes.TEMPLATE)
  ) {
    // We are only checking non-empty v-slot here
    // since we only care about slots that introduce scope variables.
    const vSlot = findDir(node, 'slot')
    if (vSlot) {
      const slotProps = vSlot.exp
      if (!__BROWSER__ && context.prefixIdentifiers) {
        slotProps && context.addIdentifiers(slotProps)
      }

      context.scopes.vSlot++
      return () => {
        if (!__BROWSER__ && context.prefixIdentifiers) {
          slotProps && context.removeIdentifiers(slotProps)
        }
        context.scopes.vSlot--
      }
    }
  }
}
#+end_src
* 36c1f36 build user component as slots(组件是如何当做 slot 处理的)

[[https://github.com/gcclll/stb-vue-next/commit/36c1f36ea2a92119d2a61f3012972229e85b1e30][feat(add): user component treat as slot to build · gcclll/stb-vue-next@36c1f36]]

完整用户组件当 slot 处理流程图：
[[/img/vue3/compiler-core/pcg/pcg-v-slot.svg]]

~<Comp><div/></Comp>~

这里 ~Comp~ 是组件类型(~tagType=1,COMPONENT~) 会在 ~transformElement~ 中被当做
~slot~ 来处理调用 ~buildSlots()~ 。

#+begin_comment
更多测试用例(~<f12>~)打开控制台查看 ->> 。
#+end_comment

#+begin_export html
<script>
l1(`<slot /> 插槽 generator 阶段`)
compile(`<Comp><div/></Comp>`, 'implicit default slot')
compile(`<Comp v-slot="{ foo }">{{ foo }}{{ bar }}</Comp>`, 'on-component default slot')
compile(`<Comp v-slot:named="{ foo }">{{ foo }}{{ bar }}</Comp>`, 'on component named slot')
compile(`<Comp>
        <template v-slot:one="{ foo }">
          {{ foo }}{{ bar }}
        </template>
        <template #two="{ bar }">
          {{ foo }}{{ bar }}
        </template>
      </Comp>`, 'template named slots')
compile(`<Comp v-slot:[named]="{ foo }">{{ foo }}{{ bar }}</Comp>`, 'on component dynamically named slot')
compile(`<Comp>
        <template #one>foo</template>bar<span/>
      </Comp>`, 'named slots w/ implicit default slot')
compile(`<Comp>
        <template v-slot:[one]="{ foo }">
          {{ foo }}{{ bar }}
        </template>
        <template #[two]="{ bar }">
          {{ foo }}{{ bar }}
        </template>
      </Comp>`, 'dynamically named slots')
compile(`<Comp>
        <template #default="{ foo }">
          <Inner v-slot="{ bar }">
            {{ foo }}{{ bar }}{{ baz }}
          </Inner>
          {{ foo }}{{ bar }}{{ baz }}
        </template>
      </Comp>`, 'nested slots scoping')

compile(`<div v-for="i in list">
        <Comp v-slot="bar">foo</Comp>
      </div>`, 'should force dynamic when inside v-for')
l2(` TODO should only force dynamic slots when actually using scope vars w/ prefixIdentifiers: true`)
compile(`<Comp>
        <template #one v-if="ok">hello</template>
      </Comp>`, 'named slot with v-if')
l2(` TODO named slot with v-if + prefixIdentifiers: true`)
compile(`<Comp>
        <template #one v-if="ok">foo</template>
        <template #two="props" v-else-if="orNot">bar</template>
        <template #one v-else>baz</template>
      </Comp>`, 'named slot with v-if + v-else-if + v-else')
l2(` TODO 'named slot with v-for w/ prefixIdentifiers: true'`)
compile(`<Comp>
        <template v-for="name in list" #[name]>{{ name }}</template>
      </Comp>`, 'named slot with v-for')
compile(`<Comp><template v-slot:named="slotProps"><div/></template><div :id="defaultSlotId"/></Comp>`, '具名插槽+其他非 template 元素全当做默认插槽处理')
</script>
#+end_export

** fbed5cf add component with default slot without <template> transform

[[https://github.com/gcclll/stb-vue-next/commit/fbed5cf508e91ea20195af4dafa491957a4d1d60][feat(add): default slot without template · gcclll/stb-vue-next@fbed5cf]]

~<Comp><div/></Comp>~

这种情况，用户组件上既没有 ~v-slot~ 孩子节点里面也没有 ~<template v-slot>~ 最后
的处理是 ~<Comp></Comp>~ 里面的所有 children 被当做默认插槽处理。

该示例符合：
1. 组件上没有 ~v-slot~ 指令
2. 孩子节点里面没有 ~<template v-slot:name="slotProps">~

因此，这里的处理是将 ~<div/>~ 即 ~comp.children~ 全部作为默认的 ~slot:default~
来处理。

处理流程： ~<Comp>~ -> ~transformElement~ -> ~isComponent~ -> ~buildSlots()~ ->
~{slots, hasDynamicSlots}~ -> ~vnodeChildren~ -> ~{type: 13,VNODE_CALL,
children: vnodeChildren, ... }~

#+begin_src js
const {
  baseParse,
  baseCompile
} = require(process.env.PWD + '/../../static/js/vue/compiler-core.global.js')

const { ast } = baseCompile(`<Comp><div/></Comp>`)
console.log(ast.codegenNode)
#+end_src

#+RESULTS:
#+begin_example
{
  type: 13,
  tag: '_component_Comp',
  props: undefined,
  children: {
    type: 15,
    loc: { start: [Object], end: [Object], source: '<Comp><div/></Comp>' },
    properties: [ [Object], [Object] ]
  },
  patchFlag: undefined,
  dynamicProps: undefined,
  directives: undefined,
  isBlock: true,
  disableTracking: false,
  loc: {
    start: { column: 1, line: 1, offset: 0 },
    end: { column: 20, line: 1, offset: 19 },
    source: '<Comp><div/></Comp>'
  }
}
undefined
#+end_example

另外在 ~transformElement()~ 函数中通过 ~isComponent = node.tagType ===
ElementTypes.COMPONENT~ 检测是不是用户组件，如果是继续解析该组件类型(~resolveComponentType()~)。

这里最终得到的结果是： ~vnodeTag = _component_Comp~ 作为标签名，也是该 ~<Comp/>~
组件在 Vue 实例过程中的存在的标签名(组件名称)。

** 8bed175 add component with default slot without <template> generator

[[https://github.com/gcclll/stb-vue-next/commit/8bed17574988042023be8ac420254918232ef7c4][feat(add): user component resolver generator · gcclll/stb-vue-next@8bed175]]

因为在 transform 阶段 transformElement 过程中，检测到 ~<Comp>~ 是个用户组件，所
以将其增加到了 ~context.components.add('Comp')~ 中了，在 generator 阶段会去检测
这个 ~components~ 用来解析组件得到组件的引用：

~_component_Comp = _resolveComponent("Comp")~

新增的代码主要由两部分：

1. 新增 ~genAssets()~ 函数处理 ~context.components~

   处理之后的结果就是增加 ~_component_Comp = _resolveComponent("Comp")~

2. 在 ~generate()~ 中增加 ~ast.components~ 检测，如果有内容调用 ~genAssets()~ 解
   析


#+begin_src typescript
// generate() 中增加
 if (ast.components.length) {
    genAssets(ast.components, 'component', context)
    if (ast.directives.length || ast.temps > 0) {
      newline()
    }
  }

// 新增
function genAssets(
  assets: string[],
  type: 'component' | 'directive',
  { helper, push, newline }: CodegenContext
) {
  const resolver = helper(
    type === 'component' ? RESOLVE_COMPONENT : RESOLVE_DIRECTIVE
  )

  for (let i = 0; i < assets.length; i++) {
    const id = assets[i]
    push(
      `const ${toValidAssetId(id, type)} = ${resolver}(${JSON.stringify(id)})`
    )
    if (i < assets.length - 1) {
      newline()
    }
  }
}
#+end_src

测试：
#+begin_src js

const {
  baseParse,
  baseCompile
} = require(process.env.PWD + '/../../static/js/vue/compiler-core.global.js')

const { code } = baseCompile(`<Comp><div/></Comp>`, { hoistStatic: true })
console.log(code)
#+end_src

#+RESULTS:
#+begin_example
const _Vue = Vue
const { createVNode: _createVNode } = _Vue

const _hoisted_1 = /*#__PURE__*/_createVNode("div", null, null, -1 /* HOISTED */)

return function render(_ctx, _cache) {
  with (_ctx) {
    const { createVNode : _createVNode, resolveComponent : _resolveComponent, withCtx : _withCtx, openBlock : _openBlock, createBlock : _createBlock } = _Vue

    const _component_Comp = _resolveComponent("Comp")

    return (_openBlock(), _createBlock(_component_Comp, null, {
      default: _withCtx(() => [
        _hoisted_1
      ]),
      _: 1
    }))
  }
}
undefined
#+end_example

缺少 ~1 /* STABLE */~ 注释: [[https://github.com/gcclll/stb-vue-next/commit/08a6fcaab9224552dbd7876930d964e6bcc534d9][fix: slot flag text · gcclll/stb-vue-next@08a6fca]]

注意 ~_createBlock()~ 的第三个参数变成了一个对象(~children~) 对象里面包含了两个
属性: ~default~ 和 ~_~ 分别代表了默认插槽下的孩子节点，和该插槽标识(~1-STABLE,2-FORWARDED,3-DYNAMIC~)
** 9f58154 fix: 文本节点没有合并(~transformText~)

[[https://github.com/gcclll/stb-vue-next/commit/9f58154809447e6b718e1579149165fc848e8185][fix: adjacent text node need merge · gcclll/stb-vue-next@9f58154]]

对于 ~`<Comp v-slot="{ foo }">{{ foo }}{{ bar }}</Comp>`~ 用例得到的结果非预期。

vue-next 正确结果：
#+begin_src js
const {
  baseCompile
} = require(process.env.PWD + '/../../static/vue/vue.js')
 
const { ast } = baseCompile(`<Comp v-slot="{ foo }">{{ foo }}{{ bar }}</Comp>`)
const returns = ast.codegenNode.children.properties[0].value.returns
console.log(returns)
console.log(`>>> 解析后的 {{ foo }} {{ bar }} 应该合并`)
console.log(returns[0].content)
console.log(`>>> 下面正是合并之后的两个插值`)
console.log(returns[0].content.children)
#+end_src

#+RESULTS:
#+begin_example
You are running a development build of Vue.
Make sure to use the production build (*.prod.js) when deploying for production.
[
  {
    type: 12,
    content: { type: 8, loc: [Object], children: [Array] },
    loc: { start: [Object], end: [Object], source: '{{ foo }}' },
    codegenNode: {
      type: 14,
      loc: [Object],
      callee: Symbol(createTextVNode),
      arguments: [Array]
    }
  }
]
>>> 解析后的 {{ foo }} {{ bar }} 应该合并
{
  type: 8,
  loc: {
    start: { column: 24, line: 1, offset: 23 },
    end: { column: 33, line: 1, offset: 32 },
    source: '{{ foo }}'
  },
  children: [
    { type: 5, content: [Object], loc: [Object] },
    ' + ',
    { type: 5, content: [Object], loc: [Object] }
  ]
}
>>> 下面正是合并之后的两个插值
[
  {
    type: 5,
    content: {
      type: 4,
      isStatic: false,
      constType: 0,
      content: 'foo',
      loc: [Object]
    },
    loc: { start: [Object], end: [Object], source: '{{ foo }}' }
  },
  ' + ',
  {
    type: 5,
    content: {
      type: 4,
      isStatic: false,
      constType: 0,
      content: 'bar',
      loc: [Object]
    },
    loc: { start: [Object], end: [Object], source: '{{ bar }}' }
  }
]
undefined
#+end_example

看下现阶段 stb-vue-next 输出结果：
#+begin_src js

const {
  baseCompile
} = require(process.env.PWD + '/../../static/js/vue/compiler-core.global.js')
 
const { ast } = baseCompile(`<Comp v-slot="{ foo }">{{ foo }}{{ bar }}</Comp>`)
const returns = ast.codegenNode.children.properties[0].value.returns
console.log(returns[0].content)
console.log(returns[1].content)
#+end_src

#+RESULTS:
#+begin_example
{
  type: 5,
  content: {
    type: 4,
    isStatic: false,
    isConstant: false,
    content: 'foo',
    loc: { start: [Object], end: [Object], source: 'foo' }
  },
  loc: {
    start: { column: 24, line: 1, offset: 23 },
    end: { column: 33, line: 1, offset: 32 },
    source: '{{ foo }}'
  }
}
{
  type: 5,
  content: {
    type: 4,
    isStatic: false,
    isConstant: false,
    content: 'bar',
    loc: { start: [Object], end: [Object], source: 'bar' }
  },
  loc: {
    start: { column: 33, line: 1, offset: 32 },
    end: { column: 42, line: 1, offset: 41 },
    source: '{{ bar }}'
  }
}
undefined
#+end_example

stb-vue-next 明显 returns 里面包含了两个元素分别是： ~{{ foo }}~ 和 ~{{ bar }}~

这是因为在 ~transformText~ 里面没有进行文本(插值也算)合并。
** 0773374 add component nested slots scoping

[[https://github.com/gcclll/stb-vue-next/commit/0773374334feb1ed86ff38c65dea917480b6cb89][fix: patchFlag should |= but != · gcclll/stb-vue-next@0773374]]

插槽嵌套使用。

#+begin_src js
`<Comp>
    <template #default="{ foo }">
        <Inner v-slot="{ bar }">
        {{ foo }}{{ bar }}{{ baz }}
        </Inner>
        {{ foo }}{{ bar }}{{ baz }}
    </template>
</Comp>`
#+end_src

插槽嵌套使用时的解析是先里后外，因为在 transform 阶段 ast 阶段转换之后，会进行回
溯，回溯过程是相反的。

如：

ast 结构 transform：

~Comp.children -> [template] -> template.children -> [Inner, foo, bar, baz] ->
Inner.children -> [foo, bar, baz]~

ast回溯:

~Inner.children -> Inner -> template.children -> template -> Comp.children -> Comp~

所以首先执行 ~transformElement()~ 的是 ~Inner~ 所以它会先进入 ~buildSlots()~ 构
建插槽结构，完了之后是 ~<template>~ 最后是 ~<Comp>~

-----

render 推导过程：

1. ~<Inner v-slot="{bar}">{{foo}}{{bar}}{{baz}}</Inner>~

   是在用户组件上应用了 ~v-slot~ 且是默认插槽，因此它的所有孩子节点都会成为默认
   插槽一部分。

   结果：
   #+begin_src js
   _createVNode(_component_Inner, null, {
     default: _withCtx(({ bar }) => [
       _createTextVNode(_toDisplayString(foo) + _toDisplayString(bar) + _toDisplayString(baz), 1 /* TEXT */)
     ]),
     _: 2, /* DYNAMIC */
   }, 1024 /* DYNAMIC_SLOTS */)
   #+end_src

   这里使用的是 ~_createVNode~ 因为 ~Inner~ 非唯一的孩子节点。
2. ~<template #default="{foo}">...</template>~

   #+begin_src js
   (_openBlock(), _createBlock(_component_Comp, null {
     default: _withCtx(({ foo }) => [
       _createVNode(_component_Inner, null, {
          default: _withCtx(({ bar }) => [
             _createTextVNode(_toDisplayString(foo) + _toDisplayString(bar) + _toDisplayString(baz), 1 /* TEXT */)
           ]),
          _: 2 /* DYNAMIC */
       }, 1024 /* DYNAMIC_SLOTS */),
       _createTextVNode(_toDisplayString(foo) + _toDisplayString(bar) + _toDisplayString(baz), 1 /* TEXT */)
     ]),
     _: 1 /* STABLE */
   }))
   #+end_src

   这里有个判断 ~Inner~ 为动态 slot 的关键点： ~context.scopes.vSlot > 0~ 而这个
   值是在收集 ~transformXxx~ 阶段递增 +1 而后回溯过程中 -1 的。

   在收集阶段 ~<template>~ 收集到 ~trackSlotScopes()~ 函数此时
   ~context.scopes.vSlot = 1~ 然后递归 children执行到 ~Inner~ 收集阶段的时候
   ~context.scopes.vSlot = 2~ 直到递归结束。

   开始回溯，先是在 ~Inner~ 上应用 transformElement 直到 ~Inner~ 回溯到执行
   ~trackSlotScopes()~ 应为它也有 ~v-slot~ 指令，所以 ~Inner~ 能收集到这个函数，
   它回溯结束执行 ~trackSlotScopes()~ 随之 ~context.scopes.vSlot--~ 所以此时，在
   回溯 ~Inner~ 结束之后在开始回溯 ~<template>~ 之前 ~context.scopes.vSlot = 1~
   。

   这就是 ~Inner~ 为什么没有动态属性名但是依旧会判断为动态插槽的原理。

   #+begin_quote
   一句话：如果在 ~<template v-slot>~ 里面嵌套另一个 ~v-slot~ 那个这个不管有没有
   动态属性名都会被当做动态插槽来处理。
   #+end_quote
** c1ace74 add component with v-slot inside v-for

#+begin_src js
`<div v-for="i in list">
  <Comp v-slot="bar">foo</Comp>
</div>`
#+end_src

~let hasDynamicSlots = context.scopes.vSlot > 0 || context.scopes.vFor > 0;~

根据这个判断决定 v-for 里面的 v-slot 为动态插槽。
** cfef20e add named slot with v-if

[[https://github.com/gcclll/stb-vue-next/commit/cfef20efd83d030924c23308cfb1e38c2b63e228][feat(add): slot with v-if · gcclll/stb-vue-next@cfef20e]]

#+begin_src js
`<Comp>
  <template #one v-if="ok">hello</template>
</Comp>`
#+end_src

测试：
#+begin_src js
const {
  baseParse,
  baseCompile
} = require(process.env.PWD + '/../../static/js/vue/compiler-core.global.js')

const { code } = baseCompile(`<Comp>
  <template #one v-if="ok">hello</template>
</Comp>`)
console.log(code)
#+end_src

#+RESULTS:
#+begin_example
const _Vue = Vue

return function render(_ctx, _cache) {
  with (_ctx) {
    const { createTextVNode : _createTextVNode, resolveComponent : _resolveComponent, withCtx : _withCtx, createSlots : _createSlots, createVNode : _createVNode, openBlock : _openBlock, createBlock : _createBlock } = _Vue

    const _component_Comp = _resolveComponent("Comp")

    return (_openBlock(), _createBlock(_component_Comp, null, _createSlots({ _: 2 /* DYNAMIC */ }, [
      ok
        ? {
            name: "one",
            fn: _withCtx(() => [
              _createTextVNode("hello")
            ])
          }
        : undefined
    ]), 1024 /* DYNAMIC_SLOTS */))
  }
}
undefined
#+end_example

动态 slots 处理之后：
~_createSlots({ /* 静态 slots */, [ /* 动态 slots 列表 */ ] })~

看下面的运行时的 ~createSlots(slots, dynamicSlots)~ 其实就是讲两者合并在一起了
v-if 是个对象 ~{ fn, name }~ v-for 是该对象的数组。
#+begin_src typescript
export function createSlots(
  slots: Record<string, Slot>,
  dynamicSlots: (
    | CompiledSlotDescriptor
    | CompiledSlotDescriptor[]
    | undefined)[]
): Record<string, Slot> {
  for (let i = 0; i < dynamicSlots.length; i++) {
    const slot = dynamicSlots[i]
    // array of dynamic slot generated by <template v-for="..." #[...]>
    if (isArray(slot)) {
      for (let j = 0; j < slot.length; j++) {
        slots[slot[j].name] = slot[j].fn
      }
    } else if (slot) {
      // conditional single slot generated by <template v-if="..." #foo>
      slots[slot.name] = slot.fn
    }
  }
  return slots
}
#+end_src

拓展： ~v-else, v-else-if~
[[https://github.com/gcclll/stb-vue-next/commit/e48d46a759478d28eea223c4884ec4815ceb5ac0][feat(add): v-else/v-else-if with v-slot · gcclll/stb-vue-next@e48d46a]]

与普通的 v-else/v-else-if 处理机制一样，首先是要找到他们兄弟节点前面的 v-if 节点，
然后将该节点挂接到 v-if 节点后面。

核心代码：
#+begin_src typescript
// v-else/if on slot
let j = i
let prev
while (j--) {
    // 找到相邻的 v-if
    prev = children[j]
    // 往回找第一个非注释的节点
    if (prev.type !== NodeTypes.COMMENT) {
        break
    }
}

// 如果该节点是 v-if 合法，否则不合法使用情况
if (prev && isTemplateNode(prev) && findDir(prev, 'if')) {
    // remove node
    children.splice(i, 1)
    i--
    __TEST__ && assert(dynamicSlots.length > 0)
    // attach this slot to previous conditional
    let conditional = dynamicSlots[
        dynamicSlots.length - 1
    ] as ConditionalExpression

  // 这目的是找到 ?: 表达式最后的那个节点
    while (
        conditional.alternate.type === NodeTypes.JS_CONDITIONAL_EXPRESSION
    ) {
        conditional = conditional.alternate
    }

  // 将当前的 v-else/v-else-if 挂到最后那个节点表达式位置
  // vElse.exp 检测是 v-else-if 还是 v-else(没有值exp)
    conditional.alternate = vElse.exp
        ? createConditionalExpression(
            vElse.exp,
            buildDynamicSlot(slotName, slotFunction),
            defaultFallback
        )
        : buildDynamicSlot(slotName, slotFunction)
} else {
    context.onError(
        createCompilerError(ErrorCodes.X_V_ELSE_NO_ADJACENT_IF, vElse.loc)
    )
}
#+end_src

** c1ace74 add v-for on v-slot component

[[https://github.com/gcclll/stb-vue-next/commit/c1ace746e229db02a9b311d1becfe4deb1513048][feat(add): v-slot inside v-for · gcclll/stb-vue-next@c1ace74]]


v-for 的处理和 v-if 原理是一样的，最后返回的都是  ~{name, fn}~ 类型，只不过
v-for 返回的是这个类型的数组。

v-for _renderList 和 slot 的结合：

#+begin_src js
_renderList(list, (i) => {
  return {
    name: name,
    fn: _withCtx(() => [
      _createTextVNode(_toDisplayString(name), 1 /* TEXT */)
    ])
  }
})

// 等于是： [ { name, fn }, { name1, fn1 }]
// 然后 _renderSlots ->
_renderSlots({ _: 2 /* DYNAMIC */ }, [
  _renderList(list, ...)
])

// -> _createBlock
_createBlock(_component_Comp, null, _renderSlots({
  /* 静态，最终动态插槽会合并到该对象来 */
}, [
  /* ... 动态列表 */
]))

// 对比无动态插槽情况：
_createBlock(_component_Comp, null {
  default: _withCtx(() => [
    _createTextVNode(_toDisplayString(foo), 1 /* TEXT */)
  ]),
  _: 1 /* STABLE */
})
#+end_src

测试：
#+begin_src js
const {
  baseParse,
  baseCompile
} = require(process.env.PWD + '/../../static/js/vue/compiler-core.global.js')
 
const { code } = baseCompile(`<Comp>
        <template v-for="name in list" #[name]>{{ name }}</template>
      </Comp>`)
console.log(code)
#+end_src

#+RESULTS:
#+begin_example
const _Vue = Vue

return function render(_ctx, _cache) {
  with (_ctx) {
    const { toDisplayString : _toDisplayString, createTextVNode : _createTextVNode, resolveComponent : _resolveComponent, withCtx : _withCtx, renderList : _renderList, createSlots : _createSlots, createVNode : _createVNode, openBlock : _openBlock, createBlock : _createBlock } = _Vue

    const _component_Comp = _resolveComponent("Comp")

    return (_openBlock(), _createBlock(_component_Comp, null, _createSlots({ _: 2 /* DYNAMIC */ }, [
      _renderList(list, (name) => {
        return {
          name: name,
          fn: _withCtx(() => [
            _createTextVNode(_toDisplayString(name), 1 /* TEXT */)
          ])
        }
      ))
    ]), 1024 /* DYNAMIC_SLOTS */))
  }
}
undefined
#+end_example

无非就是不同类型元素、组件 render 方式的组合。
** 小结：v-slot 几种用法
:PROPERTIES:
:COLUMNS: %CUSTOM_ID[(Custom Id)]
:CUSTOM_ID: slot-usage
:END: 

1. ~<Comp><div/></Comp>~ , 用户组件上的默认插槽
   
   #+begin_src js
   const _hoisted_1 = /*# __PURE__ */_createVNode('div', null, null, -1 /* HOISTED */)
   (_openBlock(), _createBlock(_component_Comp, null, {
     default: _withCtx(() => [
       _hoisted_1
     ]),
     _: 1 /* STABLE */
   }))
   #+end_src
2. ~<Comp v-slot="slotProps"><div/></Comp>~, 用户组件上带 ~slotProps~ 的默认插槽
   
   #+begin_src js
   const _hoisted_1 = /*# __PURE__ */_createVNode('div', null, null, -1 /* HOISTED */)
   (_openBlock(), _createBlock(_component_Comp, null, {
     default: _withCtx((slotProps) => [
       _hoisted_1
     ]),
     _: 1 /* STABLE */
   }))
   #+end_src
3. ~<Comp v-slot:named="slotProps">~, 用户组件上具名插槽

   #+begin_src js
   const _hoisted_1 = /*# __PURE__ */_createVNode('div', null, null, -1 /* HOISTED */)
   (_openBlock(), _createBlock(_component_Comp, null, {
     named: _withCtx((slotProps) => [
       _hoisted_1
     ])
   }))
   #+end_src

4. ~<Comp v-slot:[named]="slotProps">~, 用户组件上动态具名插槽
   
   #+begin_src js
   const _hoisted_1 = /*# __PURE__ */_createVNode('div', null, null, -1 /* HOISTED */)
   (_openBlock(), _createBlock(_component_Comp, null, {
     [named]: _withCtx((slotProps) => [
       _hoisted_1
     ])
   }))
   #+end_src
5. <template> 默认插槽

   ~<Comp><template v-slot="slotProps"><div/></template></Comp>~
   
   ~<template>~ 上的默认插槽，这个时候 ~<Comp>~ 不能在使用 ~v-slot~ ，下同 
6. <template> 具名插槽

   ~<Comp><template v-slot:named="slotProps"></Comp>~

   #+begin_src js
   return (_openBlock(), _createBlock(_component_Comp, null, {
     named: _withCtx((slotProps) => []),
     _: 1 /* STABLE */
   }))
   #+end_src
   
7. <template> 动态具名插槽

   ~<Comp><template v-slot:[named]="slotProps"></Comp>~
   
   #+begin_src js
   return (_openBlock(), _createBlock(_component_Comp, null, {
     [named]: _withCtx((slotProps) => []),
     _: 1 /* STABLE */
   }))
   #+end_src
8. <template> 具名插槽，其余非 template 元素当做默认插槽处理

   ~<Comp><template v-slot:named="slotProps"><div/></template><div :id="defaultSlotId"/></Comp>~
   
   ~<template>~ 上的具名插槽 + 默认插槽，在组件内的非 <template> 元素(即： ~<div/>~)都会被动作默认插槽来处理

   #+begin_src js
   const _hoisted_1 = /*# __PURE__ */_createVNode("div", null, null, -1 /* HOISTED */)
   _createBlock(_component_Comp, null, {
     named: _withCtx((slotProps) => [
       _hoisted_1
     ]),
     default: _withCtx(() => [
       _createVNode('div', {
         id: defaultSlotId
       }, null, 8 /* PROPS */, ["id"])
     ])
     _: 1 /* STABLE */
   })
   #+end_src
9. v-slot + v-if 插槽使用

   ~<Comp><template v-if="ok" #named="slotProps">{{ bar }}</template></Comp>~
   
   配合 v-if 使用的 slot template, 最后解析成 ：
   ~ok ? { name: 'named', fn : _withCtx(() => [ _createTextVNode(_toDisplayString(bar)) ]) } : undefined~
   
   #+begin_src js
   return (_openBlock(), _createBlock(_component_Comp, null, _renderSlots(
     { _: 2 /* DYNAMIC */ }, [
       ok ?
        {
          name: 'named',
          fn: _withCtx((slotProps) => [
            _createTextVNode(_toDisplayString(bar), 1 /* TEXT */)
          ])
        } : undefined
     ]
   )))
   #+end_src
10. v-slot + v-for 插槽上使用

   ~<Comp><template v-for="i in list" #named="{ prop }">{{ bar }}</template></Comp>~
    
   #+begin_src js
   return (_openBlock(), _createBlock(_component_Comp, null, _renderSlots(
     { _: 2 /* DYNAMIC */ },
     _renderList(list, (i) => {
       return {
         name: 'named',
         fn: _withCtx(({ prop }) => [
           _createTextVNode(_toDisplayString(bar), 1 /* TEXT */)
         ])
       }
     })
   )))
   #+end_src


#+begin_quote
插槽按状态分为：
1. 静态插槽，动态插槽除外的插槽
2. 动态插槽，有 ~v-if/v-for/v-else[-if]~ 指令或 ~v-slot:[named]~ 或作为 ~v-for~
   节点的孩子节点都视为动态插槽
#+end_quote

* update vue-next merge into stb-vue-next[2020-12-11 16:54:06]

更新 vue-next 合并到 stb-vue-next。

1. ast.ts 更新

   + ~SimpleExpressionNode~ : 去掉 ~isConstant~ 属性，增加 ~constType~
   + 去掉了 ~StaticType~ 增加 ~ConstantType~
      #+begin_src typescript
   /**
    * Static types have several levels.
    * Higher levels implies lower levels. e.g. a node that can be stringified
    * can always be hoisted and skipped for patch.
    */
   export const enum ConstantTypes {
     NOT_CONSTANT = 0,
     CAN_SKIP_PATCH,
     CAN_HOIST,
     CAN_STRINGIFY
   }
      #+end_src
2. codegen.ts 更新

   [[https://github.com/gcclll/stb-vue-next/commit/521b879d80b9c982f1a15dbc89404725141674d6][fix: merge vue-next codegen.ts · gcclll/stb-vue-next@521b879]]
3. parse.ts 更新

   ast 结构中的 ~isConstant~ 改成 ~ConstantTypes~ 类型值

   [[https://github.com/gcclll/stb-vue-next/commit/fdbdc4f93ad04f6544d77bf3ebf20e4f58673930][fix: merge vue-next parse.ts isConstant -> constType · gcclll/stb-vue-next@fdbdc4f]]
4. transform.ts 更新

   [[https://github.com/gcclll/stb-vue-next/commit/22a8f0be4405592621f805848533396642b4b2f2][fix: merge vue-next transform.ts · gcclll/stb-vue-next@22a8f0b]]

   + add ~filename~
   + add ~isTS, inline~
5. transformElement.ts

   [[https://github.com/gcclll/stb-vue-next/commit/1d85990627d0383741c7050fb4af8929377691e1][fix: merge vue-next transformElement.ts · gcclll/stb-vue-next@1d85990]]
6. transformSlotOutlet.ts

   [[https://github.com/gcclll/stb-vue-next/commit/58e87f3adcfa0657602d459043468ac5ce8859cb][fix: merge vue-next transformSlotOutlet.ts · gcclll/stb-vue-next@58e87f3]]
   修改 ~<slot></slot>~ 属性解析逻辑。
