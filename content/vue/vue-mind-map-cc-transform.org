#+TITLE: Vue3 源码头脑风暴之 3 ☞compiler-core - transform + codegen
#+DATE: <2020-11-30 10:07:11>
#+TAGS[]: vue, vue3, compiler-core, parser, compiler, transform
#+CATEGORIES[]: vue
#+LANGUAGE: zh-cn
#+STARTUP: indent

#+begin_export html
<link href="https://fonts.goo~gleapis.com/cs~s2?family=ZCOOL+XiaoWei&display=swap" rel="stylesheet">
<kbd>
<font color="blue" size="3" style="font-family: 'ZCOOL XiaoWei', serif;">
  诗号：六道同坠，魔劫万千，引渡如来。
</font>
</kbd><br><br>
#+end_export

[[/img/bdx/yiyeshu-001.jpg]]

@@html:<kbd>@@
*[[https://github.com/gcclll/stb-vue-next][stb-vue-next]] 完全拷贝于 [[https://github.com/vuejs/vue-next][vue-next]] ，主要目的学习及尝试应用于机顶盒环境。*
@@html:</kbd>@@

@@html:<kbd>@@ *本文依据 commit 进程进行记录，只要跟着下面的进程走，你将能完整实
现 vue ast transform 和 codegen generate 最后生成 render 函数 💃🏼💃🏼💃🏼* @@html:</kbd>@@

#+begin_quote
声明：该篇为 ts 源码(/commit/)版本，之前做过一遍完整的 js 版本，更详细，也可参考

[[https://www.cheng92.com/vue/vue3-source-code-compiler-core-compile_ts/][Vue3.0 源码系列（二）编译器核心 - Compiler core 3: compile.ts - 若叶知秋]]

由于 transform 阶段直接测试不太好直观的看出结果，因此这里会结合 codegen 来一起实
现，即该文包含 compiler-core 三大阶段的最后两个阶段(transform + generate)
#+end_quote

#+begin_export html
<script src="/js/vue/compiler-core.global.js"></script>
<script>
let i = 0, j = 0
const l1 = x => (j = 0, console.log(`%c >>> ${++i} ${x}`, 'background: #222; color: #bada55'))
const l2 = x => console.log(`%c > ${i}.${j++} ${x}`, 'background: #222; color: #bada55')
const log = (args) => console.log.apply(console, args)
log.blue = x => log([`%c ${x}`, `color: blue`])
log.red = x => log([`%c ${x}`, `color: red`])
const { baseCompile } = VueCompilerCore
const compile = (tpl, title, logAst = false) => {
    l2(title)
    const { code, ast } = baseCompile(tpl, {
        onError: (e) => console.warn(e.message),
        hoistStatic: true
    })

    log([code])
    logAst && log(ast)
}

</script>
#+end_export


* 关键知识点

1. [[#element-transform][🔗]] root.children.length = 1 且类型是 ELEMENT的时候将 ~CREATE_VNODE~ 改成
   ~CREATE_BLOCK~   
2. [[#v-bind][🔗]] 动态属性为表达式时，中间不能有空格

   如： ~<div :[first + second]="third" ...~ 是非法的。

   因为 ~parseAttribute()~ 中的正则是不支持中间有空格的：

   取参数名的正则： ~/^[^\t\r\n\f />][^\t\r\n\f />=]*/~
3. [[#v-bind][🔗]] v-bind 指令的几种用法 ->
* 脑图

# [[/img/vue3/compiler-core/compiler-core-parser.svg]]

* e03a03c init transform module

[[https://github.com/gcclll/stb-vue-next/commit/e03a03c5d775ff9315cc027d88b0669a775cf590][feat(init): transform section · gcclll/stb-vue-next@e03a03c]]

初始化函数。

#+begin_src typescript
export function createTransformContext(
  root: RootNode,
  {
    prefixIdentifiers = false,
    hoistStatic = false,
    cacheHandlers = false,
    nodeTransforms = [],
    directiveTransforms = {},
    transformHoist = null,
    isBuiltInComponent = NOOP,
    isCustomElement = NOOP,
    expressionPlugins = [],
    scopeId = null,
    ssr = false,
    ssrCssVars = ``,
    bindingMetadata = {},
    onError = defaultOnError
  }: TransformOptions
): TransformContext {
  const context: TransformContext = {

    // ...

    // methods
    helper(name) {
      context.helpers.add(name)
      return name
    },
    helperString(name) {
      return ``
    },
    replaceNode(node) {},
    removeNode(node) {},
    onNodeRemoved: () => {},
    addIdentifiers(exp) {
      // TODO
    },
    removeIdentifiers(exp) {
      // TODO
    },
    hoist(exp) {
      // TODO
      return {} as any
    },
    cache(exp, isVNode = false) {
      // TODO
      return {} as any
    }
  }

  return context
}

export function transform(root: RootNode, options: TransformOptions) {
  // TODO
}

// TODO
// createRootCodegen

export function traverseChildren(
  parent: ParentNode,
  context: TransformContext
) {
  // TODO
}

export function traverseNode(
  node: RootNode | TemplateChildNode,
  context: TransformContext
) {}

export function createStructuralDirectiveTransform(
  name: string | RegExp,
  fn: StructuralDirectiveTransform
): NodeTransform {
  return {} as any
}
#+end_src

* fc6f1f1 add transform function

[[https://github.com/gcclll/stb-vue-next/commit/fc6f1f112ae0e98b7e2e9a432d3dca1d6420307a][feat: transform function · gcclll/stb-vue-next@fc6f1f1]]

1. create transform context
2. traverse nodes, 递归遍历所有节点，构造器 codegenNode
3. hoist static, 静态节点提升，复用
4. ssr render, 不需要创建根节点 codegenNode
5. 复制 context 属性到 -> root


[[http://qiniu.ii6g.com/img/20201130231832.png]]

transform 作用就是通过 ~traverseNode()~ 递归遍历所有节点，解析，构造对应的节点
codegenNode 。
* b0d72da add compile.ts>compile()

[[https://github.com/gcclll/stb-vue-next/commit/b0d72dac2738fd270b0ea7fe0bb33f47597a233b][feat(add): compile function · gcclll/stb-vue-next@b0d72da]]

对外的 compile 函数，执行分为三个阶段：

- ast(~baseParse()~) -> 解析出 ast 结构
- transform(~transform()~) -> 解析 ast 得到 codegenNode
- codegen(~generate()~) -> 将 codegenNode 解析成 Render 函数


这是后面测试的基础，所以得提前实现了。

#+begin_src typescript

export function baseCompile(
  template: string | RootNode,
  options: CompilerOptions = {}
): CodegenResult {
  // const onError = options.onError || defaultOnError
  const isModuleMode = options.mode === 'module'

  const prefixIdentifiers =
    !__BROWSER__ && (options.prefixIdentifiers === true || isModuleMode)

  // TODO errors
  const ast = isString(template) ? baseParse(template, options) : template
  const [nodeTransforms, directiveTransforms] = getBaseTransformPreset(
    prefixIdentifiers
  )

  transform(
    ast,
    extend({}, options, {
      prefixIdentifiers,
      nodeTransforms: [
        ...nodeTransforms,
        ...(options.nodeTransforms || []) // user transforms
      ],
      directiveTransforms: extend(
        {},
        directiveTransforms,
        options.directiveTransforms || {}
      )
    })
  )

  return generate(
    ast,
    extend({}, options, {
      prefixIdentifiers
    })
  )
}
#+end_src

* 35248ce add exports maybe needs

[[https://github.com/gcclll/stb-vue-next/commit/35248ceece1aa8650b65f7f7ce13612660a65397][feat(add): compiler-core exports · gcclll/stb-vue-next@35248ce]]

增加 compiler-core 模块的导出(~export~)内容
* 05a223b add transform pure text
:PROPERTIES:
:COLUMNS: %CUSTOM_ID[(Custom Id)]
:CUSTOM_ID: pure-text
:END: 

[[https://github.com/gcclll/stb-vue-next/commit/05a223b7b1eb2ab877aec3b11feace484a7dde82][feat(add): transform pure text · gcclll/stb-vue-next@05a223b]]

#+begin_src typescript
export function traverseNode(
  node: RootNode | TemplateChildNode,
  context: TransformContext
) {
  // 保存当前被处理的 节点
  context.currentNode = node
  // 应用 transform 插件
  const { nodeTransforms } = context
  // 针对每个节点会收集到一个或多个 transformXxx 函数，用来解析它的 ast
  // 得到 codegenNode ，这些函数会在当前的节点树被递归遍历完之后调用
  const exitFns = []
  for (let i = 0; i < nodeTransforms.length; i++) {
    const onExit = nodeTransforms[i](node, context)
    if (onExit) {
      if (isArray(onExit)) {
        exitFns.push(...onExit)
      } else {
        exitFns.push(onExit)
      }
    }

    if (!context.currentNode) {
      // 节点可能被删除了，比如： v-else-if, v-else 会合并到 v-if 的 branches[] 中
      return
    } else {
      // 节点可能会替换了，需要更新
      node = context.currentNode
    }
  }

  switch (
    node.type
    // TODO
  ) {
  }

  context.currentNode = node
  let i = exitFns.length
  while (i--) {
    exitFns[i]()
  }
}
#+end_src

transform 阶段代码毕竟的三个阶段

1. 收集 transformXxx 函数到 exitFns
2. 根据 ast节点类型递归遍历子孙节点
3. 按照收集时相反的顺序执行 exitFns，解析出 codegenNode


为了方便测试，在 ~generate()~ 中直接返回 ast :
[[https://github.com/gcclll/stb-vue-next/commit/999d8d6b611443f8fd04282786d4a67f018d6319][test: generate return ast for test · gcclll/stb-vue-next@999d8d6]]
#+begin_src js
const {
  baseCompile
} = require(process.env.PWD + '/../../static/js/vue/compiler-core.global.js')

const res = baseCompile(`pure text`)
console.log(res.children[0])
#+end_src

+RESULTS:
#+begin_example
{
  type: 2,
  content: 'pure text',
  loc: {
    start: { column: 1, line: 1, offset: 0 },
    end: { column: 10, line: 1, offset: 9 },
    source: 'pure text'
  }
}
#+end_example

结果显示并没有 codegenNode 因为在transformText 中满足条件

~children.length === 1 && node.type === NodeTypes.ROOT~ 而直接退出了。

至于 ~root.codegenNode = undefined~ 需要实现 ~createRootCodegen()~

*** 61ce406 add createRootCodegen() to create root.codegenNode

[[https://github.com/gcclll/stb-vue-next/commit/61ce4066c9b49e11399da0b499220f426da444a0][feat: createRootCodegen() for pure text · gcclll/stb-vue-next@61ce406]]

只增加了针对非 ELEMENT 类型或者孩子节点没有 codegenNode 的情况实现(当前 commit
最简化)。

当 root.children 只有一个孩子节点且该节点没有自己的 codegenNode 时候：
#+begin_src typescript
function createRootCodegen(root: RootNode, context: TransformContext) {
  // const { helper } = context
  const { children } = root
  if (children.length === 1) {
    // 只有一个孩子节点，直接取该孩子节点 的 codegenNode
    const child = children[0]
    if (isSingleElementRoot(root, child) && child.codegenNode) {
      // 当 root 节点下只有一个 element 元素的孩子节点时，不进行提升
    } else {
      // - single <slot/>, IfNode, ForNode: already blocks.
      // - single text node: always patched.
      // root codegen falls through via genNode()

      root.codegenNode = child
    }
  } else if (children.length > 1) {
    // TODO
  } else {
    // no children = noop, codegen will return null.
  }
}
#+end_src

测试
#+begin_src js
const {
  baseCompile
} = require(process.env.PWD + '/../../static/js/vue/compiler-core.global.js')

const res = baseCompile(`pure text`)
console.log(res)
#+end_src

#+RESULTS:
#+begin_example
{
  type: 0,
  children: [ { type: 2, content: 'pure text', loc: [Object] } ],
  helpers: [],
  components: [],
  directives: [],
  hoists: [],
  imports: [],
  cached: 0,
  temps: 0,
  codegenNode: {
    type: 2,
    content: 'pure text',
    loc: { start: [Object], end: [Object], source: 'pure text' }
  },
  loc: {
    start: { column: 1, line: 1, offset: 0 },
    end: { column: 10, line: 1, offset: 9 },
    source: 'pure text'
  }
}
#+end_example

注意 codegenNode 其实就是 ~root.children[0]~ 节点本身。
*** b9f3cb7 add transform text

[[https://github.com/gcclll/stb-vue-next/commit/b9f3cb762e36e7f7090987db9cba77948845cdaf][feat: transformText function · gcclll/stb-vue-next@b9f3cb7]]

[[http://qiniu.ii6g.com/img/20201130150054.png]]

1. 必须是文本节点或者类型是组合表达式类型(~COMPOUND_EXPRESSION~)
2. patch flag 处理
3. 构造 TEXT_CALL 类型节点
4. codegenNode -> createCallExpression
*** f6d5271 add generate text codegen

codegen 阶段目的是将 codegenNode 解析成 Render 函数的一部分。

1. /f6d5271/ add ~createCodegenContext()~

   [[https://github.com/gcclll/stb-vue-next/commit/f6d52713ae8154d438c2ed94641525fa3c05edef][feat(add): codegen context creator · gcclll/stb-vue-next@f6d5271]]

   上下文对象创建函数，重点方法有两个(~push(code, node)~ 和 ~helper(key)~)。

   FIX1: lint errors, [[https://github.com/gcclll/stb-vue-next/commit/0ac8c2f4b6b5022caa0f83a7f850226c30a99d33][fix: f6d5271 lint errors · gcclll/stb-vue-next@0ac8c2f]]

2. /2ef2699/ 增加 text codegen generator 实现

   [[https://github.com/gcclll/stb-vue-next/commit/2ef2699b95457be4456b736b70467b98bf240ddd][feat: generate text codegen · gcclll/stb-vue-next@2ef2699]]

   该部分涉及到一个较为完整的 codegen generator 流程，所以增加内容较多，因此这里
   不直接贴代码了，请点击上面 commit 链接查看实际增加的源码。

   处理流程：

   - preamble 处理，如果是 Node 环境需要通过 ~import { ...} from 'vue'~ 语法，如
     果是浏览器环境使用 ~const { ... } = Vue~ 解构语法。

   - 是否使用 ~with() {}~ 作用域语法，默认是使用的

   - ~return ...~ 返回实际 render 函数返回结果，这里将返回最后被渲染的 DOM 结构。

   - ~genNode()~ 递归处理 ast 生成 render 函数的对应部分代码

3. /6b901f9/ 增加 node 环境或 module 环境处理(~genModulePreamble~)

   [[https://github.com/gcclll/stb-vue-next/commit/6b901f9f3d8af3dc415d31a6c5027d8e262fa74f][feat: module preamble · gcclll/stb-vue-next@6b901f9]]
   modue preamble : ~export { ... } from 'vue'~
   function preamble: ~const { ... } = Vue~


重点增加的 genXxx 函数 ~genText(node, context)~ 专门用来处理文本节点的。

#+begin_src typescript
function genText(
  node: TextNode | SimpleExpressionNode,
  context: CodegenContext
) {
  context.push(JSON.stringify(node.content), node)
}
#+end_src
*** 测试

测试将分为两个部分，
**** function preamble 形式(作为全局 ~Vue~ 对象引入)

#+begin_src js
const {
  baseCompile
} = require(process.env.PWD + '/../../static/js/vue/compiler-core.global.js')

const res = baseCompile(`pure text`)
console.log(res.code)
#+end_src

#+RESULTS:
:
: return function render(_ctx, _cache) {
:   with (_ctx) {
:     return "pure text"
:   }
: }
: undefined

[[https://github.com/gcclll/stb-vue-next/commit/6b3bd2e4c20dc7a325ff7c0575c127595da91b42][fix: less the last } paren · gcclll/stb-vue-next@6b3bd2e]]

**** module preamble 形式(*es6* 模块化导出导入)

#+begin_src js
const {
  baseParse,
  baseCompile
} = require(process.env.PWD + '/../../static/js/vue/compiler-core.global.js')

const res = baseCompile(`pure text`, { mode: 'module' })
console.log(res.code)
#+end_src

#+RESULTS:
:
: return function render(_ctx, _cache) {
:   return "pure text"
: }
: undefined

这里好像看不出啥区别，后面再说吧。
* 2f749b2 add interpolation generator
:PROPERTIES:
:COLUMNS: %CUSTOM_ID[(Custom Id)]
:CUSTOM_ID: interpolation
:END: 

[[https://github.com/gcclll/stb-vue-next/commit/2f749b2a5d0872713704a52943bb18b550c559c0][feat(add): transform -> generate interpolation · gcclll/stb-vue-next@2f749b2]]

#+begin_src js
const {
  baseParse,
  baseCompile
} = require(process.env.PWD + '/../../static/js/vue/compiler-core.global.js')

const res = baseCompile(`{{ a > b }}`)
console.log(res.code)
console.log(res.ast.children[0])
#+end_src

这里实现分几个部分：

*transform*: traverseNode() 增加对插值的处理，后面增加了 traverseChildren 处理，因为所有的
ast 都是挂在 ~root.children~ 中的，所以最开始解析的是 ~ROOT~ 节点，因此这里必须
要增加 ~ROOT~ 类型的解析，调用 ~traverseChildren(node, ctx)~ 去递归解析 ~root.children~

#+begin_quote
transform() -> traverseNode(): ROOT 解析 -> traverseChildren() ->
traverseNode(): INTERPOLATION
#+end_quote

新增核心函数：遍历所有 ~children[]~ 调用 ~traverseNode()~ 
#+begin_src typescript
export function traverseChildren(
  parent: ParentNode,
  context: TransformContext
) {
  // TODO	  let i = 0
  const nodeRemoved = () => {
    i--
  }

  for (; i < parent.children.length; i++) {
    const child = parent.children[i]
    if (isString(child)) continue
    context.parent = parent
    context.childIndex = i // 方便在 transformXxx 函数中能快速定位到当前节点
    context.onNodeRemoved = nodeRemoved
    traverseNode(child, context)
  }
}
#+end_src

[[http://qiniu.ii6g.com/img/20201201155917.png]]

*codegen*: ~genNode()~ 中新增 ~INTERPOLATION~ 和 ~SIMPLE_EXPRESSION~ 类型的处理，
 因为 INTERPOLATION 的 ast.content(如上面代码执行结果) 类型是 SIMPLE_EXPRESSION。

 #+begin_src typescript
function genExpression(node: SimpleExpressionNode, context: CodegenContext) {
  const { content, isStatic } = node
  context.push(isStatic ? JSON.stringify(content) : content, node)
}

function genInterpolation(node: InterpolationNode, context: CodegenContext) {
  const { push, helper, pure } = context
  if (pure) push(PURE_ANNOTATION)
  push(`${helper(TO_DISPLAY_STRING)}(`)
  genNode(node.content, context)
  push(')')
}
 #+end_src

-----

[[https://github.com/gcclll/stb-vue-next/commit/2d0e2a6f7610059f37aef798d37eaafdf8c43377][feat(add): comment generator · gcclll/stb-vue-next@2d0e2a6]]
 
拓展：add comment generator

#+begin_src js

const {
  baseParse,
  baseCompile
} = require(process.env.PWD + '/../../static/js/vue/compiler-core.global.js')

const res = baseCompile(`<!-- i'm a comment -->`)
console.log(res.code)
#+end_src

#+RESULTS:
#+begin_example
const _Vue = Vue

return function render(_ctx, _cache) {
  with (_ctx) {
    const { createCommentVNode : _createCommentVNode } = _Vue

    return _createCommentVNode(" i'm a comment ")
  }
}
undefined
#+end_example
* add element transfrom and generator
:PROPERTIES:
:COLUMNS: %CUSTOM_ID[(Custom Id)]
:CUSTOM_ID: element
:END: 

** 准备工作 ~compiler-core/src/utils.ts~

[[https://github.com/gcclll/stb-vue-next/commit/9436d8fe155767391a278807ae02a6ae9eff94a3][feat: utils for compiler-core · gcclll/stb-vue-next@9436d8f]]

相关正则： ~const memberExpRE = /^[A-Za-z_$][\w$]*(?:\s*\.\s*[A-Za-z_$][\w$]*|\[[^\]]+\])*$/~

[[http://qiniu.ii6g.com/img/image.png]]

[[https://github.com/gcclll/stb-vue-next/commit/2265e466e6daea95614d5fe96968b30ff11a2e19][feat(add): resolveComponentType · gcclll/stb-vue-next@2265e46]]

解析出组件的类型，大体分为四类：

1. 动态组件： ~<component is="xx">~ 或 ~<component v-is="xx">~
2. 内置组件： ~Teleport, Transition, KeepAlive, Suspense~
3. 用户组件： ~$setup[]~ 上的组件
4. 用户组件： ~context.components[]~ 上的组件

** 87339d2 add element transform
:PROPERTIES:
:COLUMNS: %CUSTOM_ID[(Custom Id)]
:CUSTOM_ID: element-transform
:END: 

[[https://github.com/gcclll/stb-vue-next/commit/87339d25f1fa43ed5e0a13dabc60fec9479451c1][feat(add): transformElement function · gcclll/stb-vue-next@87339d2]]

普通标签的 transform codegenNode阶段。

1. add ~createVNodeCall()~ 函数，创建基本的 ELEMENT 类型节点 codegenNode

  根据 ~isBlock~ 参数决定使用 BLOCK 函数还是 VNODE 函数。
   
  #+begin_src typescript
   export function createVNodeCall(
       context: TransformContext | null,
       tag: VNodeCall['tag'],
       props?: VNodeCall['props'],
       children?: VNodeCall['children'],
       patchFlag?: VNodeCall['patchFlag'],
       dynamicProps?: VNodeCall['dynamicProps'],
       directives?: VNodeCall['directives'],
       isBlock: VNodeCall['isBlock'] = false,
       disableTracking: VNodeCall['disableTracking'] = false,
       loc = locStub
   ): VNodeCall {
   if (context) {
       if (isBlock) {
           context.helper(OPEN_BLOCK)
           context.helper(CREATE_BLOCK)
       } else {
           context.helper(CREATE_VNODE)
       }
   }

   return {
       type: NodeTypes.VNODE_CALL,
       tag,
       props,
       children,
       patchFlag,
       dynamicProps,
       directives,
       isBlock,
       disableTracking,
       loc
   }
 }
 #+end_src

2. add ~createObjectExpression()~ 函数

   #+begin_src typescript
    export function createObjectExpression(
        properties: ObjectExpression['properties'],
        loc: SourceLocation = locStub
    ): ObjectExpression {
    return {
        type: NodeTypes.JS_OBJECT_EXPRESSION,
        loc,
        properties
    }
    }
   #+end_src

3. add ~getStaticType()~ 判断节点是否需要做静态提升处理

4. add ~transformElement: postTransformElement()~ 函数

5. add ~stringifyDynamicPropNames()~ 将属性转成数组结构


测试：
#+begin_src js
const {
  baseParse,
  baseCompile
} = require(process.env.PWD + '/../../static/js/vue/compiler-core.global.js')
 
const res = baseCompile(`<div></div>`)
console.log('root codegenNode: ', res.ast.codegenNode)
console.log(res.code)
#+end_src

#+RESULTS:
#+begin_example
root codegenNode:  undefined
const _Vue = Vue

return function render(_ctx, _cache) {
  with (_ctx) {
    const { createVNode : _createVNode } = _Vue

    return null
  }
}
undefined
#+end_example

正确结果：
#+begin_example
ƒ render(_ctx, _cache) {
  with (_ctx) {
    const { createVNode: _createVNode, openBlock: _openBlock, createBlock: _createBlock } = _Vue

    return (_openBlock(), _createBlock("div"))
  }
}
#+end_example

问题：
1. 根节点 codegenNode 为空
2. render 函数内没有 ~openBlock, createBlock~ 导出
3. return 后面没内容(这是 generator 范畴，此节不展开)


问题1，2都是在同一个地方处理的，因为当 ROOT 节点只有一个孩子节点的时候，不会用
CREATE_VNODE 创建，而是改用 CREATE_BLOCK，所以这两个问题一起处理

FIX 1,2: [[https://github.com/gcclll/stb-vue-next/commit/97cf290240fa937f167f8aadd6e6527744da4cbe][fix: no export open/create block function from Vue · gcclll/stb-vue-next@97cf290]]

修改： ~createRootCodegen(root: RootNode, context: TransformContext)~

** 2f58786 add element generator

[[https://github.com/gcclll/stb-vue-next/commit/2f58786c56986672c6b7cabdcd541363bf05b4dd][feat: element generator · gcclll/stb-vue-next@2f58786]]

路径：

1. ~VNODE_CALL~ ->

2. ~genVNodeCall()~ ->

3. ~genNodeList([], ctx)~ ->

    - string: ~push(node)~
    - array: ~genNodeListAsArray(node, ctx)~ 
    - other: ~genNode(node, ctx)~


测试:
#+begin_src js
const {
  baseParse,
  baseCompile
} = require(process.env.PWD + '/../../static/js/vue/compiler-core.global.js')
 
const res = baseCompile(`<div></div>`)
console.log('root codegenNode: ', res.ast.codegenNode)
console.log(res.code)
#+end_src

#+RESULTS:
#+begin_example
root codegenNode:  {
  type: 13,
  tag: '"div"',
  props: undefined,
  children: undefined,
  patchFlag: undefined,
  dynamicProps: undefined,
  directives: undefined,
  isBlock: true,
  disableTracking: false,
  loc: {
    start: { column: 1, line: 1, offset: 0 },
    end: { column: 12, line: 1, offset: 11 },
    source: '<div></div>'
  }
}
const _Vue = Vue

return function render(_ctx, _cache) {
  with (_ctx) {
    const { createVNode : _createVNode, openBlock : _openBlock, createBlock : _createBlock } = _Vue

    return (_openBlock(), _createBlock("div"))
  }
}
#+end_example
** 05ca2f8 root.children 有多个孩子

[[https://github.com/gcclll/stb-vue-next/commit/05ca2f8bedf21d146a01ad5694c727bbe776145c][feat: root.children has multi child · gcclll/stb-vue-next@05ca2f8 · GitHub]]

当有多个孩子节点的时候，会创建一个 ~fragment~ 将他们包起来。

[[http://qiniu.ii6g.com/img/20201201232048.png]]

FIX: 死循环， ~genNode(node.codegenNode, ctx)~

[[http://qiniu.ii6g.com/img/20201201232120.png]]

测试：

#+begin_src js

const {
  baseParse,
  baseCompile
} = require(process.env.PWD + '/../../static/js/vue/compiler-core.global.js')
 
const res = baseCompile(`<div></div><div></div>`)
console.log(res.code)
#+end_src

#+RESULTS:
#+begin_example
const _Vue = Vue

return function render(_ctx, _cache) {
  with (_ctx) {
    const { createVNode : _createVNode, Fragment : _Fragment, openBlock : _openBlock, createBlock : _createBlock } = _Vue

    return (_openBlock(), _createBlock(_Fragment,null,[
      _createVNode("div"),
      _createVNode("div")
    ],64 /* STABLE_FRAGMENT */))
  }
}
undefined
#+end_example

FIX: 参数之间少了空格([[https://github.com/gcclll/stb-vue-next/commit/05ca2f8bedf21d146a01ad5694c727bbe776145c?branch=05ca2f8bedf21d146a01ad5694c727bbe776145c&diff=split][feat: root.children has multi child · gcclll/stb-vue-next@05ca2f8]])

正解：
#+begin_example
const _Vue = Vue
const { createVNode: _createVNode } = _Vue

const _hoisted_1 = /*#__PURE__*/_createVNode("div", null, null, -1 /* HOISTED */)
const _hoisted_2 = /*#__PURE__*/_createVNode("div", null, null, -1 /* HOISTED */)

return function render(_ctx, _cache) {
  with (_ctx) {
    const { createVNode: _createVNode, Fragment: _Fragment, openBlock: _openBlock, createBlock: _createBlock } = _Vue

    return (_openBlock(), _createBlock(_Fragment, null, [
      _hoisted_1,
      _hoisted_2
    ], 64 /* STABLE_FRAGMENT */))
  }
}
#+end_example

正确答案中做了静态提升处理，代码在 ~transform()~ 函数中 ~hoistStatic(root,
context)~ 的调用，会从 ROOT 节点开始遍历，将需要提升的节点进行提升处理。
* 7cb3dbf add hoist static 静态提升

满足提升的三种情况：

1. tag 和 tagType 都是 ELEMENT 且整棵树都是静态
2. 包含动态孩子节点，但是有静态属性的，将属性提升
3. 纯文本节点


[[https://github.com/gcclll/stb-vue-next/commit/7d7dbd4e20198e73df5c93804dce122656252c8f][feat(add): hoist static · gcclll/stb-vue-next@7d7dbd4]]

transform() 中增加静态提升处理：

#+begin_src typescript
if (options.hoistStatic) {
  hoistStatic(root, context)
}
#+end_src

[[https://github.com/gcclll/stb-vue-next/commit/7cb3dbf94bd17c5af68dc55103a8031da28be55b][feat: hoist static · gcclll/stb-vue-next@7cb3dbf]]

1. 修改 ~genFunctionPreamble(ast: RootNode, context: CodegenContext)~ 解构出需要用到的函数(~_createVNode~)

   [[/img/commit/diff-hoist-decon-functions.png]]

2. 增加 ~genHoists()~ 函数，生成 ~ast.hoists~ 中需要提升的节点

    #+begin_src typescript
    function genHoists(hoists: (JSChildNode | null)[], context: CodegenContext) {
    if (!hoists.length) {
        return
    }

    context.pure = true
    const { push, newline, helper, scopeId, mode } = context
    const genScopeId = !__BROWSER__ && scopeId != null && mode !== 'function'
    newline()

    // push scope Id before initializing hoisted vnodes so that these vnodes
    // get the proper scopeId as well.
    if (genScopeId) {
        push(`${helper(PUSH_SCOPE_ID)}("${scopeId}")`)
        newline()
    }

    hoists.forEach((exp, i) => {
        if (exp) {
        push(`const _hoisted_${i + 1} = `)
        genNode(exp, context)
        newline()
        }
    })

    if (genScopeId) {
        push(`${helper(POP_SCOPE_ID)}()`)
        newline()
    }

    context.pure = false
    }
    #+end_src


测试：
#+begin_src js
const {
  baseParse,
  baseCompile
} = require(process.env.PWD + '/../../static/js/vue/compiler-core.global.js')
 
const res = baseCompile(`<div></div><div></div>`, { hoistStatic: true })
console.log(res.code)
#+end_src

#+RESULTS:
#+begin_example
const _Vue = Vue
const { createVNode: _createVNode } = _Vue

const _hoisted_1 = /*#__PURE__*/_createVNode("div", null, null, -1 /* HOISTED */)
const _hoisted_2 = /*#__PURE__*/_createVNode("div", null, null, -1 /* HOISTED */)

return function render(_ctx, _cache) {
  with (_ctx) {
    const { createVNode : _createVNode, Fragment : _Fragment, openBlock : _openBlock, createBlock : _createBlock } = _Vue

    return (_openBlock(), _createBlock(_Fragment, null, [
      _hoisted_1,
      _hoisted_2
    ], 64 /* STABLE_FRAGMENT */))
  }
}
undefined
#+end_example

#+begin_quote
PS: 静态属性提升 [[https://github.com/gcclll/stb-vue-next/commit/1e58eeb605b0dc88c90dac550b927f89dd18e07d][feat: props hoist static · gcclll/stb-vue-next@1e58eeb]]
#+end_quote

* prop transform and generator

在这之前我们完成了以下几个基本部分：

- [[#pure-text][文本]]
- [[#interpolation][插值]]
- [[#element][普通标签(一个和多个)]]


接下来需要完成属性的解析才能进行下一步，因为 ~v-if, v-for, v-slot, ...~ 都需要属
性解析。

属性转换这里异常复杂，需要慢慢展开来讲，并且涉及到各种指令，因此对于完整的测试需
要等所有指令 transform 完成之后再进行。

** 1792f93 props transform

*** buildProps

[[https://github.com/gcclll/stb-vue-next/commit/1792f93b26aff5d0db60d83b946a83fb0fa6e776][feat(add): transform props · gcclll/stb-vue-next@1792f93]]


- 将 ~codegenNode.props~ 构建成 如下结构：

  #+begin_src json
{
    "type":15,
    "properties":[
        {
            "type":16,
            "key":{
                "type":4,
                "isConstant":false,
                "content":"class",
                "isStatic":true
            },
            "value":{
                "type":4,
                "isConstant":false,
                "content":"second",
                "isStatic":true
            }
        },
        {
            "type":16,
            "key":{
                "type":4,
                "isConstant":false,
                "content":"onClick",
                "isStatic":true
            },
            "value":{
                "type":4,
                "content":"clickHandle",
                "isStatic":false,
                "isConstant":false,
            }
        }
    ]
}
  #+end_src

- v-bind,v-on 指令，没有参数，需要将 props 合并

*** transform props

[[https://github.com/gcclll/stb-vue-next/commit/20a5fa8bfefa9dd98a7965f78ff1f84de2591962][feat: transform props in codgenNode · gcclll/stb-vue-next@20a5fa8]]
** e4acc0d props generator

[[https://github.com/gcclll/stb-vue-next/commit/e4acc0dd5e33ceab3420f9e5ca8857f090bb536c][feat: props generator · gcclll/stb-vue-next@e4acc0d]]

修改点：

1. add ~genExpressionAsPropertyKey()~ 生成属性 key 函数

   三种可能的属性名

   - 静态属性名: ~<div class="value">~ -> ~{ class: "value" }~

   - 动态属性名: ~<div :[propName]="value"~ -> ~{ [propName]: "value"}~

   - 组合表达式属性名：TODO

    #+begin_src typescript
   // 生成对象的属性 key (可能是静态，动态)
   function genExpressionAsPropertyKey(
     node: ExpressionNode,
     context: CodegenContext
   ) {
     const { push } = context
     if (node.type === NodeTypes.COMPOUND_EXPRESSION) {
       // TODO 动态属性名或表达式
     } else if (node.isStatic) {
       // only quote key if necessary
       const text = isSimpleIdentifier(node.content)
         ? node.content
         : JSON.stringify(node.content)

       push(text, node)
     } else {
       push(`[${node.content}]`, node)
     }
   }
    #+end_src

2. add ~genObjectExpression()~ 将属性列表生成对象

   遍历节点的 ~node.properties~ 先生成 key(~genExpressionAsPropertyKey(key)~) 再生成 value(~genNode(value)~) 。


测试：
#+begin_src js

const {
  baseParse,
  baseCompile
} = require(process.env.PWD + '/../../static/js/vue/compiler-core.global.js')
 
const res = baseCompile(`<div class="first" name="div"></div>`, { hoistStatic: true })
console.log(res.code)
#+end_src

#+RESULTS:
#+begin_example
const _Vue = Vue
const { createVNode: _createVNode } = _Vue

const _hoisted_1 = {
  class: "first",
  name: "div"
}

return function render(_ctx, _cache) {
  with (_ctx) {
    const { createVNode : _createVNode, openBlock : _openBlock, createBlock : _createBlock } = _Vue

    return (_openBlock(), _createBlock("div", _hoisted_1))
  }
}
undefined
#+end_example

#+begin_quote
实例中最后是用的 ~createBlock()~ 是因为 root.children 只有一个 child 。
#+end_quote

** static props

修改函数： ~transforms/transformElement~

#+begin_src js

const {
  baseParse,
  baseCompile
} = require(process.env.PWD + '/../../static/js/vue/compiler-core.global.js')
 
const res = baseCompile(`<div class="first"></div><div class="second"></div>`, { hoistStatic: true })
console.log(res.ast.codegenNode.children[0].props[0])
#+end_src

#+RESULTS:
#+begin_example
{
  type: 6,
  name: 'class',
  value: {
    type: 2,
    content: 'first',
    loc: { start: [Object], end: [Object], source: '"first"' }
  },
  loc: {
    start: { column: 6, line: 1, offset: 5 },
    end: { column: 19, line: 1, offset: 18 },
    source: 'class="first"'
  }
}
undefined
#+end_example
** 6951dd1 merge props

[[https://github.com/gcclll/stb-vue-next/commit/6951dd1ff97da1ef803e97770162fe0293ef76cc][feat: merge props · gcclll/stb-vue-next@6951dd1]]

合并属性的条件：存在没有参数的指令，如： ~<div v-bind="{...}" v-on="{...}"~

FIX: [[https://github.com/gcclll/stb-vue-next/commit/12a66f0ebef241b282b4ccf746ddabc1a2f45ef1][fix: merge toHandlers props · gcclll/stb-vue-next@12a66f0]]

#+begin_src js

const {
  baseParse,
  baseCompile
} = require(process.env.PWD + '/../../static/js/vue/compiler-core.global.js')
const log = (code, title) => {
  console.log(`>>> ${title}`)
  const res = baseCompile(code)
  console.log(res.code)
}
 
log(`
<div class="first" v-on="{ click: clickHandle  }" v-bind="{ style: 'color:red' }"></div>`, '无参数的指令，合并所有属性')

log(`<div class="second" v-on:click="clickHandle" v-bind:style="color:red"></div>`, '有参数的指令，不合并')
#+end_src

#+RESULTS:
#+begin_example
>>> 无参数的指令，合并所有属性
const _Vue = Vue

return function render(_ctx, _cache) {
  with (_ctx) {
    const { toHandlers : _toHandlers, mergeProps : _mergeProps, createVNode : _createVNode, openBlock : _openBlock, createBlock : _createBlock } = _Vue

    return (_openBlock(), _createBlock("div", _mergeProps({ class: "first" }, _toHandlers({ click: clickHandle  }), { style: 'color:red' }), null, 16 /* FULL_PROPS */))
  }
}
>>> 有参数的指令，不合并
const _Vue = Vue

return function render(_ctx, _cache) {
  with (_ctx) {
    const { resolveDirective : _resolveDirective, createVNode : _createVNode, openBlock : _openBlock, createBlock : _createBlock } = _Vue

    return _withDirectives((_openBlock(), _createBlock("div", { class: "second" }, null, 512 /* NEED_PATCH */)), )
  }
}
undefined
#+end_example

有参数指令时，需要结合 ~v-on~ 指令解析，因此需要先实现了 transform 指令才能得到下面的正确结果。

不合并(~mergeProps()~) 的正解：

#+begin_src js
(function anonymous(
) {
const _Vue = Vue

return function render(_ctx, _cache) {
  with (_ctx) {
    const { createVNode: _createVNode, openBlock: _openBlock, createBlock: _createBlock } = _Vue

    return (_openBlock(), _createBlock("div", {
      class: "second",
      onClick: clickHandle,
      style: { color: 'red' }
    }, null, 12 /* STYLE, PROPS */, ["onClick"]))
  }
}
})
#+end_src

下面将继续完成指令相关的 transform
* 6c43451 add v-on transform

init: [[https://github.com/gcclll/stb-vue-next/commit/98dcc9653790a319c3bc04222322167db21546df][feat(init): v-on directive · gcclll/stb-vue-next@98dcc96]]

实现：[[https://github.com/gcclll/stb-vue-next/commit/6c4345156ffc86542120bb97deb438097b36efca][feat: v-on directive transform · gcclll/stb-vue-next@6c43451]]

#+begin_src js

const {
  baseParse,
  baseCompile
} = require(process.env.PWD + '/../../static/js/vue/compiler-core.global.js')
 
const res = baseCompile(`<div class="second" v-on:click="clickHandle" v-bind:style="color:red"></div>`)

console.log(res.code)
#+end_src

#+RESULTS:
#+begin_example
const _Vue = Vue

return function render(_ctx, _cache) {
  with (_ctx) {
    const { resolveDirective : _resolveDirective, createVNode : _createVNode, openBlock : _openBlock, createBlock : _createBlock } = _Vue

    return _withDirectives((_openBlock(), _createBlock("div", {
      class: "second",
      onClick: clickHandle
    }, null, 8 /* PROPS */, ["onClick"])), )
  }
}
undefined
#+end_example

问题： ~v-bind~ 没有被解析出来。
* f805858 add v-bind transform
:PROPERTIES:
:COLUMNS: %CUSTOM_ID[(Custom Id)]
:CUSTOM_ID: v-bind
:END: 

[[https://github.com/gcclll/stb-vue-next/commit/f80585802218bcc75aad502880c571b642257ef0][feat(add): v-bind transform · gcclll/stb-vue-next@f805858]]

#+begin_src js
const {
  baseParse,
  baseCompile
} = require(process.env.PWD + '/../../static/js/vue/compiler-core.global.js')
 
const res = baseCompile(`
<div v-bind:name="test"
  :age="100"
  :[propName]="myName"
  :[first+second]="thrid"
  :no-need-camel-prop="noNeedCamelProp"
  :need-camel-prop.camel="needCamelProp"
  :no-exp-prop.camel
></div>`, {
  onError(e) {
    console.log(e.message)
  }
})
console.log(`>>> render function\n`)
console.log(res.code)
#+end_src

#+RESULTS:
#+begin_example
v-bind is missing expression.
>>> render function

const _Vue = Vue

return function render(_ctx, _cache) {
  with (_ctx) {
    const { createVNode : _createVNode, openBlock : _openBlock, createBlock : _createBlock } = _Vue

    return (_openBlock(), _createBlock("div", {
      name: test,
      age: 100,
      [propName || ""]: myName,
      [first+second || ""]: thrid,
      "no-need-camel-prop": noNeedCamelProp,
      needCamelProp: needCamelProp,
      noExpProp: ""
    }, null, 16 /* FULL_PROPS */, ["name","age","no-need-camel-prop","needCamelProp","noExpProp"]))
  }
}
undefined
#+end_example

v-bind 属性支持以下几种方式：

- ~v-bind:name="test"~ 无缩写属性，最普通的一种用法
- ~:age="100"~ 缩写形式
- ~:[propName]="myName"~ 普通动态属性名
- ~:[first+second]="third"~ 表达式动态属性名
- ~:no-need-camel-prop="noNeedCamelProp"~ 不需要转驼峰的属性名
- ~:need-camel-prop.camel="needCamelProp"~ 需要转成驼峰的属性名，需要制定
  ~.camel~ 修饰符
- ~no-exp-prop.camel~ 无属性值的属性，会给默认 ~""~ 值，同时给出警告，不建议使用。
* 0cc76f0 add v-model transform

[[https://github.com/gcclll/stb-vue-next/commit/0cc76f04112b1194e0a5cafae0a49bc399462ebf][feat(add): v-model transform · gcclll/stb-vue-next@0cc76f0]]

~<input v-model="model" />~

经过 ~transformModel~ 之后的 node.props:

#+begin_src json
[
    {
        "type":16, // JS_PROPERTY
        "key":{
            "type":4, // SIMPLE_EXPRESSION
            "content":"modelValue",
            "isStatic":true,
            "constType":3
        },
        "value":{
            "type":4,
            "content":"model",
            "isStatic":false,
            "constType":0,
        }
    },
    {
        "type":16,
        "key":{
            "type":4,
            "content":"onUpdate:modelValue",
            "isStatic":true,
            "constType":3
        },
        "value":{
            "type":8, // COMPOUND_EXPRESSION
            "children":[
                "$event => (",
                {
                    "type":4,
                    "content":"model",
                    "isStatic":false,
                    "constType":0,
                },
                " = $event)"
            ]
        }
    }
]
#+end_src

compiler-core 阶段的解析脑图：
[[/img/vue3/compiler-core/pcg/pcg-08-v-model-cc.svg]]

从图中可以看出， v-model 指令的解析也是在 buildProps 中完成的，关于这个函数的脑
图也可以查看 [[/vue/vue-mind-map-house-cc/#key-01-build-props][buildProps(node, context) 如何构建 props ?]]

vue/baseCompile 解析之后的结果：

#+begin_src js
const _Vue = Vue

return function render(_ctx, _cache) {
  with (_ctx) {
    const { createVNode: _createVNode, openBlock: _openBlock, createBlock: _createBlock } = _Vue

    return (_openBlock(), _createBlock("input", {
      modelValue: model,
      "onUpdate:modelValue": $event => (model = $event)
    }, null, 8 /* PROPS */, ["modelValue", "onUpdate:modelValue"]))
  }
}
#+end_src

vue/compile 经过 compile-dom package(/未完成/) 的 transformModel 之后的结果：

#+begin_src js
(function anonymous(
) {
const _Vue = Vue

return function render(_ctx, _cache) {
  with (_ctx) {
    const { vModelText: _vModelText, createVNode: _createVNode, withDirectives: _withDirectives, openBlock: _openBlock, createBlock: _createBlock } = _Vue

    return _withDirectives((_openBlock(), _createBlock("input", {
      "onUpdate:modelValue": $event => (model = $event)
    }, null, 8 /* PROPS */, ["onUpdate:modelValue"])), [
      [_vModelText, model]
    ])
  }
}
})
#+end_src

[[https://github.com/gcclll/stb-vue-next/commit/a537be0fc265243012032750a801b6e6582751d5][fix: v-model no value · gcclll/stb-vue-next@a537be0]]

修复之后(~genNode~ 没有实现 ~8,COMPOUND_EXPRESSION~ 类型)，测试

1. 不带参数的 ~v-model~

   #+begin_src js
    const {
        baseParse,
        baseCompile
    } = require(process.env.PWD + '/../../static/js/vue/compiler-core.global.js')

    const { code } = baseCompile(`<input v-model="model" />`)
    console.log(code)
    #+end_src

    #+RESULTS:
    #+begin_example
    const _Vue = Vue

    return function render(_ctx, _cache) {
      with (_ctx) {
        const { createVNode : _createVNode, openBlock : _openBlock, createBlock : _createBlock } = _Vue

        return (_openBlock(), _createBlock("input", {
          modelValue: model,
          "onUpdate:modelValue": $event => (model = $event)
        }, null, 8 /* PROPS */, ["modelValue","onUpdate:modelValue"]))
      }
    }
    #+end_example

2. 指令 ~{ prefixIdentifiers: true }~ 选项(需要 node 环境, *TODO*)

   #+begin_src js
    const {
        baseParse,
        baseCompile
    } = require(process.env.PWD + '/../../static/js/vue/compiler-core.global.js')

    const { code } = baseCompile(`<input v-model="model" />`, {
      prefixIdentifiers: true
    })
    console.log(code)
   #+end_src

   #+RESULTS:
   #+begin_example
   const _Vue = Vue

   return function render(_ctx, _cache) {
     with (_ctx) {
       const { createVNode : _createVNode, openBlock : _openBlock, createBlock : _createBlock } = _Vue

       return (_openBlock(), _createBlock("input", {
         modelValue: model,
         "onUpdate:modelValue": $event => (model = $event)
       }, null, 8 /* PROPS */, ["modelValue","onUpdate:modelValue"]))
     }
   }
   undefined
   #+end_example

3. 组合表达式(~8,COMPOUND_EXPRESSION~)

   #+begin_src js
const {
  baseParse,
  baseCompile
} = require(process.env.PWD + '/../../static/js/vue/compiler-core.global.js')

const { code } = baseCompile(`<input v-model="model[index]" />`)
console.log(code)
 
   #+end_src

   #+RESULTS:
   #+begin_example
   const _Vue = Vue

   return function render(_ctx, _cache) {
     with (_ctx) {
       const { createVNode : _createVNode, openBlock : _openBlock, createBlock : _createBlock } = _Vue

       return (_openBlock(), _createBlock("input", {
         modelValue: model[index],
         "onUpdate:modelValue": $event => (model[index] = $event)
       }, null, 8 /* PROPS */, ["modelValue","onUpdate:modelValue"]))
     }
   }
   undefined
   #+end_example

4. 带参数

   #+begin_src js

const {
  baseParse,
  baseCompile
} = require(process.env.PWD + '/../../static/js/vue/compiler-core.global.js')
 
const { code } = baseCompile(`<input v-model:value="model" />`)
console.log(code)
   #+end_src

   #+RESULTS:
   #+begin_example
   const _Vue = Vue

   return function render(_ctx, _cache) {
     with (_ctx) {
       const { createVNode : _createVNode, openBlock : _openBlock, createBlock : _createBlock } = _Vue

       return (_openBlock(), _createBlock("input", {
         value: model,
         "onUpdate:value": $event => (model = $event)
       }, null, 40 /* PROPS, HYDRATE_EVENTS */, ["value","onUpdate:value"]))
     }
   }
   undefined
   #+end_example

    不带参数的时候参数名会给一个默认值： ~modelValue~, 如果有自己的参数会直接使
   用提供的参数名。

5. 动态参数

   #+begin_src js

const {
  baseParse,
  baseCompile
} = require(process.env.PWD + '/../../static/js/vue/compiler-core.global.js')
 
const { code } = baseCompile(`<input v-model:[value]="model" />`)
console.log(code)
   #+end_src

   有问题结果：
   #+RESULTS:
   #+begin_example
   const _Vue = Vue

   return function render(_ctx, _cache) {
     with (_ctx) {
       const { createVNode : _createVNode, openBlock : _openBlock, createBlock : _createBlock } = _Vue

       return (_openBlock(), _createBlock("input", {
         [value]: model,
         : $event => (model = $event)
       }, null, 16 /* FULL_PROPS */))
     }
   }
   #+end_example

   结果显示，动态属性的事件名没有被解析出来 ~: $event => (model = $event)~ 。

   修复之后结果([[https://github.com/gcclll/stb-vue-next/commit/94a7a850d7e060e948c5672cdb170c47489feda9][fix: v-model dynamic arg generate · gcclll/stb-vue-next@94a7a85]])：
   #+RESULTS:
   #+begin_example
   const _Vue = Vue

   return function render(_ctx, _cache) {
     with (_ctx) {
       const { createVNode : _createVNode, openBlock : _openBlock, createBlock : _createBlock } = _Vue

       return (_openBlock(), _createBlock("input", {
         [value]: model,
         ["onUpdate:" + value]: $event => (model = $event)
       }, null, 16 /* FULL_PROPS */))
     }
   }
   #+end_example

6. 缓存事件回调函数(~cacheHandlers: true~, *TODO*)

   需要结合 ~prefixIdentifiers: true~ 使用。
* bf18a84 add v-once transform

[[https://github.com/gcclll/stb-vue-next/commit/bf18a84650adaf68004a0ce0977d33b1436a4587][feat(add): v-once · gcclll/stb-vue-next@bf18a84]]

#+begin_src typescript
const seen = new WeakSet()

export const transformOnce: NodeTransform = (node, context) => {
  if (node.type === NodeTypes.ELEMENT && findDir(node, 'once', true)) {
    // 缓存实现 v-once，就算有数据更新也不会重新生成 render 函数
    if (seen.has(node)) {
      return
    }
    seen.add(node)
    context.helper(SET_BLOCK_TRACKING)
    return () => {
      const cur = context.currentNode as ElementNode | IfNode | ForNode
      if (cur.codegenNode) {
        cur.codegenNode = context.cache(cur.codegenNode, true /* isVNode */)
      }
    }
  }
}
#+end_src

~v-once~ 指令的实现看似挺简单的，将解析后的 node 节点缓存到 ~seen: WeakSet~ 中，
下次使用的时候直接取缓存(~context.cache(...)~)，而不是重新生成 ~codegenNode~

~JS_CACHE_EXPRESSION~ 结构：

#+begin_src typescript
export function createCacheExpression(
  index: number,
  value: JSChildNode,
  isVNode: boolean = false
): CacheExpression {
  return {
    type: NodeTypes.JS_CACHE_EXPRESSION,
    index, // 在 context.cached 中的索引
    value, // v-once节点的 ast
    isVNode, // block 或 vnode ?
    loc: locStub
  }
}
#+end_src

generator 阶段实现：[[https://github.com/gcclll/stb-vue-next/commit/8bacf14f156f0ca357d4c0efdbc75dc2120a3ec5][feat(add): v-once generator · gcclll/stb-vue-next@8bacf14]]

在 ~genNode()~ 中增加 ~JS_CACHE_EXPRESSION~ 类型的分支处理。

#+begin_src typescript
function genCacheExpression(node: CacheExpression, context: CodegenContext) {
  const { push, helper, indent, deindent, newline } = context
  if (node.isVNode) {
    indent()
    push(`${helper(SET_BLOCK_TRACKING)}(-1),`)
    newline()
  }

  push(`_cache[${node.index}] = `)
  genNode(node.value, context)
  if (node.isVNode) {
    push(`,`)
    newline()
    push(`${helper(SET_BLOCK_TRACKING)}(1),`)
    newline()
    push(`_cache[${node.index}]`)
    deindent()
  }
  push(`)`)
}
#+end_src

测试：

#+begin_src js
const {
  baseParse,
  baseCompile
} = require(process.env.PWD + '/../../static/js/vue/compiler-core.global.js')
 
const c = ( tpl, desc ) => {
  console.log(desc)
  const { code } = baseCompile(tpl)
  console.log(code)
}

c(`<div :id="foo" v-once />`, `>>> <div :id="foo" v-once />`)
c(`<div><div :id="foo" v-once /></div>`, `>>> 标签中嵌套使用`)
c(`<div><Comp :id="foo" v-once /></div>`, `>>> 在自定义组件上`)
#+end_src

#+RESULTS:
#+begin_example
>>> <div :id="foo" v-once />
const _Vue = Vue

return function render(_ctx, _cache) {
  with (_ctx) {
    const { setBlockTracking : _setBlockTracking, createVNode : _createVNode } = _Vue

    return _cache[1] || (
      _setBlockTracking(-1),
      _cache[1] = _createVNode("div", { id: foo }, null, 8 /* PROPS */, ["id"]),
      _setBlockTracking(1),
      _cache[1]
    )
  }
}
>>> 标签中嵌套使用
const _Vue = Vue

return function render(_ctx, _cache) {
  with (_ctx) {
    const { setBlockTracking : _setBlockTracking, createVNode : _createVNode, openBlock : _openBlock, createBlock : _createBlock } = _Vue

    return (_openBlock(), _createBlock("div", null, [
      _cache[1] || (
        _setBlockTracking(-1),
        _cache[1] = _createVNode("div", { id: foo }, null, 8 /* PROPS */, ["id"]),
        _setBlockTracking(1),
        _cache[1]
      )
    ]))
  }
}
>>> 在自定义组件上
const _Vue = Vue

return function render(_ctx, _cache) {
  with (_ctx) {
    const { setBlockTracking : _setBlockTracking, resolveComponent : _resolveComponent, createVNode : _createVNode, openBlock : _openBlock, createBlock : _createBlock } = _Vue

    return (_openBlock(), _createBlock("div", null, [
      _cache[1] || (
        _setBlockTracking(-1),
        _cache[1] = _createVNode(_component_Comp, { id: foo }, null, 8 /* PROPS */, ["id"]),
        _setBlockTracking(1),
        _cache[1]
      )
    ]))
  }
}
undefined
#+end_example

TODO 缺少： ~const _component_Comp = _resolveComponent("Comp")~
* acdea14 add v-if transform

~v-if~ 指令源码脑图可参考： [[/vue/vue-mind-map-house-cc/#pcg-v-if][05 v-if 指令(git:0a591b6)]]

对于 ~v-if|else|else-if~ 指令在 transform 阶段，转换收集 transformXxx 函数过程中，
会先针对指令进行处理，比如： ~v-else, v-else-if~ 指令的组件会被解析到 ~v-if~ 节
点的 ~node.branches[]~ 分支数组里面之后被删除，这些都是在收集 transformXxx 之前需要完成的。

包括 ~v-for~ 指令都需要经过 ~createStructuralDirectiveTransform()~ 函数封装一层
之后，返回对应的 ~transformXxx~ 函数。

#+begin_src typescript

export function createStructuralDirectiveTransform(
  name: string | RegExp,
  fn: StructuralDirectiveTransform
): NodeTransform {
  const matches = isString(name)
    ? (n: string) => n === name
    : (n: string) => name.test(n)

  return (node, context) => {
    if (node.type === NodeTypes.ELEMENT) {
      const { props } = node
      // structural directive transforms are not concerned with slots
      // as they are handled separately in vSlot.ts
      if (node.tagType === ElementTypes.TEMPLATE && props.some(isVSlot)) {
        return
      }
      const exitFns = []
      for (let i = 0; i < props.length; i++) {
        const prop = props[i]
        if (prop.type === NodeTypes.DIRECTIVE && matches(prop.name)) {
          // structural directives are removed to avoid infinite recursion
          // also we remove them *before* applying so that it can further
          // traverse itself in case it moves the node around
          props.splice(i, 1)
          i--
          const onExit = fn(node, prop, context)
          if (onExit) exitFns.push(onExit)
        }
      }
      return exitFns
    }
  }
}
#+end_src

通过 ~for (...)~ 将所有 v-if/v-for 相关指令经过他们自己的处理函数(比如：
~processIf~ ) 之后得到最终的 ~onExit~ 收集到 ~exitFns~ 中，在处理过程中随时会出
现节点的删除操作(比如： ~v-else~ 节点会在解析完之后被删除)，在正常的 traverse 过
程中这些节点都不会再存在。

#+begin_quote
PS: 正确理解应该属于移动操作，因为原始的 AST 结构并没改变，只不过是在原有的 AST
数结构中移除到新的 AST 节点下面了。
#+end_quote

** acdea14 v-if transform init

[[https://github.com/gcclll/stb-vue-next/commit/acdea1419d0361a4566a5f2a53ffc8bb1f941878][feat(init): v-if transform · gcclll/stb-vue-next@acdea14]]

#+begin_src typescript
export const transformIf = createStructuralDirectiveTransform(
  /^(if|else|else-if)$/,
  (node, dir, context) => {
    return processIf(node, dir, context, (ifNode, branch, isRoot) => {
      // TODO
      console.log(ifNode, branch, isRoot)
      return () => {}
    })
  }
)

export function processIf(
  node: ElementNode,
  dir: DirectiveNode,
  context: TransformContext,
  processCodegen?: (
    node: IfNode,
    branch: IfBranchNode,
    isRoot: boolean
  ) => (() => void) | undefined
) {}
#+end_src

初始化 v-if process 函数， processIf 函数里面会针对 v-if 节点甚至它的兄弟节点做
一系列操作，比如将下一个是 ~v-else~ 的兄弟节点删除移到自己的 ~branches[]~ 里面。
** 9039a3e v-if transform processIf

[[https://github.com/gcclll/stb-vue-next/commit/9039a3e567260d33c0bc617d4c58639b14b66fec][feat: v-if processIf · gcclll/stb-vue-next@9039a3e]]

这里增加了两个函数的实现：

1. processIf, 解析 if，创建 ~IF,9~ 类型的结构，替换 v-if 原来的 ast

   #+begin_src typescript
    const ifNode: IfNode = {
      type: NodeTypes.IF,
      loc: node.loc,
      branches: [branch]
    }
   #+end_src

   其中 branches 保存着所有 v-else, v-else-if 分支节点，这里其实是创建了一个默认
   的分支节点，因为 ~v-if~ 系列指令在 ~render~ 函数中是以三元运算符(~?:~)形式存
   在的，所以 if 后面必须要有一个分支，即 ~condition ? node1 : node2~ 中的 node2
   必须是个有效的值，才能正常使用 ~?:~ 运算符。

   所以，如果只有 ~v-if~ 指令的时候三元符后面的值起始是个空值(好像是 ~null~)
   
2. createIfBranch, 创建 ~v-if~ 的分支节点的
   
   #+begin_src typescript
function createIfBranch(node: ElementNode, dir: DirectiveNode): IfBranchNode {
  return {
    type: NodeTypes.IF_BRANCH,
    loc: node.loc,
    // condition ? v-if node : v-else node
    condition: dir.name === 'else' ? undefined : dir.exp,
    // 如果用的是 <template v-if="condition" ... 就需要 node.children
    // 因为 template 本身是不该被渲染的
    children:
      node.tagType === ElementTypes.TEMPLATE && !findDir(node, 'for')
        ? node.children
        : [node],
    // 对于 v-for, v-if/... 都应该给它个 key, 这里是用户编写是的提供的唯一 key
    // 如果没有解析器会默认生成一个全局唯一的 key
    userKey: findProp(node, `key`)
  }
}
   #+end_src

    注意看最后一个属性， ~v-if~ 分支也是需要一个 ~key~ 属性的。
** 44985b4 v-if transform createIfBranch

[[https://github.com/gcclll/stb-vue-next/commit/44985b49e031752a7c84464b29adb769050cb1fb][feat: v-if createIfBranch · gcclll/stb-vue-next@44985b4]]

#+begin_src typescript
export function createConditionalExpression(
  test: ConditionalExpression['test'],
  consequent: ConditionalExpression['consequent'],
  alternate: ConditionalExpression['alternate'],
  newline = true
) {
  return {
    type: NodeTypes.JS_CONDITIONAL_EXPRESSION,
    test,
    consequent,
    alternate,
    newline,
    loc: locStub
  }
}
#+end_src

这里的结构(~v-if~)在 render 函数中的对应关系：

~test ? consequent : alternate~

如果有 v-else-if 时候， ~alternate~ 结构会是个完整的 ~JS_CONDITIONAL_EXPRESSION~
，即： ~alternate: { test, consequent, alternate, ...}~ 所以：

~test ? consequent : test1 ? consequent 1 : alternate~

[[https://github.com/gcclll/stb-vue-next/commit/1e24eb7a30588690a4e83f888623b97f0085e899][fix: no v-if transform · gcclll/stb-vue-next@1e24eb7]]

到这里 v-if 指令 transform 阶段已经完成，测试结果：

#+begin_src js
const {
  baseParse,
  baseCompile
} = require(process.env.PWD + '/../../static/js/vue/compiler-core.global.js')
 
const { code, ast } = baseCompile(`<div v-if="ok"/>`)
console.log(`>>> ast.codegenNode 结果`)
console.log(ast.codegenNode)
#+end_src

#+RESULTS:
#+begin_example
>>> ast.codegenNode 结果
{
  type: 9,
  loc: {
    start: { column: 1, line: 1, offset: 0 },
    end: { column: 17, line: 1, offset: 16 },
    source: '<div v-if="ok"/>'
  },
  branches: [
    {
      type: 10,
      loc: [Object],
      condition: [Object],
      children: [Array],
      userKey: undefined
    }
  ],
  codegenNode: {
    type: 19,
    test: {
      type: 4,
      content: 'ok',
      isStatic: false,
      isConstant: false,
      loc: [Object]
    },
    consequent: {
      type: 13,
      tag: '"div"',
      props: [Object],
      children: undefined,
      patchFlag: undefined,
      dynamicProps: undefined,
      directives: undefined,
      isBlock: true,
      disableTracking: false,
      loc: [Object]
    },
    alternate: {
      type: 14,
      loc: [Object],
      callee: Symbol(createCommentVNode),
      arguments: [Array]
    },
    newline: true,
    loc: { source: '', start: [Object], end: [Object] }
  }
}
undefined
#+end_example

+RESULTS: 错误结果
#+begin_example
const _Vue = Vue

return function render(_ctx, _cache) {
  with (_ctx) {
    const { createVNode : _createVNode, openBlock : _openBlock, createBlock : _createBlock, createCommentVNode : _createCommentVNode } = _Vue

    return (_openBlock(), _createBlock("div", { key: 0 }))
  }
}
>>> ast.codegenNode 结果
{
  type: 13,
  tag: '"div"',
  props: {
    type: 15,
    loc: { source: '', start: [Object], end: [Object] },
    properties: [ [Object] ]
  },
  children: undefined,
  patchFlag: undefined,
  dynamicProps: undefined,
  directives: undefined,
  isBlock: true,
  disableTracking: false,
  loc: {
    start: { column: 1, line: 1, offset: 0 },
    end: { column: 17, line: 1, offset: 16 },
    source: '<div v-if="ok"/>'
  }
}
undefined
#+end_example

结果显示是不对的，因为创建的 ~IF~ 结构没有替换 ast 🌲中原来的节点，追踪后发现是
漏掉了 ~context.replaceNode(node)~ 的实现。

[[https://github.com/gcclll/stb-vue-next/commit/47c30d296b2f42759aea8de4730ae1802dbb6e32][fix: v-if codegenNode is incorrect · gcclll/stb-vue-next@47c30d2]]

traverseNode 中需要增加 ~case 9,IF~ 分支处理，遍历所有的 ~branches[]~ 。

[[https://github.com/gcclll/stb-vue-next/commit/179f06f716687166b167f5d190073bfe65a9393f][fix: v-if branches no codegenNode · gcclll/stb-vue-next@179f06f]]
** 742757e v-if generator

[[https://github.com/gcclll/stb-vue-next/commit/742757ebe2c4d1faaadf32b6606d43cef2900934?branch=742757ebe2c4d1faaadf32b6606d43cef2900934&diff=split][feat: v-if generator · gcclll/stb-vue-next@742757e]]

genNode 增加 ~JS_CONDITIONAL_EXPRESSION~ 分支处理(~genConditionalExpression~)

#+begin_src typescript
function genConditionalExpression(
  node: ConditionalExpression,
  context: CodegenContext
) {
  const { test, consequent, alternate, newline: needNewline } = node
  const { push, indent, deindent, newline } = context
  if (test.type === NodeTypes.SIMPLE_EXPRESSION) {
    // 非简单的标识符需要用括号，可能是表达式，所以需要 (a + b) ? ... : ...
    const needsParams = !isSimpleIdentifier(test.content)
    needsParams && push(`(`)
    genExpression(test, context)
    needsParams && push(`)`)
  } else {
    push(`(`)
    genNode(test, context)
    push(`)`)
  }

  needNewline && indent()
  context.indentLevel++
  needNewline || push(` `)
  push(`? `)
  genNode(consequent, context)
  context.indentLevel--
  needNewline && newline()
  needNewline || push(` `)
  push(`: `)
  const isNested = alternate.type === NodeTypes.JS_CONDITIONAL_EXPRESSION
  if (!isNested) {
    // 不是嵌套
    context.indentLevel++
  }
  genNode(alternate, context)
  if (!isNested) {
    context.indentLevel--
  }

  needNewline && deindent(true /* without newline */)
}
#+end_src

~genConditionalExpression~ 处理分为三个部分

1. ~test~ 生成条件表达式，这里是: ~ok~ ，如果是表达式需要括号： ~(a + b)~
2. ~consequent~ 用来生成 ~?~ 后面的表达式，即 ~ok~ 结果为 truth 时执行
3. ~alternate~ 用来生成 ~:~ 后面的表达式，即 ~ok~ 结果为 falsy 时执行

   ~alternate~ 中的结构可能也是个 ~JS_CONDITIONAL_EXPRESSION~ 结构，代表可能有
   ~v-else-if~ 分支，如： ~(a + b) ? node1 : (c + d) ? node2 : othernode~ 。


测试：
#+begin_src js

const {
  baseParse,
  baseCompile
} = require(process.env.PWD + '/../../static/js/vue/compiler-core.global.js')
 
const c = ( tpl, desc ) => {
  console.log(`>>> ` + desc)
  const { code } = baseCompile(tpl, { hoistStatic: true })
  console.log(code)
}

c(`<div v-if="ok"/>`, 'basic v-if')
c(`<template v-if="ok"><div/>hello<p/></template>`, 'template v-if')
#+end_src

#+RESULTS:
#+begin_example
>>> basic v-if
const _Vue = Vue
const { createVNode: _createVNode, createCommentVNode: _createCommentVNode } = _Vue

const _hoisted_1 = { key: 0 }

return function render(_ctx, _cache) {
  with (_ctx) {
    const { createVNode : _createVNode, openBlock : _openBlock, createBlock : _createBlock, createCommentVNode : _createCommentVNode } = _Vue

    return ok
      ? (_openBlock(), _createBlock("div", _hoisted_1))
      : _createCommentVNode("v-if", true)
  }
}
>>> template v-if
const _Vue = Vue
const { createVNode: _createVNode, createCommentVNode: _createCommentVNode, createTextVNode: _createTextVNode } = _Vue

const _hoisted_1 = /*#__PURE__*/_createVNode("div", null, null, -1 /* HOISTED */)
const _hoisted_2 = /*#__PURE__*/_createTextVNode("hello")
const _hoisted_3 = /*#__PURE__*/_createVNode("p", null, null, -1 /* HOISTED */)

return function render(_ctx, _cache) {
  with (_ctx) {
    const { createVNode : _createVNode, createTextVNode : _createTextVNode, Fragment : _Fragment, openBlock : _openBlock, createBlock : _createBlock, createCommentVNode : _createCommentVNode } = _Vue

    return ok
      ? (_openBlock(), _createBlock(_Fragment, { key: 0 }, [
          _hoisted_1,
          _hoisted_2,
          _hoisted_3
        ], 64 /* STABLE_FRAGMENT */))
      : _createCommentVNode("v-if", true)
  }
}
undefined
#+end_example

BUG: 这里居然少了个 ~_hoisted_2~ ???

#+begin_src js
[
  _hoisted_1,
  ,
  _hoisted_3
]
#+end_src

答： ~genNode()~ 中缺少对 ~4,TEXT_CALL~ 纯文本类型处理。

解：[[https://github.com/gcclll/stb-vue-next/commit/2372b5fb793da98a8330aa843137e852d5c375c1][fix: v-if TEXT_CALL gen node · gcclll/stb-vue-next@2372b5f]]

#+begin_comment
更多测试(~<f12>~)打开控制台查看 ->> 。
#+end_comment

#+begin_export html
<script>
l1(`transform`)
compile(`<div v-if="ok"/>`, 'basic v-if')
compile(`<template v-if="ok"><div/>hello<p/></template>`, 'template v-if')
compile(`<Component v-if="ok"></Component>`, 'component v-if')
</script>
#+end_export
** fa77b51 v-else/v-else-if

[[https://github.com/gcclll/stb-vue-next/commit/fa77b5146f3a3af6c8372012cb6a4d8482adb0c6][feat(add): v-else · gcclll/stb-vue-next@fa77b51]]

修改点：

1. ~processCodegen()~ 函数里面增加分支处理

  [[http://qiniu.ii6g.com/img/20201209164845.png]] 
    这里有一个需要注意的点: ~getParentCondition()~ 会一直查找
   ~JS_CONDITIONAL_EXPRESSION~ 类型节点的 ~alternate~ ，如果它依旧是个
   ~JS_CONDITIONAL_EXPRESSION~ 类型，说明是多级的 ~if/else~ 条件语句，直到找到最
   后一个不是为止。

   相当于 ： ~c1 ? cons1 : c2 ? cons2 : c3 ? cons3 : alt~ 会一直从 ~c1~ 节点开始
   查找直到找到最后的那个 ~alt~ 节点为止，然后将新的分支挂到 ~alt~ 后面组织成新
   的分支:  ~c1 ? cons1 : c2 ? cons2 : c3 ? cons3 : c4 ? cons4 : newalt~

   #+begin_comment
    PS: c1, c2, c3, c4 分别代表分支节点的 ~test~ ，最后追加的 ~c4 ? cons4 :
    newalt~ 三个对象都属于新加的节点， ~{test -> c4, cons4 -> consequent,
    alternate -> newalt }~
   #+end_comment

2. ~processIf()~ 里增加分支处理

   新增代码里有个 ~while~ 循环去从当前的分支节点开始在它的兄弟节点里面往回找，直
   到找到第一个 ~9,IF~ 节点，这中间不允许出现其他有效节点(除注释，空文本节点外)，
   因为 ~v-if/else~ 指令节点必须紧靠着。

   找到之后，要将当前分支节点删除，并且同时要去手动 ~traverseNode(branch)~ 一次，
   因为他在原来的 ast 树种删除了，所以原来的 traverse 进程不会遍历它，因此需要手
   动执行 traverse 去处理它及其孩子节点生成对应的 codegenNode 。

   然后将其 push 到 ~9,IF~ 节点的 ~node.branches~ 里面作为分支。

3. ~isSameKey(a,b)~ 新增，检测两个 key 属性是不是相同

   几种判定为不相同的条件：
   1) key 类型不同 (~a.type !== b.type~)

   2) key 值不同 (~a.value.content !== b.value.content~)

   3) key 如果是指令类型，检测表达式类型，静态属性异同(~isStatic~)

4. ~getParentCondition()~ 新增，递归 ~9，IF~ 节点的
   ~node.alternate.alternate.alternate...~ 直到找到 ~alternate~ 不是
   ~JS_CONDITIONAL_EXPRESSION~ 的情况
      

FIX: [[https://github.com/gcclll/stb-vue-next/commit/464d6815adf49596065440001e0bc5397ad2aa69][fix: v-else current node dont removed · gcclll/stb-vue-next@464d681]]

测试：
#+begin_src js

const {
  baseParse,
  baseCompile
} = require(process.env.PWD + '/../../static/js/vue/compiler-core.global.js')
 
const { code } = baseCompile(`<div v-if="ok"/><p v-else/>`)
console.log(code)
#+end_src

#+RESULTS:
#+begin_example
const _Vue = Vue

return function render(_ctx, _cache) {
  with (_ctx) {
    const { createVNode : _createVNode, openBlock : _openBlock, createBlock : _createBlock, createCommentVNode : _createCommentVNode } = _Vue

    return ok
      ? (_openBlock(), _createBlock("div", { key: 0 }))
      : (_openBlock(), _createBlock("p", { key: 1 }))
  }
}
undefined
#+end_example

#+begin_comment
更多测试(~<f12>~)打开控制台查看 ->> 。
#+end_comment

#+begin_export html
<script>
compile(`<div v-if="ok"/><p v-else/>`, 'v-if + v-else')
compile(`<template v-if="ok"><div/>hello<p/></template>`, 'template v-if')
compile(`<div v-if="ok"/><p v-else-if="orNot"/>`, 'v-if + v-else-if')
compile(`<div v-if="ok"/><p v-else-if="orNot"/><template v-else>fine</template>`, 'v-if + v-else-if + v-else')
compile(`
        <div v-if="ok"/>
        <!--foo-->
        <p v-else-if="orNot"/>
        <!--bar-->
        <template v-else>fine</template>
      `, 'comment between branches')

l1(`with prefixIdentifiers ... TODO`)
l1(`errors`)
compile(`<div v-else/>`, `<div v-else/> 没有匹配的 v-if`)
compile(`<div v-else-if="foo"/>`, `<div v-else-if="foo"/>, 没有匹配的 v-if`)
compile(`<div v-if="ok" :key="a + 1" /><div v-else :key="a + 1" />`,
`<div v-if="ok" :key="a + 1" /><div v-else :key="a + 1" />, 相同的 key`
)
log.red(`不允许不同分支使用相似的 key，因为 key 是指令属性，因此会对比它的类型及表达式`)
l1(`v-on with v-if`)
compile(`<button v-on="{ click: clickEvent }" v-if="true">w/ v-if</button>`, 'v-if 上使用 v-on 指令')
log.blue(`因为这里用的是无参数的 v-on 所以会导致所有属性被合并(_mergeProps(...))。`)
</script>

#+end_export

BUG: v-else-if 被解析成了 ~else~ 因为 parser 阶段匹配正则不对。
[[https://github.com/gcclll/stb-vue-next/commit/5b83d1c12a8580638d7952e712f7c6776a099a50][fix: parser v-else-if failed · gcclll/stb-vue-next@5b83d1c]]
* 6c82066 add v-for transform

[[https://github.com/gcclll/stb-vue-next/commit/3a1662ecde9600525088a48420e526b6f9820931][feat(init): v-for · gcclll/stb-vue-next@3a1662e]]

[[https://github.com/gcclll/stb-vue-next/commit/6c8206676c5d5229c853fb21cb91aad1a9f1d4a2][feat: v-for directive · gcclll/stb-vue-next@6c82066]]

v-for 指令实现过程中需要用到的几个函数：

- ~transformFor()~ 最终生成的 tranformXxx 函数
- ~createStructuralDirectiveTransform()~ 同 ~v-if~ 指令
- ~processFor()~ 处理 ~v-for~ 指令入口
- ~processCodegen()~ 同 ~v-if~ 用来生成 ~codegenNode~ 的函数
- ~parseForExpression()~ 将 ~v-for="item in items"~ 表达式解析成
  ~ForParseResult{source, value, key, index}~ 类型 AST 。
- ~createAliasExpression()~ 给 ~value, key, index~ 创建 ~SIMPLE_EXPRESSION~ 类型
  结构。
- ~createForLoopParams()~ 创建 ~_renderList~ 函数回调的参数 ~[value, key,
  index]~ ，如果没有使用默认变量： ~_~ 或 ~__~ ，如： ~(_, __, index)~


其中 ~parseForExpression()~ 函数是解析 ~v-for~ 表达式的核心函数，里面使用了三个
正则，用来匹配指令表达式：

1. ~const forAliasRE = /([\s\S]*?)\s+(?:in|of)\s+([\s\S]*)/~

   [[http://qiniu.ii6g.com/img/20201210155617.png]]

   匹配 ~v-for="item in items"~ 中的值部分

   #+begin_src js
   const re = /([\s\S]*?)\s+(?:in|of)\s+([\s\S]*)/
   const log = (params) => console.log(params.map((p, i) => `${i}, ${p}`).join(`\n`))
   log.title = console.log

   log.title(`>>> 匹配 item in items`)
   log("item in items".match(re))
   log.title(`>>> 匹配 (item, key) in items`)
   log("( item, key ) in items".match(re))
   #+end_src

   #+RESULTS:
   : >>> 匹配 item in items
   : 0, item in items
   : 1, item
   : 2, items
   : >>> 匹配 (item, key) in items
   : 0, ( item, key ) in items
   : 1, ( item, key )
   : 2, items
   : undefined

2. ~const forIteratorRE = /,([^,\}\]]*)(?:,([^,\}\]]*))?$/~

   [[http://qiniu.ii6g.com/img/20201210161642.png]]

   这个正则表达式用来匹配 ~(item, key) in items~ 中的 ~item~ 和 ~key~

   #+begin_src js
   const re = /,([^,\}\]]*)(?:,([^,\}\]]*))?$/ 
   const log = (params) => console.log(params.map((p, i) => `${i}, ${p}`).join(`\n`))
   log.title = console.log

   log.title(`>>> 匹配 'item, key, index' 中的 key 和 index`)
   log("item, key, index".match(re))
   log.title(`>>> 匹配 "item, key" 中的 key`)
   log("item, key".match(re))
   #+end_src

   #+RESULTS:
   : >>> 匹配 'item, key, index' 中的 key 和 index
   : 0, , key, index
   : 1,  key
   : 2,  index
   : >>> 匹配 "item, key" 中的 key
   : 0, , key
   : 1,  key
   : 2, undefined
   : undefined

3. ~const stripParensRE = /^\(|\)$/g~ 这个用来匹配 ~(item, key, index)~ 前后括号


~parseForExpression()~ 核心实现：

1. ~source~ 数据源， ~forAliasRE~ 匹配后的 ~RHS~ 值
   
   #+begin_src json
   source: {
    type: 4, // SIMPLE_EXPRESSION
    loc: { source: 'obj', start: [Object], end: [Object] },
    isConstant: false,
    content: 'obj',
    isStatic: false
   }
   #+end_src
2. ~value~ 的取值，在 AST 中对应 ~valueAlias~

   ~valueContent = valueContent.replace(forIteratorRE,
   '').trim()~

   通过匹配 ~key, index~ 的正则，反向替换得到 ~value~
    #+begin_src js
    const re = /,([^,\}\]]*)(?:,([^,\}\]]*))?$/
    console.log(`item, key, index`.replace(re, '').trim())
    console.log(`>>> 支持解构`)
    console.log(`[ id, value ], key, index`.replace(re, '').trim())
    #+end_src

    #+RESULTS:
    : item
    : >>> 支持解构
    : [ id, value ]
    : undefined

    解析后的结构：
    #+begin_src json
    valueAlias: {
        type: 4, // SIMPLE_EXPRESSION
        loc: { source: 'value', start: [Object], end: [Object] },
        isConstant: false,
        content: 'value',
        isStatic: false
    }
    #+end_src
3. ~key~ 取值处理，在 AST 中对应 ~keyAlias~

   #+begin_src js
    keyAlias: {
        type: 4,
        loc: { source: 'key', start: [Object], end: [Object] },
        isConstant: false,
        content: 'key',
        isStatic: false
    }
   #+end_src
4. ~index~ 取值处理，在 AST中对应 ~objectIndexAlias~

   #+begin_src js
    objectIndexAlias: {
        type: 4,
        loc: { source: 'index', start: [Object], end: [Object] },
        isConstant: false,
        content: 'index',
        isStatic: false
    }
   #+end_src


测试：
#+begin_src js
const {
  baseParse,
  baseCompile
} = require(process.env.PWD + '/../../static/js/vue/compiler-core.global.js')
 
const { ast } = baseCompile(`<span v-for="(value, key, index) in obj" />`)
const { source, valueAlias, keyAlias, objectIndexAlias, type } = ast.codegenNode
console.log(`type: ${type}`)
console.log(`>>> 数据源`)
console.log(source)
console.log(`>>> value`)
console.log(valueAlias)
console.log(`>>> key`)
console.log(keyAlias)
console.log(`>>> index`)
console.log(objectIndexAlias)
console.log(`>>> _renderList(obj, (value, key, index) => {...}) 第二个参数`)
console.log(ast.codegenNode.codegenNode.children.arguments[1])
#+end_src

#+RESULTS:
#+begin_example
type: 11
>>> 数据源
{
  type: 4,
  loc: {
    source: 'obj',
    start: { column: 37, line: 1, offset: 36 },
    end: { column: 40, line: 1, offset: 39 }
  },
  isConstant: false,
  content: 'obj',
  isStatic: false
}
>>> value
{
  type: 4,
  loc: {
    source: 'value',
    start: { column: 15, line: 1, offset: 14 },
    end: { column: 20, line: 1, offset: 19 }
  },
  isConstant: false,
  content: 'value',
  isStatic: false
}
>>> key
{
  type: 4,
  loc: {
    source: 'key',
    start: { column: 22, line: 1, offset: 21 },
    end: { column: 25, line: 1, offset: 24 }
  },
  isConstant: false,
  content: 'key',
  isStatic: false
}
>>> index
{
  type: 4,
  loc: {
    source: 'index',
    start: { column: 27, line: 1, offset: 26 },
    end: { column: 32, line: 1, offset: 31 }
  },
  isConstant: false,
  content: 'index',
  isStatic: false
}
>>> _renderList(obj, (value, key, index) => {...}) 第二个参数
{
  type: 18, // JS_FUNCTION_EXPRESSION
  params: [
    {
      type: 4,
      loc: [Object],
      isConstant: false,
      content: 'value',
      isStatic: false
    },
    {
      type: 4,
      loc: [Object],
      isConstant: false,
      content: 'key',
      isStatic: false
    },
    {
      type: 4,
      loc: [Object],
      isConstant: false,
      content: 'index',
      isStatic: false
    }
  ],
  returns: {
    type: 13,
    tag: '"span"',
    props: undefined,
    children: undefined,
    patchFlag: undefined,
    dynamicProps: undefined,
    directives: undefined,
    isBlock: true,
    disableTracking: false,
    loc: {
      start: [Object],
      end: [Object],
      source: '<span v-for="(value, key, index) in obj" />'
    }
  },
  newline: true,
  isSlot: false,
  loc: {
    source: '',
    start: { line: 1, column: 1, offset: 0 },
    end: { line: 1, column: 1, offset: 0 }
  }
}
undefined
#+end_example
* 39a20fe add v-for generator

[[https://github.com/gcclll/stb-vue-next/commit/39a20fef0001cf22de6632f96df474c87a127a9d][feat(add): v-for generator · gcclll/stb-vue-next@39a20fe]]

codegen 阶段新增对应的实现： ~18,JS_FUNCTION_EXPRESSION~

这个主要是用来解析 ~_renderList(source, (value, key, index) => { ... })~ 函数的
第二个参数的，这是个用来 render 列表项的函数。

测试：

#+begin_src js
const {
  baseParse,
  baseCompile
} = require(process.env.PWD + '/../../static/js/vue/compiler-core.global.js')

const { code } = baseCompile('<span v-for="(item) in items" />')
console.log(code)
#+end_src

#+RESULTS:
#+begin_example
const _Vue = Vue

return function render(_ctx, _cache) {
  with (_ctx) {
    const { renderList : _renderList, Fragment : _Fragment, openBlock : _openBlock, createBlock : _createBlock, createVNode : _createVNode } = _Vue

    return (_openBlock(true), _createBlock(_Fragment, null, _renderList(items, (item) => {
      return (_openBlock(), _createBlock("span"))
    )), 256 /* UNKEYED_FRAGMENT */))
  }
}
undefined
#+end_example

#+begin_quote
更多测试用例请 ~<f12>~ 打开控制台查看。
#+end_quote

#+begin_export html
<script>
l1(`v-for directive`)
compile(`<span v-for="(item) in items" />`, `basic v-for`)
compile('<span v-for="(item, key, index) in items" />', 'value + key + index')
compile('<span v-for="(, key, index) in items" />', `skipped value`)
compile('<span v-for="(item,,index) in items" />', `skipped key`)
compile('<span v-for="(,,index) in items" />', `skipped value & key`)
compile('<p v-for="item in 10">{{item}}</p>', `v-for with constant expression`)
compile(`<template v-for="item in items">hello<span/></template>`, `template v-for`)
compile('<template v-for="item in items"><slot/></template>', `template v-for w/ <slot/>`)
log.red(`TODO <slot> 待完成......`)
compile('<template v-for="item in items" :key="item.id"><span :id="item.id" /></template>', `template v-for key injection with single child`)
compile('<slot v-for="item in items"></slot>', `v-for on <slot/>`)
log.red(`TODO <slot> 待完成......`)
compile('<span v-for="(item) in items" :key="item" />', `keyed v-for`)
compile('<template v-for="item in items" :key="item">hello<span/></template>', `keyed template v-for`)
compile(`<div v-if="ok" v-for="i in list"/>`, `v-if + v-for`)
compile(`<template v-if="ok" v-for="i in list"/>`, 'v-if + v-for on <template>')
compile('<div v-for="i in list" v-foo/>', `v-for on element with custom directive`)

</script>

#+end_export
