#+TITLE: Vue3 æºç å¤´è„‘é£æš´ä¹‹ 3 â˜compiler-core - transform + codegen
#+DATE: <2020-11-30 10:07:11>
#+TAGS[]: vue, vue3, compiler-core, parser, compiler, transform
#+CATEGORIES[]: vue
#+LANGUAGE: zh-cn
#+STARTUP: indent shrink

#+begin_export html
<link href="https://fonts.goo~gleapis.com/cs~s2?family=ZCOOL+XiaoWei&display=swap" rel="stylesheet">
<kbd>
<font color="blue" size="3" style="font-family: 'ZCOOL XiaoWei', serif;">
  è¯—å·ï¼šå…­é“åŒå ï¼Œé­”åŠ«ä¸‡åƒï¼Œå¼•æ¸¡å¦‚æ¥ã€‚
</font>
</kbd><br><br>
#+end_export

[[/img/bdx/yiyeshu-001.jpg]]

@@html:<kbd>@@
*[[https://github.com/gcclll/stb-vue-next][stb-vue-next]] å®Œå…¨æ‹·è´äº [[https://github.com/vuejs/vue-next][vue-next]] ï¼Œä¸»è¦ç›®çš„å­¦ä¹ åŠå°è¯•åº”ç”¨äºæœºé¡¶ç›’ç¯å¢ƒã€‚*
@@html:</kbd>@@

@@html:<kbd>@@ *æœ¬æ–‡ä¾æ® commit è¿›ç¨‹è¿›è¡Œè®°å½•ï¼Œåªè¦è·Ÿç€ä¸‹é¢çš„è¿›ç¨‹èµ°ï¼Œä½ å°†èƒ½å®Œæ•´å®
ç° vue ast transform å’Œ codegen generate æœ€åç”Ÿæˆ render å‡½æ•° ğŸ’ƒğŸ¼ğŸ’ƒğŸ¼ğŸ’ƒğŸ¼* @@html:</kbd>@@

#+begin_quote
å£°æ˜ï¼šè¯¥ç¯‡ä¸º ts æºç (/commit/)ç‰ˆæœ¬ï¼Œä¹‹å‰åšè¿‡ä¸€éå®Œæ•´çš„ js ç‰ˆæœ¬ï¼Œæ›´è¯¦ç»†ï¼Œä¹Ÿå¯å‚è€ƒ

[[https://www.cheng92.com/vue/vue3-source-code-compiler-core-compile_ts/][Vue3.0 æºç ç³»åˆ—ï¼ˆäºŒï¼‰ç¼–è¯‘å™¨æ ¸å¿ƒ - Compiler core 3: compile.ts - è‹¥å¶çŸ¥ç§‹]]

ç”±äº transform é˜¶æ®µç›´æ¥æµ‹è¯•ä¸å¤ªå¥½ç›´è§‚çš„çœ‹å‡ºç»“æœï¼Œå› æ­¤è¿™é‡Œä¼šç»“åˆ codegen æ¥ä¸€èµ·å®
ç°ï¼Œå³è¯¥æ–‡åŒ…å« compiler-core ä¸‰å¤§é˜¶æ®µçš„æœ€åä¸¤ä¸ªé˜¶æ®µ(transform + generate)
#+end_quote

#+begin_export html
<script src="/js/vue/compiler-core.global.js"></script>
<script>
let i = 0, j = 0
const l1 = x => (j = 0, console.log(`%c >>> ${++i} ${x}`, 'background: #222; color: #bada55'))
const l2 = x => console.log(`%c > ${i}.${j++} ${x}`, 'background: #222; color: #bada55')
const log = (args) => console.log.apply(console, Array.isArray(args) ? args : [args])
log.blue = x => log([`%c ${x}`, `color: blue`])
log.red = x => log([`%c ${x}`, `color: red`])
const { baseCompile } = VueCompilerCore
const compile = (tpl, title, logAst = false) => {
    l2(title)
    if (!tpl) return null
    const { code, ast } = baseCompile(tpl, {
        onError: (e) => console.warn(e.message),
        hoistStatic: true,
        ...( compile.options || {} )
    })

    log([code])
    logAst && log(typeof logAst === 'function' ? logAst(ast) : ast)
    return ast
}
const c = (tpl, desc) => compile(tpl, desc, ast => ast.codegenNode.props)

</script>
#+end_export


* å…³é”®çŸ¥è¯†ç‚¹

1. [[#element-transform][ğŸ”—]] root.children.length = 1 ä¸”ç±»å‹æ˜¯ ELEMENTçš„æ—¶å€™å°† ~CREATE_VNODE~ æ”¹æˆ
   ~CREATE_BLOCK~   
2. [[#v-bind][ğŸ”—]] åŠ¨æ€å±æ€§ä¸ºè¡¨è¾¾å¼æ—¶ï¼Œä¸­é—´ä¸èƒ½æœ‰ç©ºæ ¼

   å¦‚ï¼š ~<div :[first + second]="third" ...~ æ˜¯éæ³•çš„ã€‚

   å› ä¸º ~parseAttribute()~ ä¸­çš„æ­£åˆ™æ˜¯ä¸æ”¯æŒä¸­é—´æœ‰ç©ºæ ¼çš„ï¼š

   å–å‚æ•°åçš„æ­£åˆ™ï¼š ~/^[^\t\r\n\f />][^\t\r\n\f />=]*/~
3. [[#v-bind][ğŸ”—]] v-bind æŒ‡ä»¤çš„å‡ ç§ç”¨æ³• ->
4. [[#slot-usage][ğŸ”—]] ç”¨æˆ·ç»„ä»¶ -> æ’æ§½å¤„ç† -> v-slot ä½¿ç”¨æ–¹æ³•
* è„‘å›¾

# [[/img/vue3/compiler-core/compiler-core-parser.svg]]

* e03a03c init transform module

[[https://github.com/gcclll/stb-vue-next/commit/e03a03c5d775ff9315cc027d88b0669a775cf590][feat(init): transform section Â· gcclll/stb-vue-next@e03a03c]]

åˆå§‹åŒ–å‡½æ•°ã€‚

#+begin_src typescript
export function createTransformContext(
  root: RootNode,
  {
    prefixIdentifiers = false,
    hoistStatic = false,
    cacheHandlers = false,
    nodeTransforms = [],
    directiveTransforms = {},
    transformHoist = null,
    isBuiltInComponent = NOOP,
    isCustomElement = NOOP,
    expressionPlugins = [],
    scopeId = null,
    ssr = false,
    ssrCssVars = ``,
    bindingMetadata = {},
    onError = defaultOnError
  }: TransformOptions
): TransformContext {
  const context: TransformContext = {

    // ...

    // methods
    helper(name) {
      context.helpers.add(name)
      return name
    },
    helperString(name) {
      return ``
    },
    replaceNode(node) {},
    removeNode(node) {},
    onNodeRemoved: () => {},
    addIdentifiers(exp) {
      // TODO
    },
    removeIdentifiers(exp) {
      // TODO
    },
    hoist(exp) {
      // TODO
      return {} as any
    },
    cache(exp, isVNode = false) {
      // TODO
      return {} as any
    }
  }

  return context
}

export function transform(root: RootNode, options: TransformOptions) {
  // TODO
}

// TODO
// createRootCodegen

export function traverseChildren(
  parent: ParentNode,
  context: TransformContext
) {
  // TODO
}

export function traverseNode(
  node: RootNode | TemplateChildNode,
  context: TransformContext
) {}

export function createStructuralDirectiveTransform(
  name: string | RegExp,
  fn: StructuralDirectiveTransform
): NodeTransform {
  return {} as any
}
#+end_src

* fc6f1f1 add transform function

[[https://github.com/gcclll/stb-vue-next/commit/fc6f1f112ae0e98b7e2e9a432d3dca1d6420307a][feat: transform function Â· gcclll/stb-vue-next@fc6f1f1]]

1. create transform context
2. traverse nodes, é€’å½’éå†æ‰€æœ‰èŠ‚ç‚¹ï¼Œæ„é€ å™¨ codegenNode
3. hoist static, é™æ€èŠ‚ç‚¹æå‡ï¼Œå¤ç”¨
4. ssr render, ä¸éœ€è¦åˆ›å»ºæ ¹èŠ‚ç‚¹ codegenNode
5. å¤åˆ¶ context å±æ€§åˆ° -> root


[[http://qiniu.ii6g.com/img/20201130231832.png]]

transform ä½œç”¨å°±æ˜¯é€šè¿‡ ~traverseNode()~ é€’å½’éå†æ‰€æœ‰èŠ‚ç‚¹ï¼Œè§£æï¼Œæ„é€ å¯¹åº”çš„èŠ‚ç‚¹
codegenNode ã€‚
* b0d72da add compile.ts>compile()

[[https://github.com/gcclll/stb-vue-next/commit/b0d72dac2738fd270b0ea7fe0bb33f47597a233b][feat(add): compile function Â· gcclll/stb-vue-next@b0d72da]]

å¯¹å¤–çš„ compile å‡½æ•°ï¼Œæ‰§è¡Œåˆ†ä¸ºä¸‰ä¸ªé˜¶æ®µï¼š

- ast(~baseParse()~) -> è§£æå‡º ast ç»“æ„
- transform(~transform()~) -> è§£æ ast å¾—åˆ° codegenNode
- codegen(~generate()~) -> å°† codegenNode è§£ææˆ Render å‡½æ•°


è¿™æ˜¯åé¢æµ‹è¯•çš„åŸºç¡€ï¼Œæ‰€ä»¥å¾—æå‰å®ç°äº†ã€‚

#+begin_src typescript

export function baseCompile(
  template: string | RootNode,
  options: CompilerOptions = {}
): CodegenResult {
  // const onError = options.onError || defaultOnError
  const isModuleMode = options.mode === 'module'

  const prefixIdentifiers =
    !__BROWSER__ && (options.prefixIdentifiers === true || isModuleMode)

  // TODO errors
  const ast = isString(template) ? baseParse(template, options) : template
  const [nodeTransforms, directiveTransforms] = getBaseTransformPreset(
    prefixIdentifiers
  )

  transform(
    ast,
    extend({}, options, {
      prefixIdentifiers,
      nodeTransforms: [
        ...nodeTransforms,
        ...(options.nodeTransforms || []) // user transforms
      ],
      directiveTransforms: extend(
        {},
        directiveTransforms,
        options.directiveTransforms || {}
      )
    })
  )

  return generate(
    ast,
    extend({}, options, {
      prefixIdentifiers
    })
  )
}
#+end_src

* 35248ce add exports maybe needs

[[https://github.com/gcclll/stb-vue-next/commit/35248ceece1aa8650b65f7f7ce13612660a65397][feat(add): compiler-core exports Â· gcclll/stb-vue-next@35248ce]]

å¢åŠ  compiler-core æ¨¡å—çš„å¯¼å‡º(~export~)å†…å®¹
* 05a223b add transform pure text
:PROPERTIES:
:COLUMNS: %CUSTOM_ID[(Custom Id)]
:CUSTOM_ID: pure-text
:END: 

[[https://github.com/gcclll/stb-vue-next/commit/05a223b7b1eb2ab877aec3b11feace484a7dde82][feat(add): transform pure text Â· gcclll/stb-vue-next@05a223b]]

#+begin_src typescript
export function traverseNode(
  node: RootNode | TemplateChildNode,
  context: TransformContext
) {
  // ä¿å­˜å½“å‰è¢«å¤„ç†çš„ èŠ‚ç‚¹
  context.currentNode = node
  // åº”ç”¨ transform æ’ä»¶
  const { nodeTransforms } = context
  // é’ˆå¯¹æ¯ä¸ªèŠ‚ç‚¹ä¼šæ”¶é›†åˆ°ä¸€ä¸ªæˆ–å¤šä¸ª transformXxx å‡½æ•°ï¼Œç”¨æ¥è§£æå®ƒçš„ ast
  // å¾—åˆ° codegenNode ï¼Œè¿™äº›å‡½æ•°ä¼šåœ¨å½“å‰çš„èŠ‚ç‚¹æ ‘è¢«é€’å½’éå†å®Œä¹‹åè°ƒç”¨
  const exitFns = []
  for (let i = 0; i < nodeTransforms.length; i++) {
    const onExit = nodeTransforms[i](node, context)
    if (onExit) {
      if (isArray(onExit)) {
        exitFns.push(...onExit)
      } else {
        exitFns.push(onExit)
      }
    }

    if (!context.currentNode) {
      // èŠ‚ç‚¹å¯èƒ½è¢«åˆ é™¤äº†ï¼Œæ¯”å¦‚ï¼š v-else-if, v-else ä¼šåˆå¹¶åˆ° v-if çš„ branches[] ä¸­
      return
    } else {
      // èŠ‚ç‚¹å¯èƒ½ä¼šæ›¿æ¢äº†ï¼Œéœ€è¦æ›´æ–°
      node = context.currentNode
    }
  }

  switch (
    node.type
    // TODO
  ) {
  }

  context.currentNode = node
  let i = exitFns.length
  while (i--) {
    exitFns[i]()
  }
}
#+end_src

transform é˜¶æ®µä»£ç æ¯•ç«Ÿçš„ä¸‰ä¸ªé˜¶æ®µ

1. æ”¶é›† transformXxx å‡½æ•°åˆ° exitFns
2. æ ¹æ® astèŠ‚ç‚¹ç±»å‹é€’å½’éå†å­å­™èŠ‚ç‚¹
3. æŒ‰ç…§æ”¶é›†æ—¶ç›¸åçš„é¡ºåºæ‰§è¡Œ exitFnsï¼Œè§£æå‡º codegenNode


ä¸ºäº†æ–¹ä¾¿æµ‹è¯•ï¼Œåœ¨ ~generate()~ ä¸­ç›´æ¥è¿”å› ast :
[[https://github.com/gcclll/stb-vue-next/commit/999d8d6b611443f8fd04282786d4a67f018d6319][test: generate return ast for test Â· gcclll/stb-vue-next@999d8d6]]
#+begin_src js
const {
  baseCompile
} = require(process.env.PWD + '/../../static/js/vue/compiler-core.global.js')

const res = baseCompile(`pure text`)
console.log(res.children[0])
#+end_src

+RESULTS:
#+begin_example
{
  type: 2,
  content: 'pure text',
  loc: {
    start: { column: 1, line: 1, offset: 0 },
    end: { column: 10, line: 1, offset: 9 },
    source: 'pure text'
  }
}
#+end_example

ç»“æœæ˜¾ç¤ºå¹¶æ²¡æœ‰ codegenNode å› ä¸ºåœ¨transformText ä¸­æ»¡è¶³æ¡ä»¶

~children.length === 1 && node.type === NodeTypes.ROOT~ è€Œç›´æ¥é€€å‡ºäº†ã€‚

è‡³äº ~root.codegenNode = undefined~ éœ€è¦å®ç° ~createRootCodegen()~

*** 61ce406 add createRootCodegen() to create root.codegenNode

[[https://github.com/gcclll/stb-vue-next/commit/61ce4066c9b49e11399da0b499220f426da444a0][feat: createRootCodegen() for pure text Â· gcclll/stb-vue-next@61ce406]]

åªå¢åŠ äº†é’ˆå¯¹é ELEMENT ç±»å‹æˆ–è€…å­©å­èŠ‚ç‚¹æ²¡æœ‰ codegenNode çš„æƒ…å†µå®ç°(å½“å‰ commit
æœ€ç®€åŒ–)ã€‚

å½“ root.children åªæœ‰ä¸€ä¸ªå­©å­èŠ‚ç‚¹ä¸”è¯¥èŠ‚ç‚¹æ²¡æœ‰è‡ªå·±çš„ codegenNode æ—¶å€™ï¼š
#+begin_src typescript
function createRootCodegen(root: RootNode, context: TransformContext) {
  // const { helper } = context
  const { children } = root
  if (children.length === 1) {
    // åªæœ‰ä¸€ä¸ªå­©å­èŠ‚ç‚¹ï¼Œç›´æ¥å–è¯¥å­©å­èŠ‚ç‚¹ çš„ codegenNode
    const child = children[0]
    if (isSingleElementRoot(root, child) && child.codegenNode) {
      // å½“ root èŠ‚ç‚¹ä¸‹åªæœ‰ä¸€ä¸ª element å…ƒç´ çš„å­©å­èŠ‚ç‚¹æ—¶ï¼Œä¸è¿›è¡Œæå‡
    } else {
      // - single <slot/>, IfNode, ForNode: already blocks.
      // - single text node: always patched.
      // root codegen falls through via genNode()

      root.codegenNode = child
    }
  } else if (children.length > 1) {
    // TODO
  } else {
    // no children = noop, codegen will return null.
  }
}
#+end_src

æµ‹è¯•
#+begin_src js
const {
  baseCompile
} = require(process.env.PWD + '/../../static/js/vue/compiler-core.global.js')

const res = baseCompile(`pure text`)
console.log(res)
#+end_src

#+RESULTS:
#+begin_example
{
  type: 0,
  children: [ { type: 2, content: 'pure text', loc: [Object] } ],
  helpers: [],
  components: [],
  directives: [],
  hoists: [],
  imports: [],
  cached: 0,
  temps: 0,
  codegenNode: {
    type: 2,
    content: 'pure text',
    loc: { start: [Object], end: [Object], source: 'pure text' }
  },
  loc: {
    start: { column: 1, line: 1, offset: 0 },
    end: { column: 10, line: 1, offset: 9 },
    source: 'pure text'
  }
}
#+end_example

æ³¨æ„ codegenNode å…¶å®å°±æ˜¯ ~root.children[0]~ èŠ‚ç‚¹æœ¬èº«ã€‚
*** b9f3cb7 add transform text

[[https://github.com/gcclll/stb-vue-next/commit/b9f3cb762e36e7f7090987db9cba77948845cdaf][feat: transformText function Â· gcclll/stb-vue-next@b9f3cb7]]

[[http://qiniu.ii6g.com/img/20201130150054.png]]

1. å¿…é¡»æ˜¯æ–‡æœ¬èŠ‚ç‚¹æˆ–è€…ç±»å‹æ˜¯ç»„åˆè¡¨è¾¾å¼ç±»å‹(~COMPOUND_EXPRESSION~)
2. patch flag å¤„ç†
3. æ„é€  TEXT_CALL ç±»å‹èŠ‚ç‚¹
4. codegenNode -> createCallExpression
*** f6d5271 add generate text codegen

codegen é˜¶æ®µç›®çš„æ˜¯å°† codegenNode è§£ææˆ Render å‡½æ•°çš„ä¸€éƒ¨åˆ†ã€‚

1. /f6d5271/ add ~createCodegenContext()~

   [[https://github.com/gcclll/stb-vue-next/commit/f6d52713ae8154d438c2ed94641525fa3c05edef][feat(add): codegen context creator Â· gcclll/stb-vue-next@f6d5271]]

   ä¸Šä¸‹æ–‡å¯¹è±¡åˆ›å»ºå‡½æ•°ï¼Œé‡ç‚¹æ–¹æ³•æœ‰ä¸¤ä¸ª(~push(code, node)~ å’Œ ~helper(key)~)ã€‚

   FIX1: lint errors, [[https://github.com/gcclll/stb-vue-next/commit/0ac8c2f4b6b5022caa0f83a7f850226c30a99d33][fix: f6d5271 lint errors Â· gcclll/stb-vue-next@0ac8c2f]]

2. /2ef2699/ å¢åŠ  text codegen generator å®ç°

   [[https://github.com/gcclll/stb-vue-next/commit/2ef2699b95457be4456b736b70467b98bf240ddd][feat: generate text codegen Â· gcclll/stb-vue-next@2ef2699]]

   è¯¥éƒ¨åˆ†æ¶‰åŠåˆ°ä¸€ä¸ªè¾ƒä¸ºå®Œæ•´çš„ codegen generator æµç¨‹ï¼Œæ‰€ä»¥å¢åŠ å†…å®¹è¾ƒå¤šï¼Œå› æ­¤è¿™é‡Œ
   ä¸ç›´æ¥è´´ä»£ç äº†ï¼Œè¯·ç‚¹å‡»ä¸Šé¢ commit é“¾æ¥æŸ¥çœ‹å®é™…å¢åŠ çš„æºç ã€‚

   å¤„ç†æµç¨‹ï¼š

   - preamble å¤„ç†ï¼Œå¦‚æœæ˜¯ Node ç¯å¢ƒéœ€è¦é€šè¿‡ ~import { ...} from 'vue'~ è¯­æ³•ï¼Œå¦‚
     æœæ˜¯æµè§ˆå™¨ç¯å¢ƒä½¿ç”¨ ~const { ... } = Vue~ è§£æ„è¯­æ³•ã€‚

   - æ˜¯å¦ä½¿ç”¨ ~with() {}~ ä½œç”¨åŸŸè¯­æ³•ï¼Œé»˜è®¤æ˜¯ä½¿ç”¨çš„

   - ~return ...~ è¿”å›å®é™… render å‡½æ•°è¿”å›ç»“æœï¼Œè¿™é‡Œå°†è¿”å›æœ€åè¢«æ¸²æŸ“çš„ DOM ç»“æ„ã€‚

   - ~genNode()~ é€’å½’å¤„ç† ast ç”Ÿæˆ render å‡½æ•°çš„å¯¹åº”éƒ¨åˆ†ä»£ç 

3. /6b901f9/ å¢åŠ  node ç¯å¢ƒæˆ– module ç¯å¢ƒå¤„ç†(~genModulePreamble~)

   [[https://github.com/gcclll/stb-vue-next/commit/6b901f9f3d8af3dc415d31a6c5027d8e262fa74f][feat: module preamble Â· gcclll/stb-vue-next@6b901f9]]
   modue preamble : ~export { ... } from 'vue'~
   function preamble: ~const { ... } = Vue~


é‡ç‚¹å¢åŠ çš„ genXxx å‡½æ•° ~genText(node, context)~ ä¸“é—¨ç”¨æ¥å¤„ç†æ–‡æœ¬èŠ‚ç‚¹çš„ã€‚

#+begin_src typescript
function genText(
  node: TextNode | SimpleExpressionNode,
  context: CodegenContext
) {
  context.push(JSON.stringify(node.content), node)
}
#+end_src
*** æµ‹è¯•

æµ‹è¯•å°†åˆ†ä¸ºä¸¤ä¸ªéƒ¨åˆ†ï¼Œ
**** function preamble å½¢å¼(ä½œä¸ºå…¨å±€ ~Vue~ å¯¹è±¡å¼•å…¥)

#+begin_src js
const {
  baseCompile
} = require(process.env.PWD + '/../../static/js/vue/compiler-core.global.js')

const res = baseCompile(`pure text`)
console.log(res.code)
#+end_src

#+RESULTS:
:
: return function render(_ctx, _cache) {
:   with (_ctx) {
:     return "pure text"
:   }
: }
: undefined

[[https://github.com/gcclll/stb-vue-next/commit/6b3bd2e4c20dc7a325ff7c0575c127595da91b42][fix: less the last } paren Â· gcclll/stb-vue-next@6b3bd2e]]

**** module preamble å½¢å¼(*es6* æ¨¡å—åŒ–å¯¼å‡ºå¯¼å…¥)

#+begin_src js
const {
  baseParse,
  baseCompile
} = require(process.env.PWD + '/../../static/js/vue/compiler-core.global.js')

const res = baseCompile(`pure text`, { mode: 'module' })
console.log(res.code)
#+end_src

#+RESULTS:
:
: return function render(_ctx, _cache) {
:   return "pure text"
: }
: undefined

è¿™é‡Œå¥½åƒçœ‹ä¸å‡ºå•¥åŒºåˆ«ï¼Œåé¢å†è¯´å§ã€‚
* 2f749b2 add interpolation generator
:PROPERTIES:
:COLUMNS: %CUSTOM_ID[(Custom Id)]
:CUSTOM_ID: interpolation
:END: 

[[https://github.com/gcclll/stb-vue-next/commit/2f749b2a5d0872713704a52943bb18b550c559c0][feat(add): transform -> generate interpolation Â· gcclll/stb-vue-next@2f749b2]]

#+begin_src js
const {
  baseParse,
  baseCompile
} = require(process.env.PWD + '/../../static/js/vue/compiler-core.global.js')

const res = baseCompile(`{{ a > b }}`)
console.log(res.code)
console.log(res.ast.children[0])
#+end_src

è¿™é‡Œå®ç°åˆ†å‡ ä¸ªéƒ¨åˆ†ï¼š

*transform*: traverseNode() å¢åŠ å¯¹æ’å€¼çš„å¤„ç†ï¼Œåé¢å¢åŠ äº† traverseChildren å¤„ç†ï¼Œå› ä¸ºæ‰€æœ‰çš„
ast éƒ½æ˜¯æŒ‚åœ¨ ~root.children~ ä¸­çš„ï¼Œæ‰€ä»¥æœ€å¼€å§‹è§£æçš„æ˜¯ ~ROOT~ èŠ‚ç‚¹ï¼Œå› æ­¤è¿™é‡Œå¿…é¡»
è¦å¢åŠ  ~ROOT~ ç±»å‹çš„è§£æï¼Œè°ƒç”¨ ~traverseChildren(node, ctx)~ å»é€’å½’è§£æ ~root.children~

#+begin_quote
transform() -> traverseNode(): ROOT è§£æ -> traverseChildren() ->
traverseNode(): INTERPOLATION
#+end_quote

æ–°å¢æ ¸å¿ƒå‡½æ•°ï¼šéå†æ‰€æœ‰ ~children[]~ è°ƒç”¨ ~traverseNode()~ 
#+begin_src typescript
export function traverseChildren(
  parent: ParentNode,
  context: TransformContext
) {
  // TODO	  let i = 0
  const nodeRemoved = () => {
    i--
  }

  for (; i < parent.children.length; i++) {
    const child = parent.children[i]
    if (isString(child)) continue
    context.parent = parent
    context.childIndex = i // æ–¹ä¾¿åœ¨ transformXxx å‡½æ•°ä¸­èƒ½å¿«é€Ÿå®šä½åˆ°å½“å‰èŠ‚ç‚¹
    context.onNodeRemoved = nodeRemoved
    traverseNode(child, context)
  }
}
#+end_src

[[http://qiniu.ii6g.com/img/20201201155917.png]]

*codegen*: ~genNode()~ ä¸­æ–°å¢ ~INTERPOLATION~ å’Œ ~SIMPLE_EXPRESSION~ ç±»å‹çš„å¤„ç†ï¼Œ
 å› ä¸º INTERPOLATION çš„ ast.content(å¦‚ä¸Šé¢ä»£ç æ‰§è¡Œç»“æœ) ç±»å‹æ˜¯ SIMPLE_EXPRESSIONã€‚

 #+begin_src typescript
function genExpression(node: SimpleExpressionNode, context: CodegenContext) {
  const { content, isStatic } = node
  context.push(isStatic ? JSON.stringify(content) : content, node)
}

function genInterpolation(node: InterpolationNode, context: CodegenContext) {
  const { push, helper, pure } = context
  if (pure) push(PURE_ANNOTATION)
  push(`${helper(TO_DISPLAY_STRING)}(`)
  genNode(node.content, context)
  push(')')
}
 #+end_src

-----

[[https://github.com/gcclll/stb-vue-next/commit/2d0e2a6f7610059f37aef798d37eaafdf8c43377][feat(add): comment generator Â· gcclll/stb-vue-next@2d0e2a6]]
 
æ‹“å±•ï¼šadd comment generator

#+begin_src js

const {
  baseParse,
  baseCompile
} = require(process.env.PWD + '/../../static/js/vue/compiler-core.global.js')

const res = baseCompile(`<!-- i'm a comment -->`)
console.log(res.code)
#+end_src

#+RESULTS:
#+begin_example
const _Vue = Vue

return function render(_ctx, _cache) {
  with (_ctx) {
    const { createCommentVNode : _createCommentVNode } = _Vue

    return _createCommentVNode(" i'm a comment ")
  }
}
undefined
#+end_example
* add element transfrom and generator
:PROPERTIES:
:COLUMNS: %CUSTOM_ID[(Custom Id)]
:CUSTOM_ID: element
:END: 

** å‡†å¤‡å·¥ä½œ ~compiler-core/src/utils.ts~

[[https://github.com/gcclll/stb-vue-next/commit/9436d8fe155767391a278807ae02a6ae9eff94a3][feat: utils for compiler-core Â· gcclll/stb-vue-next@9436d8f]]

ç›¸å…³æ­£åˆ™ï¼š ~const memberExpRE = /^[A-Za-z_$][\w$]*(?:\s*\.\s*[A-Za-z_$][\w$]*|\[[^\]]+\])*$/~

[[http://qiniu.ii6g.com/img/image.png]]

[[https://github.com/gcclll/stb-vue-next/commit/2265e466e6daea95614d5fe96968b30ff11a2e19][feat(add): resolveComponentType Â· gcclll/stb-vue-next@2265e46]]

è§£æå‡ºç»„ä»¶çš„ç±»å‹ï¼Œå¤§ä½“åˆ†ä¸ºå››ç±»ï¼š

1. åŠ¨æ€ç»„ä»¶ï¼š ~<component is="xx">~ æˆ– ~<component v-is="xx">~
2. å†…ç½®ç»„ä»¶ï¼š ~Teleport, Transition, KeepAlive, Suspense~
3. ç”¨æˆ·ç»„ä»¶ï¼š ~$setup[]~ ä¸Šçš„ç»„ä»¶
4. ç”¨æˆ·ç»„ä»¶ï¼š ~context.components[]~ ä¸Šçš„ç»„ä»¶

** 87339d2 add element transform
:PROPERTIES:
:COLUMNS: %CUSTOM_ID[(Custom Id)]
:CUSTOM_ID: element-transform
:END: 

[[https://github.com/gcclll/stb-vue-next/commit/87339d25f1fa43ed5e0a13dabc60fec9479451c1][feat(add): transformElement function Â· gcclll/stb-vue-next@87339d2]]

æ™®é€šæ ‡ç­¾çš„ transform codegenNodeé˜¶æ®µã€‚

1. add ~createVNodeCall()~ å‡½æ•°ï¼Œåˆ›å»ºåŸºæœ¬çš„ ELEMENT ç±»å‹èŠ‚ç‚¹ codegenNode

  æ ¹æ® ~isBlock~ å‚æ•°å†³å®šä½¿ç”¨ BLOCK å‡½æ•°è¿˜æ˜¯ VNODE å‡½æ•°ã€‚
   
  #+begin_src typescript
   export function createVNodeCall(
       context: TransformContext | null,
       tag: VNodeCall['tag'],
       props?: VNodeCall['props'],
       children?: VNodeCall['children'],
       patchFlag?: VNodeCall['patchFlag'],
       dynamicProps?: VNodeCall['dynamicProps'],
       directives?: VNodeCall['directives'],
       isBlock: VNodeCall['isBlock'] = false,
       disableTracking: VNodeCall['disableTracking'] = false,
       loc = locStub
   ): VNodeCall {
   if (context) {
       if (isBlock) {
           context.helper(OPEN_BLOCK)
           context.helper(CREATE_BLOCK)
       } else {
           context.helper(CREATE_VNODE)
       }
   }

   return {
       type: NodeTypes.VNODE_CALL,
       tag,
       props,
       children,
       patchFlag,
       dynamicProps,
       directives,
       isBlock,
       disableTracking,
       loc
   }
 }
 #+end_src

2. add ~createObjectExpression()~ å‡½æ•°

   #+begin_src typescript
    export function createObjectExpression(
        properties: ObjectExpression['properties'],
        loc: SourceLocation = locStub
    ): ObjectExpression {
    return {
        type: NodeTypes.JS_OBJECT_EXPRESSION,
        loc,
        properties
    }
    }
   #+end_src

3. add ~getStaticType()~ åˆ¤æ–­èŠ‚ç‚¹æ˜¯å¦éœ€è¦åšé™æ€æå‡å¤„ç†

4. add ~transformElement: postTransformElement()~ å‡½æ•°

5. add ~stringifyDynamicPropNames()~ å°†å±æ€§è½¬æˆæ•°ç»„ç»“æ„


æµ‹è¯•ï¼š
#+begin_src js
const {
  baseParse,
  baseCompile
} = require(process.env.PWD + '/../../static/js/vue/compiler-core.global.js')
 
const res = baseCompile(`<div></div>`)
console.log('root codegenNode: ', res.ast.codegenNode)
console.log(res.code)
#+end_src

#+RESULTS:
#+begin_example
root codegenNode:  undefined
const _Vue = Vue

return function render(_ctx, _cache) {
  with (_ctx) {
    const { createVNode : _createVNode } = _Vue

    return null
  }
}
undefined
#+end_example

æ­£ç¡®ç»“æœï¼š
#+begin_example
Æ’ render(_ctx, _cache) {
  with (_ctx) {
    const { createVNode: _createVNode, openBlock: _openBlock, createBlock: _createBlock } = _Vue

    return (_openBlock(), _createBlock("div"))
  }
}
#+end_example

é—®é¢˜ï¼š
1. æ ¹èŠ‚ç‚¹ codegenNode ä¸ºç©º
2. render å‡½æ•°å†…æ²¡æœ‰ ~openBlock, createBlock~ å¯¼å‡º
3. return åé¢æ²¡å†…å®¹(è¿™æ˜¯ generator èŒƒç•´ï¼Œæ­¤èŠ‚ä¸å±•å¼€)


é—®é¢˜1ï¼Œ2éƒ½æ˜¯åœ¨åŒä¸€ä¸ªåœ°æ–¹å¤„ç†çš„ï¼Œå› ä¸ºå½“ ROOT èŠ‚ç‚¹åªæœ‰ä¸€ä¸ªå­©å­èŠ‚ç‚¹çš„æ—¶å€™ï¼Œä¸ä¼šç”¨
CREATE_VNODE åˆ›å»ºï¼Œè€Œæ˜¯æ”¹ç”¨ CREATE_BLOCKï¼Œæ‰€ä»¥è¿™ä¸¤ä¸ªé—®é¢˜ä¸€èµ·å¤„ç†

FIX 1,2: [[https://github.com/gcclll/stb-vue-next/commit/97cf290240fa937f167f8aadd6e6527744da4cbe][fix: no export open/create block function from Vue Â· gcclll/stb-vue-next@97cf290]]

ä¿®æ”¹ï¼š ~createRootCodegen(root: RootNode, context: TransformContext)~

** 2f58786 add element generator

[[https://github.com/gcclll/stb-vue-next/commit/2f58786c56986672c6b7cabdcd541363bf05b4dd][feat: element generator Â· gcclll/stb-vue-next@2f58786]]

è·¯å¾„ï¼š

1. ~VNODE_CALL~ ->

2. ~genVNodeCall()~ ->

3. ~genNodeList([], ctx)~ ->

    - string: ~push(node)~
    - array: ~genNodeListAsArray(node, ctx)~ 
    - other: ~genNode(node, ctx)~


æµ‹è¯•:
#+begin_src js
const {
  baseParse,
  baseCompile
} = require(process.env.PWD + '/../../static/js/vue/compiler-core.global.js')
 
const res = baseCompile(`<div></div>`)
console.log('root codegenNode: ', res.ast.codegenNode)
console.log(res.code)
#+end_src

#+RESULTS:
#+begin_example
root codegenNode:  {
  type: 13,
  tag: '"div"',
  props: undefined,
  children: undefined,
  patchFlag: undefined,
  dynamicProps: undefined,
  directives: undefined,
  isBlock: true,
  disableTracking: false,
  loc: {
    start: { column: 1, line: 1, offset: 0 },
    end: { column: 12, line: 1, offset: 11 },
    source: '<div></div>'
  }
}
const _Vue = Vue

return function render(_ctx, _cache) {
  with (_ctx) {
    const { createVNode : _createVNode, openBlock : _openBlock, createBlock : _createBlock } = _Vue

    return (_openBlock(), _createBlock("div"))
  }
}
#+end_example
** 05ca2f8 root.children æœ‰å¤šä¸ªå­©å­

[[https://github.com/gcclll/stb-vue-next/commit/05ca2f8bedf21d146a01ad5694c727bbe776145c][feat: root.children has multi child Â· gcclll/stb-vue-next@05ca2f8 Â· GitHub]]

å½“æœ‰å¤šä¸ªå­©å­èŠ‚ç‚¹çš„æ—¶å€™ï¼Œä¼šåˆ›å»ºä¸€ä¸ª ~fragment~ å°†ä»–ä»¬åŒ…èµ·æ¥ã€‚

[[http://qiniu.ii6g.com/img/20201201232048.png]]

FIX: æ­»å¾ªç¯ï¼Œ ~genNode(node.codegenNode, ctx)~

[[http://qiniu.ii6g.com/img/20201201232120.png]]

æµ‹è¯•ï¼š

#+begin_src js

const {
  baseParse,
  baseCompile
} = require(process.env.PWD + '/../../static/js/vue/compiler-core.global.js')
 
const res = baseCompile(`<div></div><div></div>`)
console.log(res.code)
#+end_src

#+RESULTS:
#+begin_example
const _Vue = Vue

return function render(_ctx, _cache) {
  with (_ctx) {
    const { createVNode : _createVNode, Fragment : _Fragment, openBlock : _openBlock, createBlock : _createBlock } = _Vue

    return (_openBlock(), _createBlock(_Fragment,null,[
      _createVNode("div"),
      _createVNode("div")
    ],64 /* STABLE_FRAGMENT */))
  }
}
undefined
#+end_example

FIX: å‚æ•°ä¹‹é—´å°‘äº†ç©ºæ ¼([[https://github.com/gcclll/stb-vue-next/commit/05ca2f8bedf21d146a01ad5694c727bbe776145c?branch=05ca2f8bedf21d146a01ad5694c727bbe776145c&diff=split][feat: root.children has multi child Â· gcclll/stb-vue-next@05ca2f8]])

æ­£è§£ï¼š
#+begin_example
const _Vue = Vue
const { createVNode: _createVNode } = _Vue

const _hoisted_1 = /*#__PURE__*/_createVNode("div", null, null, -1 /* HOISTED */)
const _hoisted_2 = /*#__PURE__*/_createVNode("div", null, null, -1 /* HOISTED */)

return function render(_ctx, _cache) {
  with (_ctx) {
    const { createVNode: _createVNode, Fragment: _Fragment, openBlock: _openBlock, createBlock: _createBlock } = _Vue

    return (_openBlock(), _createBlock(_Fragment, null, [
      _hoisted_1,
      _hoisted_2
    ], 64 /* STABLE_FRAGMENT */))
  }
}
#+end_example

æ­£ç¡®ç­”æ¡ˆä¸­åšäº†é™æ€æå‡å¤„ç†ï¼Œä»£ç åœ¨ ~transform()~ å‡½æ•°ä¸­ ~hoistStatic(root,
context)~ çš„è°ƒç”¨ï¼Œä¼šä» ROOT èŠ‚ç‚¹å¼€å§‹éå†ï¼Œå°†éœ€è¦æå‡çš„èŠ‚ç‚¹è¿›è¡Œæå‡å¤„ç†ã€‚
* 7cb3dbf add hoist static é™æ€æå‡

æ»¡è¶³æå‡çš„ä¸‰ç§æƒ…å†µï¼š

1. tag å’Œ tagType éƒ½æ˜¯ ELEMENT ä¸”æ•´æ£µæ ‘éƒ½æ˜¯é™æ€
2. åŒ…å«åŠ¨æ€å­©å­èŠ‚ç‚¹ï¼Œä½†æ˜¯æœ‰é™æ€å±æ€§çš„ï¼Œå°†å±æ€§æå‡
3. çº¯æ–‡æœ¬èŠ‚ç‚¹


[[https://github.com/gcclll/stb-vue-next/commit/7d7dbd4e20198e73df5c93804dce122656252c8f][feat(add): hoist static Â· gcclll/stb-vue-next@7d7dbd4]]

transform() ä¸­å¢åŠ é™æ€æå‡å¤„ç†ï¼š

#+begin_src typescript
if (options.hoistStatic) {
  hoistStatic(root, context)
}
#+end_src

[[https://github.com/gcclll/stb-vue-next/commit/7cb3dbf94bd17c5af68dc55103a8031da28be55b][feat: hoist static Â· gcclll/stb-vue-next@7cb3dbf]]

1. ä¿®æ”¹ ~genFunctionPreamble(ast: RootNode, context: CodegenContext)~ è§£æ„å‡ºéœ€è¦ç”¨åˆ°çš„å‡½æ•°(~_createVNode~)

   [[/img/commit/diff-hoist-decon-functions.png]]

2. å¢åŠ  ~genHoists()~ å‡½æ•°ï¼Œç”Ÿæˆ ~ast.hoists~ ä¸­éœ€è¦æå‡çš„èŠ‚ç‚¹

    #+begin_src typescript
    function genHoists(hoists: (JSChildNode | null)[], context: CodegenContext) {
    if (!hoists.length) {
        return
    }

    context.pure = true
    const { push, newline, helper, scopeId, mode } = context
    const genScopeId = !__BROWSER__ && scopeId != null && mode !== 'function'
    newline()

    // push scope Id before initializing hoisted vnodes so that these vnodes
    // get the proper scopeId as well.
    if (genScopeId) {
        push(`${helper(PUSH_SCOPE_ID)}("${scopeId}")`)
        newline()
    }

    hoists.forEach((exp, i) => {
        if (exp) {
        push(`const _hoisted_${i + 1} = `)
        genNode(exp, context)
        newline()
        }
    })

    if (genScopeId) {
        push(`${helper(POP_SCOPE_ID)}()`)
        newline()
    }

    context.pure = false
    }
    #+end_src


æµ‹è¯•ï¼š
#+begin_src js
const {
  baseParse,
  baseCompile
} = require(process.env.PWD + '/../../static/js/vue/compiler-core.global.js')
 
const res = baseCompile(`<div></div><div></div>`, { hoistStatic: true })
console.log(res.code)
#+end_src

#+RESULTS:
#+begin_example
const _Vue = Vue
const { createVNode: _createVNode } = _Vue

const _hoisted_1 = /*#__PURE__*/_createVNode("div", null, null, -1 /* HOISTED */)
const _hoisted_2 = /*#__PURE__*/_createVNode("div", null, null, -1 /* HOISTED */)

return function render(_ctx, _cache) {
  with (_ctx) {
    const { createVNode : _createVNode, Fragment : _Fragment, openBlock : _openBlock, createBlock : _createBlock } = _Vue

    return (_openBlock(), _createBlock(_Fragment, null, [
      _hoisted_1,
      _hoisted_2
    ], 64 /* STABLE_FRAGMENT */))
  }
}
undefined
#+end_example

#+begin_quote
PS: é™æ€å±æ€§æå‡ [[https://github.com/gcclll/stb-vue-next/commit/1e58eeb605b0dc88c90dac550b927f89dd18e07d][feat: props hoist static Â· gcclll/stb-vue-next@1e58eeb]]
#+end_quote

* prop transform and generator

åœ¨è¿™ä¹‹å‰æˆ‘ä»¬å®Œæˆäº†ä»¥ä¸‹å‡ ä¸ªåŸºæœ¬éƒ¨åˆ†ï¼š

- [[#pure-text][æ–‡æœ¬]]
- [[#interpolation][æ’å€¼]]
- [[#element][æ™®é€šæ ‡ç­¾(ä¸€ä¸ªå’Œå¤šä¸ª)]]


æ¥ä¸‹æ¥éœ€è¦å®Œæˆå±æ€§çš„è§£ææ‰èƒ½è¿›è¡Œä¸‹ä¸€æ­¥ï¼Œå› ä¸º ~v-if, v-for, v-slot, ...~ éƒ½éœ€è¦å±
æ€§è§£æã€‚

å±æ€§è½¬æ¢è¿™é‡Œå¼‚å¸¸å¤æ‚ï¼Œéœ€è¦æ…¢æ…¢å±•å¼€æ¥è®²ï¼Œå¹¶ä¸”æ¶‰åŠåˆ°å„ç§æŒ‡ä»¤ï¼Œå› æ­¤å¯¹äºå®Œæ•´çš„æµ‹è¯•éœ€
è¦ç­‰æ‰€æœ‰æŒ‡ä»¤ transform å®Œæˆä¹‹åå†è¿›è¡Œã€‚

** 1792f93 props transform

*** buildProps

[[https://github.com/gcclll/stb-vue-next/commit/1792f93b26aff5d0db60d83b946a83fb0fa6e776][feat(add): transform props Â· gcclll/stb-vue-next@1792f93]]


- å°† ~codegenNode.props~ æ„å»ºæˆ å¦‚ä¸‹ç»“æ„ï¼š

  #+begin_src json
{
    "type":15,
    "properties":[
        {
            "type":16,
            "key":{
                "type":4,
                "isConstant":false,
                "content":"class",
                "isStatic":true
            },
            "value":{
                "type":4,
                "isConstant":false,
                "content":"second",
                "isStatic":true
            }
        },
        {
            "type":16,
            "key":{
                "type":4,
                "isConstant":false,
                "content":"onClick",
                "isStatic":true
            },
            "value":{
                "type":4,
                "content":"clickHandle",
                "isStatic":false,
                "isConstant":false,
            }
        }
    ]
}
  #+end_src

- v-bind,v-on æŒ‡ä»¤ï¼Œæ²¡æœ‰å‚æ•°ï¼Œéœ€è¦å°† props åˆå¹¶

*** transform props

[[https://github.com/gcclll/stb-vue-next/commit/20a5fa8bfefa9dd98a7965f78ff1f84de2591962][feat: transform props in codgenNode Â· gcclll/stb-vue-next@20a5fa8]]
** e4acc0d props generator

[[https://github.com/gcclll/stb-vue-next/commit/e4acc0dd5e33ceab3420f9e5ca8857f090bb536c][feat: props generator Â· gcclll/stb-vue-next@e4acc0d]]

ä¿®æ”¹ç‚¹ï¼š

1. add ~genExpressionAsPropertyKey()~ ç”Ÿæˆå±æ€§ key å‡½æ•°

   ä¸‰ç§å¯èƒ½çš„å±æ€§å

   - é™æ€å±æ€§å: ~<div class="value">~ -> ~{ class: "value" }~

   - åŠ¨æ€å±æ€§å: ~<div :[propName]="value"~ -> ~{ [propName]: "value"}~

   - ç»„åˆè¡¨è¾¾å¼å±æ€§åï¼šTODO

    #+begin_src typescript
   // ç”Ÿæˆå¯¹è±¡çš„å±æ€§ key (å¯èƒ½æ˜¯é™æ€ï¼ŒåŠ¨æ€)
   function genExpressionAsPropertyKey(
     node: ExpressionNode,
     context: CodegenContext
   ) {
     const { push } = context
     if (node.type === NodeTypes.COMPOUND_EXPRESSION) {
       // TODO åŠ¨æ€å±æ€§åæˆ–è¡¨è¾¾å¼
     } else if (node.isStatic) {
       // only quote key if necessary
       const text = isSimpleIdentifier(node.content)
         ? node.content
         : JSON.stringify(node.content)

       push(text, node)
     } else {
       push(`[${node.content}]`, node)
     }
   }
    #+end_src

2. add ~genObjectExpression()~ å°†å±æ€§åˆ—è¡¨ç”Ÿæˆå¯¹è±¡

   éå†èŠ‚ç‚¹çš„ ~node.properties~ å…ˆç”Ÿæˆ key(~genExpressionAsPropertyKey(key)~) å†ç”Ÿæˆ value(~genNode(value)~) ã€‚


æµ‹è¯•ï¼š
#+begin_src js

const {
  baseParse,
  baseCompile
} = require(process.env.PWD + '/../../static/js/vue/compiler-core.global.js')
 
const res = baseCompile(`<div class="first" name="div"></div>`, { hoistStatic: true })
console.log(res.code)
#+end_src

#+RESULTS:
#+begin_example
const _Vue = Vue
const { createVNode: _createVNode } = _Vue

const _hoisted_1 = {
  class: "first",
  name: "div"
}

return function render(_ctx, _cache) {
  with (_ctx) {
    const { createVNode : _createVNode, openBlock : _openBlock, createBlock : _createBlock } = _Vue

    return (_openBlock(), _createBlock("div", _hoisted_1))
  }
}
undefined
#+end_example

#+begin_quote
å®ä¾‹ä¸­æœ€åæ˜¯ç”¨çš„ ~createBlock()~ æ˜¯å› ä¸º root.children åªæœ‰ä¸€ä¸ª child ã€‚
#+end_quote

** static props

ä¿®æ”¹å‡½æ•°ï¼š ~transforms/transformElement~

#+begin_src js

const {
  baseParse,
  baseCompile
} = require(process.env.PWD + '/../../static/js/vue/compiler-core.global.js')
 
const res = baseCompile(`<div class="first"></div><div class="second"></div>`, { hoistStatic: true })
console.log(res.ast.codegenNode.children[0].props[0])
#+end_src

#+RESULTS:
#+begin_example
{
  type: 6,
  name: 'class',
  value: {
    type: 2,
    content: 'first',
    loc: { start: [Object], end: [Object], source: '"first"' }
  },
  loc: {
    start: { column: 6, line: 1, offset: 5 },
    end: { column: 19, line: 1, offset: 18 },
    source: 'class="first"'
  }
}
undefined
#+end_example
** 6951dd1 merge props

[[https://github.com/gcclll/stb-vue-next/commit/6951dd1ff97da1ef803e97770162fe0293ef76cc][feat: merge props Â· gcclll/stb-vue-next@6951dd1]]

åˆå¹¶å±æ€§çš„æ¡ä»¶ï¼šå­˜åœ¨æ²¡æœ‰å‚æ•°çš„æŒ‡ä»¤ï¼Œå¦‚ï¼š ~<div v-bind="{...}" v-on="{...}"~

FIX: [[https://github.com/gcclll/stb-vue-next/commit/12a66f0ebef241b282b4ccf746ddabc1a2f45ef1][fix: merge toHandlers props Â· gcclll/stb-vue-next@12a66f0]]

#+begin_src js

const {
  baseParse,
  baseCompile
} = require(process.env.PWD + '/../../static/js/vue/compiler-core.global.js')
const log = (code, title) => {
  console.log(`>>> ${title}`)
  const res = baseCompile(code)
  console.log(res.code)
}
 
log(`
<div class="first" v-on="{ click: clickHandle  }" v-bind="{ style: 'color:red' }"></div>`, 'æ— å‚æ•°çš„æŒ‡ä»¤ï¼Œåˆå¹¶æ‰€æœ‰å±æ€§')

log(`<div class="second" v-on:click="clickHandle" v-bind:style="color:red"></div>`, 'æœ‰å‚æ•°çš„æŒ‡ä»¤ï¼Œä¸åˆå¹¶')
#+end_src

#+RESULTS:
#+begin_example
>>> æ— å‚æ•°çš„æŒ‡ä»¤ï¼Œåˆå¹¶æ‰€æœ‰å±æ€§
const _Vue = Vue

return function render(_ctx, _cache) {
  with (_ctx) {
    const { toHandlers : _toHandlers, mergeProps : _mergeProps, createVNode : _createVNode, openBlock : _openBlock, createBlock : _createBlock } = _Vue

    return (_openBlock(), _createBlock("div", _mergeProps({ class: "first" }, _toHandlers({ click: clickHandle  }), { style: 'color:red' }), null, 16 /* FULL_PROPS */))
  }
}
>>> æœ‰å‚æ•°çš„æŒ‡ä»¤ï¼Œä¸åˆå¹¶
const _Vue = Vue

return function render(_ctx, _cache) {
  with (_ctx) {
    const { resolveDirective : _resolveDirective, createVNode : _createVNode, openBlock : _openBlock, createBlock : _createBlock } = _Vue

    return _withDirectives((_openBlock(), _createBlock("div", { class: "second" }, null, 512 /* NEED_PATCH */)), )
  }
}
undefined
#+end_example

æœ‰å‚æ•°æŒ‡ä»¤æ—¶ï¼Œéœ€è¦ç»“åˆ ~v-on~ æŒ‡ä»¤è§£æï¼Œå› æ­¤éœ€è¦å…ˆå®ç°äº† transform æŒ‡ä»¤æ‰èƒ½å¾—åˆ°ä¸‹é¢çš„æ­£ç¡®ç»“æœã€‚

ä¸åˆå¹¶(~mergeProps()~) çš„æ­£è§£ï¼š

#+begin_src js
(function anonymous(
) {
const _Vue = Vue

return function render(_ctx, _cache) {
  with (_ctx) {
    const { createVNode: _createVNode, openBlock: _openBlock, createBlock: _createBlock } = _Vue

    return (_openBlock(), _createBlock("div", {
      class: "second",
      onClick: clickHandle,
      style: { color: 'red' }
    }, null, 12 /* STYLE, PROPS */, ["onClick"]))
  }
}
})
#+end_src

ä¸‹é¢å°†ç»§ç»­å®ŒæˆæŒ‡ä»¤ç›¸å…³çš„ transform
* 6c43451 add v-on transform

init: [[https://github.com/gcclll/stb-vue-next/commit/98dcc9653790a319c3bc04222322167db21546df][feat(init): v-on directive Â· gcclll/stb-vue-next@98dcc96]]

å®ç°ï¼š[[https://github.com/gcclll/stb-vue-next/commit/6c4345156ffc86542120bb97deb438097b36efca][feat: v-on directive transform Â· gcclll/stb-vue-next@6c43451]]

#+begin_src js

const {
  baseParse,
  baseCompile
} = require(process.env.PWD + '/../../static/js/vue/compiler-core.global.js')
 
const res = baseCompile(`<div class="second" v-on:click="clickHandle" v-bind:style="color:red"></div>`)

console.log(res.code)
#+end_src

#+RESULTS:
#+begin_example
const _Vue = Vue

return function render(_ctx, _cache) {
  with (_ctx) {
    const { resolveDirective : _resolveDirective, createVNode : _createVNode, openBlock : _openBlock, createBlock : _createBlock } = _Vue

    return _withDirectives((_openBlock(), _createBlock("div", {
      class: "second",
      onClick: clickHandle
    }, null, 8 /* PROPS */, ["onClick"])), )
  }
}
undefined
#+end_example

é—®é¢˜ï¼š ~v-bind~ æ²¡æœ‰è¢«è§£æå‡ºæ¥ã€‚

å¦‚æœ v-onçš„ exp æ˜¯ä¸ªç®€å•çš„è¡¨è¾¾å¼ï¼Œéœ€è¦å°†å…¶è½¬æˆå‡½æ•° ~$event => (i++)~

[[https://github.com/gcclll/stb-vue-next/commit/1542b412cef3a1c81e3099e52bb5f7aa1fee2abe][feat(add): v-on with simple expression as handler Â· gcclll/stb-vue-next@1542b41]]

åˆ¤æ–­æ˜¯ç®€å•è¡¨è¾¾å¼çš„ä¾æ®ï¼š

~const isInlineStatement = !(isMemberExp || fnExpRE.test(exp.content))~

å³ä¸æ˜¯ member expression ä¹Ÿä¸æ˜¯ function expression ã€‚

member expression: ~/^[A-Za-z_$][\w$]*(?:\s*\.\s*[A-Za-z_$][\w$]*|\[[^\]]+\])*$/~
[[http://qiniu.ii6g.com/img/20201212163019.png]]

function expresstion: ~/^\s*([\w$_]+|\([^)]*?\))\s*=>|^\s*function(?:\s+[\w$]+)?\s*\(/~
[[http://qiniu.ii6g.com/img/20201212163123.png]]

æµ‹è¯•ï¼š
#+begin_src js
const {
  baseParse,
  baseCompile
} = require(process.env.PWD + '/../../static/js/vue/compiler-core.global.js')
 
const { code, ast } = baseCompile(`<div v-on:click="i++"></div>`)
console.log(code)
console.log(`>>> event name`)
console.log(ast.codegenNode.props.properties[0].key)
console.log(`>>> event handler`)
console.log(ast.codegenNode.props.properties[0].value)
#+end_src

#+RESULTS:
#+begin_example
const _Vue = Vue

return function render(_ctx, _cache) {
  with (_ctx) {
    const { createVNode : _createVNode, openBlock : _openBlock, createBlock : _createBlock } = _Vue

    return (_openBlock(), _createBlock("div", {
      onClick: $event => (i++)
    }, null, 8 /* PROPS */, ["onClick"]))
  }
}
>>> event name
{
  type: 4,
  loc: {
    start: { column: 11, line: 1, offset: 10 },
    end: { column: 16, line: 1, offset: 15 },
    source: 'click'
  },
  content: 'onClick',
  isStatic: true,
  constType: 3
}
>>> event handler
{
  type: 8,
  loc: {
    source: '',
    start: { line: 1, column: 1, offset: 0 },
    end: { line: 1, column: 1, offset: 0 }
  },
  children: [
    '$event => (',
    {
      type: 4,
      content: 'i++',
      isStatic: false,
      constType: 0,
      loc: [Object]
    },
    ')'
  ]
}
undefined
#+end_example

#+begin_comment
æ›´å¤šæµ‹è¯•ç”¨ä¾‹(~<f12>~)æ‰“å¼€æ§åˆ¶å°æŸ¥çœ‹ ->> ã€‚
#+end_comment

#+begin_export html
<script>
l1(`v-on æŒ‡ä»¤`)
c(`<div v-on:click="onClick"/>`, `v-on click`)
c(`<div v-on:[event]="handler"/>`, `v-onåŠ¨æ€äº‹ä»¶å`)
l2(`TODO 'dynamic arg with prefixing'`)
l2(`TODO dynamic arg with complex exp prefixing`)
c(`<div @click="i++"/>`, 'å¦‚æœ v-on çš„exp æ˜¯ä¸ªç®€å•è¡¨è¾¾å¼ï¼Œè¦ç”¨å‡½æ•°å°è£…èµ·æ¥')
c(`<div @click="foo();bar()"/>`, `æ”¯æŒå¤šä¸ªè¡¨è¾¾å¼`)
c(`<div @click="\nfoo();\nbar()\n"/>`, `æ”¯æŒå¤šè¡Œè¡¨è¾¾å¼`)
c(`<div @click="foo($event)"/>`, `å‡½æ•°è°ƒç”¨`)
c(`<div @click="foo($event);bar()"/>`, `å‡½æ•°è°ƒç”¨åŠ è¡¨è¾¾å¼æ··åˆ`)
c(`<div @click="$event => foo($event)"/>`, `å¦‚æœæœ¬èº«æ˜¯å‡½æ•°ä¸ç”¨å¤šä½™å¤„ç†`)
c(`<div @click="
      $event => {
        foo($event)
      }
    "/>`, `=> å¦‚æœè¡¨è¾¾å¼å·²ç»æ˜¯å‡½æ•°åŸæ ·è¾“å‡ºå°±è¡Œ`)
c(`<div @click="
      function($event) {
        foo($event)
      }
    "/>`, `function, å¦‚æœè¡¨è¾¾å¼å·²ç»æ˜¯å‡½æ•°åŸæ ·è¾“å‡ºå°±è¡Œ`)
c(`<div @click="a['b' + c]"/>`, `å¦‚æœè¡¨è¾¾å¼æ˜¯å¯¹è±¡å–å€¼è¡¨è¾¾å¼ï¼Œä¸ç”¨å¤„ç†`)
c(`<div v-on:click />`, `å¦‚æœæ²¡æœ‰è¡¨è¾¾å¼å’Œä¿®é¥°ç¬¦ï¼ŒæŠ¥é”™`)
c(`<div v-on:click.prevent />`, `å¦‚æœæ²¡è¡¨è¾¾å¼ä½†æ˜¯æœ‰ä¿®é¥°ç¬¦ï¼Œä¸æŠ¥é”™`)
c(`<div v-on:foo-bar="onMount"/>`, `äº‹ä»¶åä¸º foo-bar è¦è½¬æˆé©¼å³° onFooBar`)
c(`<div v-on:vnode-mounted="onMount"/>`, 'case conversion for vnode hooks')
compile.options = { cacheHandlers: true }
c(`<div v-on:click.prevent />`, `empty handler`)
c(`<div v-on:click="foo" />`, 'member expression handler')
c(`<div v-on:click="foo.bar" />`, 'compound member expression handler')
c(`<comp v-on:click="foo" />`, 'bail on component member expression handler')
c(`<div v-on:click="() => foo()" />`, 'inline function expression handler')
c(`<div v-on:click="foo++" />`, 'inline statement handler')
</script>
#+end_export

~options.cacheHandlers~ å±æ€§è¦é…åˆ ~options.prefixIdentifiers~ ä½¿ç”¨ã€‚

ä½œç”¨æ˜¯ç¼“å­˜äº‹ä»¶å¤„ç†å‡½æ•°ï¼ŒåŸç†æ˜¯:
#+begin_src js
return function render(_ctx, _cache) {
  with (_ctx) {
    const { createVNode : _createVNode, openBlock : _openBlock, createBlock : _createBlock } = _Vue

    return (_openBlock(), _createBlock("div", {
      onClick: _cache[1] || (_cache[1] = () => {})
    }))
  }
}
#+end_src

ç¼“å­˜çš„é™„åŠ æ¡ä»¶ï¼š ~let shouldCache: boolean = context.cacheHandlers && !exp~

æ²¡æœ‰è¡¨è¾¾å¼å€¼çš„æƒ…å†µä¸‹æ‰ç¼“å­˜ï¼Œå› ä¸ºæ­¤æ—¶ä¼šåˆ›å»ºä¸€ä¸ªç©ºçš„å‡½æ•°ä½œä¸ºäº‹ä»¶ handlerï¼Œä¸ºäº†é¿å…
åˆ›å»ºè¿‡å¤šçš„æ— æ„ä¹‰çš„ç©ºå‡½æ•°ï¼Œä½¿ç”¨ç¼“å­˜æ˜¯ä¸ªä¸é”™çš„é€‰æ‹©(+ä½†ï¼Œä¸€èˆ¬ç»‘å®šäº†äº‹ä»¶åº”è¯¥ä¸è‡³äºä¸
ç»™å¤„ç†å‡½æ•°å§!!!+)ã€‚


* f805858 add v-bind transform
:PROPERTIES:
:COLUMNS: %CUSTOM_ID[(Custom Id)]
:CUSTOM_ID: v-bind
:END: 

[[https://github.com/gcclll/stb-vue-next/commit/f80585802218bcc75aad502880c571b642257ef0][feat(add): v-bind transform Â· gcclll/stb-vue-next@f805858]]

#+begin_src js
const {
  baseParse,
  baseCompile
} = require(process.env.PWD + '/../../static/js/vue/compiler-core.global.js')
 
const res = baseCompile(`
<div v-bind:name="test"
  :age="100"
  :[propName]="myName"
  :[first+second]="thrid"
  :no-need-camel-prop="noNeedCamelProp"
  :need-camel-prop.camel="needCamelProp"
  :no-exp-prop.camel
></div>`, {
  onError(e) {
    console.log(e.message)
  }
})
console.log(`>>> render function\n`)
console.log(res.code)
#+end_src

#+RESULTS:
#+begin_example
v-bind is missing expression.
>>> render function

const _Vue = Vue

return function render(_ctx, _cache) {
  with (_ctx) {
    const { createVNode : _createVNode, openBlock : _openBlock, createBlock : _createBlock } = _Vue

    return (_openBlock(), _createBlock("div", {
      name: test,
      age: 100,
      [propName || ""]: myName,
      [first+second || ""]: thrid,
      "no-need-camel-prop": noNeedCamelProp,
      needCamelProp: needCamelProp,
      noExpProp: ""
    }, null, 16 /* FULL_PROPS */, ["name","age","no-need-camel-prop","needCamelProp","noExpProp"]))
  }
}
undefined
#+end_example

v-bind å±æ€§æ”¯æŒä»¥ä¸‹å‡ ç§æ–¹å¼ï¼š

- ~v-bind:name="test"~ æ— ç¼©å†™å±æ€§ï¼Œæœ€æ™®é€šçš„ä¸€ç§ç”¨æ³•
- ~:age="100"~ ç¼©å†™å½¢å¼
- ~:[propName]="myName"~ æ™®é€šåŠ¨æ€å±æ€§å
- ~:[first+second]="third"~ è¡¨è¾¾å¼åŠ¨æ€å±æ€§å
- ~:no-need-camel-prop="noNeedCamelProp"~ ä¸éœ€è¦è½¬é©¼å³°çš„å±æ€§å
- ~:need-camel-prop.camel="needCamelProp"~ éœ€è¦è½¬æˆé©¼å³°çš„å±æ€§åï¼Œéœ€è¦åˆ¶å®š
  ~.camel~ ä¿®é¥°ç¬¦
- ~no-exp-prop.camel~ æ— å±æ€§å€¼çš„å±æ€§ï¼Œä¼šç»™é»˜è®¤ ~""~ å€¼ï¼ŒåŒæ—¶ç»™å‡ºè­¦å‘Šï¼Œä¸å»ºè®®ä½¿ç”¨ã€‚

#+begin_comment
æ›´å¤šæµ‹è¯•ç”¨ä¾‹(~<f12>~)æ‰“å¼€æ§åˆ¶å°æŸ¥çœ‹ ->> ã€‚
#+end_comment

#+begin_export html
<script>
l1(`v-bind æŒ‡ä»¤ >>>>>`)
c(`<div v-bind:id="id"/>`, 'basic')
c(`<div v-bind:[id]="id"/>`, `dynamic arg`)
c(`<div v-bind:arg />`, `should error if no expression`)
c(`<div v-bind:foo-bar.camel="id"/>`, '.camel modifier')
c(`<div v-bind:[foo].camel="id"/>`, '.camel modifier w/ dynamic arg')
c(`<div v-bind:[foo(bar)].camel="id"/>`, '.camel modifier w/ dynamic arg + prefixIdentifiers')
</script>
#+end_export

* 0cc76f0 add v-model transform

[[https://github.com/gcclll/stb-vue-next/commit/0cc76f04112b1194e0a5cafae0a49bc399462ebf][feat(add): v-model transform Â· gcclll/stb-vue-next@0cc76f0]]

~<input v-model="model" />~

ç»è¿‡ ~transformModel~ ä¹‹åçš„ node.props:

#+begin_src json
[
    {
        "type":16, // JS_PROPERTY
        "key":{
            "type":4, // SIMPLE_EXPRESSION
            "content":"modelValue",
            "isStatic":true,
            "constType":3
        },
        "value":{
            "type":4,
            "content":"model",
            "isStatic":false,
            "constType":0,
        }
    },
    {
        "type":16,
        "key":{
            "type":4,
            "content":"onUpdate:modelValue",
            "isStatic":true,
            "constType":3
        },
        "value":{
            "type":8, // COMPOUND_EXPRESSION
            "children":[
                "$event => (",
                {
                    "type":4,
                    "content":"model",
                    "isStatic":false,
                    "constType":0,
                },
                " = $event)"
            ]
        }
    }
]
#+end_src

compiler-core é˜¶æ®µçš„è§£æè„‘å›¾ï¼š
[[/img/vue3/compiler-core/pcg/pcg-08-v-model-cc.svg]]

ä»å›¾ä¸­å¯ä»¥çœ‹å‡ºï¼Œ v-model æŒ‡ä»¤çš„è§£æä¹Ÿæ˜¯åœ¨ buildProps ä¸­å®Œæˆçš„ï¼Œå…³äºè¿™ä¸ªå‡½æ•°çš„è„‘
å›¾ä¹Ÿå¯ä»¥æŸ¥çœ‹ [[/vue/vue-mind-map-house-cc/#key-01-build-props][buildProps(node, context) å¦‚ä½•æ„å»º props ?]]

vue/baseCompile è§£æä¹‹åçš„ç»“æœï¼š

#+begin_src js
const _Vue = Vue

return function render(_ctx, _cache) {
  with (_ctx) {
    const { createVNode: _createVNode, openBlock: _openBlock, createBlock: _createBlock } = _Vue

    return (_openBlock(), _createBlock("input", {
      modelValue: model,
      "onUpdate:modelValue": $event => (model = $event)
    }, null, 8 /* PROPS */, ["modelValue", "onUpdate:modelValue"]))
  }
}
#+end_src

vue/compile ç»è¿‡ compile-dom package(/æœªå®Œæˆ/) çš„ transformModel ä¹‹åçš„ç»“æœï¼š

#+begin_src js
(function anonymous(
) {
const _Vue = Vue

return function render(_ctx, _cache) {
  with (_ctx) {
    const { vModelText: _vModelText, createVNode: _createVNode, withDirectives: _withDirectives, openBlock: _openBlock, createBlock: _createBlock } = _Vue

    return _withDirectives((_openBlock(), _createBlock("input", {
      "onUpdate:modelValue": $event => (model = $event)
    }, null, 8 /* PROPS */, ["onUpdate:modelValue"])), [
      [_vModelText, model]
    ])
  }
}
})
#+end_src

[[https://github.com/gcclll/stb-vue-next/commit/a537be0fc265243012032750a801b6e6582751d5][fix: v-model no value Â· gcclll/stb-vue-next@a537be0]]

ä¿®å¤ä¹‹å(~genNode~ æ²¡æœ‰å®ç° ~8,COMPOUND_EXPRESSION~ ç±»å‹)ï¼Œæµ‹è¯•

1. ä¸å¸¦å‚æ•°çš„ ~v-model~

   #+begin_src js
    const {
        baseParse,
        baseCompile
    } = require(process.env.PWD + '/../../static/js/vue/compiler-core.global.js')

    const { code } = baseCompile(`<input v-model="model" />`)
    console.log(code)
    #+end_src

    #+RESULTS:
    #+begin_example
    const _Vue = Vue

    return function render(_ctx, _cache) {
      with (_ctx) {
        const { createVNode : _createVNode, openBlock : _openBlock, createBlock : _createBlock } = _Vue

        return (_openBlock(), _createBlock("input", {
          modelValue: model,
          "onUpdate:modelValue": $event => (model = $event)
        }, null, 8 /* PROPS */, ["modelValue","onUpdate:modelValue"]))
      }
    }
    #+end_example

2. æŒ‡ä»¤ ~{ prefixIdentifiers: true }~ é€‰é¡¹(éœ€è¦ node ç¯å¢ƒ, *TODO*)

   #+begin_src js
    const {
        baseParse,
        baseCompile
    } = require(process.env.PWD + '/../../static/js/vue/compiler-core.global.js')

    const { code } = baseCompile(`<input v-model="model" />`, {
      prefixIdentifiers: true
    })
    console.log(code)
   #+end_src

   #+RESULTS:
   #+begin_example
   const _Vue = Vue

   return function render(_ctx, _cache) {
     with (_ctx) {
       const { createVNode : _createVNode, openBlock : _openBlock, createBlock : _createBlock } = _Vue

       return (_openBlock(), _createBlock("input", {
         modelValue: model,
         "onUpdate:modelValue": $event => (model = $event)
       }, null, 8 /* PROPS */, ["modelValue","onUpdate:modelValue"]))
     }
   }
   undefined
   #+end_example

3. ç»„åˆè¡¨è¾¾å¼(~8,COMPOUND_EXPRESSION~)

   #+begin_src js
const {
  baseParse,
  baseCompile
} = require(process.env.PWD + '/../../static/js/vue/compiler-core.global.js')

const { code } = baseCompile(`<input v-model="model[index]" />`)
console.log(code)
 
   #+end_src

   #+RESULTS:
   #+begin_example
   const _Vue = Vue

   return function render(_ctx, _cache) {
     with (_ctx) {
       const { createVNode : _createVNode, openBlock : _openBlock, createBlock : _createBlock } = _Vue

       return (_openBlock(), _createBlock("input", {
         modelValue: model[index],
         "onUpdate:modelValue": $event => (model[index] = $event)
       }, null, 8 /* PROPS */, ["modelValue","onUpdate:modelValue"]))
     }
   }
   undefined
   #+end_example

4. å¸¦å‚æ•°

   #+begin_src js

const {
  baseParse,
  baseCompile
} = require(process.env.PWD + '/../../static/js/vue/compiler-core.global.js')
 
const { code } = baseCompile(`<input v-model:value="model" />`)
console.log(code)
   #+end_src

   #+RESULTS:
   #+begin_example
   const _Vue = Vue

   return function render(_ctx, _cache) {
     with (_ctx) {
       const { createVNode : _createVNode, openBlock : _openBlock, createBlock : _createBlock } = _Vue

       return (_openBlock(), _createBlock("input", {
         value: model,
         "onUpdate:value": $event => (model = $event)
       }, null, 40 /* PROPS, HYDRATE_EVENTS */, ["value","onUpdate:value"]))
     }
   }
   undefined
   #+end_example

    ä¸å¸¦å‚æ•°çš„æ—¶å€™å‚æ•°åä¼šç»™ä¸€ä¸ªé»˜è®¤å€¼ï¼š ~modelValue~, å¦‚æœæœ‰è‡ªå·±çš„å‚æ•°ä¼šç›´æ¥ä½¿
   ç”¨æä¾›çš„å‚æ•°åã€‚

5. åŠ¨æ€å‚æ•°

   #+begin_src js

const {
  baseParse,
  baseCompile
} = require(process.env.PWD + '/../../static/js/vue/compiler-core.global.js')
 
const { code } = baseCompile(`<input v-model:[value]="model" />`)
console.log(code)
   #+end_src

   æœ‰é—®é¢˜ç»“æœï¼š
   #+RESULTS:
   #+begin_example
   const _Vue = Vue

   return function render(_ctx, _cache) {
     with (_ctx) {
       const { createVNode : _createVNode, openBlock : _openBlock, createBlock : _createBlock } = _Vue

       return (_openBlock(), _createBlock("input", {
         [value]: model,
         : $event => (model = $event)
       }, null, 16 /* FULL_PROPS */))
     }
   }
   #+end_example

   ç»“æœæ˜¾ç¤ºï¼ŒåŠ¨æ€å±æ€§çš„äº‹ä»¶åæ²¡æœ‰è¢«è§£æå‡ºæ¥ ~: $event => (model = $event)~ ã€‚

   ä¿®å¤ä¹‹åç»“æœ([[https://github.com/gcclll/stb-vue-next/commit/94a7a850d7e060e948c5672cdb170c47489feda9][fix: v-model dynamic arg generate Â· gcclll/stb-vue-next@94a7a85]])ï¼š
   #+RESULTS:
   #+begin_example
   const _Vue = Vue

   return function render(_ctx, _cache) {
     with (_ctx) {
       const { createVNode : _createVNode, openBlock : _openBlock, createBlock : _createBlock } = _Vue

       return (_openBlock(), _createBlock("input", {
         [value]: model,
         ["onUpdate:" + value]: $event => (model = $event)
       }, null, 16 /* FULL_PROPS */))
     }
   }
   #+end_example

6. ç¼“å­˜äº‹ä»¶å›è°ƒå‡½æ•°(~cacheHandlers: true~, *TODO*)

   éœ€è¦ç»“åˆ ~prefixIdentifiers: true~ ä½¿ç”¨ã€‚
* bf18a84 add v-once transform

[[https://github.com/gcclll/stb-vue-next/commit/bf18a84650adaf68004a0ce0977d33b1436a4587][feat(add): v-once Â· gcclll/stb-vue-next@bf18a84]]

#+begin_src typescript
const seen = new WeakSet()

export const transformOnce: NodeTransform = (node, context) => {
  if (node.type === NodeTypes.ELEMENT && findDir(node, 'once', true)) {
    // ç¼“å­˜å®ç° v-onceï¼Œå°±ç®—æœ‰æ•°æ®æ›´æ–°ä¹Ÿä¸ä¼šé‡æ–°ç”Ÿæˆ render å‡½æ•°
    if (seen.has(node)) {
      return
    }
    seen.add(node)
    context.helper(SET_BLOCK_TRACKING)
    return () => {
      const cur = context.currentNode as ElementNode | IfNode | ForNode
      if (cur.codegenNode) {
        cur.codegenNode = context.cache(cur.codegenNode, true /* isVNode */)
      }
    }
  }
}
#+end_src

~v-once~ æŒ‡ä»¤çš„å®ç°çœ‹ä¼¼æŒºç®€å•çš„ï¼Œå°†è§£æåçš„ node èŠ‚ç‚¹ç¼“å­˜åˆ° ~seen: WeakSet~ ä¸­ï¼Œ
ä¸‹æ¬¡ä½¿ç”¨çš„æ—¶å€™ç›´æ¥å–ç¼“å­˜(~context.cache(...)~)ï¼Œè€Œä¸æ˜¯é‡æ–°ç”Ÿæˆ ~codegenNode~

~JS_CACHE_EXPRESSION~ ç»“æ„ï¼š

#+begin_src typescript
export function createCacheExpression(
  index: number,
  value: JSChildNode,
  isVNode: boolean = false
): CacheExpression {
  return {
    type: NodeTypes.JS_CACHE_EXPRESSION,
    index, // åœ¨ context.cached ä¸­çš„ç´¢å¼•
    value, // v-onceèŠ‚ç‚¹çš„ ast
    isVNode, // block æˆ– vnode ?
    loc: locStub
  }
}
#+end_src

generator é˜¶æ®µå®ç°ï¼š[[https://github.com/gcclll/stb-vue-next/commit/8bacf14f156f0ca357d4c0efdbc75dc2120a3ec5][feat(add): v-once generator Â· gcclll/stb-vue-next@8bacf14]]

åœ¨ ~genNode()~ ä¸­å¢åŠ  ~JS_CACHE_EXPRESSION~ ç±»å‹çš„åˆ†æ”¯å¤„ç†ã€‚

#+begin_src typescript
function genCacheExpression(node: CacheExpression, context: CodegenContext) {
  const { push, helper, indent, deindent, newline } = context
  if (node.isVNode) {
    indent()
    push(`${helper(SET_BLOCK_TRACKING)}(-1),`)
    newline()
  }

  push(`_cache[${node.index}] = `)
  genNode(node.value, context)
  if (node.isVNode) {
    push(`,`)
    newline()
    push(`${helper(SET_BLOCK_TRACKING)}(1),`)
    newline()
    push(`_cache[${node.index}]`)
    deindent()
  }
  push(`)`)
}
#+end_src

æµ‹è¯•ï¼š

#+begin_src js
const {
  baseParse,
  baseCompile
} = require(process.env.PWD + '/../../static/js/vue/compiler-core.global.js')
 
const c = ( tpl, desc ) => {
  console.log(desc)
  const { code } = baseCompile(tpl)
  console.log(code)
}

c(`<div :id="foo" v-once />`, `>>> <div :id="foo" v-once />`)
c(`<div><div :id="foo" v-once /></div>`, `>>> æ ‡ç­¾ä¸­åµŒå¥—ä½¿ç”¨`)
c(`<div><Comp :id="foo" v-once /></div>`, `>>> åœ¨è‡ªå®šä¹‰ç»„ä»¶ä¸Š`)
#+end_src

#+RESULTS:
#+begin_example
>>> <div :id="foo" v-once />
const _Vue = Vue

return function render(_ctx, _cache) {
  with (_ctx) {
    const { setBlockTracking : _setBlockTracking, createVNode : _createVNode } = _Vue

    return _cache[1] || (
      _setBlockTracking(-1),
      _cache[1] = _createVNode("div", { id: foo }, null, 8 /* PROPS */, ["id"]),
      _setBlockTracking(1),
      _cache[1]
    )
  }
}
>>> æ ‡ç­¾ä¸­åµŒå¥—ä½¿ç”¨
const _Vue = Vue

return function render(_ctx, _cache) {
  with (_ctx) {
    const { setBlockTracking : _setBlockTracking, createVNode : _createVNode, openBlock : _openBlock, createBlock : _createBlock } = _Vue

    return (_openBlock(), _createBlock("div", null, [
      _cache[1] || (
        _setBlockTracking(-1),
        _cache[1] = _createVNode("div", { id: foo }, null, 8 /* PROPS */, ["id"]),
        _setBlockTracking(1),
        _cache[1]
      )
    ]))
  }
}
>>> åœ¨è‡ªå®šä¹‰ç»„ä»¶ä¸Š
const _Vue = Vue

return function render(_ctx, _cache) {
  with (_ctx) {
    const { setBlockTracking : _setBlockTracking, resolveComponent : _resolveComponent, createVNode : _createVNode, openBlock : _openBlock, createBlock : _createBlock } = _Vue

    return (_openBlock(), _createBlock("div", null, [
      _cache[1] || (
        _setBlockTracking(-1),
        _cache[1] = _createVNode(_component_Comp, { id: foo }, null, 8 /* PROPS */, ["id"]),
        _setBlockTracking(1),
        _cache[1]
      )
    ]))
  }
}
undefined
#+end_example

TODO ç¼ºå°‘ï¼š ~const _component_Comp = _resolveComponent("Comp")~
* acdea14 add v-if transform

~v-if~ æŒ‡ä»¤æºç è„‘å›¾å¯å‚è€ƒï¼š [[/vue/vue-mind-map-house-cc/#pcg-v-if][05 v-if æŒ‡ä»¤(git:0a591b6)]]

å¯¹äº ~v-if|else|else-if~ æŒ‡ä»¤åœ¨ transform é˜¶æ®µï¼Œè½¬æ¢æ”¶é›† transformXxx å‡½æ•°è¿‡ç¨‹ä¸­ï¼Œ
ä¼šå…ˆé’ˆå¯¹æŒ‡ä»¤è¿›è¡Œå¤„ç†ï¼Œæ¯”å¦‚ï¼š ~v-else, v-else-if~ æŒ‡ä»¤çš„ç»„ä»¶ä¼šè¢«è§£æåˆ° ~v-if~ èŠ‚
ç‚¹çš„ ~node.branches[]~ åˆ†æ”¯æ•°ç»„é‡Œé¢ä¹‹åè¢«åˆ é™¤ï¼Œè¿™äº›éƒ½æ˜¯åœ¨æ”¶é›† transformXxx ä¹‹å‰éœ€è¦å®Œæˆçš„ã€‚

åŒ…æ‹¬ ~v-for~ æŒ‡ä»¤éƒ½éœ€è¦ç»è¿‡ ~createStructuralDirectiveTransform()~ å‡½æ•°å°è£…ä¸€å±‚
ä¹‹åï¼Œè¿”å›å¯¹åº”çš„ ~transformXxx~ å‡½æ•°ã€‚

#+begin_src typescript

export function createStructuralDirectiveTransform(
  name: string | RegExp,
  fn: StructuralDirectiveTransform
): NodeTransform {
  const matches = isString(name)
    ? (n: string) => n === name
    : (n: string) => name.test(n)

  return (node, context) => {
    if (node.type === NodeTypes.ELEMENT) {
      const { props } = node
      // structural directive transforms are not concerned with slots
      // as they are handled separately in vSlot.ts
      if (node.tagType === ElementTypes.TEMPLATE && props.some(isVSlot)) {
        return
      }
      const exitFns = []
      for (let i = 0; i < props.length; i++) {
        const prop = props[i]
        if (prop.type === NodeTypes.DIRECTIVE && matches(prop.name)) {
          // structural directives are removed to avoid infinite recursion
          // also we remove them *before* applying so that it can further
          // traverse itself in case it moves the node around
          props.splice(i, 1)
          i--
          const onExit = fn(node, prop, context)
          if (onExit) exitFns.push(onExit)
        }
      }
      return exitFns
    }
  }
}
#+end_src

é€šè¿‡ ~for (...)~ å°†æ‰€æœ‰ v-if/v-for ç›¸å…³æŒ‡ä»¤ç»è¿‡ä»–ä»¬è‡ªå·±çš„å¤„ç†å‡½æ•°(æ¯”å¦‚ï¼š
~processIf~ ) ä¹‹åå¾—åˆ°æœ€ç»ˆçš„ ~onExit~ æ”¶é›†åˆ° ~exitFns~ ä¸­ï¼Œåœ¨å¤„ç†è¿‡ç¨‹ä¸­éšæ—¶ä¼šå‡º
ç°èŠ‚ç‚¹çš„åˆ é™¤æ“ä½œ(æ¯”å¦‚ï¼š ~v-else~ èŠ‚ç‚¹ä¼šåœ¨è§£æå®Œä¹‹åè¢«åˆ é™¤)ï¼Œåœ¨æ­£å¸¸çš„ traverse è¿‡
ç¨‹ä¸­è¿™äº›èŠ‚ç‚¹éƒ½ä¸ä¼šå†å­˜åœ¨ã€‚

#+begin_quote
PS: æ­£ç¡®ç†è§£åº”è¯¥å±äºç§»åŠ¨æ“ä½œï¼Œå› ä¸ºåŸå§‹çš„ AST ç»“æ„å¹¶æ²¡æ”¹å˜ï¼Œåªä¸è¿‡æ˜¯åœ¨åŸæœ‰çš„ AST
æ•°ç»“æ„ä¸­ç§»é™¤åˆ°æ–°çš„ AST èŠ‚ç‚¹ä¸‹é¢äº†ã€‚
#+end_quote

** acdea14 v-if transform init

[[https://github.com/gcclll/stb-vue-next/commit/acdea1419d0361a4566a5f2a53ffc8bb1f941878][feat(init): v-if transform Â· gcclll/stb-vue-next@acdea14]]

#+begin_src typescript
export const transformIf = createStructuralDirectiveTransform(
  /^(if|else|else-if)$/,
  (node, dir, context) => {
    return processIf(node, dir, context, (ifNode, branch, isRoot) => {
      // TODO
      console.log(ifNode, branch, isRoot)
      return () => {}
    })
  }
)

export function processIf(
  node: ElementNode,
  dir: DirectiveNode,
  context: TransformContext,
  processCodegen?: (
    node: IfNode,
    branch: IfBranchNode,
    isRoot: boolean
  ) => (() => void) | undefined
) {}
#+end_src

åˆå§‹åŒ– v-if process å‡½æ•°ï¼Œ processIf å‡½æ•°é‡Œé¢ä¼šé’ˆå¯¹ v-if èŠ‚ç‚¹ç”šè‡³å®ƒçš„å…„å¼ŸèŠ‚ç‚¹åš
ä¸€ç³»åˆ—æ“ä½œï¼Œæ¯”å¦‚å°†ä¸‹ä¸€ä¸ªæ˜¯ ~v-else~ çš„å…„å¼ŸèŠ‚ç‚¹åˆ é™¤ç§»åˆ°è‡ªå·±çš„ ~branches[]~ é‡Œé¢ã€‚
** 9039a3e v-if transform processIf

[[https://github.com/gcclll/stb-vue-next/commit/9039a3e567260d33c0bc617d4c58639b14b66fec][feat: v-if processIf Â· gcclll/stb-vue-next@9039a3e]]

è¿™é‡Œå¢åŠ äº†ä¸¤ä¸ªå‡½æ•°çš„å®ç°ï¼š

1. processIf, è§£æ ifï¼Œåˆ›å»º ~IF,9~ ç±»å‹çš„ç»“æ„ï¼Œæ›¿æ¢ v-if åŸæ¥çš„ ast

   #+begin_src typescript
    const ifNode: IfNode = {
      type: NodeTypes.IF,
      loc: node.loc,
      branches: [branch]
    }
   #+end_src

   å…¶ä¸­ branches ä¿å­˜ç€æ‰€æœ‰ v-else, v-else-if åˆ†æ”¯èŠ‚ç‚¹ï¼Œè¿™é‡Œå…¶å®æ˜¯åˆ›å»ºäº†ä¸€ä¸ªé»˜è®¤
   çš„åˆ†æ”¯èŠ‚ç‚¹ï¼Œå› ä¸º ~v-if~ ç³»åˆ—æŒ‡ä»¤åœ¨ ~render~ å‡½æ•°ä¸­æ˜¯ä»¥ä¸‰å…ƒè¿ç®—ç¬¦(~?:~)å½¢å¼å­˜
   åœ¨çš„ï¼Œæ‰€ä»¥ if åé¢å¿…é¡»è¦æœ‰ä¸€ä¸ªåˆ†æ”¯ï¼Œå³ ~condition ? node1 : node2~ ä¸­çš„ node2
   å¿…é¡»æ˜¯ä¸ªæœ‰æ•ˆçš„å€¼ï¼Œæ‰èƒ½æ­£å¸¸ä½¿ç”¨ ~?:~ è¿ç®—ç¬¦ã€‚

   æ‰€ä»¥ï¼Œå¦‚æœåªæœ‰ ~v-if~ æŒ‡ä»¤çš„æ—¶å€™ä¸‰å…ƒç¬¦åé¢çš„å€¼èµ·å§‹æ˜¯ä¸ªç©ºå€¼(å¥½åƒæ˜¯ ~null~)
   
2. createIfBranch, åˆ›å»º ~v-if~ çš„åˆ†æ”¯èŠ‚ç‚¹çš„
   
   #+begin_src typescript
function createIfBranch(node: ElementNode, dir: DirectiveNode): IfBranchNode {
  return {
    type: NodeTypes.IF_BRANCH,
    loc: node.loc,
    // condition ? v-if node : v-else node
    condition: dir.name === 'else' ? undefined : dir.exp,
    // å¦‚æœç”¨çš„æ˜¯ <template v-if="condition" ... å°±éœ€è¦ node.children
    // å› ä¸º template æœ¬èº«æ˜¯ä¸è¯¥è¢«æ¸²æŸ“çš„
    children:
      node.tagType === ElementTypes.TEMPLATE && !findDir(node, 'for')
        ? node.children
        : [node],
    // å¯¹äº v-for, v-if/... éƒ½åº”è¯¥ç»™å®ƒä¸ª key, è¿™é‡Œæ˜¯ç”¨æˆ·ç¼–å†™æ˜¯çš„æä¾›çš„å”¯ä¸€ key
    // å¦‚æœæ²¡æœ‰è§£æå™¨ä¼šé»˜è®¤ç”Ÿæˆä¸€ä¸ªå…¨å±€å”¯ä¸€çš„ key
    userKey: findProp(node, `key`)
  }
}
   #+end_src

    æ³¨æ„çœ‹æœ€åä¸€ä¸ªå±æ€§ï¼Œ ~v-if~ åˆ†æ”¯ä¹Ÿæ˜¯éœ€è¦ä¸€ä¸ª ~key~ å±æ€§çš„ã€‚
** 44985b4 v-if transform createIfBranch

[[https://github.com/gcclll/stb-vue-next/commit/44985b49e031752a7c84464b29adb769050cb1fb][feat: v-if createIfBranch Â· gcclll/stb-vue-next@44985b4]]

#+begin_src typescript
export function createConditionalExpression(
  test: ConditionalExpression['test'],
  consequent: ConditionalExpression['consequent'],
  alternate: ConditionalExpression['alternate'],
  newline = true
) {
  return {
    type: NodeTypes.JS_CONDITIONAL_EXPRESSION,
    test,
    consequent,
    alternate,
    newline,
    loc: locStub
  }
}
#+end_src

è¿™é‡Œçš„ç»“æ„(~v-if~)åœ¨ render å‡½æ•°ä¸­çš„å¯¹åº”å…³ç³»ï¼š

~test ? consequent : alternate~

å¦‚æœæœ‰ v-else-if æ—¶å€™ï¼Œ ~alternate~ ç»“æ„ä¼šæ˜¯ä¸ªå®Œæ•´çš„ ~JS_CONDITIONAL_EXPRESSION~
ï¼Œå³ï¼š ~alternate: { test, consequent, alternate, ...}~ æ‰€ä»¥ï¼š

~test ? consequent : test1 ? consequent 1 : alternate~

[[https://github.com/gcclll/stb-vue-next/commit/1e24eb7a30588690a4e83f888623b97f0085e899][fix: no v-if transform Â· gcclll/stb-vue-next@1e24eb7]]

åˆ°è¿™é‡Œ v-if æŒ‡ä»¤ transform é˜¶æ®µå·²ç»å®Œæˆï¼Œæµ‹è¯•ç»“æœï¼š

#+begin_src js
const {
  baseParse,
  baseCompile
} = require(process.env.PWD + '/../../static/js/vue/compiler-core.global.js')
 
const { code, ast } = baseCompile(`<div v-if="ok"/>`)
console.log(`>>> ast.codegenNode ç»“æœ`)
console.log(ast.codegenNode)
#+end_src

#+RESULTS:
#+begin_example
>>> ast.codegenNode ç»“æœ
{
  type: 9,
  loc: {
    start: { column: 1, line: 1, offset: 0 },
    end: { column: 17, line: 1, offset: 16 },
    source: '<div v-if="ok"/>'
  },
  branches: [
    {
      type: 10,
      loc: [Object],
      condition: [Object],
      children: [Array],
      userKey: undefined
    }
  ],
  codegenNode: {
    type: 19,
    test: {
      type: 4,
      content: 'ok',
      isStatic: false,
      isConstant: false,
      loc: [Object]
    },
    consequent: {
      type: 13,
      tag: '"div"',
      props: [Object],
      children: undefined,
      patchFlag: undefined,
      dynamicProps: undefined,
      directives: undefined,
      isBlock: true,
      disableTracking: false,
      loc: [Object]
    },
    alternate: {
      type: 14,
      loc: [Object],
      callee: Symbol(createCommentVNode),
      arguments: [Array]
    },
    newline: true,
    loc: { source: '', start: [Object], end: [Object] }
  }
}
undefined
#+end_example

+RESULTS: é”™è¯¯ç»“æœ
#+begin_example
const _Vue = Vue

return function render(_ctx, _cache) {
  with (_ctx) {
    const { createVNode : _createVNode, openBlock : _openBlock, createBlock : _createBlock, createCommentVNode : _createCommentVNode } = _Vue

    return (_openBlock(), _createBlock("div", { key: 0 }))
  }
}
>>> ast.codegenNode ç»“æœ
{
  type: 13,
  tag: '"div"',
  props: {
    type: 15,
    loc: { source: '', start: [Object], end: [Object] },
    properties: [ [Object] ]
  },
  children: undefined,
  patchFlag: undefined,
  dynamicProps: undefined,
  directives: undefined,
  isBlock: true,
  disableTracking: false,
  loc: {
    start: { column: 1, line: 1, offset: 0 },
    end: { column: 17, line: 1, offset: 16 },
    source: '<div v-if="ok"/>'
  }
}
undefined
#+end_example

ç»“æœæ˜¾ç¤ºæ˜¯ä¸å¯¹çš„ï¼Œå› ä¸ºåˆ›å»ºçš„ ~IF~ ç»“æ„æ²¡æœ‰æ›¿æ¢ ast ğŸŒ²ä¸­åŸæ¥çš„èŠ‚ç‚¹ï¼Œè¿½è¸ªåå‘ç°æ˜¯
æ¼æ‰äº† ~context.replaceNode(node)~ çš„å®ç°ã€‚

[[https://github.com/gcclll/stb-vue-next/commit/47c30d296b2f42759aea8de4730ae1802dbb6e32][fix: v-if codegenNode is incorrect Â· gcclll/stb-vue-next@47c30d2]]

traverseNode ä¸­éœ€è¦å¢åŠ  ~case 9,IF~ åˆ†æ”¯å¤„ç†ï¼Œéå†æ‰€æœ‰çš„ ~branches[]~ ã€‚

[[https://github.com/gcclll/stb-vue-next/commit/179f06f716687166b167f5d190073bfe65a9393f][fix: v-if branches no codegenNode Â· gcclll/stb-vue-next@179f06f]]
** 742757e v-if generator

[[https://github.com/gcclll/stb-vue-next/commit/742757ebe2c4d1faaadf32b6606d43cef2900934?branch=742757ebe2c4d1faaadf32b6606d43cef2900934&diff=split][feat: v-if generator Â· gcclll/stb-vue-next@742757e]]

genNode å¢åŠ  ~JS_CONDITIONAL_EXPRESSION~ åˆ†æ”¯å¤„ç†(~genConditionalExpression~)

#+begin_src typescript
function genConditionalExpression(
  node: ConditionalExpression,
  context: CodegenContext
) {
  const { test, consequent, alternate, newline: needNewline } = node
  const { push, indent, deindent, newline } = context
  if (test.type === NodeTypes.SIMPLE_EXPRESSION) {
    // éç®€å•çš„æ ‡è¯†ç¬¦éœ€è¦ç”¨æ‹¬å·ï¼Œå¯èƒ½æ˜¯è¡¨è¾¾å¼ï¼Œæ‰€ä»¥éœ€è¦ (a + b) ? ... : ...
    const needsParams = !isSimpleIdentifier(test.content)
    needsParams && push(`(`)
    genExpression(test, context)
    needsParams && push(`)`)
  } else {
    push(`(`)
    genNode(test, context)
    push(`)`)
  }

  needNewline && indent()
  context.indentLevel++
  needNewline || push(` `)
  push(`? `)
  genNode(consequent, context)
  context.indentLevel--
  needNewline && newline()
  needNewline || push(` `)
  push(`: `)
  const isNested = alternate.type === NodeTypes.JS_CONDITIONAL_EXPRESSION
  if (!isNested) {
    // ä¸æ˜¯åµŒå¥—
    context.indentLevel++
  }
  genNode(alternate, context)
  if (!isNested) {
    context.indentLevel--
  }

  needNewline && deindent(true /* without newline */)
}
#+end_src

~genConditionalExpression~ å¤„ç†åˆ†ä¸ºä¸‰ä¸ªéƒ¨åˆ†

1. ~test~ ç”Ÿæˆæ¡ä»¶è¡¨è¾¾å¼ï¼Œè¿™é‡Œæ˜¯: ~ok~ ï¼Œå¦‚æœæ˜¯è¡¨è¾¾å¼éœ€è¦æ‹¬å·ï¼š ~(a + b)~
2. ~consequent~ ç”¨æ¥ç”Ÿæˆ ~?~ åé¢çš„è¡¨è¾¾å¼ï¼Œå³ ~ok~ ç»“æœä¸º truth æ—¶æ‰§è¡Œ
3. ~alternate~ ç”¨æ¥ç”Ÿæˆ ~:~ åé¢çš„è¡¨è¾¾å¼ï¼Œå³ ~ok~ ç»“æœä¸º falsy æ—¶æ‰§è¡Œ

   ~alternate~ ä¸­çš„ç»“æ„å¯èƒ½ä¹Ÿæ˜¯ä¸ª ~JS_CONDITIONAL_EXPRESSION~ ç»“æ„ï¼Œä»£è¡¨å¯èƒ½æœ‰
   ~v-else-if~ åˆ†æ”¯ï¼Œå¦‚ï¼š ~(a + b) ? node1 : (c + d) ? node2 : othernode~ ã€‚


æµ‹è¯•ï¼š
#+begin_src js

const {
  baseParse,
  baseCompile
} = require(process.env.PWD + '/../../static/js/vue/compiler-core.global.js')
 
const c = ( tpl, desc ) => {
  console.log(`>>> ` + desc)
  const { code } = baseCompile(tpl, { hoistStatic: true })
  console.log(code)
}

c(`<div v-if="ok"/>`, 'basic v-if')
c(`<template v-if="ok"><div/>hello<p/></template>`, 'template v-if')
#+end_src

#+RESULTS:
#+begin_example
>>> basic v-if
const _Vue = Vue
const { createVNode: _createVNode, createCommentVNode: _createCommentVNode } = _Vue

const _hoisted_1 = { key: 0 }

return function render(_ctx, _cache) {
  with (_ctx) {
    const { createVNode : _createVNode, openBlock : _openBlock, createBlock : _createBlock, createCommentVNode : _createCommentVNode } = _Vue

    return ok
      ? (_openBlock(), _createBlock("div", _hoisted_1))
      : _createCommentVNode("v-if", true)
  }
}
>>> template v-if
const _Vue = Vue
const { createVNode: _createVNode, createCommentVNode: _createCommentVNode, createTextVNode: _createTextVNode } = _Vue

const _hoisted_1 = /*#__PURE__*/_createVNode("div", null, null, -1 /* HOISTED */)
const _hoisted_2 = /*#__PURE__*/_createTextVNode("hello")
const _hoisted_3 = /*#__PURE__*/_createVNode("p", null, null, -1 /* HOISTED */)

return function render(_ctx, _cache) {
  with (_ctx) {
    const { createVNode : _createVNode, createTextVNode : _createTextVNode, Fragment : _Fragment, openBlock : _openBlock, createBlock : _createBlock, createCommentVNode : _createCommentVNode } = _Vue

    return ok
      ? (_openBlock(), _createBlock(_Fragment, { key: 0 }, [
          _hoisted_1,
          _hoisted_2,
          _hoisted_3
        ], 64 /* STABLE_FRAGMENT */))
      : _createCommentVNode("v-if", true)
  }
}
undefined
#+end_example

BUG: è¿™é‡Œå±…ç„¶å°‘äº†ä¸ª ~_hoisted_2~ ???

#+begin_src js
[
  _hoisted_1,
  ,
  _hoisted_3
]
#+end_src

ç­”ï¼š ~genNode()~ ä¸­ç¼ºå°‘å¯¹ ~4,TEXT_CALL~ çº¯æ–‡æœ¬ç±»å‹å¤„ç†ã€‚

è§£ï¼š[[https://github.com/gcclll/stb-vue-next/commit/2372b5fb793da98a8330aa843137e852d5c375c1][fix: v-if TEXT_CALL gen node Â· gcclll/stb-vue-next@2372b5f]]

#+begin_comment
æ›´å¤šæµ‹è¯•ç”¨ä¾‹(~<f12>~)æ‰“å¼€æ§åˆ¶å°æŸ¥çœ‹ ->> ã€‚
#+end_comment

#+begin_export html
<script>
l1(`v-if æŒ‡ä»¤`)
compile(`<div v-if="ok"/>`, 'basic v-if')
compile(`<template v-if="ok"><div/>hello<p/></template>`, 'template v-if')
compile(`<Component v-if="ok"></Component>`, 'component v-if')
</script>
#+end_export
** fa77b51 v-else/v-else-if

[[https://github.com/gcclll/stb-vue-next/commit/fa77b5146f3a3af6c8372012cb6a4d8482adb0c6][feat(add): v-else Â· gcclll/stb-vue-next@fa77b51]]

ä¿®æ”¹ç‚¹ï¼š

1. ~processCodegen()~ å‡½æ•°é‡Œé¢å¢åŠ åˆ†æ”¯å¤„ç†

  [[http://qiniu.ii6g.com/img/20201209164845.png]] 
    è¿™é‡Œæœ‰ä¸€ä¸ªéœ€è¦æ³¨æ„çš„ç‚¹: ~getParentCondition()~ ä¼šä¸€ç›´æŸ¥æ‰¾
   ~JS_CONDITIONAL_EXPRESSION~ ç±»å‹èŠ‚ç‚¹çš„ ~alternate~ ï¼Œå¦‚æœå®ƒä¾æ—§æ˜¯ä¸ª
   ~JS_CONDITIONAL_EXPRESSION~ ç±»å‹ï¼Œè¯´æ˜æ˜¯å¤šçº§çš„ ~if/else~ æ¡ä»¶è¯­å¥ï¼Œç›´åˆ°æ‰¾åˆ°æœ€
   åä¸€ä¸ªä¸æ˜¯ä¸ºæ­¢ã€‚

   ç›¸å½“äº ï¼š ~c1 ? cons1 : c2 ? cons2 : c3 ? cons3 : alt~ ä¼šä¸€ç›´ä» ~c1~ èŠ‚ç‚¹å¼€å§‹
   æŸ¥æ‰¾ç›´åˆ°æ‰¾åˆ°æœ€åçš„é‚£ä¸ª ~alt~ èŠ‚ç‚¹ä¸ºæ­¢ï¼Œç„¶åå°†æ–°çš„åˆ†æ”¯æŒ‚åˆ° ~alt~ åé¢ç»„ç»‡æˆæ–°
   çš„åˆ†æ”¯:  ~c1 ? cons1 : c2 ? cons2 : c3 ? cons3 : c4 ? cons4 : newalt~

   #+begin_comment
    PS: c1, c2, c3, c4 åˆ†åˆ«ä»£è¡¨åˆ†æ”¯èŠ‚ç‚¹çš„ ~test~ ï¼Œæœ€åè¿½åŠ çš„ ~c4 ? cons4 :
    newalt~ ä¸‰ä¸ªå¯¹è±¡éƒ½å±äºæ–°åŠ çš„èŠ‚ç‚¹ï¼Œ ~{test -> c4, cons4 -> consequent,
    alternate -> newalt }~
   #+end_comment

2. ~processIf()~ é‡Œå¢åŠ åˆ†æ”¯å¤„ç†

   æ–°å¢ä»£ç é‡Œæœ‰ä¸ª ~while~ å¾ªç¯å»ä»å½“å‰çš„åˆ†æ”¯èŠ‚ç‚¹å¼€å§‹åœ¨å®ƒçš„å…„å¼ŸèŠ‚ç‚¹é‡Œé¢å¾€å›æ‰¾ï¼Œç›´
   åˆ°æ‰¾åˆ°ç¬¬ä¸€ä¸ª ~9,IF~ èŠ‚ç‚¹ï¼Œè¿™ä¸­é—´ä¸å…è®¸å‡ºç°å…¶ä»–æœ‰æ•ˆèŠ‚ç‚¹(é™¤æ³¨é‡Šï¼Œç©ºæ–‡æœ¬èŠ‚ç‚¹å¤–)ï¼Œ
   å› ä¸º ~v-if/else~ æŒ‡ä»¤èŠ‚ç‚¹å¿…é¡»ç´§é ç€ã€‚

   æ‰¾åˆ°ä¹‹åï¼Œè¦å°†å½“å‰åˆ†æ”¯èŠ‚ç‚¹åˆ é™¤ï¼Œå¹¶ä¸”åŒæ—¶è¦å»æ‰‹åŠ¨ ~traverseNode(branch)~ ä¸€æ¬¡ï¼Œ
   å› ä¸ºä»–åœ¨åŸæ¥çš„ ast æ ‘ç§åˆ é™¤äº†ï¼Œæ‰€ä»¥åŸæ¥çš„ traverse è¿›ç¨‹ä¸ä¼šéå†å®ƒï¼Œå› æ­¤éœ€è¦æ‰‹
   åŠ¨æ‰§è¡Œ traverse å»å¤„ç†å®ƒåŠå…¶å­©å­èŠ‚ç‚¹ç”Ÿæˆå¯¹åº”çš„ codegenNode ã€‚

   ç„¶åå°†å…¶ push åˆ° ~9,IF~ èŠ‚ç‚¹çš„ ~node.branches~ é‡Œé¢ä½œä¸ºåˆ†æ”¯ã€‚

3. ~isSameKey(a,b)~ æ–°å¢ï¼Œæ£€æµ‹ä¸¤ä¸ª key å±æ€§æ˜¯ä¸æ˜¯ç›¸åŒ

   å‡ ç§åˆ¤å®šä¸ºä¸ç›¸åŒçš„æ¡ä»¶ï¼š
   1) key ç±»å‹ä¸åŒ (~a.type !== b.type~)

   2) key å€¼ä¸åŒ (~a.value.content !== b.value.content~)

   3) key å¦‚æœæ˜¯æŒ‡ä»¤ç±»å‹ï¼Œæ£€æµ‹è¡¨è¾¾å¼ç±»å‹ï¼Œé™æ€å±æ€§å¼‚åŒ(~isStatic~)

4. ~getParentCondition()~ æ–°å¢ï¼Œé€’å½’ ~9ï¼ŒIF~ èŠ‚ç‚¹çš„
   ~node.alternate.alternate.alternate...~ ç›´åˆ°æ‰¾åˆ° ~alternate~ ä¸æ˜¯
   ~JS_CONDITIONAL_EXPRESSION~ çš„æƒ…å†µ
      

FIX: [[https://github.com/gcclll/stb-vue-next/commit/464d6815adf49596065440001e0bc5397ad2aa69][fix: v-else current node dont removed Â· gcclll/stb-vue-next@464d681]]

æµ‹è¯•ï¼š
#+begin_src js

const {
  baseParse,
  baseCompile
} = require(process.env.PWD + '/../../static/js/vue/compiler-core.global.js')
 
const { code } = baseCompile(`<div v-if="ok"/><p v-else/>`)
console.log(code)
#+end_src

#+RESULTS:
#+begin_example
const _Vue = Vue

return function render(_ctx, _cache) {
  with (_ctx) {
    const { createVNode : _createVNode, openBlock : _openBlock, createBlock : _createBlock, createCommentVNode : _createCommentVNode } = _Vue

    return ok
      ? (_openBlock(), _createBlock("div", { key: 0 }))
      : (_openBlock(), _createBlock("p", { key: 1 }))
  }
}
undefined
#+end_example

#+begin_comment
æ›´å¤šæµ‹è¯•(~<f12>~)æ‰“å¼€æ§åˆ¶å°æŸ¥çœ‹ ->> ã€‚
#+end_comment

#+begin_export html
<script>
compile(`<div v-if="ok"/><p v-else/>`, 'v-if + v-else')
compile(`<template v-if="ok"><div/>hello<p/></template>`, 'template v-if')
compile(`<div v-if="ok"/><p v-else-if="orNot"/>`, 'v-if + v-else-if')
compile(`<div v-if="ok"/><p v-else-if="orNot"/><template v-else>fine</template>`, 'v-if + v-else-if + v-else')
compile(`
        <div v-if="ok"/>
        <!--foo-->
        <p v-else-if="orNot"/>
        <!--bar-->
        <template v-else>fine</template>
      `, 'comment between branches')

l1(`with prefixIdentifiers ... TODO`)
l1(`errors`)
compile(`<div v-else/>`, `<div v-else/> æ²¡æœ‰åŒ¹é…çš„ v-if`)
compile(`<div v-else-if="foo"/>`, `<div v-else-if="foo"/>, æ²¡æœ‰åŒ¹é…çš„ v-if`)
compile(`<div v-if="ok" :key="a + 1" /><div v-else :key="a + 1" />`,
`<div v-if="ok" :key="a + 1" /><div v-else :key="a + 1" />, ç›¸åŒçš„ key`
)
log.red(`ä¸å…è®¸ä¸åŒåˆ†æ”¯ä½¿ç”¨ç›¸ä¼¼çš„ keyï¼Œå› ä¸º key æ˜¯æŒ‡ä»¤å±æ€§ï¼Œå› æ­¤ä¼šå¯¹æ¯”å®ƒçš„ç±»å‹åŠè¡¨è¾¾å¼`)
l1(`v-on with v-if`)
compile(`<button v-on="{ click: clickEvent }" v-if="true">w/ v-if</button>`, 'v-if ä¸Šä½¿ç”¨ v-on æŒ‡ä»¤')
log.blue(`å› ä¸ºè¿™é‡Œç”¨çš„æ˜¯æ— å‚æ•°çš„ v-on æ‰€ä»¥ä¼šå¯¼è‡´æ‰€æœ‰å±æ€§è¢«åˆå¹¶(_mergeProps(...))ã€‚`)
</script>

#+end_export

BUG: v-else-if è¢«è§£ææˆäº† ~else~ å› ä¸º parser é˜¶æ®µåŒ¹é…æ­£åˆ™ä¸å¯¹ã€‚
[[https://github.com/gcclll/stb-vue-next/commit/5b83d1c12a8580638d7952e712f7c6776a099a50][fix: parser v-else-if failed Â· gcclll/stb-vue-next@5b83d1c]]
* 6c82066 add v-for transform

[[https://github.com/gcclll/stb-vue-next/commit/3a1662ecde9600525088a48420e526b6f9820931][feat(init): v-for Â· gcclll/stb-vue-next@3a1662e]]

[[https://github.com/gcclll/stb-vue-next/commit/6c8206676c5d5229c853fb21cb91aad1a9f1d4a2][feat: v-for directive Â· gcclll/stb-vue-next@6c82066]]

v-for æŒ‡ä»¤å®ç°è¿‡ç¨‹ä¸­éœ€è¦ç”¨åˆ°çš„å‡ ä¸ªå‡½æ•°ï¼š

- ~transformFor()~ æœ€ç»ˆç”Ÿæˆçš„ tranformXxx å‡½æ•°
- ~createStructuralDirectiveTransform()~ åŒ ~v-if~ æŒ‡ä»¤
- ~processFor()~ å¤„ç† ~v-for~ æŒ‡ä»¤å…¥å£
- ~processCodegen()~ åŒ ~v-if~ ç”¨æ¥ç”Ÿæˆ ~codegenNode~ çš„å‡½æ•°
- ~parseForExpression()~ å°† ~v-for="item in items"~ è¡¨è¾¾å¼è§£ææˆ
  ~ForParseResult{source, value, key, index}~ ç±»å‹ AST ã€‚
- ~createAliasExpression()~ ç»™ ~value, key, index~ åˆ›å»º ~SIMPLE_EXPRESSION~ ç±»å‹
  ç»“æ„ã€‚
- ~createForLoopParams()~ åˆ›å»º ~_renderList~ å‡½æ•°å›è°ƒçš„å‚æ•° ~[value, key,
  index]~ ï¼Œå¦‚æœæ²¡æœ‰ä½¿ç”¨é»˜è®¤å˜é‡ï¼š ~_~ æˆ– ~__~ ï¼Œå¦‚ï¼š ~(_, __, index)~


å…¶ä¸­ ~parseForExpression()~ å‡½æ•°æ˜¯è§£æ ~v-for~ è¡¨è¾¾å¼çš„æ ¸å¿ƒå‡½æ•°ï¼Œé‡Œé¢ä½¿ç”¨äº†ä¸‰ä¸ª
æ­£åˆ™ï¼Œç”¨æ¥åŒ¹é…æŒ‡ä»¤è¡¨è¾¾å¼ï¼š

1. ~const forAliasRE = /([\s\S]*?)\s+(?:in|of)\s+([\s\S]*)/~

   [[http://qiniu.ii6g.com/img/20201210155617.png]]

   åŒ¹é… ~v-for="item in items"~ ä¸­çš„å€¼éƒ¨åˆ†

   #+begin_src js
   const re = /([\s\S]*?)\s+(?:in|of)\s+([\s\S]*)/
   const log = (params) => console.log(params.map((p, i) => `${i}, ${p}`).join(`\n`))
   log.title = console.log

   log.title(`>>> åŒ¹é… item in items`)
   log("item in items".match(re))
   log.title(`>>> åŒ¹é… (item, key) in items`)
   log("( item, key ) in items".match(re))
   #+end_src

   #+RESULTS:
   : >>> åŒ¹é… item in items
   : 0, item in items
   : 1, item
   : 2, items
   : >>> åŒ¹é… (item, key) in items
   : 0, ( item, key ) in items
   : 1, ( item, key )
   : 2, items
   : undefined

2. ~const forIteratorRE = /,([^,\}\]]*)(?:,([^,\}\]]*))?$/~

   [[http://qiniu.ii6g.com/img/20201210161642.png]]

   è¿™ä¸ªæ­£åˆ™è¡¨è¾¾å¼ç”¨æ¥åŒ¹é… ~(item, key) in items~ ä¸­çš„ ~item~ å’Œ ~key~

   #+begin_src js
   const re = /,([^,\}\]]*)(?:,([^,\}\]]*))?$/ 
   const log = (params) => console.log(params.map((p, i) => `${i}, ${p}`).join(`\n`))
   log.title = console.log

   log.title(`>>> åŒ¹é… 'item, key, index' ä¸­çš„ key å’Œ index`)
   log("item, key, index".match(re))
   log.title(`>>> åŒ¹é… "item, key" ä¸­çš„ key`)
   log("item, key".match(re))
   #+end_src

   #+RESULTS:
   : >>> åŒ¹é… 'item, key, index' ä¸­çš„ key å’Œ index
   : 0, , key, index
   : 1,  key
   : 2,  index
   : >>> åŒ¹é… "item, key" ä¸­çš„ key
   : 0, , key
   : 1,  key
   : 2, undefined
   : undefined

3. ~const stripParensRE = /^\(|\)$/g~ è¿™ä¸ªç”¨æ¥åŒ¹é… ~(item, key, index)~ å‰åæ‹¬å·


~parseForExpression()~ æ ¸å¿ƒå®ç°ï¼š

1. ~source~ æ•°æ®æºï¼Œ ~forAliasRE~ åŒ¹é…åçš„ ~RHS~ å€¼
   
   #+begin_src json
   source: {
    type: 4, // SIMPLE_EXPRESSION
    loc: { source: 'obj', start: [Object], end: [Object] },
    isConstant: false,
    content: 'obj',
    isStatic: false
   }
   #+end_src
2. ~value~ çš„å–å€¼ï¼Œåœ¨ AST ä¸­å¯¹åº” ~valueAlias~

   ~valueContent = valueContent.replace(forIteratorRE,
   '').trim()~

   é€šè¿‡åŒ¹é… ~key, index~ çš„æ­£åˆ™ï¼Œåå‘æ›¿æ¢å¾—åˆ° ~value~
    #+begin_src js
    const re = /,([^,\}\]]*)(?:,([^,\}\]]*))?$/
    console.log(`item, key, index`.replace(re, '').trim())
    console.log(`>>> æ”¯æŒè§£æ„`)
    console.log(`[ id, value ], key, index`.replace(re, '').trim())
    #+end_src

    #+RESULTS:
    : item
    : >>> æ”¯æŒè§£æ„
    : [ id, value ]
    : undefined

    è§£æåçš„ç»“æ„ï¼š
    #+begin_src json
    valueAlias: {
        type: 4, // SIMPLE_EXPRESSION
        loc: { source: 'value', start: [Object], end: [Object] },
        isConstant: false,
        content: 'value',
        isStatic: false
    }
    #+end_src
3. ~key~ å–å€¼å¤„ç†ï¼Œåœ¨ AST ä¸­å¯¹åº” ~keyAlias~

   #+begin_src js
    keyAlias: {
        type: 4,
        loc: { source: 'key', start: [Object], end: [Object] },
        isConstant: false,
        content: 'key',
        isStatic: false
    }
   #+end_src
4. ~index~ å–å€¼å¤„ç†ï¼Œåœ¨ ASTä¸­å¯¹åº” ~objectIndexAlias~

   #+begin_src js
    objectIndexAlias: {
        type: 4,
        loc: { source: 'index', start: [Object], end: [Object] },
        isConstant: false,
        content: 'index',
        isStatic: false
    }
   #+end_src


æµ‹è¯•ï¼š
#+begin_src js
const {
  baseParse,
  baseCompile
} = require(process.env.PWD + '/../../static/js/vue/compiler-core.global.js')
 
const { ast } = baseCompile(`<span v-for="(value, key, index) in obj" />`)
const { source, valueAlias, keyAlias, objectIndexAlias, type } = ast.codegenNode
console.log(`type: ${type}`)
console.log(`>>> æ•°æ®æº`)
console.log(source)
console.log(`>>> value`)
console.log(valueAlias)
console.log(`>>> key`)
console.log(keyAlias)
console.log(`>>> index`)
console.log(objectIndexAlias)
console.log(`>>> _renderList(obj, (value, key, index) => {...}) ç¬¬äºŒä¸ªå‚æ•°`)
console.log(ast.codegenNode.codegenNode.children.arguments[1])
#+end_src

#+RESULTS:
#+begin_example
type: 11
>>> æ•°æ®æº
{
  type: 4,
  loc: {
    source: 'obj',
    start: { column: 37, line: 1, offset: 36 },
    end: { column: 40, line: 1, offset: 39 }
  },
  isConstant: false,
  content: 'obj',
  isStatic: false
}
>>> value
{
  type: 4,
  loc: {
    source: 'value',
    start: { column: 15, line: 1, offset: 14 },
    end: { column: 20, line: 1, offset: 19 }
  },
  isConstant: false,
  content: 'value',
  isStatic: false
}
>>> key
{
  type: 4,
  loc: {
    source: 'key',
    start: { column: 22, line: 1, offset: 21 },
    end: { column: 25, line: 1, offset: 24 }
  },
  isConstant: false,
  content: 'key',
  isStatic: false
}
>>> index
{
  type: 4,
  loc: {
    source: 'index',
    start: { column: 27, line: 1, offset: 26 },
    end: { column: 32, line: 1, offset: 31 }
  },
  isConstant: false,
  content: 'index',
  isStatic: false
}
>>> _renderList(obj, (value, key, index) => {...}) ç¬¬äºŒä¸ªå‚æ•°
{
  type: 18, // JS_FUNCTION_EXPRESSION
  params: [
    {
      type: 4,
      loc: [Object],
      isConstant: false,
      content: 'value',
      isStatic: false
    },
    {
      type: 4,
      loc: [Object],
      isConstant: false,
      content: 'key',
      isStatic: false
    },
    {
      type: 4,
      loc: [Object],
      isConstant: false,
      content: 'index',
      isStatic: false
    }
  ],
  returns: {
    type: 13,
    tag: '"span"',
    props: undefined,
    children: undefined,
    patchFlag: undefined,
    dynamicProps: undefined,
    directives: undefined,
    isBlock: true,
    disableTracking: false,
    loc: {
      start: [Object],
      end: [Object],
      source: '<span v-for="(value, key, index) in obj" />'
    }
  },
  newline: true,
  isSlot: false,
  loc: {
    source: '',
    start: { line: 1, column: 1, offset: 0 },
    end: { line: 1, column: 1, offset: 0 }
  }
}
undefined
#+end_example
* 39a20fe add v-for generator

[[https://github.com/gcclll/stb-vue-next/commit/39a20fef0001cf22de6632f96df474c87a127a9d][feat(add): v-for generator Â· gcclll/stb-vue-next@39a20fe]]

codegen é˜¶æ®µæ–°å¢å¯¹åº”çš„å®ç°ï¼š ~18,JS_FUNCTION_EXPRESSION~

è¿™ä¸ªä¸»è¦æ˜¯ç”¨æ¥è§£æ ~_renderList(source, (value, key, index) => { ... })~ å‡½æ•°çš„
ç¬¬äºŒä¸ªå‚æ•°çš„ï¼Œè¿™æ˜¯ä¸ªç”¨æ¥ render åˆ—è¡¨é¡¹çš„å‡½æ•°ã€‚

æµ‹è¯•ï¼š

#+begin_src js
const {
  baseParse,
  baseCompile
} = require(process.env.PWD + '/../../static/js/vue/compiler-core.global.js')

const { code } = baseCompile('<span v-for="(item) in items" />')
console.log(code)
#+end_src

#+RESULTS:
#+begin_example
const _Vue = Vue

return function render(_ctx, _cache) {
  with (_ctx) {
    const { renderList : _renderList, Fragment : _Fragment, openBlock : _openBlock, createBlock : _createBlock, createVNode : _createVNode } = _Vue

    return (_openBlock(true), _createBlock(_Fragment, null, _renderList(items, (item) => {
      return (_openBlock(), _createBlock("span"))
    )), 256 /* UNKEYED_FRAGMENT */))
  }
}
undefined
#+end_example

#+begin_quote
æ›´å¤šæµ‹è¯•ç”¨ä¾‹è¯· ~<f12>~ æ‰“å¼€æ§åˆ¶å°æŸ¥çœ‹ã€‚
#+end_quote

#+begin_export html
<script>
l1(`v-for directive`)
compile(`<span v-for="(item) in items" />`, `basic v-for`)
compile('<span v-for="(item, key, index) in items" />', 'value + key + index')
compile('<span v-for="(, key, index) in items" />', `skipped value`)
compile('<span v-for="(item,,index) in items" />', `skipped key`)
compile('<span v-for="(,,index) in items" />', `skipped value & key`)
compile('<p v-for="item in 10">{{item}}</p>', `v-for with constant expression`)
compile(`<template v-for="item in items">hello<span/></template>`, `template v-for`)
compile('<template v-for="item in items"><slot/></template>', `template v-for w/ <slot/>`)
log.red(`TODO <slot> å¾…å®Œæˆ......`)
compile('<template v-for="item in items" :key="item.id"><span :id="item.id" /></template>', `template v-for key injection with single child`)
compile('<slot v-for="item in items"></slot>', `v-for on <slot/>`)
log.red(`TODO <slot> å¾…å®Œæˆ......`)
compile('<span v-for="(item) in items" :key="item" />', `keyed v-for`)
compile('<template v-for="item in items" :key="item">hello<span/></template>', `keyed template v-for`)
compile(`<div v-if="ok" v-for="i in list"/>`, `v-if + v-for`)
compile(`<template v-if="ok" v-for="i in list"/>`, 'v-if + v-for on <template>')
compile('<div v-for="i in list" v-foo/>', `v-for on element with custom directive`)

</script>

#+end_export
* 7cb8908 add slot outlet transform

[[https://github.com/gcclll/stb-vue-next/commit/7cb8908700da1bf0c3888a2fcd6857263d09aedd][feat(add): v-slot transform Â· gcclll/stb-vue-next@7cb8908]]

transform ~<slot />~ æ ‡ç­¾ã€‚

~<slot/>~ åœ¨ render å‡½æ•°ä¸­æ˜¯ä»¥ ~_renderSlot($slot, name, props, children)~ å½¢å¼å­˜åœ¨ã€‚

#+begin_comment
<slot> ä¸Šä¸å…è®¸è‡ªå®šä¹‰çš„æŒ‡ä»¤å­˜åœ¨ï¼Ÿ
#+end_comment


ç›¸å…³å‡½æ•°/å‚æ•°ï¼š

1. ~transformSlotOutlet()~ è¯¥é˜¶æ®µçš„ ~tranformXxx~ å‡½æ•°
2. ~SlotOutletProcessResult~ ç±»å‹å®šä¹‰ ~{slotName, slotProps}~
3. ~processSlotOutlet()~, ~<slot/>~ çš„å¤„ç†è¿‡ç¨‹

   é¦–å…ˆæ˜¯è§£ææ’æ§½åç§°(~name~ å±æ€§)ï¼Œè¯¥å±æ€§å¯ä»¥æ˜¯åŠ¨æ€(~<slot :name="myslot"/>~)ä¹Ÿ
   å¯ä»¥æ˜¯é™æ€çš„(~<slot name="myslot"/>~)ã€‚

   ç„¶åè§£æå‡ºæ’æ§½ä¸Šå®šä¹‰çš„ä¸€äº›å±æ€§(é™æ€)ï¼Œé™¤äº† ~:name~ ä¹‹å¤–æ’æ§½ä¸Š *ä¸å…è®¸æœ‰å…¶ä»–çš„
   æŒ‡ä»¤ç±»å‹çš„å±æ€§å­˜åœ¨* ã€‚
4. ~children~ å‚æ•°

   ~<slot><div/><p/></slot>~

   åœ¨ ~<slot>~ æ ‡ç­¾å†…çš„æ‰€æœ‰å…ƒç´ (~<div/><p/>~)ä¼šè¢«è§£ææˆ ~_renderSlot~ çš„ç¬¬å››ä¸ªå‚æ•°ã€‚

æµ‹è¯•ï¼š
#+begin_src js
const {
  baseParse,
  baseCompile
} = require(process.env.PWD + '/../../static/js/vue/compiler-core.global.js')
 
const { ast } = baseCompile(`<slot/>`)
console.log(ast.codegenNode)
#+end_src

#+RESULTS:
#+begin_example
{
  type: 1,
  ns: 0,
  tag: 'slot',
  tagType: 2,
  props: [],
  isSelfClosing: true,
  children: [],
  loc: {
    start: { column: 1, line: 1, offset: 0 },
    end: { column: 8, line: 1, offset: 7 },
    source: '<slot/>'
  },
  codegenNode: {
    type: 14, // JS_CALL_EXPRESSION
    loc: { start: [Object], end: [Object], source: '<slot/>' },
    callee: Symbol(renderSlot),
    arguments: [ '$slots', '"default"' ]
  }
}
undefined
#+end_example

#+begin_quote
æ›´å¤š codegenNode ç»“æœè¯· ~<f12>~ æ‰“å¼€æ§åˆ¶å°æŸ¥çœ‹ã€‚
#+end_quote

#+begin_export html
<script>
l1(`<slot/> æ’æ§½ transform é˜¶æ®µ`)

const _a = ast => [`_renderSlot å‚æ•°åˆ—è¡¨ï¼š` , ast.children[0].codegenNode.arguments ]
const c = (tpl, desc, ast = _a) => compile.call(null, tpl, desc, ast)
c(`<slot/>`, `default slot outlet`)
c(`<slot name="foo" />`, `statically named slot outletï¼Œå«é™æ€åå­—`)
c(`<slot :name="foo" />`, `dynamically named slot outlet, å«åŠ¨æ€åå­—`)
c(null, `TODO dynamically named slot outlet w/ prefixIdentifiers: true`)
c(`<slot foo="bar" :baz="qux" />`, `default slot outlet with propsï¼Œé»˜è®¤æ’æ§½+é™åŠ¨æ€å±æ€§`)
c(`<slot name="foo" foo="bar" :baz="qux" />`, `statically named slot outlet with propsï¼Œé™æ€å…·åæ’æ§½+å…¶ä»–é™åŠ¨æ€å±æ€§`)
c(`<slot :name="foo" foo="bar" :baz="qux" />`, `dynamically named slot outlet with propsï¼ŒåŠ¨æ€å…·åæ’æ§½+å…¶ä»–é™åŠ¨æ€å±æ€§`)
c(`<slot><div/></slot>`, `default slot outlet with fallback`)
c(`<slot name="foo"><div/></slot>`, `named slot outlet with fallback`)
c(`<slot :foo="bar"><div/></slot>`, `default slot outlet with props & fallback`)
c(`<slot name="foo" :foo="bar"><div/></slot>`, `named slot outlet with props & fallback`)
c(`<slot v-foo />`, `error on unexpected custom directive on <slot>ï¼Œä¸å…è®¸æœ‰è‡ªå®šä¹‰æŒ‡ä»¤ï¼Ÿ`)
</script>
#+end_export

** ebdb1ed add track slot scopes

[[https://github.com/gcclll/stb-vue-next/commit/ebdb1edbfd23312d5fb079a3955917745cac2622][feat: add track slot scopes Â· gcclll/stb-vue-next@ebdb1ed]]

è¿˜ä¸çŸ¥é“å¹²å—çš„â“ 

#+begin_src typescript
// A NodeTransform that:
// 1. Tracks scope identifiers for scoped slots so that they don't get prefixed
//    by transformExpression. This is only applied in non-browser builds with
//    { prefixIdentifiers: true }.
// 2. Track v-slot depths so that we know a slot is inside another slot.
//    Note the exit callback is executed before buildSlots() on the same node,
//    so only nested slots see positive numbers.
export const trackSlotScopes: NodeTransform = (node, context) => {
  // <component> or <template>
  if (
    node.type === NodeTypes.ELEMENT &&
    (node.tagType === ElementTypes.COMPONENT ||
      node.tagType === ElementTypes.TEMPLATE)
  ) {
    // We are only checking non-empty v-slot here
    // since we only care about slots that introduce scope variables.
    const vSlot = findDir(node, 'slot')
    if (vSlot) {
      const slotProps = vSlot.exp
      if (!__BROWSER__ && context.prefixIdentifiers) {
        slotProps && context.addIdentifiers(slotProps)
      }

      context.scopes.vSlot++
      return () => {
        if (!__BROWSER__ && context.prefixIdentifiers) {
          slotProps && context.removeIdentifiers(slotProps)
        }
        context.scopes.vSlot--
      }
    }
  }
}
#+end_src
* 36c1f36 build user component as slots(ç»„ä»¶æ˜¯å¦‚ä½•å½“åš slot å¤„ç†çš„)

[[https://github.com/gcclll/stb-vue-next/commit/36c1f36ea2a92119d2a61f3012972229e85b1e30][feat(add): user component treat as slot to build Â· gcclll/stb-vue-next@36c1f36]]

å®Œæ•´ç”¨æˆ·ç»„ä»¶å½“ slot å¤„ç†æµç¨‹å›¾ï¼š
[[/img/vue3/compiler-core/pcg/pcg-v-slot.svg]]

~<Comp><div/></Comp>~

è¿™é‡Œ ~Comp~ æ˜¯ç»„ä»¶ç±»å‹(~tagType=1,COMPONENT~) ä¼šåœ¨ ~transformElement~ ä¸­è¢«å½“åš
~slot~ æ¥å¤„ç†è°ƒç”¨ ~buildSlots()~ ã€‚

#+begin_comment
æ›´å¤šæµ‹è¯•ç”¨ä¾‹(~<f12>~)æ‰“å¼€æ§åˆ¶å°æŸ¥çœ‹ ->> ã€‚
#+end_comment

#+begin_export html
<script>
l1(`<slot /> æ’æ§½ generator é˜¶æ®µ`)
compile(`<Comp><div/></Comp>`, 'implicit default slot')
compile(`<Comp v-slot="{ foo }">{{ foo }}{{ bar }}</Comp>`, 'on-component default slot')
compile(`<Comp v-slot:named="{ foo }">{{ foo }}{{ bar }}</Comp>`, 'on component named slot')
compile(`<Comp>
        <template v-slot:one="{ foo }">
          {{ foo }}{{ bar }}
        </template>
        <template #two="{ bar }">
          {{ foo }}{{ bar }}
        </template>
      </Comp>`, 'template named slots')
compile(`<Comp v-slot:[named]="{ foo }">{{ foo }}{{ bar }}</Comp>`, 'on component dynamically named slot')
compile(`<Comp>
        <template #one>foo</template>bar<span/>
      </Comp>`, 'named slots w/ implicit default slot')
compile(`<Comp>
        <template v-slot:[one]="{ foo }">
          {{ foo }}{{ bar }}
        </template>
        <template #[two]="{ bar }">
          {{ foo }}{{ bar }}
        </template>
      </Comp>`, 'dynamically named slots')
compile(`<Comp>
        <template #default="{ foo }">
          <Inner v-slot="{ bar }">
            {{ foo }}{{ bar }}{{ baz }}
          </Inner>
          {{ foo }}{{ bar }}{{ baz }}
        </template>
      </Comp>`, 'nested slots scoping')

compile(`<div v-for="i in list">
        <Comp v-slot="bar">foo</Comp>
      </div>`, 'should force dynamic when inside v-for')
l2(` TODO should only force dynamic slots when actually using scope vars w/ prefixIdentifiers: true`)
compile(`<Comp>
        <template #one v-if="ok">hello</template>
      </Comp>`, 'named slot with v-if')
l2(` TODO named slot with v-if + prefixIdentifiers: true`)
compile(`<Comp>
        <template #one v-if="ok">foo</template>
        <template #two="props" v-else-if="orNot">bar</template>
        <template #one v-else>baz</template>
      </Comp>`, 'named slot with v-if + v-else-if + v-else')
l2(` TODO 'named slot with v-for w/ prefixIdentifiers: true'`)
compile(`<Comp>
        <template v-for="name in list" #[name]>{{ name }}</template>
      </Comp>`, 'named slot with v-for')
compile(`<Comp><template v-slot:named="slotProps"><div/></template><div :id="defaultSlotId"/></Comp>`, 'å…·åæ’æ§½+å…¶ä»–é template å…ƒç´ å…¨å½“åšé»˜è®¤æ’æ§½å¤„ç†')
</script>
#+end_export

** fbed5cf add component with default slot without <template> transform

[[https://github.com/gcclll/stb-vue-next/commit/fbed5cf508e91ea20195af4dafa491957a4d1d60][feat(add): default slot without template Â· gcclll/stb-vue-next@fbed5cf]]

~<Comp><div/></Comp>~

è¿™ç§æƒ…å†µï¼Œç”¨æˆ·ç»„ä»¶ä¸Šæ—¢æ²¡æœ‰ ~v-slot~ å­©å­èŠ‚ç‚¹é‡Œé¢ä¹Ÿæ²¡æœ‰ ~<template v-slot>~ æœ€å
çš„å¤„ç†æ˜¯ ~<Comp></Comp>~ é‡Œé¢çš„æ‰€æœ‰ children è¢«å½“åšé»˜è®¤æ’æ§½å¤„ç†ã€‚

è¯¥ç¤ºä¾‹ç¬¦åˆï¼š
1. ç»„ä»¶ä¸Šæ²¡æœ‰ ~v-slot~ æŒ‡ä»¤
2. å­©å­èŠ‚ç‚¹é‡Œé¢æ²¡æœ‰ ~<template v-slot:name="slotProps">~

å› æ­¤ï¼Œè¿™é‡Œçš„å¤„ç†æ˜¯å°† ~<div/>~ å³ ~comp.children~ å…¨éƒ¨ä½œä¸ºé»˜è®¤çš„ ~slot:default~
æ¥å¤„ç†ã€‚

å¤„ç†æµç¨‹ï¼š ~<Comp>~ -> ~transformElement~ -> ~isComponent~ -> ~buildSlots()~ ->
~{slots, hasDynamicSlots}~ -> ~vnodeChildren~ -> ~{type: 13,VNODE_CALL,
children: vnodeChildren, ... }~

#+begin_src js
const {
  baseParse,
  baseCompile
} = require(process.env.PWD + '/../../static/js/vue/compiler-core.global.js')

const { ast } = baseCompile(`<Comp><div/></Comp>`)
console.log(ast.codegenNode)
#+end_src

#+RESULTS:
#+begin_example
{
  type: 13,
  tag: '_component_Comp',
  props: undefined,
  children: {
    type: 15,
    loc: { start: [Object], end: [Object], source: '<Comp><div/></Comp>' },
    properties: [ [Object], [Object] ]
  },
  patchFlag: undefined,
  dynamicProps: undefined,
  directives: undefined,
  isBlock: true,
  disableTracking: false,
  loc: {
    start: { column: 1, line: 1, offset: 0 },
    end: { column: 20, line: 1, offset: 19 },
    source: '<Comp><div/></Comp>'
  }
}
undefined
#+end_example

å¦å¤–åœ¨ ~transformElement()~ å‡½æ•°ä¸­é€šè¿‡ ~isComponent = node.tagType ===
ElementTypes.COMPONENT~ æ£€æµ‹æ˜¯ä¸æ˜¯ç”¨æˆ·ç»„ä»¶ï¼Œå¦‚æœæ˜¯ç»§ç»­è§£æè¯¥ç»„ä»¶ç±»å‹(~resolveComponentType()~)ã€‚

è¿™é‡Œæœ€ç»ˆå¾—åˆ°çš„ç»“æœæ˜¯ï¼š ~vnodeTag = _component_Comp~ ä½œä¸ºæ ‡ç­¾åï¼Œä¹Ÿæ˜¯è¯¥ ~<Comp/>~
ç»„ä»¶åœ¨ Vue å®ä¾‹è¿‡ç¨‹ä¸­çš„å­˜åœ¨çš„æ ‡ç­¾å(ç»„ä»¶åç§°)ã€‚

** 8bed175 add component with default slot without <template> generator

[[https://github.com/gcclll/stb-vue-next/commit/8bed17574988042023be8ac420254918232ef7c4][feat(add): user component resolver generator Â· gcclll/stb-vue-next@8bed175]]

å› ä¸ºåœ¨ transform é˜¶æ®µ transformElement è¿‡ç¨‹ä¸­ï¼Œæ£€æµ‹åˆ° ~<Comp>~ æ˜¯ä¸ªç”¨æˆ·ç»„ä»¶ï¼Œæ‰€
ä»¥å°†å…¶å¢åŠ åˆ°äº† ~context.components.add('Comp')~ ä¸­äº†ï¼Œåœ¨ generator é˜¶æ®µä¼šå»æ£€æµ‹
è¿™ä¸ª ~components~ ç”¨æ¥è§£æç»„ä»¶å¾—åˆ°ç»„ä»¶çš„å¼•ç”¨ï¼š

~_component_Comp = _resolveComponent("Comp")~

æ–°å¢çš„ä»£ç ä¸»è¦ç”±ä¸¤éƒ¨åˆ†ï¼š

1. æ–°å¢ ~genAssets()~ å‡½æ•°å¤„ç† ~context.components~

   å¤„ç†ä¹‹åçš„ç»“æœå°±æ˜¯å¢åŠ  ~_component_Comp = _resolveComponent("Comp")~

2. åœ¨ ~generate()~ ä¸­å¢åŠ  ~ast.components~ æ£€æµ‹ï¼Œå¦‚æœæœ‰å†…å®¹è°ƒç”¨ ~genAssets()~ è§£
   æ


#+begin_src typescript
// generate() ä¸­å¢åŠ 
 if (ast.components.length) {
    genAssets(ast.components, 'component', context)
    if (ast.directives.length || ast.temps > 0) {
      newline()
    }
  }

// æ–°å¢
function genAssets(
  assets: string[],
  type: 'component' | 'directive',
  { helper, push, newline }: CodegenContext
) {
  const resolver = helper(
    type === 'component' ? RESOLVE_COMPONENT : RESOLVE_DIRECTIVE
  )

  for (let i = 0; i < assets.length; i++) {
    const id = assets[i]
    push(
      `const ${toValidAssetId(id, type)} = ${resolver}(${JSON.stringify(id)})`
    )
    if (i < assets.length - 1) {
      newline()
    }
  }
}
#+end_src

æµ‹è¯•ï¼š
#+begin_src js

const {
  baseParse,
  baseCompile
} = require(process.env.PWD + '/../../static/js/vue/compiler-core.global.js')

const { code } = baseCompile(`<Comp><div/></Comp>`, { hoistStatic: true })
console.log(code)
#+end_src

#+RESULTS:
#+begin_example
const _Vue = Vue
const { createVNode: _createVNode } = _Vue

const _hoisted_1 = /*#__PURE__*/_createVNode("div", null, null, -1 /* HOISTED */)

return function render(_ctx, _cache) {
  with (_ctx) {
    const { createVNode : _createVNode, resolveComponent : _resolveComponent, withCtx : _withCtx, openBlock : _openBlock, createBlock : _createBlock } = _Vue

    const _component_Comp = _resolveComponent("Comp")

    return (_openBlock(), _createBlock(_component_Comp, null, {
      default: _withCtx(() => [
        _hoisted_1
      ]),
      _: 1
    }))
  }
}
undefined
#+end_example

ç¼ºå°‘ ~1 /* STABLE */~ æ³¨é‡Š: [[https://github.com/gcclll/stb-vue-next/commit/08a6fcaab9224552dbd7876930d964e6bcc534d9][fix: slot flag text Â· gcclll/stb-vue-next@08a6fca]]

æ³¨æ„ ~_createBlock()~ çš„ç¬¬ä¸‰ä¸ªå‚æ•°å˜æˆäº†ä¸€ä¸ªå¯¹è±¡(~children~) å¯¹è±¡é‡Œé¢åŒ…å«äº†ä¸¤ä¸ª
å±æ€§: ~default~ å’Œ ~_~ åˆ†åˆ«ä»£è¡¨äº†é»˜è®¤æ’æ§½ä¸‹çš„å­©å­èŠ‚ç‚¹ï¼Œå’Œè¯¥æ’æ§½æ ‡è¯†(~1-STABLE,2-FORWARDED,3-DYNAMIC~)
** 9f58154 fix: æ–‡æœ¬èŠ‚ç‚¹æ²¡æœ‰åˆå¹¶(~transformText~)

[[https://github.com/gcclll/stb-vue-next/commit/9f58154809447e6b718e1579149165fc848e8185][fix: adjacent text node need merge Â· gcclll/stb-vue-next@9f58154]]

å¯¹äº ~`<Comp v-slot="{ foo }">{{ foo }}{{ bar }}</Comp>`~ ç”¨ä¾‹å¾—åˆ°çš„ç»“æœéé¢„æœŸã€‚

vue-next æ­£ç¡®ç»“æœï¼š
#+begin_src js
const {
  baseCompile
} = require(process.env.PWD + '/../../static/vue/vue.js')
 
const { ast } = baseCompile(`<Comp v-slot="{ foo }">{{ foo }}{{ bar }}</Comp>`)
const returns = ast.codegenNode.children.properties[0].value.returns
console.log(returns)
console.log(`>>> è§£æåçš„ {{ foo }} {{ bar }} åº”è¯¥åˆå¹¶`)
console.log(returns[0].content)
console.log(`>>> ä¸‹é¢æ­£æ˜¯åˆå¹¶ä¹‹åçš„ä¸¤ä¸ªæ’å€¼`)
console.log(returns[0].content.children)
#+end_src

#+RESULTS:
#+begin_example
You are running a development build of Vue.
Make sure to use the production build (*.prod.js) when deploying for production.
[
  {
    type: 12,
    content: { type: 8, loc: [Object], children: [Array] },
    loc: { start: [Object], end: [Object], source: '{{ foo }}' },
    codegenNode: {
      type: 14,
      loc: [Object],
      callee: Symbol(createTextVNode),
      arguments: [Array]
    }
  }
]
>>> è§£æåçš„ {{ foo }} {{ bar }} åº”è¯¥åˆå¹¶
{
  type: 8,
  loc: {
    start: { column: 24, line: 1, offset: 23 },
    end: { column: 33, line: 1, offset: 32 },
    source: '{{ foo }}'
  },
  children: [
    { type: 5, content: [Object], loc: [Object] },
    ' + ',
    { type: 5, content: [Object], loc: [Object] }
  ]
}
>>> ä¸‹é¢æ­£æ˜¯åˆå¹¶ä¹‹åçš„ä¸¤ä¸ªæ’å€¼
[
  {
    type: 5,
    content: {
      type: 4,
      isStatic: false,
      constType: 0,
      content: 'foo',
      loc: [Object]
    },
    loc: { start: [Object], end: [Object], source: '{{ foo }}' }
  },
  ' + ',
  {
    type: 5,
    content: {
      type: 4,
      isStatic: false,
      constType: 0,
      content: 'bar',
      loc: [Object]
    },
    loc: { start: [Object], end: [Object], source: '{{ bar }}' }
  }
]
undefined
#+end_example

çœ‹ä¸‹ç°é˜¶æ®µ stb-vue-next è¾“å‡ºç»“æœï¼š
#+begin_src js

const {
  baseCompile
} = require(process.env.PWD + '/../../static/js/vue/compiler-core.global.js')
 
const { ast } = baseCompile(`<Comp v-slot="{ foo }">{{ foo }}{{ bar }}</Comp>`)
const returns = ast.codegenNode.children.properties[0].value.returns
console.log(returns[0].content)
console.log(returns[1].content)
#+end_src

#+RESULTS:
#+begin_example
{
  type: 5,
  content: {
    type: 4,
    isStatic: false,
    isConstant: false,
    content: 'foo',
    loc: { start: [Object], end: [Object], source: 'foo' }
  },
  loc: {
    start: { column: 24, line: 1, offset: 23 },
    end: { column: 33, line: 1, offset: 32 },
    source: '{{ foo }}'
  }
}
{
  type: 5,
  content: {
    type: 4,
    isStatic: false,
    isConstant: false,
    content: 'bar',
    loc: { start: [Object], end: [Object], source: 'bar' }
  },
  loc: {
    start: { column: 33, line: 1, offset: 32 },
    end: { column: 42, line: 1, offset: 41 },
    source: '{{ bar }}'
  }
}
undefined
#+end_example

stb-vue-next æ˜æ˜¾ returns é‡Œé¢åŒ…å«äº†ä¸¤ä¸ªå…ƒç´ åˆ†åˆ«æ˜¯ï¼š ~{{ foo }}~ å’Œ ~{{ bar }}~

è¿™æ˜¯å› ä¸ºåœ¨ ~transformText~ é‡Œé¢æ²¡æœ‰è¿›è¡Œæ–‡æœ¬(æ’å€¼ä¹Ÿç®—)åˆå¹¶ã€‚
** 0773374 add component nested slots scoping

[[https://github.com/gcclll/stb-vue-next/commit/0773374334feb1ed86ff38c65dea917480b6cb89][fix: patchFlag should |= but != Â· gcclll/stb-vue-next@0773374]]

æ’æ§½åµŒå¥—ä½¿ç”¨ã€‚

#+begin_src js
`<Comp>
    <template #default="{ foo }">
        <Inner v-slot="{ bar }">
        {{ foo }}{{ bar }}{{ baz }}
        </Inner>
        {{ foo }}{{ bar }}{{ baz }}
    </template>
</Comp>`
#+end_src

æ’æ§½åµŒå¥—ä½¿ç”¨æ—¶çš„è§£ææ˜¯å…ˆé‡Œåå¤–ï¼Œå› ä¸ºåœ¨ transform é˜¶æ®µ ast é˜¶æ®µè½¬æ¢ä¹‹åï¼Œä¼šè¿›è¡Œå›
æº¯ï¼Œå›æº¯è¿‡ç¨‹æ˜¯ç›¸åçš„ã€‚

å¦‚ï¼š

ast ç»“æ„ transformï¼š

~Comp.children -> [template] -> template.children -> [Inner, foo, bar, baz] ->
Inner.children -> [foo, bar, baz]~

astå›æº¯:

~Inner.children -> Inner -> template.children -> template -> Comp.children -> Comp~

æ‰€ä»¥é¦–å…ˆæ‰§è¡Œ ~transformElement()~ çš„æ˜¯ ~Inner~ æ‰€ä»¥å®ƒä¼šå…ˆè¿›å…¥ ~buildSlots()~ æ„
å»ºæ’æ§½ç»“æ„ï¼Œå®Œäº†ä¹‹åæ˜¯ ~<template>~ æœ€åæ˜¯ ~<Comp>~

-----

render æ¨å¯¼è¿‡ç¨‹ï¼š

1. ~<Inner v-slot="{bar}">{{foo}}{{bar}}{{baz}}</Inner>~

   æ˜¯åœ¨ç”¨æˆ·ç»„ä»¶ä¸Šåº”ç”¨äº† ~v-slot~ ä¸”æ˜¯é»˜è®¤æ’æ§½ï¼Œå› æ­¤å®ƒçš„æ‰€æœ‰å­©å­èŠ‚ç‚¹éƒ½ä¼šæˆä¸ºé»˜è®¤
   æ’æ§½ä¸€éƒ¨åˆ†ã€‚

   ç»“æœï¼š
   #+begin_src js
   _createVNode(_component_Inner, null, {
     default: _withCtx(({ bar }) => [
       _createTextVNode(_toDisplayString(foo) + _toDisplayString(bar) + _toDisplayString(baz), 1 /* TEXT */)
     ]),
     _: 2, /* DYNAMIC */
   }, 1024 /* DYNAMIC_SLOTS */)
   #+end_src

   è¿™é‡Œä½¿ç”¨çš„æ˜¯ ~_createVNode~ å› ä¸º ~Inner~ éå”¯ä¸€çš„å­©å­èŠ‚ç‚¹ã€‚
2. ~<template #default="{foo}">...</template>~

   #+begin_src js
   (_openBlock(), _createBlock(_component_Comp, null {
     default: _withCtx(({ foo }) => [
       _createVNode(_component_Inner, null, {
          default: _withCtx(({ bar }) => [
             _createTextVNode(_toDisplayString(foo) + _toDisplayString(bar) + _toDisplayString(baz), 1 /* TEXT */)
           ]),
          _: 2 /* DYNAMIC */
       }, 1024 /* DYNAMIC_SLOTS */),
       _createTextVNode(_toDisplayString(foo) + _toDisplayString(bar) + _toDisplayString(baz), 1 /* TEXT */)
     ]),
     _: 1 /* STABLE */
   }))
   #+end_src

   è¿™é‡Œæœ‰ä¸ªåˆ¤æ–­ ~Inner~ ä¸ºåŠ¨æ€ slot çš„å…³é”®ç‚¹ï¼š ~context.scopes.vSlot > 0~ è€Œè¿™ä¸ª
   å€¼æ˜¯åœ¨æ”¶é›† ~transformXxx~ é˜¶æ®µé€’å¢ +1 è€Œåå›æº¯è¿‡ç¨‹ä¸­ -1 çš„ã€‚

   åœ¨æ”¶é›†é˜¶æ®µ ~<template>~ æ”¶é›†åˆ° ~trackSlotScopes()~ å‡½æ•°æ­¤æ—¶
   ~context.scopes.vSlot = 1~ ç„¶åé€’å½’ childrenæ‰§è¡Œåˆ° ~Inner~ æ”¶é›†é˜¶æ®µçš„æ—¶å€™
   ~context.scopes.vSlot = 2~ ç›´åˆ°é€’å½’ç»“æŸã€‚

   å¼€å§‹å›æº¯ï¼Œå…ˆæ˜¯åœ¨ ~Inner~ ä¸Šåº”ç”¨ transformElement ç›´åˆ° ~Inner~ å›æº¯åˆ°æ‰§è¡Œ
   ~trackSlotScopes()~ åº”ä¸ºå®ƒä¹Ÿæœ‰ ~v-slot~ æŒ‡ä»¤ï¼Œæ‰€ä»¥ ~Inner~ èƒ½æ”¶é›†åˆ°è¿™ä¸ªå‡½æ•°ï¼Œ
   å®ƒå›æº¯ç»“æŸæ‰§è¡Œ ~trackSlotScopes()~ éšä¹‹ ~context.scopes.vSlot--~ æ‰€ä»¥æ­¤æ—¶ï¼Œåœ¨
   å›æº¯ ~Inner~ ç»“æŸä¹‹ååœ¨å¼€å§‹å›æº¯ ~<template>~ ä¹‹å‰ ~context.scopes.vSlot = 1~
   ã€‚

   è¿™å°±æ˜¯ ~Inner~ ä¸ºä»€ä¹ˆæ²¡æœ‰åŠ¨æ€å±æ€§åä½†æ˜¯ä¾æ—§ä¼šåˆ¤æ–­ä¸ºåŠ¨æ€æ’æ§½çš„åŸç†ã€‚

   #+begin_quote
   ä¸€å¥è¯ï¼šå¦‚æœåœ¨ ~<template v-slot>~ é‡Œé¢åµŒå¥—å¦ä¸€ä¸ª ~v-slot~ é‚£ä¸ªè¿™ä¸ªä¸ç®¡æœ‰æ²¡æœ‰
   åŠ¨æ€å±æ€§åéƒ½ä¼šè¢«å½“åšåŠ¨æ€æ’æ§½æ¥å¤„ç†ã€‚
   #+end_quote
** c1ace74 add component with v-slot inside v-for

#+begin_src js
`<div v-for="i in list">
  <Comp v-slot="bar">foo</Comp>
</div>`
#+end_src

~let hasDynamicSlots = context.scopes.vSlot > 0 || context.scopes.vFor > 0;~

æ ¹æ®è¿™ä¸ªåˆ¤æ–­å†³å®š v-for é‡Œé¢çš„ v-slot ä¸ºåŠ¨æ€æ’æ§½ã€‚
** cfef20e add named slot with v-if

[[https://github.com/gcclll/stb-vue-next/commit/cfef20efd83d030924c23308cfb1e38c2b63e228][feat(add): slot with v-if Â· gcclll/stb-vue-next@cfef20e]]

#+begin_src js
`<Comp>
  <template #one v-if="ok">hello</template>
</Comp>`
#+end_src

æµ‹è¯•ï¼š
#+begin_src js
const {
  baseParse,
  baseCompile
} = require(process.env.PWD + '/../../static/js/vue/compiler-core.global.js')

const { code } = baseCompile(`<Comp>
  <template #one v-if="ok">hello</template>
</Comp>`)
console.log(code)
#+end_src

#+RESULTS:
#+begin_example
const _Vue = Vue

return function render(_ctx, _cache) {
  with (_ctx) {
    const { createTextVNode : _createTextVNode, resolveComponent : _resolveComponent, withCtx : _withCtx, createSlots : _createSlots, createVNode : _createVNode, openBlock : _openBlock, createBlock : _createBlock } = _Vue

    const _component_Comp = _resolveComponent("Comp")

    return (_openBlock(), _createBlock(_component_Comp, null, _createSlots({ _: 2 /* DYNAMIC */ }, [
      ok
        ? {
            name: "one",
            fn: _withCtx(() => [
              _createTextVNode("hello")
            ])
          }
        : undefined
    ]), 1024 /* DYNAMIC_SLOTS */))
  }
}
undefined
#+end_example

åŠ¨æ€ slots å¤„ç†ä¹‹åï¼š
~_createSlots({ /* é™æ€ slots */, [ /* åŠ¨æ€ slots åˆ—è¡¨ */ ] })~

çœ‹ä¸‹é¢çš„è¿è¡Œæ—¶çš„ ~createSlots(slots, dynamicSlots)~ å…¶å®å°±æ˜¯è®²ä¸¤è€…åˆå¹¶åœ¨ä¸€èµ·äº†
v-if æ˜¯ä¸ªå¯¹è±¡ ~{ fn, name }~ v-for æ˜¯è¯¥å¯¹è±¡çš„æ•°ç»„ã€‚
#+begin_src typescript
export function createSlots(
  slots: Record<string, Slot>,
  dynamicSlots: (
    | CompiledSlotDescriptor
    | CompiledSlotDescriptor[]
    | undefined)[]
): Record<string, Slot> {
  for (let i = 0; i < dynamicSlots.length; i++) {
    const slot = dynamicSlots[i]
    // array of dynamic slot generated by <template v-for="..." #[...]>
    if (isArray(slot)) {
      for (let j = 0; j < slot.length; j++) {
        slots[slot[j].name] = slot[j].fn
      }
    } else if (slot) {
      // conditional single slot generated by <template v-if="..." #foo>
      slots[slot.name] = slot.fn
    }
  }
  return slots
}
#+end_src

æ‹“å±•ï¼š ~v-else, v-else-if~
[[https://github.com/gcclll/stb-vue-next/commit/e48d46a759478d28eea223c4884ec4815ceb5ac0][feat(add): v-else/v-else-if with v-slot Â· gcclll/stb-vue-next@e48d46a]]

ä¸æ™®é€šçš„ v-else/v-else-if å¤„ç†æœºåˆ¶ä¸€æ ·ï¼Œé¦–å…ˆæ˜¯è¦æ‰¾åˆ°ä»–ä»¬å…„å¼ŸèŠ‚ç‚¹å‰é¢çš„ v-if èŠ‚ç‚¹ï¼Œ
ç„¶åå°†è¯¥èŠ‚ç‚¹æŒ‚æ¥åˆ° v-if èŠ‚ç‚¹åé¢ã€‚

æ ¸å¿ƒä»£ç ï¼š
#+begin_src typescript
// v-else/if on slot
let j = i
let prev
while (j--) {
    // æ‰¾åˆ°ç›¸é‚»çš„ v-if
    prev = children[j]
    // å¾€å›æ‰¾ç¬¬ä¸€ä¸ªéæ³¨é‡Šçš„èŠ‚ç‚¹
    if (prev.type !== NodeTypes.COMMENT) {
        break
    }
}

// å¦‚æœè¯¥èŠ‚ç‚¹æ˜¯ v-if åˆæ³•ï¼Œå¦åˆ™ä¸åˆæ³•ä½¿ç”¨æƒ…å†µ
if (prev && isTemplateNode(prev) && findDir(prev, 'if')) {
    // remove node
    children.splice(i, 1)
    i--
    __TEST__ && assert(dynamicSlots.length > 0)
    // attach this slot to previous conditional
    let conditional = dynamicSlots[
        dynamicSlots.length - 1
    ] as ConditionalExpression

  // è¿™ç›®çš„æ˜¯æ‰¾åˆ° ?: è¡¨è¾¾å¼æœ€åçš„é‚£ä¸ªèŠ‚ç‚¹
    while (
        conditional.alternate.type === NodeTypes.JS_CONDITIONAL_EXPRESSION
    ) {
        conditional = conditional.alternate
    }

  // å°†å½“å‰çš„ v-else/v-else-if æŒ‚åˆ°æœ€åé‚£ä¸ªèŠ‚ç‚¹è¡¨è¾¾å¼ä½ç½®
  // vElse.exp æ£€æµ‹æ˜¯ v-else-if è¿˜æ˜¯ v-else(æ²¡æœ‰å€¼exp)
    conditional.alternate = vElse.exp
        ? createConditionalExpression(
            vElse.exp,
            buildDynamicSlot(slotName, slotFunction),
            defaultFallback
        )
        : buildDynamicSlot(slotName, slotFunction)
} else {
    context.onError(
        createCompilerError(ErrorCodes.X_V_ELSE_NO_ADJACENT_IF, vElse.loc)
    )
}
#+end_src

** c1ace74 add v-for on v-slot component

[[https://github.com/gcclll/stb-vue-next/commit/c1ace746e229db02a9b311d1becfe4deb1513048][feat(add): v-slot inside v-for Â· gcclll/stb-vue-next@c1ace74]]


v-for çš„å¤„ç†å’Œ v-if åŸç†æ˜¯ä¸€æ ·çš„ï¼Œæœ€åè¿”å›çš„éƒ½æ˜¯  ~{name, fn}~ ç±»å‹ï¼Œåªä¸è¿‡
v-for è¿”å›çš„æ˜¯è¿™ä¸ªç±»å‹çš„æ•°ç»„ã€‚

v-for _renderList å’Œ slot çš„ç»“åˆï¼š

#+begin_src js
_renderList(list, (i) => {
  return {
    name: name,
    fn: _withCtx(() => [
      _createTextVNode(_toDisplayString(name), 1 /* TEXT */)
    ])
  }
})

// ç­‰äºæ˜¯ï¼š [ { name, fn }, { name1, fn1 }]
// ç„¶å _renderSlots ->
_renderSlots({ _: 2 /* DYNAMIC */ }, [
  _renderList(list, ...)
])

// -> _createBlock
_createBlock(_component_Comp, null, _renderSlots({
  /* é™æ€ï¼Œæœ€ç»ˆåŠ¨æ€æ’æ§½ä¼šåˆå¹¶åˆ°è¯¥å¯¹è±¡æ¥ */
}, [
  /* ... åŠ¨æ€åˆ—è¡¨ */
]))

// å¯¹æ¯”æ— åŠ¨æ€æ’æ§½æƒ…å†µï¼š
_createBlock(_component_Comp, null {
  default: _withCtx(() => [
    _createTextVNode(_toDisplayString(foo), 1 /* TEXT */)
  ]),
  _: 1 /* STABLE */
})
#+end_src

æµ‹è¯•ï¼š
#+begin_src js
const {
  baseParse,
  baseCompile
} = require(process.env.PWD + '/../../static/js/vue/compiler-core.global.js')
 
const { code } = baseCompile(`<Comp>
        <template v-for="name in list" #[name]>{{ name }}</template>
      </Comp>`)
console.log(code)
#+end_src

#+RESULTS:
#+begin_example
const _Vue = Vue

return function render(_ctx, _cache) {
  with (_ctx) {
    const { toDisplayString : _toDisplayString, createTextVNode : _createTextVNode, resolveComponent : _resolveComponent, withCtx : _withCtx, renderList : _renderList, createSlots : _createSlots, createVNode : _createVNode, openBlock : _openBlock, createBlock : _createBlock } = _Vue

    const _component_Comp = _resolveComponent("Comp")

    return (_openBlock(), _createBlock(_component_Comp, null, _createSlots({ _: 2 /* DYNAMIC */ }, [
      _renderList(list, (name) => {
        return {
          name: name,
          fn: _withCtx(() => [
            _createTextVNode(_toDisplayString(name), 1 /* TEXT */)
          ])
        }
      ))
    ]), 1024 /* DYNAMIC_SLOTS */))
  }
}
undefined
#+end_example

æ— éå°±æ˜¯ä¸åŒç±»å‹å…ƒç´ ã€ç»„ä»¶ render æ–¹å¼çš„ç»„åˆã€‚
** å°ç»“ï¼šv-slot å‡ ç§ç”¨æ³•
:PROPERTIES:
:COLUMNS: %CUSTOM_ID[(Custom Id)]
:CUSTOM_ID: slot-usage
:END: 

1. ~<Comp><div/></Comp>~ , ç”¨æˆ·ç»„ä»¶ä¸Šçš„é»˜è®¤æ’æ§½
   
   #+begin_src js
   const _hoisted_1 = /*# __PURE__ */_createVNode('div', null, null, -1 /* HOISTED */)
   (_openBlock(), _createBlock(_component_Comp, null, {
     default: _withCtx(() => [
       _hoisted_1
     ]),
     _: 1 /* STABLE */
   }))
   #+end_src
2. ~<Comp v-slot="slotProps"><div/></Comp>~, ç”¨æˆ·ç»„ä»¶ä¸Šå¸¦ ~slotProps~ çš„é»˜è®¤æ’æ§½
   
   #+begin_src js
   const _hoisted_1 = /*# __PURE__ */_createVNode('div', null, null, -1 /* HOISTED */)
   (_openBlock(), _createBlock(_component_Comp, null, {
     default: _withCtx((slotProps) => [
       _hoisted_1
     ]),
     _: 1 /* STABLE */
   }))
   #+end_src
3. ~<Comp v-slot:named="slotProps">~, ç”¨æˆ·ç»„ä»¶ä¸Šå…·åæ’æ§½

   #+begin_src js
   const _hoisted_1 = /*# __PURE__ */_createVNode('div', null, null, -1 /* HOISTED */)
   (_openBlock(), _createBlock(_component_Comp, null, {
     named: _withCtx((slotProps) => [
       _hoisted_1
     ])
   }))
   #+end_src

4. ~<Comp v-slot:[named]="slotProps">~, ç”¨æˆ·ç»„ä»¶ä¸ŠåŠ¨æ€å…·åæ’æ§½
   
   #+begin_src js
   const _hoisted_1 = /*# __PURE__ */_createVNode('div', null, null, -1 /* HOISTED */)
   (_openBlock(), _createBlock(_component_Comp, null, {
     [named]: _withCtx((slotProps) => [
       _hoisted_1
     ])
   }))
   #+end_src
5. <template> é»˜è®¤æ’æ§½

   ~<Comp><template v-slot="slotProps"><div/></template></Comp>~
   
   ~<template>~ ä¸Šçš„é»˜è®¤æ’æ§½ï¼Œè¿™ä¸ªæ—¶å€™ ~<Comp>~ ä¸èƒ½åœ¨ä½¿ç”¨ ~v-slot~ ï¼Œä¸‹åŒ 
6. <template> å…·åæ’æ§½

   ~<Comp><template v-slot:named="slotProps"></Comp>~

   #+begin_src js
   return (_openBlock(), _createBlock(_component_Comp, null, {
     named: _withCtx((slotProps) => []),
     _: 1 /* STABLE */
   }))
   #+end_src
   
7. <template> åŠ¨æ€å…·åæ’æ§½

   ~<Comp><template v-slot:[named]="slotProps"></Comp>~
   
   #+begin_src js
   return (_openBlock(), _createBlock(_component_Comp, null, {
     [named]: _withCtx((slotProps) => []),
     _: 1 /* STABLE */
   }))
   #+end_src
8. <template> å…·åæ’æ§½ï¼Œå…¶ä½™é template å…ƒç´ å½“åšé»˜è®¤æ’æ§½å¤„ç†

   ~<Comp><template v-slot:named="slotProps"><div/></template><div :id="defaultSlotId"/></Comp>~
   
   ~<template>~ ä¸Šçš„å…·åæ’æ§½ + é»˜è®¤æ’æ§½ï¼Œåœ¨ç»„ä»¶å†…çš„é <template> å…ƒç´ (å³ï¼š ~<div/>~)éƒ½ä¼šè¢«åŠ¨ä½œé»˜è®¤æ’æ§½æ¥å¤„ç†

   #+begin_src js
   const _hoisted_1 = /*# __PURE__ */_createVNode("div", null, null, -1 /* HOISTED */)
   _createBlock(_component_Comp, null, {
     named: _withCtx((slotProps) => [
       _hoisted_1
     ]),
     default: _withCtx(() => [
       _createVNode('div', {
         id: defaultSlotId
       }, null, 8 /* PROPS */, ["id"])
     ])
     _: 1 /* STABLE */
   })
   #+end_src
9. v-slot + v-if æ’æ§½ä½¿ç”¨

   ~<Comp><template v-if="ok" #named="slotProps">{{ bar }}</template></Comp>~
   
   é…åˆ v-if ä½¿ç”¨çš„ slot template, æœ€åè§£ææˆ ï¼š
   ~ok ? { name: 'named', fn : _withCtx(() => [ _createTextVNode(_toDisplayString(bar)) ]) } : undefined~
   
   #+begin_src js
   return (_openBlock(), _createBlock(_component_Comp, null, _renderSlots(
     { _: 2 /* DYNAMIC */ }, [
       ok ?
        {
          name: 'named',
          fn: _withCtx((slotProps) => [
            _createTextVNode(_toDisplayString(bar), 1 /* TEXT */)
          ])
        } : undefined
     ]
   )))
   #+end_src
10. v-slot + v-for æ’æ§½ä¸Šä½¿ç”¨

   ~<Comp><template v-for="i in list" #named="{ prop }">{{ bar }}</template></Comp>~
    
   #+begin_src js
   return (_openBlock(), _createBlock(_component_Comp, null, _renderSlots(
     { _: 2 /* DYNAMIC */ },
     _renderList(list, (i) => {
       return {
         name: 'named',
         fn: _withCtx(({ prop }) => [
           _createTextVNode(_toDisplayString(bar), 1 /* TEXT */)
         ])
       }
     })
   )))
   #+end_src


#+begin_quote
æ’æ§½æŒ‰çŠ¶æ€åˆ†ä¸ºï¼š
1. é™æ€æ’æ§½ï¼ŒåŠ¨æ€æ’æ§½é™¤å¤–çš„æ’æ§½
2. åŠ¨æ€æ’æ§½ï¼Œæœ‰ ~v-if/v-for/v-else[-if]~ æŒ‡ä»¤æˆ– ~v-slot:[named]~ æˆ–ä½œä¸º ~v-for~
   èŠ‚ç‚¹çš„å­©å­èŠ‚ç‚¹éƒ½è§†ä¸ºåŠ¨æ€æ’æ§½
#+end_quote

* update vue-next merge into stb-vue-next[2020-12-11 16:54:06]

æ›´æ–° vue-next åˆå¹¶åˆ° stb-vue-nextã€‚

1. ast.ts æ›´æ–°

   + ~SimpleExpressionNode~ : å»æ‰ ~isConstant~ å±æ€§ï¼Œå¢åŠ  ~constType~
   + å»æ‰äº† ~StaticType~ å¢åŠ  ~ConstantType~
      #+begin_src typescript
   /**
    * Static types have several levels.
    * Higher levels implies lower levels. e.g. a node that can be stringified
    * can always be hoisted and skipped for patch.
    */
   export const enum ConstantTypes {
     NOT_CONSTANT = 0,
     CAN_SKIP_PATCH,
     CAN_HOIST,
     CAN_STRINGIFY
   }
      #+end_src
2. codegen.ts æ›´æ–°

   [[https://github.com/gcclll/stb-vue-next/commit/521b879d80b9c982f1a15dbc89404725141674d6][fix: merge vue-next codegen.ts Â· gcclll/stb-vue-next@521b879]]
3. parse.ts æ›´æ–°

   ast ç»“æ„ä¸­çš„ ~isConstant~ æ”¹æˆ ~ConstantTypes~ ç±»å‹å€¼

   [[https://github.com/gcclll/stb-vue-next/commit/fdbdc4f93ad04f6544d77bf3ebf20e4f58673930][fix: merge vue-next parse.ts isConstant -> constType Â· gcclll/stb-vue-next@fdbdc4f]]
4. transform.ts æ›´æ–°

   [[https://github.com/gcclll/stb-vue-next/commit/22a8f0be4405592621f805848533396642b4b2f2][fix: merge vue-next transform.ts Â· gcclll/stb-vue-next@22a8f0b]]

   + add ~filename~
   + add ~isTS, inline~
5. transformElement.ts

   [[https://github.com/gcclll/stb-vue-next/commit/1d85990627d0383741c7050fb4af8929377691e1][fix: merge vue-next transformElement.ts Â· gcclll/stb-vue-next@1d85990]]
6. transformSlotOutlet.ts

   [[https://github.com/gcclll/stb-vue-next/commit/58e87f3adcfa0657602d459043468ac5ce8859cb][fix: merge vue-next transformSlotOutlet.ts Â· gcclll/stb-vue-next@58e87f3]]
   ä¿®æ”¹ ~<slot></slot>~ å±æ€§è§£æé€»è¾‘ã€‚
