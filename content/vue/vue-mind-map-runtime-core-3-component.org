#+TITLE: Vue3 æºç å¤´è„‘é£æš´ä¹‹ 7 â˜ runtime-core(3) - render component
#+DATE: <2021-03-16 15:31:46>
#+TAGS[]: vue, vue3, runtime-core, render, component
#+CATEGORIES[]: vue
#+LANGUAGE: zh-cn
#+STARTUP: indent shrink inlineimages

#+begin_export html
<link href="https://fonts.goo~gleapis.com/cs~s2?family=ZCOOL+XiaoWei&display=swap" rel="stylesheet">
<kbd>
<font color="blue" size="3" style="font-family: 'ZCOOL XiaoWei', serif;">
  è¯—å·ï¼šå…­é“åŒå ï¼Œé­”åŠ«ä¸‡åƒï¼Œå¼•æ¸¡å¦‚æ¥ã€‚
</font>
</kbd><br><br>
<script src="/js/utils.js"></script>
<script src="/js/vue/vue-next.js"></script>
<!--<script src="https://unpkg.com/vue@next"></script>-->
<script>
insertCssLink("https://unpkg.com/element-plus/lib/theme-chalk/index.css");
</script>
<script src="https://unpkg.com/element-plus/lib/index.full.js"></script>
#+end_export

[[/img/bdx/yiyeshu-001.jpg]]

@@html:<kbd>@@
*[[https://github.com/gcclll/stb-vue-next][stb-vue-next]] å®Œå…¨æ‹·è´äº [[https://github.com/vuejs/vue-next][vue-next]] ï¼Œä¸»è¦ç›®çš„ç”¨äºå­¦ä¹ ã€‚*
@@html:</kbd>@@

#+begin_quote
æœ¬æ–‡ä¸º runtime-core(2) ç»­é›†ï¼Œä¸Šç¯‡ï¼š [[/vue/vue-mind-map-runtime-core-2-render/][Vue3 æºç å¤´è„‘é£æš´ä¹‹ 7 â˜ runtime-core(2) - render]]
#+end_quote

* æµç¨‹å›¾(è„‘å›¾)
:PROPERTIES:
:COLUMNS: %CUSTOM_ID[(Custom Id)]
:CUSTOM_ID: mindmap
:END:

[[/img/vue3/runtime-core/vue-runtime-core-render-component.svg]]

è¿™ä¸€èŠ‚æ–°å¢å†…å®¹è¾ƒå¤šï¼Œä¸»è¦æ–°å¢ä»¥ä¸‹å‡ ä¸ªå‡½æ•°

1. ~processComponent()~ åœ¨ patch() ä¸­æ‰§è¡Œ switch default åˆ†æ”¯ï¼Œæ»¡è¶³
   ~ShapeFlags.COMPONENT~ æ¡ä»¶
2. ~mountComponent(n2,...)~ é¦–æ¬¡åŠ è½½ç»„ä»¶æ—¶è°ƒç”¨çš„å‡½æ•°
3. ~setupComponent(instance)~ å»ºç«‹ç»„ä»¶å®ä¾‹ï¼Œåšä¸€äº›ç»“æ„åˆå§‹åŒ–æ“ä½œ(å¦‚ï¼špropså’Œ
   slots)ç­‰
4. ~setupStatefulComponent(instance,isSSR)~ åˆ›å»ºæœ‰çŠ¶æ€ç»„ä»¶ï¼Œæ‰§è¡Œ ~setup()~ å‡½æ•°
5. ~setupRenderEffect()~ é€šè¿‡ [[/vue/vue-mind-map-reactivity/#fn-effect][effect()]] å‡½æ•°è¿”å› ~instance.update~ åˆ›å»ºä¸€ä¸ªç›‘å¬-
   æ›´æ–°å‡½æ•°ã€‚
6. ~finishComponentSetup(instance,isSSR)~ è¿™ä¸ªå‡½æ•°åœ¨ ~setupStatefulComponent()~
   ä¸­è°ƒç”¨ï¼Œä¸»è¦åšçš„äº‹æƒ…æ˜¯å¤„ç† SSRï¼Œæ²¡æœ‰ render å‡½æ•°æœ‰ template æ—¶è°ƒç”¨ compile ç¼–
   è¯‘å‡º render å‡½æ•°ï¼Œå…¼å®¹ 2.x çš„ options api

* processComponent(å¦‚ä½•patchç»„ä»¶çš„ï¼Ÿ)
:PROPERTIES:
:COLUMNS: %CUSTOM_ID[(Custom Id)]
:CUSTOM_ID: render-component
:END:

é—®é¢˜ä¿®å¤ï¼š [[#q-allow-recurse][TypeError: Cannot read property 'allowRecurse' of null]]

~processComponent(n1,n2,...)~ å‡½æ•°ä¸»è¦åˆ†ä¸‰ç§æƒ…å†µ

1. mount, æ²¡æœ‰ n1 old æ—¶å€™ï¼Œå±äºçº¯ mount æ“ä½œ
   a. keep-alive ç±»å‹ï¼Œåªéœ€è¦é‡æ–°æ¿€æ´» activate
   b. å¦åˆ™æ‰§è¡Œ mountComponent(n2, ....) é¦–æ¬¡åŠ è½½ç»„ä»¶
2. update, éé¦–æ¬¡åŠ è½½æ‰§è¡Œæ›´æ–°æ“ä½œ

#+begin_src js
const { log, f, shuffle, runtime_test, renderChildren } = require(process.env
  .BLOG_DIR_VUE + "/lib.js");
import(process.env.BLOG_DIR_VUE + "/runtime-test.global.js").then(
  ({ h, render, nodeOps, serializeInner: inner, ref }) => {
    const root = nodeOps.createElement("div");
    const logRoot = () => log("root: " + inner(root));

    logRoot();
    const value = ref(true);
    let parentVnode, childVnode1, childVnode2;

    const Parent = {
      render: () => {
        // return h("div", "æµ‹è¯•...");
        return (parentVnode = h(Child));
      },
    };

    const Child = {
      render: () => {
        return value.value
          ? (childVnode1 = h("div", "child 1"))
          : (childVnode2 = h("span", "child 2"));
      },
    };

    const p = h(Parent);
    render(p, root);
    logRoot();
    value.value = false;
    logRoot();
  },
  (err) => {
    console.log(err.message);
  }
);
#+end_src

#+RESULTS:
#+begin_example
undefinedroot:
component stateful ? 4
call setup
no setup
[Function: render] render
mount component
normalize vnode
patch component
component stateful ? 4
call setup
no setup
[Function: render] render
mount component
normalize vnode
patch component
root: <div>child 1</div>
root: <div>child 1</div>
component update
#+end_example

æµç¨‹ç®€å›¾ï¼š

[[/img/vue3/runtime-core/vue-runtime-core-render-component-brief.svg]]

è¿™é‡Œæ‰§è¡Œå°±æ˜¯ ~mountComponent(n2,...)~ è¡Œä¸ºï¼Œé¦–æ¬¡åŠ è½½ç»„ä»¶ï¼Œå®Œæˆï¼š

1. ~setupComponent(instance)~ æ‰§è¡Œ setup å‡½æ•°ï¼Œåˆå§‹åŒ– props&slots ç­‰
2. ~setupRenderEffect(instance,...)~ æ³¨å†Œ instance.update effect

   å½“å®ä¾‹çŠ¶æ€å‘ç”Ÿæ”¹å˜æ—¶æ‰§è¡Œè¿™ä¸ª effect fnï¼Œå¦‚æœæ˜¯é¦–æ¬¡(çˆ¶çº§è°ƒç”¨ processComponent)
   æ‰§è¡Œ!isMounted åˆ†æ”¯è¿›è¡Œç»„ä»¶é¦–æ¬¡åŠ è½½ï¼Œå¦åˆ™å½“ç»„ä»¶è‡ªèº«çŠ¶æ€æ”¹å˜æ˜¯è§¦å‘çš„ update æ“
   ä½œ


åœ¨ ~setupComponent~ ä¸­ï¼Œä¸»è¦å®Œæˆ

1. initProps
2. initSlots
3. setupStatefulComponent(instance,isSSR) æœ‰çŠ¶æ€ç»„ä»¶(éå‡½æ•°ç»„ä»¶)


ç´§æ¥ç€ ~setupStatefulComponent(instance,isSSR)~ ä¸­æ£€æµ‹ setup å‡½æ•°ï¼Œå¹¶æ‰§è¡Œå®ƒï¼Œå¦‚
æœæ²¡æœ‰ setup å‡½æ•°å°±è¿›å…¥ finishComponentSetup(instance) æ£€æµ‹ render æˆ– template
æœ€ç»ˆç›®çš„æ˜¯è·å¾— render å‡½æ•°ï¼Œå¦‚æœæ²¡æœ‰ render ä¼šé€šè¿‡ compile(template) ç¼–è¯‘å‡º
render å‡½æ•°ï¼Œæœ€ååœ¨ instance.update ä¸­æ‰§è¡Œ render å‡½æ•°(åœ¨è¿™å‰åä¼šè§¦å‘
beforeMount å’Œ mounted å‘¨æœŸå‡½æ•°)ã€‚


#+begin_quote
æ‰€ä»¥ï¼Œä¸€å¥—æµç¨‹ä¸‹æ¥å¯ä»¥ç®€å•æè¿°ä¸º

mount -> props&slots åˆå§‹åŒ– -> setup() -> æœ‰çŠ¶æ€ç»„ä»¶å¤„ç†å¾—åˆ° render å‡½æ•° -> æœ€å
é€šè¿‡ instance.update effect æ¥ç›‘å¬å®ä¾‹çŠ¶æ€å˜åŒ–ï¼Œè§¦å‘ mount æˆ–è€… updateã€‚

åœ¨ effect mount é˜¶æ®µä¼šè§¦å‘ç”Ÿå‘½å‘¨æœŸå‡½æ•°ï¼š

1. beforeMount + mounted
2. onVnodeBeforeMount + onVnodeMounted(é’ˆå¯¹ vnode ç»“æ„å˜åŒ–è€Œè¨€)
3. activated(å¦‚æœæ˜¯ keep-alive çš„è¯)

ç»„ä»¶çš„æ¸²æŸ“å°±å‘ç”Ÿåœ¨ beforeMount ä¹‹å mounted ä¹‹å‰çš„ renderComponentRoot() å¾—åˆ°
vnode äº¤ç»™ patch å»è¿›è¡Œæ¸²æŸ“ã€‚
#+end_quote

ç¤ºä¾‹ä»£ç ä¸­ï¼Œåé¢ä¿®æ”¹äº† ~value.value=false~ åé¢ dom å¹¶æ²¡æ”¹å˜ï¼Œä½†æ˜¯è¾“å‡ºäº†
/component update/ è¯´æ˜è¿›å…¥äº† ~instance.update effect~ çš„ else åˆ†æ”¯ï¼Œå› ä¸ºä¸æ˜¯ç¬¬
ä¸€æ¬¡ï¼Œæ‰€ä»¥è¿™é‡Œéœ€è¦å®ç°æ›´æ–°ç»„ä»¶éƒ¨åˆ†ã€‚

** effect update component

å› ä¸º instance.update æ˜¯é€šè¿‡ ~effect()~ å°è£…çš„å‡½æ•°ï¼Œä¸”è¿™ä¸ªå‡½æ•°ä¸­ä½¿ç”¨åˆ°äº† instance
å®ä¾‹è€Œè¿™ä¸ªå®ä¾‹åˆåœ¨ setupComponent ä¸­æœ‰åšè¿‡ä»£ç†ï¼Œå› æ­¤å¯¹å®ƒçš„è®¿é—®ä¼šè§¦å‘ effect
trackï¼ŒçŠ¶æ€æ›´æ–°ä¼šè§¦å‘ effect trigger(å“åº”å¼åŸç†)ã€‚

[[https://github.com/gcclll/stb-vue-next/commit/12544657c05c740c09a3632e0e2cf9ec9e29ca67][feat(add): component update Â· gcclll/stb-vue-next@1254465]]

æ¶‰åŠçš„ä¿®æ”¹ï¼š
#+begin_src typescript
instance.update = effect(
  function componentEffect() {
    // ç›‘å¬æ›´æ–°
    if (!instance.isMounted) {
      // ...
    } else {
      // updateComponent
      // å½“ç»„ä»¶è‡ªèº«çš„çŠ¶æ€æˆ–çˆ¶ç»„ä»¶è°ƒç”¨ processComponent æ—¶è§¦å‘
      console.log("component update");
      let { next, bu, u, parent, vnode } = instance;
      let originNext = next;
      let vnodeHook: VNodeHook | null | undefined;

      if (next) {
        next.el = vnode.el;
        updateComponentPreRender(instance, next, optimized);
      } else {
        next = vnode;
      }

      // beforeUpdate hook
      if (bu) {
        invokeArrayFns(bu);
      }
      // onVnodeBeforeUpdate
      if ((vnodeHook = next.props && next.props.onVnodeBeforeUpdate)) {
        invokeVNodeHook(vnodeHook, parent, next, vnode);
      }

      //render
      const nextTree = renderComponentRoot(instance);
      const prevTree = instance.subTree;
      instance.subTree = nextTree;

      patch(
        prevTree,
        nextTree,
        // å¦‚æœåœ¨ teleport ä¸­ï¼Œparent å¯èƒ½ä¼šå‘ç”Ÿæ”¹å˜
        hostParentNode(prevTree.el!)!,
        // anchor may have changed if it's in a fragment
        getNextHostNode(prevTree),
        instance,
        parentSuspense,
        isSVG
      );

      next.el = nextTree.el;
      if (originNext === null) {
        // self-triggered update. In case of HOC, update parent component
        // vnode el. HOC is indicated by parent instance's subTree pointing
        // to child component's vnode
        // TODO
      }

      // updated hook
      if (u) {
        queuePostRenderEffect(u, parentSuspense);
      }
      // onVnodeUpdated
      if ((vnodeHook = next.props && next.props.onVnodeUpdated)) {
        queuePostRenderEffect(() => {
          invokeVNodeHook(vnodeHook!, parent, next!, vnode);
        });
      }
    }
  },
  __DEV__
    ? // æä¾› onTrack/onTrigger é€‰é¡¹æ‰§è¡Œ rtc&rtg ä¸¤ä¸ªå‘¨æœŸå‡½æ•°
      createDevEffectOptions(instance)
    : prodEffectOptions
);
#+end_src

å’Œ updateComponentPreRender å®ç°è¿™ä¸ªå‡½æ•°è®© instance.update åœ¨ nextTick() ä¹‹åæ‰§
è¡Œ pre ä¼˜å…ˆäº post å’Œ job ä»»åŠ¡([[/vue/vue-mind-map-runtime-core/#scheduler][è¯¦æƒ…æŸ¥çœ‹ä»»åŠ¡è°ƒåº¦->]])ï¼š
#+begin_src typescript
const updateComponentPreRender = (
    instance: ComponentInternalInstance,
    nextVNode: VNode,
    optimized: boolean
  ) => {
    nextVNode.component = instance
    // const prevProps = instance.vnode.props
    instance.vnode = nextVNode
    instance.next = null
    // TODO update props
    // TODO update slots

    // props update may have triggered pre-flush watchers.
    // flush them before the render update.
    flushPreFlushCbs(undefined, instance.update)
  }
#+end_src

ä¹‹å‰çš„ç”¨ä¾‹å†æµ‹è¯•ä¸€éï¼š
#+begin_src js
const { log, f, shuffle, runtime_test, renderChildren } = require(process.env
  .BLOG_DIR_VUE + "/lib.js");
import(process.env.BLOG_DIR_VUE + "/runtime-test.global.js").then(
  async ({ h, render, nodeOps, serializeInner: inner, ref, nextTick }) => {
    const root = nodeOps.createElement("div");
    const logRoot = () => log("root: " + inner(root));

    logRoot();
    const value = ref(true);
    let parentVnode, childVnode1, childVnode2;
    const idValue = ref("parent");

    const Parent = {
      render: () => {
        console.log("parent render");
        return (parentVnode = h("div", { id: idValue.value }, h(Child)));
      },
    };

    const Child = {
      render: () => {
        console.log("child render");
        return value.value
          ? (childVnode1 = h("div", "child 1"))
          : (childVnode2 = h("span", "child 2"));
      },
    };

    const p = h(Parent);
    render(p, root);
    logRoot();
    console.log("before change value");
    value.value = false;
    await nextTick();
    console.log("after change value");
    logRoot();

    console.log('before id change');
    idValue.value = 'parent-id'
    await nextTick()
    console.log('after id change');
    logRoot()
  },
  (err) => {
    console.log(err.message);
  }
);
#+end_src

#+RESULTS:
#+begin_example
undefinedroot:
component stateful ? 4
call setup
no setup
[Function: render] render
mount component
normalize vnode
parent render
patch component
component stateful ? 4
call setup
no setup
[Function: render] render
mount component
normalize vnode
child render
patch component
root: <div id="parent"><div>child 1</div></div>
before change value
component update
normalize vnode
child render
after change value
root: <div id="parent"><span>child 2</span></div>
before id change
component update
normalize vnode
parent render
after id change
root: <div id="parent"><span>child 2</span></div>
#+end_example

è¿™é‡Œè¦è®©è¾“å‡ºè¾¾åˆ°æ•ˆæœï¼Œéœ€è¦å°† resolve æ”¹æˆ async function å¹¶ä¸”è¦åœ¨ nextTick() å
è¾“å‡ºæ›´æ–°åçš„ç»“æœï¼Œå› ä¸º instance.update è°ƒç”¨äº† ~flushPreFlushCbs(null,
instane.update)~ ä¹Ÿå°±æ˜¯è¯´è¿™ä¸ªå‡½æ•°æ˜¯ä¸ªå¼‚æ­¥æ›´æ–°ï¼Œä¸”ä¼šåœ¨ ~nextTick()~ åè§¦å‘ï¼Œè¯¦æƒ…
åˆ†ææŸ¥çœ‹â€œ[[/vue/vue-mind-map-runtime-core/#scheduler][ä»»åŠ¡è°ƒåº¦æœºåˆ¶åˆ†æ]]â€

#+begin_quote
é—®é¢˜ï¼š å¦‚ä¸Šé¢çš„ç»“æœï¼Œå½“æˆ‘ä»¬æ”¹å˜ ~idValue.value="parent-id"~ çš„æ—¶å€™ï¼Œå®é™…ç»“æœå¹¶æ²¡
æœ‰æ”¹å˜ï¼Ÿ

ç­”ï¼š å› ä¸ºåœ¨ ~setupComponent()~ ä¸­çš„ ~initProps()~ ä»¥åŠ ~updateComponentPreRender()~
ä¸­çš„ ~updateProps()~ è¿˜æ²¡å®ç°ï¼Œä¸‹ä¸€èŠ‚æ­æ™“ã€‚
#+end_quote
** normalize props options
:PROPERTIES:
:COLUMNS: %CUSTOM_ID[(Custom Id)]
:CUSTOM_ID: norm-props-opt
:END:

[[https://github.com/gcclll/stb-vue-next/commit/7d6ac555be06253f6dab5af8d6a0c2df8b46b656][feat(add): normalize props options Â· gcclll/stb-vue-next@7d6ac55]]

å¯¹åº”å®˜æ–¹æ–‡æ¡£å†…å®¹ï¼š [[https://v3.vuejs.org/guide/component-props.html#prop-types][Props | Vue.js]]

#+begin_quote
è¿™é‡Œä½œç”¨ç®€å•æè¿°å°±æ˜¯ï¼Œå°† props çš„å®šä¹‰åœ¨ç»„ä»¶åŠ è½½åˆå§‹åŒ–æ—¶è§£ææˆå…·ä½“çš„å€¼ï¼Œå¦‚ï¼š
~props: ['foo']~ è§£ææˆ ~foo={}~ å› ä¸ºå­—ç¬¦ä¸²æ•°ç»„çš„ props ä¼šç»™æ¯ä¸ªå±æ€§åˆå§‹åŒ–ä¸€ä¸ªç©º
å¯¹è±¡ã€‚
#+end_quote

æ¯”å¦‚ï¼š

1. æ•°ç»„ï¼š ~props: ['foo', 'bar', 'foo-bar']~

    è½¬æˆ ~{foo: {}, bar: {}, fooBar: {}}~

2. å¯¹è±¡: ~props: { foo: [Boolean, String], bar: Function }~

   è¡¨ç¤º foo å¯ä»¥æ˜¯å¸ƒå°”å€¼æˆ–å­—ç¬¦ä¸²ï¼Œbar æ˜¯ä¸ªå‡½æ•°

   è½¬æ¢è¿‡ç¨‹(0: ~BooleanFlags.shouldCast~, 1: ~BooleanFlags.shouldCastTrue~)

   ~foo = { type: [Boolean, String] }~ -> æ‰¾ Boolean

   ~foo = { type: [Boolean, String], 0: true }~ ->

   æ‰¾ String éœ€æ»¡è¶³ ~stringIndex < 0 || booleanIndex < stringIndex~

   ~foo = { type: [Boolean, String], 0: true, 1: true }~

   æœ€åå†³å®š ~foo~ æ˜¯ä¸æ˜¯åº”è¯¥è¿›è¡Œ cast ? æ¡ä»¶æ˜¯å¸ƒå°”ç±»å‹æˆ–è€…æœ‰ default é»˜è®¤å€¼ã€‚


æºç ï¼š
#+begin_src typescript
export function normalizePropsOptions(
  comp: ConcreteComponent,
  appContext: AppContext,
  asMixin: false
): NormalizedPropsOptions {
  if (!appContext.deopt && comp.__props) {
    return comp.__props
  }

  const raw = comp.props
  const normalized: NormalizedPropsOptions[0] = {}
  const needCastKeys: NormalizedPropsOptions[1] = []

  // mixin/extends props åº”ç”¨
  let hasExtends = false
  // å¿…é¡»å¼€æ”¯ 2.x options api æ”¯æŒï¼Œä¸”ä¸æ˜¯å‡½æ•°å¼ç»„ä»¶
  // ç»§æ‰¿æ¥çš„å±æ€§ï¼Œç”¨æ³•ï¼š ~CompA = { extends: CompB, ... }~
  // CompA ä¼šç»§æ‰¿ CompB çš„ props
  if (__FEATURE_OPTIONS_API__ && !isFunction(comp)) {
    const extendProps = (raw: ComponentOptions) => {
      hasExtends = true
      const [props, keys] = normalizePropsOptions(raw, appContext, true)
      extend(normalized, props)
      if (keys) {
        needCastKeys.push(...keys)
      }
    }

    // Comp: { extends: CompA } å¤„ç†
    if (comp.extends) {
      extendProps(comp.extends)
    }

    // Comp: { mixins: [mixin] } å¤„ç†
    if (!asMixin && appContext.mixins.length) {
      appContext.mixins.forEach(extendProps)
    }
  }

  // æ—¢æ²¡æœ‰è‡ªèº«çš„ props ä¹Ÿæ²¡æœ‰ extends ç»§æ‰¿æ¥çš„ props åˆå§‹åŒ–ä¸º []
  if (!raw && !hasExtends) {
    return (comp.__props = EMPTY_ARR as any)
  }

  if (isArray(raw)) {
    // å½“ props æ˜¯æ•°ç»„çš„æ—¶å€™ï¼Œå¿…é¡»æ˜¯å­—ç¬¦ç±»å‹ï¼Œå¦‚: props: ['foo', 'bar', 'foo-bar']
    // 'foo-bar' ä¼šè½¬æˆ 'fooBar'ï¼Œä¸å…è®¸ '$xxx' å½¢å¼çš„å˜é‡å
    for (let i = 0; i < raw.length; i++) {
      const normalizedKey = camelize(raw[i])
      // ç»„ä»¶çš„å±æ€§åä¸èƒ½æ˜¯ä»¥ $xx å¼€å¤´çš„åç§°ï¼Œè¿™ä¸ªæ˜¯ä½œä¸ºå†…éƒ¨å±æ€§çš„
      if (validatePropName(normalizedKey)) {
        normalized[normalizedKey] = EMPTY_OBJ
      }
    }
  } else if (raw) {
    // å¯¹è±¡ç±»å‹ props: { foo: 1, bar: 2, ... }
    for (const key in raw) {
      // 'foo-bar' -> 'fooBar'
      const normalizedKey = camelize(key)
      // æ£€æŸ¥ $xxx éæ³•å±æ€§
      if (validatePropName(normalizedKey)) {
        const opt = raw[key]
        // ? å€¼ä¸ºæ•°ç»„æˆ–å‡½æ•°å˜æˆï¼š { type: opt } ?
        // è¿™é‡Œå«ä¹‰å…¶å®æ˜¯ï¼š ~props: { foo: [Boolean, Function] }~
        // å¯ä»¥ç”¨æ•°ç»„å®šä¹‰è¯¥å±æ€§å¯ä»¥æ˜¯å¤šç§ç±»å‹çš„å…¶ä¸­ä¸€ç§
        const prop: NormalizedProp = (normalized[normalizedKey] =
          isArray(opt) || isFunction(opt) ? { type: opt } : opt)
        if (prop) {
          // æ‰¾åˆ° Boolean åœ¨ foo: [Boolean, Function] ä¸­çš„ç´¢å¼•
          const booleanIndex = getTypeIndex(Boolean, prop.type)
          const stringIndex = getTypeIndex(String, prop.type)
          prop[BooleanFlags.shouldCast] = booleanIndex > -1
          // [String, Boolean] ç±»å‹ï¼ŒString åœ¨ Boolean å‰é¢
          prop[BooleanFlags.shouldCastTrue] =
            stringIndex < 0 || booleanIndex < stringIndex
          // å¦‚æœæ˜¯å¸ƒå°”ç±»å‹çš„å€¼æˆ–è€…æœ‰é»˜è®¤å€¼çš„å±æ€§éœ€è¦è½¬æ¢
          // è½¬æ¢æ˜¯æ ¹æ® type å’Œ default å€¼å¤„ç†
          // typeéå‡½æ•°ï¼Œdefaultæ˜¯å‡½æ•°ï¼Œæ‰§è¡Œ default() å¾—åˆ°é»˜è®¤å€¼
          if (booleanIndex > -1 || hasOwn(prop, 'default')) {
            needCastKeys.push(normalizedKey)
          }
        }
      }
    }
  }

  return (comp.__props = [normalized, needCastKeys])
}

#+end_src

ç„¶åè¿™ä¸ªå¤„ç†ä¹‹åçš„ propsï¼Œä¼šè¢«ä¿å­˜åˆ°ç»„ä»¶çš„ ~comp.__props=[normalied,
needCastKeys]~ ä¸Šï¼Œè€Œè¿™ä¸ªä¼šåœ¨ ~resolvePropValue()~ ä¸­è¿›ä¸€æ­¥å¤„ç†ï¼Œè¿™é‡Œçš„
~needCastKeys~ éå¸¸é‡è¦ï¼Œå®ƒä¼šå†³å®šæœ€åçš„å€¼åº”è¯¥å¦‚ä½•è¢«å¤„ç†(~resolvePropValue~ ä¸­å¤„
ç†)ã€‚

æ¯”å¦‚ï¼š ~{ type: String, default: () => 'xxx' }~ é‚£ä¹ˆæ»¡è¶³ ~type!==Function &&
isFunction(dfault)~ åˆ™ä¼šç›´æ¥æ‰§è¡Œ default() å¾—åˆ°å±æ€§é»˜è®¤å€¼ã€‚

å¦‚æœå±æ€§çš„ ~opt[BooleanFlags.shouldCast]~ ä¸º ~true~ å¦‚[[#norm-props-opt][æœ€å¼€å§‹çš„è¯´æ˜]]ï¼Œå…¶å®å°±æ˜¯
~prop["0"]~ çš„å€¼ï¼Œåªè¦ prop çš„ç±»å‹ä¸­æœ‰ ~Boolean~ è¿™ä¸ªå€¼å°±æ˜¯ ~true~ ã€‚

æ­¤æ—¶éœ€è¦å°†å±æ€§çš„å€¼è½¬æˆ

1. *true* : ç±»å‹å£°æ˜ä¸­æœ‰ ~Boolean~ ä¸”æœ‰ ~String~ çš„æ—¶å€™ï¼Œå®ƒçš„å€¼å¦‚æœæ˜¯ ~''~ æˆ–è€…
   ~key === value~ æƒ…å†µä¸‹è½¬æˆ ~true~, å› ä¸ºæŒ‡å®šäº†å¯ä»¥æ˜¯ ~String~ ç±»å‹ï¼Œæ‰€ä»¥ç©ºå­—ç¬¦
   ä¸²æ˜¯å…è®¸çš„ã€‚

2. *false* : ~(!hasOwn(props, key) && !hasDefault)~, raw props ä¸­æ²¡æœ‰è¿™ä¸ªå±æ€§ä¸”
   æ²¡æœ‰ ~default~ é»˜è®¤å€¼çš„æ—¶å€™è½¬æˆ ~false~, ç­‰äºæ˜¯å‡å€¼ç±»å‹ã€‚

** component props
:PROPERTIES:
:COLUMNS: %CUSTOM_ID[(Custom Id)]
:CUSTOM_ID: component-props
:END:

[[https://github.com/gcclll/stb-vue-next/commit/9a6aa70c2109179a884b1496eea09af50a6efdb5][feat(add): init component props Â· gcclll/stb-vue-next@9a6aa70]]

æ–°å¢ä»£ç ï¼š
#+begin_src typescript
// component.ts > setupComponent()
export function setupComponent(
  instance: ComponentInternalInstance,
  isSSR = false
) {
  // ...
  // init props & slots
  initProps(instance, props, isStateful, isSSR);
  // ...
  return setupResult;
}
#+end_src

*componentProps.ts > initProps()*
1. def -> attrs.__vInterval = 1
2. setFullProps å¤„ç† rawProps å°†ç»“æœåé¦ˆåˆ° props å’Œ attrs
3. æœ‰çŠ¶æ€ç»„ä»¶ï¼Ÿå°† props reactive åŒ–ï¼ŒSSRä¸‹ä¸æ”¯æŒå±æ€§å“åº”å¼å…¶å®å°±æ˜¯æœåŠ¡å™¨è¿”å›çš„å±
   æ€§éƒ½æ˜¯å¸¦æœ‰æœ€ç»ˆå€¼çš„è€Œä¸æ˜¯åœ¨å®¢æˆ·ç«¯åŠ¨æ€èƒ½æ”¹å˜çš„
4. å‡½æ•°ç»„ä»¶çš„ props å¯é€‰å±æ€§å’Œå¿…é¡»å±æ€§ï¼Ÿå¯é€‰ç”¨  attrs å¦åˆ™ç”¨ props
#+begin_src typescript
export function initProps(
  instance: ComponentInternalInstance,
  rawProps: Data | null,
  isStateful: number,
  isSSR = false
) {
  const props: Data = {};
  const attrs: Data = {};
  def(attrs, InternalObjectKey, 1);
  setFullProps(instance, rawProps, props, attrs);
  // TODO validation

  if (isStateful) {
    instance.props = isSSR ? props : shallowReactive(props);
  } else {
    if (!instance.type.props) {
      // functional optional props, props === attrs
      instance.props = attrs;
    } else {
      // functional declared props
      instance.props = props;
    }
  }
  instance.attrs = attrs;
}

#+end_src

*componentProps.ts > setFullProps()*
è¿™ä¸ªå‡½æ•°ç›®çš„æ˜¯å°† rawProps ç»„ä»¶çš„ props è§£æå‡ºæ¥æ ¹æ®å„è‡ªç‰¹æ€§
åˆ†æ´¾åˆ° props æˆ– attrs
1. key, ref å±æ€§ä¸ä¿ç•™ï¼Œå› ä¸ºç»„ä»¶æ›´æ–°æ—¶ key å¯èƒ½å‘ç”Ÿæ”¹å˜ï¼Œrefå¼•ç”¨ä¹Ÿä¼šå˜å¥½æŒ‡å‘æ›´æ–°åçš„ DOM å…ƒç´ 
2. options å•¥æ„æ€ï¼Ÿ
3. äº‹ä»¶å±æ€§(~onClick~)ä¼šå­˜æ”¾åˆ° attrs !
4. needCastKeys ? è¿™æ˜¯åšå•¥å‘¢ resolvePropValueï¼Ÿ

#+begin_src typescript
function setFullProps(
  instance: ComponentInternalInstance,
  rawProps: Data | null,
  props: Data,
  attrs: Data
) {
  const [options, needCastKeys] = instance.propsOptions;
  if (rawProps) {
    for (const key in rawProps) {
      const value = rawProps[key];
      // key, ref ä¿ç•™ï¼Œä¸å¾€ä¸‹ä¼ 
      // å³è¿™ä¸¤ä¸ªå±æ€§ä¸ä¼šç»§æ‰¿ç»™ child
      if (isReservedProp(key)) {
        continue;
      }

      let camelKey;
      if (options && hasOwn(options, (camelKey = camelize(key)))) {
        props[camelKey] = value;
      } else if (!isEmitListener(instance.emitsOptions, key)) {
        attrs[key] = value;
      }
    }
  }

  if (needCastKeys) {
    const rawCurrentProps = toRaw(props);
    for (let i = 0; i < needCastKeys.length; i++) {
      const key = needCastKeys[i];
      props[key] = resolvePropValue(
        options!,
        rawCurrentProps,
        key,
        rawCurrentProps[key],
        instance
      );
    }
  }
}
#+end_src

*componentProps.ts -> resolvePropValue()*
1. ~props:{name: {default: v=> myname }, type: String}~

   å½“ type éå‡½æ•°æ—¶ï¼Œè¯´æ˜ ~name~ æ˜¯ä¸ªå­—ç¬¦ä¸²ç±»å‹ï¼Œä½†æ˜¯å®ƒçš„ ~default~ åˆæ˜¯ä¸ªå‡½æ•°ï¼Ÿ
   é‚£ä¹ˆè¿™ç§æƒ…å†µä¼šåœ¨è¿™é‡Œè¢«å¤„ç†ï¼Œæœ€åå°† name çš„å€¼èµ‹å€¼ä¸º ~default(props)~ æ‰§è¡Œä¹‹åçš„ç»“æœ
2. ~props:{name: {default: v=> myname }, type: Function}~

   è¿™ç§æƒ…å†µï¼Œè¯´æ˜ ~name~ æœ¬èº«å°±æ˜¯å‡½æ•°ï¼Œä¸éœ€è¦æ‰§è¡Œ defaultã€‚
3. ~props:{name: value, type: String|Number}~ æ™®é€šç±»å‹æƒ…å†µ
4. boolean ç±»å‹çš„å€¼å¤„ç†ï¼Œæœ€åéƒ½ä¼šè½¬æˆ ~true~ æˆ– ~false~

#+begin_src typescript
function resolvePropValue(
  options: NormalizedProps,
  props: Data,
  key: string,
  value: unknown,
  instance: ComponentInternalInstance
) {
  /*
   * è¿™é‡Œé¢çš„å¤„ç†æ˜¯é’ˆå¯¹ props: { name: { ... } } ç±»å‹è€Œè¨€
   * 1. é»˜è®¤å€¼çš„å¤„ç†ï¼Œ default å¯èƒ½æ˜¯å‡½æ•°æˆ–æ™®é€šç±»å‹å€¼ï¼Œå¦‚æœæ˜¯å‡½æ•°åº”è¯¥å¾—åˆ°
   * å‡½æ•°æ‰§è¡Œçš„ç»“æœä½œä¸ºå®ƒçš„å€¼ï¼Œæ³¨æ„ä¸‹é¢çš„æ£€æµ‹å‡½æ•°æ—¶å‰ç½®æ¡ä»¶æ˜¯è¯¥ç±»å‹ä¸æ˜¯å‡½æ•°ï¼Œ
   * å¦‚æœç±»å‹ä¹Ÿæ˜¯å‡½æ•°ï¼Œé»˜è®¤å€¼å°±æ˜¯è¯¥å‡½æ•°æœ¬èº«ï¼Œè€Œéæ‰§è¡Œåçš„ç»“æœå€¼
   * 2. å¸ƒå°”å€¼çš„å¤„ç†ï¼Œå€¼è½¬æˆ true or false
   */
  const opt = options[key]
  if (opt != null) {
    const hasDefault = hasOwn(opt, 'default')
    // é»˜è®¤å€¼
    if (hasDefault && value === undefined) {
      const defaultValue = opt.default
      // props: { name: { default: (props) => 'xxx' } }
      // ç±»å‹ä¸æ˜¯å‡½æ•°ï¼Ÿä½†æ˜¯é»˜è®¤å€¼æ˜¯å‡½æ•°ï¼Œæ‰§è¡Œå¾—åˆ°ç»“æœ
      if (opt.type !== Function && isFunction(defaultValue)) {
        setCurrentInstance(instance)
        value = defaultValue(props)
        setCurrentInstance(null)
      } else {
        // props: { name: { default: 'xxx' } }
        value = defaultValue
      }
    }
    // boolean casting
    if (opt[BooleanFlags.shouldCast]) {
      if (!hasOwn(props, key) && !hasDefault) {
        value = false
      } else if (
        opt[BooleanFlags.shouldCastTrue] &&
        (value === '' || value === hyphenate(key))
      ) {
        value = true
      }
    }
  }
  return value
}
#+end_src

#+begin_quote
â“ ç„¶åä¸ props æœ‰å…³çš„ propsOptions æ˜¯æ¥è‡ªå“ªé‡Œï¼Ÿ
#+end_quote

å›é¡¾ä¸‹ component render è¿‡ç¨‹ï¼š

patch -> switch default -> PatchFlags.COMPONENT ->

processComponent -> mountComponent ->

createComponentInstance -> setupComponent -> setupRenderEffect

æœ‰äº†ï¼Ÿ

æ˜¯çš„ï¼Œå°±æ˜¯å®ƒ -> ~createComponentInstance~ åˆ›å»ºç»„ä»¶å®ä¾‹ä¸­ï¼Œè¿›è¡Œäº†åˆå§‹åŒ–ï¼Œå…¶ä¸­ç»„ç»‡
çš„ç»“æ„é‡Œé¢å°±æœ‰ä¸€ä¸ª

~propsOptions: normalizePropsOptions(type, appContext)~

å’Œ

~emitsOptions: normalizeEmitsOptions(type, appContext)~

** component setup
:PROPERTIES:
:COLUMNS: %CUSTOM_ID[(Custom Id)]
:CUSTOM_ID: setup
:END:

1. setup å¦‚æœè¿”å›å€¼æ˜¯å‡½æ•°ç›´æ¥æ˜¯ render å‡½æ•°
2. setup è¿”å›å€¼æ˜¯å¯¹è±¡ï¼Œåˆ™å½“åšå’Œ data ä¸€æ ·çš„ç»„ä»¶çŠ¶æ€å¤„ç†


[[/img/vue3/runtime-core/vue-runtime-core-setup-result.jpg]]

æ›´å¤šåˆ†æè§æ³¨é‡Šï¼Œç›¸å…³ä»£ç :
#+begin_src typescript
// å¦‚æœç»„ä»¶æ˜¯ä¸ªå¯¹è±¡ï¼Œè€Œéå‡½æ•°æ˜¯ç»„ä»¶æ˜¯ä¼šç»è¿‡è¿™ä¸ªå‡½æ•°
function setupStatefulComponent(
  instance: ComponentInternalInstance,
  isSSR: boolean
) {
  const Component = instance.type as ComponentOptions;

  // 0. create render proxy property access cache
  // è¿™ä¸ªæ˜¯é’ˆå¯¹ instance ä¸Šå±æ€§çš„ get æ“ä½œç±»å‹è¿›è¡Œäº† key å€¼ç¼“å­˜
  // æ¯”å¦‚ï¼šå½“ä½ å¯¹ setupState æˆ– dataçš„å±æ€§ è¿›è¡Œäº† get è®¿é—®ï¼Œ
  // é‚£ä¹ˆè¯¥å±æ€§çš„keyå€¼ä¼šè®°å½•ä¸ºè¯¥ç±»å‹(accessCache[key]=AccessTypes.SETUP)
  // å½“ä½ ä¸‹æ¬¡å†åœ¨ instance ä¸Šè®¿é—®è¿™ä¸ªkey çš„æ—¶å€™ï¼Œé‚£ä¹ˆè¿™ä¸ªæ—¶å€™å°±ä¼šçŸ¥é“è¿™ä¸ª key
  // æ˜¯åœ¨ setupState ä¸Šï¼Œé‚£ä¹ˆå°±ç›´æ¥è¿”å› setupState[key] å°±è¡Œäº†
  // è€Œä¸ç”¨å»é‡å¤è¿›è¡Œ if...elseif...else å» setupData, data, context
  // æˆ– props åˆ¤æ–­ç„¶åå†³å®šå»å“ªä¸ªä¸Šé¢å–å€¼ï¼ŒåŠ å¿«æ±‚å€¼é€Ÿåº¦ã€‚
  // å¦‚ï¼š setupState={foo:1}, data={bar:2}
  // å–å€¼ï¼š this.foo è§¦å‘ get æ“ä½œï¼Œè¿™ä¸ªæ—¶å€™ç¬¬ä¸€æ¬¡å–å€¼çš„æ—¶å€™ä¼šè¿›è¡Œ
  // if setupState else if data æ£€æµ‹'foo'åœ¨å“ªä¸ªå¯¹è±¡ä¸Šï¼Œå‘ç°åœ¨
  // setupState ä¸Šï¼Œç„¶åå°† 'foo' ç¼“å­˜åˆ° accessCache['foo'] ='setup'
  // ä¸‹æ¬¡å†æ¬¡å–å€¼this.fooï¼Œé‚£ä¹ˆæœ¬æ¬¡å°±ä¼šç›´æ¥è¿”å› setupState['foo']
  instance.accessCache = Object.create(null);

  // 1. create public instance / render proxy
  // also mark it raw so it's never observed
  // ä»£ç†ç›®çš„ï¼šè®©å–å€¼æ“ä½œèƒ½åœ¨ setupState, data, ctx, props åŠ
  // appContext.config.globalProperties ä¸Šä¾æ¬¡æŸ¥æ‰¾å¯¹åº”çš„å±æ€§å€¼
  // ä¼˜å…ˆçº§ï¼š
  // 1. é $xxx å±æ€§ï¼Œ setupState > data > ctx > props
  // 2. this.$xxx å–å€¼ï¼Œ public å±æ€§: $,$el,$data,$props,$attrs
  //  ,$slots,$refs,$parent,$root,$emit,$options,$forceUpdate,
  //  ,$nextTick,$watch
  // > cssModule å±æ€§ vue-loader æ³¨å…¥çš„css å˜é‡
  // > instance.ctx
  // > appContext.config.globalProperties, å¦‚ï¼š this.$router
  instance.proxy = new Proxy(instance.ctx, PublicInstanceProxyHandlers);

  console.log("call setup");
  // 2. call setup()
  const { setup } = Component;
  if (setup) {
    // ä¼ é€’ç»™ setup(props, setupContext) çš„ç¬¬äºŒä¸ªå‚æ•°
    // setupContext: { attrs, slots, emit, expose }
    const setupContext = (instance.setupContext =
      setup.length > 1 ? createSetupContext(instance) : null);

    currentInstance = instance;
    // å®ä¾‹åˆå§‹åŒ–æœŸé—´ï¼Œç¦æ­¢ track æ“ä½œï¼Œget æ”¶é›†ä¾èµ–
    pauseTracking();
    // æ‰§è¡Œ setup å‡½æ•°
    const setupResult = callWithErrorHandling(
      setup,
      instance,
      ErrorCodes.SETUP_FUNCTION,
      [__DEV__ ? shallowReadonly(instance.props) : instance.props, setupContext]
    );
    resetTracking();
    currentInstance = null;

    // å¯¹setup ç»“æœå¤„ç†ï¼Œè¿”å›å€¼åªèƒ½æ˜¯å¯¹è±¡æˆ–å‡½æ•°
    if (isPromise(setupResult)) {
      if (isSSR) {
        // return the promise so server-renderer can wait on it
        return setupResult.then((resolvedResult: unknown) => {
          handleSetupResult(instance, resolvedResult, isSSR);
        });
      } else if (__FEATURE_SUSPENSE__) {
        // async setup returned Promise.
        // bail here and wait for re-entry.

        instance.asyncDep = setupResult;
      } else if (__DEV__) {
        // TODO warn
      }
    } else {
      // setup() æ‰§è¡Œç»“æœåªèƒ½æ˜¯å‡½æ•°æˆ–å¯¹è±¡
      // 1. å¦‚æœæ˜¯å¯¹è±¡ï¼Œè¿”å›å¯¹è±¡çš„æ‰€æœ‰å±æ€§å½“åšçŠ¶æ€å¤„ç†ï¼Œå’Œ data æ€§è´¨ç›¸åŒ
      // 2. å¦‚æœæ˜¯å‡½æ•°ï¼Œè§†ä¸ºç»„ä»¶çš„ render å‡½æ•°
      // å³ï¼Œæ”¯æŒåœ¨ setup ä¸­ç›´æ¥æ‰‹å†™ render å‡½æ•°
      handleSetupResult(instance, setupResult, isSSR);
    }
  } else {
    // ...
  }
}

// handleSetupResult
export function handleSetupResult(
  instance: ComponentInternalInstance,
  setupResult: unknown,
  isSSR: boolean
) {
  // 1. å¦‚æœæ˜¯å‡½æ•°å½“åšrenderå‡½æ•°å¤„ç†
  // 2. å¦‚æœæ˜¯å¯¹è±¡
  if (isFunction(setupResult)) {
    // è¿”å›å†…è” render å‡½æ•°
    if (__NODE_JS__ && (instance.type as ComponentOptions).__ssrInlineRender) {
      // SSR æœåŠ¡ç«¯æ¸²æŸ“ï¼Œæ›¿æ¢ ssrRender å‡½æ•°
      // when the function's name is `ssrRender` (compiled by SFC inline mode),
      // set it as ssrRender instead.
      instance.ssrRender = setupResult;
    } else {
      instance.render = setupResult as InternalRenderFunction;
    }
  } else if (isObject(setupResult)) {
    // è¿”å› bindingsï¼Œè¿™äº›å˜é‡å¯ä»¥ç›´æ¥åœ¨æ¨¡æ¿ä¸­ä½¿ç”¨
    // æ³¨æ„è¿™é‡Œçš„ state æ˜¯ shallow refï¼Œå³éé€’å½’ reactive çš„
    instance.setupState = proxyRefs(setupResult);
  } else {
    // warn å¿…é¡»è¿”å›å¯¹è±¡
  }
  // æœ€åå®Œæˆrenderå‡½æ•°æ£€æŸ¥
  // å¯èƒ½æ˜¯ SFCæƒ…å†µçš„ æ¨¡æ¿è¯­æ³•ï¼Œæ²¡æœ‰ç›´æ¥çš„renderå‡½æ•°ï¼Œéœ€è¦è¿›è¡Œ
  // compile æ“ä½œç”Ÿæˆ instance.rendder = Component.renderå‡½æ•°
  // render æ‰§è¡Œä¸æ˜¯è¿™é‡Œï¼Œè€Œæ˜¯åœ¨ instance.update çš„ effect å‡½æ•°ä¸­çš„
  // renderComponentRoot ä¸­
  finishComponentSetup(instance, isSSR);
}
#+end_src

æµ‹è¯•ï¼š
#+begin_src js
const { log, f, shuffle, runtime_test, renderChildren } = require(process.env
  .BLOG_DIR_VUE + "/lib.js");
import(process.env.BLOG_DIR_VUE + "/runtime-test.global.js").then(
  async ({
    h,
    render,
    nodeOps,
    serializeInner: inner,
    ref,
    nextTick,
    defineComponent,
  }) => {
    const root = nodeOps.createElement("div");
    const logRoot = () => log("root: " + inner(root));

    logRoot();
    log(">>>component setup return object");
    let props, attrs;
    try {
      const Comp = defineComponent({
        props: ["bar"],
        setup(_props, { attrs: _attrs }) {
          console.log("setup...");
          return () => {
            props = _props;
            attrs = _attrs;
          };
        },
      });
      render(h(Comp, { foo: 1, bar: 2 }), root);
      log([props, attrs]);
      render(h(Comp, { fooBar: 2, bar: 3, fooBaz: 4 }), root);
      log([props, attrs]);
      render(h(Comp, { qux: 5 }), root);
      log([props, attrs]);
    } catch (e) {
      log(e);
    }

    logRoot();
  },
  (err) => {
    console.log(err.message);
  }
);
#+end_src

#+RESULTS:
#+begin_example
undefinedroot:
>>>component setup return object
component stateful ? 4
call setup
setup...
[Function (anonymous)] render
mount component
normalize vnode
patch component
{ bar: 2 } { foo: 1 }
{ bar: 2 } { foo: 1 }
{ bar: 2 } { foo: 1 }
root:
#+end_example
** component update
:PROPERTIES:
:COLUMNS: %CUSTOM_ID[(Custom Id)]
:CUSTOM_ID: comp-update
:END:

éœ€è¦ä¿®æ”¹ç‚¹ï¼š

1. åœ¨ ~processComponent~ ä¸­å¢åŠ  ~updateComponent~ æ›´æ–°ç»„ä»¶
2. åœ¨ instance.update effect å‡½æ•°ä¸­å¢åŠ  ~updateProps()~ diff->update props


è¿™é‡Œä¸»è¦åŒ…å«äº† props çš„æ›´æ–°è§„åˆ™ï¼Œå¯¹äº children çš„ diff å’Œ update è§„åˆ™åˆ†æå¯ä»¥æŸ¥
çœ‹ [[/vue/vue-mind-map-runtime-core-2-render/#keyed-children][patchKeyedChildren diff å’Œ æ›´æ–°åŸç†åˆ†æï¼]]

ç»„ä»¶æ›´æ–°ï¼Œä»£ç æ‰§è¡Œæµç¨‹ï¼š

çŠ¶æ€å˜æ›´ -> instance.update effect æ‰§è¡Œ ->

å¦‚æœæœ‰ next vnode è§¦å‘ ~updateComponentPreRender()~ æ›´æ–° props å’Œ slots

æ‰§è¡Œ beforeUpdate hook

æ‰§è¡Œ onVnodeBeforeUpdate hook

å¾—åˆ°æ–°æ ‘ğŸŒ² nextTree = renderComponentRoot(instance)

è€æ ‘ğŸŒ² prevTree = instance.subTree

è¿›è¡Œ patch(prevTree, nextTree) æ“ä½œ

æ‰§è¡Œ updated hook å’Œ onVnodeUpdated hook

æµ‹è¯•ï¼š
#+begin_src js
const { log, f, shuffle, runtime_test, renderChildren } = require(process.env
  .BLOG_DIR_VUE + "/lib.js");
import(process.env.BLOG_DIR_VUE + "/runtime-test.global.js").then(
  async ({
    h,
    render,
    nodeOps,
    serializeInner: inner,
    ref,
    nextTick,
    defineComponent,
  }) => {
    const root = nodeOps.createElement("div");
    const logRoot = () => log("root: " + inner(root));
    let oa = { a: 1 },
      ob = { b: 1 },
      i = 0,
      j = 0;
    const defaultFn = () => (console.log(`fn called ${++i}`), oa);
    const defaultBaz = () => (console.log(`baz called ${++j}`), ob);

    let proxy;
    logRoot();
    try {
      const Comp = {
        props: {
          foo: { default: 1 },
          bar: { default: defaultFn },
          baz: { type: Function, default: defaultBaz },
        },
        render() {
          proxy = this;
        },
      };
      const print = (s) => {
        log(">>> " + s);
        const prevBar = proxy.bar;
        log("proxy.foo = " + proxy.foo);
        // å› ä¸ºæ—  typeï¼Œè€Œ default æ˜¯ä¸ªå‡½æ•°ï¼Œä¼šè¢«æ‰§è¡Œå¾—åˆ°ç»“æœ
        log("prevBar === oa: " + (prevBar === oa));
        // å› ä¸º type Function ï¼Œæ‰€ä»¥default æ˜¯ Function çš„è¯ä¸ä¼šè¢«æ‰§è¡Œ
        log("proxy.baz === defaultBaz, " + (proxy.baz === defaultBaz));
        log("proxy.bar === prevBar, " + (proxy.bar === prevBar));
      };
      render(h(Comp, { foo: 2 }), root);
      print("first");
      // update
      render(h(Comp, { foo: 3 }), root);
      print("update");
    } catch (e) {
      log(e.message);
    }
  },
  (err) => {
    console.log(err.message);
  }
);
#+end_src

#+RESULTS:
#+begin_example
undefinedroot:
{
  type: {
    props: { foo: [Object], bar: [Object], baz: [Object] },
    render: [Function: render]
  },
  shapeFlag: 4
}
fn called 1
component stateful ? 4
call setup
no setup
[Function: render] render
mount component
update effect
normalize vnode
patch component
{ type: Symbol(Comment), shapeFlag: 0 }
>>> first
proxy.foo = 2
prevBar === oa: true
proxy.baz === defaultBaz, true
proxy.bar === prevBar, true
{
  type: {
    props: { foo: [Object], bar: [Object], baz: [Object] },
    render: [Function: render],
    __props: [ [Object], [Array] ]
  },
  shapeFlag: 4
}
update component
should update component
has changed props
should update component....
normal update
update effect
component update
update comp pre render
normalize vnode
Cannot read property 'parentNode' of null
#+end_example

#+begin_quote
â“ æ²¡æœ‰è§¦å‘ ~instance.update~ ?

[[https://github.com/gcclll/stb-vue-next/commit/3771bfb42adaee8d3f84388d3d8d654ca44678fd][fix: props update invalid Â· gcclll/stb-vue-next@3771bfb]]

ä¿®å¤åï¼Œå›å»é‡æ–°æµ‹è¯•ã€‚
#+end_quote

FIX å¢åŠ ä»£ç ï¼š
#+begin_src typescript
const updateComponent = (n1: VNode, n2: VNode, optimized: boolean) => {
  console.log("update component");
  const instance = (n2.component = n1.component)!;
  if (shouldUpdateComponent(n1, n2, optimized)) {
    console.log("should update component....");
    if (
      __FEATURE_SUSPENSE__ &&
      instance.asyncDep && // async setup
      instance.asyncResolved
    ) {
      // ...
      return;
    } else {
      // æ–°å¢ä»£ç ã€‹ã€‹ã€‹ã€‹ã€‹ã€‹ã€‹ã€‹
      // æ­£å¸¸æ›´æ–°
      instance.next = n2;
      // è€ƒè™‘åˆ° child ç»„ä»¶å¯èƒ½æ­£åœ¨é˜Ÿåˆ—ä¸­æ’é˜Ÿï¼Œç§»é™¤å®ƒé¿å…
      // åœ¨åŒä¸€ä¸ª flush tick é‡å¤æ›´æ–°åŒä¸€ä¸ªå­ç»„ä»¶
      // å½“ä¸‹ä¸€æ¬¡æ›´æ–°æ¥åˆ°æ—¶ï¼Œä¹‹å‰çš„ä¸€æ¬¡æ›´æ–°å–æ¶ˆï¼Ÿ
      invalidateJob(instance.update);
      // instance.update æ˜¯åœ¨ setupRenderEffect ä¸­
      // å®šä¹‰çš„ä¸€ä¸ª reactive effect runner
      // ä¸»åŠ¨è§¦å‘æ›´æ–°
      instance.update();
    }
    return;
  } else {
    // ...
  }
};
#+end_src

#+begin_quote
â“ Cannot read property 'parentNode' of null

è¿™ä¸ªæŠ¥é”™å‘ç”Ÿåœ¨ instance.update effect çš„ else æ›´æ–°ç»„ä»¶ä¸­ï¼Œ

patch(... hostParentNode(prevTree.el!)!, ...)

çš„æ—¶å€™ï¼Œå»å–å€¼ prevTree.el å¾—åˆ°çš„æ˜¯ç©ºå€¼ï¼Œè¿›å…¥ hostParentNode è°ƒç”¨
node.parentNode æŠ¥é”™çš„ã€‚

è¿™é‡Œä¸ºä»€ä¹ˆ prevTree.el æ˜¯ null ? æ›´æ–°çš„è¯ä¹‹å‰çš„ node ä¸åº”è¯¥å·²ç»åŠ è½½å¥½äº†å—ï¼Ÿ
#+end_quote
** component slots
:PROPERTIES:
:COLUMNS: %CUSTOM_ID[(Custom Id)]
:CUSTOM_ID: comp-slots
:END:

[[https://github.com/gcclll/stb-vue-next/commit/a7884300c10c3cb3f0f5812ff2a6621651421e39][feat(add): init&update slots Â· gcclll/stb-vue-next@a788430]]

ä¿®æ”¹ç‚¹ï¼š


1. åˆå§‹åŒ–ï¼Œ ~setupComponent()~ ä¸­çš„ ~initSlots()~
2. ~updateComponent()~ -> ~updateComponentPreRender()~ ä¸­ ~updateSlots()~ æ›´æ–° slots


å¯¹åº”åŠ¨ä½œï¼š init -> update

å¯¹åº”ç»„ä»¶é˜¶æ®µï¼š åˆå§‹åŒ–(initSlots()) -> æ›´æ–°(updateSlots())

*** åˆå§‹åŒ–(~initSlots()~)ï¼š
:PROPERTIES:
:COLUMNS: %CUSTOM_ID[(Custom Id)]
:CUSTOM_ID: init-slots
:END:

#+begin_src typescript
export const initSlots = (
  instance: ComponentInternalInstance,
  children: VNodeNormalizedChildren
) => {
  if (instance.vnode.shapeFlag & ShapeFlags.SLOTS_CHILDREN) {
    const type = (children as RawSlots)._
    if (type) {
      instance.slots = children as InternalSlots
      // make compiler marker non-enumerable
      def(children as InternalSlots, '_', type)
    } else {
      normalizeObjectSlots(children as RawSlots, (instance.slots = {}))
    }
  } else {
    instance.slots = {}
    if (children) {
      normalizeVNodeSlots(instance, children)
    }
  }
  def(instance.slots, InternalObjectKey, 1)
}
#+end_src

è¦åˆ†ææ•´ä¸ªï¼Œéœ€è¦å›é¡¾ä¸‹ [[/vue/vue-mind-map-runtime-core-1/#normalize-children][normalizeChildren(vnode, children)]] å¤„ç†é€»è¾‘ï¼Œè¦ææ¸…æ¥šä»€ä¹ˆ
æƒ…å†µä¸‹ä¼šæ˜¯ ~SLOTS_CHILDREN~ ã€‚

æ ¹æ® ~normalizeChildren()~ çš„å®ç°ä¸­ï¼Œå¯çŸ¥éœ€è¦æ»¡è¶³ä¸‹é¢å‡ ä¸ªæ¡ä»¶ï¼š

#+begin_src js
if (isObject(vnode.children)) {
  if (isElement(vnode.shapeFlag) || isTELEPORT(vnode.shapeFlag)) {
    // default slot
  } else {
    // é ELEMENT æˆ– TELEPORT ç±»å‹
    // å¦‚ï¼š <Comp><template v-slot:named><div/></template></Comp>
    // children åªæœ‰ä¸€ä¸ª template ä¼šè¢«è§£ææˆä¸€ä¸ª vnode å¯¹è±¡
    // ä¸” vnode type æ˜¯ template
    type = ShapeFlags.SLOTS_CHILDREN;
  }
} else if (isFunction(vnode.children)) {
  // children æ˜¯ä¸ªå‡½æ•°
  // å‡½æ•°å¼ç»„ä»¶ Comp = { render() {
  //   return h('div', null, () => h('div') /* slot */)
  // }}
  type = ShapeFlags.SLOTS_CHILDREN;
}
#+end_src

1. ~children = { _: ... }~ å†…éƒ¨æ’æ§½ï¼Ÿ

2. normalizeObjectSlots: children æ˜¯å¯¹è±¡ç±»å‹ï¼š

    ~{named: slotFn1, default: slotFn2 }~

    éå†æ‰€æœ‰ key-value =>

    (*æ¨è*)å¦‚æœ value æ˜¯å‡½æ•°éœ€è¦å°† slotFn ç”¨ withCtx å°è£…ä¸€å±‚ï¼Œè®©å…¶åœ¨å½“å‰å®ä¾‹çš„ä¸Šä¸‹æ–‡ä¸­æ­£ç¡®âœ…æ‰§è¡Œã€‚
    #+begin_src typescript
     const normalizeSlot = (
       key: string,
       rawSlot: Function,
       ctx: ComponentInternalInstance | null | undefined
     ): Slot =>
       withCtx((props: any) => {
         // warn: åœ¨ Render å‡½æ•°å¤–æ‰§è¡Œäº† slot function
         return normalizeSlotValue(rawSlot(props));
       }, ctx);
    #+end_src

    (*ä¸æ¨è*)å¦‚æœ value ä¸æ˜¯å‡½æ•°ï¼Œç»è¿‡
    #+begin_src typescript
    const normalizeSlotValue = (value: unknown): VNode[] =>
    isArray(value)
        ? value.map(normalizeVNode)
        : [normalizeVNode(value as VNodeChild)]
    #+end_src

    å¤„ç†ä¹‹åè½¬æˆå‡½æ•°èµ‹å€¼ ~slots[key] = () => normalized~

    æœ€ç»ˆéƒ½æ˜¯å°† slot value è½¬æˆä¸€ä¸ªå‡½æ•°ä¿å­˜åˆ° ~instance.slots{}~ ä¸­

3. é ~SLOTS_CHILDREN~ ï¼Œé‚£åªæœ‰ä¸€ç§æƒ…å†µ

   children ä¸­æ²¡æœ‰ ~<template v-slot:named ...>~ ï¼Œæ­¤æ—¶å®ƒæ‰€æœ‰çš„ child éƒ½ä¼šè¢«å½“åš
   é»˜è®¤æ’æ§½æ¥å¤„ç†ã€‚

   #+begin_src typescript
   const normalizeVNodeSlots = (
     instance: ComponentInternalInstance,
     children: VNodeNormalizedChildren
   ) => {
     const normalized = normalizeSlotValue(children);
     instance.slots.default = () => normalized;
   };
   #+end_src

   å¦‚ï¼š
   #+begin_src js
   const { log, shuffle, runtime_test, renderChildren } = require(process.env
     .BLOG_DIR_VUE + "/lib.js");
   import(process.env.BLOG_DIR_VUE + "/runtime-test.global.js").then(
     async ({ h, createVNode: c }) => {
       log.br();
       const Comp = { template: "<div/>" };
       const slot = () => {};
       const node = h(Comp, slot);
       log(">>> å‡½æ•°ä½œä¸º children è§£æä¸ºé»˜è®¤æ’æ§½");
       log.f(node, ["children", "type"]);
       log(node.children);
     }
   );
    #+end_src

   #+RESULTS:
   : undefined
   :
   : >>> å‡½æ•°ä½œä¸º children è§£æä¸ºé»˜è®¤æ’æ§½
   : {
   :   type: { template: '<div/>' },
   :   children: { default: [Function: slot], _ctx: null }
   : }
   : { default: [Function: slot], _ctx: null }

*** æ›´æ–°(~updateSlots()~)
:PROPERTIES:
:COLUMNS: %CUSTOM_ID[(Custom Id)]
:CUSTOM_ID: update-slots
:END:

æ›´æ–°æ’æ§½æ­¥éª¤ï¼š

1. åˆå¹¶ instance.slots å’Œ children
2. ç„¶ååˆ é™¤ children ä¸­æ²¡æœ‰çš„æ’æ§½

#+begin_src typescript
export const updateSlots = (
  instance: ComponentInternalInstance,
  children: VNodeNormalizedChildren
) => {
  const { vnode, slots } = instance;
  let needDeletionCheck = true;
  let deletionComparisonTarget = EMPTY_OBJ;
  console.log("update slots");
  // children æ˜¯ å‡½æ•°æˆ–å¯¹è±¡ç±»å‹(éæ•°ç»„)
  if (vnode.shapeFlag & ShapeFlags.SLOTS_CHILDREN) {
    const type = (children as RawSlots)._;
    if (type) {
      console.log("update slots type");
      // compiled slots.
      if (__DEV__ && isHmrUpdating) {
        // TODO
      } else if (type === SlotFlags.STABLE) {
        // compiled AND stable
        // ä¸éœ€è¦æ›´æ–°ï¼Œè·³è¿‡ slots åˆ é™¤æ“ä½œ
        needDeletionCheck = false;
      } else {
        // compiled but dynamic (v-if/v-for on slots)
        // update slots, but skip normalization
        extend(slots, children as Slots);
      }
    } else {
      console.log("update slots no type");
      needDeletionCheck = !(children as RawSlots).$stable;
      normalizeObjectSlots(children as RawSlots, slots);
    }
    // å¯¹è±¡ç±»å‹ç›´æ¥åˆå¹¶ï¼Œè¿™é‡Œè®°å½•éœ€è¦è¿›è¡Œåˆ é™¤æ“ä½œçš„å¯¹è±¡ï¼Œchildren
    // ä¸Šé¢åªæ˜¯è¿›è¡Œäº†ç®€å•çš„å¯¹è±¡åˆå¹¶æ“ä½œ
    // å¦‚ï¼š slots={a,b,d}, children = {a,b,c}
    // åˆå¹¶ä¹‹åï¼š slots={a,b,c,d},åé¢éœ€è¦åˆ é™¤çš„æ˜¯ d è¿™ä¸ªæ’æ§½
    deletionComparisonTarget = children as RawSlots;
  } else if (children) {
    // <Comp>...è¿™é‡Œæ²¡æœ‰ <template #named ...> æƒ…å†µ</Comp>
    // <Comp> é‡Œé¢çš„æ‰€æœ‰å†…å®¹éƒ½ä¼šè¢«å½“åšé»˜è®¤æ’æ§½æ¥è§£æ
    console.log("update slots children");
    // non slot object children (direct value)
    // passed to a component
    // å½“åšé»˜è®¤æ’æ§½æ¥å¤„ç†ï¼Œè§£æåï¼š slots.default = () => normalized
    normalizeVNodeSlots(instance, children);
    // è¿™é‡Œç›®çš„æ˜¯ä¸ºäº†åªä¿ç•™ default å…¶ä»–éƒ½éœ€è¦åˆ é™¤
    deletionComparisonTarget = { default: 1 };
  }

  console.log({ needDeletionCheck });
  // delete stale slots
  // åˆ é™¤æ—§çš„ slots
  if (needDeletionCheck) {
    for (const key in slots) {
      // é `_` å†…éƒ¨æ’æ§½ï¼Œä¸”ä¸å†æ–°çš„ children ä¸­çš„
      if (!isInternalKey(key) && !(key in deletionComparisonTarget)) {
        delete slots[key];
      }
    }
  }
};
#+end_src
** props tests

ä¼ å…¥çš„ rawProps å’Œç»„ä»¶è‡ªèº«çš„ props ç»è¿‡å¤„ç†ä¹‹å(setFullProps()) ä¼šå°† rawProps æ ¹
æ®ä¸€å®šè§„åˆ™åˆ†æ´¾åˆ°ç»„ä»¶ props æˆ– attrs ä¸­å»ã€‚

è¿™é‡Œçš„ rawProps ä»£è¡¨æ˜¯ parent åœ¨æ¸²æŸ“å­ç»„ä»¶çš„æ—¶å€™ä¼ é€’ç»™å®ƒçš„ props ï¼Œå¦‚ï¼š

~render(h(Child, { foo:1, bar:2}),root)~

ä¸­çš„ ~{foo:1,bar:2}~ å³ parent propsï¼Œç„¶åç»„ä»¶å¯ä»¥å®šä¹‰è‡ªèº«çš„ props å±æ€§ï¼š

~defineComponent({ props: ['foo'] })~ æ„å‘³ç€ï¼Œè¯¥å­ç»„ä»¶åªæ¥å— ~'foo'~ ä½œä¸º props
è€Œå…¶ä»–çš„ä¼šè¢«è§£ææˆ attrs ã€‚

component props æµ‹è¯•ï¼š

#+begin_src js
const { log, f, shuffle, runtime_test, renderChildren } = require(process.env
  .BLOG_DIR_VUE + "/lib.js");
import(process.env.BLOG_DIR_VUE + "/runtime-test.global.js").then(
  async ({
    h,
    render,
    nodeOps,
    serializeInner: inner,
    ref,
    nextTick,
    defineComponent,
  }) => {
    const root = nodeOps.createElement("div");
    const logRoot = () => log("root: " + inner(root));

    logRoot();
    log(">>>stateful");
    let props, attrs, proxy;
    try {
      const Comp = defineComponent({
        props: ["fooBar", "barBaz", "foo-baz"],
        render() {
          console.log("comp render");
          props = this.$props;
          attrs = this.$attrs;
          proxy = this;
        },
      });

      render(h(Comp, { fooBar: 1, bar: 2, fooBaz: 3 }), root);
    } catch (e) {
      log(e);
    }

    console.log("proxy.fooBar=" + proxy.fooBar);
    log([props, attrs]);
    logRoot();
  },
  (err) => {
    console.log(err.message);
  }
);
#+end_src

#+RESULTS:
#+begin_example
undefinedroot:
>>>stateful
{
  type: {
    props: [ 'fooBar', 'barBaz', 'foo-baz' ],
    render: [Function: render]
  },
  shapeFlag: 4
}
component stateful ? 4
call setup
no setup
[Function: render] render
mount component
update effect
normalize vnode
comp render
patch component
{ type: Symbol(Comment), shapeFlag: 0 }
proxy.fooBar=1
{ fooBar: 1, fooBaz: 3 } { bar: 2 }
root:
#+end_example
** component unmount

[[https://github.com/gcclll/stb-vue-next/commit/79c5061781235abffd5d744781857fd3cfa0008a][feat(add): add unmount component Â· gcclll/stb-vue-next@79c5061]]

ä¸»è¦å·¥ä½œï¼š

1. æ‰§è¡Œ ~beforeUnmount~ å‘¨æœŸå‡½æ•°
2. åœæ‰æ‰€æœ‰ effects ä¾èµ–
3. æ£€æŸ¥ update å‡½æ•°ï¼Œå¤„ç†åœ¨å¼‚æ­¥ update ä¹‹å‰æ‰§è¡Œäº† unmount
4. åœ¨ post queue ä¸­æ‰§è¡Œ ~unmounted~ å‘¨æœŸå‡½æ•°
5. åœ¨ post queue ä¸­æ ‡è®° ~instance.isUnmounted=true~ æ ‡è®°ç»„ä»¶å·²ç»å¸è½½äº†


#+begin_quote
ä¸‰ç§é˜Ÿåˆ—ä»»åŠ¡ï¼Œ ~pre, post, job~ æ‰§è¡Œé¡ºåºï¼š pre > job > postï¼Œè¯¦æƒ…æŸ¥çœ‹

[[/vue/vue-mind-map-runtime-core-1/#scheduler][scheduler ä»»åŠ¡è°ƒåº¦æœºåˆ¶]]
#+end_quote

#+begin_src typescript
const unmountComponent = (
  instance: ComponentInternalInstance,
  parentSuspense: SuspenseBoundary | null,
  doRemove?: boolean
) => {
  const { bum, effects, update, subTree, um } = instance;
  // beforeUnmount hook
  if (bum) {
    invokeArrayFns(bum);
  }
  if (effects) {
    for (let i = 0; i < effects.length; i++) {
      stop(effects[i]);
    }
  }

  // update may be null if a component is unmounted before its async
  // setup has resolved.
  if (update) {
    stop(update);
    unmount(subTree, instance, parentSuspense, doRemove);
  }

  // unmounted hook
  if (um) {
    queuePostRenderEffect(um, parentSuspense);
  }
  queuePostRenderEffect(() => {
    instance.isUnmounted = true;
  }, parentSuspense);

  // TODO suspense
};
#+end_src
** normalize emits options

[[https://github.com/gcclll/stb-vue-next/commit/b918dde38055d7e6faf6e2371647f805c10f2721][feat(add): props event init Â· gcclll/stb-vue-next@b918dde]]

** é—®é¢˜

*** TypeError: Cannot read property 'allowRecurse' of null
:PROPERTIES:
:COLUMNS: %CUSTOM_ID[(Custom Id)]
:CUSTOM_ID: q-allow-recurse
:END:

#+begin_example
TypeError: Cannot read property 'allowRecurse' of null
    at createReactiveEffect (/Users/simon/blog/cheng92.com/static/js/vue/runtime-test.global.js:251:39)
    at effect (/Users/simon/blog/cheng92.com/static/js/vue/runtime-test.global.js:199:22)
    at setupRenderEffect (/Users/simon/blog/cheng92.com/static/js/vue/runtime-test.global.js:2738:29)
    at mountComponent (/Users/simon/blog/cheng92.com/static/js/vue/runtime-test.global.js:2733:11)
    at processComponent (/Users/simon/blog/cheng92.com/static/js/vue/runtime-test.global.js:2724:19)
    at patch (/Users/simon/blog/cheng92.com/static/js/vue/runtime-test.global.js:2616:23)
    at render (/Users/simon/blog/cheng92.com/static/js/vue/runtime-test.global.js:3099:15)
    at /private/var/folders/1n/xw58p9v90tn42m87q527fvgr0000gn/T/babel-orafVD/js-script-Vmw0ga:29:5
#+end_example

å› ä¸ºå®ç°é—®é¢˜ï¼š

#+begin_src typescript
instance.update = effect(function componentEffect() {
      // ç›‘å¬æ›´æ–°
      if (!instance.isMounted) {
        // è¿˜æ²¡åŠ è½½å®Œæˆï¼Œå¯èƒ½æ˜¯ç¬¬ä¸€æ¬¡ mount æ“ä½œ
        // TODO
      } else {
        // TODO
      }
    }, __DEV__ ? /* TODO */ (null as any) : prodEffectOptions)
#+end_src

æ–‡å­—å†…çš„æµ‹è¯•æ˜¯åŸºäº node development ç¯å¢ƒæµ‹è¯•çš„ï¼Œè¿™é‡Œ effect options æ˜¯ null æ‰€ä»¥
æŠ¥é”™ã€‚

[[https://github.com/gcclll/stb-vue-next/commit/63675a485bf8223b3be8d76fa3ce28d397d8e726][fix: effect null options Â· gcclll/stb-vue-next@63675a4]]
* processText|Comment|Static
:PROPERTIES:
:COLUMNS: %CUSTOM_ID[(Custom Id)]
:CUSTOM_ID: render-text
:END:

[[https://github.com/gcclll/stb-vue-next/commit/636e87099f5e1322cf2af0aeb82614e2fa6a7fe3][feat(add): processText updte Â· gcclll/stb-vue-next@636e870 Â· GitHub]]

æœ¬èŠ‚åŒ…å«(ä¸»è¦æºç ï¼Œæ²¡å•¥å¥½åˆ†æçš„)ï¼š

1. æ–‡æœ¬èŠ‚ç‚¹
2. æ³¨é‡ŠèŠ‚ç‚¹
3. é™æ€èŠ‚ç‚¹


** Text
:PROPERTIES:
:COLUMNS: %CUSTOM_ID[(Custom Id)]
:CUSTOM_ID: Text
:END:

#+begin_src typescript
const processText: ProcessTextOrCommentFn = (n1, n2, container, anchor) => {
  if (n1 == null /* old */) {
    // æ–°èŠ‚ç‚¹ï¼Œæ’å…¥å¤„ç†
    hostInsert(
      (n2.el = hostCreateText(n2.children as string)),
      container,
      anchor
    );
  } else {
    // has old vnode, need to diff
    const el = (n2.el = n1.el!);
    if (n2.children !== n1.children) {
      hostSetText(el, n2.children as string);
    }
  }
};
#+end_src

å› ä¸ºåœ¨ compiler-core parse é˜¶æ®µçš„æ–‡æœ¬å¤„ç†ä¸­ï¼Œå¦‚æœæ˜¯å“é“ƒçš„æ–‡æœ¬èŠ‚ç‚¹ä¼šè¢«åˆå¹¶ï¼Œå¦‚ï¼š

~<div>{{ text1 }} {{ text2 }}</div>~ æœ€ç»ˆä¼šåˆå¹¶ï¼š

~<div>{{ text1 + ' ' + text2 }}</div>~ æœ€ç»ˆæ›¿æ¢çš„æ˜¯ ~<div/>~ æ•´ä¸ªå†…å®¹ã€‚

** Comment
:PROPERTIES:
:COLUMNS: %CUSTOM_ID[(Custom Id)]
:CUSTOM_ID: Comment
:END:

[[https://github.com/gcclll/stb-vue-next/commit/448936662634690c5d2e5596e31d066b0f96cd63][feat(add): process comment node Â· gcclll/stb-vue-next@4489366 Â· GitHub]]

#+begin_src typescript
const processCommentNode: ProcessTextOrCommentFn = (
    n1,
    n2,
    container,
    anchor
  ) => {
    if (n1 == null) {
      hostInsert(
        (n2.el = hostCreateComment((n2.children as string) || '')),
        container,
        anchor
      )
    } else {
      // there's no support for dynamic comments
      n2.el = n1.el
    }
  }

#+end_src

** Static
:PROPERTIES:
:COLUMNS: %CUSTOM_ID[(Custom Id)]
:CUSTOM_ID: Static
:END:

patch -> case Static:

#+begin_src typescript
// case Static:
if (n1 == null) {
  mountStaticNode(n2, container, anchor, isSVG);
} else if (__DEV__) {
  patchStaticNode(n1, n2, container, isSVG);
}
// break
#+end_src

æ²¡æœ‰ old vnode -> mount

æœ‰ old node -> patch

*mount*:
#+begin_src typescript
const mountStaticNode = (
  n2: VNode,
  container: RendererElement,
  anchor: RendererNode | null,
  isSVG: boolean
) => {
  // static nodes are only present when used with compiler-dom/runtime-dom
  // which guarantees presence of hostInsertStaticContent.
  [n2.el, n2.anchor] = hostInsertStaticContent!(
    n2.children as string,
    container,
    anchor,
    isSVG
  );
};
#+end_src

mount æ—¶ç”¨åˆ°çš„ ~hostInsertStaticContent()~ æ˜¯åœ¨ runtime-dom åŒ…ä¸­å®ç°çš„ï¼Œå…ˆé¢„è§ˆä¸‹
ä»£ç ï¼š

#+begin_src typescript
function insertStaticContent(content, parent, anchor, isSVG) {
  const temp = isSVG
    ? tempSVGContainer || (tempSVGContainer = doc.createElementNS(svgNS, "svg"))
    : tempContainer || (tempContainer = doc.createElement("div"));
  temp.innerHTML = content;
  const first = temp.firstChild as Element;
  let node: Element | null = first;
  let last: Element = node;
  while (node) {
    last = node;
    nodeOps.insert(node, parent, anchor);
    node = temp.firstChild as Element;
  }
  return [first, last];
}
#+end_src

å¯ä»¥çœ‹åˆ° ~temp.innerHTML = content~ ä¸€ä¸ªç®€å•çš„å†…å®¹å…¨æ›¿æ¢æ“ä½œã€‚

*patchStaticNode*: å› ä¸ºé™æ€èŠ‚ç‚¹åœ¨ç”Ÿäº§ç¯å¢ƒä¸­ä¼šè¢«æå‡ï¼Œé‡ç”¨ï¼Œå› æ­¤ä¸å­˜åœ¨ patch é˜¶æ®µã€‚
#+begin_src typescript
const patchStaticNode = (
  n1: VNode,
  n2: VNode,
  container: RendererElement,
  isSVG: boolean
) => {
  // static nodes are only patched during dev for HMR
  if (n2.children !== n1.children) {
    const anchor = hostNextSibling(n1.anchor!);
    // remove existing
    removeStaticNode(n1);
    // insert new
    [n2.el, n2.anchor] = hostInsertStaticContent!(
      n2.children as string,
      container,
      anchor,
      isSVG
    );
  } else {
    n2.el = n1.el;
    n2.anchor = n1.anchor;
  }
};
#+end_src

*moveStaticNode*: åœ¨ diff -> update é˜¶æ®µ move() ä¸­è§¦å‘
#+begin_src typescript
const moveStaticNode = (
  { el, anchor }: VNode,
  container: RendererElement,
  nextSibling: RendererNode | null
) => {
  let next;
  while (el && el !== anchor) {
    next = hostNextSibling(el);
    hostInsert(el, container, nextSibling);
    el = next;
  }
  hostInsert(anchor!, container, nextSibling);
};
#+end_src

*removeStaticNode*: ~remove()~ ä¸­è§¦å‘
#+begin_src typescript
const removeStaticNode = ({ el, anchor }: VNode) => {
  let next;
  while (el && el !== anchor) {
    next = hostNextSibling(el);
    hostRemove(el);
    el = next;
  }
  hostRemove(anchor!);
};
#+end_src
* processFragment
:PROPERTIES:
:COLUMNS: %CUSTOM_ID[(Custom Id)]
:CUSTOM_ID: render-fragment
:END:

Fragment çš„æƒ…å†µï¼š children æœ‰å¤šä¸ª child çš„æ—¶å€™ï¼Œä¼šç”¨ä¸€ä¸ª fragment äº‹å…ˆåŒ…èµ·æ¥ã€‚

[[/img/vue3/runtime-core/vue-runtime-core-render-fragment.svg]]

~STABLE_FRAGMENT~ æƒ…å†µï¼š

1. ~v-if~

   é¦–å…ˆè¦æ»¡è¶³ children.length !== 1 å³æœ‰ä¸€ä¸ªä»¥ä¸Šçš„ children, å¦‚ï¼š

   ~<div><p/><p/></div>~

   æˆ–è€…éç¬¬ä¸€ä¸ª child ELEMENT ç±»å‹ï¼Œå¦‚ï¼š

   ~<div><Comp/></div>~

   å…¶è¦æ»¡è¶³ ~(children.length === 1 && firstChild.type === NodeTypes.FOR)~ å¦‚ï¼š

   ~<div v-for="item in list"><p/></div>~

   æ‰ä¼šè¢«å½“åš ~PatchFlags.STABLE_FRAGMENT~

   #+begin_src typescript
    // vIf.ts
    const needFragmentWrapper =
      children.length !== 1 || firstChild.type !== NodeTypes.ELEMENT;
    if (needFragmentWrapper) {
      if (children.length === 1 && firstChild.type === NodeTypes.FOR) {
        // ...
      } else {
        return createVNodeCall(
          // ...
          PatchFlags.STABLE_FRAGMENT +
            (__DEV__ ? ` /* ${PatchFlagNames[PatchFlags.STABLE_FRAGMENT]} */` : ``),
          // ...
        );
      }
    }
   #+end_src

2. ~v-for~

   #+begin_src typescript
    // vFor.ts
    const isStableFragment =
        forNode.source.type === NodeTypes.SIMPLE_EXPRESSION &&
        forNode.source.constType > 0
      const fragmentFlag = isStableFragment
        ? PatchFlags.STABLE_FRAGMENT
        : keyProp
          ? PatchFlags.KEYED_FRAGMENT
          : PatchFlags.UNKEYED_FRAGMENT
   #+end_src


æºç ï¼š
#+begin_src typescript
const processFragment = (
    n1: VNode | null,
    n2: VNode,
    container: RendererElement,
    anchor: RendererNode | null,
    parentComponent: ComponentInternalInstance | null,
    parentSuspense: SuspenseBoundary | null,
    isSVG: boolean,
    optimized: boolean
  ) => {
    const fragmentStartAnchor = (n2.el = n1 ? n1.el : hostCreateText(''))!
    const fragmentEndAnchor = (n2.anchor = n1 ? n1.anchor : hostCreateText(''))!

    let { patchFlag, dynamicChildren } = n2
    if (patchFlag > 0) {
      optimized = true
    }

    if (__DEV__ && isHmrUpdating) {
      // HMR updated, force full diff
      patchFlag = 0
      optimized = false
      dynamicChildren = null
    }

    if (n1 == null) {
      hostInsert(fragmentStartAnchor, container, anchor)
      hostInsert(fragmentEndAnchor, container, anchor)
      // fragment çš„ children åªä¼šæ˜¯ array children
      // å› ä¸ºä»–ä»¬è¦ä¹ˆæ˜¯é€šè¿‡ compiler ç”Ÿæˆçš„ï¼Œè¦ä¹ˆæ˜¯ç”±æ•°ç»„åˆ›å»ºçš„
      mountChildren(
        n2.children as VNodeArrayChildren,
        container,
        fragmentEndAnchor,
        parentComponent,
        parentSuspense,
        isSVG,
        optimized
      )
    } else {
      if (
        patchFlag > 0 &&
        patchFlag & PatchFlags.STABLE_FRAGMENT &&
        dynamicChildren &&
        // #2715 the previous fragment could've been a BAILed one as a result
        // of renderSlot() with no valid children
        n1.dynamicChildren
      ) {
        // a stable fragment (template root or <template v-for>) doesn't need to
        // patch children order, but it may contain dynamicChildren.
        patchBlockChildren(
          n1.dynamicChildren,
          dynamicChildren,
          container,
          parentComponent,
          parentSuspense,
          isSVG
        )
        if (__DEV__ && parentComponent && parentComponent.type.__hmrId) {
          traverseStaticChildren(n1, n2)
        } else if (
          // #2080 if the stable fragment has a key, it's a <template v-for> that may
          //  get moved around. Make sure all root level vnodes inherit el.
          // #2134 or if it's a component root, it may also get moved around
          // as the component is being moved.
          n2.key != null ||
          (parentComponent && n2 === parentComponent.subTree)
        ) {
          traverseStaticChildren(n1, n2, true /* shallow */)
        }
      } else {
        // keyed / unkeyed, or manual fragments.
        // for keyed & unkeyed, since they are compiler generated from v-for,
        // each child is guaranteed to be a block so the fragment will never
        // have dynamicChildren.
        patchChildren(
          n1,
          n2,
          container,
          fragmentEndAnchor,
          parentComponent,
          parentSuspense,
          isSVG,
          optimized
        )
      }
    }
  }
#+end_src
* TELEPORT
:PROPERTIES:
:COLUMNS: %CUSTOM_ID[(Custom Id)]
:CUSTOM_ID: teleport
:END:

[[https://github.com/gcclll/stb-vue-next/commit/0fcfa324ac72cf74ff24677bfa2305dac2dde6ac][feat(init): Teleport Â· gcclll/stb-vue-next@0fcfa32 Â· GitHub]]

[[/img/vue3/runtime-core/vue-runtime-core-render-teleport.svg]]

** æ–°å¢ä»£ç :

*TeleportImpl*: ç»„ä»¶æ¨¡æ¿
#+begin_src typescript
export const TeleportImpl = {
  __isTeleport: true,
  process() {},
  remove() {},
  move: moveTeleport,
  hydrate: hydrateTeleport
}
#+end_src

*resolveTarget*: æ ¹æ®é€‰æ‹©å™¨æ‰¾åˆ°ç›®æ ‡å…ƒç´ 
#+begin_src typescript
const resolveTarget = <T = RendererElement>(
  props: TeleportProps | null,
  select: RendererOptions['querySelector']
): T | null => {
  const targetSelector = props && props.to
  if (isString(targetSelector)) {
    if (!select) {
      // æ— æ•ˆé€‰æ‹©å™¨
      return null
    } else {
      const target = select(targetSelector)
      // Teleport è®¾ç½®å¤±è´¥
      return target as any
    }
  } else {
    // æ— æ•ˆçš„ Teleport ç›®æ ‡
    return targetSelector as any
  }
}
#+end_src

*moveTeleport*: æ‰§è¡Œç§»åŠ¨
#+begin_src typescript
function moveTeleport(
  vnode: VNode,
  container: RendererElement,
  parentAnchor: RendererNode | null,
  { o: { insert }, m: move }: RendererInternals,
  moveType: TeleportMoveTypes = TeleportMoveTypes.REORDER
) {
  // TODO
}
#+end_src

*hydrateTeleport*:
#+begin_src typescript
function hydrateTeleport(
  node: Node,
  vnode: TeleportVNode,
  parentComponent: ComponentInternalInstance | null,
  parentSuspense: SuspenseBoundary | null,
  optimized: boolean,
  {
    o: { nextSibling, parentNode, querySelector }
  }: RendererInternals<Node, Element>,
  hydrateChildren: (
    node: Node | null,
    vnode: VNode,
    container: Element,
    parentComponent: ComponentInternalInstance | null,
    parentSuspense: SuspenseBoundary | null,
    optimized: boolean
  ) => Node | null
): Node | null {
  return vnode.anchor && nextSibling(vnode.anchor as Node)
}
#+end_src

å¯¼å‡ºç»„ä»¶ ~Teleport~ï¼š
#+begin_src typescript
// Force-casted public typing for h and TSX props inference
export const Teleport = (TeleportImpl as any) as {
  __isTeleport: true
  new (): { $props: VNodeProps & TeleportProps }
#+end_src

** process()
:PROPERTIES:
:COLUMNS: %CUSTOM_ID[(Custom Id)]
:CUSTOM_ID: teleport-process
:END:

#+begin_src typescript
function process(/*çœç•¥å‚æ•°*/) {
  // ...

  const disabled = isTeleportDisabled(n2.props);
  const { shapeFlag, children } = n2;

  if (n1 == null) {
    // insert anchors in the main view
    // <container><placeholder/><anchor/></container>
    insert(placeholder, container, anchor);
    // <container><main-anchor/><anchor/></container>
    insert(mainAnchor, container, anchor);
    // æ ¹æ®é€‰æ‹©å™¨ <Teleport to="selector"/> selector
    // æ‰¾åˆ°ç›®æ ‡ DOM å…ƒç´ 
    const target = (n2.target = resolveTarget(n2.props, querySelector));
    // <target><!-- '' --></target>ï¼Œç”¨æ¥ä½œä¸ºæ’å…¥æ—¶çš„å‚è€ƒèŠ‚ç‚¹
    const targetAnchor = (n2.targetAnchor = createText(""));
    if (target) {
      insert(targetAnchor, target);
      // #2652 we could be teleporting from a non-SVG tree into an SVG tree
      isSVG = isSVG || isTargetSVG(target);
    } /* else if warn ... */

    const mount = (container: RendererElement, anchor: RendererNode) => {
      // å°† vnode children æ¸²æŸ“åˆ° target å…ƒç´ å†…
      // ä¼šæ’å…¥åˆ° anchor çš„å‰é¢,å¦‚ï¼š ~<target><children/><!--''--></target>~
    };

    if (disabled) {
      // å¤±æ•ˆçŠ¶æ€ï¼Œä¸ç›´æ¥æ¸²æŸ“åˆ°ç›®æ ‡å…ƒç´ ä¸­ï¼Œè€Œæ˜¯æŒ‚åœ¨äº† #app å†…å¯¹åº”çš„
      // èŠ‚ç‚¹é‡Œé¢ï¼Œç­‰å¾…çŠ¶æ€ enable å†æ¸²æŸ“å› target å…ƒç´ 
      mount(container, mainAnchor);
    } else if (target) {
      // ç›´æ¥æ¸²æŸ“è¿›ç›®æ ‡å…ƒç´ 
      mount(target, targetAnchor);
    }
  } else {
    // update content
    // éé¦–æ¬¡æ¸²æŸ“
    n2.el = n1.el;
    // å·²ç»æ¸²æŸ“åˆ° tar

    if (n2.dynamicChildren) {
      // åŠ¨æ€å­èŠ‚ç‚¹ patch
    } else if (!optimized) {
      // patch n1|n2 children
    }

    if (disabled) {
      // n2 new teleport disabled -> n1 old target enabled
      // n2 ç›´æ¥ç§»åˆ° #app ç»“æ„ä¸­çš„ container ä¸Šï¼Œæš‚æ—¶ä¸ç›´æ¥æ¸²æŸ“åˆ°
      // ç›®æ ‡å…ƒç´ ä¸Š
      if (!wasDisabled) {
        // moveTeleport
      }
    } else {
      // target changed
      // teleport çš„ to å±æ€§å€¼å‘ç”Ÿäº†å˜åŒ–ï¼Œæ‰¾åˆ°æ–°çš„ç›®æ ‡
      // è¿›è¡Œç§»åŠ¨
      if ((n2.props && n2.props.to) !== (n1.props && n1.props.to)) {
        // 1. æ‰¾æ–°ç›®æ ‡
        // 2. å°† n2 ç§»åŠ¨åˆ°æ–°çš„ç›®æ ‡ä¸­
        // ...
      } else if (wasDisabled) {
        // çŠ¶æ€å˜æ›´
        // disabled -> enabled
        // move into teleport target
        // ä» container ä¸­å°† n2 ç§»åˆ°ç›®æ ‡å…ƒç´ ä¸­
      }
    }
  }
}
#+end_src

å¯¹äº teleport çš„ mount å’Œ update ä¸¤ä¸ªå…±åŒç‚¹(ä¹Ÿæ˜¯é‡ç‚¹)ï¼š

1. å½“ new teleport æ˜¯ disabled æ—¶ï¼Œä¸ç›´æ¥æ¸²æŸ“åˆ°ç›®æ ‡å…ƒç´ ä¸­ï¼Œè€Œæ˜¯æŒ‚åœ¨å½“å‰
   container ä¸­å¾…ç”¨
2. å½“ new teleport çŠ¶æ€ enabled æ—¶ï¼Œä¸è®º old ä»€ä¹ˆçŠ¶æ€ï¼Œéƒ½ä¼šè®²æ–°çš„ teleport
   children æ¸²æŸ“åˆ°ç›®æ ‡å…ƒç´ ä¸‹é¢ã€‚


Teleport çš„ç§»åŠ¨ç±»å‹æœ‰ï¼š

1. ~TARGET_CHANGE~ ç›®æ ‡å‘ç”Ÿäº†å˜åŒ–ï¼Œ teleport çš„ ~to~ å±æ€§å˜åŒ–

   #+begin_src typescript
   // move target anchor if this is a target change.
   if (moveType === TeleportMoveTypes.TARGET_CHANGE) {
     insert(vnode.targetAnchor!, container, parentAnchor);
   }
   #+end_src
2. ~TOGGLE~ çŠ¶æ€å‘ç”Ÿäº†å˜åŒ– enable -> disable æˆ– disable -> enable
3. ~REORDER~ ç›®æ ‡å…ƒç´ å†…è¿›è¡Œé‡æ–°æ’åº ?

   #+begin_src typescript
   // move main view anchor if this is a re-order.
   if (isReorder) {
     insert(anchor!, container, parentAnchor);
   }
   #+end_src
** TODO æµ‹è¯•

#+begin_src js
const { log, f, shuffle, runtime_test, renderChildren } = require(process.env
  .BLOG_DIR_VUE + "/lib.js");
import(process.env.BLOG_DIR_VUE + "/runtime-test.global.js").then(
  ({ h, render, Teleport, nodeOps, serializeInner: inner, ref }) => {
    const target = nodeOps.createElement("div");
    const root = nodeOps.createElement("div");

    try {
      render(
        h(() => [
          h(Teleport, { to: target }, h("div", "teleported")),
          h("div", "root"),
        ]),
        root
      );
    } catch (e) {
      console.log(e.message);
    }

    log([">>> root", inner(root)]);
    log([">>> target", inner(target)]);
  },
  (err) => {
    console.log(err.message);
  }
);
#+end_src

#+RESULTS:
: undefinedcomponent stateful ? 0
: mount component
: update effect
: patch component
: >>> root
: >>> target

#+begin_quote
â“ æ²¡ç»“æœï¼ï¼ï¼ï¼ï¼ï¼
#+end_quote

* SUSPENSE
:PROPERTIES:
:COLUMNS: %CUSTOM_ID[(Custom Id)]
:CUSTOM_ID: suspense
:END:

[[https://github.com/gcclll/stb-vue-next/commit/fd651abed0f0bbfb4e41910909212faeca26e116][feat(add): suspense Â· gcclll/stb-vue-next@fd651ab]]

Suspense ç»„ä»¶å’Œ [[#teleport][Teleport]] ä¸€æ ·çš„ç»„ç»‡ç»“æ„å’Œä½¿ç”¨æ–¹å¼

ç»“æ„ï¼š

#+begin_src js
var Tmpl = {
  __isSuspense: true,
  process() {}
}
#+end_src

ç„¶ååœ¨ process ä¸­å¤„ç† mount æˆ– patch æµç¨‹ï¼Œè¿™é‡Œé¢å’Œæ™®é€šæ ‡ç­¾æˆ–æ™®é€šç»„ä»¶çš„å¤„ç†æ˜¯ä¸€
æ ·çš„ï¼Œ mount or patchã€‚

ä¸‹é¢æ¥çœ‹ä¸‹è¿™ä¸ªç»„ä»¶æ˜¯å¦‚ä½•å®ç°çš„ï¼ŒåŠŸèƒ½åˆæ˜¯å¦‚ä½•ï¼Ÿ

æ–°å¢å‡½æ•°ï¼š

#+begin_src typescript
// 1. æ¨¡æ¿
// æ ¹æ®æ³¨é‡Šè¯´æ˜ï¼Œä¹‹æ‰€ä»¥é‡‡ç”¨è¿™ç§ç»“æ„æ˜¯ä¸ºäº†èƒ½è®© Suspense é€‚ç”¨ tree-shaking
export const SuspenseImpl = {
  __isSuspense: true,
  process(n1: VNode | null, n2: VNode /*...*/) {
    if (n1 == null) {
      // mount
    } else {
      // patch
    }
  },
  hydrate: hydrateSuspense,
  create: createSuspenseBoundary,
};

// 2. mountSuspense
// 3. patchSuspense
#+end_src

åˆ—è¡¨ï¼š

| åç§°                       | æè¿° |
|----------------------------+------|
| ~SuspenseImpl~             | -    |
| ~mountSuspense()~          | -    |
| ~patchSuspense()~          | -    |
| ~SuspenseBoundary~         | -    |
| ~createSuspenseBoundary()~ | -    |
| ~hydrateSuspense()~        | -    |

è„‘å›¾ï¼š

[[/img/vue3/runtime-core/vue-runtime-core-suspense.svg]]

#+begin_quote
é‡ç‚¹é€»è¾‘ï¼š
1. Suspense çš„æ¸²æŸ“è½¬æŠ˜ç‚¹å‘ç”Ÿåœ¨ ~mountComponent~ ä¸­ï¼Œå°† ~setupRenderEffect~ åšäº†
   ä¸€æ¬¡å°è£…ï¼Œè®©å…¶åœ¨ ~setup()~ è¿”å›çš„ Promise çŠ¶æ€å®Œæˆä¹‹åå»æ‰§è¡Œ
2. åœ¨æ•´ä¸ª Suspense mount æˆ– patch è¿‡ç¨‹ä¸­ï¼Œä½¿ç”¨äº† ~suspense.deps~ æ¥è®°å½•å¼‚æ­¥äº‹ä»¶ï¼Œ
   åªæœ‰å½“è¿™ä¸ªå€¼ä¸º ~0~ çš„æ—¶å€™è¯´æ˜å¯ä»¥è¿›è¡Œè§£æå¹¶æŒ‚åœ¨åˆ°çœŸå®DOMä¸Šäº†(æ¯”å¦‚. æœåŠ¡å™¨ç«¯æ•°
   æ®è¯·æ±‚å®Œæˆ)
#+end_quote

** SuspenseBoundary æ•°æ®ç»“æ„

åªåˆ—å‡ºéƒ¨åˆ†ä¸ Suspense å…³è”æ€§å¼ºçš„å­—æ®µï¼š

| åç§°            | æè¿°                                  |
|-----------------+---------------------------------------|
| vnode           | VNode ç»“æ„                            |
| hiddenContainer | -                                     |
| activeBranch    | è¯·æ±‚å®Œæˆä¹‹åæ˜¾ç¤ºçš„ç»„ä»¶åˆ†æ”¯ ~#default~ |
| pendingBranch   | è¯·æ±‚ä¸­æ˜¾ç¤ºçš„åˆ†æ”¯ ~#fallback~          |
| deps            | ç»„ä»¶ä¾èµ–                              |
| timeout         | è¶…æ—¶æ—¶é—´                              |
| isInFallback    | -                                     |
| isHydrating     | -                                     |
| effects         | [] ä¾èµ–åˆ—è¡¨                           |
| resolve(force)  | -                                     |
| fallback()      | å‚æ•°ï¼š fallbackVnode                  |
| move()          | -                                     |
| next()          | -                                     |
| registerDep()   | æ³¨å†Œå®ä¾‹ä¾èµ–                          |


#+begin_src typescript
export interface SuspenseBoundary {
  vnode: VNode<RendererNode, RendererElement, SuspenseProps>;
  parent: SuspenseBoundary | null;
  parentComponent: ComponentInternalInstance | null;
  isSVG: boolean;
  container: RendererElement;
  hiddenContainer: RendererElement;
  anchor: RendererNode | null;
  activeBranch: VNode | null;
  pendingBranch: VNode | null;
  deps: number;
  pendingId: number;
  timeout: number;
  isInFallback: boolean;
  isHydrating: boolean;
  isUnmounted: boolean;
  effects: Function[];
  resolve(force?: boolean): void;
  fallback(fallbackVNode: VNode): void;
  move(
    container: RendererElement,
    anchor: RendererNode | null,
    type: MoveType
  ): void;
  next(): RendererNode | null;
  registerDep(
    instance: ComponentInternalInstance,
    setupRenderEffect: SetupRenderEffectFn
  ): void;
  unmount(parentSuspense: SuspenseBoundary | null, doRemove?: boolean): void;
}
#+end_src

** mountSuspense()
:PROPERTIES:
:COLUMNS: %CUSTOM_ID[(Custom Id)]
:CUSTOM_ID: suspense-mount
:END:

[[https://github.com/gcclll/stb-vue-next/commit/802b9adfcebae8b9e0ba2f0ad7e9f995c3675920][feat(add): suspense mount Â· gcclll/stb-vue-next@802b9ad]]


#+begin_src typescript
function mountSuspense() {
  const {
    p: patch,
    o: { createElement },
  } = rendererInternals;
  const hiddenContainer = createElement("div");
  const suspense = (vnode.suspense = createSuspenseBoundary(
    vnode,
    parentSuspense,
    parentComponent,
    container,
    hiddenContainer,
    anchor,
    isSVG,
    optimized,
    rendererInternals
  ));

  // start mounting the content subtree in an off-dom container
  patch(
    null,
    (suspense.pendingBranch = vnode.ssContent!),
    hiddenContainer,
    null,
    parentComponent,
    suspense,
    isSVG
  );
  // now check if we have encountered any async deps
  if (suspense.deps > 0) {
    // has async
    // mount the fallback tree
    patch(
      null,
      vnode.ssFallback!,
      container,
      anchor,
      parentComponent,
      null, // fallback tree will not have suspense context
      isSVG
    );
    setActiveBranch(suspense, vnode.ssFallback!);
  } else {
    // Suspense has no async deps. Just resolve.
    suspense.resolve();
  }
}

// è®¾ç½®æ¿€æ´»çš„ branch
function setActiveBranch(suspense: SuspenseBoundary, branch: VNode) {
  suspense.activeBranch = branch;
  const { vnode, parentComponent } = suspense;
  const el = (vnode.el = branch.el);
  // in case suspense is the root node of a component,
  // recursively update the HOC el
  if (parentComponent && parentComponent.subTree === vnode) {
    parentComponent.vnode.el = el;
    updateHOCHostEl(parentComponent, el);
  }
}
#+end_src

1. åˆ›å»ºä¸€ä¸ª DOM ä¹‹åçš„ divï¼Œå³è¿˜æ²¡æ¸²æŸ“åˆ° DOM ç»“æ„ä¸­çš„
2. æ„å»º Suspense ç»„ä»¶ç»“æ„ï¼Œè¿™ä¸ªç»“æ„é VNode ï¼Œè€Œæ˜¯æŒ‚åœ¨ vnode.suspense ä¸Šçš„ä¸€ä¸ª
   ~SuspenseBoundary~ ç»“æ„
3. å¼€å§‹ mount å†…å®¹é‡Œçš„å­æ ‘
4. æ£€æµ‹ Suspense æœ‰æ²¡å¼‚æ­¥ä¾èµ–ï¼Œå¦‚æœæœ‰ï¼Œåˆ™éœ€è¦å…ˆè§£æè¿™äº›å¼‚æ­¥ä¾èµ–ï¼Œå®Œæˆä¹‹åå†æ¿€æ´» branch
5. æ²¡æœ‰å¼‚æ­¥ä¾èµ–ç›´æ¥æ‹¿åˆ°ç»“æœè§£æå‡ºç»„ä»¶


ä¹Ÿå°±æ˜¯è¯´è¿™é‡Œé¢éœ€è¦é‡ç‚¹å…³æ³¨çš„å…¶å®æ˜¯â€œæœ‰æ²¡å¼‚æ­¥ä¾èµ–çš„é—®é¢˜â€ã€‚

æ²¡æœ‰ä¾èµ–çš„æ—¶å€™ç”¨åˆ°äº† ~suspense.resolve()~ è¿™ä¸ªåº”è¯¥æ˜¯å°†åˆ›å»ºçš„ off-dom div æŒ‚åˆ°çœŸ
å® DOM ä¸Šå»ã€‚
** suspense.resolve()
:PROPERTIES:
:COLUMNS: %CUSTOM_ID[(Custom Id)]
:CUSTOM_ID: suspense-resolve
:END:

#+begin_src typescript
function resolve(resume = false) {
  const {
    vnode,
    activeBranch,
    pendingBranch,
    pendingId,
    effects,
    parentComponent,
    container,
  } = suspense;

  if (suspense.isHydrating) {
    suspense.isHydrating = false;
  } else if (!resume) {
    // 1. transition æ”¯æŒï¼Œå°† move() æ“ä½œæ³¨å†Œåˆ° afterLeave å›è°ƒ
    // 2. å¸è½½å½“å‰çš„ subTree å¯èƒ½æ˜¯ fallback
    // 3. ä¸æ˜¯ transition dely enter è¿›è¡Œ move()
    // è¿™é‡Œæœ€åæ‰§è¡Œçš„æ“ä½œå°±æ˜¯ move() å¦‚æœæ˜¯ transition delay enter
    // åˆ™å°† move() æ³¨å†Œåˆ° afterLeaveï¼Œå¦åˆ™ç›´æ¥æ‰§è¡Œ move() å°† suspense
    // å†…å®¹æ¸²æŸ“åˆ°çœŸå®DOMä¸Š
    const delayEnter =
      activeBranch &&
      pendingBranch!.transition &&
      pendingBranch!.transition.mode === "out-in";
    if (delayEnter) {
      activeBranch!.transition!.afterLeave = () => {
        if (pendingId === suspense.pendingId) {
          move(pendingBranch!, container, anchor, MoveType.ENTER);
        }
      };
    }
    // this is initial anchor on mount
    let { anchor } = suspense;
    // unmount current active tree
    if (activeBranch) {
      // if the fallback tree was mounted, it may have been moved
      // as part of a parent suspense. get the latest anchor for insertion
      anchor = next(activeBranch);
      unmount(activeBranch, parentComponent, suspense, true);
    }
    if (!delayEnter) {
      // move content from off-dom container to actual container
      move(pendingBranch!, container, anchor, MoveType.ENTER);
    }
  }

  // æ ‡è®°å½“å‰æ¿€æ´»çŠ¶æ€çš„åˆ†æ”¯ï¼Œæ­¤æ—¶æ˜¯ #default
  setActiveBranch(suspense, pendingBranch!);
  suspense.pendingBranch = null;
  suspense.isInFallback = false;

  // flush buffered effects
  // check if there is a pending parent suspense
  // æ³¨å†Œçš„ effect å¤„ç†ï¼Œè¿™é‡Œçš„å¤„ç†è¯´æ˜äº† suspense çš„çˆ¶å­ä¾èµ–æ‰§è¡Œ
  // çš„é¡ºåºé—®é¢˜ï¼Œ effects æ˜¯æŒ‰ç…§æ•°ç»„åŠ å…¥é¡ºåºæ‰§è¡Œçš„(è¯¦æƒ…å¯ä»¥æŸ¥çœ‹ reactivity æ–‡ç« )
  // æ‰€ä»¥ effects çš„ä¼˜å…ˆçº§æ˜¯è‡ªä¸Šè€Œä¸‹çš„ï¼Œå³ parent-parent > parent > children
  let parent = suspense.parent;
  let hasUnresolvedAncestor = false;
  while (parent) {
    if (parent.pendingBranch) {
      // found a pending parent suspense, merge buffered post jobs
      // into that parent
      parent.effects.push(...effects);
      hasUnresolvedAncestor = true;
      break;
    }
    parent = parent.parent;
  }
  // no pending parent suspense, flush all jobs
  // å¦‚æœæ²¡æœ‰æŒ‚èµ·çš„ parent suspense ç›´æ¥ flush æ‰æ‰€æœ‰ä»»åŠ¡
  // ç»“åˆä¸Šé¢çš„ while ä¸¾ä¾‹ï¼š
  // CompA -> CompB -> CompC
  // å½“è§£æåˆ° CompC æ—¶ï¼Œä¸€ç›´å¾€ä¸Šæ£€æµ‹ B å’Œ A å¦‚æœ B æœ‰æŒ‚èµ·çš„ä»»åŠ¡
  // C è¿™é‡Œçš„ä»»åŠ¡ä¸ä¼šè¢« flushï¼Œè€Œæ˜¯åŠ å…¥åˆ° B çš„é˜Ÿåˆ—ç­‰å¾…æ‰§è¡Œ
  // ç„¶å C è§£æå®Œæˆï¼Œå›æº¯åˆ° B çš„è§£æï¼Œæ­¤æ—¶åˆéµå¾ªåŒä¸€å¥—è§„åˆ™æ£€æµ‹ A çš„
  // æŒ‚èµ·ä»»åŠ¡ï¼Œç›´åˆ°æœ€åè¦ä¹ˆç«‹å³æ‰§è¡Œ B çš„ä»»åŠ¡è¦ä¹ˆ B çš„ä»»åŠ¡ä¹ŸåŠ å…¥åˆ° A
  // æœ€åç”± A æ‰§è¡Œæ‰€æœ‰çš„ä»»åŠ¡(åŒ…å«å­ suspense çš„)
  if (!hasUnresolvedAncestor) {
    queuePostFlushCb(effects);
  }
  suspense.effects = [];

  // invoke @resolve event
  const onResolve = vnode.props && vnode.props.onResolve;
  if (isFunction(onResolve)) {
    onResolve();
  }
}
#+end_src

åˆ†æå¦‚ä¸Šé¢çš„æ³¨é‡Šï¼Œ ~resolve()~ ä¸»è¦ç›®çš„å°±æ˜¯å°† off-dom div ä¸Šçš„ suspense ç»„ä»¶åœ¨å¼‚
æ­¥äº‹ä»¶å®Œæˆåæ ¹æ®ç»“æœè§£æå‡ºå¯¹åº”çš„åˆ†æ”¯ï¼Œå°†è¿™ä¸ªåˆ†æ”¯æŒ‚è½½åˆ°çœŸå®çš„ DOM ä¸Šå»ï¼ŒåŒæ—¶æ¿€æ´»
å®ƒ(æ˜¾ç¤ºå‡ºæ¥)ã€‚

å…¶ä»–å¤„ç†ï¼š

1. ~transition~ çš„å»¶è¿Ÿè¿›å…¥å¤„ç†ï¼Œé€šè¿‡å°† move() æ“ä½œæ³¨å†Œåˆ° ~afterLeave()~ å›è°ƒå®ç°
2. effects ä»»åŠ¡å¤„ç†ï¼Œè¿™é‡Œçš„ä»»åŠ¡å¤„ç†æœºåˆ¶æ˜¯ï¼š

   åªæœ‰åœ¨ parent æ²¡æœ‰ä»»ä½•æŒ‚èµ·çš„ä»»åŠ¡æ—¶å€™æ‰ä¼šç«‹å³å¾—åˆ°æ‰§è¡Œï¼Œå¦åˆ™åªä¼šè¿›è¡Œåˆå¹¶æ“ä½œã€‚


å› ä¸ºä»£ç æœ€åéœ€è¦æ‰§è¡Œ ~move()~ æ“ä½œå°† ~#default~ æ›¿æ¢ ~#fallback~ ï¼Œæ‰€ä»¥ä¸‹é¢å…ˆå®
ç° ~suspense.move()~ å†æ¥æµ‹è¯•ã€‚
** suspense.move()
:PROPERTIES:
:COLUMNS: %CUSTOM_ID[(Custom Id)]
:CUSTOM_ID: suspense-move
:END:

å®ç°è¿™ä¸ª move æœ‰å‡ ä¸ªåœ°æ–¹éœ€è¦ä¿®æ”¹

1. SuspenseBoundary ä¸­çš„ move()

   #+begin_src typescript
   var foo = {
     move(container, anchor, type) {
       suspense.activeBranch &&
         move(suspense.activeBranch, container, anchor, type);
       suspense.container = container;
     },
   };
   #+end_src

2. renderer.ts ä¸­çš„ move() å‡½æ•°ï¼Œå®ç° SUSPENSE ç»„ä»¶çš„å¤„ç†

   #+begin_src typescript
   const move = () => {
     // ...
     // SUSPENSE
     if (__FEATURE_SUSPENSE__ && shapeFlag & ShapeFlags.SUSPENSE) {
       console.log("move suspense");
       vnode.suspense!.move(container, anchor, moveType);
       return;
     }
     // ...
   };
   #+end_src

3. å¦å¤– mountComponent ä¸­æ¼äº†å¯¹ SUSPENSE çš„å¤„ç†

   #+begin_src typescript
    const mountComponent = () => {
      // ... create instance
      // ... setupComponent

      // setup() æ˜¯ä¸ªå¼‚æ­¥å‡½æ•°ï¼Œè¿”å›äº† promise ï¼Œåœ¨ setupComponent
      // ä¸­ä¼šå°† setup æ‰§è¡Œç»“æœèµ‹å€¼ç»™ instance.asyncDepï¼Œå³ SUSPENSE å¤„ç†
      if (__FEATURE_SUSPENSE__ && instance.asyncDep) {
        // å°† setupRenderEffect æ³¨å†Œåˆ° parent deps è¿™é‡Œçš„ deps
        // æ‰§è¡Œç”±ä¸€å®šçš„è§„åˆ™, å¦‚æœ parent suspense æ²¡æœ‰ç»“æŸï¼Œchild deps
        // ä¸ä¼šç«‹å³æ‰§è¡Œï¼Œè€Œæ˜¯å°†å®ƒä»¬åˆå¹¶åˆ° parent suspense deps ä¸­ç­‰å¾… parent çŠ¶æ€å®Œæˆäº†æ‰ä¼šæ‰§è¡Œï¼Œå¯¹äº
        // parent deps ä¹Ÿéµå¾ªè¿™ä¸ªè§„åˆ™ï¼Œç›´åˆ°æ²¡æœ‰æœªå®Œæˆçš„ parent suspenseä¸ºæ­¢
        parentSuspense && parentSuspense.registerDep(instance, setupRenderEffect);
        // è¿™é‡Œç­‰äºæ˜¯è¯´å…ˆç”¨ä¸€ä¸ªæ³¨é‡ŠèŠ‚ç‚¹å ä½ï¼Œç­‰å¼‚æ­¥å®Œæˆä¹‹åæ›¿æ¢
        if (!initialVNode.el) {
          const placeholder = (instance.subTree = createVNode(Comment));
          processCommentNode(null, placeholder, container!, anchor);
        }
        return;
      }

      // ... setupRenderEffect SUSPENSE ä¸ä¼šè¿›å…¥åˆ°è¿™é‡Œ
    };
   #+end_src


æµ‹è¯•ï¼š
#+begin_src js
const { log, f, shuffle, runtime_test, renderChildren } = require(process.env
  .BLOG_DIR_VUE + "/lib.js");
import(process.env.BLOG_DIR_VUE + "/runtime-test.global.js").then(
  async ({
    nextTick,
    h,
    render,
    nodeOps,
    serializeInner: inner,
    ref,
    Suspense,
  }) => {
    log.br()
    const deps = [];
    function defineAsyncComponent(comp, delay = 0) {
      return {
        setup(props, { slots }) {
          const p = new Promise((resolve) => {
            setTimeout(() => {
              resolve(() => h(comp, props, slots));
            }, delay);
          });
          deps.push(p.then(() => Promise.resolve()));
          return p;
        },
      };
    }

    const Async = defineAsyncComponent({
      render() {
        return h("div", "async");
      },
    });

    const Comp = {
      setup() {
        return () =>
          h(Suspense, null, {
            default: h(Async),
            fallback: h("div", "fallback"),
          });
      },
    };

    const root = nodeOps.createElement("div");
    try {
      render(h(Comp), root);
    } catch (e) {
      console.log(e);
    }
    console.log("before");
    console.log(inner(root));

    await Promise.all(deps);
    await nextTick();
    console.log("after");
    console.log(inner(root));
  },
  (err) => {
    console.log(err);
  }
);
#+end_src

#+RESULTS:
#+begin_example
undefined

component stateful ? 4
call setup
[Function (anonymous)] render
mount component
update effect
normalize vnode
patch component
component stateful ? 4
call setup
mount component
process element
mount elment
{ shapeFlag: 9 }
before
<div>fallback</div>
[Function (anonymous)] render
update effect
normalize vnode
patch component
component stateful ? 4
call setup
no setup
[Function: render] render
mount component
update effect
normalize vnode
patch component
process element
mount elment
{ shapeFlag: 9 }
moving...
move component
moving...
move component
moving...
move host insert
after
<div>async</div>
#+end_example

#+begin_quote
â“. ç»“æœå‘ç°å¹¶æ²¡å˜åŒ–ï¼Ÿï¼Ÿï¼Ÿ
#+begin_example
before
<!---->
after
<!---->
#+end_example

æ—¢æ²¡æœ‰æ¸²æŸ“ fallback ä¹Ÿæ²¡æœ‰æ¸²æŸ“ default çš„ï¼Œä¸ºä½•ï¼Ÿ
#+end_quote

ä¸Šé¢çš„ç¬¬äºŒç‚¹æœ‰è¯´åˆ°åœ¨ /renderer.ts/ çš„ ~mountComponent()~ ä¸­å¢åŠ äº†å¯¹ ~SUSPENSE~
çš„å¤„ç†ï¼Œè¿™é‡Œé¢æœ‰ä¸ªæ³¨å†Œä¾èµ–çš„åŠ¨ä½œï¼Œè¿™é‡Œæ³¨å†Œçš„æ˜¯ ~setupRenderEffect~ å‡½æ•°ï¼Œè¿™ä¸ªå‡½
æ•°æ­£æ˜¯ç”¨æ¥ mount & update ç»„ä»¶çš„ï¼Œè€Œåœ¨ /components/Suspense.ts/ ä¸­å¹¶æ²¡æœ‰å®ç°ï¼Œæ‰€
ä»¥é—®é¢˜å°±å‡ºåœ¨è¿™é‡Œäº†ï¼ï¼ï¼

FIXï¼š [[#suspense-register-dep][suspense.registerDep()]]

** suspense.registerDep()
:PROPERTIES:
:COLUMNS: %CUSTOM_ID[(Custom Id)]
:CUSTOM_ID: suspense-register-dep
:END:

[[https://github.com/gcclll/stb-vue-next/commit/e0fa81e82115f6a7e7f9b9f683061ef2c8886d0e][feat(add): suspense registerDeps Â· gcclll/stb-vue-next@e0fa81e]]

#+begin_src typescript
function registerDep(instance, setupRenderEffect) {
  const isInPendingSuspense = !!suspense.pendingBranch;
  if (isInPendingSuspense) {
    suspense.deps++;
  }
  const hydratedEl = instance.vnode.el;
  // æ•è· setup æ‰§è¡Œçš„å¼‚å¸¸ï¼Œæˆ–æ¥å—æ‰§è¡Œçš„ç»“æœ
  instance
    .asyncDep!.catch((err) => {
      handleError(err, instance, ErrorCodes.SETUP_FUNCTION);
    })
    .then((asyncSetupResult) => {
      // å½“ setup() çš„ promise çŠ¶æ€å˜æ›´ä¹‹åé‡è¯•
      // å› ä¸ºåœ¨è§£æä¹‹å‰ç»„ä»¶å¯èƒ½å·²ç»è¢«å¸è½½äº†
      if (
        instance.isUnmounted ||
        suspense.isUnmounted ||
        suspense.pendingId !== instance.suspenseId
      ) {
        return;
      }

      // ä»è¯¥ç»„ä»¶å¼€å§‹é‡è¯•ï¼ŒçŠ¶æ€æ ‡è®°ä¸ºå·²ç»å®Œæˆ
      instance.asyncResolved = true;
      const { vnode } = instance;
      handleSetupResult(instance, asyncSetupResult, false);
      if (hydratedEl) {
        // è™šæ‹ŸèŠ‚ç‚¹å¯èƒ½åœ¨ async dep çŠ¶æ€å®Œæˆä¹‹å‰è¢«æŸä¸ªæ›´æ–°æ›¿æ¢æ‰äº†
        vnode.el = hydratedEl;
      }
      const placeHolder = !hydratedEl && instance.subTree.el;
      setupRenderEffect(
        instance,
        vnode,
        // ç»„ä»¶å¯èƒ½åœ¨ resolve ä¹‹å‰è¢«ç§»é™¤äº†
        // å¦‚æœè¿™ä¸ªä¸æ˜¯ä¸€ä¸ª hydrationï¼Œinstance.subTree å°†ä¼šæ˜¯ä¸ªæ³¨é‡Š
        // å ä½èŠ‚ç‚¹
        parentNode(hydratedEl || instance.subTree.el!),
        hydratedEl ? null : next(instance.subTree),
        suspense,
        isSVG,
        optimized
      );
      if (placeHolder) {
        remove(placeHolder);
      }
      updateHOCHostEl(instance, vnode.el);
      // only decrease deps count if suspense is not already resolved
      // æ²¡æœ‰ä»»ä½•ä¾èµ–äº†å°±å¼€å§‹è§£æ Suspense
      if (isInPendingSuspense && --suspense.deps === 0) {
        suspense.resolve();
      }
    });
}
#+end_src

è¿™ä¸ªå‡½æ•°ä¸»è¦å®ç°ç‚¹ï¼š

1. æ¥å— ~setup()~ æ‰§è¡Œçš„ç»“æœ(~Promise~) asyncSetupResult å¹¶æ•è·å¼‚å¸¸ï¼Œå¯¹ç»“æœè¿›è¡Œ
   åˆ†æå¤„ç†
2. æ£€æµ‹ç»„ä»¶æ˜¯ä¸æ˜¯å·²ç»å¸è½½äº†ï¼Œæˆ–è€… suspense è¢«ç§»é™¤ï¼Œå°±ä¸éœ€è¦ç»§ç»­å¤„ç†äº†ï¼Œé€€å‡ºå³å¯

   #+begin_src typescript
    if (
      instance.isUnmounted ||
      suspense.isUnmounted ||
      suspense.pendingId !== instance.suspenseId
    ) {
      return;
    }
   #+end_src
3. ä½¿ç”¨ ~handleSetupResult(instance, asyncSetupResult, false)~ å¤„ç† setup æ‰§è¡Œç»“
   æœï¼Œåˆ°åº•æ˜¯ render è¿˜æ˜¯çŠ¶æ€ï¼Œéœ€è¦è§£æ
4. ç„¶åæ‰§è¡Œ setupRenderEffect æ‰§è¡Œç»„ä»¶çš„ mount æˆ– update æ“ä½œ
5. ç§»é™¤å ä½çš„æ³¨é‡ŠèŠ‚ç‚¹
6. suspense.deps æ‰§è¡Œå®Œæˆä¹‹åå°±å¯ä»¥å¼€å§‹è§£æ suspense ç»„ä»¶ è¿›è¡Œ move æ“ä½œäº†ã€‚
** patchSuspense()
** suspense.unmount&fallback&å…¶ä»–
:PROPERTIES:
:COLUMNS: %CUSTOM_ID[(Custom Id)]
:CUSTOM_ID: suspense-other
:END:

[[https://github.com/gcclll/stb-vue-next/commit/080898d17073b322a1d8c86fba2bf271bc25e82f][feat(add): suspense unmount & fallback... Â· gcclll/stb-vue-next@080898d]]

æ–°å¢ï¼š

1. ~patchSuspense()~ å’Œå…¶ä»–æ™®é€šç±»å‹çš„å¤„ç†å·®ä¸å¤šï¼Œæ— éå°±æ˜¯æ£€æµ‹ old å’Œ new branch çš„
   ç±»å‹ï¼Œè¿›è¡Œ patch()ï¼ŒæœŸé—´è§¦å‘ ~onPending~ äº‹ä»¶
2. ~suspense.fallback()~ å¤„ç†ï¼Œå½“å¼‚æ­¥äº‹ä»¶æœªå®Œæˆæ—¶æ˜¾ç¤ºçš„ ~#fallback~ åˆ†æ”¯å¤„ç†ï¼ŒæœŸé—´
   è§¦å‘ ~onFallback~ äº‹ä»¶
3. ~suspense.unmount()~ æ£€æµ‹ activeBranch å’Œ pendingBranch å…ˆå¸è½½ active éšåå¸è½½
   pending åˆ†æ”¯(å‰ææ˜¯å­˜åœ¨çš„æƒ…å†µä¸‹)
** Suspense ç»„ä»¶æµ‹è¯•

#+begin_src js
// `/js/vue/tests/Suspense.js'
require(process.env.BLOG_DIR_VUE + "/tests/Suspense.js");
#+end_src

** å°ç»“

SUSPENSE ç»„ä»¶çš„å¤§è‡´æ‰§è¡Œæµç¨‹

1. patch è¿›å…¥ switch default æ£€æµ‹åˆ° shapeFlag æ˜¯ SUSPENSE
2. è°ƒç”¨ type.process(n1,n2,...) å¤„ç† Suspense ç»„ä»¶ï¼Œæ ¹æ® n1 å†³å®šæ˜¯ mountSuspense
   è¿˜æ˜¯ patchSuspense è¿™é‡Œå’Œå…¶ä»–ç±»å‹ç»„ä»¶å¤„ç†é€»è¾‘ä¸€è‡´
3. é¦–æ¬¡(mount), è¿›è¡Œ mountSuspense åˆ›å»º Suspense ç»„ä»¶ï¼Œå¯¹ pendingBranch è¿›è¡Œ patch æ“ä½œ
   (æŒ‚åœ¨åˆ°ä¸€ä¸ªéDOMæ ‘ä¸­çš„ 'div' å…ƒç´ (/off-dom/)ï¼Œå¾…ç”¨)ï¼Œå³å¼‚æ­¥æ“ä½œè¿˜æœªå®Œæˆæ—¶æ˜¾ç¤º
   çš„åˆ†æ”¯ï¼Œå¦‚ï¼š ~#fallback~
4. éé¦–æ¬¡(update)ï¼Œè¿›è¡Œ patchSuspense å¯¹æ¯”æ–°æ—§çš„ branch è¿›è¡Œ patch


è¦ç‚¹ï¼šåœ¨ ~mountComponent()~ ä¸­ä¸æ˜¯ç›´æ¥è°ƒç”¨ ~setupRenderEffect()~ è€Œæ˜¯è°ƒ
ç”¨ ~suspense.registerDep()~ å»å¤„ç† ~setup~ æ‰§è¡Œçš„ç»“æœ(~instance.asyncDep~)ï¼Œå®ƒæ˜¯
ä¸ªPromise åœ¨å…¶åçš„ then() ä¸­æ¥å— setup æ‰§è¡Œç»“æœï¼Œç„¶åå¼€å§‹è°ƒç”¨ setupRenderEffect
mount æˆ– update å­æ ‘èŠ‚ç‚¹ï¼Œå¾… suspense ä¸Šçš„æ‰€æœ‰ä¾èµ–éƒ½å®Œæˆä¹‹åå¼€å§‹ resolve()
Suspense ç»„ä»¶å°†å…¶æŒ‚åœ¨åˆ°çœŸå®çš„ DOM ä¸­ã€‚

#+begin_quote
åŸç†ï¼š setup() è¿”å› Promiseï¼Œrender è¿‡ç¨‹ä¸­æ³¨å†Œæ¸²æŸ“å‡½æ•°ï¼Œå¾… promise çŠ¶æ€å®Œæˆè°ƒç”¨
then æ¥å—å¼‚æ­¥ç»“æœæ¥æ¸²æŸ“ Suspense ç»„ä»¶(ä»»åŠ¡ä¸º ~post~ ç±»å‹)ã€‚
#+end_quote
* KEEP_ALIVE
:PROPERTIES:
:COLUMNS: %CUSTOM_ID[(Custom Id)]
:CUSTOM_ID: keep-alive
:END:

[[https://github.com/gcclll/stb-vue-next/commit/a192cb42020ae44aa150e1dc9decc20bb6b01b96][feat(add): keep-alive render Â· gcclll/stb-vue-next@a192cb4]]

KeepAlive ç»„ä»¶çš„ render å…¥å£åœ¨ ~processComponent()~ ä¸­ï¼Œå½“ ~n1 == null~ æƒ…å†µä¸‹ï¼Œ
ä¼šå»æ£€æµ‹è¯¥ç»„ä»¶æ˜¯ä¸æ˜¯ ~keep-alive~ ç±»å‹ï¼Œå¦‚æœæ˜¯ç›´æ¥è°ƒç”¨ ~activate()~ æ¿€æ´»ã€‚

#+begin_src diff
// 17. processComponent
  const processComponent = (
  /*...*/) => {
    if (n1 == null) {
      // mount
-      if (false /* keep alive */) {
-        // TODO
+      if (n2.shapeFlag & ShapeFlags.COMPONENT_KEPT_ALIVE) {
+        ;(parentComponent!.ctx as KeepAliveContext).activate(
+          n2,
+          container,
+          anchor,
+          isSVG,
+          optimized
+        )
#+end_src

unmount æ“ä½œæ—¶ï¼Œå¦‚æœæ˜¯ keep-alive ç›´æ¥è°ƒç”¨ ~deactivate()~ å¤±æ•ˆï¼Œè€Œä¸æ˜¯çœŸæ­£çš„ä»
DOM ç§»é™¤ã€‚

[[https://github.com/gcclll/stb-vue-next/commit/024b24b9812f70d962cd2056a9164d6504d1ddd7][feat(add): keep-alive render unmount Â· gcclll/stb-vue-next@024b24b]]

#+begin_src diff
const unmount: UnmountFn = (...) => {
// ...
-    // TODO keep-alive
-    // keep-alive
+    if (shapeFlag & ShapeFlags.COMPONENT_SHOULD_KEEP_ALIVE) {
+      ;(parentComponent!.ctx as KeepAliveContext).deactivate(vnode)
+      return
+    }
// ...
}
#+end_src

åœ¨ ~mountComponent()~ ä¸­ï¼š

#+begin_src diff
  // 18. mountComponent
  const mountComponent: MountComponentFn = (...) => {
    const instance: ComponentInternalInstance = (initialVNode.component = createComponentInstance(
      initialVNode,
      parentComponent,
      parentSuspense
    ))

+    if (isKeepAlive(initialVNode)) {
+      ;(instance.ctx as KeepAliveContext).renderer = internals
+    }
#+end_src

è¿™é‡Œå°† keep-alive ç»„ä»¶çš„ setup() å‡½æ•°ä¸­ç”¨åˆ°çš„ä¸€äº› renderer å‡½æ•°ä¿å­˜å¼•ç”¨åˆ°
ctx.renderer ä¸Šä¾›åé¢ ~setup()~ ä¸­ä½¿ç”¨ã€‚

#+begin_src
instance.ctx.renderer: {
    p: patch,
    m: move,
    um: _unmount,
    o: { createElement }
}
#+end_src

keep-alive ä½œä¸ºå†…éƒ¨ç»„ä»¶ï¼Œå†…ç½®äº† ~setup()~ å‡½æ•°çš„å®ç°ï¼Œæ‰€ä»¥åœ¨

patch -> processComponent -> mountComponent -> setupComponent

æ—¶è°ƒç”¨çš„å°±æ˜¯è¿™ä¸ªå†…ç½®çš„ setup() å‡½æ•°ã€‚

setup() å‡½æ•°ä½“å¤§è‡´ä»£ç ï¼š
#+begin_src typescript
function setup(props: KeepAliveProps, { slots }: SetupContext) {
  const cache: Cache = new Map();
  const keys: Keys = new Set();
  let current: VNode | null = null;

  const instance = getCurrentInstance()!;
  const parentSuspense = instance.suspense;

  const sharedContext = instance.ctx as KeepAliveContext;
  const {
    renderer: {
      p: patch,
      m: move,
      um: _unmount,
      o: { createElement },
    },
  } = sharedContext;
  const storageContainer = createElement("div");

  sharedContext.activate = (vnode, container, anchor, isSVG, optimized) => {};

  sharedContext.deactivate = (vnode: VNode) => {};

  // å¯¹ renderer unmount çš„ä¸€æ¬¡å°è£…
  function unmount(vnode: VNode) {}

  // è¿‡æ»¤æ‰ç¼“å­˜
  function pruneCache(filter?: (name: string) => boolean) {}

  function pruneCacheEntry(key: CacheKey) {}

  // TODO ç›‘å¬ include/exclude å±æ€§å˜åŒ–
  // TODO åœ¨ render ä¹‹åç¼“å­˜å­æ ‘(subTree)
  // TODO æ³¨å†Œç”Ÿå‘½å‘¨æœŸ

  return () => {
    // è¯¥å‡½æ•°è§£æå‡ºåŸå§‹ VNode èŠ‚ç‚¹è¿”å›
  };
}
#+end_src

ä¸Šé¢ä»£ç æä¾›äº†ä¸€ä¸‹ä¿¡æ¯ï¼š
1. ~activate~ & ~deactivate()~ å‡½æ•°æ˜¯æŒ‚åœ¨ VNode çš„ ctx ä¸Šçš„ï¼Œå¹¶ä¸”æ˜¯åœ¨ setup() è°ƒ
   ç”¨æœŸé—´äº§ç”Ÿ
2. ç¼“å­˜æœºåˆ¶
3. åªæ³¨å†Œäº† ~mounted, unmounted, update~ å£°æ˜å‘¨æœŸ
4. æœ€åè¿”å›çš„å‡½æ•°å¯ä»¥å¾—åˆ°æœ€åŸå§‹çš„ VNode èŠ‚ç‚¹


æ³¨æ„çœ‹ ~processComponent()~ ä¸­çš„åˆ¤æ–­:

~if (n2.shapeFlag & ShapeFlags.COMPONENT_KEPT_ALIVE) { activate() }~

è€Œ ~COMPONENT_KEPT_ALIVE~ æ ‡è®°çš„èµ‹å€¼åˆæ˜¯å‘ç”Ÿåœ¨ ~setup()~ å‡½æ•°ä¸­ï¼Œä¹Ÿå°±æ˜¯è¯´å¯¹äº
~keep-alive~ ç»„ä»¶é¦–æ¬¡åŠ è½½ä¸ä¼šè¿›å…¥åˆ° activate() è€Œæ˜¯ç›´æ¥æŒ‰ç…§æ™®é€šç»„ä»¶å¤„ç†è°ƒç”¨
~mountComponent()~ å»è°ƒç”¨ ~setup()~ åˆå§‹åŒ–è¯¥ ~keep-alive~ ç»„ä»¶çš„ä¸€äº›å‡½æ•°ç­‰(å…¶ä¸­
å°±åŒ…å« ~activate~ å’Œ ~deactivate()~ å‡½æ•°)

å½“çŠ¶æ€å‘ç”Ÿå˜åŒ–æ—¶æ ¹æ®ç‰¹å®šæ¡ä»¶æœ€åæ‰§è¡Œæ¿€æ´»æ‰ä¼šå»è°ƒç”¨ ~activate()~ è€Œä¸æ˜¯è¿›å…¥ ~mountComponent()~

[[/img/vue3/runtime-core/vue-runtime-core-keep-alive.svg]]

** activate()
:PROPERTIES:
:COLUMNS: %CUSTOM_ID[(Custom Id)]
:CUSTOM_ID: keep-alive-activate
:END:

[[https://github.com/gcclll/stb-vue-next/commit/267fdbdddbcafe62ac93c476bd75d22bbf3d9552][feat(add): keep-alive ctx.activate Â· gcclll/stb-vue-next@267fdbd]]

#+begin_src typescript
sharedContext.activate = (vnode, container, anchor, isSVG, optimized) => {
  const instance = vnode.component!;
  move(vnode, container, anchor, MoveType.ENTER, parentSuspense);
  // props å¯èƒ½å‘ç”Ÿå˜åŒ–ï¼Œè¿™é‡Œæ‰§è¡Œä¸€æ¬¡ patch æ“ä½œ
  patch(
    instance.vnode,
    vnode,
    container,
    anchor,
    instance,
    parentSuspense,
    isSVG,
    optimized
  );
  queuePostRenderEffect(() => {
    instance.isDeactivated = false;
    if (instance.a) {
      // activated å‘¨æœŸå‡½æ•°
      invokeArrayFns(instance.a);
    }
    const vnodeHook = vnode.props && vnode.props.onVnodeMounted;
    if (vnodeHook) {
      invokeVNodeHook(vnodeHook, instance.parent, vnode);
    }
  }, parentSuspense);
};
#+end_src

æ¿€æ´» ~keep-alive~ ç»„ä»¶çš„å‡½æ•°ï¼Œåªæœ‰å½“éé¦–æ¬¡çš„æ—¶å€™ï¼ŒçŠ¶æ€å‘ç”Ÿå˜æ›´æ—¶ä¼šè¢«è°ƒç”¨ï¼Œæ³¨æ„ä¸Š
é¢çš„ä»»åŠ¡ç±»å‹ ~post~ ï¼Œå‘¨æœŸå‡½æ•°çš„è°ƒç”¨æ˜¯å¼‚æ­¥å‘ç”Ÿçš„ï¼Œä¼šåœ¨ä¸‹ä¸€ä¸ª tick ä¸­èµ‹å€¼ã€‚
** deactivate()
:PROPERTIES:
:COLUMNS: %CUSTOM_ID[(Custom Id)]
:CUSTOM_ID: keep-alive-deactivate
:END:

[[https://github.com/gcclll/stb-vue-next/commit/b340d57b5f1888ff1a0c6aae84d946a2f867f8b2][feat(add): keep-alive ctx.deactivate Â· gcclll/stb-vue-next@b340d57]]

#+begin_src typescript
sharedContext.deactivate = (vnode: VNode) => {
  const instance = vnode.component!;
  move(vnode, storageContainer, null, MoveType.LEAVE, parentSuspense);
  queuePostRenderEffect(() => {
    if (instance.da) {
      invokeArrayFns(instance.da);
    }
    const vnodeHook = vnode.props && vnode.props.onVnodeUnmounted;
    if (vnodeHook) {
      invokeVNodeHook(vnodeHook, instance.parent, vnode);
    }
    instance.isDeactivated = true;
  }, parentSuspense);
};
#+end_src

å¦‚æœçœ‹è¿™é‡Œå¤±æ´»çŠ¶æ€ä¸‹ç»„ä»¶æ˜¯å¦‚ä½•è¿›è¡Œæ›´æ–°çš„ï¼Ÿ

~storageContainer~ æ˜¯åœ¨ setup ä¸­åˆ›å»ºçš„ä¸€ä¸ªç©ºçš„ off-dom div å…ƒç´ ï¼Œè¿™é‡Œç­‰äºæ˜¯å½“ç»„
ä»¶å¤±æ´»æ—¶ä¼šå°† keep-alive å…ˆæŒ‚è½½åˆ°è¿™ä¸ª off-dom div ä¸Šå».
** unmount()
:PROPERTIES:
:COLUMNS: %CUSTOM_ID[(Custom Id)]
:CUSTOM_ID: keep-alive-unmount
:END:

[[https://github.com/gcclll/stb-vue-next/commit/4ce0b9b43af304af28db7eae5d40211d3280459f][feat(add): keep-alive unmount Â· gcclll/stb-vue-next@4ce0b9b]]

#+begin_src typescript
// å¯¹ renderer unmount çš„ä¸€æ¬¡å°è£…
function unmount(vnode: VNode) {
  resetShapeFlag(vnode);
  _unmount(vnode, instance, parentSuspense);
}

function resetShapeFlag(vnode: VNode) {
  let shapeFlag = vnode.shapeFlag;
  if (shapeFlag & ShapeFlags.COMPONENT_SHOULD_KEEP_ALIVE) {
    shapeFlag -= ShapeFlags.COMPONENT_SHOULD_KEEP_ALIVE;
  }
  if (shapeFlag & ShapeFlags.COMPONENT_KEPT_ALIVE) {
    shapeFlag -= ShapeFlags.COMPONENT_KEPT_ALIVE;
  }
  vnode.shapeFlag = shapeFlag;
}
#+end_src
** include & exclude props
:PROPERTIES:
:COLUMNS: %CUSTOM_ID[(Custom Id)]
:CUSTOM_ID: keep-alive-include-exclude
:END:

[[https://github.com/gcclll/stb-vue-next/commit/fdcc3060f9469256055d8dec39b6f46b3e6faa28][feat(add): keep-alive include & exclude props Â· gcclll/stb-vue-next@fdcc306]]

ä¸»è¦å¢åŠ ä¸¤ä¸ªå‡½æ•°å®ç°ï¼Œä¸€ä¸ªç›‘å¬åŠ¨ä½œ(~watch([include, exclude],...)~):

#+begin_src typescript
// è¿‡æ»¤æ‰ç¼“å­˜
function pruneCache(filter?: (name: string) => boolean) {
  cache.forEach((vnode, key) => {
    const name = getComponentName(vnode.type as ConcreteComponent);
    if (name && (!filter || !filter(name))) {
      pruneCacheEntry(key);
    }
  });
}

function pruneCacheEntry(key: CacheKey) {
  const cached = cache.get(key) as VNode;
  if (!current || cached.type !== current.type) {
    // æ–°å¢æˆ–èŠ‚ç‚¹ç±»å‹å‘ç”Ÿå˜åŒ–ï¼Œç›´æ¥å¸è½½æ‰è€çš„
    unmount(cached);
  } else if (current) {
    // é‡ç½®æ ‡è®°å°±å¯ä»¥äº†ï¼Ÿ
    // å½“å‰æ¿€æ´»çš„å®ä¾‹ä¸è¯¥å†æ˜¯ kept-alive
    // æˆ‘ä»¬ä¸èƒ½ç«‹å³å¸è½½ä½†æ˜¯ç¨åä¼šè¿›è¡Œå¸è½½ï¼Œæ‰€ä»¥è¿™é‡Œå…ˆé‡ç½®å…¶æ ‡è®°
    // ä¸èƒ½ç«‹å³å¸è½½ï¼Ÿ
    // æ˜¯å› ä¸ºåœ¨ activate å’Œ deactivate ä¸­çš„å‘¨æœŸå‡½æ•°è°ƒç”¨
    // æ˜¯é‡‡ç”¨çš„ post ç±»å‹å¼‚æ­¥æ‰§è¡Œçš„ç¼˜æ•…å—ï¼Ÿ
    resetShapeFlag(current);
  }
  cache.delete(key);
  keys.delete(key);
}

// ç›‘å¬ include/exclude å±æ€§å˜åŒ–
watch(
  () => [props.include, props.exclude],
  ([include, exclude]) => {
    // æ”¯æŒä¸‰ç§ç±»å‹
    // 1. å­—ç¬¦ä¸², 'a,b,c'
    // 2. æ­£åˆ™è¡¨è¾¾å¼ï¼Œ /a|b|c/
    // 3. æ•°ç»„ï¼Œ ['a', 'b', 'c', /d|e/]
    include && pruneCache((name) => matches(include, name));
    exclude && pruneCache((name) => !matches(exclude, name));
  },
  { flush: "post", deep: true }
);
#+end_src

*include* æŒ‡å®šéœ€è¦ç¼“å­˜çš„ç»„ä»¶åç§°

*exclude* æŒ‡å®šä¸éœ€è¦è¿›è¡Œç¼“å­˜çš„ç»„ä»¶åç§°

ç±»å‹ï¼š ~String, RegExp, Array~
** cache subtree
:PROPERTIES:
:COLUMNS: %CUSTOM_ID[(Custom Id)]
:CUSTOM_ID: keep-alive-cache-subtree
:END:

[[https://github.com/gcclll/stb-vue-next/commit/efb757777be9f6c51a2fb1be56a33ee86fc42e43][feat(add): keep-alive cache subtree Â· gcclll/stb-vue-next@efb7577]]

å¯¹  ~<keep-alive/>~ çš„å­©å­èŠ‚ç‚¹ğŸŒ²è¿›è¡Œç¼“å­˜ã€‚

#+begin_src typescript
// åœ¨ render ä¹‹åç¼“å­˜å­æ ‘(subTree)
let pendingCacheKey: CacheKey | null = null;
const cacheSubtree = () => {
  if (pendingCacheKey != null) {
    cache.set(pendingCacheKey, getInnerChild(instance.subTree));
  }
};
// æ³¨å†Œç”Ÿå‘½å‘¨æœŸ
onMounted(cacheSubtree);
onUpdated(cacheSubtree);

onBeforeUnmount(() => {
  cache.forEach((cached) => {
    const { subTree, suspense } = instance;
    const vnode = getInnerChild(subTree);
    if (cached.type === vnode.type) {
      // æœ‰ç¼“å­˜çš„èŠ‚ç‚¹
      // å½“å‰å®ä¾‹ä¼šæˆä¸º keep-alive çš„ unmount ä¸€éƒ¨åˆ†
      resetShapeFlag(vnode);
      // ä½†æ˜¯åœ¨è¿™é‡Œæ‰§è¡Œå®ƒçš„ deactivated é’©å­å‡½æ•°
      const da = vnode.component!.da;
      da && queuePostRenderEffect(da, suspense);
      return;
    }
    // æ²¡æœ‰ç¼“å­˜çš„ç›´æ¥ unmount
    unmount(cached);
  });
});
#+end_src

åœ¨ ~<keep-alive/>~ å¸è½½ä¹‹å‰å°†å·²ç»ç¼“å­˜ ~deactivated~ é’©å­å‡½æ•°æ¨å…¥é˜Ÿåˆ—ç­‰å¾…æ‰§è¡Œï¼Œæ²¡
æœ‰ç¼“å­˜çš„ç›´æ¥è°ƒç”¨ ~unmount()~ å¸è½½æ‰ã€‚

** setup() -> render å‡½æ•°
:PROPERTIES:
:COLUMNS: %CUSTOM_ID[(Custom Id)]
:CUSTOM_ID: keep-alive-setup-render
:END:

[[https://github.com/gcclll/stb-vue-next/commit/9b75803d90f6e285c063fbbf41042dc381de3cfe][feat(add): keep-alive return render function Â· gcclll/stb-vue-next@9b75803]]

åœ¨ ~setupComponent()~ ä¸­ï¼Œæœ€åè°ƒç”¨ setup() å¾—åˆ° setupResult ï¼Œæœ€åä¼šå°†è¿™ä¸ª
setupResult ä¼ é€’ç»™ handleSetupResult() å»å¤„ç†ï¼Œè¿”å›ç»“æœï¼Œè¿™é‡Œé¢å½“æ£€æµ‹åˆ°
setupResult æ˜¯ä¸ªå‡½æ•°çš„æ—¶å€™ï¼Œé‚£ä¹ˆè¿™ä¸ªå‡½æ•°ä¼šè¢«å½“åšæ˜¯ ~instance.render~ å‡½æ•°å¤„ç†ã€‚

å³ï¼Œè¿™é‡Œçš„ setupResult æ˜¯ ~<keep-alive/>~ ç»„ä»¶ children çš„ render å‡½æ•°ã€‚

#+begin_src typescript
function setup() {
  // ...
  return () => {
    // è¯¥å‡½æ•°è§£æå‡ºåŸå§‹ VNode èŠ‚ç‚¹è¿”å›
    // æ ¹æ®ç»„ä»¶çš„æ‰§è¡Œæµç¨‹ï¼Œè¿™ä¸ªå‡½æ•°å°†ä¼šåœ¨ setupComponent() ä¸­
    // æ‰§è¡Œ setup() å¾—åˆ° setupResult ï¼Œä¼ é€’ç»™ handleSetupResult()
    // å‡½æ•°ï¼Œè¿™é‡Œé¢æ£€æµ‹ setupResult ä¹Ÿå°±æ˜¯è¿™ä¸ªåŒ¿åå‡½æ•°ï¼Œå¦‚æœå®ƒæ˜¯å‡½æ•°
    // ä¼šç›´æ¥è¢«å½“åš render å‡½æ•°å¤„ç†(instance.render æˆ– instance.ssrRender)
    // ç»“è®ºå°±æ˜¯ï¼Œè¿™ä¸ªåŒ¿åå‡½æ•°æ˜¯ render() å‡½æ•°

    pendingCacheKey = null;
    if (!slots.default) {
      // ç»„ä»¶æ”¯æŒé»˜è®¤æ’æ§½ä½¿ç”¨æ–¹å¼
      return null;
    }

    const children = slots.default();
    const rawVNode = children[0];
    if (children.length > 1) {
      // KeepAlive ç»„ä»¶åªèƒ½åŒ…å«ä¸€ä¸ªç»„ä»¶ä½œä¸º child
      // ä¹Ÿå°±æ˜¯è¯´ ~<keep-alive><CompA/><CompB/></keep-alive/>~
      // æ˜¯ä¸åˆæ³•çš„ä½¿ç”¨
      current = null;
      // warn...
      return children;
    } else if (
      !isVNode(rawVNode) ||
      (!(rawVNode.shapeFlag & ShapeFlags.STATEFUL_COMPONENT) &&
        !(rawVNode.shapeFlag & ShapeFlags.SUSPENSE))
    ) {
      // 1. é VNode ç±»å‹èŠ‚ç‚¹
      // 2. æ—¢ä¸æ˜¯æœ‰çŠ¶æ€ç»„ä»¶(å¯¹è±¡ç±»å‹ç»„ä»¶)ä¹Ÿä¸æ˜¯ Suspense çš„æ—¶å€™
      // ç›¸åæ„å‘³ç€ï¼ŒèŠ‚ç‚¹å¿…é¡»æ»¡è¶³ä¸‹é¢å‡ ç§æƒ…å†µ
      // 1. æ˜¯ VNode ç±»å‹ä¸”æ˜¯æœ‰çŠ¶æ€ç»„ä»¶(éå‡½æ•°å¼ç»„ä»¶)
      // 2. æˆ–è€…æ˜¯ VNode ç±»å‹ä¸”æ˜¯Suspense ç»„ä»¶
      current = null;
      return rawVNode;
    }

    // ä¹Ÿå°±æ˜¯è¯´ keep-alive åªæ¥å—æœ‰çŠ¶æ€ç»„ä»¶æˆ–è€… Suspense ä½œä¸ºå”¯ä¸€çš„ child
    let vnode = getInnerChild(rawVNode);
    const comp = vnode.type as ConcreteComponent;
    const name = getComponentName(comp);
    const { include, exclude, max } = props;

    if (
      // æ— ç¼“å­˜çš„èŠ‚ç‚¹
      (include && (!name || !matches(include, name))) ||
      // åœ¨ä¸ç¼“å­˜çš„èŠ‚ç‚¹ä»¬ä¹‹åˆ—
      (exclude && name && matches(exclude, name))
    ) {
      current = vnode;
      return rawVNode;
    }

    const key = vnode.key == null ? comp : vnode.key;
    const cachedVNode = cache.get(key);

    // å…‹éš†ä¸€ä»½å¦‚æœå®ƒæœ‰è¢«å¤ç”¨çš„è¯ï¼Œå› ä¸ºæˆ‘ä»¬å³å°†ä¿®æ”¹å®ƒ
    if (vnode.el) {
      vnode = cloneVNode(vnode);
      if (rawVNode.shapeFlag & ShapeFlags.SUSPENSE) {
        rawVNode.ssContent = vnode;
      }
    }

    pendingCacheKey = key;

    if (cachedVNode) {
      vnode.el = cachedVNode.el;
      vnode.component = cachedVNode.component;
      if (vnode.transition) {
        // åœ¨ subTree ä¸Šé€’å½’æ›´æ–° transition é’©å­å‡½æ•°
        setTransitionHooks(vnode, vnode.transition!);
      }

      // é¿å… vnode æ­£åœ¨é¦–æ¬¡ mount
      vnode.shapeFlag |= ShapeFlags.COMPONENT_KEPT_ALIVE;
      // æ ‡è®° key ä¸ºæœ€æ–°çš„
      keys.delete(key);
      keys.add(key);
    } else {
      // æ²¡æœ‰ç¼“å­˜çš„æƒ…å†µ
      keys.add(key);
      // åˆ é™¤æœ€è€çš„ entryï¼Œç¼“å†²æ± å·²ç»æ»¡äº†ï¼Œåˆ é™¤æ‰æœ€è€çš„é‚£ä¸ª
      if (max && keys.size > parseInt(max as string, 10)) {
        // å› ä¸º Set æ²¡æœ‰ç›´æ¥å–æŒ‡å®šä½ç½®å…ƒç´ çš„å€¼
        // è¿™é‡Œçš„ç›®çš„æ˜¯å˜ç›¸çš„å– Set ä¸­ç¬¬ä¸€ä¸ªå…ƒç´ ï¼Œå³æœ€æ—© add çš„é‚£ä¸ª key
        // å¦‚ï¼š new Set([1,2,3,4]) => keys.values() => <1,2,3,4>
        // next() å¾—åˆ°è¿­ä»£å™¨ä¸‹ä¸€ä¸ªå€¼ { value: 1, done: false }
        // .value å¾—åˆ°ç¬¬ä¸€ä¸ªé›†åˆå…ƒç´ çš„å€¼
        pruneCacheEntry(keys.values().next().value);
      }
    }

    // é¿å… vnode æ­£åœ¨è¢«å¸è½½ï¼Œåœ¨renderer unmount ä¸­ä¼šæ£€æµ‹
    vnode.shapeFlag |= ShapeFlags.COMPONENT_SHOULD_KEEP_ALIVE;

    current = vnode;

    return rawVNode;
  };
}
#+end_src

æœ€åè¿”å›çš„æ˜¯ ~children[0]~ èŠ‚ç‚¹ã€‚

é‡Œé¢æœ‰ä¸ªç½®ä½æ ‡è¯†å€¼å¾—æ³¨æ„ï¼š ~ShapeFlags.COMPONENT_SHOULD_KEEP_ALIVE~

è¿™ä¸ªä½œç”¨æ˜¯å•¥ï¼Ÿ

1. ~unmount()~ ä¸­è°ƒç”¨ deactivate() çš„æ¡ä»¶

   #+begin_src typescript
   // keep-alive
   if (shapeFlag & ShapeFlags.COMPONENT_SHOULD_KEEP_ALIVE) {
     (parentComponent!.ctx as KeepAliveContext).deactivate(vnode);
     return;
   }
   #+end_src
2. ~instance.update~ çš„ effect ä¸­è§¦å‘ ~activated~ å‘¨æœŸå‡½æ•°çš„æ¡ä»¶

   #+begin_src typescript
   // activated hook for keep-alive roots.
   // #1742 activated hook must be accessed after first render
   // since the hook may be injected by a child keep-alive
   const { a } = instance;
   if (a && initialVNode.shapeFlag & ShapeFlags.COMPONENT_SHOULD_KEEP_ALIVE) {
     queuePostRenderEffect(a, parentSuspense);
   }
   #+end_src
** æµ‹è¯•
:PROPERTIES:
:COLUMNS: %CUSTOM_ID[(Custom Id)]
:CUSTOM_ID: keep-alive-tests
:END:

#+begin_src js
// `/js/vue/tests/Suspense.js'
require(process.env.BLOG_DIR_VUE + "/tests/KeepAlive.js");
#+end_src

#+RESULTS:
: undefined
:
: Cannot read property '_vnode' of undefined

#+begin_quote
âš  æœ‰é”™è¯¯ï¼Œå¾…å®Œæˆã€‚ã€‚ã€‚vue-next æµ‹è¯•è§æœ€åä¸€ç« èŠ‚[[#testing][ã€Šæµ‹è¯•ã€‹]]
#+end_quote
* set ref
:PROPERTIES:
:COLUMNS: %CUSTOM_ID[(Custom Id)]
:CUSTOM_ID: ref
:END:

å®˜æ–¹ä½¿ç”¨æ–‡æ¡£: [[https://v3.vuejs.org/api/special-attributes.html#ref][Special Attributes | Vue.js]]

å®˜æ–¹ç¤ºä¾‹ï¼š

#+begin_src html
<!-- vm.$refs.p will be the DOM node -->
<p ref="p">hello</p>

<!-- vm.$refs.child will be the child component instance -->
<child-component ref="child"></child-component>

<!-- When bound dynamically, we can define ref as a callback function, passing the element or component instance explicitly -->
<child-component :ref="(el) => child = el"></child-component>
#+end_src

patch() å‡½æ•°ä¸­å¯¹ ref å±æ€§çš„å¤„ç†(set ref)ï¼š

[[https://github.com/gcclll/stb-vue-next/commit/a0a1344a13ebf9d403aaefe845bd573ef3a8eda8][feat(add): set ref Â· gcclll/stb-vue-next@a0a1344]]

æºç å®ç°ä¸»è¦æœ‰å‡ ä¸ªæ­¥éª¤ï¼š
1. ref æ”¯æŒæ•°æ®?
2. æ˜¯ä¸æ˜¯å¼‚æ­¥ç»„ä»¶ value = null
3. æœ‰çŠ¶æ€ç»„ä»¶(~STATEFULL_COMPONENT~, åˆ†å‡½æ•°ç»„ä»¶)

   ~value = vnode.component!.exposed || vnode.component!.proxy~
4. å…¶ä»–æƒ…å†µä¸‹ value = vnode.el

   å³ 2,3,4 éƒ½æ˜¯ä¸ºäº†è®¾ç½® value æŒ‡å‘å“ªä¸ªå¼•ç”¨ï¼Œæ¯”å¦‚ vnode.el åœ¨æ¸²æŸ“ä¹‹åä¼šè¢«èµ‹å€¼ä¸ºå½“
   å‰ vnode å¯¹åº”çš„é‚£ä¸ª DOM å…ƒç´ ã€‚
5. æ–­å¼€ oldRef å¼•ç”¨
6. è®¾ç½® refï¼Œåˆ†ä¸‰ç§æƒ…å†µ

   - ref æ˜¯å­—ç¬¦ä¸²ç›´æ¥ ~refs[ref] = value~ å– key è®¾å€¼

   - ref æ˜¯ Ref ç±»å‹ï¼Œ ~ref.value = value~

   - ref æ˜¯å‡½æ•°ç±»å‹ï¼Œ ~ref(value, refs)~ è°ƒç”¨


    åœ¨è®¾å€¼çš„æ—¶å€™ä¼šæ ¹æ® value æ˜¯å¦ä¸ºç©ºå€¼æ¥æ§åˆ¶æ˜¯å¦è¿›è¡Œå¼‚æ­¥è®¾ç½®ï¼Œç­‰ Render æ‰§è¡Œå®Œ
    æˆä¹‹åå†è®¾ç½®

    #+begin_src typescript
    if (value) {
      (doSet as SchedulerCb).id = -1;
      queuePostRenderEffect(doSet, parentSuspense);
    } else {
      doSet();
    }
    #+end_src


æºç :
#+begin_src typescript
const patch: PatchFn = (/*...*/) => {
  // ...
  // set ref
  setRef(ref, n1 && n1.ref, parentSuspense, n2);
};

export const setRef = (
  rawRef: VNodeNormalizedRef,
  oldRawRef: VNodeNormalizedRef | null,
  parentSuspense: SuspenseBoundary | null,
  vnode: VNode | null
) => {
  if (isArray(rawRef)) {
    rawRef.forEach((r, i) =>
      setRef(
        r,
        oldRawRef && (isArray(oldRawRef) ? oldRawRef[i] : oldRawRef),
        parentSuspense,
        vnode
      )
    );
    return;
  }

  let value:
    | ComponentPublicInstance
    | RendererNode
    | Record<string, any>
    | null;
  // async ç»„ä»¶ï¼Œå¯ä»¥é€šè¿‡ defineAsyncComponent å£°æ˜çš„ç»„ä»¶
  // loader ä¼šèµ‹ç»™ __asyncLoaderï¼Œå¦‚æœæ˜¯å¼‚æ­¥ç»„ä»¶éœ€è¦ç­‰ç»„ä»¶æ¸²æŸ“å®Œæˆä¹‹å
  // å†å»è®¾ç½® ref
  if (!vnode || isAsyncWrapper(vnode)) {
    value = null;
  } else {
    if (vnode.shapeFlag & ShapeFlags.STATEFUL_COMPONENT) {
      value = vnode.component!.exposed || vnode.component!.proxy;
    } else {
      value = vnode.el;
    }
  }

  const { i: owner, r: ref } = rawRef;

  if (__DEV__ && !owner) {
    // warn ä¸¢å¤± ref owner ä¸Šä¸‹æ–‡
    return;
  }

  const oldRef = oldRawRef && (oldRawRef as VNodeNormalizedRefAtom).r;
  const refs = owner.refs === EMPTY_OBJ ? (owner.refs = {}) : owner.refs;
  const setupState = owner.setupState;

  // unset old ref
  if (oldRef != null && oldRef !== ref) {
    if (isString(oldRef)) {
      refs[oldRef] = null;
      if (hasOwn(setupState, oldRef)) {
        setupState[oldRef] = null;
      }
    } else if (isRef(oldRef)) {
      oldRef.value = null;
    }
  }

  if (isString(ref)) {
    const doSet = () => {
      refs[ref] = value;
      if (hasOwn(setupState, ref)) {
        setupState[ref] = value;
      }
    };

    // #1789: éç©ºå€¼ï¼Œåœ¨ render ç»“æŸåè®¾ç½®
    // æ§åˆ¶æ„å‘³ç€æ˜¯ unmountï¼Œå®ƒä¸åº”è¯¥é‡å†™åŒkey çš„å…¶ä»– ref
    if (value) {
      (doSet as SchedulerCb).id = -1;
      queuePostRenderEffect(doSet, parentSuspense);
    } else {
      doSet();
    }
  } else if (isRef(ref)) {
    const doSet = () => {
      ref.value = value;
    };

    if (value) {
      (doSet as SchedulerCb).id = -1;
      queuePostRenderEffect(doSet, parentSuspense);
    } else {
      doSet();
    }
  } else if (isFunction(ref)) {
    callWithErrorHandling(ref, owner, ErrorCodes.FUNCTION_REF, [value, refs]);
  } else if (__DEV__) {
    // warn ...
  }
};
#+end_src

è¿™é‡Œå¯ä»¥ç®€å•ç†è§£ä¸ºï¼šå°† ~ref~ è®¾å€¼ä¸º ~vnode.el~ è¿™æ˜¯ä¸ªå¼•ç”¨ï¼Œå› æ­¤å½“å®ƒæœ‰å€¼çš„æ—¶å€™ä¹Ÿ
ç­‰äºæ˜¯ ref æœ‰å€¼äº†ï¼Œç„¶ååˆ†ä¸ºå¼‚æ­¥å’ŒåŒæ­¥ï¼Œå¼‚æ­¥éœ€è¦ç­‰ render å®Œæˆå†å»è®¾ç½®ã€‚
* direcitve hooks
:PROPERTIES:
:COLUMNS: %CUSTOM_ID[(Custom Id)]
:CUSTOM_ID: dir-hooks
:END:

[[https://github.com/gcclll/stb-vue-next/commit/1343be213f6f0b95b2b37b16733b722e8c465099][feat(add): directive hooks Â· gcclll/stb-vue-next@1343be2]]

æ‰§è¡ŒæŒ‡ä»¤å£°æ˜å‘¨æœŸé’©å­å‡½æ•°ï¼š
#+begin_src typescript
export function invokeDirectiveHook(
  vnode: VNode,
  prevVNode: VNode | null,
  instance: ComponentInternalInstance | null,
  name: keyof ObjectDirective
) {
  const bindings = vnode.dirs!
  const oldBindings = prevVNode && prevVNode.dirs!
  for (let i = 0; i < bindings.length; i++) {
    const binding = bindings[i]
    if (oldBindings) {
      binding.oldValue = oldBindings[i].value
    }
    const hook = binding.dir[name] as DirectiveHook | undefined
    if (hook) {
      callWithAsyncErrorHandling(hook, instance, ErrorCodes.DIRECTIVE_HOOK, [
        vnode.el,
        binding,
        vnode,
        prevVNode
      ])
    }
  }
}
#+end_src

ç»™ç»„ä»¶æ³¨å†ŒæŒ‡ä»¤é›†ï¼š
#+begin_src typescript

export function withDirectives<T extends VNode>(
  vnode: T,
  directives: DirectiveArguments
): T {
  const internalInstance = currentRenderingInstance
  if (internalInstance === null) {
    __DEV__ && warn(`withDirectives can only be used inside render functions.`)
    return vnode
  }
  const instance = internalInstance.proxy
  const bindings: DirectiveBinding[] = vnode.dirs || (vnode.dirs = [])
  for (let i = 0; i < directives.length; i++) {
    let [dir, value, arg, modifiers = EMPTY_OBJ] = directives[i]
    if (isFunction(dir)) {
      dir = {
        mounted: dir,
        updated: dir
      } as ObjectDirective
    }
    bindings.push({
      dir,
      instance,
      value,
      oldValue: void 0,
      arg,
      modifiers
    })
  }
  return vnode
}
#+end_src

created, befoureMounted, mounted å‘ç”Ÿåœ¨ mountElement()
#+begin_src typescript
// å‘ç”Ÿåœ¨ mountChildren ä¹‹å
if (dirs) {
  invokeDirectiveHook(vnode, null, parentComponent, "created");
}

// ...

// åœ¨æ’å…¥DOMä¹‹å‰æ‰§è¡Œ
if (dirs) {
  invokeDirectiveHook(vnode, null, parentComponent, "beforeMount");
}

//  hostInsert(el, container, anchor)

// æ’å…¥DOMä¹‹åæ‰§è¡Œï¼Œæ”¾å…¥ä»»åŠ¡é˜Ÿåˆ—ç­‰å¾… render ç»“æŸ
if (
  (vnodeHook = props && props.onVnodeMounted) ||
  needCallTransitionHooks ||
  dirs
) {
  queuePostRenderEffect(() => {
    vnodeHook && invokeVNodeHook(vnodeHook, parentComponent, vnode);
    needCallTransitionHooks && transition!.enter(el);
    dirs && invokeDirectiveHook(vnode, null, parentComponent, "mounted");
  }, parentSuspense);
}
#+end_src

beforeUpdate, updated å‘ç”Ÿåœ¨ mountChildren()
#+begin_src diff
+    if ((vnodeHook = newProps.onVnodeBeforeUpdate)) {
+      invokeVNodeHook(vnodeHook, parentComponent, n2, n1)
+    }

+ if (dirs) {
+      invokeDirectiveHook(n2, n1, parentComponent, 'beforeUpdate')
+    }

+   if ((vnodeHook = newProps.onVnodeUpdated) || dirs) {
+      queuePostRenderEffect(() => {
+        vnodeHook && invokeVNodeHook(vnodeHook, parentComponent, n2, n1)
+        dirs && invokeDirectiveHook(n2, n1, parentComponent, 'updated')
+      }, parentSuspense)
+    }
#+end_src

unmounted å‘ç”Ÿåœ¨ unmount()
#+begin_src diff
+    if ((vnodeHook = props && props.onVnodeUnmounted) || shouldInvokeDirs) {
+      queuePostRenderEffect(() => {
+        vnodeHook && invokeVNodeHook(vnodeHook, parentComponent, vnode)
+        shouldInvokeDirs &&
+          invokeDirectiveHook(vnode, null, parentComponent, 'unmounted')
+      }, parentSuspense)
+    }
#+end_src

æµ‹è¯•ï¼š
#+begin_src js
const { log, f, shuffle, runtime_test, renderChildren } = require(process.env
  .BLOG_DIR_VUE + "/lib.js");
import(process.env.BLOG_DIR_VUE + "/runtime-test.global.js").then(
  ({
    h,
    render,
    nodeOps,
    serializeInner: inner,
    ref,
    currentInstance,
    withDirectives,
  }) => {
    const count = ref(0);
    let _vnode = null,
      _prevVnode;

    const beforeMount = (el, binding, vnode, prevVnode) => {
      log(">>> before mounted");
      log("el.tag = " + el.tag);
      log("el.parentNode = " + el.parentNode);
      log("root.children.length = " + root.children.length);

      log(binding);
      log("vnode = _vnode, " + (vnode === _vnode));
      log("prev vnode = " + prevVnode);
    };

    const mounted = (el, binding, vnode, prevVnode) => {
      log(">>> mounted");
      log("el.tag = " + el.tag);
      log("el.parentNode = root" + (el.parentNode === root));
      log("root.children[0] = el" + (el.children[0] === el));

      log(binding);
      log("vnode = _vnode, " + (vnode === _vnode));
      log("prev vnode = " + prevVnode);
    };

    const beforeUpdate = (el, binding, vnode, prevVnode) => {
      log(">>> before update");
      log("el.tag = " + el.tag);
      log("el.parentNode = root" + (el.parentNode === root));
      log("root.children[0] = el" + (el.children[0] === el));

      log("èŠ‚ç‚¹åº”è¯¥è¿˜æ²¡æ›´æ–° el.children[0].text = " + (count.value - 1));
      log(binding);
      log("vnode = _vnode, " + (vnode === _vnode));
      log("prev vnode = _prevVnode" + (prevVNode === _prevVnode));
    };

    const updated = (el, binding, vnode, prevVnode) => {
      log(">>> updated");
      log("el.tag = " + el.tag);
      log("el.parentNode = root" + (el.parentNode === root));
      log("root.children[0] = el" + (el.children[0] === el));

      log("èŠ‚ç‚¹åº”è¯¥å·²ç»æ›´æ–° el.children[0].text = " + count.value);
      log(binding);
      log("vnode = _vnode, " + (vnode === _vnode));
      log("prev vnode = _prevVnode" + (prevVNode === _prevVnode));
    };

    const beforeUnmount = (el, binding, vnode, prevVnode) => {
      log(">>> before unmount");
      log("el.tag = " + el.tag);
      log("el.parentNode = root" + (el.parentNode === root));
      log("root.children[0] = el" + (el.children[0] === el));

      log("èŠ‚ç‚¹åº”è¯¥å·²ç»æ›´æ–° el.children[0].text = " + count.value);
      log(binding);
      log("vnode = _vnode, " + (vnode === _vnode));
      log("prev vnode = " + prevVNode);
    };
    const unmounted = (el, binding, vnode, prevVnode) => {
      log(">>> unmounted");
      log("el.tag = " + el.tag);
      log("el.parentNode = " + el.parentNode);
      log("root.children.length = " + el.children.length);

      log("èŠ‚ç‚¹åº”è¯¥å·²ç»æ›´æ–° el.children[0].text = " + count.value);
      log(binding);
      log("vnode = _vnode, " + (vnode === _vnode));
      log("prev vnode = " + prevVNode);
    };

    const dir = {
      beforeMount,
      mounted,
      beforeUpdate,
      updated,
      beforeUnmount,
      unmounted,
    };

    let _instance = null;
    const Comp = {
      setup() {
        _instance = currentInstance;
      },
      render() {
        (_prevVnode = _vnode),
          (_vnode = withDirectives(h("div", count.value), [
            [
              dir, // dir, v-dir
              count.value, // value, v-dir:foo.ok=value
              "foo", // argument
              { ok: true }, // modifiers
            ],
          ]));
        return _vnode;
      },
    };

    const root = nodeOps.createElement("div");
    render(h(Comp), root);
  },

  (err) => {
    console.log(err.message);
  }
);
#+end_src

#+RESULTS:
#+begin_example
undefinedcomponent stateful ? 4
call setup
[Function: render] render
normalize vnode
>>> before mounted
el.tag = div
el.parentNode = null
root.children.length = 0
{
  dir: {
    beforeMount: [Function: beforeMount],
    mounted: [Function: mounted],
    beforeUpdate: [Function: beforeUpdate],
    updated: [Function: updated],
    beforeUnmount: [Function: beforeUnmount],
    unmounted: [Function: unmounted]
  },
  instance: {},
  value: 0,
  oldValue: undefined,
  arg: 'foo',
  modifiers: { ok: true }
}
vnode = _vnode, true
prev vnode = null
>>> mounted
el.tag = div
el.parentNode = roottrue
root.children[0] = elfalse
{
  dir: {
    beforeMount: [Function: beforeMount],
    mounted: [Function: mounted],
    beforeUpdate: [Function: beforeUpdate],
    updated: [Function: updated],
    beforeUnmount: [Function: beforeUnmount],
    unmounted: [Function: unmounted]
  },
  instance: {},
  value: 0,
  oldValue: undefined,
  arg: 'foo',
  modifiers: { ok: true }
}
vnode = _vnode, true
prev vnode = null
#+end_example
* TODO component props
:PROPERTIES:
:COLUMNS: %CUSTOM_ID[(Custom Id)]
:CUSTOM_ID: component-props
:END:

[[https://github.com/gcclll/stb-vue-next/commit/6f6a0bee8e84f93a5cdab83e4db87b9897b1e041][feat(add): patch props Â· gcclll/stb-vue-next@6f6a0be]]

#+begin_src js
const { log, f, shuffle, runtime_test, renderChildren } = require(process.env
  .BLOG_DIR_VUE + "/lib.js");
import(process.env.BLOG_DIR_VUE + "/runtime-test.global.js").then(
  ({
    h,
    render,
    nodeOps,
    serializeInner: inner,
    ref,
    currentInstance,
    withDirectives,
    defineComponent,
  }) => {
    let props;
    let attrs;
    let proxy;

    const Comp = defineComponent({
      props: ["fooBar", "barBaz"],
      render() {
        props = this.$props;
        attrs = this.$attrs;
        proxy = this;
      },
    });

    const _log = (title) => {
      log([
        '>>> ' + title,
        '\nproxy.fooBar = ' + proxy.fooBar,
        '\n> props\n', props,
        '\n> attrs\n', attrs
      ])
    }

    const root = nodeOps.createElement('div')
    render(h(Comp, { fooBar: 1, bar: 2 }), root)
    _log('test')

    render(h(Comp, { 'foo-bar': 3, bar: 3, baz: 4, barBaz: 5 }), root)
    _log('foo-bar ä¼šè½¬æˆ fooBar')

    render(h(Comp, { qux: 5 }), root)
    _log('åˆ é™¤ camel case')

    log('\n>>> stateful with setup')
  },

  (err) => {
    console.log(err.message);
  }
);
#+end_src

#+RESULTS:
#+begin_example
undefinedcomponent stateful ? 4
call setup
no setup
[Function: render] render
normalize vnode
>>> test
proxy.fooBar = 1
> props
 { fooBar: 1 }
> attrs
 { bar: 2 }
should update component
has changed props
normalize vnode
>>> foo-bar ä¼šè½¬æˆ fooBar
proxy.fooBar = 3
> props
 { fooBar: 3, barBaz: 5 }
> attrs
 { bar: 3, baz: 4 }
should update component
has changed props
normalize vnode
>>> åˆ é™¤ camel case
proxy.fooBar = undefined
> props
 { fooBar: undefined, barBaz: undefined }
> attrs
 { qux: 5 }
#+end_example

* æµ‹è¯•
:PROPERTIES:
:COLUMNS: %CUSTOM_ID[(Custom Id)]
:CUSTOM_ID: testing
:END:

#+begin_export html
<p style="font-weight:800;font-size:28px;">Teleport Testing...</p>
<div id="6MyGYf">
<p style="background:red;color:white;" id="p0"></p>
<p style="background:red;color:white;" id="p1"></p>
<p style="background:red;color:white;" id="p2"></p>
<p style="background:red;color:white;" id="p3"></p>
<p style="background:red;color:white;" id="p4"></p>
<p style="background:red;color:white;" id="p5"></p>
<p style="background:red;color:white;" id="p6"></p>
<p style="background:red;color:white;" id="p7"></p>
<div id="dzwrLeuq5V"></div>
<script src="/js/vue/tests/dzwrLeuq5V.js"></script>

<p style="font-weight:800;font-size:28px;">Suspense Testing...</p>
<div id="WTYoDwLIkv"></div>
<script src="/js/vue/tests/WTYoDwLIkv.js"></script>

<p style="font-weight:800;font-size:28px;">KeepAlive Testing...</p>
<div id="r9KorlFxQ9"></div>
<script src="/js/vue/tests/r9KorlFxQ9.js"></script>

<p style="font-weight:800;font-size:28px;">Directive Testing...</p>
<div id="VSkUTk5fho"></div>
<script src="/js/vue/tests/VSkUTk5fho.js"></script>

#+end_export

** è„‘å›¾ & æµ‹è¯•ç»“æœ GIF
1. keep-alive æµ‹è¯•å˜åŒ– GIF(13M):

    [[/img/vue3/runtime-core/gifs/test-keep-alive.gif]]

    ç»“åˆ[[#keep-alive-deactivate][æºç ]]

    #+begin_src typescript
    // deactivate()
    const storageContainer = createElement("div");
    move(vnode, storageContainer, null, MoveType.LEAVE, parentSuspense);
    #+end_src

    å³ï¼Œ deactivated çš„ DOM èŠ‚ç‚¹å…¶å®å¹¶éç›´æ¥åˆ é™¤äº†ï¼Œè€Œæ˜¯ç§»åˆ°åˆ°äº†ä¸€ä¸ª  ~off-dom~
   çš„å…ƒç´ ä¸Šäº†ï¼Œå¾…é‡æ–°æ¿€æ´»çš„æ—¶å€™å†ç§»å›æ¥(åœ¨æºç çš„ deactivate å’Œ activate å‡½æ•°ä¸­å¢
   åŠ  ~storageContainer~ æ‰“å°).

2. æµ‹è¯•è„‘å›¾ï¼š

    [[/img/vue3/runtime-core/vue-sample-runtime-core-suspense.svg]]
