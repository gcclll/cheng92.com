#+TITLE: Vue3 æºç å¤´è„‘é£æš´ä¹‹ 7 â˜ runtime-core(3) - render component
#+DATE: <2021-03-16 15:31:46>
#+TAGS[]: vue, vue3, runtime-core, render, component
#+CATEGORIES[]: vue
#+LANGUAGE: zh-cn
#+STARTUP: indent shrink inlineimages

#+begin_export html
<link href="https://fonts.goo~gleapis.com/cs~s2?family=ZCOOL+XiaoWei&display=swap" rel="stylesheet">
<kbd>
<font color="blue" size="3" style="font-family: 'ZCOOL XiaoWei', serif;">
  è¯—å·ï¼šå…­é“åŒå ï¼Œé­”åŠ«ä¸‡åƒï¼Œå¼•æ¸¡å¦‚æ¥ã€‚
</font>
</kbd><br><br>
<script src="https://unpkg.com/vue@next"></script>
<script src="https://unpkg.com/element-plus/lib/index.full.js"></script>
<script src="/js/utils.js"></script>
#+end_export

[[/img/bdx/yiyeshu-001.jpg]]

@@html:<kbd>@@
*[[https://github.com/gcclll/stb-vue-next][stb-vue-next]] å®Œå…¨æ‹·è´äº [[https://github.com/vuejs/vue-next][vue-next]] ï¼Œä¸»è¦ç›®çš„ç”¨äºå­¦ä¹ ã€‚*
@@html:</kbd>@@

#+begin_quote
æœ¬æ–‡ä¸º runtime-core(2) ç»­é›†ï¼Œä¸Šç¯‡ï¼š [[/vue/vue-mind-map-runtime-core-2-render/][Vue3 æºç å¤´è„‘é£æš´ä¹‹ 7 â˜ runtime-core(2) - render]]
#+end_quote


* æµç¨‹å›¾(è„‘å›¾)
:PROPERTIES:
:COLUMNS: %CUSTOM_ID[(Custom Id)]
:CUSTOM_ID: mindmap
:END:

[[/img/vue3/runtime-core/vue-runtime-core-render-component.svg]]

è¿™ä¸€èŠ‚æ–°å¢å†…å®¹è¾ƒå¤šï¼Œä¸»è¦æ–°å¢ä»¥ä¸‹å‡ ä¸ªå‡½æ•°

1. ~processComponent()~ åœ¨ patch() ä¸­æ‰§è¡Œ switch default åˆ†æ”¯ï¼Œæ»¡è¶³
   ~ShapeFlags.COMPONENT~ æ¡ä»¶
2. ~mountComponent(n2,...)~ é¦–æ¬¡åŠ è½½ç»„ä»¶æ—¶è°ƒç”¨çš„å‡½æ•°
3. ~setupComponent(instance)~ å»ºç«‹ç»„ä»¶å®ä¾‹ï¼Œåšä¸€äº›ç»“æ„åˆå§‹åŒ–æ“ä½œ(å¦‚ï¼špropså’Œ
   slots)ç­‰
4. ~setupStatefulComponent(instance,isSSR)~ åˆ›å»ºæœ‰çŠ¶æ€ç»„ä»¶ï¼Œæ‰§è¡Œ ~setup()~ å‡½æ•°
5. ~setupRenderEffect()~ é€šè¿‡ [[/vue/vue-mind-map-reactivity/#fn-effect][effect()]] å‡½æ•°è¿”å› ~instance.update~ åˆ›å»ºä¸€ä¸ªç›‘å¬-
   æ›´æ–°å‡½æ•°ã€‚
6. ~finishComponentSetup(instance,isSSR)~ è¿™ä¸ªå‡½æ•°åœ¨ ~setupStatefulComponent()~
   ä¸­è°ƒç”¨ï¼Œä¸»è¦åšçš„äº‹æƒ…æ˜¯å¤„ç† SSRï¼Œæ²¡æœ‰ render å‡½æ•°æœ‰ template æ—¶è°ƒç”¨ compile ç¼–
   è¯‘å‡º render å‡½æ•°ï¼Œå…¼å®¹ 2.x çš„ options api

* processComponent(å¦‚ä½•patchç»„ä»¶çš„ï¼Ÿ)
:PROPERTIES:
:COLUMNS: %CUSTOM_ID[(Custom Id)]
:CUSTOM_ID: render-component
:END:

é—®é¢˜ä¿®å¤ï¼š [[#q-allow-recurse][TypeError: Cannot read property 'allowRecurse' of null]]

~processComponent(n1,n2,...)~ å‡½æ•°ä¸»è¦åˆ†ä¸‰ç§æƒ…å†µ

1. mount, æ²¡æœ‰ n1 old æ—¶å€™ï¼Œå±äºçº¯ mount æ“ä½œ
   a. keep-alive ç±»å‹ï¼Œåªéœ€è¦é‡æ–°æ¿€æ´» activate
   b. å¦åˆ™æ‰§è¡Œ mountComponent(n2, ....) é¦–æ¬¡åŠ è½½ç»„ä»¶
2. update, éé¦–æ¬¡åŠ è½½æ‰§è¡Œæ›´æ–°æ“ä½œ

#+begin_src js
const { log, f, shuffle, runtime_test, renderChildren } = require(process.env
  .BLOG_DIR_VUE + "/lib.js");
import(process.env.BLOG_DIR_VUE + "/runtime-test.global.js").then(
  ({ h, render, nodeOps, serializeInner: inner, ref }) => {
    const root = nodeOps.createElement("div");
    const logRoot = () => log("root: " + inner(root));

    logRoot();
    const value = ref(true);
    let parentVnode, childVnode1, childVnode2;

    const Parent = {
      render: () => {
        // return h("div", "æµ‹è¯•...");
        return (parentVnode = h(Child));
      },
    };

    const Child = {
      render: () => {
        return value.value
          ? (childVnode1 = h("div", "child 1"))
          : (childVnode2 = h("span", "child 2"));
      },
    };

    const p = h(Parent);
    render(p, root);
    logRoot();
    value.value = false;
    logRoot();
  },
  (err) => {
    console.log(err.message);
  }
);
#+end_src

#+RESULTS:
#+begin_example
undefinedroot:
component stateful ? 4
call setup
no setup
[Function: render] render
mount component
normalize vnode
patch component
component stateful ? 4
call setup
no setup
[Function: render] render
mount component
normalize vnode
patch component
root: <div>child 1</div>
root: <div>child 1</div>
component update
#+end_example

æµç¨‹ç®€å›¾ï¼š

[[/img/vue3/runtime-core/vue-runtime-core-render-component-brief.svg]]

è¿™é‡Œæ‰§è¡Œå°±æ˜¯ ~mountComponent(n2,...)~ è¡Œä¸ºï¼Œé¦–æ¬¡åŠ è½½ç»„ä»¶ï¼Œå®Œæˆï¼š

1. ~setupComponent(instance)~ æ‰§è¡Œ setup å‡½æ•°ï¼Œåˆå§‹åŒ– props&slots ç­‰
2. ~setupRenderEffect(instance,...)~ æ³¨å†Œ instance.update effect

   å½“å®ä¾‹çŠ¶æ€å‘ç”Ÿæ”¹å˜æ—¶æ‰§è¡Œè¿™ä¸ª effect fnï¼Œå¦‚æœæ˜¯é¦–æ¬¡(çˆ¶çº§è°ƒç”¨ processComponent)
   æ‰§è¡Œ!isMounted åˆ†æ”¯è¿›è¡Œç»„ä»¶é¦–æ¬¡åŠ è½½ï¼Œå¦åˆ™å½“ç»„ä»¶è‡ªèº«çŠ¶æ€æ”¹å˜æ˜¯è§¦å‘çš„ update æ“
   ä½œ


åœ¨ ~setupComponent~ ä¸­ï¼Œä¸»è¦å®Œæˆ

1. initProps
2. initSlots
3. setupStatefulComponent(instance,isSSR) æœ‰çŠ¶æ€ç»„ä»¶(éå‡½æ•°ç»„ä»¶)


ç´§æ¥ç€ ~setupStatefulComponent(instance,isSSR)~ ä¸­æ£€æµ‹ setup å‡½æ•°ï¼Œå¹¶æ‰§è¡Œå®ƒï¼Œå¦‚
æœæ²¡æœ‰ setup å‡½æ•°å°±è¿›å…¥ finishComponentSetup(instance) æ£€æµ‹ render æˆ– template
æœ€ç»ˆç›®çš„æ˜¯è·å¾— render å‡½æ•°ï¼Œå¦‚æœæ²¡æœ‰ render ä¼šé€šè¿‡ compile(template) ç¼–è¯‘å‡º
render å‡½æ•°ï¼Œæœ€ååœ¨ instance.update ä¸­æ‰§è¡Œ render å‡½æ•°(åœ¨è¿™å‰åä¼šè§¦å‘
beforeMount å’Œ mounted å‘¨æœŸå‡½æ•°)ã€‚


#+begin_quote
æ‰€ä»¥ï¼Œä¸€å¥—æµç¨‹ä¸‹æ¥å¯ä»¥ç®€å•æè¿°ä¸º

mount -> props&slots åˆå§‹åŒ– -> setup() -> æœ‰çŠ¶æ€ç»„ä»¶å¤„ç†å¾—åˆ° render å‡½æ•° -> æœ€å
é€šè¿‡ instance.update effect æ¥ç›‘å¬å®ä¾‹çŠ¶æ€å˜åŒ–ï¼Œè§¦å‘ mount æˆ–è€… updateã€‚

åœ¨ effect mount é˜¶æ®µä¼šè§¦å‘ç”Ÿå‘½å‘¨æœŸå‡½æ•°ï¼š

1. beforeMount + mounted
2. onVnodeBeforeMount + onVnodeMounted(é’ˆå¯¹ vnode ç»“æ„å˜åŒ–è€Œè¨€)
3. activated(å¦‚æœæ˜¯ keep-alive çš„è¯)

ç»„ä»¶çš„æ¸²æŸ“å°±å‘ç”Ÿåœ¨ beforeMount ä¹‹å mounted ä¹‹å‰çš„ renderComponentRoot() å¾—åˆ°
vnode äº¤ç»™ patch å»è¿›è¡Œæ¸²æŸ“ã€‚
#+end_quote

ç¤ºä¾‹ä»£ç ä¸­ï¼Œåé¢ä¿®æ”¹äº† ~value.value=false~ åé¢ dom å¹¶æ²¡æ”¹å˜ï¼Œä½†æ˜¯è¾“å‡ºäº†
/component update/ è¯´æ˜è¿›å…¥äº† ~instance.update effect~ çš„ else åˆ†æ”¯ï¼Œå› ä¸ºä¸æ˜¯ç¬¬
ä¸€æ¬¡ï¼Œæ‰€ä»¥è¿™é‡Œéœ€è¦å®ç°æ›´æ–°ç»„ä»¶éƒ¨åˆ†ã€‚

** effect update component

å› ä¸º instance.update æ˜¯é€šè¿‡ ~effect()~ å°è£…çš„å‡½æ•°ï¼Œä¸”è¿™ä¸ªå‡½æ•°ä¸­ä½¿ç”¨åˆ°äº† instance
å®ä¾‹è€Œè¿™ä¸ªå®ä¾‹åˆåœ¨ setupComponent ä¸­æœ‰åšè¿‡ä»£ç†ï¼Œå› æ­¤å¯¹å®ƒçš„è®¿é—®ä¼šè§¦å‘ effect
trackï¼ŒçŠ¶æ€æ›´æ–°ä¼šè§¦å‘ effect trigger(å“åº”å¼åŸç†)ã€‚

[[https://github.com/gcclll/stb-vue-next/commit/12544657c05c740c09a3632e0e2cf9ec9e29ca67][feat(add): component update Â· gcclll/stb-vue-next@1254465]]

æ¶‰åŠçš„ä¿®æ”¹ï¼š
#+begin_src typescript
instance.update = effect(
  function componentEffect() {
    // ç›‘å¬æ›´æ–°
    if (!instance.isMounted) {
      // ...
    } else {
      // updateComponent
      // å½“ç»„ä»¶è‡ªèº«çš„çŠ¶æ€æˆ–çˆ¶ç»„ä»¶è°ƒç”¨ processComponent æ—¶è§¦å‘
      console.log("component update");
      let { next, bu, u, parent, vnode } = instance;
      let originNext = next;
      let vnodeHook: VNodeHook | null | undefined;

      if (next) {
        next.el = vnode.el;
        updateComponentPreRender(instance, next, optimized);
      } else {
        next = vnode;
      }

      // beforeUpdate hook
      if (bu) {
        invokeArrayFns(bu);
      }
      // onVnodeBeforeUpdate
      if ((vnodeHook = next.props && next.props.onVnodeBeforeUpdate)) {
        invokeVNodeHook(vnodeHook, parent, next, vnode);
      }

      //render
      const nextTree = renderComponentRoot(instance);
      const prevTree = instance.subTree;
      instance.subTree = nextTree;

      patch(
        prevTree,
        nextTree,
        // å¦‚æœåœ¨ teleport ä¸­ï¼Œparent å¯èƒ½ä¼šå‘ç”Ÿæ”¹å˜
        hostParentNode(prevTree.el!)!,
        // anchor may have changed if it's in a fragment
        getNextHostNode(prevTree),
        instance,
        parentSuspense,
        isSVG
      );

      next.el = nextTree.el;
      if (originNext === null) {
        // self-triggered update. In case of HOC, update parent component
        // vnode el. HOC is indicated by parent instance's subTree pointing
        // to child component's vnode
        // TODO
      }

      // updated hook
      if (u) {
        queuePostRenderEffect(u, parentSuspense);
      }
      // onVnodeUpdated
      if ((vnodeHook = next.props && next.props.onVnodeUpdated)) {
        queuePostRenderEffect(() => {
          invokeVNodeHook(vnodeHook!, parent, next!, vnode);
        });
      }
    }
  },
  __DEV__
    ? // æä¾› onTrack/onTrigger é€‰é¡¹æ‰§è¡Œ rtc&rtg ä¸¤ä¸ªå‘¨æœŸå‡½æ•°
      createDevEffectOptions(instance)
    : prodEffectOptions
);
#+end_src

å’Œ updateComponentPreRender å®ç°è¿™ä¸ªå‡½æ•°è®© instance.update åœ¨ nextTick() ä¹‹åæ‰§
è¡Œ pre ä¼˜å…ˆäº post å’Œ job ä»»åŠ¡([[/vue/vue-mind-map-runtime-core/#scheduler][è¯¦æƒ…æŸ¥çœ‹ä»»åŠ¡è°ƒåº¦->]])ï¼š
#+begin_src typescript
const updateComponentPreRender = (
    instance: ComponentInternalInstance,
    nextVNode: VNode,
    optimized: boolean
  ) => {
    nextVNode.component = instance
    // const prevProps = instance.vnode.props
    instance.vnode = nextVNode
    instance.next = null
    // TODO update props
    // TODO update slots

    // props update may have triggered pre-flush watchers.
    // flush them before the render update.
    flushPreFlushCbs(undefined, instance.update)
  }
#+end_src

ä¹‹å‰çš„ç”¨ä¾‹å†æµ‹è¯•ä¸€éï¼š
#+begin_src js
const { log, f, shuffle, runtime_test, renderChildren } = require(process.env
  .BLOG_DIR_VUE + "/lib.js");
import(process.env.BLOG_DIR_VUE + "/runtime-test.global.js").then(
  async ({ h, render, nodeOps, serializeInner: inner, ref, nextTick }) => {
    const root = nodeOps.createElement("div");
    const logRoot = () => log("root: " + inner(root));

    logRoot();
    const value = ref(true);
    let parentVnode, childVnode1, childVnode2;
    const idValue = ref("parent");

    const Parent = {
      render: () => {
        console.log("parent render");
        return (parentVnode = h("div", { id: idValue.value }, h(Child)));
      },
    };

    const Child = {
      render: () => {
        console.log("child render");
        return value.value
          ? (childVnode1 = h("div", "child 1"))
          : (childVnode2 = h("span", "child 2"));
      },
    };

    const p = h(Parent);
    render(p, root);
    logRoot();
    console.log("before change value");
    value.value = false;
    await nextTick();
    console.log("after change value");
    logRoot();

    console.log('before id change');
    idValue.value = 'parent-id'
    await nextTick()
    console.log('after id change');
    logRoot()
  },
  (err) => {
    console.log(err.message);
  }
);
#+end_src

#+RESULTS:
#+begin_example
undefinedroot:
component stateful ? 4
call setup
no setup
[Function: render] render
mount component
normalize vnode
parent render
patch component
component stateful ? 4
call setup
no setup
[Function: render] render
mount component
normalize vnode
child render
patch component
root: <div id="parent"><div>child 1</div></div>
before change value
component update
normalize vnode
child render
after change value
root: <div id="parent"><span>child 2</span></div>
before id change
component update
normalize vnode
parent render
after id change
root: <div id="parent"><span>child 2</span></div>
#+end_example

è¿™é‡Œè¦è®©è¾“å‡ºè¾¾åˆ°æ•ˆæœï¼Œéœ€è¦å°† resolve æ”¹æˆ async function å¹¶ä¸”è¦åœ¨ nextTick() å
è¾“å‡ºæ›´æ–°åçš„ç»“æœï¼Œå› ä¸º instance.update è°ƒç”¨äº† ~flushPreFlushCbs(null,
instane.update)~ ä¹Ÿå°±æ˜¯è¯´è¿™ä¸ªå‡½æ•°æ˜¯ä¸ªå¼‚æ­¥æ›´æ–°ï¼Œä¸”ä¼šåœ¨ ~nextTick()~ åè§¦å‘ï¼Œè¯¦æƒ…
åˆ†ææŸ¥çœ‹â€œ[[/vue/vue-mind-map-runtime-core/#scheduler][ä»»åŠ¡è°ƒåº¦æœºåˆ¶åˆ†æ]]â€

#+begin_quote
é—®é¢˜ï¼š å¦‚ä¸Šé¢çš„ç»“æœï¼Œå½“æˆ‘ä»¬æ”¹å˜ ~idValue.value="parent-id"~ çš„æ—¶å€™ï¼Œå®é™…ç»“æœå¹¶æ²¡
æœ‰æ”¹å˜ï¼Ÿ

ç­”ï¼š å› ä¸ºåœ¨ ~setupComponent()~ ä¸­çš„ ~initProps()~ ä»¥åŠ ~updateComponentPreRender()~
ä¸­çš„ ~updateProps()~ è¿˜æ²¡å®ç°ï¼Œä¸‹ä¸€èŠ‚æ­æ™“ã€‚
#+end_quote
** normalize props options
:PROPERTIES:
:COLUMNS: %CUSTOM_ID[(Custom Id)]
:CUSTOM_ID: norm-props-opt
:END:

[[https://github.com/gcclll/stb-vue-next/commit/7d6ac555be06253f6dab5af8d6a0c2df8b46b656][feat(add): normalize props options Â· gcclll/stb-vue-next@7d6ac55]]

å¯¹åº”å®˜æ–¹æ–‡æ¡£å†…å®¹ï¼š [[https://v3.vuejs.org/guide/component-props.html#prop-types][Props | Vue.js]]

#+begin_quote
è¿™é‡Œä½œç”¨ç®€å•æè¿°å°±æ˜¯ï¼Œå°† props çš„å®šä¹‰åœ¨ç»„ä»¶åŠ è½½åˆå§‹åŒ–æ—¶è§£ææˆå…·ä½“çš„å€¼ï¼Œå¦‚ï¼š
~props: ['foo']~ è§£ææˆ ~foo={}~ å› ä¸ºå­—ç¬¦ä¸²æ•°ç»„çš„ props ä¼šç»™æ¯ä¸ªå±æ€§åˆå§‹åŒ–ä¸€ä¸ªç©º
å¯¹è±¡ã€‚
#+end_quote

æ¯”å¦‚ï¼š

1. æ•°ç»„ï¼š ~props: ['foo', 'bar', 'foo-bar']~

    è½¬æˆ ~{foo: {}, bar: {}, fooBar: {}}~

2. å¯¹è±¡: ~props: { foo: [Boolean, String], bar: Function }~

   è¡¨ç¤º foo å¯ä»¥æ˜¯å¸ƒå°”å€¼æˆ–å­—ç¬¦ä¸²ï¼Œbar æ˜¯ä¸ªå‡½æ•°

   è½¬æ¢è¿‡ç¨‹(0: ~BooleanFlags.shouldCast~, 1: ~BooleanFlags.shouldCastTrue~)

   ~foo = { type: [Boolean, String] }~ -> æ‰¾ Boolean

   ~foo = { type: [Boolean, String], 0: true }~ ->

   æ‰¾ String éœ€æ»¡è¶³ ~stringIndex < 0 || booleanIndex < stringIndex~

   ~foo = { type: [Boolean, String], 0: true, 1: true }~

   æœ€åå†³å®š ~foo~ æ˜¯ä¸æ˜¯åº”è¯¥è¿›è¡Œ cast ? æ¡ä»¶æ˜¯å¸ƒå°”ç±»å‹æˆ–è€…æœ‰ default é»˜è®¤å€¼ã€‚


æºç ï¼š
#+begin_src typescript
export function normalizePropsOptions(
  comp: ConcreteComponent,
  appContext: AppContext,
  asMixin: false
): NormalizedPropsOptions {
  if (!appContext.deopt && comp.__props) {
    return comp.__props
  }

  const raw = comp.props
  const normalized: NormalizedPropsOptions[0] = {}
  const needCastKeys: NormalizedPropsOptions[1] = []

  // mixin/extends props åº”ç”¨
  let hasExtends = false
  // å¿…é¡»å¼€æ”¯ 2.x options api æ”¯æŒï¼Œä¸”ä¸æ˜¯å‡½æ•°å¼ç»„ä»¶
  // ç»§æ‰¿æ¥çš„å±æ€§ï¼Œç”¨æ³•ï¼š ~CompA = { extends: CompB, ... }~
  // CompA ä¼šç»§æ‰¿ CompB çš„ props
  if (__FEATURE_OPTIONS_API__ && !isFunction(comp)) {
    const extendProps = (raw: ComponentOptions) => {
      hasExtends = true
      const [props, keys] = normalizePropsOptions(raw, appContext, true)
      extend(normalized, props)
      if (keys) {
        needCastKeys.push(...keys)
      }
    }

    // Comp: { extends: CompA } å¤„ç†
    if (comp.extends) {
      extendProps(comp.extends)
    }

    // Comp: { mixins: [mixin] } å¤„ç†
    if (!asMixin && appContext.mixins.length) {
      appContext.mixins.forEach(extendProps)
    }
  }

  // æ—¢æ²¡æœ‰è‡ªèº«çš„ props ä¹Ÿæ²¡æœ‰ extends ç»§æ‰¿æ¥çš„ props åˆå§‹åŒ–ä¸º []
  if (!raw && !hasExtends) {
    return (comp.__props = EMPTY_ARR as any)
  }

  if (isArray(raw)) {
    // å½“ props æ˜¯æ•°ç»„çš„æ—¶å€™ï¼Œå¿…é¡»æ˜¯å­—ç¬¦ç±»å‹ï¼Œå¦‚: props: ['foo', 'bar', 'foo-bar']
    // 'foo-bar' ä¼šè½¬æˆ 'fooBar'ï¼Œä¸å…è®¸ '$xxx' å½¢å¼çš„å˜é‡å
    for (let i = 0; i < raw.length; i++) {
      const normalizedKey = camelize(raw[i])
      // ç»„ä»¶çš„å±æ€§åä¸èƒ½æ˜¯ä»¥ $xx å¼€å¤´çš„åç§°ï¼Œè¿™ä¸ªæ˜¯ä½œä¸ºå†…éƒ¨å±æ€§çš„
      if (validatePropName(normalizedKey)) {
        normalized[normalizedKey] = EMPTY_OBJ
      }
    }
  } else if (raw) {
    // å¯¹è±¡ç±»å‹ props: { foo: 1, bar: 2, ... }
    for (const key in raw) {
      // 'foo-bar' -> 'fooBar'
      const normalizedKey = camelize(key)
      // æ£€æŸ¥ $xxx éæ³•å±æ€§
      if (validatePropName(normalizedKey)) {
        const opt = raw[key]
        // ? å€¼ä¸ºæ•°ç»„æˆ–å‡½æ•°å˜æˆï¼š { type: opt } ?
        // è¿™é‡Œå«ä¹‰å…¶å®æ˜¯ï¼š ~props: { foo: [Boolean, Function] }~
        // å¯ä»¥ç”¨æ•°ç»„å®šä¹‰è¯¥å±æ€§å¯ä»¥æ˜¯å¤šç§ç±»å‹çš„å…¶ä¸­ä¸€ç§
        const prop: NormalizedProp = (normalized[normalizedKey] =
          isArray(opt) || isFunction(opt) ? { type: opt } : opt)
        if (prop) {
          // æ‰¾åˆ° Boolean åœ¨ foo: [Boolean, Function] ä¸­çš„ç´¢å¼•
          const booleanIndex = getTypeIndex(Boolean, prop.type)
          const stringIndex = getTypeIndex(String, prop.type)
          prop[BooleanFlags.shouldCast] = booleanIndex > -1
          // [String, Boolean] ç±»å‹ï¼ŒString åœ¨ Boolean å‰é¢
          prop[BooleanFlags.shouldCastTrue] =
            stringIndex < 0 || booleanIndex < stringIndex
          // å¦‚æœæ˜¯å¸ƒå°”ç±»å‹çš„å€¼æˆ–è€…æœ‰é»˜è®¤å€¼çš„å±æ€§éœ€è¦è½¬æ¢
          // è½¬æ¢æ˜¯æ ¹æ® type å’Œ default å€¼å¤„ç†
          // typeéå‡½æ•°ï¼Œdefaultæ˜¯å‡½æ•°ï¼Œæ‰§è¡Œ default() å¾—åˆ°é»˜è®¤å€¼
          if (booleanIndex > -1 || hasOwn(prop, 'default')) {
            needCastKeys.push(normalizedKey)
          }
        }
      }
    }
  }

  return (comp.__props = [normalized, needCastKeys])
}

#+end_src

ç„¶åè¿™ä¸ªå¤„ç†ä¹‹åçš„ propsï¼Œä¼šè¢«ä¿å­˜åˆ°ç»„ä»¶çš„ ~comp.__props=[normalied,
needCastKeys]~ ä¸Šï¼Œè€Œè¿™ä¸ªä¼šåœ¨ ~resolvePropValue()~ ä¸­è¿›ä¸€æ­¥å¤„ç†ï¼Œè¿™é‡Œçš„
~needCastKeys~ éå¸¸é‡è¦ï¼Œå®ƒä¼šå†³å®šæœ€åçš„å€¼åº”è¯¥å¦‚ä½•è¢«å¤„ç†(~resolvePropValue~ ä¸­å¤„
ç†)ã€‚

æ¯”å¦‚ï¼š ~{ type: String, default: () => 'xxx' }~ é‚£ä¹ˆæ»¡è¶³ ~type!==Function &&
isFunction(dfault)~ åˆ™ä¼šç›´æ¥æ‰§è¡Œ default() å¾—åˆ°å±æ€§é»˜è®¤å€¼ã€‚

å¦‚æœå±æ€§çš„ ~opt[BooleanFlags.shouldCast]~ ä¸º ~true~ å¦‚[[#norm-props-opt][æœ€å¼€å§‹çš„è¯´æ˜]]ï¼Œå…¶å®å°±æ˜¯
~prop["0"]~ çš„å€¼ï¼Œåªè¦ prop çš„ç±»å‹ä¸­æœ‰ ~Boolean~ è¿™ä¸ªå€¼å°±æ˜¯ ~true~ ã€‚

æ­¤æ—¶éœ€è¦å°†å±æ€§çš„å€¼è½¬æˆ

1. *true* : ç±»å‹å£°æ˜ä¸­æœ‰ ~Boolean~ ä¸”æœ‰ ~String~ çš„æ—¶å€™ï¼Œå®ƒçš„å€¼å¦‚æœæ˜¯ ~''~ æˆ–è€…
   ~key === value~ æƒ…å†µä¸‹è½¬æˆ ~true~, å› ä¸ºæŒ‡å®šäº†å¯ä»¥æ˜¯ ~String~ ç±»å‹ï¼Œæ‰€ä»¥ç©ºå­—ç¬¦
   ä¸²æ˜¯å…è®¸çš„ã€‚

2. *false* : ~(!hasOwn(props, key) && !hasDefault)~, raw props ä¸­æ²¡æœ‰è¿™ä¸ªå±æ€§ä¸”
   æ²¡æœ‰ ~default~ é»˜è®¤å€¼çš„æ—¶å€™è½¬æˆ ~false~, ç­‰äºæ˜¯å‡å€¼ç±»å‹ã€‚

** component props
:PROPERTIES:
:COLUMNS: %CUSTOM_ID[(Custom Id)]
:CUSTOM_ID: component-props
:END:

[[https://github.com/gcclll/stb-vue-next/commit/9a6aa70c2109179a884b1496eea09af50a6efdb5][feat(add): init component props Â· gcclll/stb-vue-next@9a6aa70]]

æ–°å¢ä»£ç ï¼š
#+begin_src typescript
// component.ts > setupComponent()
export function setupComponent(
  instance: ComponentInternalInstance,
  isSSR = false
) {
  // ...
  // init props & slots
  initProps(instance, props, isStateful, isSSR);
  // ...
  return setupResult;
}
#+end_src

*componentProps.ts > initProps()*
1. def -> attrs.__vInterval = 1
2. setFullProps å¤„ç† rawProps å°†ç»“æœåé¦ˆåˆ° props å’Œ attrs
3. æœ‰çŠ¶æ€ç»„ä»¶ï¼Ÿå°† props reactive åŒ–ï¼ŒSSRä¸‹ä¸æ”¯æŒå±æ€§å“åº”å¼å…¶å®å°±æ˜¯æœåŠ¡å™¨è¿”å›çš„å±
   æ€§éƒ½æ˜¯å¸¦æœ‰æœ€ç»ˆå€¼çš„è€Œä¸æ˜¯åœ¨å®¢æˆ·ç«¯åŠ¨æ€èƒ½æ”¹å˜çš„
4. å‡½æ•°ç»„ä»¶çš„ props å¯é€‰å±æ€§å’Œå¿…é¡»å±æ€§ï¼Ÿå¯é€‰ç”¨  attrs å¦åˆ™ç”¨ props
#+begin_src typescript
export function initProps(
  instance: ComponentInternalInstance,
  rawProps: Data | null,
  isStateful: number,
  isSSR = false
) {
  const props: Data = {};
  const attrs: Data = {};
  def(attrs, InternalObjectKey, 1);
  setFullProps(instance, rawProps, props, attrs);
  // TODO validation

  if (isStateful) {
    instance.props = isSSR ? props : shallowReactive(props);
  } else {
    if (!instance.type.props) {
      // functional optional props, props === attrs
      instance.props = attrs;
    } else {
      // functional declared props
      instance.props = props;
    }
  }
  instance.attrs = attrs;
}

#+end_src

*componentProps.ts > setFullProps()*
è¿™ä¸ªå‡½æ•°ç›®çš„æ˜¯å°† rawProps ç»„ä»¶çš„ props è§£æå‡ºæ¥æ ¹æ®å„è‡ªç‰¹æ€§
åˆ†æ´¾åˆ° props æˆ– attrs
1. key, ref å±æ€§ä¸ä¿ç•™ï¼Œå› ä¸ºç»„ä»¶æ›´æ–°æ—¶ key å¯èƒ½å‘ç”Ÿæ”¹å˜ï¼Œrefå¼•ç”¨ä¹Ÿä¼šå˜å¥½æŒ‡å‘æ›´æ–°åçš„ DOM å…ƒç´ 
2. options å•¥æ„æ€ï¼Ÿ
3. äº‹ä»¶å±æ€§(~onClick~)ä¼šå­˜æ”¾åˆ° attrs !
4. needCastKeys ? è¿™æ˜¯åšå•¥å‘¢ resolvePropValueï¼Ÿ

#+begin_src typescript
function setFullProps(
  instance: ComponentInternalInstance,
  rawProps: Data | null,
  props: Data,
  attrs: Data
) {
  const [options, needCastKeys] = instance.propsOptions;
  if (rawProps) {
    for (const key in rawProps) {
      const value = rawProps[key];
      // key, ref ä¿ç•™ï¼Œä¸å¾€ä¸‹ä¼ 
      // å³è¿™ä¸¤ä¸ªå±æ€§ä¸ä¼šç»§æ‰¿ç»™ child
      if (isReservedProp(key)) {
        continue;
      }

      let camelKey;
      if (options && hasOwn(options, (camelKey = camelize(key)))) {
        props[camelKey] = value;
      } else if (!isEmitListener(instance.emitsOptions, key)) {
        attrs[key] = value;
      }
    }
  }

  if (needCastKeys) {
    const rawCurrentProps = toRaw(props);
    for (let i = 0; i < needCastKeys.length; i++) {
      const key = needCastKeys[i];
      props[key] = resolvePropValue(
        options!,
        rawCurrentProps,
        key,
        rawCurrentProps[key],
        instance
      );
    }
  }
}
#+end_src

*componentProps.ts -> resolvePropValue()*
1. ~props:{name: {default: v=> myname }, type: String}~

   å½“ type éå‡½æ•°æ—¶ï¼Œè¯´æ˜ ~name~ æ˜¯ä¸ªå­—ç¬¦ä¸²ç±»å‹ï¼Œä½†æ˜¯å®ƒçš„ ~default~ åˆæ˜¯ä¸ªå‡½æ•°ï¼Ÿ
   é‚£ä¹ˆè¿™ç§æƒ…å†µä¼šåœ¨è¿™é‡Œè¢«å¤„ç†ï¼Œæœ€åå°† name çš„å€¼èµ‹å€¼ä¸º ~default(props)~ æ‰§è¡Œä¹‹åçš„ç»“æœ
2. ~props:{name: {default: v=> myname }, type: Function}~

   è¿™ç§æƒ…å†µï¼Œè¯´æ˜ ~name~ æœ¬èº«å°±æ˜¯å‡½æ•°ï¼Œä¸éœ€è¦æ‰§è¡Œ defaultã€‚
3. ~props:{name: value, type: String|Number}~ æ™®é€šç±»å‹æƒ…å†µ
4. boolean ç±»å‹çš„å€¼å¤„ç†ï¼Œæœ€åéƒ½ä¼šè½¬æˆ ~true~ æˆ– ~false~

#+begin_src typescript
function resolvePropValue(
  options: NormalizedProps,
  props: Data,
  key: string,
  value: unknown,
  instance: ComponentInternalInstance
) {
  /*
   * è¿™é‡Œé¢çš„å¤„ç†æ˜¯é’ˆå¯¹ props: { name: { ... } } ç±»å‹è€Œè¨€
   * 1. é»˜è®¤å€¼çš„å¤„ç†ï¼Œ default å¯èƒ½æ˜¯å‡½æ•°æˆ–æ™®é€šç±»å‹å€¼ï¼Œå¦‚æœæ˜¯å‡½æ•°åº”è¯¥å¾—åˆ°
   * å‡½æ•°æ‰§è¡Œçš„ç»“æœä½œä¸ºå®ƒçš„å€¼ï¼Œæ³¨æ„ä¸‹é¢çš„æ£€æµ‹å‡½æ•°æ—¶å‰ç½®æ¡ä»¶æ˜¯è¯¥ç±»å‹ä¸æ˜¯å‡½æ•°ï¼Œ
   * å¦‚æœç±»å‹ä¹Ÿæ˜¯å‡½æ•°ï¼Œé»˜è®¤å€¼å°±æ˜¯è¯¥å‡½æ•°æœ¬èº«ï¼Œè€Œéæ‰§è¡Œåçš„ç»“æœå€¼
   * 2. å¸ƒå°”å€¼çš„å¤„ç†ï¼Œå€¼è½¬æˆ true or false
   */
  const opt = options[key]
  if (opt != null) {
    const hasDefault = hasOwn(opt, 'default')
    // é»˜è®¤å€¼
    if (hasDefault && value === undefined) {
      const defaultValue = opt.default
      // props: { name: { default: (props) => 'xxx' } }
      // ç±»å‹ä¸æ˜¯å‡½æ•°ï¼Ÿä½†æ˜¯é»˜è®¤å€¼æ˜¯å‡½æ•°ï¼Œæ‰§è¡Œå¾—åˆ°ç»“æœ
      if (opt.type !== Function && isFunction(defaultValue)) {
        setCurrentInstance(instance)
        value = defaultValue(props)
        setCurrentInstance(null)
      } else {
        // props: { name: { default: 'xxx' } }
        value = defaultValue
      }
    }
    // boolean casting
    if (opt[BooleanFlags.shouldCast]) {
      if (!hasOwn(props, key) && !hasDefault) {
        value = false
      } else if (
        opt[BooleanFlags.shouldCastTrue] &&
        (value === '' || value === hyphenate(key))
      ) {
        value = true
      }
    }
  }
  return value
}
#+end_src

#+begin_quote
â“ ç„¶åä¸ props æœ‰å…³çš„ propsOptions æ˜¯æ¥è‡ªå“ªé‡Œï¼Ÿ
#+end_quote

å›é¡¾ä¸‹ component render è¿‡ç¨‹ï¼š

patch -> switch default -> PatchFlags.COMPONENT ->

processComponent -> mountComponent ->

createComponentInstance -> setupComponent -> setupRenderEffect

æœ‰äº†ï¼Ÿ

æ˜¯çš„ï¼Œå°±æ˜¯å®ƒ -> ~createComponentInstance~ åˆ›å»ºç»„ä»¶å®ä¾‹ä¸­ï¼Œè¿›è¡Œäº†åˆå§‹åŒ–ï¼Œå…¶ä¸­ç»„ç»‡
çš„ç»“æ„é‡Œé¢å°±æœ‰ä¸€ä¸ª

~propsOptions: normalizePropsOptions(type, appContext)~

å’Œ

~emitsOptions: normalizeEmitsOptions(type, appContext)~

** component setup
:PROPERTIES:
:COLUMNS: %CUSTOM_ID[(Custom Id)]
:CUSTOM_ID: setup
:END:

1. setup å¦‚æœè¿”å›å€¼æ˜¯å‡½æ•°ç›´æ¥æ˜¯ render å‡½æ•°
2. setup è¿”å›å€¼æ˜¯å¯¹è±¡ï¼Œåˆ™å½“åšå’Œ data ä¸€æ ·çš„ç»„ä»¶çŠ¶æ€å¤„ç†


[[/img/vue3/runtime-core/vue-runtime-core-setup-result.jpg]]

æ›´å¤šåˆ†æè§æ³¨é‡Šï¼Œç›¸å…³ä»£ç :
#+begin_src typescript
// å¦‚æœç»„ä»¶æ˜¯ä¸ªå¯¹è±¡ï¼Œè€Œéå‡½æ•°æ˜¯ç»„ä»¶æ˜¯ä¼šç»è¿‡è¿™ä¸ªå‡½æ•°
function setupStatefulComponent(
  instance: ComponentInternalInstance,
  isSSR: boolean
) {
  const Component = instance.type as ComponentOptions;

  // 0. create render proxy property access cache
  // è¿™ä¸ªæ˜¯é’ˆå¯¹ instance ä¸Šå±æ€§çš„ get æ“ä½œç±»å‹è¿›è¡Œäº† key å€¼ç¼“å­˜
  // æ¯”å¦‚ï¼šå½“ä½ å¯¹ setupState æˆ– dataçš„å±æ€§ è¿›è¡Œäº† get è®¿é—®ï¼Œ
  // é‚£ä¹ˆè¯¥å±æ€§çš„keyå€¼ä¼šè®°å½•ä¸ºè¯¥ç±»å‹(accessCache[key]=AccessTypes.SETUP)
  // å½“ä½ ä¸‹æ¬¡å†åœ¨ instance ä¸Šè®¿é—®è¿™ä¸ªkey çš„æ—¶å€™ï¼Œé‚£ä¹ˆè¿™ä¸ªæ—¶å€™å°±ä¼šçŸ¥é“è¿™ä¸ª key
  // æ˜¯åœ¨ setupState ä¸Šï¼Œé‚£ä¹ˆå°±ç›´æ¥è¿”å› setupState[key] å°±è¡Œäº†
  // è€Œä¸ç”¨å»é‡å¤è¿›è¡Œ if...elseif...else å» setupData, data, context
  // æˆ– props åˆ¤æ–­ç„¶åå†³å®šå»å“ªä¸ªä¸Šé¢å–å€¼ï¼ŒåŠ å¿«æ±‚å€¼é€Ÿåº¦ã€‚
  // å¦‚ï¼š setupState={foo:1}, data={bar:2}
  // å–å€¼ï¼š this.foo è§¦å‘ get æ“ä½œï¼Œè¿™ä¸ªæ—¶å€™ç¬¬ä¸€æ¬¡å–å€¼çš„æ—¶å€™ä¼šè¿›è¡Œ
  // if setupState else if data æ£€æµ‹'foo'åœ¨å“ªä¸ªå¯¹è±¡ä¸Šï¼Œå‘ç°åœ¨
  // setupState ä¸Šï¼Œç„¶åå°† 'foo' ç¼“å­˜åˆ° accessCache['foo'] ='setup'
  // ä¸‹æ¬¡å†æ¬¡å–å€¼this.fooï¼Œé‚£ä¹ˆæœ¬æ¬¡å°±ä¼šç›´æ¥è¿”å› setupState['foo']
  instance.accessCache = Object.create(null);

  // 1. create public instance / render proxy
  // also mark it raw so it's never observed
  // ä»£ç†ç›®çš„ï¼šè®©å–å€¼æ“ä½œèƒ½åœ¨ setupState, data, ctx, props åŠ
  // appContext.config.globalProperties ä¸Šä¾æ¬¡æŸ¥æ‰¾å¯¹åº”çš„å±æ€§å€¼
  // ä¼˜å…ˆçº§ï¼š
  // 1. é $xxx å±æ€§ï¼Œ setupState > data > ctx > props
  // 2. this.$xxx å–å€¼ï¼Œ public å±æ€§: $,$el,$data,$props,$attrs
  //  ,$slots,$refs,$parent,$root,$emit,$options,$forceUpdate,
  //  ,$nextTick,$watch
  // > cssModule å±æ€§ vue-loader æ³¨å…¥çš„css å˜é‡
  // > instance.ctx
  // > appContext.config.globalProperties, å¦‚ï¼š this.$router
  instance.proxy = new Proxy(instance.ctx, PublicInstanceProxyHandlers);

  console.log("call setup");
  // 2. call setup()
  const { setup } = Component;
  if (setup) {
    // ä¼ é€’ç»™ setup(props, setupContext) çš„ç¬¬äºŒä¸ªå‚æ•°
    // setupContext: { attrs, slots, emit, expose }
    const setupContext = (instance.setupContext =
      setup.length > 1 ? createSetupContext(instance) : null);

    currentInstance = instance;
    // å®ä¾‹åˆå§‹åŒ–æœŸé—´ï¼Œç¦æ­¢ track æ“ä½œï¼Œget æ”¶é›†ä¾èµ–
    pauseTracking();
    // æ‰§è¡Œ setup å‡½æ•°
    const setupResult = callWithErrorHandling(
      setup,
      instance,
      ErrorCodes.SETUP_FUNCTION,
      [__DEV__ ? shallowReadonly(instance.props) : instance.props, setupContext]
    );
    resetTracking();
    currentInstance = null;

    // å¯¹setup ç»“æœå¤„ç†ï¼Œè¿”å›å€¼åªèƒ½æ˜¯å¯¹è±¡æˆ–å‡½æ•°
    if (isPromise(setupResult)) {
      if (isSSR) {
        // return the promise so server-renderer can wait on it
        return setupResult.then((resolvedResult: unknown) => {
          handleSetupResult(instance, resolvedResult, isSSR);
        });
      } else if (__FEATURE_SUSPENSE__) {
        // async setup returned Promise.
        // bail here and wait for re-entry.

        instance.asyncDep = setupResult;
      } else if (__DEV__) {
        // TODO warn
      }
    } else {
      // setup() æ‰§è¡Œç»“æœåªèƒ½æ˜¯å‡½æ•°æˆ–å¯¹è±¡
      // 1. å¦‚æœæ˜¯å¯¹è±¡ï¼Œè¿”å›å¯¹è±¡çš„æ‰€æœ‰å±æ€§å½“åšçŠ¶æ€å¤„ç†ï¼Œå’Œ data æ€§è´¨ç›¸åŒ
      // 2. å¦‚æœæ˜¯å‡½æ•°ï¼Œè§†ä¸ºç»„ä»¶çš„ render å‡½æ•°
      // å³ï¼Œæ”¯æŒåœ¨ setup ä¸­ç›´æ¥æ‰‹å†™ render å‡½æ•°
      handleSetupResult(instance, setupResult, isSSR);
    }
  } else {
    // ...
  }
}

// handleSetupResult
export function handleSetupResult(
  instance: ComponentInternalInstance,
  setupResult: unknown,
  isSSR: boolean
) {
  // 1. å¦‚æœæ˜¯å‡½æ•°å½“åšrenderå‡½æ•°å¤„ç†
  // 2. å¦‚æœæ˜¯å¯¹è±¡
  if (isFunction(setupResult)) {
    // è¿”å›å†…è” render å‡½æ•°
    if (__NODE_JS__ && (instance.type as ComponentOptions).__ssrInlineRender) {
      // SSR æœåŠ¡ç«¯æ¸²æŸ“ï¼Œæ›¿æ¢ ssrRender å‡½æ•°
      // when the function's name is `ssrRender` (compiled by SFC inline mode),
      // set it as ssrRender instead.
      instance.ssrRender = setupResult;
    } else {
      instance.render = setupResult as InternalRenderFunction;
    }
  } else if (isObject(setupResult)) {
    // è¿”å› bindingsï¼Œè¿™äº›å˜é‡å¯ä»¥ç›´æ¥åœ¨æ¨¡æ¿ä¸­ä½¿ç”¨
    // æ³¨æ„è¿™é‡Œçš„ state æ˜¯ shallow refï¼Œå³éé€’å½’ reactive çš„
    instance.setupState = proxyRefs(setupResult);
  } else {
    // warn å¿…é¡»è¿”å›å¯¹è±¡
  }
  // æœ€åå®Œæˆrenderå‡½æ•°æ£€æŸ¥
  // å¯èƒ½æ˜¯ SFCæƒ…å†µçš„ æ¨¡æ¿è¯­æ³•ï¼Œæ²¡æœ‰ç›´æ¥çš„renderå‡½æ•°ï¼Œéœ€è¦è¿›è¡Œ
  // compile æ“ä½œç”Ÿæˆ instance.rendder = Component.renderå‡½æ•°
  // render æ‰§è¡Œä¸æ˜¯è¿™é‡Œï¼Œè€Œæ˜¯åœ¨ instance.update çš„ effect å‡½æ•°ä¸­çš„
  // renderComponentRoot ä¸­
  finishComponentSetup(instance, isSSR);
}
#+end_src

æµ‹è¯•ï¼š
#+begin_src js
const { log, f, shuffle, runtime_test, renderChildren } = require(process.env
  .BLOG_DIR_VUE + "/lib.js");
import(process.env.BLOG_DIR_VUE + "/runtime-test.global.js").then(
  async ({
    h,
    render,
    nodeOps,
    serializeInner: inner,
    ref,
    nextTick,
    defineComponent,
  }) => {
    const root = nodeOps.createElement("div");
    const logRoot = () => log("root: " + inner(root));

    logRoot();
    log(">>>component setup return object");
    let props, attrs;
    try {
      const Comp = defineComponent({
        props: ["bar"],
        setup(_props, { attrs: _attrs }) {
          console.log("setup...");
          return () => {
            props = _props;
            attrs = _attrs;
          };
        },
      });
      render(h(Comp, { foo: 1, bar: 2 }), root);
      log([props, attrs]);
      render(h(Comp, { fooBar: 2, bar: 3, fooBaz: 4 }), root);
      log([props, attrs]);
      render(h(Comp, { qux: 5 }), root);
      log([props, attrs]);
    } catch (e) {
      log(e);
    }

    logRoot();
  },
  (err) => {
    console.log(err.message);
  }
);
#+end_src

#+RESULTS:
#+begin_example
undefinedroot:
>>>component setup return object
component stateful ? 4
call setup
setup...
[Function (anonymous)] render
mount component
normalize vnode
patch component
{ bar: 2 } { foo: 1 }
{ bar: 2 } { foo: 1 }
{ bar: 2 } { foo: 1 }
root:
#+end_example
** component update
:PROPERTIES:
:COLUMNS: %CUSTOM_ID[(Custom Id)]
:CUSTOM_ID: comp-update
:END:

éœ€è¦ä¿®æ”¹ç‚¹ï¼š

1. åœ¨ ~processComponent~ ä¸­å¢åŠ  ~updateComponent~ æ›´æ–°ç»„ä»¶
2. åœ¨ instance.update effect å‡½æ•°ä¸­å¢åŠ  ~updateProps()~ diff->update props


è¿™é‡Œä¸»è¦åŒ…å«äº† props çš„æ›´æ–°è§„åˆ™ï¼Œå¯¹äº children çš„ diff å’Œ update è§„åˆ™åˆ†æå¯ä»¥æŸ¥
çœ‹ [[/vue/vue-mind-map-runtime-core-2-render/#keyed-children][patchKeyedChildren diff å’Œ æ›´æ–°åŸç†åˆ†æï¼]]

ç»„ä»¶æ›´æ–°ï¼Œä»£ç æ‰§è¡Œæµç¨‹ï¼š

çŠ¶æ€å˜æ›´ -> instance.update effect æ‰§è¡Œ ->

å¦‚æœæœ‰ next vnode è§¦å‘ ~updateComponentPreRender()~ æ›´æ–° props å’Œ slots

æ‰§è¡Œ beforeUpdate hook

æ‰§è¡Œ onVnodeBeforeUpdate hook

å¾—åˆ°æ–°æ ‘ğŸŒ² nextTree = renderComponentRoot(instance)

è€æ ‘ğŸŒ² prevTree = instance.subTree

è¿›è¡Œ patch(prevTree, nextTree) æ“ä½œ

æ‰§è¡Œ updated hook å’Œ onVnodeUpdated hook

æµ‹è¯•ï¼š
#+begin_src js
const { log, f, shuffle, runtime_test, renderChildren } = require(process.env
  .BLOG_DIR_VUE + "/lib.js");
import(process.env.BLOG_DIR_VUE + "/runtime-test.global.js").then(
  async ({
    h,
    render,
    nodeOps,
    serializeInner: inner,
    ref,
    nextTick,
    defineComponent,
  }) => {
    const root = nodeOps.createElement("div");
    const logRoot = () => log("root: " + inner(root));
    let oa = { a: 1 },
      ob = { b: 1 },
      i = 0,
      j = 0;
    const defaultFn = () => (console.log(`fn called ${++i}`), oa);
    const defaultBaz = () => (console.log(`baz called ${++j}`), ob);

    let proxy;
    logRoot();
    try {
      const Comp = {
        props: {
          foo: { default: 1 },
          bar: { default: defaultFn },
          baz: { type: Function, default: defaultBaz },
        },
        render() {
          proxy = this;
        },
      };
      const print = (s) => {
        log(">>> " + s);
        const prevBar = proxy.bar;
        log("proxy.foo = " + proxy.foo);
        // å› ä¸ºæ—  typeï¼Œè€Œ default æ˜¯ä¸ªå‡½æ•°ï¼Œä¼šè¢«æ‰§è¡Œå¾—åˆ°ç»“æœ
        log("prevBar === oa: " + (prevBar === oa));
        // å› ä¸º type Function ï¼Œæ‰€ä»¥default æ˜¯ Function çš„è¯ä¸ä¼šè¢«æ‰§è¡Œ
        log("proxy.baz === defaultBaz, " + (proxy.baz === defaultBaz));
        log("proxy.bar === prevBar, " + (proxy.bar === prevBar));
      };
      render(h(Comp, { foo: 2 }), root);
      print("first");
      // update
      render(h(Comp, { foo: 3 }), root);
      print("update");
    } catch (e) {
      log(e.message);
    }
  },
  (err) => {
    console.log(err.message);
  }
);
#+end_src

#+RESULTS:
#+begin_example
undefinedroot:
{
  type: {
    props: { foo: [Object], bar: [Object], baz: [Object] },
    render: [Function: render]
  },
  shapeFlag: 4
}
fn called 1
component stateful ? 4
call setup
no setup
[Function: render] render
mount component
update effect
normalize vnode
patch component
{ type: Symbol(Comment), shapeFlag: 0 }
>>> first
proxy.foo = 2
prevBar === oa: true
proxy.baz === defaultBaz, true
proxy.bar === prevBar, true
{
  type: {
    props: { foo: [Object], bar: [Object], baz: [Object] },
    render: [Function: render],
    __props: [ [Object], [Array] ]
  },
  shapeFlag: 4
}
update component
should update component
has changed props
should update component....
normal update
update effect
component update
update comp pre render
normalize vnode
Cannot read property 'parentNode' of null
#+end_example

#+begin_quote
â“ æ²¡æœ‰è§¦å‘ ~instance.update~ ?

[[https://github.com/gcclll/stb-vue-next/commit/3771bfb42adaee8d3f84388d3d8d654ca44678fd][fix: props update invalid Â· gcclll/stb-vue-next@3771bfb]]

ä¿®å¤åï¼Œå›å»é‡æ–°æµ‹è¯•ã€‚
#+end_quote

FIX å¢åŠ ä»£ç ï¼š
#+begin_src typescript
const updateComponent = (n1: VNode, n2: VNode, optimized: boolean) => {
  console.log("update component");
  const instance = (n2.component = n1.component)!;
  if (shouldUpdateComponent(n1, n2, optimized)) {
    console.log("should update component....");
    if (
      __FEATURE_SUSPENSE__ &&
      instance.asyncDep && // async setup
      instance.asyncResolved
    ) {
      // ...
      return;
    } else {
      // æ–°å¢ä»£ç ã€‹ã€‹ã€‹ã€‹ã€‹ã€‹ã€‹ã€‹
      // æ­£å¸¸æ›´æ–°
      instance.next = n2;
      // è€ƒè™‘åˆ° child ç»„ä»¶å¯èƒ½æ­£åœ¨é˜Ÿåˆ—ä¸­æ’é˜Ÿï¼Œç§»é™¤å®ƒé¿å…
      // åœ¨åŒä¸€ä¸ª flush tick é‡å¤æ›´æ–°åŒä¸€ä¸ªå­ç»„ä»¶
      // å½“ä¸‹ä¸€æ¬¡æ›´æ–°æ¥åˆ°æ—¶ï¼Œä¹‹å‰çš„ä¸€æ¬¡æ›´æ–°å–æ¶ˆï¼Ÿ
      invalidateJob(instance.update);
      // instance.update æ˜¯åœ¨ setupRenderEffect ä¸­
      // å®šä¹‰çš„ä¸€ä¸ª reactive effect runner
      // ä¸»åŠ¨è§¦å‘æ›´æ–°
      instance.update();
    }
    return;
  } else {
    // ...
  }
};
#+end_src

#+begin_quote
â“ Cannot read property 'parentNode' of null

è¿™ä¸ªæŠ¥é”™å‘ç”Ÿåœ¨ instance.update effect çš„ else æ›´æ–°ç»„ä»¶ä¸­ï¼Œ

patch(... hostParentNode(prevTree.el!)!, ...)

çš„æ—¶å€™ï¼Œå»å–å€¼ prevTree.el å¾—åˆ°çš„æ˜¯ç©ºå€¼ï¼Œè¿›å…¥ hostParentNode è°ƒç”¨
node.parentNode æŠ¥é”™çš„ã€‚

è¿™é‡Œä¸ºä»€ä¹ˆ prevTree.el æ˜¯ null ? æ›´æ–°çš„è¯ä¹‹å‰çš„ node ä¸åº”è¯¥å·²ç»åŠ è½½å¥½äº†å—ï¼Ÿ
#+end_quote
** component slots
:PROPERTIES:
:COLUMNS: %CUSTOM_ID[(Custom Id)]
:CUSTOM_ID: comp-slots
:END:

[[https://github.com/gcclll/stb-vue-next/commit/a7884300c10c3cb3f0f5812ff2a6621651421e39][feat(add): init&update slots Â· gcclll/stb-vue-next@a788430]]

ä¿®æ”¹ç‚¹ï¼š


1. åˆå§‹åŒ–ï¼Œ ~setupComponent()~ ä¸­çš„ ~initSlots()~
2. ~updateComponent()~ -> ~updateComponentPreRender()~ ä¸­ ~updateSlots()~ æ›´æ–° slots


å¯¹åº”åŠ¨ä½œï¼š init -> update

å¯¹åº”ç»„ä»¶é˜¶æ®µï¼š åˆå§‹åŒ–(initSlots()) -> æ›´æ–°(updateSlots())

*** åˆå§‹åŒ–(~initSlots()~)ï¼š
:PROPERTIES:
:COLUMNS: %CUSTOM_ID[(Custom Id)]
:CUSTOM_ID: init-slots
:END:

#+begin_src typescript
export const initSlots = (
  instance: ComponentInternalInstance,
  children: VNodeNormalizedChildren
) => {
  if (instance.vnode.shapeFlag & ShapeFlags.SLOTS_CHILDREN) {
    const type = (children as RawSlots)._
    if (type) {
      instance.slots = children as InternalSlots
      // make compiler marker non-enumerable
      def(children as InternalSlots, '_', type)
    } else {
      normalizeObjectSlots(children as RawSlots, (instance.slots = {}))
    }
  } else {
    instance.slots = {}
    if (children) {
      normalizeVNodeSlots(instance, children)
    }
  }
  def(instance.slots, InternalObjectKey, 1)
}
#+end_src

è¦åˆ†ææ•´ä¸ªï¼Œéœ€è¦å›é¡¾ä¸‹ [[/vue/vue-mind-map-runtime-core-1/#normalize-children][normalizeChildren(vnode, children)]] å¤„ç†é€»è¾‘ï¼Œè¦ææ¸…æ¥šä»€ä¹ˆ
æƒ…å†µä¸‹ä¼šæ˜¯ ~SLOTS_CHILDREN~ ã€‚

æ ¹æ® ~normalizeChildren()~ çš„å®ç°ä¸­ï¼Œå¯çŸ¥éœ€è¦æ»¡è¶³ä¸‹é¢å‡ ä¸ªæ¡ä»¶ï¼š

#+begin_src js
if (isObject(vnode.children)) {
  if (isElement(vnode.shapeFlag) || isTELEPORT(vnode.shapeFlag)) {
    // default slot
  } else {
    // é ELEMENT æˆ– TELEPORT ç±»å‹
    // å¦‚ï¼š <Comp><template v-slot:named><div/></template></Comp>
    // children åªæœ‰ä¸€ä¸ª template ä¼šè¢«è§£ææˆä¸€ä¸ª vnode å¯¹è±¡
    // ä¸” vnode type æ˜¯ template
    type = ShapeFlags.SLOTS_CHILDREN;
  }
} else if (isFunction(vnode.children)) {
  // children æ˜¯ä¸ªå‡½æ•°
  // å‡½æ•°å¼ç»„ä»¶ Comp = { render() {
  //   return h('div', null, () => h('div') /* slot */)
  // }}
  type = ShapeFlags.SLOTS_CHILDREN;
}
#+end_src

1. ~children = { _: ... }~ å†…éƒ¨æ’æ§½ï¼Ÿ

2. normalizeObjectSlots: children æ˜¯å¯¹è±¡ç±»å‹ï¼š

    ~{named: slotFn1, default: slotFn2 }~

    éå†æ‰€æœ‰ key-value =>

    (*æ¨è*)å¦‚æœ value æ˜¯å‡½æ•°éœ€è¦å°† slotFn ç”¨ withCtx å°è£…ä¸€å±‚ï¼Œè®©å…¶åœ¨å½“å‰å®ä¾‹çš„ä¸Šä¸‹æ–‡ä¸­æ­£ç¡®âœ…æ‰§è¡Œã€‚
    #+begin_src typescript
     const normalizeSlot = (
       key: string,
       rawSlot: Function,
       ctx: ComponentInternalInstance | null | undefined
     ): Slot =>
       withCtx((props: any) => {
         // warn: åœ¨ Render å‡½æ•°å¤–æ‰§è¡Œäº† slot function
         return normalizeSlotValue(rawSlot(props));
       }, ctx);
    #+end_src

    (*ä¸æ¨è*)å¦‚æœ value ä¸æ˜¯å‡½æ•°ï¼Œç»è¿‡
    #+begin_src typescript
    const normalizeSlotValue = (value: unknown): VNode[] =>
    isArray(value)
        ? value.map(normalizeVNode)
        : [normalizeVNode(value as VNodeChild)]
    #+end_src

    å¤„ç†ä¹‹åè½¬æˆå‡½æ•°èµ‹å€¼ ~slots[key] = () => normalized~

    æœ€ç»ˆéƒ½æ˜¯å°† slot value è½¬æˆä¸€ä¸ªå‡½æ•°ä¿å­˜åˆ° ~instance.slots{}~ ä¸­

3. é ~SLOTS_CHILDREN~ ï¼Œé‚£åªæœ‰ä¸€ç§æƒ…å†µ

   children ä¸­æ²¡æœ‰ ~<template v-slot:named ...>~ ï¼Œæ­¤æ—¶å®ƒæ‰€æœ‰çš„ child éƒ½ä¼šè¢«å½“åš
   é»˜è®¤æ’æ§½æ¥å¤„ç†ã€‚

   #+begin_src typescript
   const normalizeVNodeSlots = (
     instance: ComponentInternalInstance,
     children: VNodeNormalizedChildren
   ) => {
     const normalized = normalizeSlotValue(children);
     instance.slots.default = () => normalized;
   };
   #+end_src

   å¦‚ï¼š
   #+begin_src js
   const { log, shuffle, runtime_test, renderChildren } = require(process.env
     .BLOG_DIR_VUE + "/lib.js");
   import(process.env.BLOG_DIR_VUE + "/runtime-test.global.js").then(
     async ({ h, createVNode: c }) => {
       log.br();
       const Comp = { template: "<div/>" };
       const slot = () => {};
       const node = h(Comp, slot);
       log(">>> å‡½æ•°ä½œä¸º children è§£æä¸ºé»˜è®¤æ’æ§½");
       log.f(node, ["children", "type"]);
       log(node.children);
     }
   );
    #+end_src

   #+RESULTS:
   : undefined
   :
   : >>> å‡½æ•°ä½œä¸º children è§£æä¸ºé»˜è®¤æ’æ§½
   : {
   :   type: { template: '<div/>' },
   :   children: { default: [Function: slot], _ctx: null }
   : }
   : { default: [Function: slot], _ctx: null }

*** æ›´æ–°(~updateSlots()~)
:PROPERTIES:
:COLUMNS: %CUSTOM_ID[(Custom Id)]
:CUSTOM_ID: update-slots
:END:

æ›´æ–°æ’æ§½æ­¥éª¤ï¼š

1. åˆå¹¶ instance.slots å’Œ children
2. ç„¶ååˆ é™¤ children ä¸­æ²¡æœ‰çš„æ’æ§½

#+begin_src typescript
export const updateSlots = (
  instance: ComponentInternalInstance,
  children: VNodeNormalizedChildren
) => {
  const { vnode, slots } = instance;
  let needDeletionCheck = true;
  let deletionComparisonTarget = EMPTY_OBJ;
  console.log("update slots");
  // children æ˜¯ å‡½æ•°æˆ–å¯¹è±¡ç±»å‹(éæ•°ç»„)
  if (vnode.shapeFlag & ShapeFlags.SLOTS_CHILDREN) {
    const type = (children as RawSlots)._;
    if (type) {
      console.log("update slots type");
      // compiled slots.
      if (__DEV__ && isHmrUpdating) {
        // TODO
      } else if (type === SlotFlags.STABLE) {
        // compiled AND stable
        // ä¸éœ€è¦æ›´æ–°ï¼Œè·³è¿‡ slots åˆ é™¤æ“ä½œ
        needDeletionCheck = false;
      } else {
        // compiled but dynamic (v-if/v-for on slots)
        // update slots, but skip normalization
        extend(slots, children as Slots);
      }
    } else {
      console.log("update slots no type");
      needDeletionCheck = !(children as RawSlots).$stable;
      normalizeObjectSlots(children as RawSlots, slots);
    }
    // å¯¹è±¡ç±»å‹ç›´æ¥åˆå¹¶ï¼Œè¿™é‡Œè®°å½•éœ€è¦è¿›è¡Œåˆ é™¤æ“ä½œçš„å¯¹è±¡ï¼Œchildren
    // ä¸Šé¢åªæ˜¯è¿›è¡Œäº†ç®€å•çš„å¯¹è±¡åˆå¹¶æ“ä½œ
    // å¦‚ï¼š slots={a,b,d}, children = {a,b,c}
    // åˆå¹¶ä¹‹åï¼š slots={a,b,c,d},åé¢éœ€è¦åˆ é™¤çš„æ˜¯ d è¿™ä¸ªæ’æ§½
    deletionComparisonTarget = children as RawSlots;
  } else if (children) {
    // <Comp>...è¿™é‡Œæ²¡æœ‰ <template #named ...> æƒ…å†µ</Comp>
    // <Comp> é‡Œé¢çš„æ‰€æœ‰å†…å®¹éƒ½ä¼šè¢«å½“åšé»˜è®¤æ’æ§½æ¥è§£æ
    console.log("update slots children");
    // non slot object children (direct value)
    // passed to a component
    // å½“åšé»˜è®¤æ’æ§½æ¥å¤„ç†ï¼Œè§£æåï¼š slots.default = () => normalized
    normalizeVNodeSlots(instance, children);
    // è¿™é‡Œç›®çš„æ˜¯ä¸ºäº†åªä¿ç•™ default å…¶ä»–éƒ½éœ€è¦åˆ é™¤
    deletionComparisonTarget = { default: 1 };
  }

  console.log({ needDeletionCheck });
  // delete stale slots
  // åˆ é™¤æ—§çš„ slots
  if (needDeletionCheck) {
    for (const key in slots) {
      // é `_` å†…éƒ¨æ’æ§½ï¼Œä¸”ä¸å†æ–°çš„ children ä¸­çš„
      if (!isInternalKey(key) && !(key in deletionComparisonTarget)) {
        delete slots[key];
      }
    }
  }
};
#+end_src
** props tests

ä¼ å…¥çš„ rawProps å’Œç»„ä»¶è‡ªèº«çš„ props ç»è¿‡å¤„ç†ä¹‹å(setFullProps()) ä¼šå°† rawProps æ ¹
æ®ä¸€å®šè§„åˆ™åˆ†æ´¾åˆ°ç»„ä»¶ props æˆ– attrs ä¸­å»ã€‚

è¿™é‡Œçš„ rawProps ä»£è¡¨æ˜¯ parent åœ¨æ¸²æŸ“å­ç»„ä»¶çš„æ—¶å€™ä¼ é€’ç»™å®ƒçš„ props ï¼Œå¦‚ï¼š

~render(h(Child, { foo:1, bar:2}),root)~

ä¸­çš„ ~{foo:1,bar:2}~ å³ parent propsï¼Œç„¶åç»„ä»¶å¯ä»¥å®šä¹‰è‡ªèº«çš„ props å±æ€§ï¼š

~defineComponent({ props: ['foo'] })~ æ„å‘³ç€ï¼Œè¯¥å­ç»„ä»¶åªæ¥å— ~'foo'~ ä½œä¸º props
è€Œå…¶ä»–çš„ä¼šè¢«è§£ææˆ attrs ã€‚

component props æµ‹è¯•ï¼š

#+begin_src js
const { log, f, shuffle, runtime_test, renderChildren } = require(process.env
  .BLOG_DIR_VUE + "/lib.js");
import(process.env.BLOG_DIR_VUE + "/runtime-test.global.js").then(
  async ({
    h,
    render,
    nodeOps,
    serializeInner: inner,
    ref,
    nextTick,
    defineComponent,
  }) => {
    const root = nodeOps.createElement("div");
    const logRoot = () => log("root: " + inner(root));

    logRoot();
    log(">>>stateful");
    let props, attrs, proxy;
    try {
      const Comp = defineComponent({
        props: ["fooBar", "barBaz", "foo-baz"],
        render() {
          console.log("comp render");
          props = this.$props;
          attrs = this.$attrs;
          proxy = this;
        },
      });

      render(h(Comp, { fooBar: 1, bar: 2, fooBaz: 3 }), root);
    } catch (e) {
      log(e);
    }

    console.log("proxy.fooBar=" + proxy.fooBar);
    log([props, attrs]);
    logRoot();
  },
  (err) => {
    console.log(err.message);
  }
);
#+end_src

#+RESULTS:
#+begin_example
undefinedroot:
>>>stateful
{
  type: {
    props: [ 'fooBar', 'barBaz', 'foo-baz' ],
    render: [Function: render]
  },
  shapeFlag: 4
}
component stateful ? 4
call setup
no setup
[Function: render] render
mount component
update effect
normalize vnode
comp render
patch component
{ type: Symbol(Comment), shapeFlag: 0 }
proxy.fooBar=1
{ fooBar: 1, fooBaz: 3 } { bar: 2 }
root:
#+end_example
** component unmount

[[https://github.com/gcclll/stb-vue-next/commit/79c5061781235abffd5d744781857fd3cfa0008a][feat(add): add unmount component Â· gcclll/stb-vue-next@79c5061]]

ä¸»è¦å·¥ä½œï¼š

1. æ‰§è¡Œ ~beforeUnmount~ å‘¨æœŸå‡½æ•°
2. åœæ‰æ‰€æœ‰ effects ä¾èµ–
3. æ£€æŸ¥ update å‡½æ•°ï¼Œå¤„ç†åœ¨å¼‚æ­¥ update ä¹‹å‰æ‰§è¡Œäº† unmount
4. åœ¨ post queue ä¸­æ‰§è¡Œ ~unmounted~ å‘¨æœŸå‡½æ•°
5. åœ¨ post queue ä¸­æ ‡è®° ~instance.isUnmounted=true~ æ ‡è®°ç»„ä»¶å·²ç»å¸è½½äº†


#+begin_quote
ä¸‰ç§é˜Ÿåˆ—ä»»åŠ¡ï¼Œ ~pre, post, job~ æ‰§è¡Œé¡ºåºï¼š pre > job > postï¼Œè¯¦æƒ…æŸ¥çœ‹

[[/vue/vue-mind-map-runtime-core-1/#scheduler][scheduler ä»»åŠ¡è°ƒåº¦æœºåˆ¶]]
#+end_quote

#+begin_src typescript
const unmountComponent = (
  instance: ComponentInternalInstance,
  parentSuspense: SuspenseBoundary | null,
  doRemove?: boolean
) => {
  const { bum, effects, update, subTree, um } = instance;
  // beforeUnmount hook
  if (bum) {
    invokeArrayFns(bum);
  }
  if (effects) {
    for (let i = 0; i < effects.length; i++) {
      stop(effects[i]);
    }
  }

  // update may be null if a component is unmounted before its async
  // setup has resolved.
  if (update) {
    stop(update);
    unmount(subTree, instance, parentSuspense, doRemove);
  }

  // unmounted hook
  if (um) {
    queuePostRenderEffect(um, parentSuspense);
  }
  queuePostRenderEffect(() => {
    instance.isUnmounted = true;
  }, parentSuspense);

  // TODO suspense
};
#+end_src
** normalize emits options

[[https://github.com/gcclll/stb-vue-next/commit/b918dde38055d7e6faf6e2371647f805c10f2721][feat(add): props event init Â· gcclll/stb-vue-next@b918dde]]

** é—®é¢˜

*** TypeError: Cannot read property 'allowRecurse' of null
:PROPERTIES:
:COLUMNS: %CUSTOM_ID[(Custom Id)]
:CUSTOM_ID: q-allow-recurse
:END:

#+begin_example
TypeError: Cannot read property 'allowRecurse' of null
    at createReactiveEffect (/Users/simon/blog/cheng92.com/static/js/vue/runtime-test.global.js:251:39)
    at effect (/Users/simon/blog/cheng92.com/static/js/vue/runtime-test.global.js:199:22)
    at setupRenderEffect (/Users/simon/blog/cheng92.com/static/js/vue/runtime-test.global.js:2738:29)
    at mountComponent (/Users/simon/blog/cheng92.com/static/js/vue/runtime-test.global.js:2733:11)
    at processComponent (/Users/simon/blog/cheng92.com/static/js/vue/runtime-test.global.js:2724:19)
    at patch (/Users/simon/blog/cheng92.com/static/js/vue/runtime-test.global.js:2616:23)
    at render (/Users/simon/blog/cheng92.com/static/js/vue/runtime-test.global.js:3099:15)
    at /private/var/folders/1n/xw58p9v90tn42m87q527fvgr0000gn/T/babel-orafVD/js-script-Vmw0ga:29:5
#+end_example

å› ä¸ºå®ç°é—®é¢˜ï¼š

#+begin_src typescript
instance.update = effect(function componentEffect() {
      // ç›‘å¬æ›´æ–°
      if (!instance.isMounted) {
        // è¿˜æ²¡åŠ è½½å®Œæˆï¼Œå¯èƒ½æ˜¯ç¬¬ä¸€æ¬¡ mount æ“ä½œ
        // TODO
      } else {
        // TODO
      }
    }, __DEV__ ? /* TODO */ (null as any) : prodEffectOptions)
#+end_src

æ–‡å­—å†…çš„æµ‹è¯•æ˜¯åŸºäº node development ç¯å¢ƒæµ‹è¯•çš„ï¼Œè¿™é‡Œ effect options æ˜¯ null æ‰€ä»¥
æŠ¥é”™ã€‚

[[https://github.com/gcclll/stb-vue-next/commit/63675a485bf8223b3be8d76fa3ce28d397d8e726][fix: effect null options Â· gcclll/stb-vue-next@63675a4]]
* processText|Comment|Static
:PROPERTIES:
:COLUMNS: %CUSTOM_ID[(Custom Id)]
:CUSTOM_ID: render-text
:END:

[[https://github.com/gcclll/stb-vue-next/commit/636e87099f5e1322cf2af0aeb82614e2fa6a7fe3][feat(add): processText updte Â· gcclll/stb-vue-next@636e870 Â· GitHub]]

æœ¬èŠ‚åŒ…å«(ä¸»è¦æºç ï¼Œæ²¡å•¥å¥½åˆ†æçš„)ï¼š

1. æ–‡æœ¬èŠ‚ç‚¹
2. æ³¨é‡ŠèŠ‚ç‚¹
3. é™æ€èŠ‚ç‚¹


** Text
:PROPERTIES:
:COLUMNS: %CUSTOM_ID[(Custom Id)]
:CUSTOM_ID: Text
:END:

#+begin_src typescript
const processText: ProcessTextOrCommentFn = (n1, n2, container, anchor) => {
  if (n1 == null /* old */) {
    // æ–°èŠ‚ç‚¹ï¼Œæ’å…¥å¤„ç†
    hostInsert(
      (n2.el = hostCreateText(n2.children as string)),
      container,
      anchor
    );
  } else {
    // has old vnode, need to diff
    const el = (n2.el = n1.el!);
    if (n2.children !== n1.children) {
      hostSetText(el, n2.children as string);
    }
  }
};
#+end_src

å› ä¸ºåœ¨ compiler-core parse é˜¶æ®µçš„æ–‡æœ¬å¤„ç†ä¸­ï¼Œå¦‚æœæ˜¯å“é“ƒçš„æ–‡æœ¬èŠ‚ç‚¹ä¼šè¢«åˆå¹¶ï¼Œå¦‚ï¼š

~<div>{{ text1 }} {{ text2 }}</div>~ æœ€ç»ˆä¼šåˆå¹¶ï¼š

~<div>{{ text1 + ' ' + text2 }}</div>~ æœ€ç»ˆæ›¿æ¢çš„æ˜¯ ~<div/>~ æ•´ä¸ªå†…å®¹ã€‚

** Comment
:PROPERTIES:
:COLUMNS: %CUSTOM_ID[(Custom Id)]
:CUSTOM_ID: Comment
:END:

[[https://github.com/gcclll/stb-vue-next/commit/448936662634690c5d2e5596e31d066b0f96cd63][feat(add): process comment node Â· gcclll/stb-vue-next@4489366 Â· GitHub]]

#+begin_src typescript
const processCommentNode: ProcessTextOrCommentFn = (
    n1,
    n2,
    container,
    anchor
  ) => {
    if (n1 == null) {
      hostInsert(
        (n2.el = hostCreateComment((n2.children as string) || '')),
        container,
        anchor
      )
    } else {
      // there's no support for dynamic comments
      n2.el = n1.el
    }
  }

#+end_src

** Static
:PROPERTIES:
:COLUMNS: %CUSTOM_ID[(Custom Id)]
:CUSTOM_ID: Static
:END:

patch -> case Static:

#+begin_src typescript
// case Static:
if (n1 == null) {
  mountStaticNode(n2, container, anchor, isSVG);
} else if (__DEV__) {
  patchStaticNode(n1, n2, container, isSVG);
}
// break
#+end_src

æ²¡æœ‰ old vnode -> mount

æœ‰ old node -> patch

*mount*:
#+begin_src typescript
const mountStaticNode = (
  n2: VNode,
  container: RendererElement,
  anchor: RendererNode | null,
  isSVG: boolean
) => {
  // static nodes are only present when used with compiler-dom/runtime-dom
  // which guarantees presence of hostInsertStaticContent.
  [n2.el, n2.anchor] = hostInsertStaticContent!(
    n2.children as string,
    container,
    anchor,
    isSVG
  );
};
#+end_src

mount æ—¶ç”¨åˆ°çš„ ~hostInsertStaticContent()~ æ˜¯åœ¨ runtime-dom åŒ…ä¸­å®ç°çš„ï¼Œå…ˆé¢„è§ˆä¸‹
ä»£ç ï¼š

#+begin_src typescript
function insertStaticContent(content, parent, anchor, isSVG) {
  const temp = isSVG
    ? tempSVGContainer || (tempSVGContainer = doc.createElementNS(svgNS, "svg"))
    : tempContainer || (tempContainer = doc.createElement("div"));
  temp.innerHTML = content;
  const first = temp.firstChild as Element;
  let node: Element | null = first;
  let last: Element = node;
  while (node) {
    last = node;
    nodeOps.insert(node, parent, anchor);
    node = temp.firstChild as Element;
  }
  return [first, last];
}
#+end_src

å¯ä»¥çœ‹åˆ° ~temp.innerHTML = content~ ä¸€ä¸ªç®€å•çš„å†…å®¹å…¨æ›¿æ¢æ“ä½œã€‚

*patchStaticNode*: å› ä¸ºé™æ€èŠ‚ç‚¹åœ¨ç”Ÿäº§ç¯å¢ƒä¸­ä¼šè¢«æå‡ï¼Œé‡ç”¨ï¼Œå› æ­¤ä¸å­˜åœ¨ patch é˜¶æ®µã€‚
#+begin_src typescript
const patchStaticNode = (
  n1: VNode,
  n2: VNode,
  container: RendererElement,
  isSVG: boolean
) => {
  // static nodes are only patched during dev for HMR
  if (n2.children !== n1.children) {
    const anchor = hostNextSibling(n1.anchor!);
    // remove existing
    removeStaticNode(n1);
    // insert new
    [n2.el, n2.anchor] = hostInsertStaticContent!(
      n2.children as string,
      container,
      anchor,
      isSVG
    );
  } else {
    n2.el = n1.el;
    n2.anchor = n1.anchor;
  }
};
#+end_src

*moveStaticNode*: åœ¨ diff -> update é˜¶æ®µ move() ä¸­è§¦å‘
#+begin_src typescript
const moveStaticNode = (
  { el, anchor }: VNode,
  container: RendererElement,
  nextSibling: RendererNode | null
) => {
  let next;
  while (el && el !== anchor) {
    next = hostNextSibling(el);
    hostInsert(el, container, nextSibling);
    el = next;
  }
  hostInsert(anchor!, container, nextSibling);
};
#+end_src

*removeStaticNode*: ~remove()~ ä¸­è§¦å‘
#+begin_src typescript
const removeStaticNode = ({ el, anchor }: VNode) => {
  let next;
  while (el && el !== anchor) {
    next = hostNextSibling(el);
    hostRemove(el);
    el = next;
  }
  hostRemove(anchor!);
};
#+end_src
* processFragment
:PROPERTIES:
:COLUMNS: %CUSTOM_ID[(Custom Id)]
:CUSTOM_ID: render-fragment
:END:

Fragment çš„æƒ…å†µï¼š children æœ‰å¤šä¸ª child çš„æ—¶å€™ï¼Œä¼šç”¨ä¸€ä¸ª fragment äº‹å…ˆåŒ…èµ·æ¥ã€‚

[[/img/vue3/runtime-core/vue-runtime-core-render-fragment.svg]]

~STABLE_FRAGMENT~ æƒ…å†µï¼š

1. ~v-if~

   é¦–å…ˆè¦æ»¡è¶³ children.length !== 1 å³æœ‰ä¸€ä¸ªä»¥ä¸Šçš„ children, å¦‚ï¼š

   ~<div><p/><p/></div>~

   æˆ–è€…éç¬¬ä¸€ä¸ª child ELEMENT ç±»å‹ï¼Œå¦‚ï¼š

   ~<div><Comp/></div>~

   å…¶è¦æ»¡è¶³ ~(children.length === 1 && firstChild.type === NodeTypes.FOR)~ å¦‚ï¼š

   ~<div v-for="item in list"><p/></div>~

   æ‰ä¼šè¢«å½“åš ~PatchFlags.STABLE_FRAGMENT~

   #+begin_src typescript
    // vIf.ts
    const needFragmentWrapper =
      children.length !== 1 || firstChild.type !== NodeTypes.ELEMENT;
    if (needFragmentWrapper) {
      if (children.length === 1 && firstChild.type === NodeTypes.FOR) {
        // ...
      } else {
        return createVNodeCall(
          // ...
          PatchFlags.STABLE_FRAGMENT +
            (__DEV__ ? ` /* ${PatchFlagNames[PatchFlags.STABLE_FRAGMENT]} */` : ``),
          // ...
        );
      }
    }
   #+end_src

2. ~v-for~

   #+begin_src typescript
    // vFor.ts
    const isStableFragment =
        forNode.source.type === NodeTypes.SIMPLE_EXPRESSION &&
        forNode.source.constType > 0
      const fragmentFlag = isStableFragment
        ? PatchFlags.STABLE_FRAGMENT
        : keyProp
          ? PatchFlags.KEYED_FRAGMENT
          : PatchFlags.UNKEYED_FRAGMENT
   #+end_src


æºç ï¼š
#+begin_src typescript
const processFragment = (
    n1: VNode | null,
    n2: VNode,
    container: RendererElement,
    anchor: RendererNode | null,
    parentComponent: ComponentInternalInstance | null,
    parentSuspense: SuspenseBoundary | null,
    isSVG: boolean,
    optimized: boolean
  ) => {
    const fragmentStartAnchor = (n2.el = n1 ? n1.el : hostCreateText(''))!
    const fragmentEndAnchor = (n2.anchor = n1 ? n1.anchor : hostCreateText(''))!

    let { patchFlag, dynamicChildren } = n2
    if (patchFlag > 0) {
      optimized = true
    }

    if (__DEV__ && isHmrUpdating) {
      // HMR updated, force full diff
      patchFlag = 0
      optimized = false
      dynamicChildren = null
    }

    if (n1 == null) {
      hostInsert(fragmentStartAnchor, container, anchor)
      hostInsert(fragmentEndAnchor, container, anchor)
      // fragment çš„ children åªä¼šæ˜¯ array children
      // å› ä¸ºä»–ä»¬è¦ä¹ˆæ˜¯é€šè¿‡ compiler ç”Ÿæˆçš„ï¼Œè¦ä¹ˆæ˜¯ç”±æ•°ç»„åˆ›å»ºçš„
      mountChildren(
        n2.children as VNodeArrayChildren,
        container,
        fragmentEndAnchor,
        parentComponent,
        parentSuspense,
        isSVG,
        optimized
      )
    } else {
      if (
        patchFlag > 0 &&
        patchFlag & PatchFlags.STABLE_FRAGMENT &&
        dynamicChildren &&
        // #2715 the previous fragment could've been a BAILed one as a result
        // of renderSlot() with no valid children
        n1.dynamicChildren
      ) {
        // a stable fragment (template root or <template v-for>) doesn't need to
        // patch children order, but it may contain dynamicChildren.
        patchBlockChildren(
          n1.dynamicChildren,
          dynamicChildren,
          container,
          parentComponent,
          parentSuspense,
          isSVG
        )
        if (__DEV__ && parentComponent && parentComponent.type.__hmrId) {
          traverseStaticChildren(n1, n2)
        } else if (
          // #2080 if the stable fragment has a key, it's a <template v-for> that may
          //  get moved around. Make sure all root level vnodes inherit el.
          // #2134 or if it's a component root, it may also get moved around
          // as the component is being moved.
          n2.key != null ||
          (parentComponent && n2 === parentComponent.subTree)
        ) {
          traverseStaticChildren(n1, n2, true /* shallow */)
        }
      } else {
        // keyed / unkeyed, or manual fragments.
        // for keyed & unkeyed, since they are compiler generated from v-for,
        // each child is guaranteed to be a block so the fragment will never
        // have dynamicChildren.
        patchChildren(
          n1,
          n2,
          container,
          fragmentEndAnchor,
          parentComponent,
          parentSuspense,
          isSVG,
          optimized
        )
      }
    }
  }
#+end_src
* TELEPORT
:PROPERTIES:
:COLUMNS: %CUSTOM_ID[(Custom Id)]
:CUSTOM_ID: teleport
:END:

[[https://github.com/gcclll/stb-vue-next/commit/0fcfa324ac72cf74ff24677bfa2305dac2dde6ac][feat(init): Teleport Â· gcclll/stb-vue-next@0fcfa32 Â· GitHub]]

[[/img/vue3/runtime-core/vue-runtime-core-render-teleport.svg]]

** æ–°å¢ä»£ç :

*TeleportImpl*: ç»„ä»¶æ¨¡æ¿
#+begin_src typescript
export const TeleportImpl = {
  __isTeleport: true,
  process() {},
  remove() {},
  move: moveTeleport,
  hydrate: hydrateTeleport
}
#+end_src

*resolveTarget*: æ ¹æ®é€‰æ‹©å™¨æ‰¾åˆ°ç›®æ ‡å…ƒç´ 
#+begin_src typescript
const resolveTarget = <T = RendererElement>(
  props: TeleportProps | null,
  select: RendererOptions['querySelector']
): T | null => {
  const targetSelector = props && props.to
  if (isString(targetSelector)) {
    if (!select) {
      // æ— æ•ˆé€‰æ‹©å™¨
      return null
    } else {
      const target = select(targetSelector)
      // Teleport è®¾ç½®å¤±è´¥
      return target as any
    }
  } else {
    // æ— æ•ˆçš„ Teleport ç›®æ ‡
    return targetSelector as any
  }
}
#+end_src

*moveTeleport*: æ‰§è¡Œç§»åŠ¨
#+begin_src typescript
function moveTeleport(
  vnode: VNode,
  container: RendererElement,
  parentAnchor: RendererNode | null,
  { o: { insert }, m: move }: RendererInternals,
  moveType: TeleportMoveTypes = TeleportMoveTypes.REORDER
) {
  // TODO
}
#+end_src

*hydrateTeleport*:
#+begin_src typescript
function hydrateTeleport(
  node: Node,
  vnode: TeleportVNode,
  parentComponent: ComponentInternalInstance | null,
  parentSuspense: SuspenseBoundary | null,
  optimized: boolean,
  {
    o: { nextSibling, parentNode, querySelector }
  }: RendererInternals<Node, Element>,
  hydrateChildren: (
    node: Node | null,
    vnode: VNode,
    container: Element,
    parentComponent: ComponentInternalInstance | null,
    parentSuspense: SuspenseBoundary | null,
    optimized: boolean
  ) => Node | null
): Node | null {
  return vnode.anchor && nextSibling(vnode.anchor as Node)
}
#+end_src

å¯¼å‡ºç»„ä»¶ ~Teleport~ï¼š
#+begin_src typescript
// Force-casted public typing for h and TSX props inference
export const Teleport = (TeleportImpl as any) as {
  __isTeleport: true
  new (): { $props: VNodeProps & TeleportProps }
#+end_src

** process()
:PROPERTIES:
:COLUMNS: %CUSTOM_ID[(Custom Id)]
:CUSTOM_ID: teleport-process
:END:

#+begin_src typescript
function process(/*çœç•¥å‚æ•°*/) {
  // ...

  const disabled = isTeleportDisabled(n2.props);
  const { shapeFlag, children } = n2;

  if (n1 == null) {
    // insert anchors in the main view
    // <container><placeholder/><anchor/></container>
    insert(placeholder, container, anchor);
    // <container><main-anchor/><anchor/></container>
    insert(mainAnchor, container, anchor);
    // æ ¹æ®é€‰æ‹©å™¨ <Teleport to="selector"/> selector
    // æ‰¾åˆ°ç›®æ ‡ DOM å…ƒç´ 
    const target = (n2.target = resolveTarget(n2.props, querySelector));
    // <target><!-- '' --></target>ï¼Œç”¨æ¥ä½œä¸ºæ’å…¥æ—¶çš„å‚è€ƒèŠ‚ç‚¹
    const targetAnchor = (n2.targetAnchor = createText(""));
    if (target) {
      insert(targetAnchor, target);
      // #2652 we could be teleporting from a non-SVG tree into an SVG tree
      isSVG = isSVG || isTargetSVG(target);
    } /* else if warn ... */

    const mount = (container: RendererElement, anchor: RendererNode) => {
      // å°† vnode children æ¸²æŸ“åˆ° target å…ƒç´ å†…
      // ä¼šæ’å…¥åˆ° anchor çš„å‰é¢,å¦‚ï¼š ~<target><children/><!--''--></target>~
    };

    if (disabled) {
      // å¤±æ•ˆçŠ¶æ€ï¼Œä¸ç›´æ¥æ¸²æŸ“åˆ°ç›®æ ‡å…ƒç´ ä¸­ï¼Œè€Œæ˜¯æŒ‚åœ¨äº† #app å†…å¯¹åº”çš„
      // èŠ‚ç‚¹é‡Œé¢ï¼Œç­‰å¾…çŠ¶æ€ enable å†æ¸²æŸ“å› target å…ƒç´ 
      mount(container, mainAnchor);
    } else if (target) {
      // ç›´æ¥æ¸²æŸ“è¿›ç›®æ ‡å…ƒç´ 
      mount(target, targetAnchor);
    }
  } else {
    // update content
    // éé¦–æ¬¡æ¸²æŸ“
    n2.el = n1.el;
    // å·²ç»æ¸²æŸ“åˆ° tar

    if (n2.dynamicChildren) {
      // åŠ¨æ€å­èŠ‚ç‚¹ patch
    } else if (!optimized) {
      // patch n1|n2 children
    }

    if (disabled) {
      // n2 new teleport disabled -> n1 old target enabled
      // n2 ç›´æ¥ç§»åˆ° #app ç»“æ„ä¸­çš„ container ä¸Šï¼Œæš‚æ—¶ä¸ç›´æ¥æ¸²æŸ“åˆ°
      // ç›®æ ‡å…ƒç´ ä¸Š
      if (!wasDisabled) {
        // moveTeleport
      }
    } else {
      // target changed
      // teleport çš„ to å±æ€§å€¼å‘ç”Ÿäº†å˜åŒ–ï¼Œæ‰¾åˆ°æ–°çš„ç›®æ ‡
      // è¿›è¡Œç§»åŠ¨
      if ((n2.props && n2.props.to) !== (n1.props && n1.props.to)) {
        // 1. æ‰¾æ–°ç›®æ ‡
        // 2. å°† n2 ç§»åŠ¨åˆ°æ–°çš„ç›®æ ‡ä¸­
        // ...
      } else if (wasDisabled) {
        // çŠ¶æ€å˜æ›´
        // disabled -> enabled
        // move into teleport target
        // ä» container ä¸­å°† n2 ç§»åˆ°ç›®æ ‡å…ƒç´ ä¸­
      }
    }
  }
}
#+end_src

å¯¹äº teleport çš„ mount å’Œ update ä¸¤ä¸ªå…±åŒç‚¹(ä¹Ÿæ˜¯é‡ç‚¹)ï¼š

1. å½“ new teleport æ˜¯ disabled æ—¶ï¼Œä¸ç›´æ¥æ¸²æŸ“åˆ°ç›®æ ‡å…ƒç´ ä¸­ï¼Œè€Œæ˜¯æŒ‚åœ¨å½“å‰
   container ä¸­å¾…ç”¨
2. å½“ new teleport çŠ¶æ€ enabled æ—¶ï¼Œä¸è®º old ä»€ä¹ˆçŠ¶æ€ï¼Œéƒ½ä¼šè®²æ–°çš„ teleport
   children æ¸²æŸ“åˆ°ç›®æ ‡å…ƒç´ ä¸‹é¢ã€‚


Teleport çš„ç§»åŠ¨ç±»å‹æœ‰ï¼š

1. ~TARGET_CHANGE~ ç›®æ ‡å‘ç”Ÿäº†å˜åŒ–ï¼Œ teleport çš„ ~to~ å±æ€§å˜åŒ–

   #+begin_src typescript
   // move target anchor if this is a target change.
   if (moveType === TeleportMoveTypes.TARGET_CHANGE) {
     insert(vnode.targetAnchor!, container, parentAnchor);
   }
   #+end_src
2. ~TOGGLE~ çŠ¶æ€å‘ç”Ÿäº†å˜åŒ– enable -> disable æˆ– disable -> enable
3. ~REORDER~ ç›®æ ‡å…ƒç´ å†…è¿›è¡Œé‡æ–°æ’åº ?

   #+begin_src typescript
   // move main view anchor if this is a re-order.
   if (isReorder) {
     insert(anchor!, container, parentAnchor);
   }
   #+end_src
** TODO æµ‹è¯•

#+begin_src js
const { log, f, shuffle, runtime_test, renderChildren } = require(process.env
  .BLOG_DIR_VUE + "/lib.js");
import(process.env.BLOG_DIR_VUE + "/runtime-test.global.js").then(
  ({ h, render, Teleport, nodeOps, serializeInner: inner, ref }) => {
    const target = nodeOps.createElement("div");
    const root = nodeOps.createElement("div");

    try {
      render(
        h(() => [
          h(Teleport, { to: target }, h("div", "teleported")),
          h("div", "root"),
        ]),
        root
      );
    } catch (e) {
      console.log(e.message);
    }

    log([">>> root", inner(root)]);
    log([">>> target", inner(target)]);
  },
  (err) => {
    console.log(err.message);
  }
);
#+end_src

#+RESULTS:
: undefinedcomponent stateful ? 0
: mount component
: update effect
: patch component
: >>> root
: >>> target

#+begin_quote
â“ æ²¡ç»“æœï¼ï¼ï¼ï¼ï¼ï¼
#+end_quote

* SUSPENSE
:PROPERTIES:
:COLUMNS: %CUSTOM_ID[(Custom Id)]
:CUSTOM_ID: suspense
:END:

[[https://github.com/gcclll/stb-vue-next/commit/fd651abed0f0bbfb4e41910909212faeca26e116][feat(add): suspense Â· gcclll/stb-vue-next@fd651ab]]

Suspense ç»„ä»¶å’Œ [[#teleport][Teleport]] ä¸€æ ·çš„ç»„ç»‡ç»“æ„å’Œä½¿ç”¨æ–¹å¼

ç»“æ„ï¼š

#+begin_src js
var Tmpl = {
  __isSuspense: true,
  process() {}
}
#+end_src

ç„¶ååœ¨ process ä¸­å¤„ç† mount æˆ– patch æµç¨‹ï¼Œè¿™é‡Œé¢å’Œæ™®é€šæ ‡ç­¾æˆ–æ™®é€šç»„ä»¶çš„å¤„ç†æ˜¯ä¸€
æ ·çš„ï¼Œ mount or patchã€‚

ä¸‹é¢æ¥çœ‹ä¸‹è¿™ä¸ªç»„ä»¶æ˜¯å¦‚ä½•å®ç°çš„ï¼ŒåŠŸèƒ½åˆæ˜¯å¦‚ä½•ï¼Ÿ

æ–°å¢å‡½æ•°ï¼š

#+begin_src typescript
// 1. æ¨¡æ¿
// æ ¹æ®æ³¨é‡Šè¯´æ˜ï¼Œä¹‹æ‰€ä»¥é‡‡ç”¨è¿™ç§ç»“æ„æ˜¯ä¸ºäº†èƒ½è®© Suspense é€‚ç”¨ tree-shaking
export const SuspenseImpl = {
  __isSuspense: true,
  process(n1: VNode | null, n2: VNode /*...*/) {
    if (n1 == null) {
      // mount
    } else {
      // patch
    }
  },
  hydrate: hydrateSuspense,
  create: createSuspenseBoundary,
};

// 2. mountSuspense
// 3. patchSuspense
#+end_src

åˆ—è¡¨ï¼š

| åç§°                       | æè¿° |
|----------------------------+------|
| ~SuspenseImpl~             | -    |
| ~mountSuspense()~          | -    |
| ~patchSuspense()~          | -    |
| ~SuspenseBoundary~         | -    |
| ~createSuspenseBoundary()~ | -    |
| ~hydrateSuspense()~        | -    |


** SuspenseBoundary æ•°æ®ç»“æ„

åªåˆ—å‡ºéƒ¨åˆ†ä¸ Suspense å…³è”æ€§å¼ºçš„å­—æ®µï¼š

| åç§°            | æè¿°                                  |
|-----------------+---------------------------------------|
| vnode           | VNode ç»“æ„                            |
| hiddenContainer | -                                     |
| activeBranch    | è¯·æ±‚å®Œæˆä¹‹åæ˜¾ç¤ºçš„ç»„ä»¶åˆ†æ”¯ ~#default~ |
| pendingBranch   | è¯·æ±‚ä¸­æ˜¾ç¤ºçš„åˆ†æ”¯ ~#fallback~          |
| deps            | ç»„ä»¶ä¾èµ–                              |
| timeout         | è¶…æ—¶æ—¶é—´                              |
| isInFallback    | -                                     |
| isHydrating     | -                                     |
| effects         | [] ä¾èµ–åˆ—è¡¨                           |
| resolve(force)  | -                                     |
| fallback()      | å‚æ•°ï¼š fallbackVnode                  |
| move()          | -                                     |
| next()          | -                                     |
| registerDep()   | æ³¨å†Œå®ä¾‹ä¾èµ–                          |


#+begin_src typescript
export interface SuspenseBoundary {
  vnode: VNode<RendererNode, RendererElement, SuspenseProps>;
  parent: SuspenseBoundary | null;
  parentComponent: ComponentInternalInstance | null;
  isSVG: boolean;
  container: RendererElement;
  hiddenContainer: RendererElement;
  anchor: RendererNode | null;
  activeBranch: VNode | null;
  pendingBranch: VNode | null;
  deps: number;
  pendingId: number;
  timeout: number;
  isInFallback: boolean;
  isHydrating: boolean;
  isUnmounted: boolean;
  effects: Function[];
  resolve(force?: boolean): void;
  fallback(fallbackVNode: VNode): void;
  move(
    container: RendererElement,
    anchor: RendererNode | null,
    type: MoveType
  ): void;
  next(): RendererNode | null;
  registerDep(
    instance: ComponentInternalInstance,
    setupRenderEffect: SetupRenderEffectFn
  ): void;
  unmount(parentSuspense: SuspenseBoundary | null, doRemove?: boolean): void;
}
#+end_src

** mountSuspense()
:PROPERTIES:
:COLUMNS: %CUSTOM_ID[(Custom Id)]
:CUSTOM_ID: suspense-mount
:END:

[[https://github.com/gcclll/stb-vue-next/commit/802b9adfcebae8b9e0ba2f0ad7e9f995c3675920][feat(add): suspense mount Â· gcclll/stb-vue-next@802b9ad]]


#+begin_src typescript
function mountSuspense() {
  const {
    p: patch,
    o: { createElement },
  } = rendererInternals;
  const hiddenContainer = createElement("div");
  const suspense = (vnode.suspense = createSuspenseBoundary(
    vnode,
    parentSuspense,
    parentComponent,
    container,
    hiddenContainer,
    anchor,
    isSVG,
    optimized,
    rendererInternals
  ));

  // start mounting the content subtree in an off-dom container
  patch(
    null,
    (suspense.pendingBranch = vnode.ssContent!),
    hiddenContainer,
    null,
    parentComponent,
    suspense,
    isSVG
  );
  // now check if we have encountered any async deps
  if (suspense.deps > 0) {
    // has async
    // mount the fallback tree
    patch(
      null,
      vnode.ssFallback!,
      container,
      anchor,
      parentComponent,
      null, // fallback tree will not have suspense context
      isSVG
    );
    setActiveBranch(suspense, vnode.ssFallback!);
  } else {
    // Suspense has no async deps. Just resolve.
    suspense.resolve();
  }
}

// è®¾ç½®æ¿€æ´»çš„ branch
function setActiveBranch(suspense: SuspenseBoundary, branch: VNode) {
  suspense.activeBranch = branch;
  const { vnode, parentComponent } = suspense;
  const el = (vnode.el = branch.el);
  // in case suspense is the root node of a component,
  // recursively update the HOC el
  if (parentComponent && parentComponent.subTree === vnode) {
    parentComponent.vnode.el = el;
    updateHOCHostEl(parentComponent, el);
  }
}
#+end_src

1. åˆ›å»ºä¸€ä¸ª DOM ä¹‹åçš„ divï¼Œå³è¿˜æ²¡æ¸²æŸ“åˆ° DOM ç»“æ„ä¸­çš„
2. æ„å»º Suspense ç»„ä»¶ç»“æ„ï¼Œè¿™ä¸ªç»“æ„é VNode ï¼Œè€Œæ˜¯æŒ‚åœ¨ vnode.suspense ä¸Šçš„ä¸€ä¸ª
   ~SuspenseBoundary~ ç»“æ„
3. å¼€å§‹ mount å†…å®¹é‡Œçš„å­æ ‘
4. æ£€æµ‹ Suspense æœ‰æ²¡å¼‚æ­¥ä¾èµ–ï¼Œå¦‚æœæœ‰ï¼Œåˆ™éœ€è¦å…ˆè§£æè¿™äº›å¼‚æ­¥ä¾èµ–ï¼Œå®Œæˆä¹‹åå†æ¿€æ´» branch
5. æ²¡æœ‰å¼‚æ­¥ä¾èµ–ç›´æ¥æ‹¿åˆ°ç»“æœè§£æå‡ºç»„ä»¶


ä¹Ÿå°±æ˜¯è¯´è¿™é‡Œé¢éœ€è¦é‡ç‚¹å…³æ³¨çš„å…¶å®æ˜¯â€œæœ‰æ²¡å¼‚æ­¥ä¾èµ–çš„é—®é¢˜â€ã€‚

æ²¡æœ‰ä¾èµ–çš„æ—¶å€™ç”¨åˆ°äº† ~suspense.resolve()~ è¿™ä¸ªåº”è¯¥æ˜¯å°†åˆ›å»ºçš„ off-dom div æŒ‚åˆ°çœŸ
å® DOM ä¸Šå»ã€‚
** suspense.resolve()
:PROPERTIES:
:COLUMNS: %CUSTOM_ID[(Custom Id)]
:CUSTOM_ID: suspense-resolve
:END:

#+begin_src typescript
function resolve(resume = false) {
  const {
    vnode,
    activeBranch,
    pendingBranch,
    pendingId,
    effects,
    parentComponent,
    container,
  } = suspense;

  if (suspense.isHydrating) {
    suspense.isHydrating = false;
  } else if (!resume) {
    // 1. transition æ”¯æŒï¼Œå°† move() æ“ä½œæ³¨å†Œåˆ° afterLeave å›è°ƒ
    // 2. å¸è½½å½“å‰çš„ subTree å¯èƒ½æ˜¯ fallback
    // 3. ä¸æ˜¯ transition dely enter è¿›è¡Œ move()
    // è¿™é‡Œæœ€åæ‰§è¡Œçš„æ“ä½œå°±æ˜¯ move() å¦‚æœæ˜¯ transition delay enter
    // åˆ™å°† move() æ³¨å†Œåˆ° afterLeaveï¼Œå¦åˆ™ç›´æ¥æ‰§è¡Œ move() å°† suspense
    // å†…å®¹æ¸²æŸ“åˆ°çœŸå®DOMä¸Š
    const delayEnter =
      activeBranch &&
      pendingBranch!.transition &&
      pendingBranch!.transition.mode === "out-in";
    if (delayEnter) {
      activeBranch!.transition!.afterLeave = () => {
        if (pendingId === suspense.pendingId) {
          move(pendingBranch!, container, anchor, MoveType.ENTER);
        }
      };
    }
    // this is initial anchor on mount
    let { anchor } = suspense;
    // unmount current active tree
    if (activeBranch) {
      // if the fallback tree was mounted, it may have been moved
      // as part of a parent suspense. get the latest anchor for insertion
      anchor = next(activeBranch);
      unmount(activeBranch, parentComponent, suspense, true);
    }
    if (!delayEnter) {
      // move content from off-dom container to actual container
      move(pendingBranch!, container, anchor, MoveType.ENTER);
    }
  }

  // æ ‡è®°å½“å‰æ¿€æ´»çŠ¶æ€çš„åˆ†æ”¯ï¼Œæ­¤æ—¶æ˜¯ #default
  setActiveBranch(suspense, pendingBranch!);
  suspense.pendingBranch = null;
  suspense.isInFallback = false;

  // flush buffered effects
  // check if there is a pending parent suspense
  // æ³¨å†Œçš„ effect å¤„ç†ï¼Œè¿™é‡Œçš„å¤„ç†è¯´æ˜äº† suspense çš„çˆ¶å­ä¾èµ–æ‰§è¡Œ
  // çš„é¡ºåºé—®é¢˜ï¼Œ effects æ˜¯æŒ‰ç…§æ•°ç»„åŠ å…¥é¡ºåºæ‰§è¡Œçš„(è¯¦æƒ…å¯ä»¥æŸ¥çœ‹ reactivity æ–‡ç« )
  // æ‰€ä»¥ effects çš„ä¼˜å…ˆçº§æ˜¯è‡ªä¸Šè€Œä¸‹çš„ï¼Œå³ parent-parent > parent > children
  let parent = suspense.parent;
  let hasUnresolvedAncestor = false;
  while (parent) {
    if (parent.pendingBranch) {
      // found a pending parent suspense, merge buffered post jobs
      // into that parent
      parent.effects.push(...effects);
      hasUnresolvedAncestor = true;
      break;
    }
    parent = parent.parent;
  }
  // no pending parent suspense, flush all jobs
  // å¦‚æœæ²¡æœ‰æŒ‚èµ·çš„ parent suspense ç›´æ¥ flush æ‰æ‰€æœ‰ä»»åŠ¡
  // ç»“åˆä¸Šé¢çš„ while ä¸¾ä¾‹ï¼š
  // CompA -> CompB -> CompC
  // å½“è§£æåˆ° CompC æ—¶ï¼Œä¸€ç›´å¾€ä¸Šæ£€æµ‹ B å’Œ A å¦‚æœ B æœ‰æŒ‚èµ·çš„ä»»åŠ¡
  // C è¿™é‡Œçš„ä»»åŠ¡ä¸ä¼šè¢« flushï¼Œè€Œæ˜¯åŠ å…¥åˆ° B çš„é˜Ÿåˆ—ç­‰å¾…æ‰§è¡Œ
  // ç„¶å C è§£æå®Œæˆï¼Œå›æº¯åˆ° B çš„è§£æï¼Œæ­¤æ—¶åˆéµå¾ªåŒä¸€å¥—è§„åˆ™æ£€æµ‹ A çš„
  // æŒ‚èµ·ä»»åŠ¡ï¼Œç›´åˆ°æœ€åè¦ä¹ˆç«‹å³æ‰§è¡Œ B çš„ä»»åŠ¡è¦ä¹ˆ B çš„ä»»åŠ¡ä¹ŸåŠ å…¥åˆ° A
  // æœ€åç”± A æ‰§è¡Œæ‰€æœ‰çš„ä»»åŠ¡(åŒ…å«å­ suspense çš„)
  if (!hasUnresolvedAncestor) {
    queuePostFlushCb(effects);
  }
  suspense.effects = [];

  // invoke @resolve event
  const onResolve = vnode.props && vnode.props.onResolve;
  if (isFunction(onResolve)) {
    onResolve();
  }
}
#+end_src

åˆ†æå¦‚ä¸Šé¢çš„æ³¨é‡Šï¼Œ ~resolve()~ ä¸»è¦ç›®çš„å°±æ˜¯å°† off-dom div ä¸Šçš„ suspense ç»„ä»¶åœ¨å¼‚
æ­¥äº‹ä»¶å®Œæˆåæ ¹æ®ç»“æœè§£æå‡ºå¯¹åº”çš„åˆ†æ”¯ï¼Œå°†è¿™ä¸ªåˆ†æ”¯æŒ‚è½½åˆ°çœŸå®çš„ DOM ä¸Šå»ï¼ŒåŒæ—¶æ¿€æ´»
å®ƒ(æ˜¾ç¤ºå‡ºæ¥)ã€‚

å…¶ä»–å¤„ç†ï¼š

1. ~transition~ çš„å»¶è¿Ÿè¿›å…¥å¤„ç†ï¼Œé€šè¿‡å°† move() æ“ä½œæ³¨å†Œåˆ° ~afterLeave()~ å›è°ƒå®ç°
2. effects ä»»åŠ¡å¤„ç†ï¼Œè¿™é‡Œçš„ä»»åŠ¡å¤„ç†æœºåˆ¶æ˜¯ï¼š

   åªæœ‰åœ¨ parent æ²¡æœ‰ä»»ä½•æŒ‚èµ·çš„ä»»åŠ¡æ—¶å€™æ‰ä¼šç«‹å³å¾—åˆ°æ‰§è¡Œï¼Œå¦åˆ™åªä¼šè¿›è¡Œåˆå¹¶æ“ä½œã€‚
** patchSuspense()

* æµ‹è¯•

#+begin_export html
<div id="6MyGYf">
<p style="background:red;color:white;" id="p0"></p>
<p style="background:red;color:white;" id="p1"></p>
<p style="background:red;color:white;" id="p2"></p>
<p style="background:red;color:white;" id="p3"></p>
<p style="background:red;color:white;" id="p4"></p>
<p style="background:red;color:white;" id="p5"></p>
<p style="background:red;color:white;" id="p6"></p>
<p style="background:red;color:white;" id="p7"></p>
<div id="dzwrLeuq5V"></div>
<script src="/js/vue/tests/dzwrLeuq5V.js"></script>
#+end_export

