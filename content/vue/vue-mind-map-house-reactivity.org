#+TITLE: Vue3 源码头脑风暴之☞reactivity
#+DATE: <2020-11-09 11:45:36>
#+TAGS[]: vue, vue3, compiler-core, parser, compiler
#+CATEGORIES[]: vue
#+LANGUAGE: zh-cn
#+STARTUP: indent shrink

#+begin_export html
<link href="https://fonts.goo~gleapis.com/cs~s2?family=ZCOOL+XiaoWei&display=swap" rel="stylesheet">
<kbd>
<font color="blue" size="3" style="font-family: 'ZCOOL XiaoWei', serif;">
  诗号：六道同坠，魔劫万千，引渡如来。
</font>
</kbd><br><br>
<script src="/js/vue/reactivity.global.prod.js"></script>
#+end_export

[[/img/bdx/yiyeshu-001.jpg]]

* TODO Proxy & Reflect 功能回顾

[[/post/javascript-apis/#api-proxy-reflect][Proxy 和 Reflect 相关的 Apis 伪码和说明连接 🛫]]

* Reactivity
:PROPERTIES:
:COLUMNS: %CUSTOM_ID[(Custom Id)]
:CUSTOM_ID: rt
:END:

vue-next 最新的响应式原理 ~Proxy + Reflect~ 。

[[#while-mind-map][由于完整脑图会比较全而大所以放到文字最后去。。。]]

[[/img/vue3/reactivity/reactivity.svg][也可以点击该链接直接新窗口打开，效果更佳。]]

* reactive(target)
:PROPERTIES:
:COLUMNS: %CUSTOM_ID[(Custom Id)]
:CUSTOM_ID: fn-rt
:END:

commit: [[https://github.com/gcclll/stb-vue-next/commit/cb3470d7c3f2944fd23e9155fc8a6afb7a51a732][cb3470d7c3f2944fd23e9155fc8a6afb7a51a732]]

该函数是作为响应式模块的入口函数，一个非常简单的处理函数：

1. 只读代理，直接返回该对象
2. 否则调用 [[#rt-cro][createReactiveObject(...args)]]

[[/img/vue3/reactivity/reactivity-reactive.svg]]

#+begin_src typescript
export function reactive(target: object) {
  // 如果试图 observe 一个只读 proxy，返回只读版本
  if (target && (target as Target)[ReactiveFlags.IS_READONLY]) {
    return target
  }

  return createReactiveObject(
    target,
    false,
    {},
    // mutableHandlers,
    {}
    // mutableCollectionHandlers
  )
#+end_src

*mutableHandlers*: 普通对象类型的 proxy handlers

*mutableCollectionHandlers*: 集合类型的 proxy handlers，因为 ~Reflect~ 并没有对集
合类型做底层映射，所以需要特殊处理。
* createReactiveObject(...args)
:PROPERTIES:
:COLUMNS: %CUSTOM_ID[(Custom Id)]
:CUSTOM_ID: fn-cro
:END:

commit: [[https://github.com/gcclll/stb-vue-next/commit/443a0b5920efaf714de08b0975c17f1d652815e4][443a0b5920efaf714de08b0975c17f1d652815e4]]

脑图：
[[/img/vue3/reactivity/reactivity-create-reactive-object.svg]]

#+begin_src typescript

function createReactiveObject(
  target: Target,
  isReadonly: boolean,
  baseHandlers: ProxyHandler<any>,
  collectionHandlers: ProxyHandler<any>
) {
  if (!isObject(target)) {
    if (__DEV__) {
      console.warn(`value cannot be made reactive: ${String(target)}`)
    }

    return target
  }

  // target 已经是 Proxy，不用重复代理
  // 异常情况：在一个 reactive object 上调用 readonly()
  if (
    target[ReactiveFlags.RAW] &&
    !(isReadonly && target[ReactiveFlags.IS_REACTIVE])
  ) {
    return target
  }

  // 代理缓存中有，直接取已缓存的
  const proxyMap = isReadonly ? readonlyMap : reactiveMap
  const existingProxy = proxyMap.get(target)
  if (existingProxy) {
    return existingProxy
  }

  // 只有合法的类型(Object|Array|[Weak]Map|[Weak]Set)才能被代理
  const targetType = getTargetType(target)
  if (targetType === TargetType.INVALID) {
    return target
  }

  const proxy = new Proxy(
    target,
    targetType === TargetType.COLLECTION ? collectionHandlers : baseHandlers
  )

  // 缓存代理映射关系
  proxyMap.set(target, proxy)
  return proxy
#+end_src
* mutableHandlers
:PROPERTIES:
:COLUMNS: %CUSTOM_ID[(Custom Id)]
:CUSTOM_ID: hm
:END:

针对非集合型对象而言，结合 ~Reflect~ 构建 Proxy 的 handlers。

** get handler
:PROPERTIES:
:COLUMNS: %CUSTOM_ID[(Custom Id)]
:CUSTOM_ID: hm-get
:END:

*** only get proxy
:PROPERTIES:
:COLUMNS: %CUSTOM_ID[(Custom Id)]
:CUSTOM_ID: hm-get-proxy
:END:

本节只实现对象的 ~get proxy handler~ ，对象属性被访问的时候会触发代理，比如下面
实例中，当访问 ~observed.count~ 时候会触发 ~console.log({ res }, "get")~ 执行。

commit: [[https://github.com/gcclll/stb-vue-next/commit/598e047407fe52183468037beb45328878431a55][598e047407fe52183468037beb45328878431a55]]

最简单 proxy get handler 脑图：
[[/img/vue3/reactivity/reactivity-basehd-get-01.svg]]
1. 调用 ~Reflect.get(target, key, receiver)~ 执行原子操作
2. 返回执行结果

主要更新代码：
#+begin_src typescript

function createGetter(isReadonly = false, shallow = false) {
  // target: 被取值的对象，key: 取值的属性，receiver: this 的值
  return function get(target: Target, key: string | symbol, receiver: object) {
    // TODO 1. key is reactive
    // TODO 2. key is readonly
    // TODO 3. key is the raw target

    // TODO 4. target is array

    const res = Reflect.get(target, key, receiver)

    // TODO 5. key is symbol, or `__protot__ | __v_isRef`

    // TODO 6. not readonly, need to track and collect deps

    // 是否只需要 reactive 一级属性(不递归 reactive)
    if (shallow) {
      return res
    }

    // TODO 6. res isRef

    // TODO 7. res is object -> reactive recursivly

    console.log({ res }, "get")
    return res
  }
#+end_src

这里只保留的最简单的代理部分。

测试代码：
#+begin_src js
var counter = { count: 0 }
var observed = VueReactivity.reactive(counter)

observed.count // trigger get handler
// 打开控制台会发现有输出: {res: 0} "get"
#+end_src

#+begin_export html
<script type="text/javascript">
var counter = { count: 0 }
var observed = VueReactivity.reactive(counter)

observed.count // trigger get handler
// 这里会输出 {res: 0} "get"
</script>
#+end_export

进行到这一步，对于测试并不是很方便，不能只管的看到输出结果，所以接下来我们将实现
~effect()~ 来收集依赖，这样我们就可以很方便的通过依赖更新 DOM 。
*** track get operation(追踪 get 操作，收集依赖)
:PROPERTIES:
:COLUMNS: %CUSTOM_ID[(Custom Id)]
:CUSTOM_ID: hm-get-track
:END:

commit: [[https://github.com/gcclll/stb-vue-next/commit/6c50273e3225761c2b1da63ce19c773603dbd523][6c50273e3225761c2b1da63ce19c773603dbd523]]

1. [[#effect-track][track(target, type, key)]] 执行依赖收集：
2. [[#effect-effect][effect(fn, options)]] 封装依赖函数，并立即执行 fn(~options.lazy = false~, 时)

[[/img/vue3/reactivity/reactivity-basehd-get-02-track.svg]]

对于 ~effect()~ 相对比较独立的一个函数，目前阶段是需要手动去调用的，所以脑图就单
独去绘制。
* effect.ts
:PROPERTIES:
:COLUMNS: %CUSTOM_ID[(Custom Id)]
:CUSTOM_ID: file-effect
:END:

commit: [[https://github.com/gcclll/stb-vue-next/commit/3fc963486868ca3583b02852f07a5aa5969ac354][3fc963486868ca3583b02852f07a5aa5969ac354]]

函数及变量列表
| name                                | type             | desc                                                                              |
|-------------------------------------+------------------+-----------------------------------------------------------------------------------|
| ~activeEffect~                      | /ReactiveEffect/ | 当前正在处理的 Effect，fn 还未执行完成，finally 还没结束                          |
| ~effectStack~                       | /Array, []/      | 缓存所有状态还没完成的 Effect                                                     |
| ~shouldTrack~                       | /boolean, true/  | track() 中用来检测当前 effect 是否结束，从而判定是否可以继续执行 track() 收集依赖 |
| ~trackStack~                        | /Array, []/      | 保存着所有 Effect 的 shouldTrack 值                                               |
| ~effect()~                          | /function/       | 封装 fn成 ReactiveEffect 结构                                                     |
| ~track(target, type, key)~          | /function/       | 收集依赖，并且响应式递归                                                          |
| ~trigger(...)~                      | /function/       | 当值更新时触发所有依赖更新                                                        |
| ~createReactiveEffect(fn, options)~ | /function/       | effect() 函数主题功能分离出来                                                     |
| ~cleanup(effect: ReactiveEffect)~   | /function/       | 清空所有 fn 的依赖 effect.deps[]                                                  |
| ~enableTracking()~                  | /function/       | 使能 Effect ，shouldTrack = true, 并将其加入 trackStack                           |
| ~resetTracking()~                   | /function/       | 重置 Effect, shouldTrack = 上一个 Effect 的 shouldTrack 值或 true                 |

[[/img/vue3/reactivity/reactivity-effect.svg]]

依赖和属性变更发生联系的桥梁模块。

1. ~effect(fn, options)~ 封装执行 fn，触发取值操作 ->
2. ~track(target, type, key)~ 收集对象及属性所有依赖 ->
3. fn 中设值操作触发 ~trigger(...)~ 执行所有 deps，更新 DOM。
   
** track(target, type, key)
:PROPERTIES:
:COLUMNS: %CUSTOM_ID[(Custom Id)]
:CUSTOM_ID: fn-effect-track
:END:

*参数列表* ：
    - ~target~ : 被代理的对象
    - ~type~ : 代理操作类型(~get/has/iterate~)
    - ~key~ : 取值操作时对应的属性名

*主要功能* ：实现依赖收集

*实现原理* ：结合 [[#fn-effect-effect][effect(fn, options)]]触发 /get proxy handler/ 里面执
行 ~track(target, type, key)~ 将当前的 ~activeEffect~ 收集到 ~depsMap~ , 所
以 ~activeEffect~ 是链接依赖函数和属性操作的桥梁，这将是未来设置值的时候触发依赖
的命脉。


 #+begin_src typescript
    export function track(target: object, type: TrackOpTypes, key: unknown) {
    if (!shouldTrack || activeEffect === undefined) {
        return
    }

    // Map< obj -> Map<key, Set[...deps]> >
    let depsMap = targetMap.get(target)
    if (!depsMap) {
        // 初始化
        targetMap.set(target, (depsMap = new Map()))
    }

    let dep = depsMap.get(key)
    if (!dep) {
        depsMap.set(key, (dep = new Set()))
    }

    // 正在请求收集的 effect ，是初次出现
    if (!dep.has(activeEffect)) {
        dep.add(activeEffect)
        // 自身保存一份被依赖者名单
        activeEffect.deps.push(dep)
        if (__DEV__ && activeEffect.options.onTrack) {
        activeEffect.options.onTrack({
            effect: activeEffect,
            target,
            type,
            key
        })
        }
    }
#+end_src

- targetMap 保存所以依赖关系，存储形式： ~Map<target -> Map<key,
     Set[...deps]>>~

- 前面两个 if 检测依赖是否有缓存，避免重复

- 最后两个 ~add~ 操作，一个是手机依赖，一个让当前的 ~effect~ 持有自己身的被依赖
  者名单
** effect(fn, options)
:PROPERTIES:
:COLUMNS: %CUSTOM_ID[(Custom Id)]
:CUSTOM_ID: fn-effect-effect
:END:

*参数列表* ：

    - ~fn~ ：依赖函数，该函数中对对象取值，触发 track 将它封装后的
      ~ReactiveEffect~ 收集到取值属性对应的 ~depsMap~ 中
    - ~options~ : 允许使用者提供外部选项，控制 effect 行为，比如： ~lazy: true~
      可以控制 effect 是否会立即执行，立即触发 track 等一系列操作。

*主要功能* : 封装依赖函数，并立即执行它，触发 track 收集依赖，主要实现还是在
~createReactiveEffect(fn, options)~ 中

#+begin_src typescript
export function effect<T = any>(
  fn: () => T,
  options: ReactiveEffectOptions = EMPTY_OBJ
): ReactiveEffect<T> {
  if (isEffect(fn)) {
    fn = fn.raw // 取出原始的函数，封装之前的
  }

  // 封装成 ReactiveEffect
  const effect = createReactiveEffect(fn, options)

  if (!options.lazy) {
    // 如果并没指定 lazy: true 选项，则立即执行 effect 收集依赖
    // 因为 effect 一般都会有取值操作，此时会触发 proxy get handler
    // 然后执行 track() 结合当前的 activeEffect 即 effect() 执行时候的这个
    // effect，这样取值操作就和当前取值作用域下的依赖函数建立的依赖关系
    effect()
  }
  return effect

#+end_src

** createReactiveEffect(fn, options)
:PROPERTIES:
:COLUMNS: %CUSTOM_ID[(Custom Id)]
:CUSTOM_ID: fn-effect-createReactiveEffect
:END:

*参数列表* ：沿用 [[#fn-effect-effect][effect(fn, options)]]

*主要功能* ：将 fn 封装成 ~ReactiveEffect~ 函数

    #+begin_src typescript
    export interface ReactiveEffect<T = any> {
        (): T // effect函数主题
        _isEffect: true // 标记自身是不是一个 ReactiveEffect 类型
        id: number // uid++ 而来，全局的一个相对唯一的 id
        active: boolean // 记录当前的 effect 是不是激活状态
        raw: () => T // 封装之前的那个 fn
        deps: Array<Dep> // fn 的被依赖者列表
        options: ReactiveEffectOptions // 额外选项，如：lazy
        allowRecurse: boolean // ???
    }
    #+end_src

*解决问题* :

    1. fn 封装之后，执行 fn 过程中使用 try...finally ，防止 fn 执行异常导致
       effect 进程中断
    2. 结合 shouldTrack, activeEffect 和 track() 函数，有效的避免了在 fn 中执行
       obj.value++ 导致 effect 死循环问题，因为 try...finally 确保了只有 fn 函数
       完成之后才会进入 finally 恢复 effect 状态(~shouldTrack = true,
       activeEffect = last || null~)。

#+begin_src typescript
function createReactiveEffect<T = any>(
  fn: () => T,
  options: ReactiveEffectOptions
): ReactiveEffect<T> {
  // 将 fn 执行封装成  ReactiveEffect 类型的函数
  const effect = function reactiveEffect(): unknown {
    if (!effect.active) {
      // 非激活状态，可能是手动调用了 stop
      // 那么执行的时候就需要考虑调用 stop 者是否提供了手动调度该 effect
      // 的函数 scheduler ? 也就是说你停止你可以重新启动
      return options.scheduler ? undefined : fn()
    }

    if (!effectStack.includes(effect)) {
      // 1. cleanup, 保持纯净
      cleanup(effect)
      try {
        // 2. 使其 tracking 状态有效，track() 中有用
        enableTracking() // track() 可以执行收集操作
        effectStack.push(effect) // effect 入栈
        // 3. 保存为当前的 activeEffect, track() 中有用
        activeEffect = effect // 记录当前的 effect -> track/trigger
        // 4. 执行 fn 并返回结果
        return fn() // 返回执行结果
      } finally {
        // 始终都会执行，避免出现异常将 effect 进程卡死
        // 5. 如果执行异常，丢弃当前的 effect ，并将状态重置为上一个 effect
        //   由一个 effect 栈来维护。

        effectStack.pop()
        resetTracking()
        activeEffect = effectStack[effectStack.length - 1]
      }
    }
  } as ReactiveEffect

  effect.id = uid++
  effect.allowRecurse = !!options.allowRecurse
  effect._isEffect = true
  effect.active = true
  effect.raw = fn // 这里保存原始函数引用
  effect.deps = []
  effect.options = options

  return effect

#+end_src
** effect -> track -> trigger 关系图
:PROPERTIES:
:COLUMNS: %CUSTOM_ID[(Custom Id)]
:CUSTOM_ID: effect-track-trigger
:END: 

[[/img/vue3/reactivity/reactivity-effect-track-trigger.svg]]
** 测试
:PROPERTIES:
:COLUMNS: %CUSTOM_ID[(Custom Id)]
:CUSTOM_ID: effect-test
:END: 

*** effect + track 完成依赖收集
:PROPERTIES:
:COLUMNS: %CUSTOM_ID[(Custom Id)]
:CUSTOM_ID: effect-test-01
:END: 

上面示例演示了如何 ~reactive~ 一个对象，然后通过 ~effect~ 来封装执行一个函数，在这个
函数里面去取值和设值操作，从而分别触发 [[#fn-effect-track][track()]] 和 [[#fn-effect-trigger][trigger()]] 收集依赖和触发更新。

~trigger()~ 还没完成，所以这里只能演示 track 和 effect 功能。

#+begin_src js
var effect = VueReactivity.effect
var reactive = VueReactivity.reactive
var counter = reactive({ count: 0 })

var $el = $("#_effect_test_01")

var exec = effect(
    function fn() {
    var c = counter.count++
    $el.find(".result").append('<p>第 ' + c + ' 次取值操作...</p>')
    }, { lazy: true }
)
$el.children(".getval").click(function() {
    exec()
})
$el.children(".reset").click(function() {
    $el.children(".result").html('')
})

#+end_src
为了更直观的看到收集动作，可以通过增加按钮来结合 effect options 的 lazy 选项，来手动触发 ~effect()~

#+begin_export html
<body>
<div id="_effect_test_01">
<button class="getval">点我触发取值操作！</button>
<button class="reset">重置</button>
<div class="result"></div>
<code></code>
</div>
</body>
<script>
setTimeout(function test() {
    if (typeof $ === 'undefined') return
    
    var effect = VueReactivity.effect
    var reactive = VueReactivity.reactive
    var counter = reactive({ count: 0 })
    
    var $el = $("#_effect_test_01")
    
    var exec = effect(
      function fn() {
        var c = counter.count++
        $el.find(".result").append('<p>第 ' + c + ' 次取值操作...</p>')
      }, { lazy: true }
    )
    $el.children(".getval").click(function() {
      exec()
    })
    $el.children(".reset").click(function() {
      $el.children(".result").html('')
    })

}, 1000)
    
</script>
#+end_export

debugger:
#+begin_example
e: {count: 0} // counter 对象
i: Set(1) // "count" 属性的依赖函数 targetMap -> depsMap -> deps
    > [[Entries]]
        // 0 -> effect(fn) -> fn 被封装之后的结果
        > 0: function(){if(!n.active)return t.scheduler?void 0:e();if(!i.includes(n)){!function(e){const{deps:t}=e;if(t.length){for(let n=0;n<t.length;n++)t[n].delete(e);t.length=0}}(n);try{return f(),i.push(n),o=n,e()}finally{i.pop(),l(),o=i[i.length-1]}}}
        > size: 1
depsMap: Map(1) // counter 对象的属性依赖对应关系 targetMap -> depsMap { key => Set[...deps] }
    > [[Entries]]
        > 0: {"count" => Set(1)}
        > size: 1

// Closure 部分
targetMaps: WeakMap
   > [[Entries]]
   > 0: {Object => Map(1)}
        > key: {count: 0}
        > value: Map(1) {"count" => Set(1)}
#+end_example

* 完整脑图
:PROPERTIES:
:COLUMNS: %CUSTOM_ID[(Custom Id)]
:CUSTOM_ID: whole-mind-map
:END:

[[/img/vue3/reactivity/reactivity.svg]]
