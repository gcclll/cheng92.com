ATE: <2020-11-09 11:45:36>
#+TAGS[]: vue, vue3, compiler-core, parser, compiler
#+CATEGORIES[]: vue
#+LANGUAGE: zh-cn
#+STARTUP: indent shrink

#+begin_export html
<link href="https://fonts.goo~gleapis.com/cs~s2?family=ZCOOL+XiaoWei&display=swap" rel="stylesheet">
<kbd>
<font color="blue" size="3" style="font-family: 'ZCOOL XiaoWei', serif;">
  诗号：六道同坠，魔劫万千，引渡如来。
</font>
</kbd><br><br>
<script src="/js/vue/reactivity.global.js"></script>
<script>
function _log(el, content) {
  $(el).children('.result').append('<p>' + content + '</p>')
}
</script>
#+end_export

[[/img/bdx/yiyeshu-001.jpg]]

@@html:<kbd>@@
*[[https://github.com/gcclll/stb-vue-next][stb-vue-next]] 完全拷贝于 [[https://github.com/vuejs/vue-next][vue-next]] ，主要目的学习及尝试应用于机顶盒环境。*
@@html:</kbd>@@

@@html:<kbd>@@ *本文依据 commit 进程进行记录* @@html:</kbd>@@

* init project
:PROPERTIES:
:COLUMNS: %CUSTOM_ID[(Custom Id)]
:CUSTOM_ID: init
:END:

初始化项目：[[https://github.com/gcclll/stb-vue-next/commit/cb3470d7c3f2944fd23e9155fc8a6afb7a51a732][feat: reactive-fn · gcclll/stb-vue-next@cb3470d]]

[[#while-mind-map][由于完整脑图会比较全而大所以放到文字最后去。。。]]

[[/img/vue3/reactivity/reactivity.svg][也可以点击该链接直接新窗口打开，效果更佳。]]
* [[https://github.com/gcclll/stb-vue-next/commit/cb3470d7c3f2944fd23e9155fc8a6afb7a51a732][4a6ac0e]] add: createReactiveObject
:PROPERTIES:
:COLUMNS: %CUSTOM_ID[(Custom Id)]
:CUSTOM_ID: fn cro
:END:

[[https://github.com/gcclll/stb-vue-next/commit/cb3470d7c3f2944fd23e9155fc8a6afb7a51a732][feat: reactive-fn · gcclll/stb-vue-next@cb3470d]]

[[/img/vue3/reactivity/reactivity-reactive.svg]]

仅增加函数声明:

#+begin_src typescript
export function reactive(target: object) {
  // 如果试图 observe 一个只读 proxy，返回只读版本
  if (target && (target as Target)[ReactiveFlags.IS_READONLY]) {
    return target
  }

  return createReactiveObject(
    target,
    false,
    mutableHandlers,
    {}
    // mutableCollectionHandlers
  )
}

function createReactiveObject(
  target: Target,
  isReadonly: boolean,
  baseHandlers: ProxyHandler<any>,
  collectionHandlers: ProxyHandler<any>
) {}
#+end_src

*mutableHandlers*: 普通对象类型的 proxy handlers

*mutableCollectionHandlers*: 集合类型的 proxy handlers，因为 ~Reflect~ 并没有对集
合类型做底层映射，所以需要特殊处理。

* [[https://github.com/gcclll/stb-vue-next/commit/443a0b5920efaf714de08b0975c17f1d652815e4][c0f0b7c]] feat: reactive(target)

[[https://github.com/gcclll/stb-vue-next/commit/443a0b5920efaf714de08b0975c17f1d652815e4][feat: createReactiveObject · gcclll/stb-vue-next@443a0b5]]

[[/img/vue3/reactivity/reactivity-create-reactive-object.svg]]

1. 重点： ~new Proxy(target, collection)~
2. 被代理类型必须是对象(引用类型)
3. target 本身已经是 proxy 了
4. target 代理有缓存不用重复创建
5. 必须是合法的类型(~Object|Array|[Weak]Map|[Weak]Set~)才能被代理
6. 记得缓存新创建的代理关系(~proxyMap~ 全局变量)

*** 用例一：普通对象

#+begin_src js
const { effect, reactive, targetMap, isReactive } = require(process.env.PWD + '/../../static/js/vue/reactivity.global.js')

const original = { foo: 1 }
const observed = reactive(original)

console.log('observed is not orignial,' + original !== observed)
console.log('observed is reactive, ' + isReactive(observed))
console.log('original is reactive, ' + isReactive(original))
console.log('observed.foo === 1, ' + observed.foo === 1)
console.log('`foo` in observed, ' + (`foo` in observed))
console.log(`Object.keys(observed) == ['foo'], ` + (Object.keys(observed).toString() === 'foo'))
#+end_src

+RESULTS:
: true
: observed is reactive, true
: original is reactive, false
: false
: `foo` in observed, true
: Object.keys(observed) == ['foo'], true
: undefined

[[https://github.com/gcclll/stb-vue-next/commit/1005ef30d5367fe306a4cfeb7e00c1cd56b1c691][b2143f9]] FIX: ~isReactive(observed): false~

[[https://github.com/gcclll/stb-vue-next/commit/1005ef30d5367fe306a4cfeb7e00c1cd56b1c691][fix: get object's __v_isReactive prop · gcclll/stb-vue-next@1005ef3]]

在 ~createGetter~ 中增加判断，如果来取的属性为 ~__v_isReactive~ 则直接返回
~!isReadonly~ 。
*** 用例二：原型

#+begin_src js
const { isReactive, effect, reactive, targetMap } = require(process.env.PWD + '/../../static/js/vue/reactivity.global.js')
const obj = {}
const reactiveObj = reactive(obj)
console.log('reactiveObj is reactive, ' + isReactive(reactiveObj))
const prototype = reactiveObj['__proto__']
const otherObj = { data: ['a'] }
console.log('otherObj is reactive, ' + isReactive(otherObj))
const reactiveOther = reactive(otherObj)
console.log('reactiveOther is reactive, ' + isReactive(reactiveOther))
console.log('reactiveOther.data[0] is `a`, ' + ( reactiveOther.data[0] === 'a' ))
console.log(`__proto__, ` + prototype)
#+end_src

+RESULTS:
: reactiveObj is reactive, true
: otherObj is reactive, false
: reactiveOther is reactive, true
: reactiveOther.data[0] is `a`, true
: __proto__, [object Object]
: undefined

FIX: [[https://github.com/gcclll/stb-vue-next/commit/1e2a3fef77b4a2b5f4dc3c497296b30b4ff06883][1005ef3]] 当取值时属性名为 ~__proto__~ 时：直接返回取值结果。

[[https://github.com/gcclll/stb-vue-next/commit/1e2a3fef77b4a2b5f4dc3c497296b30b4ff06883][feat: get key is symbol or __proto__ or __v_isRef · gcclll/stb-vue-next@1e2a3fe]]
*** 用例三：嵌套对象

#+begin_src js
const {isReactive, effect, reactive, targetMap } = require(process.env.PWD + '/../../static/js/vue/reactivity.global.js')
const original = {
  nested: {
    foo: 1
  },
  array: [{ bar: 2 }]
}

const observed = reactive(original)
console.log(`observed.nested is reactive ${isReactive(observed.nested)}`)
console.log(`observed.array is reactive ${isReactive(observed.array)}`)
console.log(`observed.array[0] is reactive ${isReactive(observed.array[0])}`)
#+end_src

+RESULTS:
: observed.nested is reactive true
: observed.array is reactive true
: observed.array[0] is reactive true

*** 用例四：代理后的对象操作也会体现在原对象上

#+begin_src js
const { isReactive, effect, reactive, targetMap } =
      require(process.env.PWD + '/../../static/js/vue/reactivity.global.js')

const or = { foo: 1 }
const ob = reactive(or)
ob.bar = 1
console.log(`ob.bar = ${ob.bar}, or.bar = ${or.bar}`)
delete ob.foo
console.log(`'foo' in ob: ${'foo' in ob}, 'foo' in or: ${'foo' in or}`)
#+end_src

+RESULTS:
: ob.bar = 1, or.bar = 1
: 'foo' in ob: false, 'foo' in or: false

结果删除后，依旧在，需要实现 delete proxy handler。
*** 用例五：原始对象上的操作也要能在代理后对象有所体现

#+begin_src js
const { isReactive, effect, reactive, targetMap } = require(process.env.PWD + '/../../static/js/vue/reactivity.global.js')

const original = { foo: 1 }
const observed = reactive(original)

original.bar = 1
console.log(`observed.bar = ${observed.bar}, original.bar = ${original.bar}`)
delete original.foo
console.log(`'foo' in original: ${'foo' in original}, 'foo' in observed: ${'foo' in observed}`)
#+end_src

+RESULTS:
: observed.bar = 1, original.bar = 1
: 'foo' in original: false, 'foo' in observed: false

*** 用例六：被设置的值如果是对象，该对象也会被 Reactive

#+begin_src js
const { isReactive, effect, reactive, targetMap } = require(process.env.PWD + '/../../static/js/vue/reactivity.global.js')

const observed = reactive({})
const raw = {}
observed.foo = raw // #0
console.log(`observed.foo === faw, ${observed.foo === raw}`) // #1
console.log(`observed.foo is reactive, ${isReactive(observed.foo)}`)
#+end_src

+RESULTS:
: observed.foo === faw, false
: observed.foo is reactive, true

访问 raw 之前(*#1* 之前)它还不是 reactive，因为递归 reactive 发生在 track() 中，即取值阶段。

如：控制台测试输出
#+begin_example
var ob = reactive({})
var raw = {}
ob.foo = raw
ob
    Proxy {foo: {…}}
        [[Handler]]: Object
            deleteProperty: ƒ deleteProperty(target, key)
            get: ƒ (target, key, receiver)
            set: ƒ (target, key, value, receiver)
        [[Target]]: Object
            foo: {} // 注意这里
        [[IsRevoked]]: false
#+end_example

进行一次取值：
#+begin_example
ob.foo
    Proxy {}
        [[Handler]]: Object
        [[Target]]: Object
        [[IsRevoked]]: false
#+end_example
*** 用例七：不该重复 proxy，返回第一个 proxy 结果

#+begin_src js
const { isReactive, effect, reactive, targetMap } = require(process.env.PWD + '/../../static/js/vue/reactivity.global.js')

const original = { foo: 1 } // #1
const observed1 = reactive(original) // #2
const observed2 = reactive(observed1) // #3
console.log(`observed2 === observed1, ${observed2 === observed1}`)
#+end_src

#+RESULTS:
: observed2 === observed1, true
: undefined

因为 ~reactive()~ 实现中组了检测，如果自身是个 proxy 就直接返回，所以 *#3* 中实
际直接将 ~observed1~ 返回了。
*** TODO 用例八：不应该用 proxies 污染原始对象？

#+begin_src js
const { isReactive, effect, reactive, targetMap } = require(process.env.PWD + '/../../static/js/vue/reactivity.global.js')

const original = { foo: 1 }
const original2 = { bar: 2 }
const observed = reactive(original)
const observed2 = reactive(original2)
observed.bar = observed2
console.log(`observed.bar === observed2, ${observed.bar === observed2}`)
console.log(`original.bar === original2, ${original.bar === original2}`)
#+end_src

+RESULTS:
: observed.bar === observed2, true
: original.bar === original2, false
* [[https://github.com/gcclll/stb-vue-next/commit/598e047407fe52183468037beb45328878431a55][443a0b5]] basic proxy get handler(createGetter)

[[https://github.com/gcclll/stb-vue-next/commit/598e047407fe52183468037beb45328878431a55][feat: reactive proxy get handler · gcclll/stb-vue-next@598e047]]

commit: 只实现对象的 ~get proxy handler~ ，对象属性被访问的时候会触发代理，比如下面
实例中，当访问 ~observed.count~ 时候会触发 ~console.log({ res }, "get")~ 执行。

最简单 proxy get handler 脑图：
[[/img/vue3/reactivity/reactivity-basehd-get-01.svg]]

1. 调用 ~Reflect.get(target, key, receiver)~ 执行原子操作
2. 返回执行结果


#+begin_src typescript
function createGetter(isReadonly = false, shallow = false) {
  // target: 被取值的对象，key: 取值的属性，receiver: this 的值
  return function get(target: Target, key: string | symbol, receiver: object) {
    const res = Reflect.get(target, key, receiver)

    // 是否只需要 reactive 一级属性(不递归 reactive)
    if (shallow) {
      return res
    }

    return res
  }
}
export const mutableHandlers: ProxyHandler<object> = {
  get
}
#+end_src

测试：
#+begin_src js
const { effect, reactive, targetMap } = require(process.env.PWD + '/../../static/js/vue/reactivity.global.js')

const target = { count: 0 }
const ob = reactive(target)
effect(() => ob.count) // ob.count 属性 收集 effect fn

console.log(targetMap.get(target))
#+end_src

+RESULTS: effect 会立即执行 fn， ~ob.count~ 取值触发 get proxy 收集 fn -> count => deps<Set>
#+begin_example
Map(1) {
  'count' => Set(1) {
    [Function: reactiveEffect] {
      id: 0,
      allowRecurse: false,
      _isEffect: true,
      active: true,
      raw: [Function (anonymous)],
      deps: [Array],
      options: {}
    }
  }
}
#+end_example
* [[https://github.com/gcclll/stb-vue-next/commit/3fc963486868ca3583b02852f07a5aa5969ac354][6c50273]] add track() and effect()

[[https://github.com/gcclll/stb-vue-next/commit/3fc963486868ca3583b02852f07a5aa5969ac354][feat: track+effect · gcclll/stb-vue-next@3fc9634]]

为了完成观察属性，通过属性的取值操作来收集依赖过程，这里同时实现了 ~track()~ 和
~effect()~ 函数。

** track(target, type, key) 监听取值收集依赖：

   [[/img/vue3/reactivity/reactivity-basehd-get-02-track.svg]]

** effect(fn, options)

[[/img/vue3/reactivity/reactivity-effect.svg]]

- *参数列表* ：

    fn - 被封装的函数，里面可对对象执行 get/set 操作。

- *主要功能* ：将 fn 封装成 ~ReactiveEffect~ 函数

    #+begin_src typescript
    export interface ReactiveEffect<T = any> {
        (): T // effect函数主题
        _isEffect: true // 标记自身是不是一个 ReactiveEffect 类型
        id: number // uid++ 而来，全局的一个相对唯一的 id
        active: boolean // 记录当前的 effect 是不是激活状态
        raw: () => T // 封装之前的那个 fn
        deps: Array<Dep> // fn 的被依赖者列表
        options: ReactiveEffectOptions // 额外选项，如：lazy
        allowRecurse: boolean // ???
    }
    #+end_src

- *解决问题* :

    1. fn 封装之后，执行 fn 过程中使用 try...finally ，防止 fn 执行异常导致
       effect 进程中断
    2. 结合 shouldTrack, activeEffect 和 track() 函数，有效的避免了在 fn 中执行
       obj.value++ 导致 effect 死循环问题，因为 try...finally 确保了只有 fn 函数
       完成之后才会进入 finally 恢复 effect 状态(~shouldTrack = true,
       activeEffect = last || null~)。


相关函数及变量列表
| name                                | type             | desc                                                                              |
|-------------------------------------+------------------+-----------------------------------------------------------------------------------|
| ~activeEffect~                      | /ReactiveEffect/ | 当前正在处理的 Effect，fn 还未执行完成，finally 还没结束                          |
| ~effectStack~                       | /Array, []/      | 缓存所有状态还没完成的 Effect                                                     |
| ~shouldTrack~                       | /boolean, true/  | track() 中用来检测当前 effect 是否结束，从而判定是否可以继续执行 track() 收集依赖 |
| ~trackStack~                        | /Array, []/      | 保存着所有 Effect 的 shouldTrack 值                                               |
| ~effect()~                          | /function/       | 封装 fn成 ReactiveEffect 结构                                                     |
| ~track(target, type, key)~          | /function/       | 收集依赖，并且响应式递归                                                          |
| ~trigger(...)~                      | /function/       | 当值更新时触发所有依赖更新                                                        |
| ~createReactiveEffect(fn, options)~ | /function/       | effect() 函数主题功能分离出来                                                     |
| ~cleanup(effect: ReactiveEffect)~   | /function/       | 清空所有 fn 的依赖 effect.deps[]                                                  |
| ~enableTracking()~                  | /function/       | 使能 Effect ，shouldTrack = true, 并将其加入 trackStack                           |
| ~resetTracking()~                   | /function/       | 重置 Effect, shouldTrack = 上一个 Effect 的 shouldTrack 值或 true                 |

#+begin_src typescript
export function effect<T = any>(
  fn: () => T,
  options: ReactiveEffectOptions = EMPTY_OBJ
): ReactiveEffect<T> {
  if (isEffect(fn)) {
    fn = fn.raw // 取出原始的函数，封装之前的
  }

  // 封装成 ReactiveEffect
  const effect = createReactiveEffect(fn, options)

  if (!options.lazy) {
    // 如果并没指定 lazy: true 选项，则立即执行 effect 收集依赖
    // 因为 effect 一般都会有取值操作，此时会触发 proxy get handler
    // 然后执行 track() 结合当前的 activeEffect 即 effect() 执行时候的这个
    // effect，这样取值操作就和当前取值作用域下的依赖函数建立的依赖关系
    effect()
  }
  return effect
}

let uid = 0

function createReactiveEffect<T = any>(
  fn: () => T,
  options: ReactiveEffectOptions
): ReactiveEffect<T> {
  // 将 fn 执行封装成  ReactiveEffect 类型的函数
  const effect = function reactiveEffect(): unknown {
    if (!effect.active) {
      // 非激活状态，可能是手动调用了 stop
      // 那么执行的时候就需要考虑调用 stop 者是否提供了手动调度该 effect
      // 的函数 scheduler ? 也就是说你停止你可以重新启动
      return options.scheduler ? undefined : fn()
    }

    if (!effectStack.includes(effect)) {
      // 1. cleanup, 保持纯净
      cleanup(effect)
      try {
        // 2. 使其 tracking 状态有效，track() 中有用
        enableTracking() // track() 可以执行收集操作
        effectStack.push(effect) // effect 入栈
        // 3. 保存为当前的 activeEffect, track() 中有用
        activeEffect = effect // 记录当前的 effect -> track/trigger
        // 4. 执行 fn 并返回结果
        return fn() // 返回执行结果
      } finally {
        // 始终都会执行，避免出现异常将 effect 进程卡死
        // 5. 如果执行异常，丢弃当前的 effect ，并将状态重置为上一个 effect
        //   由一个 effect 栈来维护。

        effectStack.pop()
        resetTracking()
        activeEffect = effectStack[effectStack.length - 1]
      }
    }
  } as ReactiveEffect

  effect.id = uid++
  effect.allowRecurse = !!options.allowRecurse
  effect._isEffect = true
  effect.active = true
  effect.raw = fn // 这里保存原始函数引用
  effect.deps = []
  effect.options = options

  return effect
}

#+end_src

依赖和属性变更发生联系的桥梁模块。

1. ~effect(fn, options)~ 封装执行 fn，触发取值操作 ->
2. ~track(target, type, key)~ 收集对象及属性所有依赖 ->
3. fn 中设值操作触发 ~trigger(...)~ 执行所有 deps，更新 DOM。
* [[https://github.com/gcclll/stb-vue-next/commit/20afde9970282c144b978b005767bd2c710d54ab][736de7c]] add trigger() proxy set handler

[[https://github.com/gcclll/stb-vue-next/commit/20afde9970282c144b978b005767bd2c710d54ab][feat: proxy set and trigger operation · gcclll/stb-vue-next@20afde9]]

** proxy set handler(createSetter)

#+begin_src typescript

function createSetter(shallow = false) {
  return function set(
    target: object,
    key: string | symbol,
    value: unknown,
    receiver: object
  ): boolean {
    const oldValue = (target as any)[key]
    // TODO shallow or not, or ref ?
    //

    const hadKey =
      isArray(target) && isIntegerKey(key)
        ? Number(key) < target.length
        : hasOwn(target, key)

    const result = Reflect.set(target, key, value, receiver)

    if (target === toRaw(receiver)) {
      if (!hadKey) {
        // TODO ADD
      } else if (hasChanged(value, oldValue)) {
        trigger(target, TriggerOpTypes.SET, key, value, oldValue)
      }
    }

    return result
}
#+end_src

** trigger()

#+begin_src typescript
export function trigger(
  target: object,
  type: TriggerOpTypes,
  key?: unknown,
  newValue?: unknown,
  oldValue?: unknown,
  oldTarget?: Map<unknown, unknown> | Set<unknown>
) {
  const depsMap = targetMap.get(target)
  if (!depsMap) {
    return
  }

  const effects = new Set<ReactiveEffect>()
  const add = (effectsToAdd: Set<ReactiveEffect> | undefined) => {
    if (effectsToAdd) {
      effectsToAdd.forEach(effect => {
        if (effect !== activeEffect || effect.allowRecurse) {
          effects.add(effect)
        }
      })
    }
  }

  if (type === TriggerOpTypes.CLEAR) {
    // TODO collection clear operation
  } else if (key === 'length' && isArray(target)) {
    // TODO array change operation
  } else {
    // SET | ADD | DELETE operation
    if (key !== void 0) {
      add(depsMap.get(key))
    }

    // TODO 迭代器 key，for...of, 使用迭代器是对数据的监听变化
  }

  const run = (effect: ReactiveEffect) => {
    if (__DEV__ && effect.options.onTrigger) {
      effect.options.onTrigger({
        effect,
        target,
        key,
        type,
        newValue,
        oldValue,
        oldTarget
      })
    }

    if (effect.options.scheduler) {
      effect.options.scheduler(effect)
    } else {
      effect()
    }
  }

  effects.forEach(run)
}
#+end_src
* [[https://github.com/gcclll/stb-vue-next/commit/b2143f9e35af77ee43792a6110ea70c4caf9a54f][b5f97b4]] observe object recursively

[[https://github.com/gcclll/stb-vue-next/commit/b2143f9e35af77ee43792a6110ea70c4caf9a54f][feat: observe object recursively · gcclll/stb-vue-next@b2143f9]]

针对嵌套对象进行递归 Reactive 。

[[/img/vue3/reactivity/reactivity-basehd-get-03-track-recursively.svg]]
* effect -> track -> trigger 关系图
:PROPERTIES:
:COLUMNS: %CUSTOM_ID[(Custom Id)]
:CUSTOM_ID: effect-track-trigger
:END: 

到此 effect + track + trigger 完成了最简单的响应式代码。

[[/img/vue3/reactivity/reactivity-effect-track-trigger.svg]]

1. effect 封装注册函数
2. track 取值触发收集依赖函数
3. trigger 设值触发所有依赖函数执行
* [[https://github.com/gcclll/stb-vue-next/commit/05b98c571560d2c1806d29cdda7b500b4b2bdeac][05b98c5]] add delete(*deleteProperty*) proxy handler
:PROPERTIES:
:COLUMNS: %CUSTOM_ID[(Custom Id)]
:CUSTOM_ID: c-delete
:END: 

[[https://github.com/gcclll/stb-vue-next/commit/05b98c571560d2c1806d29cdda7b500b4b2bdeac][feat: delete proxy handler · gcclll/stb-vue-next@05b98c5]]

#+begin_src typescript
function deleteProperty(target: object, key: string | symbol): boolean {
  const hadKey = hasOwn(target, key)
  const oldValue = (target as any)[key]
  const result = Reflect.deleteProperty(target, key)
  if (result && hadKey) {
    // 删除成功，触发 DELETE
    trigger(target, TriggerOpTypes.DELETE, key, undefined, oldValue)
  }
  return result
}

export const mutableHandlers: ProxyHandler<object> = {
  get,	  get,
  set	  set,
  deleteProperty
}
#+end_src

删除成功调用 ~trigger()~ 触发 *DELETE* 。
* [[https://github.com/gcclll/stb-vue-next/commit/ab69fe9eecb274f836bf19163636bd8f464b84d1][05b98c5]] add has, ownKeys proxy handlers

[[https://github.com/gcclll/stb-vue-next/commit/ab69fe9eecb274f836bf19163636bd8f464b84d1][feat: has + ownKeys proxy handler · gcclll/stb-vue-next@ab69fe9]]

增加 has, ownKeys proxy handlers.

#+begin_src typescript
function has(target: object, key: string | symbol): boolean {
  const result = Reflect.has(target, key)
  if (!isSymbol(key) || !builtInSymbols.has(key)) {
    track(target, TrackOpTypes.HAS, key)
  }
  return result
}

function ownKeys(target: object): (string | num | symbol)[] {
  track(target, TrackOpTypes.ITERATE, isArray(target) ? 'length' : ITERATE_KEY)
  return Reflect.ownKeys(target)
}
#+end_src

测试：

#+begin_src js
const { isReactive, effect, reactive, targetMap } = require(process.env.PWD + '/../../static/js/vue/reactivity.global.js')

const obj = reactive({ n: 0 })
let dummy = false
const runner = effect(() => (dummy = 'n' in obj), { lazy: true })

console.log(`before run effect, dummy = ${dummy}`)
runner()
console.log(`after run effect, dummy = ${dummy}`)
#+end_src

+RESULTS:
: before run effect, dummy = false
: after run effect, dummy = true
* TODO [[https://github.com/gcclll/stb-vue-next/commit/9aeb678befc3826b2ce8976b62c1172b4800df27][9aeb678]] add array support

[[https://github.com/gcclll/stb-vue-next/commit/9aeb678befc3826b2ce8976b62c1172b4800df27][feat: array support · gcclll/stb-vue-next@9aeb678]]

修改点：
#+begin_src typescript
// 数组内置方法处理
const arrayInstrumentations: Record<string, Function> = {}
;(['includes', 'indexOf', 'lastIndexOf'] as const).forEach(key => {
  const method = Array.prototype[key] as any
  arrayInstrumentations[key] = function(this: unknown[], ...args: unknown[]) {
    const arr = toRaw(this)
    for (let i = 0, l = this.length; i < l; i++) {
      track(arr, TrackOpTypes.GET, i + '')
    }

    const res = method.apply(arr, args)
    if (res === -1 || res === false) {
      return method.apply(arr, args.map(toRaw))
    } else {
      return res
    }
  }
})
;(['push', 'pop', 'shift', 'unshift', 'splice'] as const).forEach(key => {
  const method = Array.prototype[key] as any
  arrayInstrumentations[key] = function(this: unknown[], ...args: unknown[]) {
    pauseTracking()
    const res = method.apply(this, args)
    resetTracking()
    return res
  }
})

// createGetter
function createGetter(isReadonly = false, shallow = false) {
  // ...
  // 4. target is array
  const targetIsArray = isArray(target)
  if (targetIsArray && hasOwn(arrayInstrumentations, key)) {
    return Reflect.get(arrayInstrumentations, key, receiver)
  }
  // ...
}
#+end_src

1. 索引操作(~includes, lastIndexOf, indexOf~)处理

   确保索引取值的时候，能使用 track() 正确收集对应索引的依赖列表。

2. 可改变原数组长度操作(~push, pop, shift, unshift, splice~)

   因为这些函数内部实现都需要访问及改变原数组的长度，因此这里需要做一层保护，它
   们执行之前 ~shouldTrack = false~ ，执行完成之后 ~shouldTrack = true~ ，避免
   ~track()~ 死循环。


下面均为 vue-next 源码中用例分析。
- [X] T1: 读写操作

    #+begin_src js
    const { isReactive, effect, reactive, targetMap } = require(process.env.PWD + '/../../static/js/vue/reactivity.global.js')

    const original = [{ foo: 1 }, { bar: 2 }]
    const observed = reactive(original)
    console.log(`#01 original !== observed, ${original !== observed}`)
    console.log(`#02 original is reactive, ${isReactive(original)}`)
    console.log(`#03 observed is reactive, ${isReactive(observed)}`)
    console.log(`#04 observed[0] is reactive, ${isReactive(observed[0])}`)

    const clone = observed.slice()
    console.log(`#05 clone[0] is reactive, ${isReactive(clone[0])}`)
    console.log(`#06 clone[0] !== original[0], ${clone[0] !== original[0]}`)
    console.log(`#07 clone[0] === observed[0], ${clone[0] === observed[0]}`)

    const value = { baz: 3 }
    const reactiveValue = reactive(value)
    observed[0] = value
    console.log(`#08 observed[0] === reactiveValue, ${observed[0] === reactiveValue}`)
    console.log(`#09 original[0] === value, ${original[0] === value}`)
    delete observed[0]
    console.log(`#10 observed[0] === undefined, ${observed[0] === undefined}`)
    console.log(`#11 original[0] === undefined, ${original[0] === undefined}`)
    observed.push(value)
    console.log(`#12 observed[2] === reactiveValue, ${observed[2] === reactiveValue}`)
    console.log(`#13 original[2] === value, ${original[2] === value}`)
    #+end_src

    +RESULTS:
    #+begin_example
    #01 original !== observed, true
    #02 original is reactive, false
    #03 observed is reactive, true
    #04 observed[0] is reactive, true
    #05 clone[0] is reactive, true
    #06 clone[0] !== original[0], true
    #07 clone[0] === observed[0], true
    #08 observed[0] === reactiveValue, true
    #09 original[0] === value, true
    #10 observed[0] === undefined, true
    #11 original[0] === undefined, true
    #12 observed[2] === reactiveValue, true
    #13 original[2] === value, true
    #+end_example

    分析：
  - *#01* 因为 Proxy [[https://tc39.es/ecma262/#sec-proxycreate][内部实现]]实际会创建新对象
  - *#02* 读取 ~__v_isReactive~ 在 ~createGetter()~ 里面会直接返回 ~!isReadonly~
  - *#03* 同上
  - *#04* 取值的时候返回结果之前会检测当前是不是对象如果是会执行递归 reactive
  - *#05* slice [[/post/javascript-apis/#api-array-slice][实现过程]]并非深拷贝
  - *#06* 和 ~observed[0] !== original[0]~ 一个原因
  - *#07* [[/post/javascript-apis/#api-array-slice][浅拷贝问题]]
  - *#08* 先 ~observed[0]~ 对 value 取值操作，此时 Reactive value 对象时，发现该对
  象已经有映射了(proxyMap 中已存在 value -> reactiveValue 关系。)
  - *#09* proxy 的改变也会体现在 original 对象上。

    #+begin_src js
    const target = {  }
    const ob = new Proxy(target, {})
    ob.value = { test: 1 }
    console.log(target)
    #+end_src

    +RESULTS:
    : { value: { test: 1 } }
  - *#10* 同上
  - *#11* 同上
  - *#12* 同 *#08* ~proxyMap~ 中有缓存了
  - *#13* 同上
- [X] T2：索引方法(includes, lastIndexOf, indexOf)

    #+begin_src js
    const { isReactive, effect, reactive, targetMap } = require(process.env.PWD + '/../../static/js/vue/reactivity.global.js')

    const raw = {}
    const arr = reactive([{}, {}])
    arr.push(raw)
    console.log(`arr.indexOf(raw), ${arr.indexOf(raw)}`)
    console.log(`arr.indexOf(raw, 3), ${arr.indexOf(raw, 3)}`)
    console.log(`arr.includes(raw), ${arr.includes(raw)}`)
    console.log(`arr.includes(raw, 3), ${arr.includes(raw, 3)}`)
    console.log(`arr.lastIndexOf(raw), ${arr.lastIndexOf(raw)}`)
    console.log(`arr.lastIndexOf(raw, 1), ${arr.lastIndexOf(raw, 1)}`)
    #+end_src

    +RESULTS:
    : arr.indexOf(raw), 2
    : arr.indexOf(raw, 3), -1
    : arr.includes(raw), true
    : arr.includes(raw, 3), false
    : arr.lastIndexOf(raw), 2
    : arr.lastIndexOf(raw, 1), -1
- [X] T3：数组元素本身已经是 Proxy

  #+begin_src js
  const { isReactive, effect, reactive, targetMap } = require(process.env.PWD + '/../../static/js/vue/reactivity.global.js')
  const raw = []
  const obj = reactive({})
  raw.push(obj)
  const arr = reactive(raw)
  console.log(`arr.includes(obj), ${arr.includes(obj)}`)
  #+end_src

  +RESULTS: 这个应该很好理解，对象已经是 proxy 之后不会再继续代理，而是返回
  proxyMap 中缓存过的代理结果。
  : arr.includes(obj), true
- [-] T4: [[/post/javascript-apis/#api-array-reverse][reverse]] 方法也应该是 reactive 的

  *TODO*: reverse 之后找不到(~indexOf~)原始对象了？

  根据 [[/post/javascript-apis/#api-array-reverse][reverse()]] 的实现原理，本质上是元素之间的替换操作，因此并不会改变数组或元
  素本身是 proxy 性质，且属于索引赋值操作，因此会触发索引的 reactive 相关操作。

  #+begin_src js
  const { isReactive, effect, reactive, targetMap, toRaw } = require(process.env.PWD + '/../../static/js/vue/reactivity.global.js')

  const obj = { a: 1 }
  const arr = reactive([obj, { b: 2 }])
  let index = -1
  console.log(`#1 obj === arr[0], ${obj === toRaw(arr[0])}`)
  effect(() => (index = arr.indexOf(obj))) // index = 0
  console.log(`#2 before reverse, index = ${index}`)
  arr.reverse() // #3
  console.log(`#4 after reverse, index = ${index}`)
  console.log(`#5 obj === arr[1], ${obj === toRaw(arr[1])}`)
  #+end_src

  #+RESULTS:
  : #1 obj === arr[0], true
  : #2 before reverse, index = 0
  : #4 after reverse, index = -1
  : #5 obj === arr[1], true
  : undefined

  +RESULTS: 失败
  : before reverse, index = 0
  : after reverse, index = -1
  : [ { b: 2 }, { a: 1 } ]
- [ ] T5: 使用 delete 删除数组元素时不应该触发 ~length~ 依赖

  #+begin_src js
  const { isReactive, effect, reactive, targetMap } = require(process.env.PWD + '/../../static/js/vue/reactivity.global.js')
  const arr = reactive([1,2,3])
  let dummy = 0
  effect(() => {
    dummy = arr.length + 1
  })

  console.log(`before delete, dummy = ${dummy}, arr = ${arr}, len = ${arr.length}`)
  delete arr[1]
  console.log(`after delete, dummy = ${dummy}, arr = ${arr}, len = ${arr.length}`)
  #+end_src

  +RESULTS: 删除操作并不会改变数组长度
  : before delete, dummy = 4, arr = 1,2,3, len = 3
  : after delete, dummy = 4, arr = 1,,3, len = 3
  : undefined

* 阶段测试一
** effect + track + trigger 响应式基本操作(get/set)
:PROPERTIES:
:COLUMNS: %CUSTOM_ID[(Custom Id)]
:CUSTOM_ID: test-01
:END: 

commit: [[https://github.com/gcclll/stb-vue-next/commit/b5f97b413d4628f4ec8fcf4e859d387ebfac3ad8][feat: effect-trigger · gcclll/stb-vue-next@b5f97b4]]

#+RESULTS:

1. lazy: true 标识 effect fn 不会立即执行
2. 点击 set 操作，此时并没有依赖，所以只会触发 count++
3. 当点击 get 操作，触发 ~track()~ 收集依赖 fn -> deps
4. 再点击 set 操作，此时已经有依赖，所以会 ~trigger()~ 所有依赖更新
5. options.scheduler 选项作用

   如果 options 有 scheduler 选项， ~trigger()~ 的时候不会立即执行 effects 而是
   调用 scheduler 并将当前需要被执行的 effect 当做参数给 scheduler，由使用者决定
   何时去执行 effect，比如需要在 dummy 更新之前做点什么。

#+begin_export html
<style>
#_effect_test_02>.box {
  display: flex;
  justify-content: space-around;
}
#_effect_test_02>.box>button{
  border: none;
  width: 250px;
}
</style>
<div id="_effect_test_02">
<div class="box">
    <button class="getval">点我触发 get操作！</button>
    <button class="setval">点我触发 set操作！</button>
</div>
<br>
<div class="box">
    <button class="before-scheduler">手动调用 scheduler 之前</button>
    <button class="after-scheduler">手动调用 scheduler 之后</button>
</div>
<br>
<div class="box">
    <button class="code">点击查看测试源码</button>
    <button class="reset">重置</button>
</div>
<div class="result"></div>
<code></code>
</div>
#+end_export

#+begin_export html
<script id="GW0MDx">
setTimeout(function test() {
    if (typeof $ === 'undefined') return

    var ins = VueReactivity
    var effect = ins.effect
    var reactive = ins.reactive
    var target = { count: 0 }
    var counter = reactive(target)
    
    var $el = $("#_effect_test_02")
    var LOG = function (msg) {
      _log($el, msg)
    }
    
    var lazyEffect = effect(
      function fn() {
        var c = counter.count
        LOG('正在执行 effect fn..., counter.count = ' + counter.count)
      }, {
        lazy: true
      }
    )

    var effected = false
    var getDeps = function () {
      if (!ins.targetMap) return new Set()
      const depsMap = ins.targetMap.get(target) || new Map()
      return depsMap.get('count') || new Set()
    }
    $el.find(".setval").click(function() {
      counter.count++
      var size = getDeps().size
      if (size === 0) {
        LOG('target 此时无任何依赖，deps.size = ' + size + ', counter.count = ' + counter.count)
      }
    })
    $el.find(".reset").click(function() {
      ins.cleanup(lazyEffect)
      $el.children(".result").html('')
      effected = false
      counter.count = 0
      dummy = 0
      runner = undefined
      times = 0
      LOG('target.count deps.size = ' + getDeps().size)
    })
    $el.find(".getval").click(function() {
      if (!effected) {
        effected = true
        lazyEffect() // 手动执行 effect
        LOG('手动执行 effect()，开始收集依赖 fn -> deps<Set>, size: ' + getDeps().size)
      }
      LOG('取值操作(target.count 的 deps 数)：'
        + ins.targetMap.get(target).get('count').size
        + ', counter.count = ' + counter.count)
    })

    $el.find('.code').click(function() {
      console.log($("#GW0MDx").html())
      LOG('源码已输出到控制台(F12-console)....')
    })

    var dummy = 0, runner
    var counter1 = reactive({ count: 0 })
    var times = 0
    var schedulerEffect = effect(function fn() {
      dummy = counter1.count
    }, {
      scheduler: function(_effect) {
        LOG('scheduler 执行次数 ' + ++times + ', dummy = ' + dummy)
        runner = function() {
          _effect()
        }
      }
    })

    LOG('scheduler effect fn 第一次会被执行， dummy = ' + dummy)
    $el.find('.before-scheduler').click(function() {
      LOG('scheduler 不会被执行, dummy = ' + dummy)
    })

    $el.find('.after-scheduler').click(function() {
      counter1.count++
      runner()
    })
}, 1000)
    
</script>
#+end_export

** 相关用例：
1. 立即执行一次 fn，观察基本属性(一个或多个)

   #+begin_src js
    const { effect, reactive, targetMap } = require(process.env.PWD + '/../../static/js/vue/reactivity.global.js')

    const ob = reactive({ n1: 0, n2: 10 })
    let times = 0, dummy = 0
    effect(() => {
    console.log('effect fn 被执行 ' + ++times + ' 次')
    dummy = ob.n1 + ob.n2
    })

    console.log('before set: dummy = ' + dummy)
    ob.n1 = ob.n2 = 10
    console.log('after set: dummy = ' + dummy)
   #+end_src

   +RESULTS:
   : effect fn 被执行 1 次
   : before set: dummy = 10
   : effect fn 被执行 2 次
   : after set: dummy = 20

2. 给同一个属性绑定多个 effects，值变更触发多个 effect

   #+begin_src  js
    const { effect, reactive, targetMap } = require(process.env.PWD + '/../../static/js/vue/reactivity.global.js')

    let d1, d2
    const ob = reactive({ count: 0 })
    effect(() => (d1 = ob.count))
    effect(() => (d2 = ob.count))

    console.log('before set: d1 = ' + d1 + ', d2 = ' + d2)
    ob.count = 3
    console.log('after set: d1 = ' + d1 + ', d2 = ' + d2)
   #+end_src

   +RESULTS:
   : before set: d1 = 0, d2 = 0
   : after set: d1 = 3, d2 = 3
** 支持对象嵌套
:PROPERTIES:
:COLUMNS: %CUSTOM_ID[(Custom Id)]
:CUSTOM_ID: test-02
:END:

commit: [[https://github.com/gcclll/stb-vue-next/commit/b2143f9e35af77ee43792a6110ea70c4caf9a54f?branch=b2143f9e35af77ee43792a6110ea70c4caf9a54f&diff=split][feat: observe object recursively · gcclll/stb-vue-next@b2143f9]]

测试：
* 完整脑图
:PROPERTIES:
:COLUMNS: %CUSTOM_ID[(Custom Id)]
:CUSTOM_ID: whole-mind-map
:END:

[[/img/vue3/reactivity/reactivity.svg]]
