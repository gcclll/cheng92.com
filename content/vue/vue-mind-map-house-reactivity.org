#+TITLE: Vue3 源码头脑风暴之☞reactivity
#+DATE: <2020-11-09 11:45:36>
#+TAGS[]: vue, vue3, compiler-core, parser, compiler
#+CATEGORIES[]: vue
#+LANGUAGE: zh-cn
#+STARTUP: indent shrink

#+begin_export html
<link href="https://fonts.goo~gleapis.com/cs~s2?family=ZCOOL+XiaoWei&display=swap" rel="stylesheet">
<kbd>
<font color="blue" size="3" style="font-family: 'ZCOOL XiaoWei', serif;">
  诗号：六道同坠，魔劫万千，引渡如来。
</font>
</kbd><br><br>
<script src="/js/vue/reactivity.global.js"></script>
<script>
function _log(el, content) {
  $(el).children('.result').append('<p>' + content + '</p>')
}
</script>
#+end_export

[[/img/bdx/yiyeshu-001.jpg]]

@@html:<kbd>@@
*stb-vue-next 完成拷贝于 [[https://github.com/vuejs/vue-next][vue-next]] ，主要目的学习及尝试应用于机顶盒环境。*
@@html:</kbd>@@

@@html:<kbd>@@ *本文依据 commit 进程进行记录* @@html:</kbd>@@

* init project
:PROPERTIES:
:COLUMNS: %CUSTOM_ID[(Custom Id)]
:CUSTOM_ID: init
:END:

初始化项目：[[https://github.com/gcclll/stb-vue-next/commit/cb3470d7c3f2944fd23e9155fc8a6afb7a51a732][feat: reactive-fn · gcclll/stb-vue-next@cb3470d]]

[[#while-mind-map][由于完整脑图会比较全而大所以放到文字最后去。。。]]

[[/img/vue3/reactivity/reactivity.svg][也可以点击该链接直接新窗口打开，效果更佳。]]
** [[https://github.com/gcclll/stb-vue-next/commit/cb3470d7c3f2944fd23e9155fc8a6afb7a51a732][4a6ac0e]] add: createReactiveObject
:PROPERTIES:
:COLUMNS: %CUSTOM_ID[(Custom Id)]
:CUSTOM_ID: fn cro
:END:

[[https://github.com/gcclll/stb-vue-next/commit/cb3470d7c3f2944fd23e9155fc8a6afb7a51a732][feat: reactive-fn · gcclll/stb-vue-next@cb3470d]]

[[/img/vue3/reactivity/reactivity-reactive.svg]]

仅增加函数声明:

#+begin_src typescript
export function reactive(target: object) {
  // 如果试图 observe 一个只读 proxy，返回只读版本
  if (target && (target as Target)[ReactiveFlags.IS_READONLY]) {
    return target
  }

  return createReactiveObject(
    target,
    false,
    mutableHandlers,
    {}
    // mutableCollectionHandlers
  )
}

function createReactiveObject(
  target: Target,
  isReadonly: boolean,
  baseHandlers: ProxyHandler<any>,
  collectionHandlers: ProxyHandler<any>
) {}
#+end_src

*mutableHandlers*: 普通对象类型的 proxy handlers

*mutableCollectionHandlers*: 集合类型的 proxy handlers，因为 ~Reflect~ 并没有对集
合类型做底层映射，所以需要特殊处理。

** [[https://github.com/gcclll/stb-vue-next/commit/443a0b5920efaf714de08b0975c17f1d652815e4][c0f0b7c]] feat: createReactiveObject

[[https://github.com/gcclll/stb-vue-next/commit/443a0b5920efaf714de08b0975c17f1d652815e4][feat: createReactiveObject · gcclll/stb-vue-next@443a0b5]]

[[/img/vue3/reactivity/reactivity-create-reactive-object.svg]]

1. 重点： ~new Proxy(target, collection)~
2. 被代理类型必须是对象(引用类型)
3. target 本身已经是 proxy 了
4. target 代理有缓存不用重复创建
5. 必须是合法的类型(~Object|Array|[Weak]Map|[Weak]Set~)才能被代理
6. 记得缓存新创建的代理关系(~proxyMap~ 全局变量)

** [[https://github.com/gcclll/stb-vue-next/commit/598e047407fe52183468037beb45328878431a55][443a0b5]] basic proxy get handler(createGetter)

[[https://github.com/gcclll/stb-vue-next/commit/598e047407fe52183468037beb45328878431a55][feat: reactive proxy get handler · gcclll/stb-vue-next@598e047]]

commit: 只实现对象的 ~get proxy handler~ ，对象属性被访问的时候会触发代理，比如下面
实例中，当访问 ~observed.count~ 时候会触发 ~console.log({ res }, "get")~ 执行。

最简单 proxy get handler 脑图：
[[/img/vue3/reactivity/reactivity-basehd-get-01.svg]]

1. 调用 ~Reflect.get(target, key, receiver)~ 执行原子操作
2. 返回执行结果


#+begin_src typescript
function createGetter(isReadonly = false, shallow = false) {
  // target: 被取值的对象，key: 取值的属性，receiver: this 的值
  return function get(target: Target, key: string | symbol, receiver: object) {
    const res = Reflect.get(target, key, receiver)

    // 是否只需要 reactive 一级属性(不递归 reactive)
    if (shallow) {
      return res
    }

    return res
  }
}
export const mutableHandlers: ProxyHandler<object> = {
  get
}
#+end_src

测试：
#+begin_src js
const { effect, reactive, targetMap } = require(process.env.PWD + '/../../static/js/vue/reactivity.global.js')

const target = { count: 0 }
const ob = reactive(target)
effect(() => ob.count) // ob.count 属性 收集 effect fn

console.log(targetMap.get(target))
#+end_src

+RESULTS: effect 会立即执行 fn， ~ob.count~ 取值触发 get proxy 收集 fn -> count => deps<Set>
#+begin_example
Map(1) {
  'count' => Set(1) {
    [Function: reactiveEffect] {
      id: 0,
      allowRecurse: false,
      _isEffect: true,
      active: true,
      raw: [Function (anonymous)],
      deps: [Array],
      options: {}
    }
  }
}
#+end_example
** [[https://github.com/gcclll/stb-vue-next/commit/3fc963486868ca3583b02852f07a5aa5969ac354][6c50273]] add track() and effect()

[[https://github.com/gcclll/stb-vue-next/commit/3fc963486868ca3583b02852f07a5aa5969ac354][feat: track+effect · gcclll/stb-vue-next@3fc9634]]

为了完成观察属性，通过属性的取值操作来收集依赖过程，这里同时实现了 ~track()~ 和
~effect()~ 函数。

*** track(target, type, key) 监听取值收集依赖：

   [[/img/vue3/reactivity/reactivity-basehd-get-02-track.svg]]

*** effect(fn, options)

- *参数列表* ：

    fn - 被封装的函数，里面可对对象执行 get/set 操作。

- *主要功能* ：将 fn 封装成 ~ReactiveEffect~ 函数

    #+begin_src typescript
    export interface ReactiveEffect<T = any> {
        (): T // effect函数主题
        _isEffect: true // 标记自身是不是一个 ReactiveEffect 类型
        id: number // uid++ 而来，全局的一个相对唯一的 id
        active: boolean // 记录当前的 effect 是不是激活状态
        raw: () => T // 封装之前的那个 fn
        deps: Array<Dep> // fn 的被依赖者列表
        options: ReactiveEffectOptions // 额外选项，如：lazy
        allowRecurse: boolean // ???
    }
    #+end_src

- *解决问题* :

    1. fn 封装之后，执行 fn 过程中使用 try...finally ，防止 fn 执行异常导致
       effect 进程中断
    2. 结合 shouldTrack, activeEffect 和 track() 函数，有效的避免了在 fn 中执行
       obj.value++ 导致 effect 死循环问题，因为 try...finally 确保了只有 fn 函数
       完成之后才会进入 finally 恢复 effect 状态(~shouldTrack = true,
       activeEffect = last || null~)。

#+begin_src typescript
export function effect<T = any>(
  fn: () => T,
  options: ReactiveEffectOptions = EMPTY_OBJ
): ReactiveEffect<T> {
  if (isEffect(fn)) {
    fn = fn.raw // 取出原始的函数，封装之前的
  }

  // 封装成 ReactiveEffect
  const effect = createReactiveEffect(fn, options)

  if (!options.lazy) {
    // 如果并没指定 lazy: true 选项，则立即执行 effect 收集依赖
    // 因为 effect 一般都会有取值操作，此时会触发 proxy get handler
    // 然后执行 track() 结合当前的 activeEffect 即 effect() 执行时候的这个
    // effect，这样取值操作就和当前取值作用域下的依赖函数建立的依赖关系
    effect()
  }
  return effect
}

let uid = 0

function createReactiveEffect<T = any>(
  fn: () => T,
  options: ReactiveEffectOptions
): ReactiveEffect<T> {
  // 将 fn 执行封装成  ReactiveEffect 类型的函数
  const effect = function reactiveEffect(): unknown {
    if (!effect.active) {
      // 非激活状态，可能是手动调用了 stop
      // 那么执行的时候就需要考虑调用 stop 者是否提供了手动调度该 effect
      // 的函数 scheduler ? 也就是说你停止你可以重新启动
      return options.scheduler ? undefined : fn()
    }

    if (!effectStack.includes(effect)) {
      // 1. cleanup, 保持纯净
      cleanup(effect)
      try {
        // 2. 使其 tracking 状态有效，track() 中有用
        enableTracking() // track() 可以执行收集操作
        effectStack.push(effect) // effect 入栈
        // 3. 保存为当前的 activeEffect, track() 中有用
        activeEffect = effect // 记录当前的 effect -> track/trigger
        // 4. 执行 fn 并返回结果
        return fn() // 返回执行结果
      } finally {
        // 始终都会执行，避免出现异常将 effect 进程卡死
        // 5. 如果执行异常，丢弃当前的 effect ，并将状态重置为上一个 effect
        //   由一个 effect 栈来维护。

        effectStack.pop()
        resetTracking()
        activeEffect = effectStack[effectStack.length - 1]
      }
    }
  } as ReactiveEffect

  effect.id = uid++
  effect.allowRecurse = !!options.allowRecurse
  effect._isEffect = true
  effect.active = true
  effect.raw = fn // 这里保存原始函数引用
  effect.deps = []
  effect.options = options

  return effect
}

#+end_src

函数及变量列表
| name                                | type             | desc                                                                              |
|-------------------------------------+------------------+-----------------------------------------------------------------------------------|
| ~activeEffect~                      | /ReactiveEffect/ | 当前正在处理的 Effect，fn 还未执行完成，finally 还没结束                          |
| ~effectStack~                       | /Array, []/      | 缓存所有状态还没完成的 Effect                                                     |
| ~shouldTrack~                       | /boolean, true/  | track() 中用来检测当前 effect 是否结束，从而判定是否可以继续执行 track() 收集依赖 |
| ~trackStack~                        | /Array, []/      | 保存着所有 Effect 的 shouldTrack 值                                               |
| ~effect()~                          | /function/       | 封装 fn成 ReactiveEffect 结构                                                     |
| ~track(target, type, key)~          | /function/       | 收集依赖，并且响应式递归                                                          |
| ~trigger(...)~                      | /function/       | 当值更新时触发所有依赖更新                                                        |
| ~createReactiveEffect(fn, options)~ | /function/       | effect() 函数主题功能分离出来                                                     |
| ~cleanup(effect: ReactiveEffect)~   | /function/       | 清空所有 fn 的依赖 effect.deps[]                                                  |
| ~enableTracking()~                  | /function/       | 使能 Effect ，shouldTrack = true, 并将其加入 trackStack                           |
| ~resetTracking()~                   | /function/       | 重置 Effect, shouldTrack = 上一个 Effect 的 shouldTrack 值或 true                 |

[[/img/vue3/reactivity/reactivity-effect.svg]]

依赖和属性变更发生联系的桥梁模块。

1. ~effect(fn, options)~ 封装执行 fn，触发取值操作 ->
2. ~track(target, type, key)~ 收集对象及属性所有依赖 ->
3. fn 中设值操作触发 ~trigger(...)~ 执行所有 deps，更新 DOM。
** [[https://github.com/gcclll/stb-vue-next/commit/20afde9970282c144b978b005767bd2c710d54ab][736de7c]] add trigger() proxy set handler

[[https://github.com/gcclll/stb-vue-next/commit/20afde9970282c144b978b005767bd2c710d54ab][feat: proxy set and trigger operation · gcclll/stb-vue-next@20afde9]]

*** proxy set handler(createSetter)

#+begin_src typescript

function createSetter(shallow = false) {	function createSetter(shallow = false) {
  // TODO	  return function set(
    target: object,
    key: string | symbol,
    value: unknown,
    receiver: object
  ): boolean {
    const oldValue = (target as any)[key]
    // TODO shallow or not, or ref ?
    //

    const hadKey =
      isArray(target) && isIntegerKey(key)
        ? Number(key) < target.length
        : hasOwn(target, key)

    const result = Reflect.set(target, key, value, receiver)

    if (target === toRaw(receiver)) {
      if (!hadKey) {
        // TODO ADD
      } else if (hasChanged(value, oldValue)) {
        trigger(target, TriggerOpTypes.SET, key, value, oldValue)
      }
    }

    return result
  }
}
#+end_src
*** trigger()

#+begin_src typescript


export function trigger(
  target: object,
  type: TriggerOpTypes,
  key?: unknown,
  newValue?: unknown,
  oldValue?: unknown,
  oldTarget?: Map<unknown, unknown> | Set<unknown>
) {
  const depsMap = targetMap.get(target)
  if (!depsMap) {
    return
  }

  const effects = new Set<ReactiveEffect>()
  const add = (effectsToAdd: Set<ReactiveEffect> | undefined) => {
    if (effectsToAdd) {
      effectsToAdd.forEach(effect => {
        if (effect !== activeEffect || effect.allowRecurse) {
          effects.add(effect)
        }
      })
    }
  }

  if (type === TriggerOpTypes.CLEAR) {
    // TODO collection clear operation
  } else if (key === 'length' && isArray(target)) {
    // TODO array change operation
  } else {
    // SET | ADD | DELETE operation
    if (key !== void 0) {
      add(depsMap.get(key))
    }

    // TODO 迭代器 key，for...of, 使用迭代器是对数据的监听变化
  }

  const run = (effect: ReactiveEffect) => {
    if (__DEV__ && effect.options.onTrigger) {
      effect.options.onTrigger({
        effect,
        target,
        key,
        type,
        newValue,
        oldValue,
        oldTarget
      })
    }

    if (effect.options.scheduler) {
      effect.options.scheduler(effect)
    } else {
      effect()
    }
  }

  effects.forEach(run)
}
#+end_src
** b5f97b4 observe object recursively

[[https://github.com/gcclll/stb-vue-next/commit/b2143f9e35af77ee43792a6110ea70c4caf9a54f][feat: observe object recursively · gcclll/stb-vue-next@b2143f9]]

针对嵌套对象进行递归 Reactive 。

[[/img/vue3/reactivity/reactivity-basehd-get-03-track-recursively.svg]]
** effect -> track -> trigger 关系图
:PROPERTIES:
:COLUMNS: %CUSTOM_ID[(Custom Id)]
:CUSTOM_ID: effect-track-trigger
:END: 

到此 effect + track + trigger 完成了最简单的响应式代码。

[[/img/vue3/reactivity/reactivity-effect-track-trigger.svg]]

1. effect 封装注册函数
2. track 取值触发收集依赖函数
3. trigger 设值触发所有依赖函数执行
* 功能测试
:PROPERTIES:
:COLUMNS: %CUSTOM_ID[(Custom Id)]
:CUSTOM_ID: test
:END:
** effect + track + trigger 响应式基本操作(get/set)
:PROPERTIES:
:COLUMNS: %CUSTOM_ID[(Custom Id)]
:CUSTOM_ID: test-01
:END: 

commit: [[https://github.com/gcclll/stb-vue-next/commit/b5f97b413d4628f4ec8fcf4e859d387ebfac3ad8][feat: effect-trigger · gcclll/stb-vue-next@b5f97b4]]

#+RESULTS:

1. lazy: true 标识 effect fn 不会立即执行
2. 点击 set 操作，此时并没有依赖，所以只会触发 count++
3. 当点击 get 操作，触发 ~track()~ 收集依赖 fn -> deps
4. 再点击 set 操作，此时已经有依赖，所以会 ~trigger()~ 所有依赖更新
5. options.scheduler 选项作用

   如果 options 有 scheduler 选项， ~trigger()~ 的时候不会立即执行 effects 而是
   调用 scheduler 并将当前需要被执行的 effect 当做参数给 scheduler，由使用者决定
   何时去执行 effect，比如需要在 dummy 更新之前做点什么。

#+begin_export html
<style>
#_effect_test_02>.box {
  display: flex;
  justify-content: space-around;
}
#_effect_test_02>.box>button{
  border: none;
  width: 250px;
}
</style>
<div id="_effect_test_02">
<div class="box">
    <button class="getval">点我触发 get操作！</button>
    <button class="setval">点我触发 set操作！</button>
</div>
<br>
<div class="box">
    <button class="before-scheduler">手动调用 scheduler 之前</button>
    <button class="after-scheduler">手动调用 scheduler 之后</button>
</div>
<br>
<div class="box">
    <button class="code">点击查看测试源码</button>
    <button class="reset">重置</button>
</div>
<div class="result"></div>
<code></code>
</div>
#+end_export

#+begin_export html
<script id="GW0MDx">
setTimeout(function test() {
    if (typeof $ === 'undefined') return

    var ins = VueReactivity
    var effect = ins.effect
    var reactive = ins.reactive
    var target = { count: 0 }
    var counter = reactive(target)
    
    var $el = $("#_effect_test_02")
    var LOG = function (msg) {
      _log($el, msg)
    }
    
    var lazyEffect = effect(
      function fn() {
        var c = counter.count
        LOG('正在执行 effect fn..., counter.count = ' + counter.count)
      }, {
        lazy: true
      }
    )

    var effected = false
    var getDeps = function () {
      if (!ins.targetMap) return new Set()
      const depsMap = ins.targetMap.get(target) || new Map()
      return depsMap.get('count') || new Set()
    }
    $el.find(".setval").click(function() {
      counter.count++
      var size = getDeps().size
      if (size === 0) {
        LOG('target 此时无任何依赖，deps.size = ' + size + ', counter.count = ' + counter.count)
      }
    })
    $el.find(".reset").click(function() {
      ins.cleanup(lazyEffect)
      $el.children(".result").html('')
      effected = false
      counter.count = 0
      dummy = 0
      runner = undefined
      times = 0
      LOG('target.count deps.size = ' + getDeps().size)
    })
    $el.find(".getval").click(function() {
      if (!effected) {
        effected = true
        lazyEffect() // 手动执行 effect
        LOG('手动执行 effect()，开始收集依赖 fn -> deps<Set>, size: ' + getDeps().size)
      }
      LOG('取值操作(target.count 的 deps 数)：'
        + ins.targetMap.get(target).get('count').size
        + ', counter.count = ' + counter.count)
    })

    $el.find('.code').click(function() {
      console.log($("#GW0MDx").html())
      LOG('源码已输出到控制台(F12-console)....')
    })

    var dummy = 0, runner
    var counter1 = reactive({ count: 0 })
    var times = 0
    var schedulerEffect = effect(function fn() {
      dummy = counter1.count
    }, {
      scheduler: function(_effect) {
        LOG('scheduler 执行次数 ' + ++times + ', dummy = ' + dummy)
        runner = function() {
          _effect()
        }
      }
    })

    LOG('scheduler effect fn 第一次会被执行， dummy = ' + dummy)
    $el.find('.before-scheduler').click(function() {
      LOG('scheduler 不会被执行, dummy = ' + dummy)
    })

    $el.find('.after-scheduler').click(function() {
      counter1.count++
      runner()
    })
}, 1000)
    
</script>
#+end_export

-----

相关用例：
1. 立即执行一次 fn，观察基本属性(一个或多个)

   #+begin_src js
    const { effect, reactive, targetMap } = require(process.env.PWD + '/../../static/js/vue/reactivity.global.js')

    const ob = reactive({ n1: 0, n2: 10 })
    let times = 0, dummy = 0
    effect(() => {
    console.log('effect fn 被执行 ' + ++times + ' 次')
    dummy = ob.n1 + ob.n2
    })

    console.log('before set: dummy = ' + dummy)
    ob.n1 = ob.n2 = 10
    console.log('after set: dummy = ' + dummy)
   #+end_src

   +RESULTS:
   : effect fn 被执行 1 次
   : before set: dummy = 10
   : effect fn 被执行 2 次
   : after set: dummy = 20

2. 给同一个属性绑定多个 effects，值变更触发多个 effect

   #+begin_src  js
    const { effect, reactive, targetMap } = require(process.env.PWD + '/../../static/js/vue/reactivity.global.js')

    let d1, d2
    const ob = reactive({ count: 0 })
    effect(() => (d1 = ob.count))
    effect(() => (d2 = ob.count))

    console.log('before set: d1 = ' + d1 + ', d2 = ' + d2)
    ob.count = 3
    console.log('after set: d1 = ' + d1 + ', d2 = ' + d2)
   #+end_src

   +RESULTS:
   : before set: d1 = 0, d2 = 0
   : after set: d1 = 3, d2 = 3
** 支持对象嵌套
:PROPERTIES:
:COLUMNS: %CUSTOM_ID[(Custom Id)]
:CUSTOM_ID: test-02
:END:

commit: [[https://github.com/gcclll/stb-vue-next/commit/b2143f9e35af77ee43792a6110ea70c4caf9a54f?branch=b2143f9e35af77ee43792a6110ea70c4caf9a54f&diff=split][feat: observe object recursively · gcclll/stb-vue-next@b2143f9]]

测试：
* 完整脑图
:PROPERTIES:
:COLUMNS: %CUSTOM_ID[(Custom Id)]
:CUSTOM_ID: whole-mind-map
:END:

[[/img/vue3/reactivity/reactivity.svg]]
