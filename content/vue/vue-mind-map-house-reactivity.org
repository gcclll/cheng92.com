#+TITLE: Vue3 æºç å¤´è„‘é£æš´ä¹‹â˜reactivity
#+DATE: <2020-11-09 11:45:36>
#+TAGS[]: vue, vue3, compiler-core, parser, compiler
#+CATEGORIES[]: vue
#+LANGUAGE: zh-cn
#+STARTUP: indent shrink

#+begin_export html
<link href="https://fonts.goo~gleapis.com/cs~s2?family=ZCOOL+XiaoWei&display=swap" rel="stylesheet">
<kbd>
<font color="blue" size="3" style="font-family: 'ZCOOL XiaoWei', serif;">
  è¯—å·ï¼šå…­é“åŒå ï¼Œé­”åŠ«ä¸‡åƒï¼Œå¼•æ¸¡å¦‚æ¥ã€‚
</font>
</kbd><br><br>
<script src="/js/vue/reactivity.global.js"></script>
<script>
function _log(el, content) {
  $(el).children('.result').append('<p>' + content + '</p>')
}
</script>
#+end_export

[[/img/bdx/yiyeshu-001.jpg]]

* TODO Proxy & Reflect åŠŸèƒ½å›é¡¾

[[/post/javascript-apis/#api-proxy-reflect][Proxy å’Œ Reflect ç›¸å…³çš„ Apis ä¼ªç å’Œè¯´æ˜è¿æ¥ ğŸ›«]]

* Reactivity
:PROPERTIES:
:COLUMNS: %CUSTOM_ID[(Custom Id)]
:CUSTOM_ID: rt
:END:

vue-next æœ€æ–°çš„å“åº”å¼åŸç† ~Proxy + Reflect~ ã€‚

[[#while-mind-map][ç”±äºå®Œæ•´è„‘å›¾ä¼šæ¯”è¾ƒå…¨è€Œå¤§æ‰€ä»¥æ”¾åˆ°æ–‡å­—æœ€åå»ã€‚ã€‚ã€‚]]

[[/img/vue3/reactivity/reactivity.svg][ä¹Ÿå¯ä»¥ç‚¹å‡»è¯¥é“¾æ¥ç›´æ¥æ–°çª—å£æ‰“å¼€ï¼Œæ•ˆæœæ›´ä½³ã€‚]]

* reactive(target)
:PROPERTIES:
:COLUMNS: %CUSTOM_ID[(Custom Id)]
:CUSTOM_ID: fn-rt
:END:

commit: [[https://github.com/gcclll/stb-vue-next/commit/cb3470d7c3f2944fd23e9155fc8a6afb7a51a732][cb3470d7c3f2944fd23e9155fc8a6afb7a51a732]]

è¯¥å‡½æ•°æ˜¯ä½œä¸ºå“åº”å¼æ¨¡å—çš„å…¥å£å‡½æ•°ï¼Œä¸€ä¸ªéå¸¸ç®€å•çš„å¤„ç†å‡½æ•°ï¼š

1. åªè¯»ä»£ç†ï¼Œç›´æ¥è¿”å›è¯¥å¯¹è±¡
2. å¦åˆ™è°ƒç”¨ [[#rt-cro][createReactiveObject(...args)]]

[[/img/vue3/reactivity/reactivity-reactive.svg]]

#+begin_src typescript
export function reactive(target: object) {
  // å¦‚æœè¯•å›¾ observe ä¸€ä¸ªåªè¯» proxyï¼Œè¿”å›åªè¯»ç‰ˆæœ¬
  if (target && (target as Target)[ReactiveFlags.IS_READONLY]) {
    return target
  }

  return createReactiveObject(
    target,
    false,
    {},
    // mutableHandlers,
    {}
    // mutableCollectionHandlers
  )
#+end_src

*mutableHandlers*: æ™®é€šå¯¹è±¡ç±»å‹çš„ proxy handlers

*mutableCollectionHandlers*: é›†åˆç±»å‹çš„ proxy handlersï¼Œå› ä¸º ~Reflect~ å¹¶æ²¡æœ‰å¯¹é›†
åˆç±»å‹åšåº•å±‚æ˜ å°„ï¼Œæ‰€ä»¥éœ€è¦ç‰¹æ®Šå¤„ç†ã€‚
* createReactiveObject(...args)
:PROPERTIES:
:COLUMNS: %CUSTOM_ID[(Custom Id)]
:CUSTOM_ID: fn-cro
:END:

commit: [[https://github.com/gcclll/stb-vue-next/commit/443a0b5920efaf714de08b0975c17f1d652815e4][443a0b5920efaf714de08b0975c17f1d652815e4]]

è„‘å›¾ï¼š
[[/img/vue3/reactivity/reactivity-create-reactive-object.svg]]

#+begin_src typescript

function createReactiveObject(
  target: Target,
  isReadonly: boolean,
  baseHandlers: ProxyHandler<any>,
  collectionHandlers: ProxyHandler<any>
) {
  if (!isObject(target)) {
    if (__DEV__) {
      console.warn(`value cannot be made reactive: ${String(target)}`)
    }

    return target
  }

  // target å·²ç»æ˜¯ Proxyï¼Œä¸ç”¨é‡å¤ä»£ç†
  // å¼‚å¸¸æƒ…å†µï¼šåœ¨ä¸€ä¸ª reactive object ä¸Šè°ƒç”¨ readonly()
  if (
    target[ReactiveFlags.RAW] &&
    !(isReadonly && target[ReactiveFlags.IS_REACTIVE])
  ) {
    return target
  }

  // ä»£ç†ç¼“å­˜ä¸­æœ‰ï¼Œç›´æ¥å–å·²ç¼“å­˜çš„
  const proxyMap = isReadonly ? readonlyMap : reactiveMap
  const existingProxy = proxyMap.get(target)
  if (existingProxy) {
    return existingProxy
  }

  // åªæœ‰åˆæ³•çš„ç±»å‹(Object|Array|[Weak]Map|[Weak]Set)æ‰èƒ½è¢«ä»£ç†
  const targetType = getTargetType(target)
  if (targetType === TargetType.INVALID) {
    return target
  }

  const proxy = new Proxy(
    target,
    targetType === TargetType.COLLECTION ? collectionHandlers : baseHandlers
  )

  // ç¼“å­˜ä»£ç†æ˜ å°„å…³ç³»
  proxyMap.set(target, proxy)
  return proxy
#+end_src
* mutableHandlers
:PROPERTIES:
:COLUMNS: %CUSTOM_ID[(Custom Id)]
:CUSTOM_ID: hm
:END:

é’ˆå¯¹éé›†åˆå‹å¯¹è±¡è€Œè¨€ï¼Œç»“åˆ ~Reflect~ æ„å»º Proxy çš„ handlersã€‚

** get handler
:PROPERTIES:
:COLUMNS: %CUSTOM_ID[(Custom Id)]
:CUSTOM_ID: hm-get
:END:

*** only get proxy
:PROPERTIES:
:COLUMNS: %CUSTOM_ID[(Custom Id)]
:CUSTOM_ID: hm-get-proxy
:END:

æœ¬èŠ‚åªå®ç°å¯¹è±¡çš„ ~get proxy handler~ ï¼Œå¯¹è±¡å±æ€§è¢«è®¿é—®çš„æ—¶å€™ä¼šè§¦å‘ä»£ç†ï¼Œæ¯”å¦‚ä¸‹é¢
å®ä¾‹ä¸­ï¼Œå½“è®¿é—® ~observed.count~ æ—¶å€™ä¼šè§¦å‘ ~console.log({ res }, "get")~ æ‰§è¡Œã€‚

commit: [[https://github.com/gcclll/stb-vue-next/commit/598e047407fe52183468037beb45328878431a55][598e047407fe52183468037beb45328878431a55]]

æœ€ç®€å• proxy get handler è„‘å›¾ï¼š
[[/img/vue3/reactivity/reactivity-basehd-get-01.svg]]
1. è°ƒç”¨ ~Reflect.get(target, key, receiver)~ æ‰§è¡ŒåŸå­æ“ä½œ
2. è¿”å›æ‰§è¡Œç»“æœ

ä¸»è¦æ›´æ–°ä»£ç ï¼š
#+begin_src typescript
function createGetter(isReadonly = false, shallow = false) {
  // target: è¢«å–å€¼çš„å¯¹è±¡ï¼Œkey: å–å€¼çš„å±æ€§ï¼Œreceiver: this çš„å€¼
  return function get(target: Target, key: string | symbol, receiver: object) {
    // TODO 1. key is reactive
    // TODO 2. key is readonly
    // TODO 3. key is the raw target
    if (
      key === ReactiveFlags.RAW &&
      receiver === (isReadonly ? readonlyMap : reactiveMap).get(target)
    ) {
      return target
    }
    // TODO 4. target is array

    const res = Reflect.get(target, key, receiver)

    // TODO 5. key is symbol, or `__protot__ | __v_isRef`

    // DONE 6. not readonly, need to track and collect deps
    if (!isReadonly) {
      track(target, TrackOpTypes.GET, key)
    }

    // æ˜¯å¦åªéœ€è¦ reactive ä¸€çº§å±æ€§(ä¸é€’å½’ reactive)
    if (shallow) {
      return res
    }

    // TODO 6. res isRef

    // TODO 7. res is object -> reactive recursivly
    if (isObject(res)) {
      // é€’å½’ reactive åµŒå¥—å¯¹è±¡ï¼Œfeat: b2143f9
      return isReadonly ? null /* TODO */ : reactive(res)
    }

    return res
  }
}
#+end_src

è¿™é‡Œåªä¿ç•™çš„æœ€ç®€å•çš„ä»£ç†éƒ¨åˆ†ã€‚

æµ‹è¯•ä»£ç ï¼š
#+begin_src js
const { effect, reactive, targetMap } = require(process.env.PWD + '/../../static/js/vue/reactivity.global.js')

const target = { count: 0 }
const ob = reactive(target)
effect(() => ob.count) // ob.count å±æ€§ æ”¶é›† effect fn

console.log(targetMap.get(target))
#+end_src

+RESULTS: effect ä¼šç«‹å³æ‰§è¡Œ fnï¼Œ ~ob.count~ å–å€¼è§¦å‘ get proxy æ”¶é›† fn -> count => deps<Set>
#+begin_example
Map(1) {
  'count' => Set(1) {
    [Function: reactiveEffect] {
      id: 0,
      allowRecurse: false,
      _isEffect: true,
      active: true,
      raw: [Function (anonymous)],
      deps: [Array],
      options: {}
    }
  }
}
#+end_example

*** track get operation(è¿½è¸ª get æ“ä½œï¼Œæ”¶é›†ä¾èµ–)
:PROPERTIES:
:COLUMNS: %CUSTOM_ID[(Custom Id)]
:CUSTOM_ID: hm-get-track
:END:

commit: [[https://github.com/gcclll/stb-vue-next/commit/6c50273e3225761c2b1da63ce19c773603dbd523][6c50273e3225761c2b1da63ce19c773603dbd523]]

1. [[#effect-track][track(target, type, key)]] æ‰§è¡Œä¾èµ–æ”¶é›†ï¼š
2. [[#effect-effect][effect(fn, options)]] å°è£…ä¾èµ–å‡½æ•°ï¼Œå¹¶ç«‹å³æ‰§è¡Œ fn(~options.lazy = false~, æ—¶)

[[/img/vue3/reactivity/reactivity-basehd-get-02-track.svg]]

å¯¹äº ~effect()~ ç›¸å¯¹æ¯”è¾ƒç‹¬ç«‹çš„ä¸€ä¸ªå‡½æ•°ï¼Œç›®å‰é˜¶æ®µæ˜¯éœ€è¦æ‰‹åŠ¨å»è°ƒç”¨çš„ï¼Œæ‰€ä»¥è„‘å›¾å°±å•
ç‹¬å»ç»˜åˆ¶ã€‚
*** observe object recursivly(é€’å½’è§‚å¯Ÿå¯¹è±¡)
:PROPERTIES:
:COLUMNS: %CUSTOM_ID[(Custom Id)]
:CUSTOM_ID: hm-get-oor
:END:

commit: [[https://github.com/gcclll/stb-vue-next/commit/b2143f9e35af77ee43792a6110ea70c4caf9a54f?branch=b2143f9e35af77ee43792a6110ea70c4caf9a54f&diff=split][feat: observe object recursively Â· gcclll/stb-vue-next@b2143f9]]

[[/img/vue3/reactivity/reactivity-basehd-get-03-track-recursively.svg]]
* effect.ts
:PROPERTIES:
:COLUMNS: %CUSTOM_ID[(Custom Id)]
:CUSTOM_ID: file-effect
:END:

commit: [[https://github.com/gcclll/stb-vue-next/commit/3fc963486868ca3583b02852f07a5aa5969ac354][3fc963486868ca3583b02852f07a5aa5969ac354]]

å‡½æ•°åŠå˜é‡åˆ—è¡¨
| name                                | type             | desc                                                                              |
|-------------------------------------+------------------+-----------------------------------------------------------------------------------|
| ~activeEffect~                      | /ReactiveEffect/ | å½“å‰æ­£åœ¨å¤„ç†çš„ Effectï¼Œfn è¿˜æœªæ‰§è¡Œå®Œæˆï¼Œfinally è¿˜æ²¡ç»“æŸ                          |
| ~effectStack~                       | /Array, []/      | ç¼“å­˜æ‰€æœ‰çŠ¶æ€è¿˜æ²¡å®Œæˆçš„ Effect                                                     |
| ~shouldTrack~                       | /boolean, true/  | track() ä¸­ç”¨æ¥æ£€æµ‹å½“å‰ effect æ˜¯å¦ç»“æŸï¼Œä»è€Œåˆ¤å®šæ˜¯å¦å¯ä»¥ç»§ç»­æ‰§è¡Œ track() æ”¶é›†ä¾èµ– |
| ~trackStack~                        | /Array, []/      | ä¿å­˜ç€æ‰€æœ‰ Effect çš„ shouldTrack å€¼                                               |
| ~effect()~                          | /function/       | å°è£… fnæˆ ReactiveEffect ç»“æ„                                                     |
| ~track(target, type, key)~          | /function/       | æ”¶é›†ä¾èµ–ï¼Œå¹¶ä¸”å“åº”å¼é€’å½’                                                          |
| ~trigger(...)~                      | /function/       | å½“å€¼æ›´æ–°æ—¶è§¦å‘æ‰€æœ‰ä¾èµ–æ›´æ–°                                                        |
| ~createReactiveEffect(fn, options)~ | /function/       | effect() å‡½æ•°ä¸»é¢˜åŠŸèƒ½åˆ†ç¦»å‡ºæ¥                                                     |
| ~cleanup(effect: ReactiveEffect)~   | /function/       | æ¸…ç©ºæ‰€æœ‰ fn çš„ä¾èµ– effect.deps[]                                                  |
| ~enableTracking()~                  | /function/       | ä½¿èƒ½ Effect ï¼ŒshouldTrack = true, å¹¶å°†å…¶åŠ å…¥ trackStack                           |
| ~resetTracking()~                   | /function/       | é‡ç½® Effect, shouldTrack = ä¸Šä¸€ä¸ª Effect çš„ shouldTrack å€¼æˆ– true                 |

[[/img/vue3/reactivity/reactivity-effect.svg]]

ä¾èµ–å’Œå±æ€§å˜æ›´å‘ç”Ÿè”ç³»çš„æ¡¥æ¢æ¨¡å—ã€‚

1. ~effect(fn, options)~ å°è£…æ‰§è¡Œ fnï¼Œè§¦å‘å–å€¼æ“ä½œ ->
2. ~track(target, type, key)~ æ”¶é›†å¯¹è±¡åŠå±æ€§æ‰€æœ‰ä¾èµ– ->
3. fn ä¸­è®¾å€¼æ“ä½œè§¦å‘ ~trigger(...)~ æ‰§è¡Œæ‰€æœ‰ depsï¼Œæ›´æ–° DOMã€‚
   
** track(target, type, key)
:PROPERTIES:
:COLUMNS: %CUSTOM_ID[(Custom Id)]
:CUSTOM_ID: fn-effect-track
:END:

*å‚æ•°åˆ—è¡¨* ï¼š
    - ~target~ : è¢«ä»£ç†çš„å¯¹è±¡
    - ~type~ : ä»£ç†æ“ä½œç±»å‹(~get/has/iterate~)
    - ~key~ : å–å€¼æ“ä½œæ—¶å¯¹åº”çš„å±æ€§å

*ä¸»è¦åŠŸèƒ½* ï¼šå®ç°ä¾èµ–æ”¶é›†

*å®ç°åŸç†* ï¼šç»“åˆ [[#fn-effect-effect][effect(fn, options)]]è§¦å‘ /get proxy handler/ é‡Œé¢æ‰§
è¡Œ ~track(target, type, key)~ å°†å½“å‰çš„ ~activeEffect~ æ”¶é›†åˆ° ~depsMap~ , æ‰€
ä»¥ ~activeEffect~ æ˜¯é“¾æ¥ä¾èµ–å‡½æ•°å’Œå±æ€§æ“ä½œçš„æ¡¥æ¢ï¼Œè¿™å°†æ˜¯æœªæ¥è®¾ç½®å€¼çš„æ—¶å€™è§¦å‘ä¾èµ–
çš„å‘½è„‰ã€‚


 #+begin_src typescript
    export function track(target: object, type: TrackOpTypes, key: unknown) {
    if (!shouldTrack || activeEffect === undefined) {
        return
    }

    // Map< obj -> Map<key, Set[...deps]> >
    let depsMap = targetMap.get(target)
    if (!depsMap) {
        // åˆå§‹åŒ–
        targetMap.set(target, (depsMap = new Map()))
    }

    let dep = depsMap.get(key)
    if (!dep) {
        depsMap.set(key, (dep = new Set()))
    }

    // æ­£åœ¨è¯·æ±‚æ”¶é›†çš„ effect ï¼Œæ˜¯åˆæ¬¡å‡ºç°
    if (!dep.has(activeEffect)) {
        dep.add(activeEffect)
        // è‡ªèº«ä¿å­˜ä¸€ä»½è¢«ä¾èµ–è€…åå•
        activeEffect.deps.push(dep)
        if (__DEV__ && activeEffect.options.onTrack) {
        activeEffect.options.onTrack({
            effect: activeEffect,
            target,
            type,
            key
        })
        }
    }
#+end_src

- targetMap ä¿å­˜æ‰€ä»¥ä¾èµ–å…³ç³»ï¼Œå­˜å‚¨å½¢å¼ï¼š ~Map<target -> Map<key,
     Set[...deps]>>~

- å‰é¢ä¸¤ä¸ª if æ£€æµ‹ä¾èµ–æ˜¯å¦æœ‰ç¼“å­˜ï¼Œé¿å…é‡å¤

- æœ€åä¸¤ä¸ª ~add~ æ“ä½œï¼Œä¸€ä¸ªæ˜¯æ‰‹æœºä¾èµ–ï¼Œä¸€ä¸ªè®©å½“å‰çš„ ~effect~ æŒæœ‰è‡ªå·±èº«çš„è¢«ä¾èµ–
  è€…åå•
** effect(fn, options)
:PROPERTIES:
:COLUMNS: %CUSTOM_ID[(Custom Id)]
:CUSTOM_ID: fn-effect-effect
:END:

*å‚æ•°åˆ—è¡¨* ï¼š

    - ~fn~ ï¼šä¾èµ–å‡½æ•°ï¼Œè¯¥å‡½æ•°ä¸­å¯¹å¯¹è±¡å–å€¼ï¼Œè§¦å‘ track å°†å®ƒå°è£…åçš„
      ~ReactiveEffect~ æ”¶é›†åˆ°å–å€¼å±æ€§å¯¹åº”çš„ ~depsMap~ ä¸­
    - ~options~ : å…è®¸ä½¿ç”¨è€…æä¾›å¤–éƒ¨é€‰é¡¹ï¼Œæ§åˆ¶ effect è¡Œä¸ºï¼Œæ¯”å¦‚ï¼š ~lazy: true~
      å¯ä»¥æ§åˆ¶ effect æ˜¯å¦ä¼šç«‹å³æ‰§è¡Œï¼Œç«‹å³è§¦å‘ track ç­‰ä¸€ç³»åˆ—æ“ä½œã€‚

*ä¸»è¦åŠŸèƒ½* : å°è£…ä¾èµ–å‡½æ•°ï¼Œå¹¶ç«‹å³æ‰§è¡Œå®ƒï¼Œè§¦å‘ track æ”¶é›†ä¾èµ–ï¼Œä¸»è¦å®ç°è¿˜æ˜¯åœ¨
~createReactiveEffect(fn, options)~ ä¸­

#+begin_src typescript
export function effect<T = any>(
  fn: () => T,
  options: ReactiveEffectOptions = EMPTY_OBJ
): ReactiveEffect<T> {
  if (isEffect(fn)) {
    fn = fn.raw // å–å‡ºåŸå§‹çš„å‡½æ•°ï¼Œå°è£…ä¹‹å‰çš„
  }

  // å°è£…æˆ ReactiveEffect
  const effect = createReactiveEffect(fn, options)

  if (!options.lazy) {
    // å¦‚æœå¹¶æ²¡æŒ‡å®š lazy: true é€‰é¡¹ï¼Œåˆ™ç«‹å³æ‰§è¡Œ effect æ”¶é›†ä¾èµ–
    // å› ä¸º effect ä¸€èˆ¬éƒ½ä¼šæœ‰å–å€¼æ“ä½œï¼Œæ­¤æ—¶ä¼šè§¦å‘ proxy get handler
    // ç„¶åæ‰§è¡Œ track() ç»“åˆå½“å‰çš„ activeEffect å³ effect() æ‰§è¡Œæ—¶å€™çš„è¿™ä¸ª
    // effectï¼Œè¿™æ ·å–å€¼æ“ä½œå°±å’Œå½“å‰å–å€¼ä½œç”¨åŸŸä¸‹çš„ä¾èµ–å‡½æ•°å»ºç«‹çš„ä¾èµ–å…³ç³»
    effect()
  }
  return effect

#+end_src

** createReactiveEffect(fn, options)
:PROPERTIES:
:COLUMNS: %CUSTOM_ID[(Custom Id)]
:CUSTOM_ID: fn-effect-createReactiveEffect
:END:

*å‚æ•°åˆ—è¡¨* ï¼šæ²¿ç”¨ [[#fn-effect-effect][effect(fn, options)]]

*ä¸»è¦åŠŸèƒ½* ï¼šå°† fn å°è£…æˆ ~ReactiveEffect~ å‡½æ•°

    #+begin_src typescript
    export interface ReactiveEffect<T = any> {
        (): T // effectå‡½æ•°ä¸»é¢˜
        _isEffect: true // æ ‡è®°è‡ªèº«æ˜¯ä¸æ˜¯ä¸€ä¸ª ReactiveEffect ç±»å‹
        id: number // uid++ è€Œæ¥ï¼Œå…¨å±€çš„ä¸€ä¸ªç›¸å¯¹å”¯ä¸€çš„ id
        active: boolean // è®°å½•å½“å‰çš„ effect æ˜¯ä¸æ˜¯æ¿€æ´»çŠ¶æ€
        raw: () => T // å°è£…ä¹‹å‰çš„é‚£ä¸ª fn
        deps: Array<Dep> // fn çš„è¢«ä¾èµ–è€…åˆ—è¡¨
        options: ReactiveEffectOptions // é¢å¤–é€‰é¡¹ï¼Œå¦‚ï¼šlazy
        allowRecurse: boolean // ???
    }
    #+end_src

*è§£å†³é—®é¢˜* :

    1. fn å°è£…ä¹‹åï¼Œæ‰§è¡Œ fn è¿‡ç¨‹ä¸­ä½¿ç”¨ try...finally ï¼Œé˜²æ­¢ fn æ‰§è¡Œå¼‚å¸¸å¯¼è‡´
       effect è¿›ç¨‹ä¸­æ–­
    2. ç»“åˆ shouldTrack, activeEffect å’Œ track() å‡½æ•°ï¼Œæœ‰æ•ˆçš„é¿å…äº†åœ¨ fn ä¸­æ‰§è¡Œ
       obj.value++ å¯¼è‡´ effect æ­»å¾ªç¯é—®é¢˜ï¼Œå› ä¸º try...finally ç¡®ä¿äº†åªæœ‰ fn å‡½æ•°
       å®Œæˆä¹‹åæ‰ä¼šè¿›å…¥ finally æ¢å¤ effect çŠ¶æ€(~shouldTrack = true,
       activeEffect = last || null~)ã€‚

#+begin_src typescript
function createReactiveEffect<T = any>(
  fn: () => T,
  options: ReactiveEffectOptions
): ReactiveEffect<T> {
  // å°† fn æ‰§è¡Œå°è£…æˆ  ReactiveEffect ç±»å‹çš„å‡½æ•°
  const effect = function reactiveEffect(): unknown {
    if (!effect.active) {
      // éæ¿€æ´»çŠ¶æ€ï¼Œå¯èƒ½æ˜¯æ‰‹åŠ¨è°ƒç”¨äº† stop
      // é‚£ä¹ˆæ‰§è¡Œçš„æ—¶å€™å°±éœ€è¦è€ƒè™‘è°ƒç”¨ stop è€…æ˜¯å¦æä¾›äº†æ‰‹åŠ¨è°ƒåº¦è¯¥ effect
      // çš„å‡½æ•° scheduler ? ä¹Ÿå°±æ˜¯è¯´ä½ åœæ­¢ä½ å¯ä»¥é‡æ–°å¯åŠ¨
      return options.scheduler ? undefined : fn()
    }

    if (!effectStack.includes(effect)) {
      // 1. cleanup, ä¿æŒçº¯å‡€
      cleanup(effect)
      try {
        // 2. ä½¿å…¶ tracking çŠ¶æ€æœ‰æ•ˆï¼Œtrack() ä¸­æœ‰ç”¨
        enableTracking() // track() å¯ä»¥æ‰§è¡Œæ”¶é›†æ“ä½œ
        effectStack.push(effect) // effect å…¥æ ˆ
        // 3. ä¿å­˜ä¸ºå½“å‰çš„ activeEffect, track() ä¸­æœ‰ç”¨
        activeEffect = effect // è®°å½•å½“å‰çš„ effect -> track/trigger
        // 4. æ‰§è¡Œ fn å¹¶è¿”å›ç»“æœ
        return fn() // è¿”å›æ‰§è¡Œç»“æœ
      } finally {
        // å§‹ç»ˆéƒ½ä¼šæ‰§è¡Œï¼Œé¿å…å‡ºç°å¼‚å¸¸å°† effect è¿›ç¨‹å¡æ­»
        // 5. å¦‚æœæ‰§è¡Œå¼‚å¸¸ï¼Œä¸¢å¼ƒå½“å‰çš„ effect ï¼Œå¹¶å°†çŠ¶æ€é‡ç½®ä¸ºä¸Šä¸€ä¸ª effect
        //   ç”±ä¸€ä¸ª effect æ ˆæ¥ç»´æŠ¤ã€‚

        effectStack.pop()
        resetTracking()
        activeEffect = effectStack[effectStack.length - 1]
      }
    }
  } as ReactiveEffect

  effect.id = uid++
  effect.allowRecurse = !!options.allowRecurse
  effect._isEffect = true
  effect.active = true
  effect.raw = fn // è¿™é‡Œä¿å­˜åŸå§‹å‡½æ•°å¼•ç”¨
  effect.deps = []
  effect.options = options

  return effect

#+end_src
** trigger(target, type, key?, newValue?, oldValue?, oldTarget?)
:PROPERTIES:
:COLUMNS: %CUSTOM_ID[(Custom Id)]
:CUSTOM_ID: fn-effect-trigger
:END: 

commit: [[https://github.com/gcclll/stb-vue-next/commit/b5f97b413d4628f4ec8fcf4e859d387ebfac3ad8?branch=b5f97b413d4628f4ec8fcf4e859d387ebfac3ad8&diff=unified][b5f97b413d4628f4ec8fcf4e859d387ebfac3ad8]]
** effect -> track -> trigger å…³ç³»å›¾
:PROPERTIES:
:COLUMNS: %CUSTOM_ID[(Custom Id)]
:CUSTOM_ID: effect-track-trigger
:END: 

[[/img/vue3/reactivity/reactivity-effect-track-trigger.svg]]

* åŠŸèƒ½æµ‹è¯•
:PROPERTIES:
:COLUMNS: %CUSTOM_ID[(Custom Id)]
:CUSTOM_ID: test
:END:

** effect + track + trigger å“åº”å¼åŸºæœ¬æ“ä½œ(get/set)
:PROPERTIES:
:COLUMNS: %CUSTOM_ID[(Custom Id)]
:CUSTOM_ID: test-01
:END: 

commit: [[https://github.com/gcclll/stb-vue-next/commit/b5f97b413d4628f4ec8fcf4e859d387ebfac3ad8][feat: effect-trigger Â· gcclll/stb-vue-next@b5f97b4]]

#+RESULTS:

1. lazy: true æ ‡è¯† effect fn ä¸ä¼šç«‹å³æ‰§è¡Œ
2. ç‚¹å‡» set æ“ä½œï¼Œæ­¤æ—¶å¹¶æ²¡æœ‰ä¾èµ–ï¼Œæ‰€ä»¥åªä¼šè§¦å‘ count++
3. å½“ç‚¹å‡» get æ“ä½œï¼Œè§¦å‘ ~track()~ æ”¶é›†ä¾èµ– fn -> deps
4. å†ç‚¹å‡» set æ“ä½œï¼Œæ­¤æ—¶å·²ç»æœ‰ä¾èµ–ï¼Œæ‰€ä»¥ä¼š ~trigger()~ æ‰€æœ‰ä¾èµ–æ›´æ–°
5. options.scheduler é€‰é¡¹ä½œç”¨

   å¦‚æœ options æœ‰ scheduler é€‰é¡¹ï¼Œ ~trigger()~ çš„æ—¶å€™ä¸ä¼šç«‹å³æ‰§è¡Œ effects è€Œæ˜¯
   è°ƒç”¨ scheduler å¹¶å°†å½“å‰éœ€è¦è¢«æ‰§è¡Œçš„ effect å½“åšå‚æ•°ç»™ schedulerï¼Œç”±ä½¿ç”¨è€…å†³å®š
   ä½•æ—¶å»æ‰§è¡Œ effectï¼Œæ¯”å¦‚éœ€è¦åœ¨ dummy æ›´æ–°ä¹‹å‰åšç‚¹ä»€ä¹ˆã€‚

#+begin_export html
<style>
#_effect_test_02>.box {
  display: flex;
  justify-content: space-around;
}
#_effect_test_02>.box>button{
  border: none;
  width: 250px;
}
</style>
<div id="_effect_test_02">
<div class="box">
    <button class="getval">ç‚¹æˆ‘è§¦å‘ getæ“ä½œï¼</button>
    <button class="setval">ç‚¹æˆ‘è§¦å‘ setæ“ä½œï¼</button>
</div>
<br>
<div class="box">
    <button class="before-scheduler">æ‰‹åŠ¨è°ƒç”¨ scheduler ä¹‹å‰</button>
    <button class="after-scheduler">æ‰‹åŠ¨è°ƒç”¨ scheduler ä¹‹å</button>
</div>
<br>
<div class="box">
    <button class="code">ç‚¹å‡»æŸ¥çœ‹æµ‹è¯•æºç </button>
    <button class="reset">é‡ç½®</button>
</div>
<div class="result"></div>
<code></code>
</div>
#+end_export

#+begin_export html
<script id="GW0MDx">
setTimeout(function test() {
    if (typeof $ === 'undefined') return

    var ins = VueReactivity
    var effect = ins.effect
    var reactive = ins.reactive
    var target = { count: 0 }
    var counter = reactive(target)
    
    var $el = $("#_effect_test_02")
    var LOG = function (msg) {
      _log($el, msg)
    }
    
    var lazyEffect = effect(
      function fn() {
        var c = counter.count
        LOG('æ­£åœ¨æ‰§è¡Œ effect fn..., counter.count = ' + counter.count)
      }, {
        lazy: true
      }
    )

    var effected = false
    var getDeps = function () {
      if (!ins.targetMap) return new Set()
      const depsMap = ins.targetMap.get(target) || new Map()
      return depsMap.get('count') || new Set()
    }
    $el.find(".setval").click(function() {
      counter.count++
      var size = getDeps().size
      if (size === 0) {
        LOG('target æ­¤æ—¶æ— ä»»ä½•ä¾èµ–ï¼Œdeps.size = ' + size + ', counter.count = ' + counter.count)
      }
    })
    $el.find(".reset").click(function() {
      ins.cleanup(lazyEffect)
      $el.children(".result").html('')
      effected = false
      counter.count = 0
      dummy = 0
      runner = undefined
      times = 0
      LOG('target.count deps.size = ' + getDeps().size)
    })
    $el.find(".getval").click(function() {
      if (!effected) {
        effected = true
        lazyEffect() // æ‰‹åŠ¨æ‰§è¡Œ effect
        LOG('æ‰‹åŠ¨æ‰§è¡Œ effect()ï¼Œå¼€å§‹æ”¶é›†ä¾èµ– fn -> deps<Set>, size: ' + getDeps().size)
      }
      LOG('å–å€¼æ“ä½œ(target.count çš„ deps æ•°)ï¼š'
        + ins.targetMap.get(target).get('count').size
        + ', counter.count = ' + counter.count)
    })

    $el.find('.code').click(function() {
      console.log($("#GW0MDx").html())
      LOG('æºç å·²è¾“å‡ºåˆ°æ§åˆ¶å°(F12-console)....')
    })

    var dummy = 0, runner
    var counter1 = reactive({ count: 0 })
    var times = 0
    var schedulerEffect = effect(function fn() {
      dummy = counter1.count
    }, {
      scheduler: function(_effect) {
        LOG('scheduler æ‰§è¡Œæ¬¡æ•° ' + ++times + ', dummy = ' + dummy)
        runner = function() {
          _effect()
        }
      }
    })

    LOG('scheduler effect fn ç¬¬ä¸€æ¬¡ä¼šè¢«æ‰§è¡Œï¼Œ dummy = ' + dummy)
    $el.find('.before-scheduler').click(function() {
      LOG('scheduler ä¸ä¼šè¢«æ‰§è¡Œ, dummy = ' + dummy)
    })

    $el.find('.after-scheduler').click(function() {
      counter1.count++
      runner()
    })
}, 1000)
    
</script>
#+end_export

-----

ç›¸å…³ç”¨ä¾‹ï¼š
1. ç«‹å³æ‰§è¡Œä¸€æ¬¡ fnï¼Œè§‚å¯ŸåŸºæœ¬å±æ€§(ä¸€ä¸ªæˆ–å¤šä¸ª)

   #+begin_src js
    const { effect, reactive, targetMap } = require(process.env.PWD + '/../../static/js/vue/reactivity.global.js')

    const ob = reactive({ n1: 0, n2: 10 })
    let times = 0, dummy = 0
    effect(() => {
    console.log('effect fn è¢«æ‰§è¡Œ ' + ++times + ' æ¬¡')
    dummy = ob.n1 + ob.n2
    })

    console.log('before set: dummy = ' + dummy)
    ob.n1 = ob.n2 = 10
    console.log('after set: dummy = ' + dummy)
   #+end_src

   +RESULTS:
   : effect fn è¢«æ‰§è¡Œ 1 æ¬¡
   : before set: dummy = 10
   : effect fn è¢«æ‰§è¡Œ 2 æ¬¡
   : after set: dummy = 20

2. ç»™åŒä¸€ä¸ªå±æ€§ç»‘å®šå¤šä¸ª effectsï¼Œå€¼å˜æ›´è§¦å‘å¤šä¸ª effect

   #+begin_src  js
    const { effect, reactive, targetMap } = require(process.env.PWD + '/../../static/js/vue/reactivity.global.js')

    let d1, d2
    const ob = reactive({ count: 0 })
    effect(() => (d1 = ob.count))
    effect(() => (d2 = ob.count))

    console.log('before set: d1 = ' + d1 + ', d2 = ' + d2)
    ob.count = 3
    console.log('after set: d1 = ' + d1 + ', d2 = ' + d2)
   #+end_src

   +RESULTS:
   : before set: d1 = 0, d2 = 0
   : after set: d1 = 3, d2 = 3
** æ”¯æŒå¯¹è±¡åµŒå¥—
:PROPERTIES:
:COLUMNS: %CUSTOM_ID[(Custom Id)]
:CUSTOM_ID: test-02
:END:

commit: [[https://github.com/gcclll/stb-vue-next/commit/b2143f9e35af77ee43792a6110ea70c4caf9a54f?branch=b2143f9e35af77ee43792a6110ea70c4caf9a54f&diff=split][feat: observe object recursively Â· gcclll/stb-vue-next@b2143f9]]

* å®Œæ•´è„‘å›¾
:PROPERTIES:
:COLUMNS: %CUSTOM_ID[(Custom Id)]
:CUSTOM_ID: whole-mind-map
:END:

[[/img/vue3/reactivity/reactivity.svg]]
