ATE: <2020-11-09 11:45:36>
#+TAGS[]: vue, vue3, compiler-core, parser, compiler
#+CATEGORIES[]: vue
#+LANGUAGE: zh-cn
#+STARTUP: indent shrink

#+begin_export html
<link href="https://fonts.goo~gleapis.com/cs~s2?family=ZCOOL+XiaoWei&display=swap" rel="stylesheet">
<kbd>
<font color="blue" size="3" style="font-family: 'ZCOOL XiaoWei', serif;">
  è¯—å·ï¼šå…­é“åŒå ï¼Œé­”åŠ«ä¸‡åƒï¼Œå¼•æ¸¡å¦‚æ¥ã€‚
</font>
</kbd><br><br>
<script src="/js/vue/reactivity.global.js"></script>
<script>
function _log(el, content) {
  $(el).children('.result').append('<p>' + content + '</p>')
}
</script>
#+end_export

[[/img/bdx/yiyeshu-001.jpg]]

@@html:<kbd>@@
*[[https://github.com/gcclll/stb-vue-next][stb-vue-next]] å®Œå…¨æ‹·è´äº [[https://github.com/vuejs/vue-next][vue-next]] ï¼Œä¸»è¦ç›®çš„å­¦ä¹ åŠå°è¯•åº”ç”¨äºæœºé¡¶ç›’ç¯å¢ƒã€‚*
@@html:</kbd>@@

@@html:<kbd>@@ *æœ¬æ–‡ä¾æ® commit è¿›ç¨‹è¿›è¡Œè®°å½•* @@html:</kbd>@@

* init project
:PROPERTIES:
:COLUMNS: %CUSTOM_ID[(Custom Id)]
:CUSTOM_ID: init
:END:

åˆå§‹åŒ–é¡¹ç›®ï¼š[[https://github.com/gcclll/stb-vue-next/commit/cb3470d7c3f2944fd23e9155fc8a6afb7a51a732][feat: reactive-fn Â· gcclll/stb-vue-next@cb3470d]]

[[#while-mind-map][ç”±äºå®Œæ•´è„‘å›¾ä¼šæ¯”è¾ƒå…¨è€Œå¤§æ‰€ä»¥æ”¾åˆ°æ–‡å­—æœ€åå»ã€‚ã€‚ã€‚]]

[[/img/vue3/reactivity/reactivity.svg][ä¹Ÿå¯ä»¥ç‚¹å‡»è¯¥é“¾æ¥ç›´æ¥æ–°çª—å£æ‰“å¼€ï¼Œæ•ˆæœæ›´ä½³ã€‚]]
* [[https://github.com/gcclll/stb-vue-next/commit/cb3470d7c3f2944fd23e9155fc8a6afb7a51a732][4a6ac0e]] add: createReactiveObject
:PROPERTIES:
:COLUMNS: %CUSTOM_ID[(Custom Id)]
:CUSTOM_ID: fn cro
:END:

[[https://github.com/gcclll/stb-vue-next/commit/cb3470d7c3f2944fd23e9155fc8a6afb7a51a732][feat: reactive-fn Â· gcclll/stb-vue-next@cb3470d]]

[[/img/vue3/reactivity/reactivity-reactive.svg]]

ä»…å¢åŠ å‡½æ•°å£°æ˜:

#+begin_src typescript
export function reactive(target: object) {
  // å¦‚æœè¯•å›¾ observe ä¸€ä¸ªåªè¯» proxyï¼Œè¿”å›åªè¯»ç‰ˆæœ¬
  if (target && (target as Target)[ReactiveFlags.IS_READONLY]) {
    return target
  }

  return createReactiveObject(
    target,
    false,
    mutableHandlers,
    {}
    // mutableCollectionHandlers
  )
}

function createReactiveObject(
  target: Target,
  isReadonly: boolean,
  baseHandlers: ProxyHandler<any>,
  collectionHandlers: ProxyHandler<any>
) {}
#+end_src

*mutableHandlers*: æ™®é€šå¯¹è±¡ç±»å‹çš„ proxy handlers

*mutableCollectionHandlers*: é›†åˆç±»å‹çš„ proxy handlersï¼Œå› ä¸º ~Reflect~ å¹¶æ²¡æœ‰å¯¹é›†
åˆç±»å‹åšåº•å±‚æ˜ å°„ï¼Œæ‰€ä»¥éœ€è¦ç‰¹æ®Šå¤„ç†ã€‚

* [[https://github.com/gcclll/stb-vue-next/commit/443a0b5920efaf714de08b0975c17f1d652815e4][c0f0b7c]] feat: reactive(target)

[[https://github.com/gcclll/stb-vue-next/commit/443a0b5920efaf714de08b0975c17f1d652815e4][feat: createReactiveObject Â· gcclll/stb-vue-next@443a0b5]]

[[/img/vue3/reactivity/reactivity-create-reactive-object.svg]]

1. é‡ç‚¹ï¼š ~new Proxy(target, collection)~
2. è¢«ä»£ç†ç±»å‹å¿…é¡»æ˜¯å¯¹è±¡(å¼•ç”¨ç±»å‹)
3. target æœ¬èº«å·²ç»æ˜¯ proxy äº†
4. target ä»£ç†æœ‰ç¼“å­˜ä¸ç”¨é‡å¤åˆ›å»º
5. å¿…é¡»æ˜¯åˆæ³•çš„ç±»å‹(~Object|Array|[Weak]Map|[Weak]Set~)æ‰èƒ½è¢«ä»£ç†
6. è®°å¾—ç¼“å­˜æ–°åˆ›å»ºçš„ä»£ç†å…³ç³»(~proxyMap~ å…¨å±€å˜é‡)

*** ç”¨ä¾‹ä¸€ï¼šæ™®é€šå¯¹è±¡

#+begin_src js
const { effect, reactive, targetMap, isReactive } = require(process.env.PWD + '/../../static/js/vue/reactivity.global.js')

const original = { foo: 1 }
const observed = reactive(original)

console.log('observed is not orignial,' + original !== observed)
console.log('observed is reactive, ' + isReactive(observed))
console.log('original is reactive, ' + isReactive(original))
console.log('observed.foo === 1, ' + observed.foo === 1)
console.log('`foo` in observed, ' + (`foo` in observed))
console.log(`Object.keys(observed) == ['foo'], ` + (Object.keys(observed).toString() === 'foo'))
#+end_src

+RESULTS:
: true
: observed is reactive, true
: original is reactive, false
: false
: `foo` in observed, true
: Object.keys(observed) == ['foo'], true
: undefined

[[https://github.com/gcclll/stb-vue-next/commit/1005ef30d5367fe306a4cfeb7e00c1cd56b1c691][b2143f9]] FIX: ~isReactive(observed): false~

[[https://github.com/gcclll/stb-vue-next/commit/1005ef30d5367fe306a4cfeb7e00c1cd56b1c691][fix: get object's __v_isReactive prop Â· gcclll/stb-vue-next@1005ef3]]

åœ¨ ~createGetter~ ä¸­å¢åŠ åˆ¤æ–­ï¼Œå¦‚æœæ¥å–çš„å±æ€§ä¸º ~__v_isReactive~ åˆ™ç›´æ¥è¿”å›
~!isReadonly~ ã€‚
*** ç”¨ä¾‹äºŒï¼šåŸå‹

#+begin_src js
const { isReactive, effect, reactive, targetMap } = require(process.env.PWD + '/../../static/js/vue/reactivity.global.js')
const obj = {}
const reactiveObj = reactive(obj)
console.log('reactiveObj is reactive, ' + isReactive(reactiveObj))
const prototype = reactiveObj['__proto__']
const otherObj = { data: ['a'] }
console.log('otherObj is reactive, ' + isReactive(otherObj))
const reactiveOther = reactive(otherObj)
console.log('reactiveOther is reactive, ' + isReactive(reactiveOther))
console.log('reactiveOther.data[0] is `a`, ' + ( reactiveOther.data[0] === 'a' ))
console.log(`__proto__, ` + prototype)
#+end_src

+RESULTS:
: reactiveObj is reactive, true
: otherObj is reactive, false
: reactiveOther is reactive, true
: reactiveOther.data[0] is `a`, true
: __proto__, [object Object]
: undefined

FIX: [[https://github.com/gcclll/stb-vue-next/commit/1e2a3fef77b4a2b5f4dc3c497296b30b4ff06883][1005ef3]] å½“å–å€¼æ—¶å±æ€§åä¸º ~__proto__~ æ—¶ï¼šç›´æ¥è¿”å›å–å€¼ç»“æœã€‚

[[https://github.com/gcclll/stb-vue-next/commit/1e2a3fef77b4a2b5f4dc3c497296b30b4ff06883][feat: get key is symbol or __proto__ or __v_isRef Â· gcclll/stb-vue-next@1e2a3fe]]
*** ç”¨ä¾‹ä¸‰ï¼šåµŒå¥—å¯¹è±¡

#+begin_src js
const {isReactive, effect, reactive, targetMap } = require(process.env.PWD + '/../../static/js/vue/reactivity.global.js')
const original = {
  nested: {
    foo: 1
  },
  array: [{ bar: 2 }]
}

const observed = reactive(original)
console.log(`observed.nested is reactive ${isReactive(observed.nested)}`)
console.log(`observed.array is reactive ${isReactive(observed.array)}`)
console.log(`observed.array[0] is reactive ${isReactive(observed.array[0])}`)
#+end_src

+RESULTS:
: observed.nested is reactive true
: observed.array is reactive true
: observed.array[0] is reactive true

*** ç”¨ä¾‹å››ï¼šä»£ç†åçš„å¯¹è±¡æ“ä½œä¹Ÿä¼šä½“ç°åœ¨åŸå¯¹è±¡ä¸Š

#+begin_src js
const { isReactive, effect, reactive, targetMap } =
      require(process.env.PWD + '/../../static/js/vue/reactivity.global.js')

const or = { foo: 1 }
const ob = reactive(or)
ob.bar = 1
console.log(`ob.bar = ${ob.bar}, or.bar = ${or.bar}`)
delete ob.foo
console.log(`'foo' in ob: ${'foo' in ob}, 'foo' in or: ${'foo' in or}`)
#+end_src

+RESULTS:
: ob.bar = 1, or.bar = 1
: 'foo' in ob: false, 'foo' in or: false

ç»“æœåˆ é™¤åï¼Œä¾æ—§åœ¨ï¼Œéœ€è¦å®ç° delete proxy handlerã€‚
*** ç”¨ä¾‹äº”ï¼šåŸå§‹å¯¹è±¡ä¸Šçš„æ“ä½œä¹Ÿè¦èƒ½åœ¨ä»£ç†åå¯¹è±¡æœ‰æ‰€ä½“ç°

#+begin_src js
const { isReactive, effect, reactive, targetMap } = require(process.env.PWD + '/../../static/js/vue/reactivity.global.js')

const original = { foo: 1 }
const observed = reactive(original)

original.bar = 1
console.log(`observed.bar = ${observed.bar}, original.bar = ${original.bar}`)
delete original.foo
console.log(`'foo' in original: ${'foo' in original}, 'foo' in observed: ${'foo' in observed}`)
#+end_src

+RESULTS:
: observed.bar = 1, original.bar = 1
: 'foo' in original: false, 'foo' in observed: false

*** ç”¨ä¾‹å…­ï¼šè¢«è®¾ç½®çš„å€¼å¦‚æœæ˜¯å¯¹è±¡ï¼Œè¯¥å¯¹è±¡ä¹Ÿä¼šè¢« Reactive

#+begin_src js
const { isReactive, effect, reactive, targetMap } = require(process.env.PWD + '/../../static/js/vue/reactivity.global.js')

const observed = reactive({})
const raw = {}
observed.foo = raw // #0
console.log(`observed.foo === faw, ${observed.foo === raw}`) // #1
console.log(`observed.foo is reactive, ${isReactive(observed.foo)}`)
#+end_src

+RESULTS:
: observed.foo === faw, false
: observed.foo is reactive, true

è®¿é—® raw ä¹‹å‰(*#1* ä¹‹å‰)å®ƒè¿˜ä¸æ˜¯ reactiveï¼Œå› ä¸ºé€’å½’ reactive å‘ç”Ÿåœ¨ track() ä¸­ï¼Œå³å–å€¼é˜¶æ®µã€‚

å¦‚ï¼šæ§åˆ¶å°æµ‹è¯•è¾“å‡º
#+begin_example
var ob = reactive({})
var raw = {}
ob.foo = raw
ob
    Proxy {foo: {â€¦}}
        [[Handler]]: Object
            deleteProperty: Æ’ deleteProperty(target, key)
            get: Æ’ (target, key, receiver)
            set: Æ’ (target, key, value, receiver)
        [[Target]]: Object
            foo: {} // æ³¨æ„è¿™é‡Œ
        [[IsRevoked]]: false
#+end_example

è¿›è¡Œä¸€æ¬¡å–å€¼ï¼š
#+begin_example
ob.foo
    ProxyÂ {}
        [[Handler]]: Object
        [[Target]]: Object
        [[IsRevoked]]: false
#+end_example
*** ç”¨ä¾‹ä¸ƒï¼šä¸è¯¥é‡å¤ proxyï¼Œè¿”å›ç¬¬ä¸€ä¸ª proxy ç»“æœ

#+begin_src js
const { isReactive, effect, reactive, targetMap } = require(process.env.PWD + '/../../static/js/vue/reactivity.global.js')

const original = { foo: 1 } // #1
const observed1 = reactive(original) // #2
const observed2 = reactive(observed1) // #3
console.log(`observed2 === observed1, ${observed2 === observed1}`)
#+end_src

#+RESULTS:
: observed2 === observed1, true
: undefined

å› ä¸º ~reactive()~ å®ç°ä¸­ç»„äº†æ£€æµ‹ï¼Œå¦‚æœè‡ªèº«æ˜¯ä¸ª proxy å°±ç›´æ¥è¿”å›ï¼Œæ‰€ä»¥ *#3* ä¸­å®
é™…ç›´æ¥å°† ~observed1~ è¿”å›äº†ã€‚
*** TODO ç”¨ä¾‹å…«ï¼šä¸åº”è¯¥ç”¨ proxies æ±¡æŸ“åŸå§‹å¯¹è±¡ï¼Ÿ

#+begin_src js
const { isReactive, effect, reactive, targetMap } = require(process.env.PWD + '/../../static/js/vue/reactivity.global.js')

const original = { foo: 1 }
const original2 = { bar: 2 }
const observed = reactive(original)
const observed2 = reactive(original2)
observed.bar = observed2
console.log(`observed.bar === observed2, ${observed.bar === observed2}`)
console.log(`original.bar === original2, ${original.bar === original2}`)
#+end_src

+RESULTS:
: observed.bar === observed2, true
: original.bar === original2, false
* [[https://github.com/gcclll/stb-vue-next/commit/598e047407fe52183468037beb45328878431a55][443a0b5]] basic proxy get handler(createGetter)

[[https://github.com/gcclll/stb-vue-next/commit/598e047407fe52183468037beb45328878431a55][feat: reactive proxy get handler Â· gcclll/stb-vue-next@598e047]]

commit: åªå®ç°å¯¹è±¡çš„ ~get proxy handler~ ï¼Œå¯¹è±¡å±æ€§è¢«è®¿é—®çš„æ—¶å€™ä¼šè§¦å‘ä»£ç†ï¼Œæ¯”å¦‚ä¸‹é¢
å®ä¾‹ä¸­ï¼Œå½“è®¿é—® ~observed.count~ æ—¶å€™ä¼šè§¦å‘ ~console.log({ res }, "get")~ æ‰§è¡Œã€‚

æœ€ç®€å• proxy get handler è„‘å›¾ï¼š
[[/img/vue3/reactivity/reactivity-basehd-get-01.svg]]

1. è°ƒç”¨ ~Reflect.get(target, key, receiver)~ æ‰§è¡ŒåŸå­æ“ä½œ
2. è¿”å›æ‰§è¡Œç»“æœ


#+begin_src typescript
function createGetter(isReadonly = false, shallow = false) {
  // target: è¢«å–å€¼çš„å¯¹è±¡ï¼Œkey: å–å€¼çš„å±æ€§ï¼Œreceiver: this çš„å€¼
  return function get(target: Target, key: string | symbol, receiver: object) {
    const res = Reflect.get(target, key, receiver)

    // æ˜¯å¦åªéœ€è¦ reactive ä¸€çº§å±æ€§(ä¸é€’å½’ reactive)
    if (shallow) {
      return res
    }

    return res
  }
}
export const mutableHandlers: ProxyHandler<object> = {
  get
}
#+end_src

æµ‹è¯•ï¼š
#+begin_src js
const { effect, reactive, targetMap } = require(process.env.PWD + '/../../static/js/vue/reactivity.global.js')

const target = { count: 0 }
const ob = reactive(target)
effect(() => ob.count) // ob.count å±æ€§ æ”¶é›† effect fn

console.log(targetMap.get(target))
#+end_src

+RESULTS: effect ä¼šç«‹å³æ‰§è¡Œ fnï¼Œ ~ob.count~ å–å€¼è§¦å‘ get proxy æ”¶é›† fn -> count => deps<Set>
#+begin_example
Map(1) {
  'count' => Set(1) {
    [Function: reactiveEffect] {
      id: 0,
      allowRecurse: false,
      _isEffect: true,
      active: true,
      raw: [Function (anonymous)],
      deps: [Array],
      options: {}
    }
  }
}
#+end_example
* [[https://github.com/gcclll/stb-vue-next/commit/3fc963486868ca3583b02852f07a5aa5969ac354][6c50273]] add track() and effect()

[[https://github.com/gcclll/stb-vue-next/commit/3fc963486868ca3583b02852f07a5aa5969ac354][feat: track+effect Â· gcclll/stb-vue-next@3fc9634]]

ä¸ºäº†å®Œæˆè§‚å¯Ÿå±æ€§ï¼Œé€šè¿‡å±æ€§çš„å–å€¼æ“ä½œæ¥æ”¶é›†ä¾èµ–è¿‡ç¨‹ï¼Œè¿™é‡ŒåŒæ—¶å®ç°äº† ~track()~ å’Œ
~effect()~ å‡½æ•°ã€‚

** track(target, type, key) ç›‘å¬å–å€¼æ”¶é›†ä¾èµ–ï¼š

   [[/img/vue3/reactivity/reactivity-basehd-get-02-track.svg]]

** effect(fn, options)

[[/img/vue3/reactivity/reactivity-effect.svg]]

- *å‚æ•°åˆ—è¡¨* ï¼š

    fn - è¢«å°è£…çš„å‡½æ•°ï¼Œé‡Œé¢å¯å¯¹å¯¹è±¡æ‰§è¡Œ get/set æ“ä½œã€‚

- *ä¸»è¦åŠŸèƒ½* ï¼šå°† fn å°è£…æˆ ~ReactiveEffect~ å‡½æ•°

    #+begin_src typescript
    export interface ReactiveEffect<T = any> {
        (): T // effectå‡½æ•°ä¸»é¢˜
        _isEffect: true // æ ‡è®°è‡ªèº«æ˜¯ä¸æ˜¯ä¸€ä¸ª ReactiveEffect ç±»å‹
        id: number // uid++ è€Œæ¥ï¼Œå…¨å±€çš„ä¸€ä¸ªç›¸å¯¹å”¯ä¸€çš„ id
        active: boolean // è®°å½•å½“å‰çš„ effect æ˜¯ä¸æ˜¯æ¿€æ´»çŠ¶æ€
        raw: () => T // å°è£…ä¹‹å‰çš„é‚£ä¸ª fn
        deps: Array<Dep> // fn çš„è¢«ä¾èµ–è€…åˆ—è¡¨
        options: ReactiveEffectOptions // é¢å¤–é€‰é¡¹ï¼Œå¦‚ï¼šlazy
        allowRecurse: boolean // ???
    }
    #+end_src

- *è§£å†³é—®é¢˜* :

    1. fn å°è£…ä¹‹åï¼Œæ‰§è¡Œ fn è¿‡ç¨‹ä¸­ä½¿ç”¨ try...finally ï¼Œé˜²æ­¢ fn æ‰§è¡Œå¼‚å¸¸å¯¼è‡´
       effect è¿›ç¨‹ä¸­æ–­
    2. ç»“åˆ shouldTrack, activeEffect å’Œ track() å‡½æ•°ï¼Œæœ‰æ•ˆçš„é¿å…äº†åœ¨ fn ä¸­æ‰§è¡Œ
       obj.value++ å¯¼è‡´ effect æ­»å¾ªç¯é—®é¢˜ï¼Œå› ä¸º try...finally ç¡®ä¿äº†åªæœ‰ fn å‡½æ•°
       å®Œæˆä¹‹åæ‰ä¼šè¿›å…¥ finally æ¢å¤ effect çŠ¶æ€(~shouldTrack = true,
       activeEffect = last || null~)ã€‚


ç›¸å…³å‡½æ•°åŠå˜é‡åˆ—è¡¨
| name                                | type             | desc                                                                              |
|-------------------------------------+------------------+-----------------------------------------------------------------------------------|
| ~activeEffect~                      | /ReactiveEffect/ | å½“å‰æ­£åœ¨å¤„ç†çš„ Effectï¼Œfn è¿˜æœªæ‰§è¡Œå®Œæˆï¼Œfinally è¿˜æ²¡ç»“æŸ                          |
| ~effectStack~                       | /Array, []/      | ç¼“å­˜æ‰€æœ‰çŠ¶æ€è¿˜æ²¡å®Œæˆçš„ Effect                                                     |
| ~shouldTrack~                       | /boolean, true/  | track() ä¸­ç”¨æ¥æ£€æµ‹å½“å‰ effect æ˜¯å¦ç»“æŸï¼Œä»è€Œåˆ¤å®šæ˜¯å¦å¯ä»¥ç»§ç»­æ‰§è¡Œ track() æ”¶é›†ä¾èµ– |
| ~trackStack~                        | /Array, []/      | ä¿å­˜ç€æ‰€æœ‰ Effect çš„ shouldTrack å€¼                                               |
| ~effect()~                          | /function/       | å°è£… fnæˆ ReactiveEffect ç»“æ„                                                     |
| ~track(target, type, key)~          | /function/       | æ”¶é›†ä¾èµ–ï¼Œå¹¶ä¸”å“åº”å¼é€’å½’                                                          |
| ~trigger(...)~                      | /function/       | å½“å€¼æ›´æ–°æ—¶è§¦å‘æ‰€æœ‰ä¾èµ–æ›´æ–°                                                        |
| ~createReactiveEffect(fn, options)~ | /function/       | effect() å‡½æ•°ä¸»é¢˜åŠŸèƒ½åˆ†ç¦»å‡ºæ¥                                                     |
| ~cleanup(effect: ReactiveEffect)~   | /function/       | æ¸…ç©ºæ‰€æœ‰ fn çš„ä¾èµ– effect.deps[]                                                  |
| ~enableTracking()~                  | /function/       | ä½¿èƒ½ Effect ï¼ŒshouldTrack = true, å¹¶å°†å…¶åŠ å…¥ trackStack                           |
| ~resetTracking()~                   | /function/       | é‡ç½® Effect, shouldTrack = ä¸Šä¸€ä¸ª Effect çš„ shouldTrack å€¼æˆ– true                 |

#+begin_src typescript
export function effect<T = any>(
  fn: () => T,
  options: ReactiveEffectOptions = EMPTY_OBJ
): ReactiveEffect<T> {
  if (isEffect(fn)) {
    fn = fn.raw // å–å‡ºåŸå§‹çš„å‡½æ•°ï¼Œå°è£…ä¹‹å‰çš„
  }

  // å°è£…æˆ ReactiveEffect
  const effect = createReactiveEffect(fn, options)

  if (!options.lazy) {
    // å¦‚æœå¹¶æ²¡æŒ‡å®š lazy: true é€‰é¡¹ï¼Œåˆ™ç«‹å³æ‰§è¡Œ effect æ”¶é›†ä¾èµ–
    // å› ä¸º effect ä¸€èˆ¬éƒ½ä¼šæœ‰å–å€¼æ“ä½œï¼Œæ­¤æ—¶ä¼šè§¦å‘ proxy get handler
    // ç„¶åæ‰§è¡Œ track() ç»“åˆå½“å‰çš„ activeEffect å³ effect() æ‰§è¡Œæ—¶å€™çš„è¿™ä¸ª
    // effectï¼Œè¿™æ ·å–å€¼æ“ä½œå°±å’Œå½“å‰å–å€¼ä½œç”¨åŸŸä¸‹çš„ä¾èµ–å‡½æ•°å»ºç«‹çš„ä¾èµ–å…³ç³»
    effect()
  }
  return effect
}

let uid = 0

function createReactiveEffect<T = any>(
  fn: () => T,
  options: ReactiveEffectOptions
): ReactiveEffect<T> {
  // å°† fn æ‰§è¡Œå°è£…æˆ  ReactiveEffect ç±»å‹çš„å‡½æ•°
  const effect = function reactiveEffect(): unknown {
    if (!effect.active) {
      // éæ¿€æ´»çŠ¶æ€ï¼Œå¯èƒ½æ˜¯æ‰‹åŠ¨è°ƒç”¨äº† stop
      // é‚£ä¹ˆæ‰§è¡Œçš„æ—¶å€™å°±éœ€è¦è€ƒè™‘è°ƒç”¨ stop è€…æ˜¯å¦æä¾›äº†æ‰‹åŠ¨è°ƒåº¦è¯¥ effect
      // çš„å‡½æ•° scheduler ? ä¹Ÿå°±æ˜¯è¯´ä½ åœæ­¢ä½ å¯ä»¥é‡æ–°å¯åŠ¨
      return options.scheduler ? undefined : fn()
    }

    if (!effectStack.includes(effect)) {
      // 1. cleanup, ä¿æŒçº¯å‡€
      cleanup(effect)
      try {
        // 2. ä½¿å…¶ tracking çŠ¶æ€æœ‰æ•ˆï¼Œtrack() ä¸­æœ‰ç”¨
        enableTracking() // track() å¯ä»¥æ‰§è¡Œæ”¶é›†æ“ä½œ
        effectStack.push(effect) // effect å…¥æ ˆ
        // 3. ä¿å­˜ä¸ºå½“å‰çš„ activeEffect, track() ä¸­æœ‰ç”¨
        activeEffect = effect // è®°å½•å½“å‰çš„ effect -> track/trigger
        // 4. æ‰§è¡Œ fn å¹¶è¿”å›ç»“æœ
        return fn() // è¿”å›æ‰§è¡Œç»“æœ
      } finally {
        // å§‹ç»ˆéƒ½ä¼šæ‰§è¡Œï¼Œé¿å…å‡ºç°å¼‚å¸¸å°† effect è¿›ç¨‹å¡æ­»
        // 5. å¦‚æœæ‰§è¡Œå¼‚å¸¸ï¼Œä¸¢å¼ƒå½“å‰çš„ effect ï¼Œå¹¶å°†çŠ¶æ€é‡ç½®ä¸ºä¸Šä¸€ä¸ª effect
        //   ç”±ä¸€ä¸ª effect æ ˆæ¥ç»´æŠ¤ã€‚

        effectStack.pop()
        resetTracking()
        activeEffect = effectStack[effectStack.length - 1]
      }
    }
  } as ReactiveEffect

  effect.id = uid++
  effect.allowRecurse = !!options.allowRecurse
  effect._isEffect = true
  effect.active = true
  effect.raw = fn // è¿™é‡Œä¿å­˜åŸå§‹å‡½æ•°å¼•ç”¨
  effect.deps = []
  effect.options = options

  return effect
}

#+end_src

ä¾èµ–å’Œå±æ€§å˜æ›´å‘ç”Ÿè”ç³»çš„æ¡¥æ¢æ¨¡å—ã€‚

1. ~effect(fn, options)~ å°è£…æ‰§è¡Œ fnï¼Œè§¦å‘å–å€¼æ“ä½œ ->
2. ~track(target, type, key)~ æ”¶é›†å¯¹è±¡åŠå±æ€§æ‰€æœ‰ä¾èµ– ->
3. fn ä¸­è®¾å€¼æ“ä½œè§¦å‘ ~trigger(...)~ æ‰§è¡Œæ‰€æœ‰ depsï¼Œæ›´æ–° DOMã€‚
* [[https://github.com/gcclll/stb-vue-next/commit/20afde9970282c144b978b005767bd2c710d54ab][736de7c]] add trigger() proxy set handler

[[https://github.com/gcclll/stb-vue-next/commit/20afde9970282c144b978b005767bd2c710d54ab][feat: proxy set and trigger operation Â· gcclll/stb-vue-next@20afde9]]

** proxy set handler(createSetter)

#+begin_src typescript

function createSetter(shallow = false) {
  return function set(
    target: object,
    key: string | symbol,
    value: unknown,
    receiver: object
  ): boolean {
    const oldValue = (target as any)[key]
    // TODO shallow or not, or ref ?
    //

    const hadKey =
      isArray(target) && isIntegerKey(key)
        ? Number(key) < target.length
        : hasOwn(target, key)

    const result = Reflect.set(target, key, value, receiver)

    if (target === toRaw(receiver)) {
      if (!hadKey) {
        // TODO ADD
      } else if (hasChanged(value, oldValue)) {
        trigger(target, TriggerOpTypes.SET, key, value, oldValue)
      }
    }

    return result
}
#+end_src

** trigger()

#+begin_src typescript
export function trigger(
  target: object,
  type: TriggerOpTypes,
  key?: unknown,
  newValue?: unknown,
  oldValue?: unknown,
  oldTarget?: Map<unknown, unknown> | Set<unknown>
) {
  const depsMap = targetMap.get(target)
  if (!depsMap) {
    return
  }

  const effects = new Set<ReactiveEffect>()
  const add = (effectsToAdd: Set<ReactiveEffect> | undefined) => {
    if (effectsToAdd) {
      effectsToAdd.forEach(effect => {
        if (effect !== activeEffect || effect.allowRecurse) {
          effects.add(effect)
        }
      })
    }
  }

  if (type === TriggerOpTypes.CLEAR) {
    // TODO collection clear operation
  } else if (key === 'length' && isArray(target)) {
    // TODO array change operation
  } else {
    // SET | ADD | DELETE operation
    if (key !== void 0) {
      add(depsMap.get(key))
    }

    // TODO è¿­ä»£å™¨ keyï¼Œfor...of, ä½¿ç”¨è¿­ä»£å™¨æ˜¯å¯¹æ•°æ®çš„ç›‘å¬å˜åŒ–
  }

  const run = (effect: ReactiveEffect) => {
    if (__DEV__ && effect.options.onTrigger) {
      effect.options.onTrigger({
        effect,
        target,
        key,
        type,
        newValue,
        oldValue,
        oldTarget
      })
    }

    if (effect.options.scheduler) {
      effect.options.scheduler(effect)
    } else {
      effect()
    }
  }

  effects.forEach(run)
}
#+end_src
* [[https://github.com/gcclll/stb-vue-next/commit/b2143f9e35af77ee43792a6110ea70c4caf9a54f][b5f97b4]] observe object recursively

[[https://github.com/gcclll/stb-vue-next/commit/b2143f9e35af77ee43792a6110ea70c4caf9a54f][feat: observe object recursively Â· gcclll/stb-vue-next@b2143f9]]

é’ˆå¯¹åµŒå¥—å¯¹è±¡è¿›è¡Œé€’å½’ Reactive ã€‚

[[/img/vue3/reactivity/reactivity-basehd-get-03-track-recursively.svg]]
* effect -> track -> trigger å…³ç³»å›¾
:PROPERTIES:
:COLUMNS: %CUSTOM_ID[(Custom Id)]
:CUSTOM_ID: effect-track-trigger
:END:

åˆ°æ­¤ effect + track + trigger å®Œæˆäº†æœ€ç®€å•çš„å“åº”å¼ä»£ç ã€‚

[[/img/vue3/reactivity/reactivity-effect-track-trigger.svg]]

1. effect å°è£…æ³¨å†Œå‡½æ•°
2. track å–å€¼è§¦å‘æ”¶é›†ä¾èµ–å‡½æ•°
3. trigger è®¾å€¼è§¦å‘æ‰€æœ‰ä¾èµ–å‡½æ•°æ‰§è¡Œ
* [[https://github.com/gcclll/stb-vue-next/commit/05b98c571560d2c1806d29cdda7b500b4b2bdeac][05b98c5]] add delete(*deleteProperty*) proxy handler
:PROPERTIES:
:COLUMNS: %CUSTOM_ID[(Custom Id)]
:CUSTOM_ID: c-delete
:END:

[[https://github.com/gcclll/stb-vue-next/commit/05b98c571560d2c1806d29cdda7b500b4b2bdeac][feat: delete proxy handler Â· gcclll/stb-vue-next@05b98c5]]

#+begin_src typescript
function deleteProperty(target: object, key: string | symbol): boolean {
  const hadKey = hasOwn(target, key)
  const oldValue = (target as any)[key]
  const result = Reflect.deleteProperty(target, key)
  if (result && hadKey) {
    // åˆ é™¤æˆåŠŸï¼Œè§¦å‘ DELETE
    trigger(target, TriggerOpTypes.DELETE, key, undefined, oldValue)
  }
  return result
}

export const mutableHandlers: ProxyHandler<object> = {
  get,	  get,
  set	  set,
  deleteProperty
}
#+end_src

åˆ é™¤æˆåŠŸè°ƒç”¨ ~trigger()~ è§¦å‘ *DELETE* ã€‚
* [[https://github.com/gcclll/stb-vue-next/commit/ab69fe9eecb274f836bf19163636bd8f464b84d1][05b98c5]] add has, ownKeys proxy handlers

[[https://github.com/gcclll/stb-vue-next/commit/ab69fe9eecb274f836bf19163636bd8f464b84d1][feat: has + ownKeys proxy handler Â· gcclll/stb-vue-next@ab69fe9]]

å¢åŠ  has, ownKeys proxy handlers.

#+begin_src typescript
function has(target: object, key: string | symbol): boolean {
  const result = Reflect.has(target, key)
  if (!isSymbol(key) || !builtInSymbols.has(key)) {
    track(target, TrackOpTypes.HAS, key)
  }
  return result
}

function ownKeys(target: object): (string | num | symbol)[] {
  track(target, TrackOpTypes.ITERATE, isArray(target) ? 'length' : ITERATE_KEY)
  return Reflect.ownKeys(target)
}
#+end_src

æµ‹è¯•ï¼š

#+begin_src js
const { isReactive, effect, reactive, targetMap } = require(process.env.PWD + '/../../static/js/vue/reactivity.global.js')

const obj = reactive({ n: 0 })
let dummy = false
const runner = effect(() => (dummy = 'n' in obj), { lazy: true })

console.log(`before run effect, dummy = ${dummy}`)
runner()
console.log(`after run effect, dummy = ${dummy}`)
#+end_src

+RESULTS:
: before run effect, dummy = false
: after run effect, dummy = true
* TODO [[https://github.com/gcclll/stb-vue-next/commit/9aeb678befc3826b2ce8976b62c1172b4800df27][9aeb678]] add array support

[[https://github.com/gcclll/stb-vue-next/commit/9aeb678befc3826b2ce8976b62c1172b4800df27][feat: array support Â· gcclll/stb-vue-next@9aeb678]]

ä¿®æ”¹ç‚¹ï¼š
#+begin_src typescript
// æ•°ç»„å†…ç½®æ–¹æ³•å¤„ç†
const arrayInstrumentations: Record<string, Function> = {}
;(['includes', 'indexOf', 'lastIndexOf'] as const).forEach(key => {
  const method = Array.prototype[key] as any
  arrayInstrumentations[key] = function(this: unknown[], ...args: unknown[]) {
    const arr = toRaw(this)
    for (let i = 0, l = this.length; i < l; i++) {
      track(arr, TrackOpTypes.GET, i + '')
    }

    const res = method.apply(arr, args)
    if (res === -1 || res === false) {
      return method.apply(arr, args.map(toRaw))
    } else {
      return res
    }
  }
})
;(['push', 'pop', 'shift', 'unshift', 'splice'] as const).forEach(key => {
  const method = Array.prototype[key] as any
  arrayInstrumentations[key] = function(this: unknown[], ...args: unknown[]) {
    pauseTracking()
    const res = method.apply(this, args)
    resetTracking()
    return res
  }
})

// createGetter
function createGetter(isReadonly = false, shallow = false) {
  // ...
  // 4. target is array
  const targetIsArray = isArray(target)
  if (targetIsArray && hasOwn(arrayInstrumentations, key)) {
    return Reflect.get(arrayInstrumentations, key, receiver)
  }
  // ...
}
#+end_src

1. ç´¢å¼•æ“ä½œ(~includes, lastIndexOf, indexOf~)å¤„ç†

   ç¡®ä¿ç´¢å¼•å–å€¼çš„æ—¶å€™ï¼Œèƒ½ä½¿ç”¨ track() æ­£ç¡®æ”¶é›†å¯¹åº”ç´¢å¼•çš„ä¾èµ–åˆ—è¡¨ã€‚

2. å¯æ”¹å˜åŸæ•°ç»„é•¿åº¦æ“ä½œ(~push, pop, shift, unshift, splice~)

   å› ä¸ºè¿™äº›å‡½æ•°å†…éƒ¨å®ç°éƒ½éœ€è¦è®¿é—®åŠæ”¹å˜åŸæ•°ç»„çš„é•¿åº¦ï¼Œå› æ­¤è¿™é‡Œéœ€è¦åšä¸€å±‚ä¿æŠ¤ï¼Œå®ƒ
   ä»¬æ‰§è¡Œä¹‹å‰ ~shouldTrack = false~ ï¼Œæ‰§è¡Œå®Œæˆä¹‹å ~shouldTrack = true~ ï¼Œé¿å…
   ~track()~ æ­»å¾ªç¯ã€‚


ä¸‹é¢å‡ä¸º vue-next æºç ä¸­ç”¨ä¾‹åˆ†æã€‚
- [X] T1: è¯»å†™æ“ä½œ

    #+begin_src js
    const { isReactive, effect, reactive, targetMap } = require(process.env.PWD + '/../../static/js/vue/reactivity.global.js')

    const original = [{ foo: 1 }, { bar: 2 }]
    const observed = reactive(original)
    console.log(`#01 original !== observed, ${original !== observed}`)
    console.log(`#02 original is reactive, ${isReactive(original)}`)
    console.log(`#03 observed is reactive, ${isReactive(observed)}`)
    console.log(`#04 observed[0] is reactive, ${isReactive(observed[0])}`)

    const clone = observed.slice()
    console.log(`#05 clone[0] is reactive, ${isReactive(clone[0])}`)
    console.log(`#06 clone[0] !== original[0], ${clone[0] !== original[0]}`)
    console.log(`#07 clone[0] === observed[0], ${clone[0] === observed[0]}`)

    const value = { baz: 3 }
    const reactiveValue = reactive(value)
    observed[0] = value
    console.log(`#08 observed[0] === reactiveValue, ${observed[0] === reactiveValue}`)
    console.log(`#09 original[0] === value, ${original[0] === value}`)
    delete observed[0]
    console.log(`#10 observed[0] === undefined, ${observed[0] === undefined}`)
    console.log(`#11 original[0] === undefined, ${original[0] === undefined}`)
    observed.push(value)
    console.log(`#12 observed[2] === reactiveValue, ${observed[2] === reactiveValue}`)
    console.log(`#13 original[2] === value, ${original[2] === value}`)
    #+end_src

    +RESULTS:
    #+begin_example
    #01 original !== observed, true
    #02 original is reactive, false
    #03 observed is reactive, true
    #04 observed[0] is reactive, true
    #05 clone[0] is reactive, true
    #06 clone[0] !== original[0], true
    #07 clone[0] === observed[0], true
    #08 observed[0] === reactiveValue, true
    #09 original[0] === value, true
    #10 observed[0] === undefined, true
    #11 original[0] === undefined, true
    #12 observed[2] === reactiveValue, true
    #13 original[2] === value, true
    #+end_example

    åˆ†æï¼š
  - *#01* å› ä¸º Proxy [[https://tc39.es/ecma262/#sec-proxycreate][å†…éƒ¨å®ç°]]å®é™…ä¼šåˆ›å»ºæ–°å¯¹è±¡
  - *#02* è¯»å– ~__v_isReactive~ åœ¨ ~createGetter()~ é‡Œé¢ä¼šç›´æ¥è¿”å› ~!isReadonly~
  - *#03* åŒä¸Š
  - *#04* å–å€¼çš„æ—¶å€™è¿”å›ç»“æœä¹‹å‰ä¼šæ£€æµ‹å½“å‰æ˜¯ä¸æ˜¯å¯¹è±¡å¦‚æœæ˜¯ä¼šæ‰§è¡Œé€’å½’ reactive
  - *#05* slice [[/post/javascript-apis/#api-array-slice][å®ç°è¿‡ç¨‹]]å¹¶éæ·±æ‹·è´
  - *#06* å’Œ ~observed[0] !== original[0]~ ä¸€ä¸ªåŸå› 
  - *#07* [[/post/javascript-apis/#api-array-slice][æµ…æ‹·è´é—®é¢˜]]
  - *#08* å…ˆ ~observed[0]~ å¯¹ value å–å€¼æ“ä½œï¼Œæ­¤æ—¶ Reactive value å¯¹è±¡æ—¶ï¼Œå‘ç°è¯¥å¯¹
  è±¡å·²ç»æœ‰æ˜ å°„äº†(proxyMap ä¸­å·²å­˜åœ¨ value -> reactiveValue å…³ç³»ã€‚)
  - *#09* proxy çš„æ”¹å˜ä¹Ÿä¼šä½“ç°åœ¨ original å¯¹è±¡ä¸Šã€‚

    #+begin_src js
    const target = {  }
    const ob = new Proxy(target, {})
    ob.value = { test: 1 }
    console.log(target)
    #+end_src

    +RESULTS:
    : { value: { test: 1 } }
  - *#10* åŒä¸Š
  - *#11* åŒä¸Š
  - *#12* åŒ *#08* ~proxyMap~ ä¸­æœ‰ç¼“å­˜äº†
  - *#13* åŒä¸Š
- [X] T2ï¼šç´¢å¼•æ–¹æ³•(includes, lastIndexOf, indexOf)

    #+begin_src js
    const { isReactive, effect, reactive, targetMap } = require(process.env.PWD + '/../../static/js/vue/reactivity.global.js')

    const raw = {}
    const arr = reactive([{}, {}])
    arr.push(raw)
    console.log(`arr.indexOf(raw), ${arr.indexOf(raw)}`)
    console.log(`arr.indexOf(raw, 3), ${arr.indexOf(raw, 3)}`)
    console.log(`arr.includes(raw), ${arr.includes(raw)}`)
    console.log(`arr.includes(raw, 3), ${arr.includes(raw, 3)}`)
    console.log(`arr.lastIndexOf(raw), ${arr.lastIndexOf(raw)}`)
    console.log(`arr.lastIndexOf(raw, 1), ${arr.lastIndexOf(raw, 1)}`)
    #+end_src

    +RESULTS:
    : arr.indexOf(raw), 2
    : arr.indexOf(raw, 3), -1
    : arr.includes(raw), true
    : arr.includes(raw, 3), false
    : arr.lastIndexOf(raw), 2
    : arr.lastIndexOf(raw, 1), -1
- [X] T3ï¼šæ•°ç»„å…ƒç´ æœ¬èº«å·²ç»æ˜¯ Proxy

  #+begin_src js
  const { isReactive, effect, reactive, targetMap } = require(process.env.PWD + '/../../static/js/vue/reactivity.global.js')
  const raw = []
  const obj = reactive({})
  raw.push(obj)
  const arr = reactive(raw)
  console.log(`arr.includes(obj), ${arr.includes(obj)}`)
  #+end_src

  +RESULTS: è¿™ä¸ªåº”è¯¥å¾ˆå¥½ç†è§£ï¼Œå¯¹è±¡å·²ç»æ˜¯ proxy ä¹‹åä¸ä¼šå†ç»§ç»­ä»£ç†ï¼Œè€Œæ˜¯è¿”å›
  proxyMap ä¸­ç¼“å­˜è¿‡çš„ä»£ç†ç»“æœã€‚
  : arr.includes(obj), true
- [-] T4: [[/post/javascript-apis/#api-array-reverse][reverse]] æ–¹æ³•ä¹Ÿåº”è¯¥æ˜¯ reactive çš„

  *TODO*: reverse ä¹‹åæ‰¾ä¸åˆ°(~indexOf~)åŸå§‹å¯¹è±¡äº†ï¼Ÿ

  æ ¹æ® [[/post/javascript-apis/#api-array-reverse][reverse()]] çš„å®ç°åŸç†ï¼Œæœ¬è´¨ä¸Šæ˜¯å…ƒç´ ä¹‹é—´çš„æ›¿æ¢æ“ä½œï¼Œå› æ­¤å¹¶ä¸ä¼šæ”¹å˜æ•°ç»„æˆ–å…ƒ
  ç´ æœ¬èº«æ˜¯ proxy æ€§è´¨ï¼Œä¸”å±äºç´¢å¼•èµ‹å€¼æ“ä½œï¼Œå› æ­¤ä¼šè§¦å‘ç´¢å¼•çš„ reactive ç›¸å…³æ“ä½œã€‚

  #+begin_src js
  const { isReactive, effect, reactive, targetMap, toRaw } = require(process.env.PWD + '/../../static/js/vue/reactivity.global.js')

  const obj = { a: 1 }
  const arr = reactive([obj, { b: 2 }])
  let index = -1
  console.log(`#1 obj === arr[0], ${obj === toRaw(arr[0])}`)
  effect(() => (index = arr.indexOf(obj))) // index = 0
  console.log(`#2 before reverse, index = ${index}`)
  arr.reverse() // #3
  console.log(`#4 after reverse, index = ${index}`)
  console.log(`#5 obj === arr[1], ${obj === toRaw(arr[1])}`)
  #+end_src

  #+RESULTS:
  : #1 obj === arr[0], true
  : #2 before reverse, index = 0
  : #4 after reverse, index = -1
  : #5 obj === arr[1], true
  : undefined

  +RESULTS: å¤±è´¥
  : before reverse, index = 0
  : after reverse, index = -1
  : [ { b: 2 }, { a: 1 } ]
- [X] T5: ä½¿ç”¨ [[/post/javascript-apis/#api-op-delete][delete]] åˆ é™¤æ•°ç»„å…ƒç´ æ—¶ä¸åº”è¯¥è§¦å‘ ~length~ ä¾èµ–

  #+begin_src js
  const { isReactive, effect, reactive, targetMap } = require(process.env.PWD + '/../../static/js/vue/reactivity.global.js')
  const arr = reactive([1,2,3])
  let dummy = 0
  effect(() => {
    dummy = arr.length + 1
  })

  console.log(`before delete, dummy = ${dummy}, arr = ${arr}, len = ${arr.length}`)
  delete arr[1]
  console.log(`after delete, dummy = ${dummy}, arr = ${arr}, len = ${arr.length}`)
  #+end_src

  +RESULTS: åˆ é™¤æ“ä½œå¹¶ä¸ä¼šæ”¹å˜æ•°ç»„é•¿åº¦
  : before delete, dummy = 4, arr = 1,2,3, len = 3
  : after delete, dummy = 4, arr = 1,,3, len = 3
  : undefined

  #+begin_quote
  PS: èµ‹å€¼å·²æœ‰çš„ä¸‹æ ‡å…ƒç´ å€¼ã€æ·»åŠ éæ­£æ•´æ•°ç±»å‹çš„å±æ€§åˆ°æ•°ç»„ä¸Šéƒ½ä¸ä¼šè§¦å‘ ~length~ ä¾
  èµ–ï¼Œæœ¬è´¨ä¸Šå¹¶æ²¡æœ‰æ”¹å˜æ•°ç»„é•¿åº¦ã€‚
  #+end_quote
- [X] T6: åœ¨ effect fn ä¸­ä½¿ç”¨ ~for ... in~ è¿­ä»£è¯­å¥åº”è¯¥ /track length/

  #+begin_src js
  const { isReactive, effect, reactive, targetMap } = require(process.env.PWD + '/../../static/js/vue/reactivity.global.js')

  const nums = [1]
  const array = reactive(nums)
  let len = ''
  effect(() => {
    len = ''
    for (const key in array) {
      len += key
    }
  })

  console.log(`before push, len = ${len}`)
  array.push(1)
  console.log(`after push, len = ${len}`)
  #+end_src

  #+RESULTS:
  : before push, len = 0
  : after push, len = 01
  : undefined

  +RESULTS: è¾“å‡ºæ˜¾ç¤ºï¼Œlength ä¾èµ–å·²ç» track åˆ°äº†ï¼Œåªæ˜¯ Length å˜åŒ–å¹¶æ²¡æœ‰è§¦å‘
  #+begin_example
  Map(1) {
    'length' => Set(1) {
      [Function: reactiveEffect] {
        id: 0,
        allowRecurse: false,
        _isEffect: true,
        active: true,
        raw: [Function (anonymous)],
        deps: [Array],
        options: {}
      }
    }
  }
  before push, len = 0
  after push, len = 0
  #+end_example

  #+begin_quote
    FIX: [[https://github.com/gcclll/stb-vue-next/commit/21b4881a906d5e6f2def3a7e486934af6009e93a][feat(add): array add element support Â· gcclll/stb-vue-next@21b4881]]
  #+end_quote
* [[https://github.com/gcclll/stb-vue-next/commit/21b4881a906d5e6f2def3a7e486934af6009e93a][21b4881]] array add element support

[[https://github.com/gcclll/stb-vue-next/commit/21b4881a906d5e6f2def3a7e486934af6009e93a][feat(add): array add element support Â· gcclll/stb-vue-next@21b4881]]

å¢åŠ æ·»åŠ æ•°ç»„å…ƒç´ æ”¯æŒã€‚

#+begin_src typescript

#+end_src
1. ~createGetter -> get~ proxy handler ä¸­å¢åŠ å±æ€§æ·»åŠ  trigger æ“ä½œ

   ~trigger(target, TriggerOpTypes.ADD, key, value)~

2. effect.ts -> ~trigger()~ ä¸­å¢åŠ æ•°ç»„é•¿åº¦å˜æ›´ä¾èµ–æ”¶é›†å’Œ ~ADD~ æ“ä½œä¾èµ–æ”¶é›†

   [[http://qiniu.ii6g.com/img/20201118105046.png]]
* [[https://github.com/gcclll/stb-vue-next/commit/e85dfc630c3374aa6452891784cc58ffdc5895c6][e85dfc6]] add shallow reactive

[[https://github.com/gcclll/stb-vue-next/commit/e85dfc630c3374aa6452891784cc58ffdc5895c6][feat(add): shallowReactive api Â· gcclll/stb-vue-next@e85dfc6]]

æ­£å¸¸ track è¿‡ç¨‹ä¸­ä¼šæ£€æµ‹åµŒå¥—å†…çš„æ˜¯ä¸æ˜¯å¯¹è±¡ï¼Œå¦‚æœæ˜¯å¯¹è±¡ä¼šè¿›è¡Œé€’å½’ reactive è®©å†…éƒ¨åµŒå¥—çš„å¯¹è±¡ä¹Ÿ reactive åŒ–ã€‚

shallow reactive æ„æ€æ˜¯å½“å¯¹è±¡å­˜åœ¨åµŒå¥—çš„æ—¶å€™ï¼Œä¸è¿›è¡Œé€’å½’ reactive ã€‚

è¿™ä¸ªé€šè¿‡åœ¨ track() å‡½æ•°ä¸­åšä¸€æ¬¡æ‹¦æˆªå¤„ç†ã€‚


æµ‹è¯•ï¼š
#+begin_src js
const {
  isReactive,
  effect,
  reactive,
  targetMap,
  shallowReactive
} = require(process.env.PWD + '/../../static/js/vue/reactivity.global.js')

const props = shallowReactive({ n: { foo: 1} })

console.log(`props.n is reactive, ${isReactive(props.n)}`)

const props2 = shallowReactive({ n: reactive({ foo: 1 }) })
props2.n = reactive({ foo: 2 })
console.log(`props2.n is reactive, ${isReactive(props2.n)}`)

// array test
const shallowArray = shallowReactive([])
const a = {}
let size
effect(() => {
  size = shallowArray.length
})

console.log(`>> array`)
console.log(`before push a, size = ${size}`)
shallowArray.push(a)
console.log(`after push a, size = ${size}`)
shallowArray.pop()
console.log(`after pop, size = ${size}`)

console.log(`>> è¿­ä»£æ—¶ä¸åº”è§‚å¯Ÿ`)
shallowArray.push(a)
const spreadA = [...shallowArray][0]
// è¿­ä»£ä¹Ÿæœ‰å–å€¼è¿‡ç¨‹ï¼Œshallow = true ä¸ä¼šé€’å½’ reactive
console.log(`spreadA is reactive, ${isReactive(spreadA)}`)

console.log(`>> onTrack`)
const onTrackFn = () => console.log('on tracking...')
let b
effect(() => {
  b = Array.from(shallowArray)
}, {
  onTrack: onTrackFn
})
#+end_src

+RESULTS: [[/post/javascript-apis/#api-array-from][Array.from]] æœ¬è´¨æ˜¯è¿­ä»£å™¨æ“ä½œï¼Œæ‰€ä»¥ä¼šè§¦å‘è¿­ä»£å™¨ tracking ã€‚
#+begin_example
props.n is reactive, false
props2.n is reactive, true
>> array
before push a, size = 0
after push a, size = 1
after pop, size = 0
>> è¿­ä»£æ—¶ä¸åº”è§‚å¯Ÿ
spreadA is reactive, false
>> onTrack
on tracking...
on tracking...
undefined
#+end_example
* [[https://github.com/gcclll/stb-vue-next/commit/66e7903568bf7d5bce0faca2f85e80c36399bc66][66e7903]] add readonly reactive

[[https://github.com/gcclll/stb-vue-next/commit/66e7903568bf7d5bce0faca2f85e80c36399bc66][feat(add): readonly reactive Â· gcclll/stb-vue-next@66e7903]]

*** æµ‹è¯•(for ~Object~)ï¼š
#+begin_src js
const {
  isReactive,
  effect,
  reactive,
  targetMap,
  shallowReactive,
  readonly,
  isProxy,
  isReadonly
} = require(process.env.PWD + '/../../static/js/vue/reactivity.global.js')

console.log(`>>> should make nested values readonly`)
const original = { foo: 1, bar: { baz: 2 } }
const wrapped = readonly(original)
console.log(`wrapped !== original, ${wrapped !== original}`)
console.log(`wrapped is proxy, ${isProxy(wrapped)}`)
console.log(`wrapped is reactive, ${isReactive(wrapped)}`)
console.log(`wrapped is readonly, ${isReadonly(wrapped)}`)
console.log(`original is reactive, ${isReactive(original)}`)
console.log(`original is readonly, ${isReadonly(original)}`)
console.log(`wrapped.bar is reactive, ${isReactive(wrapped.bar)}`)
console.log(`wrapped.bar is readonly, ${isReadonly(wrapped.bar)}`)
console.log(`original.bar is reactive, ${isReactive(original.bar)}`)
console.log(`original.bar is readonly, ${isReadonly(original.bar)}`)
console.log(`>> get`)
console.log(`wrapped.foo = ${wrapped.foo}`)
console.log(`>> has`)
console.log(`'foo' in wrapped, ${'foo' in wrapped}`)
console.log(`>> ownKeys`)
console.log(`Object.keys(wrapped), [${Object.keys(wrapped)}]`)

console.log(`>> set or delete, should fail`)
const qux = Symbol('qux')
const original2 = {
  foo: 1,
  bar: {
    baz: 2
  },
  [qux]: 3
}

const wrapped2 = readonly(original2)
wrapped2.foo = 2 // fail
console.log(`after 'wrapped2.foo = 2',  wrapped2.foo = ${wrapped2.foo}`)
wrapped2.bar.baz = 3
console.log(`after 'wrapped2.bar.baz = 3', wrapped2.bar.baz = ${wrapped2.bar.baz}`)
wrapped2[qux] = 4
console.log(`after 'wrapped2[qux] = 4',  wrapped2[qux] = ${wrapped2[qux]}`)

delete wrapped2.foo
console.log(`after 'delete wrapped2.foo', wrapped2.foo = ${wrapped2.foo}`)
delete wrapped2.bar.baz
console.log(`after 'delete wrapped2.bar.baz', wrapped2.bar.baz = ${wrapped2.bar.baz}`)
delete wrapped2[qux]
console.log(`after 'delete wrapped2[qux]', wrapped2[qux] = ${wrapped2[qux]}`)
#+end_src

+RESULTS: readonly ä¼šé€’å½’åµŒå¥—å¯¹è±¡ï¼Œæ‰€ä»¥å®ƒå†…éƒ¨çš„å¯¹è±¡éƒ½ä¼šæ˜¯ readonlyã€‚
#+begin_example
>>> should make nested values readonly
wrapped !== original, true
wrapped is proxy, true
wrapped is reactive, false
wrapped is readonly, true
original is reactive, false
original is readonly, false
wrapped.bar is reactive, false
wrapped.bar is readonly, true
original.bar is reactive, false
original.bar is readonly, false
>> get
wrapped.foo = 1
>> has
'foo' in wrapped, true
>> ownKeys
Object.keys(wrapped), [foo,bar]
>> set or delete, should fail
after 'wrapped2.foo = 2',  wrapped2.foo = 1
after 'wrapped2.bar.baz = 3', wrapped2.bar.baz = 2
after 'wrapped2[qux] = 4',  wrapped2[qux] = 3
after 'delete wrapped2.foo', wrapped2.foo = 1
after 'delete wrapped2.bar.baz', wrapped2.bar.baz = 2
after 'delete wrapped2[qux]', wrapped2[qux] = 3
#+end_example

*** æµ‹è¯•(for ~Array~):
#+begin_src js
const {
  isReactive,
  effect,
  readonly,
  isReadonly,
  reactive,
  targetMap,
  isProxy,
  shallowReactive
} = require(process.env.PWD + '/../../static/js/vue/reactivity.global.js')

console.log(`>>> should make nested values readonly`)
const original = [{ foo: 1 }]
const wrapped = readonly(original)
console.log(`wrapped !== original`)
console.log(`wrapped is proxy, ${isProxy(wrapped)}`)
console.log(`wrapped is reactive, ${isReactive(wrapped)}`)
console.log(`wrapped is readonly, ${isReadonly(wrapped)}`)
console.log(`original is reactive, ${isReactive(original)}`)
console.log(`original is readonly, ${isReadonly(original)}`)
console.log(`wrapped[0] is reactive, ${isReactive(wrapped[0])}`)
console.log(`wrapped[0] is readonly, ${isReadonly(wrapped[0])}`)
console.log(`original[0] is reactive, ${isReactive(original[0])}`)
console.log(`original[0] is readonly, ${isReadonly(original[0])}`)
console.log(`> get`)
console.log(`wrapped[0].foo = ${wrapped[0].foo}`)
console.log(`> has`)
console.log(`0 in wrapped, ${0 in wrapped}`)
console.log(`> ownKeys`)
console.log(`Object.keys(wrapped) = [${Object.keys(wrapped)}]`)

const wrapped2 = readonly([{ foo: 1 }])
wrapped2[0] = 1
console.log(`after 'wrapped2[0] = 1', wrapped2[0] = ${wrapped2[0]}`)
wrapped2[0].foo = 2
console.log(`after 'wrapped2[0].foo = 2', wrapped2[0].foo = ${wrapped2[0].foo}`)
wrapped2.length = 0
console.log(`after 'wrapped2.length = 0', wrapped2.length = ${wrapped.length}`)
console.log(`after 'wrapped2.length = 0', wrapped2[0].foo = ${wrapped2[0].foo}`)
wrapped2.push(2)
console.log(`after 'wrapped2.push(2)', wrapped2.length = ${wrapped2.length}`)
#+end_src

+RESULTS:
#+begin_example
>>> should make nested values readonly
wrapped !== original
wrapped is proxy, true
wrapped is reactive, false
wrapped is readonly, true
original is reactive, false
original is readonly, false
wrapped[0] is reactive, false
wrapped[0] is readonly, true
original[0] is reactive, false
original[0] is readonly, false
> get
wrapped[0].foo = 1
> has
0 in wrapped, true
> ownKeys
Object.keys(wrapped) = [0]
after 'wrapped2[0] = 1', wrapped2[0] = [object Object]
after 'wrapped2[0].foo = 2', wrapped2[0].foo = 1
after 'wrapped2.length = 0', wrapped2.length = 1
after 'wrapped2.length = 0', wrapped2[0].foo = 1
after 'wrapped2.push(2)', wrapped2.length = 1
undefined
#+end_example
*** æµ‹è¯•(reactive, readonly äº’æ’©)

#+begin_src js
const {
  isReactive,
  effect,
  reactive,
  readonly,
  isReadonly,
  targetMap,
  toRaw,
  shallowReactive
} = require(process.env.PWD + '/../../static/js/vue/reactivity.global.js')

const a = readonly({})
const b = reactive(a)
console.log(`*#1* isReadonly(b), ${isReadonly(b)}`)
console.log(`*#2* toRaw(a) === toRaw(b), ${toRaw(a) === toRaw(b)}`)
console.log(`*#3* a === b, ${ a === b }`)
#+end_src

+RESULTS:
: *#1* isReadonly(b), true
: *#2* toRaw(a) === toRaw(b), true
: *#3* a === b, true
: undefined

1. *#1* b is readonly: ~createReactive~ ä¸­çš„å¤„ç†

   #+begin_src typescript
   if (target[ReactiveFlags.Raw] && !(isReadonly && target[ReactiveFlags.IS_REACTIVE])) {
     return target
   }
   #+end_src

   ä¸Šé¢çš„å¤„ç†é’ˆå¯¹ ~b = reactive(a)~ æœ‰ï¼š

   a æ»¡è¶³ target[ReactiveFlags.Raw] å› ä¸ºå®ƒæ˜¯ readonly çš„.

   isReadonly = false

   target[ReactiveFlags.IS_REACTIVE] ä¸æ»¡è¶³

   å› æ­¤ä¸Šé¢çš„åˆ¤æ–­æ»¡è¶³ ~target[ReactiveFlags.RAW] &&
   !target[ReactiveFlags.IS_REACTIVE]~ ç›´æ¥è¿”å› target ã€‚

2. *#2* ~toRaw(a) === toRaw(b)~ è¿™ä¸ªç»“æœä¸º trueï¼Œå› ä¸º *#1* ä¸­çš„åŸå› ï¼Œç›´æ¥è¿”å›äº† targetï¼Œ
   æ‰€ä»¥ b å®é™…ä¸Šå°±æ˜¯ a(å¦‚ç»“æœ *#3*)
* [[https://github.com/gcclll/stb-vue-next/commit/aaaf911eb88c75935970e51f843a88f6a3a3c6d6][aaaf911]] add shallow readonly reactive

[[https://github.com/gcclll/stb-vue-next/commit/aaaf911eb88c75935970e51f843a88f6a3a3c6d6][feat(add): shallow readonly reactive Â· gcclll/stb-vue-next@aaaf911]]

[[http://qiniu.ii6g.com/img/20201119153149.png]]

æµ‹è¯•:

#+begin_src js
const {
  isReactive,
  effect,
  reactive,
  targetMap,
  shallowReactive,
  shallowReadonly
} = require(process.env.PWD + '/../../static/js/vue/reactivity.global.js')

// åµŒå¥—å¯¹è±¡ä¸åº”è¯¥ reactive
console.log(`>>> should not make non-reactive properties reactive`)
let props = shallowReadonly({ n: {foo: 1} })
console.log(`isReactive(props.n), ${isReactive(props.n)}`)

// æ ¹å±æ€§åº”è¯¥æ˜¯ readonly
console.log(`>>> should make root level properties readonly`)
props = shallowReadonly({n : 1})
props.n = 2
console.log(`after 'props.n = 2', props.n = ${props.n}`)
// åµŒå¥—çš„å±æ€§ä¸åº”è¯¥æ˜¯ readonly ï¼Œå› ä¸ºæ˜¯ shallow
console.log(`>>> should NOT make nested properties readonly`)
props = shallowReadonly({ n: { foo: 1 } })
props.n.foo = 2
console.log(`after 'props.n.foo = 2', props.n.foo = ${props.n.foo}`)
#+end_src

+RESULTS:
: >>> should not make non-reactive properties reactive
: isReactive(props.n), false
: >>> should make root level properties readonly
: after 'props.n = 2', props.n = 1
: >>> should NOT make nested properties readonly
: after 'props.n.foo = 2', props.n.foo = 2
: undefined

è¿™é‡Œçš„ç»“æœä¸éš¾ç†è§£

 1. shallow ä¸ä¼šé€’å½’ reactive
 2. readonly è®©å±æ€§åªè¯»ï¼Œä½†æ˜¯ç”±äºæ˜¯ shallow æ‰€ä»¥åªæœ‰å¯¹è±¡æ ¹å±æ€§æ‰æ˜¯åªè¯»
* [[https://github.com/gcclll/stb-vue-next/commit/f1e5b3afb88d41d065f1c797f5db66ac7c65339f][f1e5b3a]] add effect stop

[[https://github.com/gcclll/stb-vue-next/commit/f1e5b3afb88d41d065f1c797f5db66ac7c65339f][feat(add): effect stop Â· gcclll/stb-vue-next@f1e5b3a]]

[[http://qiniu.ii6g.com/img/20201119162119.png]]

stop() å‡½æ•°æ“ä½œï¼š
1. æ¸…ç©ºæ‰€æœ‰ effect ä¸Šçš„ depsï¼ŒåŒæ—¶å°†å½“å‰çš„ effect ä»æ‰€æœ‰ä¾èµ–å®ƒçš„ dep ä¸­åˆ é™¤

   ~effect.deps[i].delete(effect)~ , è¿™ä¸€æ­¥æ˜¯å°† ~targetMap > depsMap > deps~ ä¸­
   çš„ effect åˆ é™¤ã€‚

   ~effect.deps.length = 0~
2. å°† effect.active ç½®ä¸º false


æ‰§è¡Œ ~stop()~ ä¹‹åï¼Œåªèƒ½æ‰‹åŠ¨è°ƒç”¨ ~runner()~ æ¥è§¦å‘ effect fn(å‰ææ˜¯æ²¡æœ‰æä¾›
~options.scheduler~ ï¼Œå¦åˆ™æ°¸è¿œä¸ä¼šè¢«æ‰§è¡Œ) ã€‚

è¢« stopped çš„ effect å¯ä»¥å½“åšå¦ä¸€ä¸ªæ­£å¸¸çš„ effect çš„ fnã€‚
* [[https://github.com/gcclll/stb-vue-next/commit/521f755fd403d5f0431bcafd1737f1d988ce0825][521f755]] add collection handlers

[[https://github.com/gcclll/stb-vue-next/commit/521f755fd403d5f0431bcafd1737f1d988ce0825][feat(add): mutable collection handlers Â· gcclll/stb-vue-next@521f755]]

[[#whole-collection][collection proxy handlers è„‘å›¾é“¾æ¥]]

å› ä¸º Reflect æ²¡æœ‰é›†åˆæ“ä½œçš„å¯¹åº”æ¥å£ï¼Œæ‰€ä»¥é’ˆå¯¹é›†åˆç±»å‹éœ€è¦é€šè¿‡ ~get proxy~ æ¥ä¸­è½¬
åšç‰¹æ®Šå¤„ç†ã€‚

#+begin_src typescript
function createInstrumentationGetter(isReadonly: boolean, shallow: boolean) {
  // TODO
}
export const mutableCollectionHandlers: ProxyHandler<CollectionTypes> = {
  // get: createInstrumentationGetter(false, false)
}
#+end_src

æ·»åŠ é›†åˆç±»å‹çš„ handlersã€‚
* [[https://github.com/gcclll/stb-vue-next/commit/a5e8e062658d458081ce1bb499b8041f6175689e][a5e8e06]] add collection get proxy handler

[[https://github.com/gcclll/stb-vue-next/commit/a5e8e062658d458081ce1bb499b8041f6175689e][feat(add): collection get proxy Â· gcclll/stb-vue-next@a5e8e06]]

é’ˆå¯¹é›†åˆçš„æ‰€æœ‰æ“ä½œä»£ç†éƒ½æ˜¯é€šè¿‡ get proxy å˜ç›¸å®Œæˆçš„ï¼Œæ‰€ä»¥ææ‡‚è¿™é‡Œæ˜¯è‡³å…³é‡è¦çš„ã€‚

collection proxy handler:

#+begin_src typescript
export const mutableCollectionHandlers: ProxyHandler<CollectionTypes> = {
  get: createInstrumentationGetter(false, false)
}
#+end_src

ç®€å•å§ï¼Œåˆ«è¢«å‡ğŸ˜ç»™è¿·æƒ‘äº†ï¼ï¼ï¼

è¿™é‡Œçš„åŸç†å¦‚æœæƒ³é€šäº†ä¹Ÿç®€å•ã€‚

è¯•æƒ³ä¸‹ï¼Œæˆ‘ä»¬è°ƒç”¨é›†åˆç±»å‹çš„æ–¹æ³•æ˜¯æ€ä¹ˆè°ƒç”¨çš„ï¼Ÿï¼Ÿï¼Ÿ

~map.get()~, ~map.set()~, ~map.delete()~, ~...~

éƒ½æ˜¯é€šè¿‡ç‚¹è¯­æ³•ä½¿ç”¨çš„ï¼Œç‚¹è¯­æ³•å‰æä¹Ÿå¿…é¡»æ˜¯å…ˆå–å‡ºå€¼æ¥è¿›è¡Œæ“ä½œï¼Œå³è¦è°ƒç”¨æ–¹æ³•ä¹‹å‰ï¼Œå…ˆ
å°†æ–¹æ³•å–å‡ºæ¥ï¼Œå› æ­¤è¿™é‡Œå°±æ˜¯å–å€¼æ“ä½œã€‚

ä»è¿™ä¸€ä¸ªå±‚çº§ä¸Šå»ç†è§£å»å®ç°ï¼Œå°±å¯ä»¥é€šè¿‡é›†åˆçš„ ~proxy get~ æ¥å˜ç›¸å®ç°æ‰€æœ‰é›†åˆçš„æ–¹
æ³•å’Œå±æ€§ä»£ç†ã€‚

æ³¨æ„ ~Reflect.get(target, key, receiver)~ ç¬¬ä¸€ä¸ªä¼ çš„æ˜¯ä»€ä¹ˆï¼Ÿ

~boolean ? instrumentations : target~ å³å°è£…åçš„ ~instrumentations~ å•Š !

å¦‚ï¼š ~map.get()~ -> ~target: map, key: get~ -> ~target: instumentations, key:
get~ -> ~get(target, key, isReadonly, isShallow)~

é›†åˆçš„æ“ä½œæœ€ç»ˆ -----> è½¬å˜æˆ instrumentations å¯¹è±¡ä¸Šçš„æ“ä½œã€‚

#+begin_quote
å»æ‰æš‚æ—¶ä¸éœ€è¦çš„ä»£ç ([[https://github.com/gcclll/stb-vue-next/commit/65ea709dac46e4310eb2ac95cb19984d9b921d88][65ea709]])ï¼š

[[https://github.com/gcclll/stb-vue-next/commit/65ea709dac46e4310eb2ac95cb19984d9b921d88][feat: add get proxy handler Â· gcclll/stb-vue-next@65ea709]]
#+end_quote

** å®ç°é¡ºåº(åŸç†)
:PROPERTIES:
:COLUMNS: %CUSTOM_ID[(Custom Id)]
:CUSTOM_ID: key-collection-proxy-get
:END: 

#+begin_src typescript
// 1. å¯¹å¤–çš„ handlers
export const mutableCollectionHandlers: ProxyHandler<CollectionTypes> = {
  get: createInstrumentationGetter(false, false)
}


// 2. å°è£… get proxy æ‰€æœ‰ collection æ“ä½œçš„å…¥å£
function createInstrumentationGetter(isReadonly: boolean, shallow: boolean) {
  const instrumentations = mutableInstrumentations

  return (
    target: CollectionTypes,
    key: string | symbol,
    receiver: CollectionTypes
  ) => {
    if (key === ReactiveFlags.IS_REACTIVE) {
      return !isReadonly
    } else if (key === ReactiveFlags.IS_READONLY) {
      return isReadonly
    } else if (key === ReactiveFlags.RAW) {
      return target
    }

    // å°†é›†åˆæ“ä½œä»£ç†åˆ° instrumentations å¯¹è±¡ä¸Š
    return Reflect.get(
      hasOwn(instrumentations, key) && key in target
        ? instrumentations
        : target,
      key,
      receiver
    )
  }
}

// 3. map -> instrumentations -> proxy ä¸­é—´å¯¹è±¡
const mutableInstrumentations: Record<string, Function> = {
  // get proxy handler, this -> target
  get(this: MapTypes, key: unknown) {
    return get(this, key)
  }
}


// 4. æœ€ç»ˆæ‰§è¡Œæ“ä½œå¾—åˆ°ç»“æœçš„å‡½æ•°
function get(
  target: MapTypes,
  key: unknown,
  isReadonly = false,
  isShallow = false
) {
  // TODO

  console.log({ target, key })
  return target.get(key)
}
#+end_src

#+begin_quote
ç†è§£è¿‡ç¨‹ï¼š

é¦–å…ˆè¦ç†è§£æ‰§è¡Œè¿™ä¸€å¥ ~map.get('foo')~ å‘ç”Ÿäº†ä»€ä¹ˆ
1. é¦–å…ˆæ˜¯ ~map.get~ å–å€¼æ“ä½œï¼Œå³ ~createInstrumentationGetter()~ æœ€å return çš„
   é‚£ä¸€å¥

   å…¶å®æ˜¯é’ˆå¯¹ ~map.get~ æ“ä½œçš„ä»£ç†ï¼Œå°† "get" æ–¹æ³•ä» *map* å¯¹è±¡ä¸­å–å‡ºæ¥çš„ä»£ç†ã€‚

   æ‰€ä»¥ ~Reflect.get(target, key, receiver)~ è¿™é‡Œçš„ ~key = "foo"~

2. ç»è¿‡ *#1* ä¹‹åï¼Œéœ€è¦ç«‹å³æ‰§è¡Œ "get" æ–¹æ³•å³ ~()~ æ“ä½œ

   æ­¤æ—¶æ‰§è¡Œçš„æ˜¯ ~mutableInstrumentations.get(this, key)~ æ–¹æ³•

   æ‰€ä»¥è¿™é‡Œçš„ ~key = 'foo'~ , ~this~ å°±æ˜¯è°ƒç”¨ ~get()~ æ–¹æ³•çš„å¯¹è±¡ *map* ã€‚ 

3. æœ€å get æ“ä½œä¼šè¢«æ¨¡å—å…¨å±€å‡½æ•° ~get(target, key, isReadonly, isShallow)~ ä»£æ›¿ï¼Œ
   åšäº†è®¸å¤šç‰¹æ®Šå¤„ç†ï¼Œæ”¶é›†ä¾èµ–ã€‚
   
#+end_quote

** [[https://github.com/gcclll/stb-vue-next/commit/12bc4da85edd0bfee3785ef3dfb77c3f52ef33cd][12bc4da]] add get handler

[[https://github.com/gcclll/stb-vue-next/commit/12bc4da85edd0bfee3785ef3dfb77c3f52ef33cd][feat(add): get function for collection proxy Â· gcclll/stb-vue-next@12bc4da]]

*FIX*: [[https://github.com/gcclll/stb-vue-next/commit/edc1d3f701e744a2b33e9ad5352597519cc06106][edc1d3f]] æ­»å¾ªç¯é—®é¢˜(ç›´æ¥æ”¾å› target.get(key) åˆä¼šè§¦å‘ get -> ...)
[[https://github.com/gcclll/stb-vue-next/commit/edc1d3f701e744a2b33e9ad5352597519cc06106][fix: infinite loop Â· gcclll/stb-vue-next@edc1d3f]]

#+begin_src js
const {
  isReactive,
  effect,
  reactive,
  targetMap,
  shallowReactive
} = require(process.env.PWD + '/../../static/js/vue/reactivity.global.js')

const map = new Map([['foo', 1]])
const observed = reactive(map)

const res = observed.get('foo')
console.log({ res })
#+end_src

+RESULTS:
: {
:   key: 'get',
:   target: Map(1) { 'foo' => 1 },
:   x: 'in createInstrumentationsGetter'
: }
: { key: 'foo', target: Map(1) { 'foo' => 1 }, x: 'in get' }
: { res: 100 }

ç»“æœå¦‚ä¸Š(å‚è§.[[#key-collection-proxy-get][åŸç†è¯¦ç»†åˆ†æ]])
1. reactive(map) -> å°† map ä»£ç†ç»™ ~instrumentations{ get }~
2. observed.get -> å¾—åˆ° instrumentations é‡Œé¢çš„ "get" æ–¹æ³•
3. ('foo') -> æ‰§è¡Œ ~instrumentations.get(this, key)~, /key = 'foo'/
4. è¿”å›ç»“æœ


#+begin_quote
è‡³æ­¤ï¼Œå®Œæˆ collection get proxy handler çš„å®Œæ•´æµç¨‹ã€‚
#+end_quote
** [[https://github.com/gcclll/stb-vue-next/commit/0b3fd712f72ddeda7c4bf5252624545650c1601b][0b3fd71]] add get handler track

[[https://github.com/gcclll/stb-vue-next/commit/0b3fd712f72ddeda7c4bf5252624545650c1601b][feat(add): collection proxy get -> global get Â· gcclll/stb-vue-next@0b3fd71]]

æ–°å¢get æ“ä½œï¼Œtrack æ·»åŠ ä¾èµ–ã€‚

#+begin_src js
const {
  isReactive,
  effect,
  reactive,
  targetMap,
  shallowReactive
} = require(process.env.PWD + '/../../static/js/vue/reactivity.global.js')

const map = new Map([['foo', 1]])
const observed = reactive(map)

let dummy
effect(() => {
  dummy = observed.get('foo')
})

console.log(`dummy = ${dummy}`)

#+end_src

+RESULTS:
#+begin_example
{
  key: 'get',
  target: Map(1) { 'foo' => 1 },
  x: 'in createInstrumentationGetter'
}
{
  key: 'foo',
  type: 'get',
  dep: Set(1) {
    [Function: reactiveEffect] {
      id: 0,
      allowRecurse: false,
      _isEffect: true,
      active: true,
      raw: [Function (anonymous)],
      deps: [Array],
      options: {}
    }
  },
  x: 'in track'
}
{ key: 'foo', target: Map(1) { 'foo' => 1 }, x: 'in global get' }
dummy = 100
#+end_example

åˆ†ä¸ºä¸‰ä¸ªé˜¶æ®µ
1. collection proxy handler å–  map.get æ–¹æ³•, ~key = 'get'~
2. ~('prop')~ æ‰§è¡ŒæœŸè§¦å‘ ~instrumentations.get(this, key), key = 'foo'~
3. æ‰§è¡Œ global get è§¦å‘ ~track~ æ”¶é›†ä¾èµ–ï¼Œè¿”å›ç»“æœå€¼


å‡è®¾ ~map.get(key)~ çš„ key ä¹Ÿæ˜¯ä¸ª proxy :

#+begin_src js
const {
  isReactive,
  effect,
  reactive,
  targetMap,
  shallowReactive
} = require(process.env.PWD + '/../../static/js/vue/reactivity.global.js')

let dummy
const key = reactive({ k: 1 })
const value = reactive({ v: 2 })
const map = reactive(new Map([[key, value]]))

effect( () => {
  dummy = map.get(key)
} )

console.log(`dummy = ${dummy}`)
#+end_src

+RESULTS:
#+begin_example
{ #1
  key: 'get',
  target: Map(1) { { k: 1 } => { v: 2 } },
  x: 'in createInstrumentationGetter'
}
#2
{ key: { k: 1 }, rawKey: { k: 1 }, eq: false }
{ #3
  key: { k: 1 },
  type: 'get',
  dep: Set(1) {
    [Function: reactiveEffect] {
      id: 0,
      allowRecurse: false,
      _isEffect: true,
      active: true,
      raw: [Function (anonymous)],
      deps: [Array],
      options: {}
    }
  },
  x: 'in track'
}
{ #4
  key: { k: 1 },
  type: 'get',
  dep: Set(1) {
    [Function: reactiveEffect] {
      id: 0,
      allowRecurse: false,
      _isEffect: true,
      active: true,
      raw: [Function (anonymous)],
      deps: [Array],
      options: {}
    }
  },
  x: 'in track'
}
{ #5
  key: { k: 1 },
  target: Map(1) { { k: 1 } => { v: 2 } },
  x: 'in global get'
}
dummy = 100
#+end_example

1. *#1* proxy collection get handler
2. *#2* global get å‡½æ•°é‡Œè°ƒç”¨ track ä¹‹å‰è¾“å‡ºï¼Œæ˜¾ç¤º ~key~ å’Œ ~rawKey~ æ˜¯ä¸åŒçš„
   (~eq = false~)ï¼Œå› ä¸ºå‰è€…æ˜¯ä¸ª proxy åè€…æ˜¯ key proxy çš„ rawValue ã€‚
3. *#3* track() è°ƒç”¨æ—¶çš„è¾“å‡ºï¼Œæ˜¾ç¤ºçš„æ˜¯éœ€è¦æ”¶é›†ä¾èµ–çš„æ˜¯ ~proxy key{k: 1}~ 
4. *#4* track() è°ƒç”¨æ—¶çš„è¾“å‡ºï¼Œæ˜¾ç¤ºçš„æ˜¯éœ€è¦æ”¶é›†ä¾èµ–çš„æ˜¯ ~raw key{k: 1}~


ä» *#3*, *#4* å¯çŸ¥å¦‚æœ key æœ¬èº«å·²ç»æ˜¯ proxy é‚£ä¹ˆå®ƒåŠå…¶å¯¹åº”çš„ rawKey åŒæ—¶ä¹Ÿä¼šæ”¶é›†
å½“å‰çš„ effect ã€‚
** [[https://github.com/gcclll/stb-vue-next/commit/77b14ef019cd320bc04f1c861424db79bcc82f9f][77b14ef]] add get handler return value

[[https://github.com/gcclll/stb-vue-next/commit/77b14ef019cd320bc04f1c861424db79bcc82f9f][feat(add): collection proxy get with value return Â· gcclll/stb-vue-next@77b14ef]]

[[http://qiniu.ii6g.com/img/20201121095654.png]]

è¿™é‡Œå¤„ç†åˆ†ä¸ºä¸¤éƒ¨åˆ†ï¼š

1. å–å‡º ~has~ æ–¹æ³•æ£€æµ‹å­˜åœ¨æ€§
2. æ ¹æ® ~isReadonly~ å’Œ ~isShallow~ å†³å®šå¯¹è¿”å›å€¼åšä»€ä¹ˆå¤„ç†ï¼Œå¦‚ï¼šé€’å½’ reactive/readonly
3. ä½¿ç”¨ target.get(key) å–å‡ºç»“æœå€¼è¿”å›
* [[https://github.com/gcclll/stb-vue-next/commit/7b680df94e359c208697111319eda9ee75560b11][7b680df]] add collection set proxy handler

[[https://github.com/gcclll/stb-vue-next/commit/7b680df94e359c208697111319eda9ee75560b11][feat(add): collection set proxy handler Â· gcclll/stb-vue-next@7b680df]]

set proxy handler å¤„ç†

1. è®¾å€¼çš„æ—¶å€™å¯èƒ½æœ‰ä¸¤ç§æƒ…å†µ a) set, b) add
2. éœ€è¦è€ƒè™‘ proxy key å’Œ raw key é—®é¢˜
3. æœ€å trigger è§¦å‘ä¾èµ–

#+begin_src typescript

function set(this: MapTypes, key: unknown, value: unknown) {
  value = toRaw(value)
  const target = toRaw(this)
  const { has, get } = getProto(target)

  let hadKey = has.call(target, key)
  // è€ƒè™‘ key å¯èƒ½æ˜¯ proxy
  if (!hadKey) {
    // to add
    key = toRaw(key)
    hadKey = has.call(target, key)
  } else if (__DEV__) {
    checkIdentityKeys(target, has, key)
  }

  const oldValue = get.call(target, key)
  // è®¾å€¼ç»“æœ
  const result = target.set(key, value)
  if (!hadKey) {
    // æ·»åŠ æ“ä½œ
    trigger(target, TriggerOpTypes.ADD, key, value)
  } else {
    // è®¾å€¼æ“ä½œ
    trigger(target, TriggerOpTypes.SET, key, value, oldValue)
  }

  return result
}
#+end_src

æµ‹è¯•
#+begin_src js
const {
  isReactive,
  effect,
  reactive,
  targetMap,
  shallowReactive
} = require(process.env.PWD + '/../../static/js/vue/reactivity.global.js')


const map = new Map()
const observed = reactive(map)

console.log(`> before get, deps`)
console.log(targetMap.get(map))
let dummy
effect(() => {
  dummy = observed.get('foo')
})

console.log(`> after get, deps`)
console.log(targetMap.get(map).get('foo'))

console.log(`#1 before set, dummy = ${dummy}`)
observed.set('foo', 1)
console.log(`#2 after set, dummy = ${dummy}`)
#+end_src

+RESULTS:
#+begin_example
> before get, deps
undefined
> after get, deps
<ref *1> Set(1) {
  [Function: reactiveEffect] {
    id: 0,
    allowRecurse: false,
    _isEffect: true,
    active: true,
    raw: [Function (anonymous)],
    deps: [ [Circular *1] ],
    options: {}
  }
}
#1 before set, dummy = undefined
#2 after set, dummy = 1
#+end_example
* [[https://github.com/gcclll/stb-vue-next/commit/73fa5ebf7f0dcdaa11bbf42df89c7f7c1ab88385][73fa5eb]] add collection size,has,add proxy handler

[[https://github.com/gcclll/stb-vue-next/commit/73fa5ebf7f0dcdaa11bbf42df89c7f7c1ab88385][feat(add): size, has, add collection proxy handlers Â· gcclll/stb-vue-next@73fa5eb]]

has: proxy key, raw key éƒ½éœ€è¦ track has æ“ä½œä¾èµ–
#+begin_src typescript
function has(this: CollectionTypes, key: unknown, isReadonly = false): boolean {
  const target = (this as any)[ReactiveFlags.RAW]
  const rawTarget = toRaw(target)
  const rawKey = toRaw(key)
  if (key !== rawKey) {
    !isReadonly && track(rawTarget, TrackOpTypes.HAS, key)
  }
  !isReadonly && track(rawTarget, TrackOpTypes.HAS, rawKey)

  return key === rawKey
    ? target.has(key)
    : target.has(key) || target.has(rawKey)
}
#+end_src

size: å–size å†…éƒ¨å®ç°è¿‡ç¨‹ä¸­æ˜¯éœ€è¦å¯¹ collection è¿›è¡Œè¿­ä»£æ“ä½œçš„ï¼Œæ‰€ä»¥ track ç”¨çš„æ˜¯ ~ITERATE_KEY~
#+begin_src typescript
function size(target: IterableCollections, isReadonly = false) {
  target = (target as any)[ReactiveFlags.RAW]
  !isReadonly && track(toRaw(target), TrackOpTypes.ITERATE, ITERATE_KEY)
  return Reflect.get(target, 'size', target)
}
#+end_src

add: set.add æ“ä½œï¼Œæ ¹æ® set ç‰¹æ€§ï¼Œkey,value éƒ½æ˜¯åŒä¸€ä¸ªä¸”å…ƒç´ æ˜¯ä¸é‡å¤çš„ï¼Œæ‰€ä»¥åªéœ€
è¦æ£€æµ‹æ˜¯ä¸æ˜¯æ–°å¢ï¼Œæ–°å¢å°±éœ€è¦ trigger ADD ã€‚
#+begin_src typescript
function add(this: SetTypes, value: unknown) {
  value = toRaw(value)
  const target = toRaw(this)
  const proto = getProto(target)
  const hadKey = proto.has.call(target, value)
  const result = target.add(value)
  // å› ä¸º set æ˜¯ä¸ä¼šå­˜åœ¨é‡å¤å…ƒç´ çš„ï¼Œæ‰€ä»¥åªä¼šåœ¨æ²¡æœ‰å½“å‰ key çš„æƒ…å†µä¸‹æ‰ä¼šæ‰§è¡Œ
  // æ·»åŠ æ“ä½œ
  if (!hadKey) {
    trigger(target, TriggerOpTypes.ADD, value, value)
  }
  return result
}
#+end_src

trigger å¤„ç†ï¼š[[https://github.com/gcclll/stb-vue-next/commit/838b4023b61bc0fede67e94aa7fd857a4950c29e][838b402]]

[[https://github.com/gcclll/stb-vue-next/commit/838b4023b61bc0fede67e94aa7fd857a4950c29e][feat(add): collection trigger cases Â· gcclll/stb-vue-next@838b402]]

æµ‹è¯•ï¼š
#+begin_src js
const {
  isReactive,
  effect,
  reactive,
  targetMap,
  shallowReactive
} = require(process.env.PWD + '/../../static/js/vue/reactivity.global.js')

const map = new Map()
const observed = reactive(map)
let dummy
effect(() => {
  dummy = observed.size
})

console.log(`before set, get map size -> dummy = ${dummy}`)
observed.set('foo', 1)
console.log(`after set, get map size -> dummy = ${dummy}`)

effect(() => {
  dummy = observed.has('foo')
})
console.log(`observed has 'foo' -> dummy = ${dummy}`)

const set = new Set()
const observedSet = reactive(set)
effect(() => {
  dummy = observedSet.size
})
console.log(`before add, get set size -> dummy = ${dummy}`)
observedSet.add(1)
console.log(`after add, get set size -> dummy = ${dummy}`)
#+end_src

+RESULTS:
: before set, get map size -> dummy = 0
: after set, get map size -> dummy = 1
: observed has 'foo' -> dummy = true
: before add, get set size -> dummy = 0
: after add, get set size -> dummy = 1

* [[https://github.com/gcclll/stb-vue-next/commit/b3c5087095ace7797cf6c38bd45b99700d4b6059][b3c5087]] add collection delete,clear proxy handler

[[https://github.com/gcclll/stb-vue-next/commit/b3c5087095ace7797cf6c38bd45b99700d4b6059][feat(add): collection delete and clear Â· gcclll/stb-vue-next@b3c5087]]

delete:
#+begin_src typescript
function deleteEntry(this: CollectionTypes, key: unknown) {
  const target = toRaw(this)
  const { has, get } = getProto(target)
  let hadKey = has.call(target, key)
  if (!hadKey) {
    key = toRaw(key)
    hadKey = has.call(target, key)
  } else if (__DEV__) {
    checkIdentityKeys(target, has, key)
  }

  const oldValue = get ? get.call(target, key) : undefined
  const result = target.delete(key)
  if (hadKey) {
    trigger(target, TriggerOpTypes.DELETE, key, undefined, oldValue)
  }
  return result
}
#+end_src

clear:
#+begin_src typescript
function clear(this: IterableCollections) {
  const target = toRaw(this)
  const hadItems = target.size !== 0
  const oldTarget = __DEV__
    ? isMap(target)
      ? new Map(target)
      : new Set(target)
    : undefined

  const result = target.clear()
  if (hadItems) {
    trigger(target, TriggerOpTypes.CLEAR, undefined, undefined, oldTarget)
  }
  return result
}
#+end_src

æµ‹è¯•ï¼š
#+begin_src js
const {
  isReactive,
  effect,
  reactive,
  targetMap,
  shallowReactive
} = require(process.env.PWD + '/../../static/js/vue/reactivity.global.js')

const map = new Map()
const observedMap = reactive(map)
let dummy
effect(() => {
  dummy = observedMap.size
})

console.log(`>>> map`)
observedMap.set('foo', 1)
console.log(`before delete, dummy = ${dummy}`)
observedMap.delete('foo')
console.log(`after delete, dummy = ${dummy}`)
observedMap.set('foo', 1)
observedMap.set('bar', 1)
console.log(`before clear, dummy = ${dummy}`)
observedMap.clear()
console.log(`after clear, dummy = ${dummy}`)
console.log(`>>> set`)

const set = new Set()
const observedSet = reactive(set)
effect(() => {
  dummy = observedSet.size
})
observedSet.add(1)
console.log(`before delete, dummy = ${dummy}`)
observedSet.delete(1)
console.log(`after delete, dummy = ${dummy}`)
observedSet.add(1)
observedSet.add(2)
observedSet.add(3)
console.log(`before clear, dummy = ${dummy}`)
observedSet.clear()
console.log(`after clear, dummy = ${dummy}`)
#+end_src

+RESULTS:
#+begin_example
>>> map
before delete, dummy = 1
after delete, dummy = 0
before clear, dummy = 2
after clear, dummy = 0
>>> set
before delete, dummy = 1
after delete, dummy = 0
before clear, dummy = 3
after clear, dummy = 0
#+end_example

* effect æµ‹è¯•
*** æµ‹è¯•1(base, prototype)

:PROPERTIES:
:COLUMNS: %CUSTOM_ID[(Custom Id)]
:CUSTOM_ID: effect-test-01
:END:

æµ‹è¯•å†…å®¹ï¼š
1. effect åŸºæœ¬ä½¿ç”¨
2. effect ä½œç”¨åŸŸåŸå‹é“¾

#+begin_src js
// åªæ‰§è¡Œä¸€æ¬¡ effect fn
const {
  isReactive,
  effect,
  reactive,
  targetMap,
  shallowReactive
} = require(process.env.PWD + '/../../static/js/vue/reactivity.global.js')

// åŸºæœ¬çš„æµ‹è¯•ç”¨ä¾‹å°±ä¸åˆ—å‡ºæ¥äº†ï¼Œè¿™é‡Œåªåˆ—å‡ºæœ‰ç–‘é—®çš„
// 1. effect fn åªæ‰§è¡Œä¸€æ¬¡
// 2. observe åŸºæœ¬å±æ€§
// 3. observe å¤šä¸ªå±æ€§(n1,n2...) -> effect(() => (dummy = obj.n1 + obj.n2))
// 4. åŒä¸€ä¸ªå±æ€§å¤šä¸ª effectï¼Œä¼šå°†è¿™å¤šä¸ª effects æ”¶é›†åˆ° prop çš„ deps ä¸­
// 5. observe å±æ€§åˆ é™¤
let dummy, dummy1, dummy2
const ob = reactive({ foo: { bar: 0 } })
effect(() => (dummy = ob.foo.bar)) // effect -> ob, ob.foo, ob.foo.bar deps
effect(() => (dummy1 = ob.foo.bar))
console.log(`before set, dummy = ${dummy}, dummy1 = ${dummy1}`)
ob.foo.bar = 8
console.log(`after set, dummy = ${dummy}, dummy1 = ${dummy1}`)
delete ob.foo.bar
console.log(`after delete, dummy = ${dummy}, dummy1 = ${dummy1}`)
console.log(`>>> åŸå‹é“¾`)

const obj1 = { num: 0 }, obj2 = { num: 2 }
const counter = reactive(obj1)
const parentCounter = reactive(obj2)
// å–å€¼åŸç†ï¼š å…ˆè‡ªèº«å†å¾€ä¸Šæ‰¾åŸå‹é“¾ï¼Œæ‰€æœ‰åªè¦
Object.setPrototypeOf(counter, parentCounter)
effect(() => (dummy = counter.num))
console.log(`dummy = ${dummy}`)
console.log(`> #1 obj1.num çš„ä¾èµ–`)
console.log(targetMap.get(obj1).get('num'))
console.log(`> #2 obj2.num çš„ä¾èµ–, delete ä¹‹å‰`)
console.log(targetMap.get(obj2))
delete counter.num // è¿™é‡Œåˆ é™¤äº†å±æ€§ï¼Œè§¦å‘ effect fn é‡Œé¢å–å€¼æ“ä½œå‘ç°æ²¡æœ‰å±æ€§äº†
// å¾€åŸå‹é“¾æ‰¾ï¼Œæ‰¾åˆ° parentCounter.num ï¼Œæ­¤æ—¶ parentCounter.num æ”¶é›† effect fn è¿›è‡ªå·±çš„ deps
// æ‰€ä»¥åé¢çš„ parentCounter.num ä¸Šçš„æ“ä½œåŒæ ·ä¼šè§¦å‘ effect fn
console.log(`after delete, dummy = ${dummy}`)
console.log(`> #3 obj2.num çš„ä¾èµ–, delete ä¹‹å`)
console.log(targetMap.get(obj2).get('num'))
parentCounter.num = 4
console.log(`#4 after 'parentCounter.num = 4', dummy = ${dummy}`)
counter.num = 3
console.log(`#5 after counter.num = 3', dummy = ${dummy}`)
#+end_src

ç»“æœåˆ†æï¼š
- *#1* obj1.num ä¾èµ–æ˜¯åœ¨ effect ç¬¬ä¸€æ¬¡æ‰§è¡Œçš„æ—¶å€™æ”¶é›†çš„
- *#2* obj2.num åœ¨æ‰§è¡Œ ~delete counter.num~ ä¹‹å‰æ˜¯æ²¡æœ‰ä»»ä½•ä¾èµ–

  å› ä¸ºæ­¤æ—¶å¹¶æ²¡æœ‰ä»»ä½• ~parentCounter~ ä¸Šçš„æ“ä½œ
- *#3* obj2.num æœ‰äº†è‡ªå·±çš„ä¾èµ–

  æ­¤æ—¶ï¼Œæ‰§è¡Œäº† ~delete counter.num~ é€»è¾‘å¦‚ä¸‹ï¼š

  å¯¹ counter.num æ‰§è¡Œåˆ é™¤ä¼šè§¦å‘ ~num~ ä¸Šçš„æ‰€æœ‰ä¾èµ– depsï¼Œå³æ‰§è¡Œ effect fnï¼Œ

  åœ¨ effect fn é‡Œé¢æœ‰ ~counter.num~ çš„å–å€¼æ“ä½œï¼Œä½†æ˜¯å‘ç°å±æ€§è¢«åˆ é™¤ï¼Œæ ¹æ®å–å€¼æŸ¥æ‰¾
  åŸç†ï¼Œä¼šåœ¨å¯¹è±¡çš„åŸå‹é“¾ä¸Šé€çº§å¾€ä¸ŠæŸ¥æ‰¾(~parentCounter~)ï¼Œæ‰¾åˆ°
  ~parentCounter.num~ éšæœºè¿›è¡Œå–å€¼æ“ä½œï¼Œæ‰€ä»¥åˆ é™¤æ“ä½œä¹‹åçš„ ~dummy = 2~ ï¼Œä¸”å–å€¼
  æ“ä½œè§¦å‘ tracking å› æ­¤æ­¤æ—¶ ~parentCounter.num~ å°±æœ‰äº†è‡ªå·±çš„ä¾èµ– effect fnã€‚
- *#4* ç»™ parentCounter è®¾å€¼è§¦å‘ effect fnï¼ŒæŸ¥æ‰¾åŸå‹é“¾ , æ‰€ä»¥ dummy = 4
- *#5* ç»™ counter è®¾å€¼è§¦å‘ effect fnï¼Œä¸æŸ¥æ‰¾åŸå‹é“¾(è‡ªèº«å±æ€§)ï¼Œæ‰€ä»¥ dummy = 3

+RESULTS:
#+begin_example
before set, dummy = 0, dummy1 = 0
after set, dummy = 8, dummy1 = 8
after delete, dummy = undefined, dummy1 = undefined
>>> åŸå‹é“¾
dummy = 0
> #1 obj1.num çš„ä¾èµ–
<ref *1> Set(1) {
  [Function: reactiveEffect] {
    id: 2,
    allowRecurse: false,
    _isEffect: true,
    active: true,
    raw: [Function (anonymous)],
    deps: [ [Circular *1] ],
    options: {}
  }
}
> #2 obj2.num çš„ä¾èµ–, delete ä¹‹å‰
undefined
after delete, dummy = 2
> #3 obj2.num çš„ä¾èµ–, delete ä¹‹å
<ref *1> Set(1) {
  [Function: reactiveEffect] {
    id: 2,
    allowRecurse: false,
    _isEffect: true,
    active: true,
    raw: [Function (anonymous)],
    deps: [ [Circular *1], [Set] ],
    options: {}
  }
}
#4 after 'parentCounter.num = 4', dummy = 4
#5 after counter.num = 3', dummy = 3
undefined
#+end_example
*** æµ‹è¯•2(stop, ...)
:PROPERTIES:
:COLUMNS: %CUSTOM_ID[(Custom Id)]
:CUSTOM_ID: effect-test-02
:END:

1. *stop* :

   #+begin_src js
    const {
        isReactive,
        effect,
        reactive,
        targetMap,
        shallowReactive,
        stop
    } = require(process.env.PWD + '/../../static/js/vue/reactivity.global.js')

    console.log(`>>> stop effect`)
    let dummy
    const obj = reactive({ prop: 1 })
    const runner = effect(() => {
        dummy = obj.prop
    })
    obj.prop = 2
    console.log(`#1, after 'obj.prop = 2', dummy = ${dummy}`)
    console.log(`> prop deps, before stop`)
    console.log(targetMap.get(obj.__v_raw).get('prop'))
    // æ¸…ç©ºäº†æ‰€æœ‰ä¾èµ–
    stop(runner) // stop the effect, set effect.active = false
    console.log(`> prop deps, after stop`)
    console.log(targetMap.get(obj.__v_raw).get('prop'))
    obj.prop = 3
    console.log(`#2, after stop, 'obj.prop = 3', dummy = ${dummy}`)
    obj.prop = 4
    console.log(`#3, after stop, 'obj.prop = 4', dummy = ${dummy}`)
    runner()
    console.log(`#4, after run runner, dummy = ${dummy}, runner.active = ${runner.active}`)
    #+end_src

    +RESULTS:
    #+begin_example
    >>> stop effect
    #1, after 'obj.prop = 2', dummy = 2
    > prop deps, before stop
    <ref *1> Set(1) {
    [Function: reactiveEffect] {
        id: 0,
        allowRecurse: false,
        _isEffect: true,
        active: true,
        raw: [Function (anonymous)],
        deps: [ [Circular *1] ],
        options: {}
    }
    }
    > prop deps, after stop
    Set(0) {}
    #2, after stop, 'obj.prop = 3', dummy = 2
    #3, after stop, 'obj.prop = 4', dummy = 2
    #4, after run runner, dummy = 4, runner.active = false
    undefined
    #+end_example

   - stop å¹²äº†ä¸¤ä»¶äº‹(a. æ¸…ç©ºæ‰€æœ‰ effect.deps, b. å°† effect.active ç½®ä¸º false)
   - stop ä¹‹å trigger æ—¶æ²¡æœ‰ deps å¯æ‰§è¡Œï¼Œæ‰€ä»¥æ— è®ºå¦‚ä½• effect fn ä¸ä¼šè¢«æ‰§è¡Œ
   - æ‰‹åŠ¨æ‰§è¡Œ runner() ä¹‹åæ‰§è¡Œeffect fn é‡æ–°æ”¶é›†ä¾èµ–(æ­¤æ—¶ active ä¾æ—§ä¸º ~false~)

2. *stop + scheduler* :

   #+begin_src js
    const {
        isReactive,
        effect,
        reactive,
        targetMap,
        stop,
        shallowReactive
    } = require(process.env.PWD + '/../../static/js/vue/reactivity.global.js')

    let dummy
    const obj = reactive({ prop : 1 })
    const queue = []
    const runner = effect(() => (dummy = obj.prop), { scheduler: e => queue.push(e) })
    obj.prop = 2
    console.log(`#1 after 'obj.prop = 2', dummy = ${dummy}`)
    console.log(`#2 after 'obj.prop = 2', queue.length = ${queue.length}`)
    stop(runner)

    queue.forEach(e => e())
    console.log(`#3 after stop, queue forEach, dummy = ${dummy}`)
    #+end_src

    +RESULTS:
    : #1 after 'obj.prop = 2', dummy = 1
    : #2 after 'obj.prop = 2', queue.length = 1
    : #3 after stop, queue forEach, dummy = 1

    æä¾›äº† scheduler é€‰é¡¹çš„ effect æ°¸è¿œä¸ä¼šè¢«æ‰§è¡Œï¼Œæºç ï¼š

    #+begin_src js
    if (!effect.active) {
        return options.scheduler ? undefined : fn()
    }
    #+end_src

3. *onStop* :

   #+begin_src js
    const {
        isReactive,
        effect,
        reactive,
        targetMap,
        stop,
        shallowReactive
    } = require(process.env.PWD + '/../../static/js/vue/reactivity.global.js')

    let n = 0
    const runner = effect(() => {}, {
        onStop() {
            console.log(`stopped ${++n} times`)
        }
    })

    stop(runner)
    stop(runner)
    stop(runner)
    #+end_src

    +RESULTS:
    : stopped 1 times

    åªä¼šè¢«æ‰§è¡Œä¸€æ¬¡ï¼Œå› ä¸º ~effect.active = true~ æ—¶æ‰å¯ä»¥è¢« stop ã€‚

4. *stop: ä¸€ä¸ª stopped çš„ effect åœ¨ä¸€ä¸ªæ­£å¸¸çš„ effect ä¸­è°ƒç”¨*

   #+begin_src js
    const {
        isReactive,
        effect,
        reactive,
        targetMap,
        stop,
        shallowReactive
    } = require(process.env.PWD + '/../../static/js/vue/reactivity.global.js')

   let dummy
   const obj = reactive({ prop: 1 })
   const runner = effect(() => {
     dummy = obj.prop
   })

   stop(runner)
   obj.prop = 2
   console.log(`#1 after stop runner, dummy = ${dummy}`)

   // è¿™é‡Œç­‰äºæ˜¯æ‰‹åŠ¨æ‰§è¡Œäº† runner effect `dummy = obj.prop`
   // æ‰€ä»¥ä¸‹é¢çš„ effect è¢« obj.prop æ”¶é›†è¿› deps<Set>
   effect(() => {
     runner()
   })
   obj.prop = 3
   console.log(`#2 after runner in effect, dummy = ${dummy}`)
   #+end_src

   +RESULTS:
   : #1 after stop runner, dummy = 1
   : #2 after runner in effect, dummy = 3

   1. *#1* å€¼ä¾æ—§æ˜¯ 1 ï¼Œæ˜¯å› ä¸º stop äº†

   2. *#2* å€¼ä¸º 3ï¼Œæ˜¯å› ä¸º effect æ‰§è¡Œ runner() ä½¿å¾— ~obj.prop~ æ”¶é›†åˆ°ç¬¬äºŒä¸ª
      effect fn ã€‚
* é˜¶æ®µæµ‹è¯•ä¸€
** effect + track + trigger å“åº”å¼åŸºæœ¬æ“ä½œ(get/set)
:PROPERTIES:
:COLUMNS: %CUSTOM_ID[(Custom Id)]
:CUSTOM_ID: test-01
:END:

commit: [[https://github.com/gcclll/stb-vue-next/commit/b5f97b413d4628f4ec8fcf4e859d387ebfac3ad8][feat: effect-trigger Â· gcclll/stb-vue-next@b5f97b4]]

#+RESULTS:

1. lazy: true æ ‡è¯† effect fn ä¸ä¼šç«‹å³æ‰§è¡Œ
2. ç‚¹å‡» set æ“ä½œï¼Œæ­¤æ—¶å¹¶æ²¡æœ‰ä¾èµ–ï¼Œæ‰€ä»¥åªä¼šè§¦å‘ count++
3. å½“ç‚¹å‡» get æ“ä½œï¼Œè§¦å‘ ~track()~ æ”¶é›†ä¾èµ– fn -> deps
4. å†ç‚¹å‡» set æ“ä½œï¼Œæ­¤æ—¶å·²ç»æœ‰ä¾èµ–ï¼Œæ‰€ä»¥ä¼š ~trigger()~ æ‰€æœ‰ä¾èµ–æ›´æ–°
5. options.scheduler é€‰é¡¹ä½œç”¨

   å¦‚æœ options æœ‰ scheduler é€‰é¡¹ï¼Œ ~trigger()~ çš„æ—¶å€™ä¸ä¼šç«‹å³æ‰§è¡Œ effects è€Œæ˜¯
   è°ƒç”¨ scheduler å¹¶å°†å½“å‰éœ€è¦è¢«æ‰§è¡Œçš„ effect å½“åšå‚æ•°ç»™ schedulerï¼Œç”±ä½¿ç”¨è€…å†³å®š
   ä½•æ—¶å»æ‰§è¡Œ effectï¼Œæ¯”å¦‚éœ€è¦åœ¨ dummy æ›´æ–°ä¹‹å‰åšç‚¹ä»€ä¹ˆã€‚

#+begin_export html
<style>
#_effect_test_02>.box {
  display: flex;
  justify-content: space-around;
}
#_effect_test_02>.box>button{
  border: none;
  width: 250px;
}
</style>
<div id="_effect_test_02">
<div class="box">
    <button class="getval">ç‚¹æˆ‘è§¦å‘ getæ“ä½œï¼</button>
    <button class="setval">ç‚¹æˆ‘è§¦å‘ setæ“ä½œï¼</button>
</div>
<br>
<div class="box">
    <button class="before-scheduler">æ‰‹åŠ¨è°ƒç”¨ scheduler ä¹‹å‰</button>
    <button class="after-scheduler">æ‰‹åŠ¨è°ƒç”¨ scheduler ä¹‹å</button>
</div>
<br>
<div class="box">
    <button class="code">ç‚¹å‡»æŸ¥çœ‹æµ‹è¯•æºç </button>
    <button class="reset">é‡ç½®</button>
</div>
<div class="result"></div>
<code></code>
</div>
#+end_export

#+begin_export html
<script id="GW0MDx">
setTimeout(function test() {
    if (typeof $ === 'undefined') return

    var ins = VueReactivity
    var effect = ins.effect
    var reactive = ins.reactive
    var target = { count: 0 }
    var counter = reactive(target)

    var $el = $("#_effect_test_02")
    var LOG = function (msg) {
      _log($el, msg)
    }

    var lazyEffect = effect(
      function fn() {
        var c = counter.count
        LOG('æ­£åœ¨æ‰§è¡Œ effect fn..., counter.count = ' + counter.count)
      }, {
        lazy: true
      }
    )

    var effected = false
    var getDeps = function () {
      if (!ins.targetMap) return new Set()
      const depsMap = ins.targetMap.get(target) || new Map()
      return depsMap.get('count') || new Set()
    }
    $el.find(".setval").click(function() {
      counter.count++
      var size = getDeps().size
      if (size === 0) {
        LOG('target æ­¤æ—¶æ— ä»»ä½•ä¾èµ–ï¼Œdeps.size = ' + size + ', counter.count = ' + counter.count)
      }
    })
    $el.find(".reset").click(function() {
      ins.cleanup(lazyEffect)
      $el.children(".result").html('')
      effected = false
      counter.count = 0
      dummy = 0
      runner = undefined
      times = 0
      LOG('target.count deps.size = ' + getDeps().size)
    })
    $el.find(".getval").click(function() {
      if (!effected) {
        effected = true
        lazyEffect() // æ‰‹åŠ¨æ‰§è¡Œ effect
        LOG('æ‰‹åŠ¨æ‰§è¡Œ effect()ï¼Œå¼€å§‹æ”¶é›†ä¾èµ– fn -> deps<Set>, size: ' + getDeps().size)
      }
      LOG('å–å€¼æ“ä½œ(target.count çš„ deps æ•°)ï¼š'
        + ins.targetMap.get(target).get('count').size
        + ', counter.count = ' + counter.count)
    })

    $el.find('.code').click(function() {
      console.log($("#GW0MDx").html())
      LOG('æºç å·²è¾“å‡ºåˆ°æ§åˆ¶å°(F12-console)....')
    })

    var dummy = 0, runner
    var counter1 = reactive({ count: 0 })
    var times = 0
    var schedulerEffect = effect(function fn() {
      dummy = counter1.count
    }, {
      scheduler: function(_effect) {
        LOG('scheduler æ‰§è¡Œæ¬¡æ•° ' + ++times + ', dummy = ' + dummy)
        runner = function() {
          _effect()
        }
      }
    })

    LOG('scheduler effect fn ç¬¬ä¸€æ¬¡ä¼šè¢«æ‰§è¡Œï¼Œ dummy = ' + dummy)
    $el.find('.before-scheduler').click(function() {
      LOG('scheduler ä¸ä¼šè¢«æ‰§è¡Œ, dummy = ' + dummy)
    })

    $el.find('.after-scheduler').click(function() {
      counter1.count++
      runner()
    })
}, 1000)

</script>
#+end_export

** ç›¸å…³ç”¨ä¾‹ï¼š
1. ç«‹å³æ‰§è¡Œä¸€æ¬¡ fnï¼Œè§‚å¯ŸåŸºæœ¬å±æ€§(ä¸€ä¸ªæˆ–å¤šä¸ª)

   #+begin_src js
    const { effect, reactive, targetMap } = require(process.env.PWD + '/../../static/js/vue/reactivity.global.js')

    const ob = reactive({ n1: 0, n2: 10 })
    let times = 0, dummy = 0
    effect(() => {
    console.log('effect fn è¢«æ‰§è¡Œ ' + ++times + ' æ¬¡')
    dummy = ob.n1 + ob.n2
    })

    console.log('before set: dummy = ' + dummy)
    ob.n1 = ob.n2 = 10
    console.log('after set: dummy = ' + dummy)
   #+end_src

   +RESULTS:
   : effect fn è¢«æ‰§è¡Œ 1 æ¬¡
   : before set: dummy = 10
   : effect fn è¢«æ‰§è¡Œ 2 æ¬¡
   : after set: dummy = 20

2. ç»™åŒä¸€ä¸ªå±æ€§ç»‘å®šå¤šä¸ª effectsï¼Œå€¼å˜æ›´è§¦å‘å¤šä¸ª effect

   #+begin_src  js
    const { effect, reactive, targetMap } = require(process.env.PWD + '/../../static/js/vue/reactivity.global.js')

    let d1, d2
    const ob = reactive({ count: 0 })
    effect(() => (d1 = ob.count))
    effect(() => (d2 = ob.count))

    console.log('before set: d1 = ' + d1 + ', d2 = ' + d2)
    ob.count = 3
    console.log('after set: d1 = ' + d1 + ', d2 = ' + d2)
   #+end_src

   +RESULTS:
   : before set: d1 = 0, d2 = 0
   : after set: d1 = 3, d2 = 3
** æ”¯æŒå¯¹è±¡åµŒå¥—
:PROPERTIES:
:COLUMNS: %CUSTOM_ID[(Custom Id)]
:CUSTOM_ID: test-02
:END:

commit: [[https://github.com/gcclll/stb-vue-next/commit/b2143f9e35af77ee43792a6110ea70c4caf9a54f?branch=b2143f9e35af77ee43792a6110ea70c4caf9a54f&diff=split][feat: observe object recursively Â· gcclll/stb-vue-next@b2143f9]]

æµ‹è¯•ï¼š
* å®Œæ•´è„‘å›¾
:PROPERTIES:
:COLUMNS: %CUSTOM_ID[(Custom Id)]
:CUSTOM_ID: whole-mind-map
:END:

[[/img/vue3/reactivity/reactivity.svg]]

** collection proxy handlers è„‘å›¾
:PROPERTIES:
:COLUMNS: %CUSTOM_ID[(Custom Id)]
:CUSTOM_ID: while-collection
:END:

[[/img/vue3/reactivity/reactivity-collection-proxy.svg]]
