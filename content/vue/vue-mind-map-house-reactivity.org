ATE: <2020-11-09 11:45:36>
#+TAGS[]: vue, vue3, compiler-core, parser, compiler
#+CATEGORIES[]: vue
#+LANGUAGE: zh-cn
#+STARTUP: indent shrink

#+begin_export html
<link href="https://fonts.goo~gleapis.com/cs~s2?family=ZCOOL+XiaoWei&display=swap" rel="stylesheet">
<kbd>
<font color="blue" size="3" style="font-family: 'ZCOOL XiaoWei', serif;">
  诗号：六道同坠，魔劫万千，引渡如来。
</font>
</kbd><br><br>
<script src="/js/vue/reactivity.global.js"></script>
<script>
function _log(el, content) {
  $(el).children('.result').append('<p>' + content + '</p>')
}
</script>
#+end_export

[[/img/bdx/yiyeshu-001.jpg]]

@@html:<kbd>@@
*[[https://github.com/gcclll/stb-vue-next][stb-vue-next]] 完全拷贝于 [[https://github.com/vuejs/vue-next][vue-next]] ，主要目的学习及尝试应用于机顶盒环境。*
@@html:</kbd>@@

@@html:<kbd>@@ *本文依据 commit 进程进行记录* @@html:</kbd>@@

* init project
:PROPERTIES:
:COLUMNS: %CUSTOM_ID[(Custom Id)]
:CUSTOM_ID: init
:END:

初始化项目：[[https://github.com/gcclll/stb-vue-next/commit/cb3470d7c3f2944fd23e9155fc8a6afb7a51a732][feat: reactive-fn · gcclll/stb-vue-next@cb3470d]]

[[#while-mind-map][由于完整脑图会比较全而大所以放到文字最后去。。。]]

[[/img/vue3/reactivity/reactivity.svg][也可以点击该链接直接新窗口打开，效果更佳。]]
* [[https://github.com/gcclll/stb-vue-next/commit/cb3470d7c3f2944fd23e9155fc8a6afb7a51a732][4a6ac0e]] add: createReactiveObject
:PROPERTIES:
:COLUMNS: %CUSTOM_ID[(Custom Id)]
:CUSTOM_ID: fn cro
:END:

[[https://github.com/gcclll/stb-vue-next/commit/cb3470d7c3f2944fd23e9155fc8a6afb7a51a732][feat: reactive-fn · gcclll/stb-vue-next@cb3470d]]

[[/img/vue3/reactivity/reactivity-reactive.svg]]

仅增加函数声明:

#+begin_src typescript
export function reactive(target: object) {
  // 如果试图 observe 一个只读 proxy，返回只读版本
  if (target && (target as Target)[ReactiveFlags.IS_READONLY]) {
    return target
  }

  return createReactiveObject(
    target,
    false,
    mutableHandlers,
    {}
    // mutableCollectionHandlers
  )
}

function createReactiveObject(
  target: Target,
  isReadonly: boolean,
  baseHandlers: ProxyHandler<any>,
  collectionHandlers: ProxyHandler<any>
) {}
#+end_src

*mutableHandlers*: 普通对象类型的 proxy handlers

*mutableCollectionHandlers*: 集合类型的 proxy handlers，因为 ~Reflect~ 并没有对集
合类型做底层映射，所以需要特殊处理。

* [[https://github.com/gcclll/stb-vue-next/commit/443a0b5920efaf714de08b0975c17f1d652815e4][c0f0b7c]] feat: reactive(target)

[[https://github.com/gcclll/stb-vue-next/commit/443a0b5920efaf714de08b0975c17f1d652815e4][feat: createReactiveObject · gcclll/stb-vue-next@443a0b5]]

[[/img/vue3/reactivity/reactivity-create-reactive-object.svg]]

1. 重点： ~new Proxy(target, collection)~
2. 被代理类型必须是对象(引用类型)
3. target 本身已经是 proxy 了
4. target 代理有缓存不用重复创建
5. 必须是合法的类型(~Object|Array|[Weak]Map|[Weak]Set~)才能被代理
6. 记得缓存新创建的代理关系(~proxyMap~ 全局变量)

*** 用例一：普通对象

#+begin_src js
const { effect, reactive, targetMap, isReactive } = require(process.env.PWD + '/../../static/js/vue/reactivity.global.js')

const original = { foo: 1 }
const observed = reactive(original)

console.log('observed is not orignial,' + original !== observed)
console.log('observed is reactive, ' + isReactive(observed))
console.log('original is reactive, ' + isReactive(original))
console.log('observed.foo === 1, ' + observed.foo === 1)
console.log('`foo` in observed, ' + (`foo` in observed))
console.log(`Object.keys(observed) == ['foo'], ` + (Object.keys(observed).toString() === 'foo'))
#+end_src

+RESULTS:
: true
: observed is reactive, true
: original is reactive, false
: false
: `foo` in observed, true
: Object.keys(observed) == ['foo'], true
: undefined

[[https://github.com/gcclll/stb-vue-next/commit/1005ef30d5367fe306a4cfeb7e00c1cd56b1c691][b2143f9]] FIX: ~isReactive(observed): false~

[[https://github.com/gcclll/stb-vue-next/commit/1005ef30d5367fe306a4cfeb7e00c1cd56b1c691][fix: get object's __v_isReactive prop · gcclll/stb-vue-next@1005ef3]]

在 ~createGetter~ 中增加判断，如果来取的属性为 ~__v_isReactive~ 则直接返回
~!isReadonly~ 。
*** 用例二：原型

#+begin_src js
const { isReactive, effect, reactive, targetMap } = require(process.env.PWD + '/../../static/js/vue/reactivity.global.js')
const obj = {}
const reactiveObj = reactive(obj)
console.log('reactiveObj is reactive, ' + isReactive(reactiveObj))
const prototype = reactiveObj['__proto__']
const otherObj = { data: ['a'] }
console.log('otherObj is reactive, ' + isReactive(otherObj))
const reactiveOther = reactive(otherObj)
console.log('reactiveOther is reactive, ' + isReactive(reactiveOther))
console.log('reactiveOther.data[0] is `a`, ' + ( reactiveOther.data[0] === 'a' ))
console.log(`__proto__, ` + prototype)
#+end_src

+RESULTS:
: reactiveObj is reactive, true
: otherObj is reactive, false
: reactiveOther is reactive, true
: reactiveOther.data[0] is `a`, true
: __proto__, [object Object]
: undefined

FIX: [[https://github.com/gcclll/stb-vue-next/commit/1e2a3fef77b4a2b5f4dc3c497296b30b4ff06883][1005ef3]] 当取值时属性名为 ~__proto__~ 时：直接返回取值结果。

[[https://github.com/gcclll/stb-vue-next/commit/1e2a3fef77b4a2b5f4dc3c497296b30b4ff06883][feat: get key is symbol or __proto__ or __v_isRef · gcclll/stb-vue-next@1e2a3fe]]
*** 用例三：嵌套对象

#+begin_src js
const {isReactive, effect, reactive, targetMap } = require(process.env.PWD + '/../../static/js/vue/reactivity.global.js')
const original = {
  nested: {
    foo: 1
  },
  array: [{ bar: 2 }]
}

const observed = reactive(original)
console.log(`observed.nested is reactive ${isReactive(observed.nested)}`)
console.log(`observed.array is reactive ${isReactive(observed.array)}`)
console.log(`observed.array[0] is reactive ${isReactive(observed.array[0])}`)
#+end_src

+RESULTS:
: observed.nested is reactive true
: observed.array is reactive true
: observed.array[0] is reactive true

*** 用例四：代理后的对象操作也会体现在原对象上

#+begin_src js
const { isReactive, effect, reactive, targetMap } =
      require(process.env.PWD + '/../../static/js/vue/reactivity.global.js')

const or = { foo: 1 }
const ob = reactive(or)
ob.bar = 1
console.log(`ob.bar = ${ob.bar}, or.bar = ${or.bar}`)
delete ob.foo
console.log(`'foo' in ob: ${'foo' in ob}, 'foo' in or: ${'foo' in or}`)
#+end_src

+RESULTS:
: ob.bar = 1, or.bar = 1
: 'foo' in ob: false, 'foo' in or: false

结果删除后，依旧在，需要实现 delete proxy handler。
*** 用例五：原始对象上的操作也要能在代理后对象有所体现

#+begin_src js
const { isReactive, effect, reactive, targetMap } = require(process.env.PWD + '/../../static/js/vue/reactivity.global.js')

const original = { foo: 1 }
const observed = reactive(original)

original.bar = 1
console.log(`observed.bar = ${observed.bar}, original.bar = ${original.bar}`)
delete original.foo
console.log(`'foo' in original: ${'foo' in original}, 'foo' in observed: ${'foo' in observed}`)
#+end_src

+RESULTS:
: observed.bar = 1, original.bar = 1
: 'foo' in original: false, 'foo' in observed: false

*** 用例六：被设置的值如果是对象，该对象也会被 Reactive

#+begin_src js
const { isReactive, effect, reactive, targetMap } = require(process.env.PWD + '/../../static/js/vue/reactivity.global.js')

const observed = reactive({})
const raw = {}
observed.foo = raw // #0
console.log(`observed.foo === faw, ${observed.foo === raw}`) // #1
console.log(`observed.foo is reactive, ${isReactive(observed.foo)}`)
#+end_src

+RESULTS:
: observed.foo === faw, false
: observed.foo is reactive, true

访问 raw 之前(*#1* 之前)它还不是 reactive，因为递归 reactive 发生在 track() 中，即取值阶段。

如：控制台测试输出
#+begin_example
var ob = reactive({})
var raw = {}
ob.foo = raw
ob
    Proxy {foo: {…}}
        [[Handler]]: Object
            deleteProperty: ƒ deleteProperty(target, key)
            get: ƒ (target, key, receiver)
            set: ƒ (target, key, value, receiver)
        [[Target]]: Object
            foo: {} // 注意这里
        [[IsRevoked]]: false
#+end_example

进行一次取值：
#+begin_example
ob.foo
    Proxy {}
        [[Handler]]: Object
        [[Target]]: Object
        [[IsRevoked]]: false
#+end_example
*** 用例七：不该重复 proxy，返回第一个 proxy 结果

#+begin_src js
const { isReactive, effect, reactive, targetMap } = require(process.env.PWD + '/../../static/js/vue/reactivity.global.js')

const original = { foo: 1 } // #1
const observed1 = reactive(original) // #2
const observed2 = reactive(observed1) // #3
console.log(`observed2 === observed1, ${observed2 === observed1}`)
#+end_src

#+RESULTS:
: observed2 === observed1, true
: undefined

因为 ~reactive()~ 实现中组了检测，如果自身是个 proxy 就直接返回，所以 *#3* 中实
际直接将 ~observed1~ 返回了。
*** TODO 用例八：不应该用 proxies 污染原始对象？

#+begin_src js
const { isReactive, effect, reactive, targetMap } = require(process.env.PWD + '/../../static/js/vue/reactivity.global.js')

const original = { foo: 1 }
const original2 = { bar: 2 }
const observed = reactive(original)
const observed2 = reactive(original2)
observed.bar = observed2
console.log(`observed.bar === observed2, ${observed.bar === observed2}`)
console.log(`original.bar === original2, ${original.bar === original2}`)
#+end_src

+RESULTS:
: observed.bar === observed2, true
: original.bar === original2, false
* [[https://github.com/gcclll/stb-vue-next/commit/598e047407fe52183468037beb45328878431a55][443a0b5]] basic proxy get handler(createGetter)

[[https://github.com/gcclll/stb-vue-next/commit/598e047407fe52183468037beb45328878431a55][feat: reactive proxy get handler · gcclll/stb-vue-next@598e047]]

commit: 只实现对象的 ~get proxy handler~ ，对象属性被访问的时候会触发代理，比如下面
实例中，当访问 ~observed.count~ 时候会触发 ~console.log({ res }, "get")~ 执行。

最简单 proxy get handler 脑图：
[[/img/vue3/reactivity/reactivity-basehd-get-01.svg]]

1. 调用 ~Reflect.get(target, key, receiver)~ 执行原子操作
2. 返回执行结果


#+begin_src typescript
function createGetter(isReadonly = false, shallow = false) {
  // target: 被取值的对象，key: 取值的属性，receiver: this 的值
  return function get(target: Target, key: string | symbol, receiver: object) {
    const res = Reflect.get(target, key, receiver)

    // 是否只需要 reactive 一级属性(不递归 reactive)
    if (shallow) {
      return res
    }

    return res
  }
}
export const mutableHandlers: ProxyHandler<object> = {
  get
}
#+end_src

测试：
#+begin_src js
const { effect, reactive, targetMap } = require(process.env.PWD + '/../../static/js/vue/reactivity.global.js')

const target = { count: 0 }
const ob = reactive(target)
effect(() => ob.count) // ob.count 属性 收集 effect fn

console.log(targetMap.get(target))
#+end_src

+RESULTS: effect 会立即执行 fn， ~ob.count~ 取值触发 get proxy 收集 fn -> count => deps<Set>
#+begin_example
Map(1) {
  'count' => Set(1) {
    [Function: reactiveEffect] {
      id: 0,
      allowRecurse: false,
      _isEffect: true,
      active: true,
      raw: [Function (anonymous)],
      deps: [Array],
      options: {}
    }
  }
}
#+end_example
* [[https://github.com/gcclll/stb-vue-next/commit/3fc963486868ca3583b02852f07a5aa5969ac354][6c50273]] add track() and effect()

[[https://github.com/gcclll/stb-vue-next/commit/3fc963486868ca3583b02852f07a5aa5969ac354][feat: track+effect · gcclll/stb-vue-next@3fc9634]]

为了完成观察属性，通过属性的取值操作来收集依赖过程，这里同时实现了 ~track()~ 和
~effect()~ 函数。

** track(target, type, key) 监听取值收集依赖：

   [[/img/vue3/reactivity/reactivity-basehd-get-02-track.svg]]

** effect(fn, options)

[[/img/vue3/reactivity/reactivity-effect.svg]]

- *参数列表* ：

    fn - 被封装的函数，里面可对对象执行 get/set 操作。

- *主要功能* ：将 fn 封装成 ~ReactiveEffect~ 函数

    #+begin_src typescript
    export interface ReactiveEffect<T = any> {
        (): T // effect函数主题
        _isEffect: true // 标记自身是不是一个 ReactiveEffect 类型
        id: number // uid++ 而来，全局的一个相对唯一的 id
        active: boolean // 记录当前的 effect 是不是激活状态
        raw: () => T // 封装之前的那个 fn
        deps: Array<Dep> // fn 的被依赖者列表
        options: ReactiveEffectOptions // 额外选项，如：lazy
        allowRecurse: boolean // ???
    }
    #+end_src

- *解决问题* :

    1. fn 封装之后，执行 fn 过程中使用 try...finally ，防止 fn 执行异常导致
       effect 进程中断
    2. 结合 shouldTrack, activeEffect 和 track() 函数，有效的避免了在 fn 中执行
       obj.value++ 导致 effect 死循环问题，因为 try...finally 确保了只有 fn 函数
       完成之后才会进入 finally 恢复 effect 状态(~shouldTrack = true,
       activeEffect = last || null~)。


相关函数及变量列表
| name                                | type             | desc                                                                              |
|-------------------------------------+------------------+-----------------------------------------------------------------------------------|
| ~activeEffect~                      | /ReactiveEffect/ | 当前正在处理的 Effect，fn 还未执行完成，finally 还没结束                          |
| ~effectStack~                       | /Array, []/      | 缓存所有状态还没完成的 Effect                                                     |
| ~shouldTrack~                       | /boolean, true/  | track() 中用来检测当前 effect 是否结束，从而判定是否可以继续执行 track() 收集依赖 |
| ~trackStack~                        | /Array, []/      | 保存着所有 Effect 的 shouldTrack 值                                               |
| ~effect()~                          | /function/       | 封装 fn成 ReactiveEffect 结构                                                     |
| ~track(target, type, key)~          | /function/       | 收集依赖，并且响应式递归                                                          |
| ~trigger(...)~                      | /function/       | 当值更新时触发所有依赖更新                                                        |
| ~createReactiveEffect(fn, options)~ | /function/       | effect() 函数主题功能分离出来                                                     |
| ~cleanup(effect: ReactiveEffect)~   | /function/       | 清空所有 fn 的依赖 effect.deps[]                                                  |
| ~enableTracking()~                  | /function/       | 使能 Effect ，shouldTrack = true, 并将其加入 trackStack                           |
| ~resetTracking()~                   | /function/       | 重置 Effect, shouldTrack = 上一个 Effect 的 shouldTrack 值或 true                 |

#+begin_src typescript
export function effect<T = any>(
  fn: () => T,
  options: ReactiveEffectOptions = EMPTY_OBJ
): ReactiveEffect<T> {
  if (isEffect(fn)) {
    fn = fn.raw // 取出原始的函数，封装之前的
  }

  // 封装成 ReactiveEffect
  const effect = createReactiveEffect(fn, options)

  if (!options.lazy) {
    // 如果并没指定 lazy: true 选项，则立即执行 effect 收集依赖
    // 因为 effect 一般都会有取值操作，此时会触发 proxy get handler
    // 然后执行 track() 结合当前的 activeEffect 即 effect() 执行时候的这个
    // effect，这样取值操作就和当前取值作用域下的依赖函数建立的依赖关系
    effect()
  }
  return effect
}

let uid = 0

function createReactiveEffect<T = any>(
  fn: () => T,
  options: ReactiveEffectOptions
): ReactiveEffect<T> {
  // 将 fn 执行封装成  ReactiveEffect 类型的函数
  const effect = function reactiveEffect(): unknown {
    if (!effect.active) {
      // 非激活状态，可能是手动调用了 stop
      // 那么执行的时候就需要考虑调用 stop 者是否提供了手动调度该 effect
      // 的函数 scheduler ? 也就是说你停止你可以重新启动
      return options.scheduler ? undefined : fn()
    }

    if (!effectStack.includes(effect)) {
      // 1. cleanup, 保持纯净
      cleanup(effect)
      try {
        // 2. 使其 tracking 状态有效，track() 中有用
        enableTracking() // track() 可以执行收集操作
        effectStack.push(effect) // effect 入栈
        // 3. 保存为当前的 activeEffect, track() 中有用
        activeEffect = effect // 记录当前的 effect -> track/trigger
        // 4. 执行 fn 并返回结果
        return fn() // 返回执行结果
      } finally {
        // 始终都会执行，避免出现异常将 effect 进程卡死
        // 5. 如果执行异常，丢弃当前的 effect ，并将状态重置为上一个 effect
        //   由一个 effect 栈来维护。

        effectStack.pop()
        resetTracking()
        activeEffect = effectStack[effectStack.length - 1]
      }
    }
  } as ReactiveEffect

  effect.id = uid++
  effect.allowRecurse = !!options.allowRecurse
  effect._isEffect = true
  effect.active = true
  effect.raw = fn // 这里保存原始函数引用
  effect.deps = []
  effect.options = options

  return effect
}

#+end_src

依赖和属性变更发生联系的桥梁模块。

1. ~effect(fn, options)~ 封装执行 fn，触发取值操作 ->
2. ~track(target, type, key)~ 收集对象及属性所有依赖 ->
3. fn 中设值操作触发 ~trigger(...)~ 执行所有 deps，更新 DOM。
* [[https://github.com/gcclll/stb-vue-next/commit/20afde9970282c144b978b005767bd2c710d54ab][736de7c]] add trigger() proxy set handler

[[https://github.com/gcclll/stb-vue-next/commit/20afde9970282c144b978b005767bd2c710d54ab][feat: proxy set and trigger operation · gcclll/stb-vue-next@20afde9]]

** proxy set handler(createSetter)

#+begin_src typescript

function createSetter(shallow = false) {
  return function set(
    target: object,
    key: string | symbol,
    value: unknown,
    receiver: object
  ): boolean {
    const oldValue = (target as any)[key]
    // TODO shallow or not, or ref ?
    //

    const hadKey =
      isArray(target) && isIntegerKey(key)
        ? Number(key) < target.length
        : hasOwn(target, key)

    const result = Reflect.set(target, key, value, receiver)

    if (target === toRaw(receiver)) {
      if (!hadKey) {
        // TODO ADD
      } else if (hasChanged(value, oldValue)) {
        trigger(target, TriggerOpTypes.SET, key, value, oldValue)
      }
    }

    return result
}
#+end_src

** trigger()

#+begin_src typescript
export function trigger(
  target: object,
  type: TriggerOpTypes,
  key?: unknown,
  newValue?: unknown,
  oldValue?: unknown,
  oldTarget?: Map<unknown, unknown> | Set<unknown>
) {
  const depsMap = targetMap.get(target)
  if (!depsMap) {
    return
  }

  const effects = new Set<ReactiveEffect>()
  const add = (effectsToAdd: Set<ReactiveEffect> | undefined) => {
    if (effectsToAdd) {
      effectsToAdd.forEach(effect => {
        if (effect !== activeEffect || effect.allowRecurse) {
          effects.add(effect)
        }
      })
    }
  }

  if (type === TriggerOpTypes.CLEAR) {
    // TODO collection clear operation
  } else if (key === 'length' && isArray(target)) {
    // TODO array change operation
  } else {
    // SET | ADD | DELETE operation
    if (key !== void 0) {
      add(depsMap.get(key))
    }

    // TODO 迭代器 key，for...of, 使用迭代器是对数据的监听变化
  }

  const run = (effect: ReactiveEffect) => {
    if (__DEV__ && effect.options.onTrigger) {
      effect.options.onTrigger({
        effect,
        target,
        key,
        type,
        newValue,
        oldValue,
        oldTarget
      })
    }

    if (effect.options.scheduler) {
      effect.options.scheduler(effect)
    } else {
      effect()
    }
  }

  effects.forEach(run)
}
#+end_src
* [[https://github.com/gcclll/stb-vue-next/commit/b2143f9e35af77ee43792a6110ea70c4caf9a54f][b5f97b4]] observe object recursively

[[https://github.com/gcclll/stb-vue-next/commit/b2143f9e35af77ee43792a6110ea70c4caf9a54f][feat: observe object recursively · gcclll/stb-vue-next@b2143f9]]

针对嵌套对象进行递归 Reactive 。

[[/img/vue3/reactivity/reactivity-basehd-get-03-track-recursively.svg]]
* effect -> track -> trigger 关系图
:PROPERTIES:
:COLUMNS: %CUSTOM_ID[(Custom Id)]
:CUSTOM_ID: effect-track-trigger
:END:

到此 effect + track + trigger 完成了最简单的响应式代码。

[[/img/vue3/reactivity/reactivity-effect-track-trigger.svg]]

1. effect 封装注册函数
2. track 取值触发收集依赖函数
3. trigger 设值触发所有依赖函数执行
* [[https://github.com/gcclll/stb-vue-next/commit/05b98c571560d2c1806d29cdda7b500b4b2bdeac][05b98c5]] add delete(*deleteProperty*) proxy handler
:PROPERTIES:
:COLUMNS: %CUSTOM_ID[(Custom Id)]
:CUSTOM_ID: c-delete
:END:

[[https://github.com/gcclll/stb-vue-next/commit/05b98c571560d2c1806d29cdda7b500b4b2bdeac][feat: delete proxy handler · gcclll/stb-vue-next@05b98c5]]

#+begin_src typescript
function deleteProperty(target: object, key: string | symbol): boolean {
  const hadKey = hasOwn(target, key)
  const oldValue = (target as any)[key]
  const result = Reflect.deleteProperty(target, key)
  if (result && hadKey) {
    // 删除成功，触发 DELETE
    trigger(target, TriggerOpTypes.DELETE, key, undefined, oldValue)
  }
  return result
}

export const mutableHandlers: ProxyHandler<object> = {
  get,	  get,
  set	  set,
  deleteProperty
}
#+end_src

删除成功调用 ~trigger()~ 触发 *DELETE* 。
* [[https://github.com/gcclll/stb-vue-next/commit/ab69fe9eecb274f836bf19163636bd8f464b84d1][05b98c5]] add has, ownKeys proxy handlers

[[https://github.com/gcclll/stb-vue-next/commit/ab69fe9eecb274f836bf19163636bd8f464b84d1][feat: has + ownKeys proxy handler · gcclll/stb-vue-next@ab69fe9]]

增加 has, ownKeys proxy handlers.

#+begin_src typescript
function has(target: object, key: string | symbol): boolean {
  const result = Reflect.has(target, key)
  if (!isSymbol(key) || !builtInSymbols.has(key)) {
    track(target, TrackOpTypes.HAS, key)
  }
  return result
}

function ownKeys(target: object): (string | num | symbol)[] {
  track(target, TrackOpTypes.ITERATE, isArray(target) ? 'length' : ITERATE_KEY)
  return Reflect.ownKeys(target)
}
#+end_src

测试：

#+begin_src js
const { isReactive, effect, reactive, targetMap } = require(process.env.PWD + '/../../static/js/vue/reactivity.global.js')

const obj = reactive({ n: 0 })
let dummy = false
const runner = effect(() => (dummy = 'n' in obj), { lazy: true })

console.log(`before run effect, dummy = ${dummy}`)
runner()
console.log(`after run effect, dummy = ${dummy}`)
#+end_src

+RESULTS:
: before run effect, dummy = false
: after run effect, dummy = true
* TODO [[https://github.com/gcclll/stb-vue-next/commit/9aeb678befc3826b2ce8976b62c1172b4800df27][9aeb678]] add array support

[[https://github.com/gcclll/stb-vue-next/commit/9aeb678befc3826b2ce8976b62c1172b4800df27][feat: array support · gcclll/stb-vue-next@9aeb678]]

修改点：
#+begin_src typescript
// 数组内置方法处理
const arrayInstrumentations: Record<string, Function> = {}
;(['includes', 'indexOf', 'lastIndexOf'] as const).forEach(key => {
  const method = Array.prototype[key] as any
  arrayInstrumentations[key] = function(this: unknown[], ...args: unknown[]) {
    const arr = toRaw(this)
    for (let i = 0, l = this.length; i < l; i++) {
      track(arr, TrackOpTypes.GET, i + '')
    }

    const res = method.apply(arr, args)
    if (res === -1 || res === false) {
      return method.apply(arr, args.map(toRaw))
    } else {
      return res
    }
  }
})
;(['push', 'pop', 'shift', 'unshift', 'splice'] as const).forEach(key => {
  const method = Array.prototype[key] as any
  arrayInstrumentations[key] = function(this: unknown[], ...args: unknown[]) {
    pauseTracking()
    const res = method.apply(this, args)
    resetTracking()
    return res
  }
})

// createGetter
function createGetter(isReadonly = false, shallow = false) {
  // ...
  // 4. target is array
  const targetIsArray = isArray(target)
  if (targetIsArray && hasOwn(arrayInstrumentations, key)) {
    return Reflect.get(arrayInstrumentations, key, receiver)
  }
  // ...
}
#+end_src

1. 索引操作(~includes, lastIndexOf, indexOf~)处理

   确保索引取值的时候，能使用 track() 正确收集对应索引的依赖列表。

2. 可改变原数组长度操作(~push, pop, shift, unshift, splice~)

   因为这些函数内部实现都需要访问及改变原数组的长度，因此这里需要做一层保护，它
   们执行之前 ~shouldTrack = false~ ，执行完成之后 ~shouldTrack = true~ ，避免
   ~track()~ 死循环。


下面均为 vue-next 源码中用例分析。
- [X] T1: 读写操作

    #+begin_src js
    const { isReactive, effect, reactive, targetMap } = require(process.env.PWD + '/../../static/js/vue/reactivity.global.js')

    const original = [{ foo: 1 }, { bar: 2 }]
    const observed = reactive(original)
    console.log(`#01 original !== observed, ${original !== observed}`)
    console.log(`#02 original is reactive, ${isReactive(original)}`)
    console.log(`#03 observed is reactive, ${isReactive(observed)}`)
    console.log(`#04 observed[0] is reactive, ${isReactive(observed[0])}`)

    const clone = observed.slice()
    console.log(`#05 clone[0] is reactive, ${isReactive(clone[0])}`)
    console.log(`#06 clone[0] !== original[0], ${clone[0] !== original[0]}`)
    console.log(`#07 clone[0] === observed[0], ${clone[0] === observed[0]}`)

    const value = { baz: 3 }
    const reactiveValue = reactive(value)
    observed[0] = value
    console.log(`#08 observed[0] === reactiveValue, ${observed[0] === reactiveValue}`)
    console.log(`#09 original[0] === value, ${original[0] === value}`)
    delete observed[0]
    console.log(`#10 observed[0] === undefined, ${observed[0] === undefined}`)
    console.log(`#11 original[0] === undefined, ${original[0] === undefined}`)
    observed.push(value)
    console.log(`#12 observed[2] === reactiveValue, ${observed[2] === reactiveValue}`)
    console.log(`#13 original[2] === value, ${original[2] === value}`)
    #+end_src

    +RESULTS:
    #+begin_example
    #01 original !== observed, true
    #02 original is reactive, false
    #03 observed is reactive, true
    #04 observed[0] is reactive, true
    #05 clone[0] is reactive, true
    #06 clone[0] !== original[0], true
    #07 clone[0] === observed[0], true
    #08 observed[0] === reactiveValue, true
    #09 original[0] === value, true
    #10 observed[0] === undefined, true
    #11 original[0] === undefined, true
    #12 observed[2] === reactiveValue, true
    #13 original[2] === value, true
    #+end_example

    分析：
  - *#01* 因为 Proxy [[https://tc39.es/ecma262/#sec-proxycreate][内部实现]]实际会创建新对象
  - *#02* 读取 ~__v_isReactive~ 在 ~createGetter()~ 里面会直接返回 ~!isReadonly~
  - *#03* 同上
  - *#04* 取值的时候返回结果之前会检测当前是不是对象如果是会执行递归 reactive
  - *#05* slice [[/post/javascript-apis/#api-array-slice][实现过程]]并非深拷贝
  - *#06* 和 ~observed[0] !== original[0]~ 一个原因
  - *#07* [[/post/javascript-apis/#api-array-slice][浅拷贝问题]]
  - *#08* 先 ~observed[0]~ 对 value 取值操作，此时 Reactive value 对象时，发现该对
  象已经有映射了(proxyMap 中已存在 value -> reactiveValue 关系。)
  - *#09* proxy 的改变也会体现在 original 对象上。

    #+begin_src js
    const target = {  }
    const ob = new Proxy(target, {})
    ob.value = { test: 1 }
    console.log(target)
    #+end_src

    +RESULTS:
    : { value: { test: 1 } }
  - *#10* 同上
  - *#11* 同上
  - *#12* 同 *#08* ~proxyMap~ 中有缓存了
  - *#13* 同上
- [X] T2：索引方法(includes, lastIndexOf, indexOf)

    #+begin_src js
    const { isReactive, effect, reactive, targetMap } = require(process.env.PWD + '/../../static/js/vue/reactivity.global.js')

    const raw = {}
    const arr = reactive([{}, {}])
    arr.push(raw)
    console.log(`arr.indexOf(raw), ${arr.indexOf(raw)}`)
    console.log(`arr.indexOf(raw, 3), ${arr.indexOf(raw, 3)}`)
    console.log(`arr.includes(raw), ${arr.includes(raw)}`)
    console.log(`arr.includes(raw, 3), ${arr.includes(raw, 3)}`)
    console.log(`arr.lastIndexOf(raw), ${arr.lastIndexOf(raw)}`)
    console.log(`arr.lastIndexOf(raw, 1), ${arr.lastIndexOf(raw, 1)}`)
    #+end_src

    +RESULTS:
    : arr.indexOf(raw), 2
    : arr.indexOf(raw, 3), -1
    : arr.includes(raw), true
    : arr.includes(raw, 3), false
    : arr.lastIndexOf(raw), 2
    : arr.lastIndexOf(raw, 1), -1
- [X] T3：数组元素本身已经是 Proxy

  #+begin_src js
  const { isReactive, effect, reactive, targetMap } = require(process.env.PWD + '/../../static/js/vue/reactivity.global.js')
  const raw = []
  const obj = reactive({})
  raw.push(obj)
  const arr = reactive(raw)
  console.log(`arr.includes(obj), ${arr.includes(obj)}`)
  #+end_src

  +RESULTS: 这个应该很好理解，对象已经是 proxy 之后不会再继续代理，而是返回
  proxyMap 中缓存过的代理结果。
  : arr.includes(obj), true
- [-] T4: [[/post/javascript-apis/#api-array-reverse][reverse]] 方法也应该是 reactive 的

  *TODO*: reverse 之后找不到(~indexOf~)原始对象了？

  根据 [[/post/javascript-apis/#api-array-reverse][reverse()]] 的实现原理，本质上是元素之间的替换操作，因此并不会改变数组或元
  素本身是 proxy 性质，且属于索引赋值操作，因此会触发索引的 reactive 相关操作。

  #+begin_src js
  const { isReactive, effect, reactive, targetMap, toRaw } = require(process.env.PWD + '/../../static/js/vue/reactivity.global.js')

  const obj = { a: 1 }
  const arr = reactive([obj, { b: 2 }])
  let index = -1
  console.log(`#1 obj === arr[0], ${obj === toRaw(arr[0])}`)
  effect(() => (index = arr.indexOf(obj))) // index = 0
  console.log(`#2 before reverse, index = ${index}`)
  arr.reverse() // #3
  console.log(`#4 after reverse, index = ${index}`)
  console.log(`#5 obj === arr[1], ${obj === toRaw(arr[1])}`)
  #+end_src

  #+RESULTS:
  : #1 obj === arr[0], true
  : #2 before reverse, index = 0
  : #4 after reverse, index = -1
  : #5 obj === arr[1], true
  : undefined

  +RESULTS: 失败
  : before reverse, index = 0
  : after reverse, index = -1
  : [ { b: 2 }, { a: 1 } ]
- [X] T5: 使用 [[/post/javascript-apis/#api-op-delete][delete]] 删除数组元素时不应该触发 ~length~ 依赖

  #+begin_src js
  const { isReactive, effect, reactive, targetMap } = require(process.env.PWD + '/../../static/js/vue/reactivity.global.js')
  const arr = reactive([1,2,3])
  let dummy = 0
  effect(() => {
    dummy = arr.length + 1
  })

  console.log(`before delete, dummy = ${dummy}, arr = ${arr}, len = ${arr.length}`)
  delete arr[1]
  console.log(`after delete, dummy = ${dummy}, arr = ${arr}, len = ${arr.length}`)
  #+end_src

  +RESULTS: 删除操作并不会改变数组长度
  : before delete, dummy = 4, arr = 1,2,3, len = 3
  : after delete, dummy = 4, arr = 1,,3, len = 3
  : undefined

  #+begin_quote
  PS: 赋值已有的下标元素值、添加非正整数类型的属性到数组上都不会触发 ~length~ 依
  赖，本质上并没有改变数组长度。
  #+end_quote
- [X] T6: 在 effect fn 中使用 ~for ... in~ 迭代语句应该 /track length/

  #+begin_src js
  const { isReactive, effect, reactive, targetMap } = require(process.env.PWD + '/../../static/js/vue/reactivity.global.js')

  const nums = [1]
  const array = reactive(nums)
  let len = ''
  effect(() => {
    len = ''
    for (const key in array) {
      len += key
    }
  })

  console.log(`before push, len = ${len}`)
  array.push(1)
  console.log(`after push, len = ${len}`)
  #+end_src

  #+RESULTS:
  : before push, len = 0
  : after push, len = 01
  : undefined

  +RESULTS: 输出显示，length 依赖已经 track 到了，只是 Length 变化并没有触发
  #+begin_example
  Map(1) {
    'length' => Set(1) {
      [Function: reactiveEffect] {
        id: 0,
        allowRecurse: false,
        _isEffect: true,
        active: true,
        raw: [Function (anonymous)],
        deps: [Array],
        options: {}
      }
    }
  }
  before push, len = 0
  after push, len = 0
  #+end_example

  #+begin_quote
    FIX: [[https://github.com/gcclll/stb-vue-next/commit/21b4881a906d5e6f2def3a7e486934af6009e93a][feat(add): array add element support · gcclll/stb-vue-next@21b4881]]
  #+end_quote
* [[https://github.com/gcclll/stb-vue-next/commit/21b4881a906d5e6f2def3a7e486934af6009e93a][21b4881]] array add element support

[[https://github.com/gcclll/stb-vue-next/commit/21b4881a906d5e6f2def3a7e486934af6009e93a][feat(add): array add element support · gcclll/stb-vue-next@21b4881]]

增加添加数组元素支持。

#+begin_src typescript

#+end_src
1. ~createGetter -> get~ proxy handler 中增加属性添加 trigger 操作

   ~trigger(target, TriggerOpTypes.ADD, key, value)~

2. effect.ts -> ~trigger()~ 中增加数组长度变更依赖收集和 ~ADD~ 操作依赖收集

   [[http://qiniu.ii6g.com/img/20201118105046.png]]
* [[https://github.com/gcclll/stb-vue-next/commit/e85dfc630c3374aa6452891784cc58ffdc5895c6][e85dfc6]] add shallow reactive

[[https://github.com/gcclll/stb-vue-next/commit/e85dfc630c3374aa6452891784cc58ffdc5895c6][feat(add): shallowReactive api · gcclll/stb-vue-next@e85dfc6]]

正常 track 过程中会检测嵌套内的是不是对象，如果是对象会进行递归 reactive 让内部嵌套的对象也 reactive 化。

shallow reactive 意思是当对象存在嵌套的时候，不进行递归 reactive 。

这个通过在 track() 函数中做一次拦截处理。


测试：
#+begin_src js
const {
  isReactive,
  effect,
  reactive,
  targetMap,
  shallowReactive
} = require(process.env.PWD + '/../../static/js/vue/reactivity.global.js')

const props = shallowReactive({ n: { foo: 1} })

console.log(`props.n is reactive, ${isReactive(props.n)}`)

const props2 = shallowReactive({ n: reactive({ foo: 1 }) })
props2.n = reactive({ foo: 2 })
console.log(`props2.n is reactive, ${isReactive(props2.n)}`)

// array test
const shallowArray = shallowReactive([])
const a = {}
let size
effect(() => {
  size = shallowArray.length
})

console.log(`>> array`)
console.log(`before push a, size = ${size}`)
shallowArray.push(a)
console.log(`after push a, size = ${size}`)
shallowArray.pop()
console.log(`after pop, size = ${size}`)

console.log(`>> 迭代时不应观察`)
shallowArray.push(a)
const spreadA = [...shallowArray][0]
// 迭代也有取值过程，shallow = true 不会递归 reactive
console.log(`spreadA is reactive, ${isReactive(spreadA)}`)

console.log(`>> onTrack`)
const onTrackFn = () => console.log('on tracking...')
let b
effect(() => {
  b = Array.from(shallowArray)
}, {
  onTrack: onTrackFn
})
#+end_src

+RESULTS: [[/post/javascript-apis/#api-array-from][Array.from]] 本质是迭代器操作，所以会触发迭代器 tracking 。
#+begin_example
props.n is reactive, false
props2.n is reactive, true
>> array
before push a, size = 0
after push a, size = 1
after pop, size = 0
>> 迭代时不应观察
spreadA is reactive, false
>> onTrack
on tracking...
on tracking...
undefined
#+end_example
* [[https://github.com/gcclll/stb-vue-next/commit/66e7903568bf7d5bce0faca2f85e80c36399bc66][66e7903]] add readonly reactive

[[https://github.com/gcclll/stb-vue-next/commit/66e7903568bf7d5bce0faca2f85e80c36399bc66][feat(add): readonly reactive · gcclll/stb-vue-next@66e7903]]

*** 测试(for ~Object~)：
#+begin_src js
const {
  isReactive,
  effect,
  reactive,
  targetMap,
  shallowReactive,
  readonly,
  isProxy,
  isReadonly
} = require(process.env.PWD + '/../../static/js/vue/reactivity.global.js')

console.log(`>>> should make nested values readonly`)
const original = { foo: 1, bar: { baz: 2 } }
const wrapped = readonly(original)
console.log(`wrapped !== original, ${wrapped !== original}`)
console.log(`wrapped is proxy, ${isProxy(wrapped)}`)
console.log(`wrapped is reactive, ${isReactive(wrapped)}`)
console.log(`wrapped is readonly, ${isReadonly(wrapped)}`)
console.log(`original is reactive, ${isReactive(original)}`)
console.log(`original is readonly, ${isReadonly(original)}`)
console.log(`wrapped.bar is reactive, ${isReactive(wrapped.bar)}`)
console.log(`wrapped.bar is readonly, ${isReadonly(wrapped.bar)}`)
console.log(`original.bar is reactive, ${isReactive(original.bar)}`)
console.log(`original.bar is readonly, ${isReadonly(original.bar)}`)
console.log(`>> get`)
console.log(`wrapped.foo = ${wrapped.foo}`)
console.log(`>> has`)
console.log(`'foo' in wrapped, ${'foo' in wrapped}`)
console.log(`>> ownKeys`)
console.log(`Object.keys(wrapped), [${Object.keys(wrapped)}]`)

console.log(`>> set or delete, should fail`)
const qux = Symbol('qux')
const original2 = {
  foo: 1,
  bar: {
    baz: 2
  },
  [qux]: 3
}

const wrapped2 = readonly(original2)
wrapped2.foo = 2 // fail
console.log(`after 'wrapped2.foo = 2',  wrapped2.foo = ${wrapped2.foo}`)
wrapped2.bar.baz = 3
console.log(`after 'wrapped2.bar.baz = 3', wrapped2.bar.baz = ${wrapped2.bar.baz}`)
wrapped2[qux] = 4
console.log(`after 'wrapped2[qux] = 4',  wrapped2[qux] = ${wrapped2[qux]}`)

delete wrapped2.foo
console.log(`after 'delete wrapped2.foo', wrapped2.foo = ${wrapped2.foo}`)
delete wrapped2.bar.baz
console.log(`after 'delete wrapped2.bar.baz', wrapped2.bar.baz = ${wrapped2.bar.baz}`)
delete wrapped2[qux]
console.log(`after 'delete wrapped2[qux]', wrapped2[qux] = ${wrapped2[qux]}`)
#+end_src

+RESULTS: readonly 会递归嵌套对象，所以它内部的对象都会是 readonly。
#+begin_example
>>> should make nested values readonly
wrapped !== original, true
wrapped is proxy, true
wrapped is reactive, false
wrapped is readonly, true
original is reactive, false
original is readonly, false
wrapped.bar is reactive, false
wrapped.bar is readonly, true
original.bar is reactive, false
original.bar is readonly, false
>> get
wrapped.foo = 1
>> has
'foo' in wrapped, true
>> ownKeys
Object.keys(wrapped), [foo,bar]
>> set or delete, should fail
after 'wrapped2.foo = 2',  wrapped2.foo = 1
after 'wrapped2.bar.baz = 3', wrapped2.bar.baz = 2
after 'wrapped2[qux] = 4',  wrapped2[qux] = 3
after 'delete wrapped2.foo', wrapped2.foo = 1
after 'delete wrapped2.bar.baz', wrapped2.bar.baz = 2
after 'delete wrapped2[qux]', wrapped2[qux] = 3
#+end_example

*** 测试(for ~Array~):
#+begin_src js
const {
  isReactive,
  effect,
  readonly,
  isReadonly,
  reactive,
  targetMap,
  isProxy,
  shallowReactive
} = require(process.env.PWD + '/../../static/js/vue/reactivity.global.js')

console.log(`>>> should make nested values readonly`)
const original = [{ foo: 1 }]
const wrapped = readonly(original)
console.log(`wrapped !== original`)
console.log(`wrapped is proxy, ${isProxy(wrapped)}`)
console.log(`wrapped is reactive, ${isReactive(wrapped)}`)
console.log(`wrapped is readonly, ${isReadonly(wrapped)}`)
console.log(`original is reactive, ${isReactive(original)}`)
console.log(`original is readonly, ${isReadonly(original)}`)
console.log(`wrapped[0] is reactive, ${isReactive(wrapped[0])}`)
console.log(`wrapped[0] is readonly, ${isReadonly(wrapped[0])}`)
console.log(`original[0] is reactive, ${isReactive(original[0])}`)
console.log(`original[0] is readonly, ${isReadonly(original[0])}`)
console.log(`> get`)
console.log(`wrapped[0].foo = ${wrapped[0].foo}`)
console.log(`> has`)
console.log(`0 in wrapped, ${0 in wrapped}`)
console.log(`> ownKeys`)
console.log(`Object.keys(wrapped) = [${Object.keys(wrapped)}]`)

const wrapped2 = readonly([{ foo: 1 }])
wrapped2[0] = 1
console.log(`after 'wrapped2[0] = 1', wrapped2[0] = ${wrapped2[0]}`)
wrapped2[0].foo = 2
console.log(`after 'wrapped2[0].foo = 2', wrapped2[0].foo = ${wrapped2[0].foo}`)
wrapped2.length = 0
console.log(`after 'wrapped2.length = 0', wrapped2.length = ${wrapped.length}`)
console.log(`after 'wrapped2.length = 0', wrapped2[0].foo = ${wrapped2[0].foo}`)
wrapped2.push(2)
console.log(`after 'wrapped2.push(2)', wrapped2.length = ${wrapped2.length}`)
#+end_src

+RESULTS:
#+begin_example
>>> should make nested values readonly
wrapped !== original
wrapped is proxy, true
wrapped is reactive, false
wrapped is readonly, true
original is reactive, false
original is readonly, false
wrapped[0] is reactive, false
wrapped[0] is readonly, true
original[0] is reactive, false
original[0] is readonly, false
> get
wrapped[0].foo = 1
> has
0 in wrapped, true
> ownKeys
Object.keys(wrapped) = [0]
after 'wrapped2[0] = 1', wrapped2[0] = [object Object]
after 'wrapped2[0].foo = 2', wrapped2[0].foo = 1
after 'wrapped2.length = 0', wrapped2.length = 1
after 'wrapped2.length = 0', wrapped2[0].foo = 1
after 'wrapped2.push(2)', wrapped2.length = 1
undefined
#+end_example
*** 测试(reactive, readonly 互撩)

#+begin_src js
const {
  isReactive,
  effect,
  reactive,
  readonly,
  isReadonly,
  targetMap,
  toRaw,
  shallowReactive
} = require(process.env.PWD + '/../../static/js/vue/reactivity.global.js')

const a = readonly({})
const b = reactive(a)
console.log(`*#1* isReadonly(b), ${isReadonly(b)}`)
console.log(`*#2* toRaw(a) === toRaw(b), ${toRaw(a) === toRaw(b)}`)
console.log(`*#3* a === b, ${ a === b }`)
#+end_src

+RESULTS:
: *#1* isReadonly(b), true
: *#2* toRaw(a) === toRaw(b), true
: *#3* a === b, true
: undefined

1. *#1* b is readonly: ~createReactive~ 中的处理

   #+begin_src typescript
   if (target[ReactiveFlags.Raw] && !(isReadonly && target[ReactiveFlags.IS_REACTIVE])) {
     return target
   }
   #+end_src

   上面的处理针对 ~b = reactive(a)~ 有：

   a 满足 target[ReactiveFlags.Raw] 因为它是 readonly 的.

   isReadonly = false

   target[ReactiveFlags.IS_REACTIVE] 不满足

   因此上面的判断满足 ~target[ReactiveFlags.RAW] &&
   !target[ReactiveFlags.IS_REACTIVE]~ 直接返回 target 。

2. *#2* ~toRaw(a) === toRaw(b)~ 这个结果为 true，因为 *#1* 中的原因，直接返回了 target，
   所以 b 实际上就是 a(如结果 *#3*)
* [[https://github.com/gcclll/stb-vue-next/commit/aaaf911eb88c75935970e51f843a88f6a3a3c6d6][aaaf911]] add shallow readonly reactive

[[https://github.com/gcclll/stb-vue-next/commit/aaaf911eb88c75935970e51f843a88f6a3a3c6d6][feat(add): shallow readonly reactive · gcclll/stb-vue-next@aaaf911]]

[[http://qiniu.ii6g.com/img/20201119153149.png]]

测试:

#+begin_src js
const {
  isReactive,
  effect,
  reactive,
  targetMap,
  shallowReactive,
  shallowReadonly
} = require(process.env.PWD + '/../../static/js/vue/reactivity.global.js')

// 嵌套对象不应该 reactive
console.log(`>>> should not make non-reactive properties reactive`)
let props = shallowReadonly({ n: {foo: 1} })
console.log(`isReactive(props.n), ${isReactive(props.n)}`)

// 根属性应该是 readonly
console.log(`>>> should make root level properties readonly`)
props = shallowReadonly({n : 1})
props.n = 2
console.log(`after 'props.n = 2', props.n = ${props.n}`)
// 嵌套的属性不应该是 readonly ，因为是 shallow
console.log(`>>> should NOT make nested properties readonly`)
props = shallowReadonly({ n: { foo: 1 } })
props.n.foo = 2
console.log(`after 'props.n.foo = 2', props.n.foo = ${props.n.foo}`)
#+end_src

+RESULTS:
: >>> should not make non-reactive properties reactive
: isReactive(props.n), false
: >>> should make root level properties readonly
: after 'props.n = 2', props.n = 1
: >>> should NOT make nested properties readonly
: after 'props.n.foo = 2', props.n.foo = 2
: undefined

这里的结果不难理解

 1. shallow 不会递归 reactive
 2. readonly 让属性只读，但是由于是 shallow 所以只有对象根属性才是只读
* [[https://github.com/gcclll/stb-vue-next/commit/f1e5b3afb88d41d065f1c797f5db66ac7c65339f][f1e5b3a]] add effect stop

[[https://github.com/gcclll/stb-vue-next/commit/f1e5b3afb88d41d065f1c797f5db66ac7c65339f][feat(add): effect stop · gcclll/stb-vue-next@f1e5b3a]]

[[http://qiniu.ii6g.com/img/20201119162119.png]]

stop() 函数操作：
1. 清空所有 effect 上的 deps，同时将当前的 effect 从所有依赖它的 dep 中删除

   ~effect.deps[i].delete(effect)~ , 这一步是将 ~targetMap > depsMap > deps~ 中
   的 effect 删除。

   ~effect.deps.length = 0~
2. 将 effect.active 置为 false


执行 ~stop()~ 之后，只能手动调用 ~runner()~ 来触发 effect fn(前提是没有提供
~options.scheduler~ ，否则永远不会被执行) 。

被 stopped 的 effect 可以当做另一个正常的 effect 的 fn。
* [[https://github.com/gcclll/stb-vue-next/commit/521f755fd403d5f0431bcafd1737f1d988ce0825][521f755]] add collection handlers

[[https://github.com/gcclll/stb-vue-next/commit/521f755fd403d5f0431bcafd1737f1d988ce0825][feat(add): mutable collection handlers · gcclll/stb-vue-next@521f755]]

[[#whole-collection][collection proxy handlers 脑图链接]]

因为 Reflect 没有集合操作的对应接口，所以针对集合类型需要通过 ~get proxy~ 来中转
做特殊处理。

#+begin_src typescript
function createInstrumentationGetter(isReadonly: boolean, shallow: boolean) {
  // TODO
}
export const mutableCollectionHandlers: ProxyHandler<CollectionTypes> = {
  // get: createInstrumentationGetter(false, false)
}
#+end_src

添加集合类型的 handlers。
* [[https://github.com/gcclll/stb-vue-next/commit/a5e8e062658d458081ce1bb499b8041f6175689e][a5e8e06]] add collection get proxy handler

[[https://github.com/gcclll/stb-vue-next/commit/a5e8e062658d458081ce1bb499b8041f6175689e][feat(add): collection get proxy · gcclll/stb-vue-next@a5e8e06]]

针对集合的所有操作代理都是通过 get proxy 变相完成的，所以搞懂这里是至关重要的。

collection proxy handler:

#+begin_src typescript
export const mutableCollectionHandlers: ProxyHandler<CollectionTypes> = {
  get: createInstrumentationGetter(false, false)
}
#+end_src

简单吧，别被假🐘给迷惑了！！！

这里的原理如果想通了也简单。

试想下，我们调用集合类型的方法是怎么调用的？？？

~map.get()~, ~map.set()~, ~map.delete()~, ~...~

都是通过点语法使用的，点语法前提也必须是先取出值来进行操作，即要调用方法之前，先
将方法取出来，因此这里就是取值操作。

从这一个层级上去理解去实现，就可以通过集合的 ~proxy get~ 来变相实现所有集合的方
法和属性代理。

注意 ~Reflect.get(target, key, receiver)~ 第一个传的是什么？

~boolean ? instrumentations : target~ 即封装后的 ~instrumentations~ 啊 !

如： ~map.get()~ -> ~target: map, key: get~ -> ~target: instumentations, key:
get~ -> ~get(target, key, isReadonly, isShallow)~

集合的操作最终 -----> 转变成 instrumentations 对象上的操作。

#+begin_quote
去掉暂时不需要的代码([[https://github.com/gcclll/stb-vue-next/commit/65ea709dac46e4310eb2ac95cb19984d9b921d88][65ea709]])：

[[https://github.com/gcclll/stb-vue-next/commit/65ea709dac46e4310eb2ac95cb19984d9b921d88][feat: add get proxy handler · gcclll/stb-vue-next@65ea709]]
#+end_quote

** 实现顺序(原理)
:PROPERTIES:
:COLUMNS: %CUSTOM_ID[(Custom Id)]
:CUSTOM_ID: key-collection-proxy-get
:END: 

#+begin_src typescript
// 1. 对外的 handlers
export const mutableCollectionHandlers: ProxyHandler<CollectionTypes> = {
  get: createInstrumentationGetter(false, false)
}


// 2. 封装 get proxy 所有 collection 操作的入口
function createInstrumentationGetter(isReadonly: boolean, shallow: boolean) {
  const instrumentations = mutableInstrumentations

  return (
    target: CollectionTypes,
    key: string | symbol,
    receiver: CollectionTypes
  ) => {
    if (key === ReactiveFlags.IS_REACTIVE) {
      return !isReadonly
    } else if (key === ReactiveFlags.IS_READONLY) {
      return isReadonly
    } else if (key === ReactiveFlags.RAW) {
      return target
    }

    // 将集合操作代理到 instrumentations 对象上
    return Reflect.get(
      hasOwn(instrumentations, key) && key in target
        ? instrumentations
        : target,
      key,
      receiver
    )
  }
}

// 3. map -> instrumentations -> proxy 中间对象
const mutableInstrumentations: Record<string, Function> = {
  // get proxy handler, this -> target
  get(this: MapTypes, key: unknown) {
    return get(this, key)
  }
}


// 4. 最终执行操作得到结果的函数
function get(
  target: MapTypes,
  key: unknown,
  isReadonly = false,
  isShallow = false
) {
  // TODO

  console.log({ target, key })
  return target.get(key)
}
#+end_src

#+begin_quote
理解过程：

首先要理解执行这一句 ~map.get('foo')~ 发生了什么
1. 首先是 ~map.get~ 取值操作，即 ~createInstrumentationGetter()~ 最后 return 的
   那一句

   其实是针对 ~map.get~ 操作的代理，将 "get" 方法从 *map* 对象中取出来的代理。

   所以 ~Reflect.get(target, key, receiver)~ 这里的 ~key = "foo"~

2. 经过 *#1* 之后，需要立即执行 "get" 方法即 ~()~ 操作

   此时执行的是 ~mutableInstrumentations.get(this, key)~ 方法

   所以这里的 ~key = 'foo'~ , ~this~ 就是调用 ~get()~ 方法的对象 *map* 。 

3. 最后 get 操作会被模块全局函数 ~get(target, key, isReadonly, isShallow)~ 代替，
   做了许多特殊处理，收集依赖。
   
#+end_quote

** [[https://github.com/gcclll/stb-vue-next/commit/12bc4da85edd0bfee3785ef3dfb77c3f52ef33cd][12bc4da]] add get handler

[[https://github.com/gcclll/stb-vue-next/commit/12bc4da85edd0bfee3785ef3dfb77c3f52ef33cd][feat(add): get function for collection proxy · gcclll/stb-vue-next@12bc4da]]

*FIX*: [[https://github.com/gcclll/stb-vue-next/commit/edc1d3f701e744a2b33e9ad5352597519cc06106][edc1d3f]] 死循环问题(直接放回 target.get(key) 又会触发 get -> ...)
[[https://github.com/gcclll/stb-vue-next/commit/edc1d3f701e744a2b33e9ad5352597519cc06106][fix: infinite loop · gcclll/stb-vue-next@edc1d3f]]

#+begin_src js
const {
  isReactive,
  effect,
  reactive,
  targetMap,
  shallowReactive
} = require(process.env.PWD + '/../../static/js/vue/reactivity.global.js')

const map = new Map([['foo', 1]])
const observed = reactive(map)

const res = observed.get('foo')
console.log({ res })
#+end_src

+RESULTS:
: {
:   key: 'get',
:   target: Map(1) { 'foo' => 1 },
:   x: 'in createInstrumentationsGetter'
: }
: { key: 'foo', target: Map(1) { 'foo' => 1 }, x: 'in get' }
: { res: 100 }

结果如上(参见.[[#key-collection-proxy-get][原理详细分析]])
1. reactive(map) -> 将 map 代理给 ~instrumentations{ get }~
2. observed.get -> 得到 instrumentations 里面的 "get" 方法
3. ('foo') -> 执行 ~instrumentations.get(this, key)~, /key = 'foo'/
4. 返回结果


#+begin_quote
至此，完成 collection get proxy handler 的完整流程。
#+end_quote
** [[https://github.com/gcclll/stb-vue-next/commit/0b3fd712f72ddeda7c4bf5252624545650c1601b][0b3fd71]] add get handler track

[[https://github.com/gcclll/stb-vue-next/commit/0b3fd712f72ddeda7c4bf5252624545650c1601b][feat(add): collection proxy get -> global get · gcclll/stb-vue-next@0b3fd71]]

新增get 操作，track 添加依赖。

#+begin_src js
const {
  isReactive,
  effect,
  reactive,
  targetMap,
  shallowReactive
} = require(process.env.PWD + '/../../static/js/vue/reactivity.global.js')

const map = new Map([['foo', 1]])
const observed = reactive(map)

let dummy
effect(() => {
  dummy = observed.get('foo')
})

console.log(`dummy = ${dummy}`)

#+end_src

+RESULTS:
#+begin_example
{
  key: 'get',
  target: Map(1) { 'foo' => 1 },
  x: 'in createInstrumentationGetter'
}
{
  key: 'foo',
  type: 'get',
  dep: Set(1) {
    [Function: reactiveEffect] {
      id: 0,
      allowRecurse: false,
      _isEffect: true,
      active: true,
      raw: [Function (anonymous)],
      deps: [Array],
      options: {}
    }
  },
  x: 'in track'
}
{ key: 'foo', target: Map(1) { 'foo' => 1 }, x: 'in global get' }
dummy = 100
#+end_example

分为三个阶段
1. collection proxy handler 取  map.get 方法, ~key = 'get'~
2. ~('prop')~ 执行期触发 ~instrumentations.get(this, key), key = 'foo'~
3. 执行 global get 触发 ~track~ 收集依赖，返回结果值


假设 ~map.get(key)~ 的 key 也是个 proxy :

#+begin_src js
const {
  isReactive,
  effect,
  reactive,
  targetMap,
  shallowReactive
} = require(process.env.PWD + '/../../static/js/vue/reactivity.global.js')

let dummy
const key = reactive({ k: 1 })
const value = reactive({ v: 2 })
const map = reactive(new Map([[key, value]]))

effect( () => {
  dummy = map.get(key)
} )

console.log(`dummy = ${dummy}`)
#+end_src

+RESULTS:
#+begin_example
{ #1
  key: 'get',
  target: Map(1) { { k: 1 } => { v: 2 } },
  x: 'in createInstrumentationGetter'
}
#2
{ key: { k: 1 }, rawKey: { k: 1 }, eq: false }
{ #3
  key: { k: 1 },
  type: 'get',
  dep: Set(1) {
    [Function: reactiveEffect] {
      id: 0,
      allowRecurse: false,
      _isEffect: true,
      active: true,
      raw: [Function (anonymous)],
      deps: [Array],
      options: {}
    }
  },
  x: 'in track'
}
{ #4
  key: { k: 1 },
  type: 'get',
  dep: Set(1) {
    [Function: reactiveEffect] {
      id: 0,
      allowRecurse: false,
      _isEffect: true,
      active: true,
      raw: [Function (anonymous)],
      deps: [Array],
      options: {}
    }
  },
  x: 'in track'
}
{ #5
  key: { k: 1 },
  target: Map(1) { { k: 1 } => { v: 2 } },
  x: 'in global get'
}
dummy = 100
#+end_example

1. *#1* proxy collection get handler
2. *#2* global get 函数里调用 track 之前输出，显示 ~key~ 和 ~rawKey~ 是不同的
   (~eq = false~)，因为前者是个 proxy 后者是 key proxy 的 rawValue 。
3. *#3* track() 调用时的输出，显示的是需要收集依赖的是 ~proxy key{k: 1}~ 
4. *#4* track() 调用时的输出，显示的是需要收集依赖的是 ~raw key{k: 1}~


从 *#3*, *#4* 可知如果 key 本身已经是 proxy 那么它及其对应的 rawKey 同时也会收集
当前的 effect 。
** [[https://github.com/gcclll/stb-vue-next/commit/77b14ef019cd320bc04f1c861424db79bcc82f9f][77b14ef]] add get handler return value

[[https://github.com/gcclll/stb-vue-next/commit/77b14ef019cd320bc04f1c861424db79bcc82f9f][feat(add): collection proxy get with value return · gcclll/stb-vue-next@77b14ef]]

[[http://qiniu.ii6g.com/img/20201121095654.png]]

这里处理分为两部分：

1. 取出 ~has~ 方法检测存在性
2. 根据 ~isReadonly~ 和 ~isShallow~ 决定对返回值做什么处理，如：递归 reactive/readonly
3. 使用 target.get(key) 取出结果值返回
* [[https://github.com/gcclll/stb-vue-next/commit/7b680df94e359c208697111319eda9ee75560b11][7b680df]] add collection set proxy handler

[[https://github.com/gcclll/stb-vue-next/commit/7b680df94e359c208697111319eda9ee75560b11][feat(add): collection set proxy handler · gcclll/stb-vue-next@7b680df]]

set proxy handler 处理

1. 设值的时候可能有两种情况 a) set, b) add
2. 需要考虑 proxy key 和 raw key 问题
3. 最后 trigger 触发依赖

#+begin_src typescript

function set(this: MapTypes, key: unknown, value: unknown) {
  value = toRaw(value)
  const target = toRaw(this)
  const { has, get } = getProto(target)

  let hadKey = has.call(target, key)
  // 考虑 key 可能是 proxy
  if (!hadKey) {
    // to add
    key = toRaw(key)
    hadKey = has.call(target, key)
  } else if (__DEV__) {
    checkIdentityKeys(target, has, key)
  }

  const oldValue = get.call(target, key)
  // 设值结果
  const result = target.set(key, value)
  if (!hadKey) {
    // 添加操作
    trigger(target, TriggerOpTypes.ADD, key, value)
  } else {
    // 设值操作
    trigger(target, TriggerOpTypes.SET, key, value, oldValue)
  }

  return result
}
#+end_src

测试
#+begin_src js
const {
  isReactive,
  effect,
  reactive,
  targetMap,
  shallowReactive
} = require(process.env.PWD + '/../../static/js/vue/reactivity.global.js')


const map = new Map()
const observed = reactive(map)

console.log(`> before get, deps`)
console.log(targetMap.get(map))
let dummy
effect(() => {
  dummy = observed.get('foo')
})

console.log(`> after get, deps`)
console.log(targetMap.get(map).get('foo'))

console.log(`#1 before set, dummy = ${dummy}`)
observed.set('foo', 1)
console.log(`#2 after set, dummy = ${dummy}`)
#+end_src

+RESULTS:
#+begin_example
> before get, deps
undefined
> after get, deps
<ref *1> Set(1) {
  [Function: reactiveEffect] {
    id: 0,
    allowRecurse: false,
    _isEffect: true,
    active: true,
    raw: [Function (anonymous)],
    deps: [ [Circular *1] ],
    options: {}
  }
}
#1 before set, dummy = undefined
#2 after set, dummy = 1
#+end_example
* [[https://github.com/gcclll/stb-vue-next/commit/73fa5ebf7f0dcdaa11bbf42df89c7f7c1ab88385][73fa5eb]] add collection size,has,add proxy handler

[[https://github.com/gcclll/stb-vue-next/commit/73fa5ebf7f0dcdaa11bbf42df89c7f7c1ab88385][feat(add): size, has, add collection proxy handlers · gcclll/stb-vue-next@73fa5eb]]

has: proxy key, raw key 都需要 track has 操作依赖
#+begin_src typescript
function has(this: CollectionTypes, key: unknown, isReadonly = false): boolean {
  const target = (this as any)[ReactiveFlags.RAW]
  const rawTarget = toRaw(target)
  const rawKey = toRaw(key)
  if (key !== rawKey) {
    !isReadonly && track(rawTarget, TrackOpTypes.HAS, key)
  }
  !isReadonly && track(rawTarget, TrackOpTypes.HAS, rawKey)

  return key === rawKey
    ? target.has(key)
    : target.has(key) || target.has(rawKey)
}
#+end_src

size: 取size 内部实现过程中是需要对 collection 进行迭代操作的，所以 track 用的是 ~ITERATE_KEY~
#+begin_src typescript
function size(target: IterableCollections, isReadonly = false) {
  target = (target as any)[ReactiveFlags.RAW]
  !isReadonly && track(toRaw(target), TrackOpTypes.ITERATE, ITERATE_KEY)
  return Reflect.get(target, 'size', target)
}
#+end_src

add: set.add 操作，根据 set 特性，key,value 都是同一个且元素是不重复的，所以只需
要检测是不是新增，新增就需要 trigger ADD 。
#+begin_src typescript
function add(this: SetTypes, value: unknown) {
  value = toRaw(value)
  const target = toRaw(this)
  const proto = getProto(target)
  const hadKey = proto.has.call(target, value)
  const result = target.add(value)
  // 因为 set 是不会存在重复元素的，所以只会在没有当前 key 的情况下才会执行
  // 添加操作
  if (!hadKey) {
    trigger(target, TriggerOpTypes.ADD, value, value)
  }
  return result
}
#+end_src

trigger 处理：[[https://github.com/gcclll/stb-vue-next/commit/838b4023b61bc0fede67e94aa7fd857a4950c29e][838b402]]

[[https://github.com/gcclll/stb-vue-next/commit/838b4023b61bc0fede67e94aa7fd857a4950c29e][feat(add): collection trigger cases · gcclll/stb-vue-next@838b402]]

测试：
#+begin_src js
const {
  isReactive,
  effect,
  reactive,
  targetMap,
  shallowReactive
} = require(process.env.PWD + '/../../static/js/vue/reactivity.global.js')

const map = new Map()
const observed = reactive(map)
let dummy
effect(() => {
  dummy = observed.size
})

console.log(`before set, get map size -> dummy = ${dummy}`)
observed.set('foo', 1)
console.log(`after set, get map size -> dummy = ${dummy}`)

effect(() => {
  dummy = observed.has('foo')
})
console.log(`observed has 'foo' -> dummy = ${dummy}`)

const set = new Set()
const observedSet = reactive(set)
effect(() => {
  dummy = observedSet.size
})
console.log(`before add, get set size -> dummy = ${dummy}`)
observedSet.add(1)
console.log(`after add, get set size -> dummy = ${dummy}`)
#+end_src

+RESULTS:
: before set, get map size -> dummy = 0
: after set, get map size -> dummy = 1
: observed has 'foo' -> dummy = true
: before add, get set size -> dummy = 0
: after add, get set size -> dummy = 1

* [[https://github.com/gcclll/stb-vue-next/commit/b3c5087095ace7797cf6c38bd45b99700d4b6059][b3c5087]] add collection delete,clear proxy handler

[[https://github.com/gcclll/stb-vue-next/commit/b3c5087095ace7797cf6c38bd45b99700d4b6059][feat(add): collection delete and clear · gcclll/stb-vue-next@b3c5087]]

delete:
#+begin_src typescript
function deleteEntry(this: CollectionTypes, key: unknown) {
  const target = toRaw(this)
  const { has, get } = getProto(target)
  let hadKey = has.call(target, key)
  if (!hadKey) {
    key = toRaw(key)
    hadKey = has.call(target, key)
  } else if (__DEV__) {
    checkIdentityKeys(target, has, key)
  }

  const oldValue = get ? get.call(target, key) : undefined
  const result = target.delete(key)
  if (hadKey) {
    trigger(target, TriggerOpTypes.DELETE, key, undefined, oldValue)
  }
  return result
}
#+end_src

clear:
#+begin_src typescript
function clear(this: IterableCollections) {
  const target = toRaw(this)
  const hadItems = target.size !== 0
  const oldTarget = __DEV__
    ? isMap(target)
      ? new Map(target)
      : new Set(target)
    : undefined

  const result = target.clear()
  if (hadItems) {
    trigger(target, TriggerOpTypes.CLEAR, undefined, undefined, oldTarget)
  }
  return result
}
#+end_src

测试：
#+begin_src js
const {
  isReactive,
  effect,
  reactive,
  targetMap,
  shallowReactive
} = require(process.env.PWD + '/../../static/js/vue/reactivity.global.js')

const map = new Map()
const observedMap = reactive(map)
let dummy
effect(() => {
  dummy = observedMap.size
})

console.log(`>>> map`)
observedMap.set('foo', 1)
console.log(`before delete, dummy = ${dummy}`)
observedMap.delete('foo')
console.log(`after delete, dummy = ${dummy}`)
observedMap.set('foo', 1)
observedMap.set('bar', 1)
console.log(`before clear, dummy = ${dummy}`)
observedMap.clear()
console.log(`after clear, dummy = ${dummy}`)
console.log(`>>> set`)

const set = new Set()
const observedSet = reactive(set)
effect(() => {
  dummy = observedSet.size
})
observedSet.add(1)
console.log(`before delete, dummy = ${dummy}`)
observedSet.delete(1)
console.log(`after delete, dummy = ${dummy}`)
observedSet.add(1)
observedSet.add(2)
observedSet.add(3)
console.log(`before clear, dummy = ${dummy}`)
observedSet.clear()
console.log(`after clear, dummy = ${dummy}`)
#+end_src

+RESULTS:
#+begin_example
>>> map
before delete, dummy = 1
after delete, dummy = 0
before clear, dummy = 2
after clear, dummy = 0
>>> set
before delete, dummy = 1
after delete, dummy = 0
before clear, dummy = 3
after clear, dummy = 0
#+end_example

* effect 测试
*** 测试1(base, prototype)

:PROPERTIES:
:COLUMNS: %CUSTOM_ID[(Custom Id)]
:CUSTOM_ID: effect-test-01
:END:

测试内容：
1. effect 基本使用
2. effect 作用域原型链

#+begin_src js
// 只执行一次 effect fn
const {
  isReactive,
  effect,
  reactive,
  targetMap,
  shallowReactive
} = require(process.env.PWD + '/../../static/js/vue/reactivity.global.js')

// 基本的测试用例就不列出来了，这里只列出有疑问的
// 1. effect fn 只执行一次
// 2. observe 基本属性
// 3. observe 多个属性(n1,n2...) -> effect(() => (dummy = obj.n1 + obj.n2))
// 4. 同一个属性多个 effect，会将这多个 effects 收集到 prop 的 deps 中
// 5. observe 属性删除
let dummy, dummy1, dummy2
const ob = reactive({ foo: { bar: 0 } })
effect(() => (dummy = ob.foo.bar)) // effect -> ob, ob.foo, ob.foo.bar deps
effect(() => (dummy1 = ob.foo.bar))
console.log(`before set, dummy = ${dummy}, dummy1 = ${dummy1}`)
ob.foo.bar = 8
console.log(`after set, dummy = ${dummy}, dummy1 = ${dummy1}`)
delete ob.foo.bar
console.log(`after delete, dummy = ${dummy}, dummy1 = ${dummy1}`)
console.log(`>>> 原型链`)

const obj1 = { num: 0 }, obj2 = { num: 2 }
const counter = reactive(obj1)
const parentCounter = reactive(obj2)
// 取值原理： 先自身再往上找原型链，所有只要
Object.setPrototypeOf(counter, parentCounter)
effect(() => (dummy = counter.num))
console.log(`dummy = ${dummy}`)
console.log(`> #1 obj1.num 的依赖`)
console.log(targetMap.get(obj1).get('num'))
console.log(`> #2 obj2.num 的依赖, delete 之前`)
console.log(targetMap.get(obj2))
delete counter.num // 这里删除了属性，触发 effect fn 里面取值操作发现没有属性了
// 往原型链找，找到 parentCounter.num ，此时 parentCounter.num 收集 effect fn 进自己的 deps
// 所以后面的 parentCounter.num 上的操作同样会触发 effect fn
console.log(`after delete, dummy = ${dummy}`)
console.log(`> #3 obj2.num 的依赖, delete 之后`)
console.log(targetMap.get(obj2).get('num'))
parentCounter.num = 4
console.log(`#4 after 'parentCounter.num = 4', dummy = ${dummy}`)
counter.num = 3
console.log(`#5 after counter.num = 3', dummy = ${dummy}`)
#+end_src

结果分析：
- *#1* obj1.num 依赖是在 effect 第一次执行的时候收集的
- *#2* obj2.num 在执行 ~delete counter.num~ 之前是没有任何依赖

  因为此时并没有任何 ~parentCounter~ 上的操作
- *#3* obj2.num 有了自己的依赖

  此时，执行了 ~delete counter.num~ 逻辑如下：

  对 counter.num 执行删除会触发 ~num~ 上的所有依赖 deps，即执行 effect fn，

  在 effect fn 里面有 ~counter.num~ 的取值操作，但是发现属性被删除，根据取值查找
  原理，会在对象的原型链上逐级往上查找(~parentCounter~)，找到
  ~parentCounter.num~ 随机进行取值操作，所以删除操作之后的 ~dummy = 2~ ，且取值
  操作触发 tracking 因此此时 ~parentCounter.num~ 就有了自己的依赖 effect fn。
- *#4* 给 parentCounter 设值触发 effect fn，查找原型链 , 所以 dummy = 4
- *#5* 给 counter 设值触发 effect fn，不查找原型链(自身属性)，所以 dummy = 3

+RESULTS:
#+begin_example
before set, dummy = 0, dummy1 = 0
after set, dummy = 8, dummy1 = 8
after delete, dummy = undefined, dummy1 = undefined
>>> 原型链
dummy = 0
> #1 obj1.num 的依赖
<ref *1> Set(1) {
  [Function: reactiveEffect] {
    id: 2,
    allowRecurse: false,
    _isEffect: true,
    active: true,
    raw: [Function (anonymous)],
    deps: [ [Circular *1] ],
    options: {}
  }
}
> #2 obj2.num 的依赖, delete 之前
undefined
after delete, dummy = 2
> #3 obj2.num 的依赖, delete 之后
<ref *1> Set(1) {
  [Function: reactiveEffect] {
    id: 2,
    allowRecurse: false,
    _isEffect: true,
    active: true,
    raw: [Function (anonymous)],
    deps: [ [Circular *1], [Set] ],
    options: {}
  }
}
#4 after 'parentCounter.num = 4', dummy = 4
#5 after counter.num = 3', dummy = 3
undefined
#+end_example
*** 测试2(stop, ...)
:PROPERTIES:
:COLUMNS: %CUSTOM_ID[(Custom Id)]
:CUSTOM_ID: effect-test-02
:END:

1. *stop* :

   #+begin_src js
    const {
        isReactive,
        effect,
        reactive,
        targetMap,
        shallowReactive,
        stop
    } = require(process.env.PWD + '/../../static/js/vue/reactivity.global.js')

    console.log(`>>> stop effect`)
    let dummy
    const obj = reactive({ prop: 1 })
    const runner = effect(() => {
        dummy = obj.prop
    })
    obj.prop = 2
    console.log(`#1, after 'obj.prop = 2', dummy = ${dummy}`)
    console.log(`> prop deps, before stop`)
    console.log(targetMap.get(obj.__v_raw).get('prop'))
    // 清空了所有依赖
    stop(runner) // stop the effect, set effect.active = false
    console.log(`> prop deps, after stop`)
    console.log(targetMap.get(obj.__v_raw).get('prop'))
    obj.prop = 3
    console.log(`#2, after stop, 'obj.prop = 3', dummy = ${dummy}`)
    obj.prop = 4
    console.log(`#3, after stop, 'obj.prop = 4', dummy = ${dummy}`)
    runner()
    console.log(`#4, after run runner, dummy = ${dummy}, runner.active = ${runner.active}`)
    #+end_src

    +RESULTS:
    #+begin_example
    >>> stop effect
    #1, after 'obj.prop = 2', dummy = 2
    > prop deps, before stop
    <ref *1> Set(1) {
    [Function: reactiveEffect] {
        id: 0,
        allowRecurse: false,
        _isEffect: true,
        active: true,
        raw: [Function (anonymous)],
        deps: [ [Circular *1] ],
        options: {}
    }
    }
    > prop deps, after stop
    Set(0) {}
    #2, after stop, 'obj.prop = 3', dummy = 2
    #3, after stop, 'obj.prop = 4', dummy = 2
    #4, after run runner, dummy = 4, runner.active = false
    undefined
    #+end_example

   - stop 干了两件事(a. 清空所有 effect.deps, b. 将 effect.active 置为 false)
   - stop 之后 trigger 时没有 deps 可执行，所以无论如何 effect fn 不会被执行
   - 手动执行 runner() 之后执行effect fn 重新收集依赖(此时 active 依旧为 ~false~)

2. *stop + scheduler* :

   #+begin_src js
    const {
        isReactive,
        effect,
        reactive,
        targetMap,
        stop,
        shallowReactive
    } = require(process.env.PWD + '/../../static/js/vue/reactivity.global.js')

    let dummy
    const obj = reactive({ prop : 1 })
    const queue = []
    const runner = effect(() => (dummy = obj.prop), { scheduler: e => queue.push(e) })
    obj.prop = 2
    console.log(`#1 after 'obj.prop = 2', dummy = ${dummy}`)
    console.log(`#2 after 'obj.prop = 2', queue.length = ${queue.length}`)
    stop(runner)

    queue.forEach(e => e())
    console.log(`#3 after stop, queue forEach, dummy = ${dummy}`)
    #+end_src

    +RESULTS:
    : #1 after 'obj.prop = 2', dummy = 1
    : #2 after 'obj.prop = 2', queue.length = 1
    : #3 after stop, queue forEach, dummy = 1

    提供了 scheduler 选项的 effect 永远不会被执行，源码：

    #+begin_src js
    if (!effect.active) {
        return options.scheduler ? undefined : fn()
    }
    #+end_src

3. *onStop* :

   #+begin_src js
    const {
        isReactive,
        effect,
        reactive,
        targetMap,
        stop,
        shallowReactive
    } = require(process.env.PWD + '/../../static/js/vue/reactivity.global.js')

    let n = 0
    const runner = effect(() => {}, {
        onStop() {
            console.log(`stopped ${++n} times`)
        }
    })

    stop(runner)
    stop(runner)
    stop(runner)
    #+end_src

    +RESULTS:
    : stopped 1 times

    只会被执行一次，因为 ~effect.active = true~ 时才可以被 stop 。

4. *stop: 一个 stopped 的 effect 在一个正常的 effect 中调用*

   #+begin_src js
    const {
        isReactive,
        effect,
        reactive,
        targetMap,
        stop,
        shallowReactive
    } = require(process.env.PWD + '/../../static/js/vue/reactivity.global.js')

   let dummy
   const obj = reactive({ prop: 1 })
   const runner = effect(() => {
     dummy = obj.prop
   })

   stop(runner)
   obj.prop = 2
   console.log(`#1 after stop runner, dummy = ${dummy}`)

   // 这里等于是手动执行了 runner effect `dummy = obj.prop`
   // 所以下面的 effect 被 obj.prop 收集进 deps<Set>
   effect(() => {
     runner()
   })
   obj.prop = 3
   console.log(`#2 after runner in effect, dummy = ${dummy}`)
   #+end_src

   +RESULTS:
   : #1 after stop runner, dummy = 1
   : #2 after runner in effect, dummy = 3

   1. *#1* 值依旧是 1 ，是因为 stop 了

   2. *#2* 值为 3，是因为 effect 执行 runner() 使得 ~obj.prop~ 收集到第二个
      effect fn 。
* 阶段测试一
** effect + track + trigger 响应式基本操作(get/set)
:PROPERTIES:
:COLUMNS: %CUSTOM_ID[(Custom Id)]
:CUSTOM_ID: test-01
:END:

commit: [[https://github.com/gcclll/stb-vue-next/commit/b5f97b413d4628f4ec8fcf4e859d387ebfac3ad8][feat: effect-trigger · gcclll/stb-vue-next@b5f97b4]]

#+RESULTS:

1. lazy: true 标识 effect fn 不会立即执行
2. 点击 set 操作，此时并没有依赖，所以只会触发 count++
3. 当点击 get 操作，触发 ~track()~ 收集依赖 fn -> deps
4. 再点击 set 操作，此时已经有依赖，所以会 ~trigger()~ 所有依赖更新
5. options.scheduler 选项作用

   如果 options 有 scheduler 选项， ~trigger()~ 的时候不会立即执行 effects 而是
   调用 scheduler 并将当前需要被执行的 effect 当做参数给 scheduler，由使用者决定
   何时去执行 effect，比如需要在 dummy 更新之前做点什么。

#+begin_export html
<style>
#_effect_test_02>.box {
  display: flex;
  justify-content: space-around;
}
#_effect_test_02>.box>button{
  border: none;
  width: 250px;
}
</style>
<div id="_effect_test_02">
<div class="box">
    <button class="getval">点我触发 get操作！</button>
    <button class="setval">点我触发 set操作！</button>
</div>
<br>
<div class="box">
    <button class="before-scheduler">手动调用 scheduler 之前</button>
    <button class="after-scheduler">手动调用 scheduler 之后</button>
</div>
<br>
<div class="box">
    <button class="code">点击查看测试源码</button>
    <button class="reset">重置</button>
</div>
<div class="result"></div>
<code></code>
</div>
#+end_export

#+begin_export html
<script id="GW0MDx">
setTimeout(function test() {
    if (typeof $ === 'undefined') return

    var ins = VueReactivity
    var effect = ins.effect
    var reactive = ins.reactive
    var target = { count: 0 }
    var counter = reactive(target)

    var $el = $("#_effect_test_02")
    var LOG = function (msg) {
      _log($el, msg)
    }

    var lazyEffect = effect(
      function fn() {
        var c = counter.count
        LOG('正在执行 effect fn..., counter.count = ' + counter.count)
      }, {
        lazy: true
      }
    )

    var effected = false
    var getDeps = function () {
      if (!ins.targetMap) return new Set()
      const depsMap = ins.targetMap.get(target) || new Map()
      return depsMap.get('count') || new Set()
    }
    $el.find(".setval").click(function() {
      counter.count++
      var size = getDeps().size
      if (size === 0) {
        LOG('target 此时无任何依赖，deps.size = ' + size + ', counter.count = ' + counter.count)
      }
    })
    $el.find(".reset").click(function() {
      ins.cleanup(lazyEffect)
      $el.children(".result").html('')
      effected = false
      counter.count = 0
      dummy = 0
      runner = undefined
      times = 0
      LOG('target.count deps.size = ' + getDeps().size)
    })
    $el.find(".getval").click(function() {
      if (!effected) {
        effected = true
        lazyEffect() // 手动执行 effect
        LOG('手动执行 effect()，开始收集依赖 fn -> deps<Set>, size: ' + getDeps().size)
      }
      LOG('取值操作(target.count 的 deps 数)：'
        + ins.targetMap.get(target).get('count').size
        + ', counter.count = ' + counter.count)
    })

    $el.find('.code').click(function() {
      console.log($("#GW0MDx").html())
      LOG('源码已输出到控制台(F12-console)....')
    })

    var dummy = 0, runner
    var counter1 = reactive({ count: 0 })
    var times = 0
    var schedulerEffect = effect(function fn() {
      dummy = counter1.count
    }, {
      scheduler: function(_effect) {
        LOG('scheduler 执行次数 ' + ++times + ', dummy = ' + dummy)
        runner = function() {
          _effect()
        }
      }
    })

    LOG('scheduler effect fn 第一次会被执行， dummy = ' + dummy)
    $el.find('.before-scheduler').click(function() {
      LOG('scheduler 不会被执行, dummy = ' + dummy)
    })

    $el.find('.after-scheduler').click(function() {
      counter1.count++
      runner()
    })
}, 1000)

</script>
#+end_export

** 相关用例：
1. 立即执行一次 fn，观察基本属性(一个或多个)

   #+begin_src js
    const { effect, reactive, targetMap } = require(process.env.PWD + '/../../static/js/vue/reactivity.global.js')

    const ob = reactive({ n1: 0, n2: 10 })
    let times = 0, dummy = 0
    effect(() => {
    console.log('effect fn 被执行 ' + ++times + ' 次')
    dummy = ob.n1 + ob.n2
    })

    console.log('before set: dummy = ' + dummy)
    ob.n1 = ob.n2 = 10
    console.log('after set: dummy = ' + dummy)
   #+end_src

   +RESULTS:
   : effect fn 被执行 1 次
   : before set: dummy = 10
   : effect fn 被执行 2 次
   : after set: dummy = 20

2. 给同一个属性绑定多个 effects，值变更触发多个 effect

   #+begin_src  js
    const { effect, reactive, targetMap } = require(process.env.PWD + '/../../static/js/vue/reactivity.global.js')

    let d1, d2
    const ob = reactive({ count: 0 })
    effect(() => (d1 = ob.count))
    effect(() => (d2 = ob.count))

    console.log('before set: d1 = ' + d1 + ', d2 = ' + d2)
    ob.count = 3
    console.log('after set: d1 = ' + d1 + ', d2 = ' + d2)
   #+end_src

   +RESULTS:
   : before set: d1 = 0, d2 = 0
   : after set: d1 = 3, d2 = 3
** 支持对象嵌套
:PROPERTIES:
:COLUMNS: %CUSTOM_ID[(Custom Id)]
:CUSTOM_ID: test-02
:END:

commit: [[https://github.com/gcclll/stb-vue-next/commit/b2143f9e35af77ee43792a6110ea70c4caf9a54f?branch=b2143f9e35af77ee43792a6110ea70c4caf9a54f&diff=split][feat: observe object recursively · gcclll/stb-vue-next@b2143f9]]

测试：
* 完整脑图
:PROPERTIES:
:COLUMNS: %CUSTOM_ID[(Custom Id)]
:CUSTOM_ID: whole-mind-map
:END:

[[/img/vue3/reactivity/reactivity.svg]]

** collection proxy handlers 脑图
:PROPERTIES:
:COLUMNS: %CUSTOM_ID[(Custom Id)]
:CUSTOM_ID: while-collection
:END:

[[/img/vue3/reactivity/reactivity-collection-proxy.svg]]
