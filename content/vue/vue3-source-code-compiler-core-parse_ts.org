#+TITLE: Vue3.0 æºç ç³»åˆ—ï¼ˆäºŒï¼‰ç¼–è¯‘å™¨æ ¸å¿ƒ - Compiler core 1: parse.ts
#+DATE: <2020-08-31 22:11:55>
#+TAGS[]: vue, vue3, vuenext, compiler
#+CATEGORIES[]: vue
#+LANGUAGE: zh-cn
#+STARTUP: indent

#+begin_export html
<script>
window.g_need_fold = 1
</script>
#+end_export 

#+begin_quote
è¯¥ç³»åˆ—æ–‡ç« ï¼Œå‡ä»¥æµ‹è¯•ç”¨ä¾‹é€šè¿‡ä¸ºåŸºå‡†ä¸€æ­¥æ­¥å®ç°ä¸€ä¸ª vue3 æºç å‰¯æœ¬(å­¦ä¹ )ã€‚
#+end_quote

@@html:<kbd>@@æ–‡å­—æ¯”è¾ƒé•¿ï¼Œå¦‚æœä¸æƒ³çœ‹æ–‡å­—å¯ç›´æ¥è½¬åˆ°[[/vue/vue-mind-map-house/][è¿™é‡Œ]]çœ‹è„‘å›¾@@html:</kbd>@@

#+begin_export html
<font color="#fc02ff">å¯èƒ½æ„Ÿå…´è¶£åˆ—è¡¨ï¼š</font>
#+end_export

1. [[#issues][æºç ç›¸å…³çš„ç–‘é—®/é—®é¢˜åˆ—è¡¨åŠå…¶è§£ç­”]] ğŸ›³ ğŸ›³ ğŸ›³ ğŸ›³ ğŸ›³
2. [[#stage_code][é˜¶æ®µæ€§çš„ä»£ç å¤‡ä»½(æ¯”å¦‚èƒ½ pass æŸä¸ªç”¨ä¾‹)]] ğŸš˜ ğŸš˜ ğŸš˜ ğŸš˜ ğŸš˜
3. [[/vue/vue-mind-map-house/][æ‰€æœ‰è„‘å›¾åˆ—è¡¨åŠç®€è¦è§£æ]]

* å°ç»“

å°ç»“ä¹‹æ‰€ä»¥æ”¾åœ¨æœ€å‰é¢ï¼Œä¸»è¦åŸå› æœ‰äºŒï¼š

1. æ–‡ç« éƒ½æ˜¯æ ¹æ®æµ‹è¯•ç”¨ä¾‹é€æ­¥ç”±å°‘åˆ°å¤šï¼Œç®€åˆ°å…¨çš„è¿›åº¦å»å®ç°å’Œæµ‹è¯•çš„ã€‚
2. æ–‡å­—å†…å®¹å¤ªå¤šï¼Œå°ç»“æ”¾å‰é¢èƒ½æå‰å¤§æ¦‚æœ‰ä¸ªå…¨å±€è§‚ï¼Œå…¨å±€çš„æ¦‚å¿µã€‚

ä¸Šå›¾ï¼šå‡ ä¸ªé‡è¦å‡½æ•°å’Œå‡ ä¸ªç®€å•çš„ç”¨ä¾‹

[[/img/vue3/compiler-core/parse_ts-brief-summary.png]]

æ¯ä¸ªå‡½æ•°çš„é‡è¦å®ç°è§£è¯´ï¼š

1. [[#parse-parsechildren][parseChildren]] æ‰€æœ‰æ¨¡æ¿è§£æçš„å…¥å£ï¼Œé‡ç‚¹æ˜¯ while å¾ªç¯æ£€æµ‹è§„åˆ™è¿›å…¥å¯¹åº”çš„ parse*
   å‡½æ•°è§£æï¼Œåˆå¹¶ç›¸é‚»æ–‡æœ¬èŠ‚ç‚¹ï¼Œè¿‡æ»¤ç©ºè¡ŒèŠ‚ç‚¹ï¼Œè¿”å› root.childrenã€‚
2. [[#parse-parsecomment][parseComment]] è¿™é‡Œçš„æ³¨é‡Šæ˜¯æŒ‡ ~<!--xx-->~ html æ³¨é‡Šï¼ŒåŒºåˆ†å‡ ç§éæ³•æƒ…å†µï¼Œå¯é€šè¿‡ç”¨
   ä¾‹æ¥ç†Ÿæ‚‰(a. [[#test-parse-comment][æ­£å¸¸æ³¨é‡Š]]ï¼Œb. [[#test-parse-errors-comment][éæ³•æ³¨é‡Š]])
3. [[#parse-parseelement][parseElememt]] è§£ææ ‡ç­¾ï¼Œå¾—åˆ°æ•´ä¸ªæ ‡ç­¾çš„ ast ç»“æ„ï¼ŒåŒ…å«ï¼šæ ‡ç­¾å tagï¼Œå±æ€§åˆ—è¡¨
   propsï¼Œå­©å­èŠ‚ç‚¹ childrenï¼Œç­‰ç­‰ã€‚
   - æ£€æµ‹è‡ªé—­åˆ(~<div/>~)å’Œç©ºæ ‡ç­¾(~<img>~)æ£€æµ‹ï¼Œå®ƒä»¬æ²¡æœ‰å­©å­èŠ‚ç‚¹ã€‚
   - å…³é”®çš„ ancestors æ•°ç»„ï¼Œåœ¨é€’å½’è§£æå­©å­èŠ‚ç‚¹çš„æ—¶å€™é€šè¿‡å‡ºå…¥æ ˆæ“ä½œä¿å­˜å½“å‰è§£æçš„
     èŠ‚ç‚¹å¯¹è±¡(å¦‚ï¼š[[#issues-03][ç–‘é—®3]])ã€‚
4. [[#parse-parsetext][parseText]] æ–‡æœ¬è§£æï¼Œéæ ‡ç­¾ï¼Œéæ’å€¼ç±»å‹çš„èŠ‚ç‚¹ä¼šè¢«å½“åšæ–‡æœ¬ç±»å‹å»è§£æã€‚æ–‡æœ¬ç»“æŸ
   æ ¹æ®æ˜¯ (~<, {{, ]]>~)ã€‚
5. [[#parse-parsetextdata][parseTextData]] è§£ææ–‡æœ¬ï¼Œæ›¿æ¢ html æ ‡è®°(åŒ¹é…ï¼š ~/&(gt|lt|amp|apos|quot);/g~)
6. [[#parse-parsetag][parseTag]] è§£æå…ƒç´ æ ‡ç­¾ï¼Œå±æ€§ propsï¼Œv-pre ç­‰æŒ‡ä»¤éƒ½æ˜¯åœ¨è¿™é‡Œé¢å‘èµ·è§£æçš„ï¼Œæ³¨æ„è‡ªé—­
   åˆæ ‡ç­¾çš„å¤„ç† isSelfClosing æ ‡å¿—ç»“æŸ parseElement ä¸­è§£æè¿›ç¨‹ã€‚
7. [[#parse-parseattributes][parseAttributes]] whle å¾ªç¯è°ƒç”¨ parseAttribute è§£æå±æ€§å­˜åˆ° props ä¸­ã€‚
8. [[#parse-parseattribute][parseAttribute]] è§£æå•ä¸ªå±æ€§ï¼Œé›†åˆä¿å­˜å±æ€§åé˜²æ­¢é‡å¤ï¼Œå…ˆè§£æå±æ€§å€¼ï¼Œç„¶åè§£æå±
   æ€§åï¼ŒæŒ‡ä»¤ï¼Œä¿®é¥°ç¬¦ï¼Œå‚æ•°ç­‰ã€‚
9. [[#parse-parseattributevalue][parseAttributeValue]] è§£æå±æ€§å€¼ï¼ŒåŒºåˆ†æœ‰å¼•å·æˆ–æ²¡å¼•å·(å³å±æ€§å€¼å¯ä»¥æ²¡å¼•å·å“¦ğŸ˜¯)ã€‚
10. [[#parse-parseinterpolation][parseInterpolation]] æ’å€¼è§£æï¼Œå– *{{* å’Œ *}}* ä¹‹é—´çš„æ–‡æœ¬ä½œä¸ºè¡¨è¾¾å¼ã€‚
11. [[#parse-parsecdata][parseCDATA]] è§£æ xml æ³¨é‡Šï¼Œå½“åšæ–‡æœ¬å¤„ç†
12. [[#parse-parseboguscomment][parseBogusComment]] è§£æ <? çš„æ³¨é‡Š
* parse.spec.ts
:PROPERTIES:
:COLUMNS: %CUSTOM_ID[(Custom Id)]
:CUSTOM_ID: parse.spec.ts
:END: 

æµ‹è¯•ç”¨ä¾‹ç»“æ„ï¼šcompiler: parse
æˆªæ­¢ï¼š2020-09-02 22:53:14

[[#test-parse-all][æ‰€æœ‰ç”¨ä¾‹å…¨éƒ¨é€šè¿‡ï¼šparse.ts çš„è§£æåŠŸèƒ½å‡ ä¹å…¨éƒ¨å®ç°(å¯èƒ½ä¼šæœ‰é—æ¼)]]

** ErrorCodes å„ç§é”™è¯¯æƒ…å†µç”¨ä¾‹
:PROPERTIES:
:COLUMNS:  %CUSTOM_ID[(Custom Id)]
:CUSTOM_ID: test-parse-errors
:END:
ä¸é€šè¿‡ç”¨ä¾‹ï¼š
- ~<textarea></div></textarea>~
- ~<template><svg><![CDATA[cdata]]></svg></template>~

ç”¨ä¾‹ä»£ç ï¼š

#+begin_src js
  const ast = baseParse(code, {
    getNamespace: (tag, parent) => {
      // è¿™é‡Œä½œç”¨æ˜¯æ”¹å˜å‘½åç©ºé—´ï¼Œä»è€Œåœ¨ parseChildren while å¾ªç¯é‡Œé¢
      // èƒ½è¿›å…¥åˆ° parseCDATA è§£æ svg
      const ns = parent ? parent.ns : Namespaces.HTML;
      if (ns === Namespaces.HTML) {
        if (tag === "svg") {
          return Namespaces.HTML + 1;
        }
      }
      return ns;
    },
    getTextMode: ({ tag }) => {
      // è¿™é‡Œä½œç”¨æ”¹å˜ textarea æ ‡ç­¾çš„ mode = RCDATAï¼Œä»è€Œåœ¨ parseChildren while
      // é‡Œé¢å°† textarea å†…éƒ¨çš„éƒ½å½“åšæ–‡æœ¬äº¤ç»™ parseText å»è§£æï¼ŒparseText é‡Œé¢ä¼šä»
      // </div></textarea> ç¬¬äºŒä¸ªå­—ç¬¦å¼€å§‹åŒ¹é… `<` æˆ– `{{` ä»¥ç¤ºç»“æŸæ ‡ç­¾çš„å¼€å§‹ä½ç½®
      // æœ€åè§£æå‡º `</div>` è¿™ä¸ªçº¯æ–‡æœ¬ï¼Œå‰©ä¸‹çš„ </textarea> è¿›å…¥ isEnd
      // åœ¨å®ç° isEnd é‡Œé¢çš„ case RCDATA åˆ†æ”¯åé¡ºåˆ©æ¨å‡ºå¾ªç¯
      if (tag === "textarea") {
        return TextModes.RCDATA;
      }
      if (tag === "script") {
        return TextModes.RAWTEXT;
      }
      return TextModes.DATA;
    },
    ...options,
    onError: spy,
  });
#+end_src

å¤§éƒ¨åˆ†éƒ½èƒ½é€šè¿‡ï¼Œåªæœ‰å°‘éƒ¨åˆ†ä¸èƒ½é€šè¿‡çš„åˆ†ä¸ºå‡ ç§ï¼š
1. CDATA ç±»å‹å¤„ç†ï¼Œéœ€è¦å®ç° parseBogusComment å’Œ parseCDATA ä¸¤ä¸ªå‡½æ•°
2. RCDATA ç±»å‹å‡ ä¸ªç”¨ä¾‹ä¸èƒ½é€šè¿‡ï¼ŒåŸå› åœ¨äºåœ¨ isEnd å‡½æ•°ä¸­æ²¡æœ‰å®ç°é™¤ DATA ç±»å‹å¤–çš„
   æƒ…å†µï¼Œå®ç°ä¹‹åå°±èƒ½æ­£å¸¸æ£€æµ‹ RCDATA çš„ç»“æŸæ ‡ç­¾ã€‚
   #+begin_src js
     function isEnd(
       context /*ParserContext*/,
       mode /*TextModes*/,
       ancestors /*ElementNode[]*/
     ) /*boolean*/ {
       const s = context.source;

       // mode ä¸º TextModes å„ç§æƒ…å†µ
       // ...çœç•¥
       switch (mode) {
         case TextModes.DATA:
           if (s.startsWith("</")) {
             // æ ‡ç­¾
             for (let i = ancestors.length - 1; i >= 0; --i) {
               if (startsWithEndTagOpen(s, ancestors[i].tag)) {
                 return true;
               }
             }
           }
           // æ–°å¢ - start
         case TextModes.RCDATA:
         case TextModes.RAWTEXT: {
           const parent = last(ancestors);
           if (parent && startsWithEndTagOpen(s, parent.tag)) {
             return true;
           }
           break;
         }
         case TextModes.CDATA:
           if (s.startsWith("]]>")) {
             return true;
           }
           break;
           // æ–°å¢ - end
       }

       // æ˜¯ TextModes.TEXT ç›´æ¥è¿”å› source çš„å†…å®¹æ˜¯å¦ä¸ºç©ºäº†
       return !s;
     }
   #+end_src

*** æ³¨é‡Šåä¾‹(åµŒå¥—æ³¨é‡Š)ï¼š
:PROPERTIES:
:COLUMNS: %CUSTOM_ID[(Custom Id)]
:CUSTOM_ID: test-parse-errors-comment
:END: 

1. ~<template><!--a<!--b--></template>~
2. ~<template><!--a<!--b<!--c--></template>~
3. ~<template><!--a<!--></template>~
4. ~<template><!--a<!--~
** å…¶ä»–ç”¨ä¾‹
*** 02-valid/invalid html
:PROPERTIES:
:COLUMNS:  %CUSTOM_ID[(Custom Id)]
:CUSTOM_ID: parse-test-other-02
:END:

#+begin_src js
  test("valid html", () => {
    const ast = baseParse(
      `<div :class="{ some: condition }">\n` +
        `  <p v-bind:style="{ color: 'red' }"/>\n` +
        `  <!-- a comment with <html> inside it -->\n` +
        `</div>`
    );

    expect(ast).toMatchSnapshot();

    expect(ast.children).toHaveLength(1);
    const el = ast.children[0];
    expect(el).toMatchObject({
      tag: "div",
    });
    expect(el.children).toHaveLength(2);
    expect(el.children[0]).toMatchObject({
      tag: "p",
    });
    expect(el.children[1]).toMatchObject({
      type: NodeTypes.COMMENT,
    });
  });

  test("invalid html", () => {
    expect(() => {
      baseParse(`<div>\n<span>\n</div>\n</span>`);
    }).toThrow("Element is missing end tag.");

    const spy = jest.fn();
    const ast = baseParse(`<div>\n<span>\n</div>\n</span>`, {
      onError: spy,
    });

    expect(spy.mock.calls).toMatchObject([
      [
        {
          code: ErrorCodes.X_MISSING_END_TAG,
          loc: {
            start: {
              offset: 6,
              line: 2,
              column: 1,
            },
          },
        },
      ],
      [
        {
          code: ErrorCodes.X_INVALID_END_TAG,
          loc: {
            start: {
              offset: 20,
              line: 4,
              column: 1,
            },
          },
        },
      ],
    ]);

    expect(ast).toMatchSnapshot();
  });
#+end_src

è¿™é‡Œè¦åˆ†æçš„æ˜¯ invalid html, è¿™ä¸ªç”¨ä¾‹æ‹¿å‡ºæ¥è¯´ä¸»è¦åŸå› æ˜¯å®ƒèƒ½å¸®åŠ©æˆ‘ä»¬æ›´å¥½çš„ç†è§£æ ‡
ç­¾åµŒå¥—æ—¶å€™çš„è§£æè¿‡ç¨‹ã€‚

~<div>\n<span>\n</div>\n</span>~

å¤§è‡´è§£ææµç¨‹æ˜¯ï¼š parseChildren -> parseElement -> parseTag -> parseChildren ->
parseElement -> parseTag -> æŠ¥é”™

debugger local æ•°æ®(è§£æå®Œ *<span>* ä¹‹å):
#+begin_src json
  Local
  ancestors: Array(1)
  0: {type: 1, ns: 0, tag: "div", tagType: 0, props: Array(0), â€¦}
  length: 1
  children: []
  context:
  column: 1
  inPref: false
  inVPref: false
  line: 3
  offset: 13
  options: {delimiters: Array(2), getNamespace: Æ’, getTextMode: Æ’, isVoidTag: Æ’, isPreTag: Æ’, â€¦}
  originalSource: "<div>â†µ<span>â†µ</div>â†µ</span>"
  source: "</div>â†µ</span>"
#+end_src

1. è§£æå‡º div æ ‡ç­¾ï¼Œæ‰€ä»¥ ~ancestors.length === 1~
2. è§£æå‡º span æ ‡ç­¾ï¼Œancestors.length åº”è¯¥æ˜¯ 2ï¼Œä½†æ˜¯ä¸Šé¢æˆ‘ä»¬åªä¿ç•™äº† span è§£æä¹‹
   åçš„æ•°æ®ï¼Œæ‰€ä»¥ ancestors.span è¢« ~pop()~ æ‰äº†ï¼Œå› ä¸ºå®ƒä¸æ˜¯é‡ç‚¹
3. è§£æå®Œ span ä¹‹åä¼šå»è§£æ \n ï¼Œä½†æ˜¯ä¼šè¢« removedWhitespace é‚£æ®µé€»è¾‘è¿‡æ»¤æ‰(æ»¡è¶³
   åœ¨ pre å’Œ next ä¹‹é—´æ¡ä»¶)
4. é‚£ä¹ˆé‡ç‚¹åœ¨è¿™ï¼Œåˆ°è¿™ä¸€æ­¥ä¹Ÿæ˜¯ä¸Šé¢ä»£ç  ~source = `</div>\n</span>`~ çš„æ—¶å€™
5. æ£€æµ‹åˆ° *</* å¼€å§‹ç»“æŸæ ‡ç­¾è§£æï¼Œæ³¨æ„çœ‹ [[#parse-parseelement][parseElement]] ä¸­æœ‰è¿™ä¹ˆä¸€æ®µ

   #+begin_src js
     if (startsWithEndTagOpen(context.source, element.tag)) {
       parseTag(context, TagType.End, parent);
     }
   #+end_src

   ç»è¿‡ 4 ä¹‹åçš„ source åˆšå¥½èƒ½æ»¡è¶³è¿™ä¸ª if ï¼Œå› æ­¤æºå¸¦ TagType.End è¿›å…¥ [[#parse-parsetag][parseTag]]ï¼Œ
   æ­¤æ—¶æœ‰ä¸ªå˜é‡ *parent* ä¿å­˜äº† ~pop()~ ä¹‹å‰çš„é‚£ä¸ª ~ancestors[1]~ å³ span é‚£ä¸ªæ ‡ç­¾
   ï¼Œä½†æ˜¯è¿™é‡Œçš„ç»“æŸæ ‡ç­¾æ˜¯ *div* æœ€åä¼šåŒ¹é…å¤±è´¥ï¼ŒæŠ›å‡ºå¼‚å¸¸ã€‚

*** 01-self closing single/multiple tag
:PROPERTIES:
:COLUMNS:  %CUSTOM_ID[(Custom Id)]
:CUSTOM_ID: parse-test-other-01
:END:

#+begin_src typescript
  /*
    ä¸ç®¡æ˜¯å•æ ‡ç­¾è¿˜æ˜¯å¤šæ ‡ç­¾ä¹Ÿå¥½ï¼Œè‡ªé—­åˆæ ‡ç­¾çš„å¤„ç†éƒ½ä¸€æ ·ï¼Œåœ¨ parseTag é‡Œé¢è§£æéƒ½éœ€è¦ç»è¿‡è¿™ä¹ˆ
    ä¸€æ®µï¼šadvanceBy(context, isSelfClosing ? 2 : 1);
    ç„¶åç»“åˆ parseElement ä¸­çš„æ£€æµ‹ isSelfClosing ç›´æ¥é€€å‡ºè¿”å›å…ƒç´ èŠ‚ç‚¹ï¼Œå³ä¸éœ€è¦å†ç»§ç»­
    è§£æå­èŠ‚ç‚¹äº†(å®ƒæ²¡æœ‰)
  ,*/
  test('self closing single tag', () => {
      const ast = baseParse('<div :class="{ some: condition }" />')

      expect(ast.children).toHaveLength(1)
      expect(ast.children[0]).toMatchObject({ tag: 'div' })
  })

  test('self closing multiple tag', () => {
      const ast = baseParse(
          `<div :class="{ some: condition }" />\n` +
              `<p v-bind:style="{ color: 'red' }"/>`
      )

      expect(ast).toMatchSnapshot()

      expect(ast.children).toHaveLength(2)
      expect(ast.children[0]).toMatchObject({ tag: 'div' })
      expect(ast.children[1]).toMatchObject({ tag: 'p' })
  })
#+end_src
** Element å…ƒç´ æ ‡ç­¾è§£æ
*** 13-ç»“æŸæ ‡ç­¾å¿½ç•¥å¤§å°å†™
:PROPERTIES:
:COLUMNS:  %CUSTOM_ID[(Custom Id)]
:CUSTOM_ID: test-element-13
:END:

~<div>hello</DIV>after~

å› ä¸ºè§£æåˆ°ç»“æŸæ ‡ç­¾çš„æ—¶å€™åŒ¹é…ç»“æŸæ ‡ç­¾åç§°çš„æ—¶å€™ä¼šè°ƒç”¨ [[#parse-startswithendtagopen][startsWithEndTagOpen]] æ£€æµ‹ï¼Œ
ä¸”é‡Œé¢æ˜¯å¿½ç•¥å¤§å°å†™çš„ï¼Œç»Ÿä¸€è½¬æˆå°å†™å»æ¯”è¾ƒã€‚
#+begin_src js
  // åŒ¹é…ï¼š</tag> æˆ–</tag æ²¡æœ‰ `>` çš„æƒ…å†µ???
  function startsWithEndTagOpen(source, tag) {
    return (
      source.startsWith("</") &&
        source.substr(2, tag.length).toLowerCase() === tag.toLowerCase() &&
        /[\t\n\f />]/.test(source[2 + tag.length] || ">")
    );
  }
#+end_src
*** 12-v-pre ç”¨ä¾‹æµ‹è¯•
:PROPERTIES:
:COLUMNS:  %CUSTOM_ID[(Custom Id)]
:CUSTOM_ID: test-element-12
:END:

~`<div v-pre :id="foo"><Comp/>{{ bar }}</div>\n` + `<div :id="foo"><Comp/>{{ bar }}</div>`~

ç°é˜¶æ®µä»£ç æš‚æ—¶æ˜¯ä¸æ”¯æŒçš„ *v-pre* çš„ã€‚æ‰€ä»¥è§£æä¹‹åä¼šå‡ºç°ä¸‹é¢çš„ç»“æœï¼š

~root.children[3]~ æœ‰ä¸‰ä¸ªå­©å­èŠ‚ç‚¹
1. first: div v-pre(è¿˜æ²¡å®ç°æ‰€ä»¥å½“åšæ™®é€šæ ‡ç­¾å¤„ç†)ï¼Œfirst.children[2] æœ‰ä¸¤ä¸ªå­©å­
   1. component ç±»å‹çš„ ~<Comp/>~ å› ä¸ºé¦–å­—æ¯å¤§å†™æ‰€ä»¥å½“åšç»„ä»¶ç±»å‹å¤„ç†
   2. bar æ’å€¼èŠ‚ç‚¹
2. second: \n æ–‡æœ¬èŠ‚ç‚¹
3. third: div :idï¼Œthird.children[2] ä¹Ÿæœ‰ä¸¤ä¸ªå­©å­å’Œ first ä¸€æ ·

#+begin_src json
  (3)Â [{â€¦}, {â€¦}, {â€¦}]
  0: {type: 1, ns: 0, tag: "div", tagType: 0, props: Array(1),Â â€¦}
  1: {type: 2, content: "â†µ", loc: {â€¦}}
  2: {type: 1, ns: 0, tag: "div", tagType: 0, props: Array(1),Â â€¦}length: 3__proto__: Array(0)
#+end_src

å®ç°ä¹‹åï¼š
#+begin_example
0: {type: 1, ns: 0, tag: "div", tagType: 0, props: Array(1), â€¦}
1: null
2: {type: 1, ns: 0, tag: "div", tagType: 0, props: Array(1), â€¦}
length: 3
__proto__: Array(0)
#+end_example

è¦é€šè¿‡è¯¥ç”¨ä¾‹éœ€è¦ä¿®æ”¹çš„ç‚¹ï¼š

1. [[#parse-parsechildren][parseChildren]] é‡Œè¦æ·»åŠ åˆ é™¤ç©ºå­—ç¬¦æ¢è¡Œç¬¦æ“ä½œ
   #+begin_src js
     function parseChildren(
       context /* ParserContext*/,
       mode /*TextModes*/,
       ancestors /*ElementNode[]*/
     ) {
       // ...
       const parent = last(ancestors);
       const ns = parent ? parent.ns : Namespaces.HTML;
       const nodes /*TemplateChildNode[]*/ = [];

       // ... çœç•¥ while

       // æ–°å¢-start
       let removedWhitespace = false;
       // TODO ç©ºæ ¼ç®¡ç†ï¼Œä¸ºäº†æ›´é«˜æ•ˆçš„è¾“å‡º
       // `\n<div>...` åˆ é™¤å¼€å¤´çš„ç©ºæ ¼å­—ç¬¦ï¼Œä¹‹å‰è§£æ v-pre ç”¨ä¾‹æ˜¯å¡åœ¨è¿™é‡Œäº†
       // è¿™é‡Œå¿˜è®°å®ç°äº†ï¼Œæ‰€ä»¥ç”¨ä¾‹ http://www.cheng92.com/vue/vue3-source-code-compiler-core-parse_ts/#headline-3
       // å¾—åˆ°äº†ä¸‰ä¸ª childï¼Œç¬¬äºŒä¸ªæ˜¯ \nï¼Œå°±æ˜¯å› ä¸ºè¿™é‡Œæ²¡å®ç°è¿‡æ»¤

       if (mode !== TextModes.RAWTEXT) {
         if (!context.inPre) {
           for (let i = 0; i < nodes.length; i++) {
             const node = nodes[i];
             if (node.type === NodeTypes.TEXT) {
               if (!/[^\t\r\n\f ]/.test(node.content)) {
                 const prev = nodes[i - 1];
                 const next = nodes[i + 1];
                 // 1. ç©ºæ ¼æ˜¯ç¬¬ä¸€ä¸ªæˆ–è€…æœ€åä¸€ä¸ªèŠ‚ç‚¹ï¼Œæˆ–è€…
                 // 2. ç©ºæ ¼ä¸æ³¨é‡ŠèŠ‚ç‚¹ç›¸é‚»
                 // 3. ç©ºæ ¼åœ¨ä¸¤ä¸ªå…ƒç´ ä¹‹é—´ï¼Œå°±æˆ‘ä»¬é‡åˆ°çš„ <div></div>\n<div>...
                 // ä¸Šé¢ä¸‰ç§æƒ…å†µçš„ç©ºæ ¼ä¼šè¢«å¿½ç•¥
                 if (
                   !prev ||
                     !next ||
                     prev.type === NodeTypes.COMMENT ||
                     next.type === NodeTypes.COMMENT ||
                     (prev.type === NodeTypes.ELEMENT &&
                      next.type === NodeTypes.ELEMENT &&
                      /[\r\n]/.test(node.content))
                 ) {
                   removedWhitespace = true;
                   nodes[i] = null;
                 } else {
                   // å¦åˆ™æ›¿æ¢æˆç©ºæ ¼
                   node.content = " ";
                 }
               } else {
                 // æ›¿æ¢æˆç©ºæ ¼
                 node.content = node.content.replace(/[\t\r\n\f ]+/g, " ");
               }
             }
           }
         } else if (parent && context.options.isPreTag(parent.tag)) {
           //å¦‚æœæ˜¯ <pre> åˆ æ‰ç¬¬ä¸€è¡Œçš„ç©ºè¡Œ
           const first = nodes[0];
           if (first && first.type === NodeTypes.TEXT) {
             first.content = first.content.replace(/^\r?\n/, "");
           }
         }
       }
       // <<<<<< æ–°å¢-end
       return removedWhitespace ? nodes.filter(Boolean) : nodes;
     }
   #+end_src
2. ä¿®æ”¹ [[#parse-parsetag][parseTag]] å¢åŠ  v-pre, <pre> ä»£ç å¤„ç†

   è¿™é‡Œä¼šæœ‰ä¸ªå€¼å¾—æ³¨æ„çš„åœ°æ–¹å°±æ˜¯å®ƒæ£€æµ‹åˆ°æ˜¯ pre ä¼šå›å¤´é‡æ–°è§£æå±æ€§ï¼Œç„¶åè¿‡æ»¤æ‰
   v-pre æŒ‡ä»¤ï¼Œå¹¶ä¸”åœ¨ [[#parse-parseattribute][parseAttribute]] é‡Œé¢ä¼šæ£€æµ‹åˆ° inVPre ä»æ¥ä¸ä¼šè¿›
   è¡ŒæŒ‡ä»¤è§£æï¼Œåªä¼šè§£ææ™®é€šçš„ propsã€‚

   #+begin_src js

     function parseTag(context, type, parent) {
       // ...

       // æ–°å¢-start
       if (context.options.isPreTag(tag)) {
         context.inPre = true;
       }

       // 1. inVPre = false å› ä¸ºåˆå§‹åŒ–é»˜è®¤ä¸ä¼šæ˜¯ v-pre çš„
       // 2. åªè¦å±æ€§åˆ—è¡¨ä¸­æœ‰ä¸€ä¸ªæ»¡è¶³ï¼šv-pre æŒ‡ä»¤ç±»å‹
       if (
         !context.inVPre &&
           props.some((p) => p.type === NodeTypes.DIRECTIVE && p.name === "pre")
       ) {
         context.inVPre = true;
         // è¿™é‡Œæ¢å¤ä¹‹å‰çš„è§£æï¼Œå› ä¸º <div v-pre>...</div> èµ°åˆ°è¿™é‡Œçš„æ—¶å€™å·²ç»è§£æå®Œäº†
         // æ‰€ä»¥è¦æ¢å¤å±æ€§å­—ç¬¦ä¸²ï¼Ÿ
         extend(context, cursor);
         context.source = currentSource;
         // ä¸ºä»€ä¹ˆè¦é‡æ–°è§£æï¼Œç›´æ¥è¿‡æ»¤ä¸å¥½å—ï¼Ÿ
         // å› ä¸º parseAttribute ä¸­åœ¨ inVPre = true æƒ…å†µä¸‹æ˜¯ä¸ä¼šå»è§£æå…¶ä»–æŒ‡ä»¤å±æ€§çš„
         // å…¶ä»–æŒ‡ä»¤ç…§æ ·ä¼šè§£æï¼Œç›´æ¥è¿‡æ»¤æ‰æ‰€æœ‰æŒ‡ä»¤å±æ€§ä¸å°±å¥½äº†ï¼Ÿ
         props = parseAttributes(context, type).filter((p) => p.name !== "v-pre");
       }
       // æ–°å¢-end

       // ...

       const val = {
         type: NodeTypes.ELEMENT,
         ns,
         tag,
         tagType,
         props,
         isSelfClosing,
         children: [],
         loc: getSelection(context, start),
         codegenNode: undefined,
       };
       return val;
     }
   #+end_src
*** 11-~<div> id=a/></div>~ å±æ€§å€¼ä¸­æ²¡æœ‰å¼•å·æ—¶

æ²¡æœ‰å¼•å·çš„æ—¶å€™æœ‰ä¸€äº›éæ³•å­—ç¬¦ï¼š ~const unexpectedChars = /["'<=`]/g;~ ï¼Œé‡åˆ°è¿™äº›
å€¼çš„æ—¶å€™ä¼šæŠ¥é”™ã€‚

åœ¨è¿™ä¹‹å‰æœ‰ä¸€ä¸ªåŒ¹é…ä½¿ç”¨æ¥åŒ¹é…å‡ºå€¼çš„ï¼š

~const match = /^[^\t\r\n\f >]+/.exec(context.source);~

è¿™ä¸ªä¼šå°† *>* ä¹‹å‰çš„ *=* ä¹‹åçš„å±æ€§å€¼åŒ¹é…å‡ºæ¥ï¼Œç„¶åäº¤ç»™ [[#parse-parsetextdata][parseTextData]] è¿›è¡Œè§£æã€‚

*** 10-~<div> id=">\'"></div>~ å±æ€§å€¼ä¸­æœ‰å¼•å·æ—¶
:PROPERTIES:
:COLUMNS:  %CUSTOM_ID[(Custom Id)]
:CUSTOM_ID: test-element-10
:END:

è¿™ç§æƒ…å†µæ˜¯åˆæ³•çš„ï¼Œå±æ€§å€¼é‡Œé¢çš„å†…å®¹ä¼šè¢«å½“åšçº¯æ–‡æœ¬å¤„ç†ã€‚

#+begin_example
props: Array(1)
0:
  name: "id"
  type: 6
  value:
    content: ">'" // å±æ€§å€¼
    type: 2
#+end_example

è¿™ä¸ªå¤„ç†è·Ÿ [[#test-element-09][ç”¨ä¾‹09]] æ˜¯ä¸€æ ·çš„é€»è¾‘

å¤šä¸ªå±æ€§çš„æƒ…å†µï¼Œåœ¨ parseAttributes ä¸­æœ‰ä¸ª while å¾ªç¯å¤„ç†ã€‚

#+begin_src typescript

  function parseAttributes(
      context: ParserContext,
      type: TagType
  ): (AttributeNode | DirectiveNode)[] {
      const props = []
      const attributeNames = new Set<string>()
      while (
          context.source.length > 0 &&
              !startsWith(context.source, '>') &&
              !startsWith(context.source, '/>')
      ) {
          // ...

          const attr = parseAttribute(context, attributeNames)
          // ...
      }
      return props
  }
#+end_src

*** 09-~<div id=""></div>~ å±æ€§å€¼ä¸ºç©ºçš„æƒ…å†µ
:PROPERTIES:
:COLUMNS:  %CUSTOM_ID[(Custom Id)]
:CUSTOM_ID: test-element-09
:END:

#+begin_src typescript

  test('attribute with empty value, double quote', () => {
      const ast = baseParse('<div id=""></div>')
      const element = ast.children[0] as ElementNode

      expect(element).toStrictEqual({
          type: NodeTypes.ELEMENT,
          ns: Namespaces.HTML,
          tag: 'div',
          tagType: ElementTypes.ELEMENT,
          codegenNode: undefined,
          props: [
              {
                  type: NodeTypes.ATTRIBUTE,
                  name: 'id',
                  value: {
                      type: NodeTypes.TEXT,
                      content: '',
                      loc: {
                          start: { offset: 8, line: 1, column: 9 },
                          end: { offset: 10, line: 1, column: 11 },
                          source: '""'
                      }
                  },
                  loc: {
                      start: { offset: 5, line: 1, column: 6 },
                      end: { offset: 10, line: 1, column: 11 },
                      source: 'id=""'
                  }
              }
          ],

          isSelfClosing: false,
          children: [],
          loc: {
              start: { offset: 0, line: 1, column: 1 },
              end: { offset: 17, line: 1, column: 18 },
              source: '<div id=""></div>'
          }
      })
  })
#+end_src

è§£æï¼š [[#parse-parsetag][parseTag]] -> [[#parse-parseattributes][parseAttributes]] -> [[#parse-parseattribute][parseAttribute]] -> [[#parse-parseattributevalue][parseAttributeValue]]
-> [[#parse-parsetextdata][parseTextData]] ç›´æ¥è¿”å›ç©ºå­—ç¬¦ä¸²ï¼Œç»„ç»‡ï¼š ~{ type, content: '', ... }~ è¿”å›

#+begin_src typescript

  function parseAttributeValue(
      context: ParserContext
  ) {
      // ...çœç•¥

      const quote = context.source[0]
      const isQuoted = quote === `"` || quote === `'`
      if (isQuoted) { // id=""ï¼Œæœ‰å¼•å·
          // Quoted value.
          advanceBy(context, 1)

          const endIndex = context.source.indexOf(quote)
          if (endIndex === -1) {
              content = parseTextData(
                  context,
                  context.source.length,
                  TextModes.ATTRIBUTE_VALUE
              )
          } else {
              // åˆ°è¿™é‡Œ
              content = parseTextData(context, endIndex, TextModes.ATTRIBUTE_VALUE)
              advanceBy(context, 1)
          }
      } else {
          // ä¸ä¼šåˆ°è¿™é‡Œ
      }

      return { content, isQuoted, loc: getSelection(context, start) }
  }
#+end_src

*** 08-~<div id></div>~ æ— å±æ€§å€¼çš„å±æ€§
:PROPERTIES:
:COLUMNS:  %CUSTOM_ID[(Custom Id)]
:CUSTOM_ID: test-element-08
:END:

#+begin_src js
  test("attribute with no value", () => {
    const ast = baseParse("<div id></div>");
    const element = ast.children[0];

    expect(element).toStrictEqual({
      type: NodeTypes.ELEMENT,
      ns: Namespaces.HTML,
      tag: "div",
      tagType: ElementTypes.ELEMENT,
      codegenNode: undefined,
      props: [
        {
          type: NodeTypes.ATTRIBUTE,
          name: "id",
          value: undefined,
          loc: {
            start: { offset: 5, line: 1, column: 6 },
            end: { offset: 7, line: 1, column: 8 },
            source: "id",
          },
        },
      ],

      isSelfClosing: false,
      children: [],
      loc: {
        start: { offset: 0, line: 1, column: 1 },
        end: { offset: 14, line: 1, column: 15 },
        source: "<div id></div>",
      },
    });
  }); // attribute with no value
#+end_src

è§£æï¼š [[#parse-parsetag][parseTag]] -> [[#parse-parseattributes][parseAttributes]] -> [[#parse-parseattribute][parseAttribute]] é‡Œé¢æœ‰ä¸€æ®µé’ˆå¯¹å±æ€§å€¼å¤„ç†

#+begin_src typescript
  function parseAttribute(
      context: ParserContext,
      nameSet: Set<string>
  ): AttributeNode | DirectiveNode {
      // ... çœç•¥

      // è¿™é‡Œæ£€æµ‹æ˜¯ä¸æ˜¯æœ‰ name= æˆ– name=value æƒ…å†µ
      if (/^[\t\r\n\f ]*=/.test(context.source)) {
          advanceSpaces(context)
          advanceBy(context, 1)
          advanceSpaces(context)
          value = parseAttributeValue(context)
          // è¿™é‡Œæ˜¯é˜²æ­¢ name= åé¢æ²¡æœ‰å€¼å¾—æƒ…å†µæŠ¥é”™
          if (!value) {
              emitError(context, ErrorCodes.MISSING_ATTRIBUTE_VALUE)
          }
      }

      // ... å› ä¸º id æ²¡æœ‰ id=? æ‰€ä»¥ç›´æ¥å›åˆ°è¿™é‡Œï¼Œä¸ä¼šè¿›å…¥
      // parseAttributeValue è§£æå±æ€§å€¼

      // ... id éæŒ‡ä»¤å±æ€§ï¼Œæ‰€ä»¥ç›´æ¥åˆ°æœ€åä»¥æ™®é€šå±æ€§ç±»å‹é€€å‡º
      return {
          type: NodeTypes.ATTRIBUTE,
          name,
          value: value && {
              type: NodeTypes.TEXT,
              content: value.content,
              loc: value.loc
          },
          loc
      }
  }
#+end_src

*** 07-isCustomElement è‡ªå®šä¹‰å…ƒç´ 
:PROPERTIES:
:COLUMNS:  %CUSTOM_ID[(Custom Id)]
:CUSTOM_ID: test-element-07
:END:

#+begin_src js
  test("custom element", () => {
    const ast = baseParse("<div></div><comp></comp>", {
      isNativeTag: (tag) => tag === "div",
      isCustomElement: (tag) => tag === "comp",
    });

    expect(ast.children[0]).toMatchObject({
      type: NodeTypes.ELEMENT,
      tag: "div",
      tagType: ElementTypes.ELEMENT, // ç”±äºæ˜¯ isNativeTag() ä½¿ç”¨äº†é»˜è®¤ ELEMENT
    });

    expect(ast.children[1]).toMatchObject({
      type: NodeTypes.ELEMENT,
      tag: "comp",
      tagType: ElementTypes.ELEMENT, // ç”±äºæ˜¯ isCustomElement() æ‰€ä»¥å‹æ ¹ä¸ä¼šè¿›å…¥åˆ° if ... ä¸­æ£€æµ‹ç±»å‹
    });
  })
#+end_src

è‡ªå®šä¹‰ç±»å‹åˆ¤æ–­ï¼š

#+begin_src typescript

  function parseTag(
      context: ParserContext,
      type: TagType,
      parent: ElementNode | undefined
  ): ElementNode {
      // ... çœç•¥

      let tagType = ElementTypes.ELEMENT
      const options = context.options
      // <comp> ç”±äºæ˜¯ isCustomElement å› æ­¤å‹æ ¹ä¸ä¼šè¿›å…¥ä¸‹é¢çš„ if (false) ...
      if (!context.inVPre && !options.isCustomElement(tag)) {
          const hasVIs = props.some(
              p => p.type === NodeTypes.DIRECTIVE && p.name === 'is'
          )
          if (options.isNativeTag && !hasVIs) {
              // div ä¼šè¿›å…¥åˆ°è¿™é‡Œï¼Œä½†æ˜¯æ£€æµ‹å¤±è´¥ if (!true) ...
              if (!options.isNativeTag(tag)) tagType = ElementTypes.COMPONENT
          } else if (
              // div è¿™é‡Œéƒ½ä¸æ»¡è¶³ï¼Œif (false) ...
              hasVIs ||
                  isCoreComponent(tag) ||
                  (options.isBuiltInComponent && options.isBuiltInComponent(tag)) ||
                  /^[A-Z]/.test(tag) ||
                  tag === 'component'
          ) {
              tagType = ElementTypes.COMPONENT
          }

          if (tag === 'slot') {
              tagType = ElementTypes.SLOT
          } else if (
              tag === 'template' &&
                  props.some(p => {
                      return (
                          p.type === NodeTypes.DIRECTIVE && isSpecialTemplateDirective(p.name)
                      )
                  })
          ) {
              tagType = ElementTypes.TEMPLATE
          }
      }

      // æ‰€ä»¥ <div> æœ€ç»ˆä½¿ç”¨äº†é»˜è®¤å€¼ï¼šELEMENT
      // æ‰€ä»¥ <comp> ç›´æ¥åˆ°äº†è¿™é‡Œï¼Œæ˜¯ï¼šELEMENT ç±»å‹
      return {
          type: NodeTypes.ELEMENT,
          ns,
          tag,
          tagType,
          props,
          isSelfClosing,
          children: [],
          loc: getSelection(context, start),
          codegenNode: undefined // to be created during transform phase
      }
  }
#+end_src
*** 06-isNativeTag åŸç”Ÿæ ‡ç­¾ç±»å‹
:PROPERTIES:
:COLUMNS:  %CUSTOM_ID[(Custom Id)]
:CUSTOM_ID: test-element-06
:END:

è¿™ä¸ªç”¨ä¾‹(~<div></div><comp></comp><Comp></Comp>~)é‡Œé¢æœ‰ä¸‰ä¸ªæ ‡ç­¾ï¼š
1. =div=
2. =comp=
3. =Comp=


åŒæ—¶ä¼ é€’ä¸€ä¸ª ~options: { isNativeTag: tag => tag === 'div' }~

æ„æ€å‘Šè¯‰ç¼–è¯‘å™¨è¿™é‡Œé¢åªæœ‰ *div* å±äºåŸç”Ÿæ ‡ç­¾ï¼Œå…¶ä»–çš„éƒ½å±äºç»„ä»¶ç±»å‹ï¼Œè¿™ä¸ªåœ¨ [[#parse-parsetag][parseTag]]
å®ç°ä¸­ä½“ç°å‡ºæ¥ã€‚

#+begin_src js
  test("native element with `isNativeTag`", () => {
    const ast = baseParse("<div></div><comp></comp><Comp></Comp>", {
      isNativeTag: (tag) => tag === "div",
    });

    expect(ast.children[0]).toMatchObject({
      type: NodeTypes.ELEMENT,
      tag: "div",
      tagType: ElementTypes.ELEMENT,
    });

    expect(ast.children[1]).toMatchObject({
      type: NodeTypes.ELEMENT,
      tag: "comp",
      tagType: ElementTypes.COMPONENT,
    });

    expect(ast.children[2]).toMatchObject({
      type: NodeTypes.ELEMENT,
      tag: "Comp",
      tagType: ElementTypes.COMPONENT,
    });
  }); // native element with `isNativeTag`
#+end_src

é€šè¿‡è¯¥ç”¨ä¾‹çš„ä»£ç å®ç°ç‰‡æ®µ(åœ¨[[#test-element-05][ç”¨ä¾‹ 05]] ä¸­å°±å·²ç»å®ç°è¿‡äº†ï¼Œå› æ­¤è¯¥ç”¨ä¾‹é¡ºåˆ©é€šè¿‡)ï¼š

#+begin_src typescript
  function parseTag(
      context: ParserContext,
      type: TagType,
      parent: ElementNode | undefined
  ): ElementNode {
      // ... çœç•¥

      let tagType = ElementTypes.ELEMENT
      const options = context.options
      // å‰æï¼Œé v-pre æŒ‡ä»¤ï¼Œä¸”éè‡ªå®šä¹‰æ ‡ç­¾(é»˜è®¤ï¼šNO)
      if (!context.inVPre && !options.isCustomElement(tag)) {

          // æ˜¯å¦æœ‰ v-is æŒ‡ä»¤
          const hasVIs = props.some(
              p => p.type === NodeTypes.DIRECTIVE && p.name === 'is'
          )

          // é¦–å…ˆç”±æä¾›åŸç”Ÿæ ‡ç­¾æ£€æµ‹å‡½æ•°ï¼Œä¸”æ²¡æœ‰ v-is æƒ…å†µä¸‹è¿›å…¥ç»„ä»¶åˆ¤æ–­
          if (options.isNativeTag && !hasVIs) {
              // ç±»å‹ä¸º COMPONENT ç»„ä»¶ç±»å‹
              if (!options.isNativeTag(tag)) tagType = ElementTypes.COMPONENT
          }

          // ... çœç•¥
      }

      return {
          type: NodeTypes.ELEMENT,
          ns,
          tag,
          tagType,
          props,
          isSelfClosing,
          children: [],
          loc: getSelection(context, start),
          codegenNode: undefined // to be created during transform phase
      }
  }
#+end_src

è€Œåœ¨æ²¡æœ‰æä¾› =isNativeTag()= çš„æƒ…å†µä¸‹ï¼Œä¸‰ç§æ ‡ç­¾çš„è§£æç»“æœä¸­çš„ =tagType= åˆæ˜¯ä¸ä¸€
æ ·çš„ï¼Œå»¶ç»­ä¸Šé¢çš„å¸¦ç»§ç»­åˆ†æï¼š

#+begin_src typescript
  function parseTag(
      context: ParserContext,
      type: TagType,
      parent: ElementNode | undefined
  ): ElementNode {
      // ... çœç•¥

      let tagType = ElementTypes.ELEMENT
      const options = context.options
      // å‰æï¼Œé v-pre æŒ‡ä»¤ï¼Œä¸”éè‡ªå®šä¹‰æ ‡ç­¾(é»˜è®¤ï¼šNO)
      if (!context.inVPre && !options.isCustomElement(tag)) {

          // æ˜¯å¦æœ‰ v-is æŒ‡ä»¤
          const hasVIs = props.some(
              p => p.type === NodeTypes.DIRECTIVE && p.name === 'is'
          )

          // é¦–å…ˆç”±æä¾›åŸç”Ÿæ ‡ç­¾æ£€æµ‹å‡½æ•°ï¼Œä¸”æ²¡æœ‰ v-is æƒ…å†µä¸‹è¿›å…¥ç»„ä»¶åˆ¤æ–­
          if (options.isNativeTag && !hasVIs) {
              // ç±»å‹ä¸º COMPONENT ç»„ä»¶ç±»å‹
              if (!options.isNativeTag(tag)) tagType = ElementTypes.COMPONENT
          } else if (
              // æŠŠè¿™é‡Œçœç•¥çš„éƒ¨åˆ†åŠ ä¸Š...
              hasVIs ||
                  isCoreComponent(tag) ||
                  (options.isBuiltInComponent && options.isBuiltInComponent(tag)) ||
                  // é‡ç‚¹åœ¨è¿™é‡Œï¼Œæ£€æµ‹åˆ°å¦‚æœæ ‡ç­¾åå¼€å¤´æ˜¯å¤§å†™çš„å°±ä¼šè¢«è§†ä¸ºç»„ä»¶ç±»å‹
                  /^[A-Z]/.test(tag) ||
                  tag === 'component'
          ) {
              tagType = ElementTypes.COMPONENT
          }

          // ... çœç•¥
      }

      return {
          type: NodeTypes.ELEMENT,
          ns,
          tag,
          tagType,
          props,
          isSelfClosing,
          children: [],
          loc: getSelection(context, start),
          codegenNode: undefined // to be created during transform phase
      }
  }
#+end_src

é‚£ä¹ˆæ¥ä¸‹æ¥çš„ç”¨ä¾‹ä¹Ÿä¸æ˜¯ä»€ä¹ˆé—®é¢˜äº†ï¼š

#+begin_src js

  test('v-is without `isNativeTag`', () => {
    const ast = baseParse(
      `<div></div><div v-is="'foo'"></div><Comp></Comp>`,
      {
        isNativeTag: tag => tag === 'div'
      }
    )

    expect(ast.children[0]).toMatchObject({
      type: NodeTypes.ELEMENT,
      tag: 'div',
      tagType: ElementTypes.ELEMENT // è¿™é‡Œæ¯‹åº¸ç½®ç–‘æ˜¯é»˜è®¤åŸç”Ÿå…ƒç´ ç±»å‹
    })

    expect(ast.children[1]).toMatchObject({
      type: NodeTypes.ELEMENT,
      tag: 'div',
      // å®¹æ˜“äº§ç”Ÿç–‘é—®çš„æ˜¯è¿™ä¸ªï¼Œè¿™é‡Œä¸ºä»€ä¹ˆæ˜¯ COMPONENTï¼Œè€Œä¸æ˜¯ element å‘¢
      // è¿™é‡Œå…³é”®åœ¨äº v-isï¼Œè®°å¾—ï¼šisNativeTag() æ£€æµ‹çš„ä¼˜å…ˆçº§æœ€é«˜å‰ææ˜¯ !hasVIs æˆç«‹æƒ…å†µ
      // ç„¶è€Œè¿™é‡Œæ˜¾ç„¶ hasVIs === true
      // å› æ­¤è¿›å…¥äº† else if (... || hasVIs || ...) { tagType = ElementTypes.COMPONENT }
      tagType: ElementTypes.COMPONENT
    })

    expect(ast.children[2]).toMatchObject({
      type: NodeTypes.ELEMENT,
      tag: 'Comp',
      // è¿™é‡Œæ²¡å•¥ç–‘é—®ï¼Œå¤§å†™å¼€å¤´æ‰€ä»¥æ˜¯ç»„ä»¶ç±»å‹
      tagType: ElementTypes.COMPONENT
    })
  })
#+end_src

è‡ªå®šä¹‰ç»„ä»¶ï¼š
*** 05-template element with directives
:PROPERTIES:
:COLUMNS:  %CUSTOM_ID[(Custom Id)]
:CUSTOM_ID: test-element-05
:END:

è¿™ä¸ªç”¨ä¾‹å¼€å§‹æ¨¡æ¿çš„è§£æã€‚

#+begin_src js
  test('template element with directives', () => {
    const ast = baseParse('<template v-if="ok"></template>')
    const element = ast.children[0]
    expect(element).toMatchObject({
      type: NodeTypes.ELEMENT,
      tagType: ElementTypes.TEMPLATE
    })
  }
#+end_src

~baseParse('<template v-if="ok"></template>')~ è§£æä¹‹åçš„ç»“æ„ï¼š

#+begin_src json
  {
    "type":0,
    "children":[
      { // <template> èŠ‚ç‚¹
        "type":1,
        "ns":0,
        "tag":"template",
        "tagType":3,
        "props":[
          {
            "type":7, // DIRECTIVE
            "name":"if",
            "exp":{
              "type":4, // SIMPLE_EXPRESSION
              "content":"ok",
              "isStatic":false,
              "isConstant":false,
              "loc":{
                // ... çœç•¥
              }
            },
            "modifiers":[
              // ä¿®é¥°ç¬¦
            ],
            "loc":{
              // çœç•¥
              "source":"v-if="ok""
            }
          }
        ],
        // ... çœç•¥
      }
    ],
    // ... çœå»
  }
#+end_src

ä¸ºäº†èƒ½è§£æå‡º ~v-if="ok"~ æˆ‘ä»¬éœ€è¦å»å®ç° [[#parse-parseattributes][parseAttributes(context, type)]] ->
[[#parse-parseattribute][parseAttribute]] -> [[#parse-parseattributevalue][parseAttributeValue]]

è¯¥ç”¨ä¾‹è€ƒå¯Ÿçš„å…¶å®å¹¶ä¸æ˜¯ ~<template>~ æ¨¡æ¿æ ‡ç­¾è§£æï¼Œè€Œæ˜¯æ ‡ç­¾ä¸Šçš„å±æ€§è§£æï¼Œå¯¹æ™®é€šçš„
~<div>~ æ ‡ç­¾ä¾ç„¶å¯ä»¥è§£æå‡ºå±æ€§ props[]ã€‚

#+begin_quote
*é’ˆå¯¹æ¨¡æ¿ =<template>= æ ‡ç­¾çš„å¤„ç†è¯¦æƒ…å¯ä»¥[[/vue/vue-mind-map-house/#map-parse-template][æŸ¥çœ‹æ­¤å¤„(å«è„‘å›¾)]]ï¼Œæ›´ç›´è§‚ã€‚*
#+end_quote
*** 04-void element
:PROPERTIES:
:COLUMNS:  %CUSTOM_ID[(Custom Id)]
:CUSTOM_ID: test-element-04
:END:

ç©ºæ ‡ç­¾è§£æï¼Œå¦‚ï¼š~<img>~

å‰ææ˜¯æä¾›äº† ~isVoidTag()~ é€‰é¡¹ã€‚
#+begin_src js
  test('void element', () => {
    const ast = baseParse('<img>after', {
      isVoidTag: (tag) => tag === 'img'
    })
    const element = ast.children[0]

    expect(element).toStrictEqual({
      type: NodeTypes.ELEMENT,
      ns: Namespaces.HTML,
      tag: 'img',
      tagType: ElementTypes.ELEMENT,
      codegenNode: undefined,
      props: [],

      isSelfClosing: false,
      children: [],
      loc: {
        start: { offset: 0, line: 1, column: 1 },
        end: { offset: 5, line: 1, column: 6 },
        source: '<img>'
      }
    })
  }
#+end_src

è¯¥ç”¨ä¾‹å’Œ[[#test-element-03][è‡ªé—­æ ‡ç­¾]]ç±»ä¼¼éƒ½æ˜¯åœ¨ [[#parse-parsetag][parseTag]] è§£æå®Œä¹‹ååœ¨ [[#parse-parseelement][parseElement]] ä¸­ç»“æŸè§£æï¼Œä¸åŒç‚¹
åœ¨äºè°ƒç”¨ [[#parse-baseparse][baseParse]] çš„æ—¶å€™éœ€è¦ä¼ é€’ä¸€ä¸ªåŒ…å« ~isVoidTag()~ çš„é€‰é¡¹ ~{isVoidTag: tag
=> tag === 'img'}~ ç”¨æ¥å‘Šè¯‰è§£æå™¨ä»€ä¹ˆæ ·çš„æ ‡ç­¾å±äºç©ºæ ‡ç­¾ï¼Œå³ä¸æ˜¯ ~<img/>~ ä¹Ÿä¸æ˜¯
~<div></div>~ ç±»å‹ã€‚

[[#parse-parseelement][parseElement]] ä¸­è§£ææ¡ä»¶ï¼š

#+begin_src js
  parseElement(context, ancestors) {
    // ... parseTag ä¸­è§£æ <img ...>
    // è‡ªé—­åˆçš„åˆ°è¿™é‡Œå°±å¯ä»¥ç»“æŸäº†
    if (element.isSelfClosing || context.options.isVoidTag?.(element.tag)) {
      return element
    }
    // ...
  }
#+end_src

*** 03-self closing
:PROPERTIES:
:COLUMNS:  %CUSTOM_ID[(Custom Id)]
:CUSTOM_ID: test-element-03
:END:
#+begin_src js
  test('self closing', () => {
    const ast = baseParse('<div/>after')
    const element = ast.children[0]

    expect(element).toStrictEqual({
      type: NodeTypes.ELEMENT,
      ns: Namespaces.HTML,
      tag: 'div',
      tagType: ElementTypes.ELEMENT,
      codegenNode: undefined,
      props: [],

      isSelfClosing: true,
      children: [],
      loc: {
        start: { offset: 0, line: 1, column: 1 },
        end: { offset: 6, line: 1, column: 7 },
        source: '<div/>'
      }
    })
  }
#+end_src
*** 02-empty div
:PROPERTIES:
:COLUMNS:  %CUSTOM_ID[(Custom Id)]
:CUSTOM_ID: test-element-02
:END:

å’Œ [[#test-element-01][01-simple div]] ä¸€æ ·ï¼Œæ— éå°±æ˜¯æ²¡æœ‰ ~children[]~ å­èŠ‚ç‚¹äº†ã€‚åœ¨ [[#parse-parseelement][parseElement]] -> [[#parse-parsetag][parseTag]] è§£æå°±ç»“æŸäº†ã€‚

#+begin_src js
  test('empty div', () => {
    const ast = baseParse('<div></div>')
    const element = ast.children[0]

    expect(element).toStrictEqual({
      type: NodeTypes.ELEMENT,
      ns: Namespaces.HTML,
      tag: 'div',
      tagType: ElementTypes.ELEMENT,
      codegenNode: undefined,
      props: [],
      isSelfClosing: false,
      children: [],
      loc: {
        start: { offset: 0, line: 1, column: 1 },
        end: { offset: 11, line: 1, column: 12 },
        source: '<div></div>'
      }
    })
  }
#+end_src

*** 01-simple div
:PROPERTIES:
:COLUMNS:  %CUSTOM_ID[(Custom Id)]
:CUSTOM_ID: test-element-01
:END:

æµç¨‹å›¾ï¼š
[[/img/vue3/compiler-core/parser-test-simple-tag-div.png]]

å› ä¸º [[#parse-parseelement][parseElement]] å·²ç»å®ç°ï¼Œå› æ­¤è¿™ä¸ªé¡ºåˆ©é€šè¿‡ï¼Œ~parseElement~ è§£æå…ˆæ£€æµ‹ ~</div>~
ç»“æŸæ ‡ç­¾ä½ç½®ï¼Œå¦‚æœæ²¡æœ‰åˆ™ä¸ºéæ³•æ— ç»“æŸæ ‡ç­¾è§¦å‘ ~ErrorCodes.EOF_IN_TAG~ å¼‚å¸¸ã€‚
#+begin_src js
  test('simple div', () => {
    const ast = baseParse('<div>hello</div>')
    const element = ast.children[0]

    expect(element).toStrictEqual({
      type: NodeTypes.ELEMENT,
      ns: Namespaces.HTML,
      tag: 'div',
      tagType: ElementTypes.ELEMENT,
      codegenNode: undefined,
      props: [],
      isSelfClosing: false, // <div åä¸º > ä¸ºéè‡ªé—­åˆæ ‡ç­¾
      children: [
        {
          type: NodeTypes.TEXT,
          content: 'hello',
          loc: {
            start: { offset: 5, line: 1, column: 6 }, // h ä½ç½®ç´¢å¼•
            end: { offset: 10, line: 1, column: 11 }, // o ä½ç½®ç´¢å¼•
            source: 'hello'
          }
        }
      ],
      loc: {
        start: { offset: 0, line: 1, column: 1 },
        end: { offset: 16, line: 1, column: 17 },
        // é‡åˆ°<div> ä¼šç›´æ¥åˆ¤æ–­æ˜¯å¦æœ‰ </div> ç„¶åæˆªå–`<div>...</div>
        source: '<div>hello</div>'
      }
    })
  })
#+end_src

æ ‡ç­¾çš„è§£æåœ¨ [[#parse-parsetag][parseTag]] ä¸­å®Œæˆï¼Œ å¦‚æœæ˜¯è‡ªé—­åˆæ ‡ç­¾ï¼Œä¼šç½®æ ‡å¿—ä½ ~isSelfClosing =
true~ ã€‚

å¹¶ä¸”è§£ææ ‡ç­¾åªä¼šè§£æåˆ° =<div>= ä¸­çš„ =<div= éƒ¨åˆ†å°±ç»“æŸï¼Œæ˜¯å› ä¸ºéœ€è¦æ£€æµ‹åé¢æ˜¯ =>=
è¿˜æ˜¯ =/>= å¦‚æœæ˜¯ =/>= åˆ™ä¸ºè‡ªé—­åˆæ ‡ç­¾éœ€è¦åŒºåˆ†å¤„ç†ï¼Œå› æ­¤è¿™é‡Œä¼šæœ‰ä¸ªåˆ¤æ–­æ¥å†³å®š
=advanceBy= 1 æˆ– 2 ä¸ªæŒ‡é’ˆä½ç½®ã€‚

#+begin_src js
  // parseTag
  let isSelfClosing = false
  if (context.source.length === 0) {
    emitError(context, ErrorCodes.EOF_IN_TAG)
  } else {
    // some <div> ... </div> åˆ°è¿™é‡Œçš„ source = > ... </div>
    // æ‰€ä»¥å¯ä»¥æ£€æµ‹æ˜¯ä¸æ˜¯ä»¥ /> å¼€å¤´çš„
    isSelfClosing = context.source.startsWith('/>')
    if (type === TagType.End && isSelfClosing) {
      emitError(context, ErrorCodes.END_TAG_WITH_TRAILING_SOLIDUS)
    }
    // å¦‚æœæ˜¯è‡ªé—­åˆæŒ‡é’ˆç§»åŠ¨ä¸¤ä½(/>)ï¼Œå¦åˆ™åªç§»åŠ¨ä¸€ä½(>)
    // åˆ°è¿™é‡Œ source = ... </div>
    advanceBy(context, isSelfClosing ? 2 : 1)
  }
#+end_src

** Comment æ³¨é‡Šè§£æ
:PROPERTIES:
:COLUMNS:  %CUSTOM_ID[(Custom Id)]
:CUSTOM_ID: test-parse-comment
:END:

æ³¨é‡Šé£æ ¼ï¼š =<!-- ... -->= ï¼Œ[[#link-05][é˜¶æ®µ 5]] åŠä¹‹å‰è¿˜ä¸æ”¯æŒæ³¨é‡Šè§£æï¼Œå› ä¸ºè¿˜æ²¡å®ç° [[#parse-parsecomment][parseComment]]ã€‚

æ³¨é‡Šæµ‹è¯•ç”¨ä¾‹ä¸å­˜åœ¨é˜¶æ®µæ€§çš„å®ç°ï¼Œåªè¦å®ç°äº† [[#parse-parsecomment][parseComment]] å°±é¥¿éƒ½å¯ä»¥é€šè¿‡äº†ï¼Œå› æ­¤è¿™é‡Œæ”¾åœ¨ä¸€èµ·é€šè¿‡è®°å½•ã€‚

1. *empty comment* ç©ºæ³¨é‡ŠèŠ‚ç‚¹
2. *simple comment* æ­£å¸¸æ³¨é‡ŠèŠ‚ç‚¹
3. *two comments* å¤šä¸ªæ³¨é‡ŠèŠ‚ç‚¹

#+begin_src js
  describe('Comment', () => {
    test('empty comment', () => {
      const ast = baseParse('<!---->')
      const comment = ast.children[0]

      expect(comment).toStrictEqual({
        type: NodeTypes.COMMENT,
        content: '',
        loc: {
          start: { offset: 0, line: 1, column: 1 },
          end: { offset: 7, line: 1, column: 8 },
          source: '<!---->'
        }
      })
    }) // empty comment

    test('simple comment', () => {
      const ast = baseParse('<!--abc-->')
      const comment = ast.children[0]

      expect(comment).toStrictEqual({
        type: NodeTypes.COMMENT,
        content: 'abc',
        loc: {
          start: { offset: 0, line: 1, column: 1 },
          end: { offset: 10, line: 1, column: 11 },
          source: '<!--abc-->'
        }
      })
    }) // simple comment

    test('two comments', () => {
      const ast = baseParse('<!--abc--><!--def-->')
      const comment1 = ast.children[0]
      const comment2 = ast.children[1]

      expect(comment1).toStrictEqual({
        type: NodeTypes.COMMENT,
        content: 'abc',
        loc: {
          start: { offset: 0, line: 1, column: 1 },
          end: { offset: 10, line: 1, column: 11 },
          source: '<!--abc-->'
        }
      })
      expect(comment2).toStrictEqual({
        type: NodeTypes.COMMENT,
        content: 'def',
        loc: {
          start: { offset: 10, line: 1, column: 11 },
          end: { offset: 20, line: 1, column: 21 },
          source: '<!--def-->'
        }
      })
    }) // two comments
  })
#+end_src

è¿™é‡Œæ€»å…±æœ‰ä¸‰ä¸ªç”¨ä¾‹ï¼Œä¸€å¼€å§‹æµ‹è¯•å¹¶ä¸èƒ½é€šè¿‡ï¼Œæ˜¯å› ä¸ºå®ç° [[#parse-pushnode][pushNode]] çš„æ—¶å€™å¿˜è®°åŠ ä¸Š
=__DEV__= ç¯å¢ƒæ£€æµ‹äº†ï¼Œå› ä¸ºç”Ÿäº§ç¯å¢ƒæ˜¯ä¸éœ€è¦ä¿å­˜æ³¨é‡ŠèŠ‚ç‚¹çš„ï¼Œå¼€å‘ç¯å¢ƒä¸ºäº†æµ‹è¯•éœ€è¦æœ‰
è¿™ä¸ªä¿¡æ¯ã€‚

#+begin_src js
  function pushNode(nodes, node) {
    // è¿™é‡ŒåŠ ä¸Š __DEV__ æ£€æµ‹ï¼Œå¼€å‘çš„æ—¶å€™è¿˜æ˜¯éœ€è¦çš„
    // ä¸ç„¶ç”¨ä¾‹ä¼šé€šä¸è¿‡ï¼Œå› ä¸ºè¿™é‡Œç›´æ¥è¿”å› Undefined äº†ï¼Œå¯¼è‡´
    // parent.children[] é‡Œé¢å¹¶ä¸å­˜åœ¨è¿™ä¸ªæ³¨é‡ŠèŠ‚ç‚¹
    // åŠ ä¸Šå°±å¥½äº†
    if (!__DEV__ && node.type === NodeTypes.COMMENT) {
      // æ³¨é‡ŠèŠ‚ç‚¹ä¸å¤„ç†
      return
    }

    // ... çœç•¥
  }
#+end_src

** Interpolation æ’å€¼è§£æ

*** 05-custom delimiters
:PROPERTIES:
:COLUMNS:  %CUSTOM_ID[(Custom Id)]
:CUSTOM_ID: test-interpolation-05
:END:

è‡ªå®šä¹‰æ’å€¼åˆ†éš”ç¬¦ï¼Œå…¶å®å¤„ç†æµç¨‹å’Œæ’å€¼å¤„ç†ä¸€æ ·ï¼Œæ‰€ä»¥æ²¡å•¥å¥½è®²çš„ï¼Œ[[#link-04][é˜¶æ®µä»£ç  4]] å°±æ”¯æŒè¯¥ç”¨ä¾‹é€šè¿‡ã€‚
#+begin_src js
  test('custom delimiters', () => {
    const ast = baseParse('<p>{msg}</p>', {
      delimiters: ['{', '}']
    })
    const element = ast.children[0]
    const interpolation = element.children[0]

    expect(interpolation).toStrictEqual({
      type: NodeTypes.INTERPOLATION,
      content: {
        type: NodeTypes.SIMPLE_EXPRESSION,
        content: `msg`,
        isStatic: false,
        isConstant: false,
        loc: {
          start: { offset: 4, line: 1, column: 5 },
          end: { offset: 7, line: 1, column: 8 },
          source: 'msg'
        }
      },
      loc: {
        start: { offset: 3, line: 1, column: 4 },
        end: { offset: 8, line: 1, column: 9 },
        source: '{msg}'
      }
    })
  })
#+end_src

*** 04-it can have tag-like notation (3)
:PROPERTIES:
:COLUMNS:  %CUSTOM_ID[(Custom Id)]
:CUSTOM_ID: test-interpolation-04
:END:

å‰é¢çš„ä¸¤ä¸ªç”¨ä¾‹å·²ç»è§£é‡Šè¿‡äº†ï¼Œæ’å€¼é‡Œé¢çš„å†…å®¹ä¼šåœ¨ [[#parse-parseinterpolation][parseInterpolation]] ä¸­ç›´æ¥å¤„ç†æˆæ’
å€¼çš„æ¨¡æ¿(source)ï¼Œä¸ä¼šè¿›å…¥åˆ° while å¾ªç¯è§¦å‘å¼‚å¸¸ã€‚

#+begin_src typescript
  test('it can have tag-like notation (3)', () => {
      const ast = baseParse('<div>{{ "</div>" }}</div>')
      // è¿™é‡Œè§£æå‡ºæ¥çš„æ˜¯ <div></div> è¿™ä¸ªå…ƒç´ èŠ‚ç‚¹
      const element = ast.children[0] as ElementNode
      // æ ‡ç­¾å†…éƒ¨çš„æ‰€æœ‰å†…å®¹åœ¨è§£æä¹‹åä¼šè¢«å½“åšå­èŠ‚ç‚¹å­˜æ”¾åˆ° children[] æ•°ç»„ä¸­
      // å› æ­¤è¿™é‡Œç¬¬ä¸€ä¸ªå­èŠ‚ç‚¹æ˜¯ä¸ªæ’å€¼æ¨¡æ¿
      const interpolation = element.children[0] as InterpolationNode

      expect(interpolation).toStrictEqual({
          type: NodeTypes.INTERPOLATION,
          content: {
              type: NodeTypes.SIMPLE_EXPRESSION,
              isStatic: false,
              // The `isConstant` is the default value and will be determined in `transformExpression`.
              isConstant: false,
              content: '"</div>"',
              loc: {
                  start: { offset: 8, line: 1, column: 9 },
                  end: { offset: 16, line: 1, column: 17 },
                  source: '"</div>"'
              }
          },
          loc: {
              start: { offset: 5, line: 1, column: 6 },
              end: { offset: 19, line: 1, column: 20 },
              source: '{{ "</div>" }}'
          }
      })
  })
#+end_src

*** 03-it can have tag-like notation(2)
:PROPERTIES:
:COLUMNS:  %CUSTOM_ID[(Custom Id)]
:CUSTOM_ID: test-interpolation-03
:END:

è¿™ä¸ªç”¨ä¾‹å…¶å®å’Œ [[#test-interpolation-02][ç”¨ä¾‹ 2]] æ˜¯ä¸€æ ·çš„ï¼Œåªä¸è¿‡æ˜¯è§£æäº†ä¸¤ä¸ªæ’å€¼è€Œå·²ï¼Œå…ˆè§£æ ={{ a<b }}=
ï¼Œæœ€åå‰©ä¸‹çš„ ={{ c>d }}= ä¼šåœ¨é€€å‡º [[#parse-parseinterpolation][parseInterpolation]] ä¹‹åå‰©ä½™çš„ context.source
ä¸º ={{ c>d }}= åœ¨ [[#parse-parsechildren][parseChildren]] é‡Œé¢ç»§ç»­è¿›è¡Œ while å¾ªç¯å¤„
ç†ï¼Œéšåˆæ£€æµ‹åˆ°æ˜¯æ’å€¼å†æ¬¡è°ƒç”¨ =parseInterpolation= è¿›è¡Œå¤„ç†å¾—åˆ°ç¬¬äºŒä¸ªæ’å€¼èŠ‚ç‚¹ã€‚
#+begin_src typescript
  test('it can have tag-like notation (2)', () => {
      const ast = baseParse('{{ a<b }}{{ c>d }}')
      const interpolation1 = ast.children[0] as InterpolationNode
      const interpolation2 = ast.children[1] as InterpolationNode

      expect(interpolation1).toStrictEqual({
          type: NodeTypes.INTERPOLATION,
          content: {
              type: NodeTypes.SIMPLE_EXPRESSION,
              content: `a<b`,
              isStatic: false,
              isConstant: false,
              loc: {
                  start: { offset: 3, line: 1, column: 4 },
                  end: { offset: 6, line: 1, column: 7 },
                  source: 'a<b'
              }
          },
          loc: {
              start: { offset: 0, line: 1, column: 1 },
              end: { offset: 9, line: 1, column: 10 },
              source: '{{ a<b }}'
          }
      })

      expect(interpolation2).toStrictEqual({
          type: NodeTypes.INTERPOLATION,
          content: {
              type: NodeTypes.SIMPLE_EXPRESSION,
              isStatic: false,
              isConstant: false,
              content: 'c>d',
              loc: {
                  start: { offset: 12, line: 1, column: 13 },
                  end: { offset: 15, line: 1, column: 16 },
                  source: 'c>d'
              }
          },
          loc: {
              start: { offset: 9, line: 1, column: 10 },
              end: { offset: 18, line: 1, column: 19 },
              source: '{{ c>d }}'
          }
      })
  }
#+end_src

[[#link-04][æ”¯æŒè¯¥ç”¨ä¾‹ä»£ç é“¾æ¥ğŸ›¬]]

*** 02-it can have tag-like notation(1)
:PROPERTIES:
:COLUMNS:  %CUSTOM_ID[(Custom Id)]
:CUSTOM_ID: test-interpolation-02
:END:

è¯¥ç”¨ä¾‹é‡Œé¢è™½ç„¶æœ‰ =<= ç¬¦å·ï¼Œä½†æ˜¯ç”±äºæ˜¯åœ¨æ’å€¼å†…éƒ¨ï¼Œä¼šè¿›å…¥ [[#parse-parseinterpolation][parseInterpolation]] ä¹‹å
å°±è¢«è§£ææˆæ’å€¼çš„ sourceï¼Œå¹¶ä¸ä¼šè¿›å…¥ while é‡Œé¢çš„ä½œä¸ºæ ‡ç­¾çš„å¼€å§‹ =<= æ¥è§£æã€‚

#+begin_src js
  test('it can have tag-like notation', () => {
    const ast = baseParse('{{ a<b }}')
    const interpolation = ast.children[0]

    expect(interpolation).toStrictEqual({
      type: NodeTypes.INTERPOLATION,
      content: {
        type: NodeTypes.SIMPLE_EXPRESSION,
        content: `a<b`, // content = preTrimContent.trim() å»æ‰å‰åç©ºæ ¼
        isStatic: false,
        isConstant: false,
        loc: {
          start: { offset: 3, line: 1, column: 4 },
          end: { offset: 6, line: 1, column: 7 },
          source: 'a<b'
        }
      },
      loc: {
        start: { offset: 0, line: 1, column: 1 },
        end: { offset: 9, line: 1, column: 10 },
        source: '{{ a<b }}'
      }
    })
  })
#+end_src

[[#link-04][é€šè¿‡è¯¥ç”¨ä¾‹ä»£ç é“¾æ¥ğŸ›¬]]

***  01- simple interpolation
:PROPERTIES:
:COLUMNS:  %CUSTOM_ID[(Custom Id)]
:CUSTOM_ID: test-interpolation-01
:END:

#+begin_src js
  test('simple interpolation', () => {
    const ast = baseParse('{{message}}')
    const interpolation = ast.children[0]

    expect(interpolation).toStrictEqual({
      type: NodeTypes.INTERPOLATION,
      content: {
        type: NodeTypes.SIMPLE_EXPRESSION,
        content: `message`,
        isStatic: false,
        isConstant: false,
        loc: {
          start: { offset: 2, line: 1, column: 3 }, // m ä½ç½®
          end: { offset: 9, line: 1, column: 10 }, // æœ€åä¸€ä¸ª e ä½ç½®
          source: `message`
        }
      },
      loc: {
        start: { offset: 0, line: 1, column: 1 }, // ç¬¬ä¸€ä¸ª { ä½ç½®
        end: { offset: 11, line: 1, column: 12 }, // æœ€åä¸€ä¸ª } ä½ç½®
        source: '{{message}}'
      }
    })
  }
#+end_src

** Text æ–‡æœ¬è§£æ
*** 07-only "{{" don\'t separate nodes
:PROPERTIES:
:COLUMNS:  %CUSTOM_ID[(Custom Id)]
:CUSTOM_ID: test-text-06
:END:

è¿™ä¸ªç”¨ä¾‹æ˜¯ç”¨æ¥æ£€æµ‹æ’å€¼ä¸å®Œæ•´çš„æƒ…å†µï¼Œæ­£å¸¸ä¼šçˆ†å‡º =X_MISSING_INTERPOLATION_END= å¼‚
å¸¸ï¼Œåœ¨è¯¥ç”¨ä¾‹ä¸­é‡å†™äº†è¯¥å¼‚å¸¸å¤„ç†ï¼Œå› æ­¤ä¸ä¼šæŠ¥é”™ï¼Œç”¨ä¾‹ä¼šå¾ˆé¡ºåˆ©é€šè¿‡ï¼Œå› ä¸ºæ²¡æœ‰å¼‚å¸¸ï¼Œ
[[#parse-parseinterpolation][parseInterpolation]] ä¼šé€€å‡ºï¼Œæœ€å ={{= ä¼šè¢«å½“åšæ™®é€šæ–‡æœ¬å†…å®¹å¤„ç†ã€‚

#+begin_src js
  test('lonly "{{" don\'t separate nodes', () => {
    const ast = baseParse('a {{ b', {
      onError: (error) => {
        if (error.code !== ErrorCodes.X_MISSING_INTERPOLATION_END) {
          throw error
        }
      }
    })
    const text = ast.children[0]

    expect(text).toStrictEqual({
      type: NodeTypes.TEXT,
      content: 'a {{ b',
      loc: {
        start: { offset: 0, line: 1, column: 1 },
        end: { offset: 6, line: 1, column: 7 },
        source: 'a {{ b'
      }
    })
  }) // lonly "{{" don\'t separate nodes
#+end_src

[[#parse-parseInterpolation][parseInterpolation]] è¯¥ç”¨ä¾‹å¤„ç†ä»£ç ï¼š

#+begin_src js
  function parseInterpolation(context, mode) {
    // æ‰¾å‡ºæ’å€¼æ¨¡æ¿çš„å¼€å§‹å’Œç»“æŸç¬¦å·ï¼Œé»˜è®¤æ˜¯ {{ å’Œ }}
    const [open, close] = context.options.delimiters
    const closeIndex = context.source.indexOf(close, open.length)
    if (closeIndex === -1) {
      // è¿™é‡Œæ£€æµ‹åˆ°æ²¡æœ‰ }} é€€å‡ºï¼Œå¹¶ä¸”åˆ°è¿™é‡Œ context æŒ‡é’ˆä¿¡æ¯å¹¶æ²¡æœ‰æ”¹å˜
      // å› æ­¤é€€å‡ºä¹‹åï¼Œé‡æ–° while æœ€åè¿›å…¥æ–‡æœ¬è§£æ parseText
      emitError(context, ErrorCodes.X_MISSING_INTERPOLATION_END)
      return undefined
    }

    // ... çœç•¥
  }
#+end_src

test:

#+begin_example
  âœ  packages git:(master) âœ— jest compiler-core
   PASS  compiler-core/__tests__/parse.spec.js (19.233 s)
    compiler: parse
      Text
        âœ“ simple text (5 ms)
        âœ“ simple text with invalid end tag (2 ms)
        âœ“ text with interpolation (1 ms)
        âœ“ text with interpolation which has `<` (1 ms)
        âœ“ text with mix of tags and interpolations (1 ms)
        âœ“ lonly "<" don't separate nodes (7 ms)
        âœ“ lonly "{{" don't separate nodes

  Test Suites: 1 passed, 1 total
  Tests:       7 passed, 7 total
  Snapshots:   0 total
  Time:        23.277 s
  Ran all test suites matching /compiler-core/i
#+end_example

*** 06-only "<" don\'t separate nodes
:PROPERTIES:
:COLUMNS:  %CUSTOM_ID[(Custom Id)]
:CUSTOM_ID: test-text-05
:END:

#+begin_src js
  test('lonly "<" don\'t separate nodes', () => {
    const ast = baseParse('a < b', {
      onError: (err) => {
        if (err.code !== ErrorCodes.INVALID_FIRST_CHARACTER_OF_TAG_NAME) {
          throw err
        }
      }
    })
    const text = ast.children[0]

    expect(text).toStrictEqual({
      type: NodeTypes.TEXT,
      content: 'a < b',
      loc: {
        start: { offset: 0, line: 1, column: 1 },
        end: { offset: 5, line: 1, column: 6 },
        source: 'a < b'
      }
    }) // lonly "<" don\'t separate nodes
  }
#+end_src

è¿™ä¸ªç”¨ä¾‹åœ¨å®ç°çš„ [[#test-text-05][test-05]] ä¹‹åå°±å¯ä»¥é€šè¿‡ï¼Œå› ä¸º =a < b= å¹¶ä¸æ˜¯æ’å€¼ä¸€éƒ¨åˆ†ï¼Œä¼šè¢«å½“åš
çº¯æ–‡æœ¬å¤„ç†ï¼Œè€Œä¸ºäº†é¿å…æŠ¥é”™ç”¨ä¾‹ä¸­é‡å†™äº† =onError=ï¼Œå› ä¸º while å¾ªç¯é‡Œåœ¨æ£€æµ‹åˆ° =<=
å¼€å¤´çš„ if æ¡ä»¶åˆ†æ”¯ä¸­ï¼Œç¬¬äºŒä¸ªå­—ç¬¦ä¸ºç©ºæ ¼çš„æƒ…å†µä¼šè¿›å…¥æœ€åçš„ else åˆ†æ”¯å¤„ç†ï¼Œå³è§¦å‘
=INVALID_FIRST_CHARACTER_OF_TAG_NAME= å¼‚å¸¸ã€‚

#+begin_src js
  else if (mode === TextModes.DATA && s[0] === '<') {
    // ... æ ‡ç­¾å¼€å¤´ <...
    if (s.length === 1) {
      emitError(context, ErrorCodes.EOF_BEFORE_TAG_NAME, 1)
    } else if (s[1] === '!') {
      // TODO æ³¨é‡Šå¤„ç†ï¼Œ<!-- ...
    } else if (s[1] === '/') {
      // ...
    } else if (/[a-z]/i.test(s[1])) {
      // ...
    } else if (s[1] === '?') {
      // ...
    } else {
      // ä¼šè¿›å…¥åˆ°è¿™é‡Œï¼Œè§¦å‘å¼‚å¸¸ï¼Œä½†æ˜¯ç”±äº options é‡Œæä¾›äº† onError é‡å†™äº†å®ƒ
      // å› æ­¤è¿™é‡Œä¸ä¼šè§¦å‘å¼‚å¸¸ï¼Œè€Œæ˜¯é€€å‡ºè¯¥åˆ†æ”¯è¿›å…¥ çº¯æ–‡æœ¬å¤„ç†ï¼Œåˆå¹¶æ–‡æœ¬ pushnode æ“ä½œ
      emitError(context, ErrorCodes.INVALID_FIRST_CHARACTER_OF_TAG_NAME, 1)
    }
  }
#+end_src

*** 05-text with mix of tags and interpolations
:PROPERTIES:
:COLUMNS:  %CUSTOM_ID[(Custom Id)]
:CUSTOM_ID: test-text-05
:END:

#+begin_src typescript
  test('text with mix of tags and interpolations', () => {
      const ast = baseParse('some <span>{{ foo < bar + foo }} text</span>')
      const text1 = ast.children[0] as TextNode
      const text2 = (ast.children[1] as ElementNode).children![1] as TextNode

      expect(text1).toStrictEqual({
          type: NodeTypes.TEXT,
          content: 'some ',
          loc: {
              start: { offset: 0, line: 1, column: 1 },
              end: { offset: 5, line: 1, column: 6 },
              source: 'some '
          }
      })
      expect(text2).toStrictEqual({
          type: NodeTypes.TEXT,
          content: ' text',
          loc: {
              start: { offset: 32, line: 1, column: 33 },
              end: { offset: 37, line: 1, column: 38 },
              source: ' text'
          }
      })
  }
#+end_src

è¿™æ˜¯ä¸ªæ ‡ç­¾+æ’å€¼æ··åˆæ¨¡æ¿ï¼Œç°é˜¶æ®µçš„ä»£ç æ˜¯é€šä¸è¿‡è¯¥æµ‹è¯•çš„ï¼Œå› ä¸ºå®ƒä¼šè¿›å…¥åˆ°ä¸‹é¢è¿™ä¸ªåˆ†æ”¯ï¼š

#+begin_src js
  else if (/[a-z]/i.test(s[2])) {
    // è¿™é‡Œéƒ½å‡ºé”™äº†ï¼Œä¸ºå•¥åé¢è¿˜æœ‰ä¸ª parseTag ???
    // åˆ°è¿™é‡Œå°±ä¼šæŠ¥é”™
    emitError(context, ErrorCodes.X_INVALID_END_TAG)
    parseTag(context, TagType.End, parent)
    continue
  } else {
#+end_src

å¦‚æ§åˆ¶å°è¾“å‡ºï¼š

[[/img/tmp/1596638044.png]]

é”™è¯¯ä¸Šé¢çš„è¾“å‡ºå…¶å®æ˜¯ }} å’Œ {{ çš„è§£æä½ç½®ä¿¡æ¯ï¼Œå¹¶ä¸” =<div>= å¹¶æ²¡æœ‰è§£ææ˜¯å› ä¸ºæˆ‘ä»¬
è¿˜æ²¡å®ç° [[#parse-parseelement][parseElement]] åˆ†æ”¯é€»è¾‘ï¼Œæ‰€ä»¥ç›´æ¥è¿‡æ»¤æ‰å½“æˆæ–‡æœ¬å¤„ç†äº†ã€‚

1. @@html:<font color='blue'>@@å³è¾¹ï¼š offset=14 åˆšå¥½æ˜¯ `some <span>{{ ` å­—ç¬¦ä¸²é•¿åº¦ + 1 å³æ’å€¼å†…ç¬¬ä¸€ä¸ªç©ºæ ¼çš„ä½ç½®@@html:</font>@@

2. @@html:<font color='blue'>@@å·¦è¾¹ï¼šoffset=29 åˆšå¥½æ˜¯ 14 + `foo < bar + foo` é•¿åº¦ä½ç½®(slice ä¸åŒ…å« endIdx)ï¼Œ å³æ’å€¼å†…æœ€åä¸€ä¸ªç©ºæ ¼çš„ä½ç½®@@html:</font>@@

æ¥ä¸‹æ¥æˆ‘ä»¬å¾—çœ‹ä¸‹æ€ä¹ˆä¸æŠ¥é”™èƒ½è§£æ =</div>= ã€‚

@@html:<font color='green'>@@
å¤§æ¦‚çš„çŒœæƒ³æ˜¯åœ¨è§£æ =<div>= çš„æ—¶å€™å‘ç°æ˜¯æ ‡ç­¾ï¼Œå¯èƒ½ä¼šé‡å†™
=onError= ï¼Œé¿å…åœ¨è§£æ =</div>= è§¦å‘å¼‚å¸¸ï¼Œè€Œæ˜¯è¿›å…¥ [[#parse-parsetag][parseTag]]
è§£æç»“æŸæ ‡ç­¾ã€‚ä½†å¾ˆå¯æƒœä¸æ˜¯è¿™æ ·ï¼Œè€Œæ˜¯åœ¨ [[#parse-parselement][parseElement]] ä¸­é€’å½’
è°ƒç”¨ [[#parse-parsechildren][parseChildren]] è§£ææ ‡ç­¾å†…éƒ¨çš„æ¨¡æ¿ï¼Œè§£æå®Œæˆä¹‹åæ£€æµ‹
ç»“æŸæ ‡ç­¾ï¼Œæ— ç»“æŸæ ‡ç­¾ï¼Œéæ³•å¼‚å¸¸ï¼Œå…·ä½“å®ç°è¯·çœ‹ [[#parse-parseelement][parseElement æºç å®
ç°]]ã€‚
@@html:</font>@@

åœ¨å®ç°äº† [[#parse-parseelement][parseElement]] å’Œéƒ¨åˆ† [[#parse-parsetag][parseTag]] ä¹‹åç”¨ä¾‹é€šè¿‡ï¼š

#+begin_example
âœ  packages git:(master) âœ— jest compiler-core
 PASS  compiler-core/__tests__/parse.spec.js (14.492 s)
  compiler: parse
    Text
      âœ“ simple text (5 ms)
      âœ“ simple text with invalid end tag (2 ms)
      âœ“ text with interpolation (2 ms)
      âœ“ text with interpolation which has `<` (1 ms)
      âœ“ text with mix of tags and interpolations (2 ms)

Test Suites: 1 passed, 1 total
Tests:       5 passed, 5 total
Snapshots:   0 total
Time:        15.743 s
Ran all test suites matching /compiler-core/i.
#+end_example

æœŸé—´ç¢°åˆ°ä¸ªé—®é¢˜ï¼š

> Cannot find module 'core-js/modules/es6.string.iterator' from 'packages/compiler-core/parse.js'

è§£å†³æ–¹æ¡ˆï¼š[[https://github.com/babel/babel/issues/9796][æ˜¯ core-js é™çº§åˆ° 2]]
*** 04-text with interpolation which has `<`
:PROPERTIES:
:COLUMNS:  %CUSTOM_ID[(Custom Id)]
:CUSTOM_ID: test-text-04
:END:

#+begin_src typescript
  test('text with interpolation which has `<`', () => {
      const ast = baseParse('some {{ a<b && c>d }} text')
      const text1 = ast.children[0] as TextNode
      const text2 = ast.children[2] as TextNode

      expect(text1).toStrictEqual({
          type: NodeTypes.TEXT,
          content: 'some ',
          loc: {
              start: { offset: 0, line: 1, column: 1 },
              end: { offset: 5, line: 1, column: 6 },
              source: 'some '
          }
      })
      expect(text2).toStrictEqual({
          type: NodeTypes.TEXT,
          content: ' text',
          loc: {
              start: { offset: 21, line: 1, column: 22 },
              end: { offset: 26, line: 1, column: 27 },
              source: ' text'
          }
      })
  })
#+end_src

è¿™ä¸ªç”¨ä¾‹å…¶å®å’Œ [[#test-text-03][03-text with interpolation]] ç”¨ä¾‹åŸç†ä¸€æ ·ï¼Œè™½ç„¶æ’å€¼é‡Œé¢æœ‰ç‰¹æ®Šå­—ç¬¦
=<= ï¼Œä½†æ˜¯ç”±äºåœ¨ [[#parse-parseInterpolation][parseInterpolation]] å‡½æ•°è§£æè¿‡ç¨‹ä¸­æ˜¯é€šè¿‡æˆªå– {{ åˆ° }} ç›´æ¥çš„å…¨éƒ¨
å­—ç¬¦ä¸²å»è§£æçš„ã€‚
#+begin_src typescript
  function parseInterpolation(
      context: ParserContext,
      mode: TextModes
  ): InterpolationNode | undefined {
      // ... çœç•¥

      // ä¹Ÿå°±æ˜¯è¿™ä¸¤è¡Œï¼Œå°† {{ ... }} å†…çš„æ‰€æœ‰å†…å®¹ä¸€æ¬¡æ€§å–å‡ºæ¥è§£æäº†ï¼Œå› æ­¤å¹¶ä¸ä¼š
      // è¿›å…¥åˆ° parseChildren çš„ while å¾ªç¯ä¸­å¤„ç†ï¼Œä¹Ÿå°±ä¸ä¼šå‡ºç°å¼‚å¸¸æƒ…å†µ
      const rawContentLength = closeIndex - open.length
      const rawContent = context.source.slice(0, rawContentLength)

      // ... çœç•¥
  }
#+end_src

æ‰€ä»¥è¿™ä¸ªç”¨ä¾‹ä¼šå¾ˆé¡ºåˆ©çš„é€šè¿‡(åœ¨ 03 ç”¨ä¾‹é€šè¿‡çš„å‰æä¸‹)ã€‚

#+begin_example
 PASS  packages/compiler-core/__tests__/parse.spec.js (5.375 s)
  compiler: parse
    Text
      âœ“ simple text (5 ms)
      âœ“ simple text with invalid end tag (3 ms)
      âœ“ text with interpolation (41 ms)
      âœ“ text with interpolation which has `<` (3 ms)


#+end_example

*** 03-text with interpolation
:PROPERTIES:
:COLUMNS:  %CUSTOM_ID[(Custom Id)]
:CUSTOM_ID: test-text-03
:END:

[[#link-04][è¯¥ç”¨ä¾‹ä»£ç é“¾æ¥ ->]]

è¯¥ç”¨ä¾‹æ£€éªŒçš„å·®å€¼çš„å¤„ç†ã€‚
#+begin_src typescript
  test("text with interpolation", () => {
      const ast = baseParse("some {{ foo + bar }} text");
      const text1 = ast.children[0],
      text2 = ast.children[2];

      expect(text1).toStrictEqual({
          type: NodeTypes.TEXT,
          content: "some ",
          loc: {
              start: { offset: 0, line: 1, column: 1 },
              source: "some ",
              end: { offset: 5, line: 1, column: 6 },
          },
      });

      expect(text2).toStrictEqual({
          type: NodeTypes.TEXT,
          content: " text",
          loc: {
              start: { offset: 20, line: 1, column: 21 },
              source: " text",
              end: { offset: 25, line: 1, column: 26 },
          },
      });
  }
#+end_src

å·®å€¼çš„å¤„ç†åˆ†æ”¯åœ¨ parseChildren çš„

#+begin_src typescript
  if (!context.inVPre && startsWith(s, context.options.delimiters[0])) {
      // '{{'
      node = parseInterpolation(context, mode)
  }
#+end_src

å®Œæˆï¼Œå› ä¸ºéœ€è¦ [[#parse-parseInterpolation][parseInterpolation()]] çš„æ”¯æŒã€‚

ç”¨ä¾‹ç»“æœ(@@html:<font color='green'>@@OK@@html:</font>@@ )ï¼š

#+begin_example
âœ  vue-next-code-read git:(master) âœ— jest parse.spec
 PASS  packages/compiler-core/__tests__/parse.spec.js
  compiler: parse
    Text
      âœ“ simple text (4 ms)
      âœ“ simple text with invalid end tag (2 ms)
      âœ“ text with interpolation (47 ms)

  console.log
    { column: 18, line: 1, offset: 17 } { column: 9, line: 1, offset: 8 } 1

      at parseInterpolation (packages/compiler-core/parse.js:262:11)

Test Suites: 1 passed, 1 total
Tests:       3 passed, 3 total
Snapshots:   0 total
Time:        8.776 s
Ran all test suites matching /parse.spec/i.
âœ  vue-next-code-read git:(master) âœ—
#+end_example

*** 02-simple text\<div>
:PROPERTIES:
:COLUMNS:  %CUSTOM_ID[(Custom Id)]
:CUSTOM_ID: test-text-02
:END:

[[#link-03][è¯¥ç”¨ä¾‹ä»£ç é“¾æ¥->]]

åœ¨è·‘è¿™ä¸ªç”¨ä¾‹çš„æ—¶å€™å‡ºç°å†…å­˜æº¢å‡ºäº†ï¼ŒæŸ¥äº†ä¸‹åŸå› æ˜¯å› ä¸ºåªæ˜¯[[#link-02][å¢åŠ äº† while é‡Œé¢çš„å„ç§
if åˆ†æ”¯]]ï¼Œä½†æ˜¯å®é™…å¹¶æ²¡æœ‰å®ç°ï¼Œè¿™ä¸ªç”¨ä¾‹ä¼šèµ°åˆ°

#+begin_src js
  else if (mode === TextModes.DATA && s[0] === "<") {
    // ... æ ‡ç­¾å¼€å¤´ <...
    if (s.length === 1) {
      emitError(context, ErrorCodes.EOF_BEFORE_TAG_NAME, 1);
    } else if (s[1] === "!") {
      // TODO æ³¨é‡Šå¤„ç†ï¼Œ<!-- ...
    } else if (s[1] === "/") {
      // </...
      if (s.length === 2) {
        emitError(context, ErrorCodes.EOF_BEFORE_TAG_NAME, 2);
      } else if (s[2] === ">") {
        // ...
      } else if (/[a-z]/i.test(s[2])) {
        // ä¼šèµ°åˆ°è¿™ä¸ªåˆ†æ”¯é‡Œé¢ï¼Œä½†æ˜¯ç”±äºä¸‹é¢çš„ parseTag æœªå®ç°ï¼Œå› æ­¤ä¸€ç›´åœ¨è¿™ä¸ªåˆ†æ”¯é‡Œé¢å¾ªç¯
        // åŠ ä¸Šç”¨ä¾‹é‡Œé¢é‡å†™äº† onError ä¸ä¼š throw err ç»ˆæ­¢ï¼Œå› æ­¤ä¼šå‡ºç°æ­»å¾ªç¯
        emitError(context, ErrorCodes.X_INVALID_END_TAG);
        // ä½†æ˜¯ä¸Šé¢éƒ½æŠ¥é”™äº†ï¼Œä¸ºä»€ä¹ˆè¿™é‡Œè¿˜è¦åŠ ä¸ª parseTag??? æ­£å¸¸ç†è§£åº”è¯¥æ˜¯èµ°ä¸åˆ°è¿™é‡Œå•Š
        // é™¤éæœ‰é‡å†™ onError æŠ¥é”™æœºåˆ¶???
        // parseTag(context, TagType.End, parent);
        continue;
      } else {
        // ...
      }
#+end_src

å› æ­¤è¦é€šè¿‡è¿™ä¸ªç”¨ä¾‹ï¼Œå°±å¿…é¡»å¾—å®ç° =parseTag(context, TagType.End, parent)= å‡½æ•°è§£ææ ‡ç­¾ã€‚

#+begin_src js
  test("simple text with invalid end tag", () => {
    const onError = jest.fn();
    const ast = baseParse("some text</div>", {
      onError,
    });
    const text = ast.children[0];

    expect(onError).toBeCalled();
    expect(text).toStrictEqual({
      type: NodeTypes.TEXT,
      content: "some text",
      loc: {
        start: { offset: 0, line: 1, column: 1 },
        end: { offset: 9, line: 1, column: 10 },
        source: "some text",
      },
    });
  }
#+end_src

å› ä¸º baseparse è°ƒç”¨çš„æ—¶å€™æœ‰ä¼ é€’ onError è¦†ç›–æŠ¥é”™ä»£ç ï¼Œä¼šè¿›å…¥åˆ° parseTag è¿›è¡Œè§£æ
æ ‡ç­¾ï¼Œå¦‚æœä¸å®ç°ä¼šå¯¼è‡´æ­»å¾ªç¯ã€‚å› æ­¤è¿™é‡Œè¦é€šè¿‡è¿™ä¸ªç”¨ä¾‹å°±å¿…é¡»å®ç° [[#parse-parsetag][parseTag()]]:

#+begin_src js
  function parseTag(context, type, parent) {
    // è·å–å½“å‰è§£æçš„èµ·å§‹ä½ç½®ï¼Œæ­¤æ—¶å€¼åº”è¯¥æ˜¯ some text çš„é•¿åº¦
    const start = getCursor(context);
    // åŒ¹é… </div è¿‡æ»¤æ‰ç©ºæ ¼å­—ç¬¦ï¼Œä½†æ˜¯ä¸ºä»€ä¹ˆè¦æŠŠ > ç»™å¿½ç•¥æ‰???
    const match = /^<\/?([a-z][^\t\r\n\f />]*)/i.exec(context.source);
    const tag = match[1];
    const ns = context.options.getNamespace(tag, parent);
    // log1: æ”¹å˜ä½ç§»ï¼Œå°† offset å®šä½åˆ° </div> çš„æœ€æœ‰ä¸€ä¸ª > ä¸Š
    // åœ¨è¿™é‡Œ context.offset = 10, context.line = 1
    advanceBy(context, match[0].length);
    // è¿‡æ»¤æ‰ç©ºæ ¼
    advanceSpaces(context);
    // log2: ç»è¿‡ advance ä¹‹å context.offset = 15, context.line = 1
    // æ­£å¥½è¿‡æ»¤ </div 5 ä¸ªå­—ç¬¦
    const cursor = getCursor(context);
    const currSource = context.source;
  }
#+end_src

parseTag å®ç°åˆ°è¿™é‡Œå°±å¯ä»¥æ»¡è¶³é€šè¿‡æµ‹è¯•ç”¨ä¾‹çš„æ¡ä»¶äº†ï¼Œè¿™é‡Œé¢ä¼šå»åŒ¹é… =</div= ç„¶åå°†
å…¶è¿‡æ»¤æ‰(é€šè¿‡ advanceBy å’Œ advanceSpaces æ¥æ”¹å˜ context é‡Œé¢çš„ offset å’Œ line å€¼)ï¼Œ
è¾“å‡ºç»“æœ(log1 å’Œ log2 ä½ç½® context çš„è¾“å‡º)ï¼š

[[/img/tmp/1595444610.png]]

*** 01-simple text
:PROPERTIES:
:COLUMNS:  %CUSTOM_ID[(Custom Id)]
:CUSTOM_ID: test-text-01
:END:

è¿™é‡Œç”¨åˆ°çš„å°±ä¸€ä¸ª baseParse å‡½æ•°ï¼Œéœ€è¦æˆ‘ä»¬æ¥å®ç°å…¶åŸºæœ¬çš„åŠŸèƒ½ä»¥é€šè¿‡è¯¥ç”¨ä¾‹ã€‚

ç”¨ä¾‹æºç ï¼š

#+begin_src js
  test('simple text', () => {
    const ast = baseParse('some text')
    const text = ast.children[0] as TextNode

    expect(text).toStrictEqual({
      type: NodeTypes.TEXT,
      content: 'some text',
      loc: {
        start: { offset: 0, line: 1, column: 1 },
        end: { offset: 9, line: 1, column: 10 },
        source: 'some text'
      }
    })
  })
#+end_src

[[https://github.com/gcclll/vue-next-code-read/tree/master/bakups/compiler-core/test-01-some-text][ç”¨ä¾‹çš„åŸºæœ¬åŠŸèƒ½ï¼ŒéªŒè¯ baseParse è§£æå‡ºæ¥çš„æ–‡æœ¬èŠ‚ç‚¹å¯¹è±¡æ˜¯å¦æ»¡è¶³åŸºæœ¬è¦æ±‚ã€‚]]

æ”¯æŒè¯¥ç”¨ä¾‹çš„é‡è¦éƒ¨åˆ†ä»£ç ï¼š

1. createParseContext æ„å»ºè¢«è§£æçš„å†…å®¹çš„å¯¹è±¡ç»“æ„
   #+begin_src js
     function createParserContext(context, options) /*ParserContext*/ {
       return {
         options: {
           ...defaultParserOptions,
           ...options,
         },
         // åˆå§‹åŒ–ä»¥ä¸‹å†…å®¹
         column: 1,
         line: 1,
         offset: 0,
         originalSource: context,
         source: context,
         inPref: false,
         inVPref: false,
       };
     }
   #+end_src
2. parseChildren
   #+begin_src js
     function parseChildren(
       context /* ParserContext*/,
       mode /*TextModes*/,
       ancesotrs /*ElementNode[]*/
     ) {
       // ...
       const nodes /*TemplateChildNode[]*/ = [];

       while (!isEnd(context, mode, ancesotrs)) {
         // do sth

         const s = context.source;
         let node = undefined;

         // ç”±äº baseparse é‡Œé¢ä¼ è¿‡æ¥çš„æ˜¯ä¸ª DATA ç±»å‹ï¼Œå› æ­¤ä¼šèµ°åˆ°è¿™ä¸ª if é‡Œ
         // é¢å»è§£æ
         if (mode === TextModes.DATA || mode === TextModes.RCDATA) {
           // è¿‡ç•¥æ‰éæ–‡æœ¬çš„
           if (!context.inVPre && s.startsWith(context.options.delimiters[0])) {
             // ... æ’å€¼å¤„ç†{{}}
           } else if (mode === TextModes.DATA && s[0] === "<") {
             // ... æ ‡ç­¾å¼€å¤´ <...
           }

           // ... åˆ°è¿™é‡Œä¹Ÿå°±æ˜¯è¯´æ–‡æœ¬èŠ‚ç‚¹ä¸ä¼šè¢«è¿™ä¸ª if å¤„ç†ï¼Œè€Œæ˜¯ç›´æ¥åˆ°
           // !node ç»™ parseText è§£æ
         }

         if (!node) {
           // çº¯æ–‡æœ¬é‡ç‚¹åœ¨è¿™é‡Œé¢å¤„ç†ï¼Œæˆªå–å­—ç¬¦ç›´åˆ°é‡åˆ° <, {{, ]]> æ ‡å¿—ç»“æŸ
           // ç„¶åä¼ å…¥åˆ° parseTextData() åˆ¤æ–­æ˜¯å¦æ˜¯æ•°æ®ç»‘å®šçš„å˜é‡ï¼Œåœ¨
           // context.options.decodeEntities() ä¸­å¤„ç†
           node = parseText(context, mode);
         }

         if (Array.isArray(node)) {
           for (let i = 0; i < node.length; i++) {
             pushNode(nodes, node[i]);
           }
         } else {
           pushNode(nodes, node);
         }
       }

       let removedWhitespace = false;

       return removedWhitespace ? nodes.filter(Boolean) : nodes;
     }
   #+end_src
3. parseText
   #+begin_src js
     function parseText(context, mode) {
       // å­—ç¬¦ä¸²è§£æç›´åˆ°é‡åˆ° <, {{, ]]> ä¸ºæ­¢
       const endTokens = ["<", context.options.delimiters[0]];
       if (mode === TextModes.CDATA) {
         endTokens.push("]]>");
       }

       let endIndex = context.source.length;
       for (let i = 0; i < endTokens.length; i++) {
         const index = context.source.indexOf(endTokens[i], 1);
         if (index !== -1 && endIndex > index) {
           endIndex = index;
         }
       }

       const start = getCursor(context);
       // è§£æ & å¼€å¤´çš„ html è¯­ä¹‰çš„ç¬¦å·(>,<,&,',")
       const content = parseTextData(context, endIndex, mode);
       return {
         type: NodeTypes.TEXT,
         content,
         // loc:{ start, end, source}
         // start,end: { line, column, offset }
         loc: getSelection(context, start),
       };
     }
   #+end_src
4. parseTextData
   #+begin_src js
     // è§£ææ–‡æœ¬æ•°æ®ï¼Œçº¯æ–‡æœ¬å†…å®¹
     function parseTextData(context, length, mode) {
       const rawText = context.source.slice(0, length);
       // è§£ææ¢è¡Œï¼Œæ›´æ–° line, column, offsetï¼Œè¿”å›æ¢è¡Œä¹‹åçš„çš„ source
       advanceBy(context, length);
       if (
         mode === TextModes.RAWTEXT ||
           mode === TextModes.CDATA ||
           rawText.indexOf("&") === -1
       ) {
         return rawText;
       }

       return context.options.decodeEntities(
         rawText,
         mode === TextModes.ATTRIBUTE_VALUE
       );
     }
   #+end_src
5. advancedBy è§£æå¤šä¸ªå­—ç¬¦ä¹‹åæ›´æ–° =start,end(line,column,offset)= ï¼Œå°¤å…¶æ˜¯æ¢è¡Œç¬¦çš„ç‰¹æ®Šå¤„ç†ã€‚
   #+begin_src js
     function advanceBy(context, numberOfCharacters) {
       const { source } = context;
       advancePositionWithMutation(context, source, numberOfCharacters);
       context.source = source.slice(numberOfCharacters);
     }
   #+end_src
6. advancePositionWithMutation
   #+begin_src js
     export function advancePositionWithMutation(
       pos,
       source,
       numberOfCharacters = source.length
     ) {
       let linesCount = 0;
       let lastNewLinePos = -1;
       for (let i = 0; i < numberOfCharacters; i++) {
         if (source.charCodeAt(i) === 10 /* newline char code */) {
           linesCount++;
           lastNewLinePos = i;
         }
       }

       pos.offset += numberOfCharacters;
       pos.line += linesCount;
       pos.column =
         lastNewLinePos === -1
         ? pos.column + numberOfCharacters
         : numberOfCharacters - lastNewLinePos;

       return pos;
     }
   #+end_src

* å‡½æ•°åˆ—è¡¨
:PROPERTIES:
:COLUMNS:  %CUSTOM_ID[(Custom Id)]
:CUSTOM_ID: parse-funcs
:END:

** baseParse(context, options)
:PROPERTIES:
:COLUMNS:  %CUSTOM_ID[(Custom Id)]
:CUSTOM_ID: parse-baseparse
:END:

#+begin_src js
  function baseParse(content, options /* ParserOptions */) /*RootNode*/ {
    const context = createParserContext(content, options);
    const start = getCursor(context);
    return createRoot(
      parseChildren(context, TextModes.DATA, []),
      getSelection(context, start)
    );
  }
#+end_src

baseParse å†…éƒ¨å®ç°åŸºæœ¬å°±æ˜¯è°ƒç”¨å…¶ä»–æ–¹æ³•ï¼Œæ‰€ä»¥æ¥ä¸‹æ¥æˆ‘ä»¬å¾—é’ˆå¯¹å®ƒä½¿ç”¨çš„å‡ ä¸ªæ–¹æ³•å»é€ä¸€å®ç°ï¼š

1. [[#parse-createparsecontext][createParserContext]]ï¼Œåˆ›å»ºèŠ‚ç‚¹è§£æå¯¹è±¡ï¼ŒåŒ…å«è§£æè¿‡ç¨‹ä¸­éœ€è¦æˆ–éœ€è¦ä¿å­˜çš„æ•°æ®
2. [[#parse-getcursor][getCursor]]ï¼Œè·å– context ä¸­çš„ offset, line, column, start, end ç­‰ä¿¡æ¯
3. [[vue/vue3-source-code-compiler-core-ast_ts/#ast-createroot][createRoot]]ï¼Œåˆ›å»ºæ ¹èŠ‚ç‚¹
4. [[#parse-parsechildren][parseChildren]]ï¼Œè§£æå­èŠ‚ç‚¹
5. [[#parse-getselection][getSelection]]ï¼Œè·å–é€‰ä¸­çš„æœªè§£æçš„å†…å®¹

[[#parse-baseparse][baseParse]] å‡½æ•°å¤§ä½“ç»“æ„å’Œä»£ç è°ƒç”¨å›¾ç¤ºï¼š
:PROPERTIES:
:COLUMNS: %CUSTOM_ID[(Custom Id)]
:CUSTOM_ID: pic-baseparse
:END:

[[/img/vue3/compiler-core/functions/parse-ts-baseparse-0.png]]

** createParseContext(context, options)
:PROPERTIES:
:COLUMNS:  %CUSTOM_ID[(Custom Id)]
:CUSTOM_ID: parse-createparsecontext
:END:

å‡½æ•°ä½œç”¨ï¼š*åˆ›å»ºè§£æå™¨ä¸Šä¸‹æ–‡å¯¹è±¡(åŒ…å«è§£æè¿‡ç¨‹ä¸­çš„ä¸€äº›è®°å½•ä¿¡æ¯)*

å‡½æ•°å£°æ˜ï¼š

=function createParserContext(context, options) /*ParserContext*/ {}=

å‚æ•°æ²¡ä»€ä¹ˆå¥½è®²çš„äº†ï¼Œä» baseParse ç»§æ‰¿è€Œæ¥ï¼Œè¿”å›çš„æ˜¯ä¸€ä¸ª [[#td-parser-context][ParserContext]] ç±»å‹ã€‚å…·ä½“
å®ç°å…¶å®å°±æ˜¯è¿”å›ä¸€ä¸ª ParserContext ç±»å‹çš„å¯¹è±¡ï¼Œé‡Œé¢åŒ…å«äº†æºç å­—ç¬¦ä¸²è¢«è§£ææ˜¯çš„ä¸€
äº›ä¿¡æ¯å­˜å‚¨ï¼Œæ¯”å¦‚ï¼šè§£ææ—¶æŒ‡é’ˆçš„ä½ç½® offsetï¼Œå½“å‰è¡Œåˆ—(line, column)ï¼ŒåŠå…¶ä»–ä¿¡æ¯ã€‚

#+begin_src typescript
  function createParserContext(
      content: string,
      options: ParserOptions
  ): ParserContext {
      return {
          options: {
              // è§£æå™¨çš„é»˜è®¤é€‰é¡¹ç»™äº†äº›é»˜è®¤å€¼ï¼Œæ¯”å¦‚ï¼šisVoidTag: No, isPreTag: NOï¼Œ ç­‰ç­‰
              ...defaultParserOptions,
              ...options
          },
          column: 1,
          line: 1,
          offset: 0,
          originalSource: content,
          source: content,
          inPre: false,
          inVPre: false
      }
  }
#+end_src

** parseChildren(context, mode, ancestors)
:PROPERTIES:
:COLUMNS:  %CUSTOM_ID[(Custom Id)]
:CUSTOM_ID: parse-parsechildren
:END:

#+begin_src js
  function parseChildren(
    context /* ParserContext*/,
    mode /*TextModes*/,
    ancesotrs /*ElementNode[]*/
  ) /* TemplateChildNode[] */{}
#+end_src

å‚æ•°åˆ—è¡¨ï¼š

1. contextï¼Œå¾…è§£æçš„æ¨¡æ¿å¯¹è±¡([[#td-parser-context][ParserContext]])
2. modeï¼Œæ–‡æœ¬æ¨¡å¼([[#td-vars-textmodes][TextModes]])
3. ancestorsï¼Œç¥–å…ˆå…ƒç´ ([[#td-ast-elementnode][ElementNode[]â€‹]])

è¿”å›ç»“æœï¼š [[/vue/vue3-source-code-compiler-core-ast_ts/#td-ast-tcn][TemplateChildNode[]â€‹]]

*** é˜¶æ®µä¸€([[#test-01-sometext][test01 some text]])

å®ç° [[#parse-parsetext][parseText()]] ä¹‹åçš„ [[#parse-parsechildren][parseChildren() ]]ä»£ç ï¼š

#+begin_src js
  function parseChildren(
    context /* ParserContext*/,
    mode /*TextModes*/,
    ancesotrs /*ElementNode[]*/
  ) {
    // ...
    const nodes /*TemplateChildNode[]*/ = [];

    while (!isEnd(context, mode, ancesotrs)) {
      // do sth

      const s = context.source;
      let node = undefined;

      // ç”±äº baseparseé‡Œé¢ä¼ è¿‡æ¥çš„æ˜¯ä¸ª DATA ç±»å‹ï¼Œå› æ­¤ä¼šèµ°åˆ°è¿™ä¸ª if é‡Œ
      // é¢å»è§£æ
      if (mode === TextModes.DATA || mode === TextModes.RCDATA) {
        // è¿‡ç•¥æ‰éæ–‡æœ¬çš„
        if (!context.inVPre && s.startsWith(context.options.delimiters[0])) {
          // ... æ’å€¼å¤„ç†{{}}
        } else if (mode === TextModes.DATA && s[0] === "<") {
          // ... æ ‡ç­¾å¼€å¤´ <...
        }

        // ... åˆ°è¿™é‡Œä¹Ÿå°±æ˜¯è¯´æ–‡æœ¬èŠ‚ç‚¹ä¸ä¼šè¢«è¿™ä¸ª if å¤„ç†ï¼Œè€Œæ˜¯ç›´æ¥åˆ°
        // !node ç»™ parseText è§£æ
      }

      if (!node) {
        node = parseText(context, mode);
      }

      if (Array.isArray(node)) {
        for (let i = 0; i < node.length; i++) {
          pushNode(nodes, node[i]);
        }
      } else {
        pushNode(nodes, node);
      }
      console.log(context, "parse children");
    }

    let removedWhitespace = false;

    return removedWhitespace ? nodes.filter(Boolean) : nodes;
  }
#+end_src

æœ€åå¤„ç†å®Œä¹‹åæ–‡æœ¬èŠ‚ç‚¹å¯¹è±¡å†…å®¹å¦‚ä¸‹ï¼š

#+begin_src js
  {
    options: {
      delimiters: [ '{{', '}}' ],
      getNamespace: [Function: getNamespace],
      getTextMode: [Function: getTextMode],
      isVoidTag: false,
      isPreTag: false,
      isCustomElement: false,
      decodeEntities: [Function: decodeEntities],
      onError: null
    },
    // è¿™é‡Œå‘ç”Ÿäº†å˜æ¢
    // column: å®šä½åˆ°äº†å­—ç¬¦ä¸²æœ€åå³ 'simple text' çš„é•¿åº¦ + 1ï¼Œå³ç»“æŸä½ç½®
    // line: å› ä¸ºåªæœ‰ä¸€è¡Œï¼Œæ‰€ä»¥ line å¹¶æœªå‘ç”Ÿæ”¹å˜ï¼Œå¦‚æœå‘ç”Ÿäº†æ”¹å˜ä¼šåœ¨ advancedBy é‡Œé¢è¿›è¡Œå¤„ç†æ›´æ–°
    // offset: ç±»ä¼¼æ–‡ä»¶å¤„ç†æ—¶çš„æŒ‡é’ˆåç§»é‡ï¼Œå³å­—ç¬¦ä¸²é•¿åº¦
    column: 12,
    line: 1,
    offset: 11,
    // ä¼šå‘ç°å¤„ç†å®Œæˆä¹‹åï¼ŒoriginalSource ç»´æŒåŸæ ·
    originalSource: 'simple text',
    // source å˜æˆäº†ç©ºå­—ç¬¦ä¸²ï¼Œå› ä¸ºå¤„ç†å®Œäº†
    source: '',
    inPref: false,
    inVPref: false
  } // parse children
#+end_src

[[#parse-baseparse][baseParse]] ä¹‹åçš„ ast ç»“æ„ï¼š

#+begin_src js
  // è¿™ä¸ªç»“æ„çš„å½¢æˆæ˜¯ç»è¿‡ createRoot å¤„ç†ä¹‹åçš„ç»“æœ
  // ç»è¿‡ parseChildren ä¹‹åçš„ç»“æœä¼šè¢«å­˜æ”¾åˆ° root çš„children ä¸­ï¼Œå¦‚ä¸‹
  {
    type: 0,
    children: [
      {
        type: 2,
        content: '\nsimple text 1\n simple text 2\n',
        loc: [Object]
      }
    ],
    loc: {
      start: { column: 1, line: 1, offset: 0 },
      end: { column: 1, line: 4, offset: 30 },
      source: '\nsimple text 1\n simple text 2\n'
    },
    helpers: [],
    components: [],
    directives: [],
    hoists: [],
    imports: [],
    cached: 0,
    temps: 0,
    codegenNode: undefined
  } //// ast

  // ç¬¬ä¸€ä¸ª children ç»“æ„ï¼š
  {
    type: 2,
    content: '\nsimple text 1\n simple text 2\n',
    loc: {
      start: { column: 1, line: 1, offset: 0 },
      end: { column: 1, line: 4, offset: 30 },
      source: '\nsimple text 1\n simple text 2\n'
    }
  } //// ast
#+end_src

é˜¶æ®µä»£ç ï¼š[[#link-01][test-01-some-text æµ‹è¯•ç”¨ä¾‹é€šè¿‡]]

å›¾ç¤ºï¼šæ–‡æœ¬è§£æ

[[/img/vue3/compiler-core/functions/parse-ts-parsechildren-text-part.png]]

*** é˜¶æ®µäºŒ([[#test-element-12][<div ...></div>\n<div ...></div>]])

å¢åŠ ç©ºè¡ŒèŠ‚ç‚¹è¿‡æ»¤ã€‚

#+begin_src js
  function parseChildren(
    context /* ParserContext*/,
    mode /*TextModes*/,
    ancestors /*ElementNode[]*/
  ) {
    // ...
    const parent = last(ancestors);
    const ns = parent ? parent.ns : Namespaces.HTML;
    const nodes /*TemplateChildNode[]*/ = [];

    let i = 0;
    while (!isEnd(context, mode, ancestors)) {
      // do sth

      const s = context.source;
      let node = undefined;

      // ç”±äº baseparseé‡Œé¢ä¼ è¿‡æ¥çš„æ˜¯ä¸ª DATA ç±»å‹ï¼Œå› æ­¤ä¼šèµ°åˆ°è¿™ä¸ª if é‡Œ
      // é¢å»è§£æ
      if (mode === TextModes.DATA || mode === TextModes.RCDATA) {
        // è¿‡ç•¥æ‰éæ–‡æœ¬çš„
        if (!context.inVPre && s.startsWith(context.options.delimiters[0])) {
          // ... æ’å€¼å¤„ç†{{}}
          node = parseInterpolation(context, mode);
        } else if (mode === TextModes.DATA && s[0] === "<") {
          // ... æ ‡ç­¾å¼€å¤´ <...
          if (s.length === 1) {
            emitError(context, ErrorCodes.EOF_BEFORE_TAG_NAME, 1);
          } else if (s[1] === "!") {
            // TODO æ³¨é‡Šå¤„ç†ï¼Œ<!-- ...
            if (s.startsWith("<!--")) {
              // æ™®é€šçš„ html æ³¨é‡Š
              node = parseComment(context);
            }
          } else if (s[1] === "/") {
            // </...
            if (s.length === 2) {
              emitError(context, ErrorCodes.EOF_BEFORE_TAG_NAME, 2);
            } else if (s[2] === ">") {
              // </> ä¸å¸¦æ ‡ç­¾åçš„æ— æ•ˆæ ‡ç­¾
              emitError(context, ErrorCodes.MISSING_END_TAG_NAME, 2);
              // è¿‡æ»¤æ‰ </> è¿™ä¸‰ä¸ªå­—ç¬¦ä¸²ï¼Œoffset>>3 é€€å‡ºæœ¬æ¬¡å¾ªç¯ç»§ç»­è§£æ
              advanceBy(context, 3);
              continue;
            } else if (/[a-z]/i.test(s[2])) {
              // è¿™é‡Œéƒ½å‡ºé”™äº†ï¼Œä¸ºå•¥åé¢è¿˜æœ‰ä¸ª parseTag ???
              emitError(context, ErrorCodes.X_INVALID_END_TAG);
              parseTag(context, TagType.End, parent);
              continue;
            } else {
              emitError(
                context,
                ErrorCodes.INVALID_FIRST_CHARACTER_OF_TAG_NAME,
                2
              );
              // node = parseBogusComment(context)
            }
          } else if (/[a-z]/i.test(s[1])) {
            // è§£æèµ·å§‹æ ‡ç­¾ï¼Œå³è¿™é‡Œæ‰æ˜¯æ ‡ç­¾æœ€å¼€å§‹çš„ä½ç½®ã€‚
            node = parseElement(context, ancestors);
          } else if (s[1] === "?") {
            // <? å¼€å§‹çš„
            emitError(
              context,
              ErrorCodes.UNEXPECTED_QUESTION_MARK_INSTEAD_OF_TAG_NAME,
              1
            );
            // node = parseBogusComment(context)
          } else {
            // å…¶ä»–æƒ…å†µéƒ½è§†ä¸ºéæ³•
            emitError(context, ErrorCodes.INVALID_FIRST_CHARACTER_OF_TAG_NAME, 1);
          }
        }

        // ... åˆ°è¿™é‡Œä¹Ÿå°±æ˜¯è¯´æ–‡æœ¬èŠ‚ç‚¹ä¸ä¼šè¢«è¿™ä¸ª if å¤„ç†ï¼Œè€Œæ˜¯ç›´æ¥åˆ°
        // !node ç»™ parseText è§£æ
      }

      if (!node) {
        node = parseText(context, mode);
      }

      if (Array.isArray(node)) {
        for (let i = 0; i < node.length; i++) {
          pushNode(nodes, node[i]);
        }
      } else {
        pushNode(nodes, node);
      }
    }

    console.log(nodes);
    let removedWhitespace = false;
    // TODO ç©ºæ ¼ç®¡ç†ï¼Œä¸ºäº†æ›´é«˜æ•ˆçš„è¾“å‡º
    // `\n<div>...` åˆ é™¤å¼€å¤´çš„ç©ºæ ¼å­—ç¬¦ï¼Œä¹‹å‰è§£æ v-pre ç”¨ä¾‹æ˜¯å¡åœ¨è¿™é‡Œäº†
    // è¿™é‡Œå¿˜è®°å®ç°äº†ï¼Œæ‰€ä»¥ç”¨ä¾‹ http://www.cheng92.com/vue/vue3-source-code-compiler-core-parse_ts/#headline-3
    // å¾—åˆ°äº†ä¸‰ä¸ª childï¼Œç¬¬äºŒä¸ªæ˜¯ \nï¼Œå°±æ˜¯å› ä¸ºè¿™é‡Œæ²¡å®ç°è¿‡æ»¤

    if (mode !== TextModes.RAWTEXT) {
      if (!context.inPre) {
        for (let i = 0; i < nodes.length; i++) {
          const node = nodes[i];
          if (node.type === NodeTypes.TEXT) {
            if (!/[^\t\r\n\f ]/.test(node.content)) {
              const prev = nodes[i - 1];
              const next = nodes[i + 1];
              // 1. ç©ºæ ¼æ˜¯ç¬¬ä¸€ä¸ªæˆ–è€…æœ€åä¸€ä¸ªèŠ‚ç‚¹ï¼Œæˆ–è€…
              // 2. ç©ºæ ¼ä¸æ³¨é‡ŠèŠ‚ç‚¹ç›¸é‚»
              // 3. ç©ºæ ¼åœ¨ä¸¤ä¸ªå…ƒç´ ä¹‹é—´ï¼Œå°±æˆ‘ä»¬é‡åˆ°çš„ <div></div>\n<div>...
              // ä¸Šé¢ä¸‰ç§æƒ…å†µçš„ç©ºæ ¼ä¼šè¢«å¿½ç•¥
              if (
                !prev ||
                  !next ||
                  prev.type === NodeTypes.COMMENT ||
                  next.type === NodeTypes.COMMENT ||
                  (prev.type === NodeTypes.ELEMENT &&
                   next.type === NodeTypes.ELEMENT &&
                   /[\r\n]/.test(node.content))
              ) {
                removedWhitespace = true;
                nodes[i] = null;
              } else {
                // å¦åˆ™æ›¿æ¢æˆç©ºæ ¼
                node.content = " ";
              }
            } else {
              // æ›¿æ¢æˆç©ºæ ¼
              node.content = node.content.replace(/[\t\r\n\f ]+/g, " ");
            }
          }
        }
      } else if (parent && context.options.isPreTag(parent.tag)) {
        //å¦‚æœæ˜¯ <pre> åˆ æ‰ç¬¬ä¸€è¡Œçš„ç©ºè¡Œ
        const first = nodes[0];
        if (first && first.type === NodeTypes.TEXT) {
          first.content = first.content.replace(/^\r?\n/, "");
        }
      }
    }

    return removedWhitespace ? nodes.filter(Boolean) : nodes;
  }
#+end_src
** parseComment(context)
:PROPERTIES:
:COLUMNS:  %CUSTOM_ID[(Custom Id)]
:CUSTOM_ID: parse-parsecomment
:END:

æ³¨é‡Šå¤„ç†å‡½æ•°ï¼Œè§£æåŸåˆ™æ˜¯åŒ¹é… =<!--= å¼€å¤´å’Œ =-->= ç»“å°¾ï¼Œä¸­é—´éƒ¨åˆ†ç»Ÿç»Ÿè§†ä¸ºæ³¨é‡Šï¼Œä¸­
é—´éœ€è¦è€ƒè™‘åµŒå¥—æ³¨é‡Šé—®é¢˜ã€‚

#+begin_src js
  function parseComment(context) /* CommentNode */ {
    const start = getCursor(context)
    let content

    const match = /--(\!)?>/.exec(context.source)
    if (!match) {
      // æ²¡æœ‰é—­åˆæ³¨é‡Šï¼Œåé¢çš„æ‰€æœ‰éƒ½ä¼šè¢«å½“åšæ³¨é‡Šå¤„ç†
      content = context.source.slice(4)
      advanceBy(context, context.source.length) // åé¢æ‰€æœ‰çš„éƒ½æˆä¸ºæ³¨é‡Š
      emitError(context, ErrorCodes.EOF_IN_COMMENT)
    } else {
      console.log(match)
      if (match.index <= 3) {
        // ç©ºæ³¨é‡Šä¹ŸæŠ¥é”™
        emitError(context, ErrorCodes.ABRUPT_CLOSING_OF_EMPTY_COMMENT)
      }

      // éæ³•ç»“æŸï¼Œæ¯”å¦‚ï¼š <!-xx--!>ï¼Œæ­£åˆ™é‡Œé¢æœ‰ä¸ª (\!)? æ•è·ç»„
      // match[1] å°±æ˜¯æŒ‡è¿™ä¸ªåŒ¹é…
      if (match[1]) {
        emitError(context, ErrorCodes.INCORRECTLY_CLOSED_COMMENT)
      }

      // å–æ³¨é‡Šå†…å®¹ï¼Œmatch.index å³ /--(\!)?>/ æ­£åˆ™åŒ¹é…çš„å¼€å§‹ç´¢å¼•ä½ç½®
      content = context.source.slice(4, match.index)

      // åµŒå¥—æ³¨é‡Š??? è¿™é‡Œslice ä¹‹åçš„ s ä¸åŒ…å«ç»“æŸ -->
      const s = context.source.slice(0, match.index)
      let prevIndex = 1,
          nestedIndex = 0

      console.log({ s })
      // é¦–å…ˆèƒ½è¿›å…¥ parseCommentï¼Œè¯´æ˜ source æ˜¯ä»¥ <!-- å¼€å¤´çš„ï¼Œä¸”æ˜¯åŒ…å« --> çš„
      // å¦åˆ™å‰é¢å°±ä¼šå‡ºç°å¼‚å¸¸ï¼Œå› æ­¤å¦‚æœåµŒå¥—é‚£å¯èƒ½æƒ…å†µåªæœ‰<!--x<!--y-->æ³¨é‡Šä¸­é—´
      // å‡ºç°è¿‡ <!--
      while ((nestedIndex = s.indexOf('<!--', prevIndex)) !== -1) {
        console.log({ nestedIndex, prevIndex, s, len: s.length })
        advanceBy(context, nestedIndex - prevIndex + 1)
        // + 4 å€¼æ˜¯ `<!--`.lengthï¼Œå¦‚æœå°äº s.lengthï¼Œè¯´æ˜åµŒå¥—äº†æ³¨é‡Š
        if (nestedIndex + 4 < s.length) {
          // éæ³•åµŒå¥—, å¦‚ï¼š<!--<!--x-->
          emitError(context, ErrorCodes.NESTED_COMMENT)
        }

        /// ç„¶åå®šä½åˆ°åµŒå¥—çš„ç¬¬ä¸€ä¸ª <!-- çš„ ! ç´¢å¼•ä¸Šï¼Œè¿›å…¥ä¸‹ä¸€è½®å¤„ç†ï¼Œç›´
        // åˆ°æ‰¾åˆ°æœ€åä¸€ä¸ªåˆæ³•çš„ <!--
        prevIndex = nestedIndex + 1
      }

      // è¿™é‡Œåº”è¯¥æ˜¯æ²¡åµŒå¥—çš„æƒ…å†µï¼Ÿï¼Ÿï¼Ÿ
      advanceBy(context, match.index + match[0].length - prevIndex + 1)
    }

    return {
      type: NodeTypes.COMMENT,
      content,
      loc: getSelection(context, start)
    }
  }
#+end_src
** parseElement(context, mode)
:PROPERTIES:
:COLUMNS:  %CUSTOM_ID[(Custom Id)]
:CUSTOM_ID: parse-parseelement
:END:

è¿™ä¸ªè§£æå‡½æ•°ï¼Œç”¨æ¥è§£æ =<div>= æ ‡ç­¾ã€‚

*** é˜¶æ®µä¸€([[#test-text-05][test-05]])

[[#test-text-05][some \<span>{{ foo < bar + foo }} text\</span>]]

æ­¤é˜¶æ®µåªå®ç°å¯¹ =<div>...</div>= çš„è§£æï¼Œä¸åŒ…å«å±æ€§ç­‰ç­‰å…¶ä»–å¤æ‚æƒ…å†µï¼Œå› ä¸ºåªéœ€è¦èƒ½
é€šè¿‡ç”¨ä¾‹ 5 å°±è¡Œã€‚

#+begin_src js
  function parseElement(context, ancestors) {
    // assert context.source æ˜¯ä»¥ <[a-z] å¼€å¤´çš„

    const wasInPre = context.inPre
    const wasInVPre = context.inVPre
    // å– ancestors æœ€åä¸€ä¸ªèŠ‚ç‚¹ node
    const parent = last(ancestors)
    const element = parseTag(context, TagType.Start, parent)

    // pre or v-pre
    const isPreBoundary = context.inPre && !wasInVPre
    const isVPreBoundary = context.inVPre && !wasInVPre

    // è‡ªé—­åˆçš„åˆ°è¿™é‡Œå°±å¯ä»¥ç»“æŸäº†
    if (element.isSelfClosing || context.options.isVoidTag?.(element.tag)) {
      return element
    }

    // å­å…ƒç´  childrenï¼Œè¢«æ¼æ‰çš„ä»£ç ï¼Œä¼šè¿›å…¥é€’å½’è°ƒç”¨ parseChildren å»è§£æ
    // <span>...</span> æ ‡ç­¾å†…çš„æ¨¡æ¿
    ancestors.push(element)
    const mode = context.options.getTextMode(element, parent)
    const children = parseChildren(context, mode, ancestors)

    ancestors.pop()
    element.children = children
    // P1.... è§£æä¹‹å children é‡Œé¢åº”è¯¥åŒ…å«ä¸¤ä¸ª node
    // node1: æ’å€¼å†…å®¹ `foo < bar + foo`
    // node2: æ–‡æœ¬èŠ‚ç‚¹ ` text`
    console.log(element)

    // ç»“æŸæ ‡ç­¾ï¼Ÿ <span></span> è¿™ç§ç±»å‹ï¼Ÿ
    // ä¸Šé¢ä¼šè§£ææ ‡ç­¾å†…çš„æ¨¡æ¿ï¼Œè§£æå®Œä¹‹å source æ­£å¸¸åº”è¯¥ä¼šæ˜¯ `</span> ....`
    // è¿›å…¥ if è§£æç»“æŸæ ‡ç­¾
    if (startsWithEndTagOpen(context.source, element.tag)) {
      parseTag(context, TagType.End, parent)
    } else {
      // ä¼šè¿›å…¥åˆ°è¿™é‡Œå‡ºç°æŠ¥é”™
      emitError(context, ErrorCodes.X_MISSING_END_TAG, 0, element.loc.start)
      if (context.source.length === 0 && element.tag.toLowerCase() === 'script') {
        const first = children[0]
        if (first && first.loc.source.startsWith('<!--')) {
          emitError(context, ErrorCodes.EOF_IN_SCRIPT_HTML_COMMENT_LIKE_TEXT)
        }
      }
    }

    element.loc = getSelection(context, element.loc.start)
    console.log(element, 'after')

    if (isPreBoundary) {
      context.inPre = false
    }

    if (isVPreBoundary) {
      context.inVPre = false
    }

    return element
  }
#+end_src

å®ç°åˆ°è¿™é‡Œæ˜¯ä¸ºäº†æƒ³çœ‹ä¸‹ç»è¿‡ [[#parse-parsetag][parseTag]] ä¹‹åçš„ element æ˜¯ä»€ä¹ˆï¼ŸparseTag é‡Œé¢æœ‰ä¸ªæ­£åˆ™
æ˜¯ç”¨æ¥åŒ¹é…å¼€å§‹æˆ–ç»“æŸæ ‡ç­¾çš„ï¼Œå³ï¼š =/^<\/?([a-z][^\t\r\n\f />]*)/i= è¿™ä¸ªæ—¢å¯ä»¥åŒ¹é…
å¼€å§‹æ ‡ç­¾ï¼Œä¹Ÿå¯ä»¥åŒ¹é…ç»“æŸæ ‡ç­¾ï¼Œå¹¶ä¸”è€ƒè™‘äº† =<div >= æœ‰ç©ºæ ¼çš„æƒ…å†µï¼Œå¿½ç•¥å¤§å°å†™ã€‚

æ­£åˆ™åŒ¹é…æµ‹è¯•ç»“æœï¼š

#+begin_example
/^<\/?([a-z][^\t\r\n\f />]*)/i.exec('<span>')
(2)Â ["<span", "span", index: 0, input: "<span>", groups: undefined]
#+end_example

æ‰€ä»¥è¿™é‡Œé¦–å…ˆåŒ¹é…è§£æçš„æ˜¯å¼€å§‹æ ‡ç­¾ =<div>= ã€‚

#+begin_src json
  // some <span>{{ foo < bar + foo }} text</span>
  // parseTag ä¹‹åçš„ element
  {
    "type":1, // èŠ‚ç‚¹ç±»å‹æ˜¯ NodeTypes.ELEMENT
    "ns":0, // å‘½åç©ºé—´å°±æ˜¯ HTML
    "tag":"span",
    "tagType":0, // æ ‡ç­¾ç±»å‹ ElementTypes.ELEMENT
    "props":[ // æ ‡ç­¾å±æ€§ï¼Œè¿™é‡Œæ²¡æœ‰
    ],
    "isSelfClosing":false, // æ˜¯ä¸æ˜¯è‡ªé—­åˆæ ‡ç­¾ï¼Œå¦‚ï¼š<img/>
    "children":[],
    "loc":{
      "start":{
        "column":6, // column ä¸æ¢è¡Œçš„æƒ…å†µä¸‹ä¸º offset + 1ï¼Œä» 1 å¼€å§‹è®¡æ•°
        "line":1, // æ²¡æ¢è¡Œç¬¦
        "offset":5 // <span> çš„ < å¼€å§‹ä½ç½®ç´¢å¼• `some `.length = 5
      },
      "end":{
        "column":12,
        "line":1,
        // è¿™é‡Œå€¼çš„å˜åŒ–åˆ†ä¸¤æ­¥
        // parseTag:start çš„æ—¶å€™
        // 1. è§£æå‡º <span ï¼Œè¿™ä¸ªæ—¶å€™ offset å…¶å®æ˜¯ 10
        // 2. æ£€æµ‹æ˜¯ä¸æ˜¯è‡ªé—­åˆæ ‡ç­¾ï¼Œå†³å®š advancedBy
        // ç§»åŠ¨æŒ‡é’ˆä½ç½®æ•°(è‡ªé—­åˆï¼š2ï¼Œéè‡ªé—­åˆï¼š1)ï¼Œåˆ°è¿™é‡Œ offset = 11
        "offset":11
      },
      "source":"<span>" // ä¸ºä»€ä¹ˆä¸æ˜¯ `<span>` ??? æ¼äº†è‡ªé—­åˆæ ‡ç­¾æ£€æµ‹æŒ‡é’ˆç§»ä½
    }
  }
#+end_src

è§£æä¹‹å context å†…å®¹å˜åŒ–ï¼š

#+begin_src json
  {
    "options":{
      // å¿½ç•¥é€‰é¡¹ï¼Œç›®å‰å¯¹æˆ‘ä»¬æ²¡å•¥ç”¨
    },
    "column":12,
    "line":1,
    "offset":11, // <span> åé¢çš„ > ç´¢å¼•
    "originalSource":"some <span>{{ foo < bar + foo }} text</span>",
    // è§£æä¹‹åçš„æ¨¡æ¿ï¼Œä¸ºä½• > æ²¡è¢«å»æ‰???ï¼Œè§ é—®é¢˜1
    "source":"{{ foo < bar + foo }} text</span>",
    "inPref":false,
    "inVPref":false
  }
#+end_src

åˆ°æ­¤æˆ‘ä»¬å·²ç»è§£æé™¤äº† =<span>= å¼€å§‹æ ‡ç­¾ï¼Œè¿™ä¸ªæ—¶å€™çš„ =node.childrens = []=ï¼Œä¸‹ä¸€æ­¥
è§£ææ ‡ç­¾é‡Œé¢çš„å†…å®¹ã€‚

åœ¨å®ç°å®Œæ•´çš„ parseElement ä¹‹åå‘ç°æ‰§è¡Œä¼šæŠ¥é”™ï¼Œå› ä¸ºè¿™ä¸ªç”¨ä¾‹å¹¶ä¸æ˜¯ =<span></span>=
æ ‡ç­¾å†…æ²¡ä¸œè¥¿ï¼Œæ‰€ä»¥ä¼šè¿›å…¥ else è§¦å‘ =emitError()= ï¼Œé‚£ä¸æ˜¯æ²¡æ³•å¾€ä¸‹èµ°äº†ï¼Ÿï¼Ÿï¼Ÿ

#+begin_src js
  // å­å…ƒç´  childrenï¼Œè¢«æ¼æ‰çš„ä»£ç ï¼Œä¼šè¿›å…¥é€’å½’è°ƒç”¨ parseChildren å»è§£æ
  // <span>...</span> æ ‡ç­¾å†…çš„æ¨¡æ¿
  ancestors.push(element)
  const mode = context.options.getTextMode(element, parent)
  const children = parseChildren(context, mode, ancestors)
  ancestors.pop()
  element.children = children
  // ...........â˜ğŸ».â˜ğŸ».â˜ğŸ».â˜ğŸ».â˜ğŸ»ï¼ŒåŠ å›å»

  if (startsWithEndTagOpen(context.source, element.tag)) {
    parseTag(context, TagType.End, parent)
  } else {
    emitError(context, ErrorCodes.X_MISSING_END_TAG, 0, element.loc.start)
    if (context.source.length === 0 && element.tag.toLowerCase() === 'script') {
      const first = children[0]
      if (first && first.loc.source.startsWith('<!--')) {
        emitError(context, ErrorCodes.EOF_IN_SCRIPT_HTML_COMMENT_LIKE_TEXT)
      }
    }
  }
#+end_src

é‚£æ˜¯å› ä¸ºå‰é¢æ¼äº†ä¸€æ®µä»£ç ã€‚

ä»£ç åŠ ä¸Šä¹‹åæœ€åä»£ç  P1 å‡ºçš„è¾“å‡º ancestors é‡Œé¢ä¼šæœ‰ä¸€ä¸ªå­èŠ‚ç‚¹(element)ï¼š

#+begin_src json
  // ancestors[{...}]ï¼Œancestors ç¬¬ä¸€ä¸ªèŠ‚ç‚¹æ˜¯ <span> è¿™ä¸ªèŠ‚ç‚¹
  // é‡ç‚¹æˆ‘ä»¬è¦çœ‹çš„æ˜¯è¿™ä¸ªèŠ‚ç‚¹çš„ children å› ä¸ºå…¶å†…éƒ¨æœ‰ `{{ foo < bar + foo }} text`
  // æ‰€ä»¥å®ƒ çš„ element åº”è¯¥æœ‰ä¸¤ä¸ªèŠ‚ç‚¹ï¼š`foo < bar + foo` å’Œ ` text`
  {
    // <span> èŠ‚ç‚¹æœ¬èº«çš„å±æ€§ï¼Œæˆ‘ä»¬é‡ç‚¹éœ€è¦å…³æ³¨çš„æ˜¯ children
    "children":[
      { // ç¬¬ä¸€ä¸ª child æ˜¯ {{ ... }} æ£€æµ‹åˆ°æ’å€¼è¿›å…¥ parseInterpolation åˆ†æ”¯
        // å¤„ç†ï¼Œå¾—åˆ°ä¸‹é¢çš„èŠ‚ç‚¹ç»“æ„ï¼Œæ’å€¼è§£æåœ¨ parseInterpolation ä¸€ç« æœ‰åˆ†æè¿‡äº†
        "type":5,
        "content":{
          "type":4,
          "isStatic":false,
          "isConstant":false,
          "content":"foo < bar + foo",
          "loc":{
            "start":{
              "column":15,
              "line":1,
              "offset":14
            },
            "end":{
              "column":30,
              "line":1,
              "offset":29
            },
            "source":"foo < bar + foo"
          }
        },
        "loc":{
          "start":{
            "column":12,
            "line":1,
            "offset":11
          },
          "end":{
            "column":33,
            "line":1,
            "offset":32
          },
          "source":"{{ foo < bar + foo }}"
        }
      },
      {
        "type":2,
        "content":" text",
        "loc":{
          "start":{
            "column":33,
            "line":1,
            "offset":32
          },
          "end":{
            "column":38,
            "line":1,
            "offset":37
          },
          "source":" text"
        }
      }
    ],
    // <span> æœ¬èº«èŠ‚ç‚¹çš„ loc
  }
#+end_src

è¿™é‡Œä¹Ÿæ²¡ä»€ä¹ˆå¥½è§£é‡Šçš„ï¼Œæ’å€¼åœ¨ [[#parse-parseinterpolation][parseInterpolation]] å¤„åˆ†æè¿‡äº†ï¼Œæ–‡æœ¬è§£æåœ¨ [[#parse-parsetext][parseText]]
å¤„åˆ†æäº†ã€‚

** parseInterpolation(context, mode)
:PROPERTIES:
:COLUMNS:  %CUSTOM_ID[(Custom Id)]
:CUSTOM_ID: parse-parseinterpolation
:END:

å‡½æ•°å£°æ˜ï¼š

#+begin_src typescript
  function parseInterpolation(
      context: ParserContext,
      mode: TextModes
  ): InterpolationNode | undefined {}
#+end_src

*context*: å°†è¢«è§£æçš„ä¸Šä¸‹æ–‡ï¼Œæ­¤æ—¶è¿™é‡Œçš„ source åº”è¯¥æ˜¯ä»¥å·®å€¼ (={{=)å¼€å§‹çš„å­—ç¬¦ä¸²ã€‚

*mode*: æ–‡æœ¬æ¨¡å¼ã€‚

#+begin_src js
  function parseInterpolation(context, mode) {
    // æ‰¾å‡ºæ’å€¼æ¨¡æ¿çš„å¼€å§‹å’Œç»“æŸç¬¦å·ï¼Œé»˜è®¤æ˜¯ {{ å’Œ }}
    const [open, close] = context.options.delimiters;
    const closeIndex = context.source.indexOf(close, open.length);
    if (closeIndex === -1) {
      emitError(context, ErrorCodes.X_MISSING_INTERPOLATION_END);
      return undefined;
    }

    const start = getCursor(context);
    advanceBy(context, open.length);

    // ä¸‹é¢æ˜¯ä» {{ ä¹‹åçš„å­—ç¬¦ä¸²å¼€å§‹è§£æ
    const innerStart = getCursor(context),
          innerEnd = getCursor(context),
          // æ’å€¼é‡Œé¢çš„å­—ç¬¦ä¸²é•¿åº¦
          rawContentLength = closeIndex - open.length,
          // æ’å€¼é‡Œé¢çš„å­—ç¬¦ä¸²å†…å®¹
          rawContent = context.source.slice(0, rawContentLength),
          preTrimContent = parseTextData(context, rawContentLength, mode),
          content = preTrimContent.trim(),
          startOffset = preTrimContent.indexOf(content);
    if (startOffset > 0) {
      advancePositionWithMutation(innerStart, rawContent, startOffset);
    }

    // {{ foo + bar }} ->
    // res = (' foo + bar '.length - 'foo + bar'.length - ' '.length)
    // æ’å€¼é‡Œé¢å­—ç¬¦ä¸²çš„é•¿åº¦ - å»æ‰ç©ºæ ¼åçš„é•¿åº¦ - èµ·å§‹ç©ºæ ¼çš„é•¿åº¦ï¼Œå¾—åˆ°çš„
    // å°±æ˜¯ç»“æŸä½ç½®çš„ offset
    const endOffset =
          rawContentLength - (preTrimContent.length - content.length - startOffset);
    advancePositionWithMutation(innerEnd, rawContent, endOffset);
    // å®šä½åˆ° }} ä½ç½®
    advanceBy(context, close.length);

    console.log(innerEnd, innerStart, "1");
    return {
      type: NodeTypes.INTERPOLATION,
      content: {
        type: NodeTypes.SIMPLE_EXPRESSION,
        isStatic: false,
        isConstant: false,
        content,
        loc: getSelection(context, innerStart, innerEnd),
      },
      loc: getSelection(context, start),
    };
  }
#+end_src

[[/img/tmp/1595570127.png]]

å›¾ä¸­æˆ‘ä»¬çœ‹åˆ°åœ¨ç»è¿‡è§£æä¹‹å innerStart å’Œ innerEnd éƒ½æ•°æ®éƒ½æ­£ç¡®å®šä½åˆ°äº†ç›¸åº”ä½ç½®ï¼Œ
innerStart æ˜¯è§£æåæ’å€¼å­—ç¬¦ä¸²çš„å¼€å§‹ä½ç½®(ç¬¬ä¸€ä¸ª ={= offset = 8(@@html:<font
color='red'>@@'some {{ 'çš„é•¿åº¦</font>))ï¼ŒinnerEnd æ˜¯è§£æåæ’å€¼å­—ç¬¦ä¸²çš„ç»“æŸä½ç½®
(æœ€åä¸€ä¸ª =}= offset = 17(<font color="purple">'some {{ foo + bar 'çš„é•¿
åº¦))@@html:</font>@@ã€‚

[[/img/vue3/compiler-core/functions/parse-ts-parseinterpolation.png]]

è§£æä¹‹åå¾—åˆ°çš„ =ast.children= å°†ä¼šæœ‰ä¸‰ä¸ªèŠ‚ç‚¹ï¼š

#+begin_src json
  (3) [{â€¦}, {â€¦}, {â€¦}]
  0: {type: 2, content: "some ", loc: {â€¦}} // å·¦ä¾§æ–‡æœ¬
  1: {type: 5, content: {â€¦}, loc: {â€¦}} // æ’å€¼éƒ¨åˆ†
  2: {type: 2, content: " text", loc: {â€¦}} // å³ä¾§æ–‡æœ¬
  length: 3
  __proto__: Array(0)
#+end_src

è§£æå›é¡¾(åˆ†åˆ«è§£æå‡ºäº†ä¸‰ä¸ªèŠ‚ç‚¹å¯¹è±¡)ï¼š

1. =0: {type: 2, content: "some ", loc: {â€¦}}=
   :PROPERTIES:
   :COLUMNS: %CUSTOM_ID[(Custom Id)]
   :CUSTOM_ID: x-1
   :END:
   è¯¦ç»†ç»“æ„ï¼š

   #+begin_src json
     0:
     content: "some " // è§£æå‡ºçš„æ–‡æœ¬å†…å®¹
     loc: // ä½ç½®ä¿¡æ¯
     end: {column: 6, line: 1, offset: 5} // è¯¥èŠ‚ç‚¹åœ¨æ¨¡æ¿ä¸­çš„ä½ç½®ä¿¡æ¯
     source: "some " // æ–‡æœ¬æºå†…å®¹
     start: {column: 1, line: 1, offset: 0} // è¯¥èŠ‚ç‚¹åœ¨æ¨¡æ¿ä¸­çš„ç»“æŸä¿¡æ¯
     __proto__: Object
     type: 2 // èŠ‚ç‚¹ç±»å‹
     __proto__: Object
   #+end_src

   é‚£ä¹ˆæ˜¯å¦‚ä½•å¾—åˆ°ä¸Šé¢çš„ç»“æœçš„å‘¢ï¼Ÿï¼Ÿï¼Ÿé‚£å¾—ä» [[#parse-parsechildren][parseChildren]] è¯´èµ·äº†ï¼Œæ¨¡æ¿ï¼š

   @@html:<kbd>@@
   --->> "some {{ foo + bar }} text"
   @@html:</kbd>@@

   =(!context.inVPre && s.startsWith(context.options.delimiters[0]))=
   @@html:<font color='red'>@@æ£€æµ‹å¤±è´¥@@html:</font>@@

   ~mode === TextModes.DATA && s[0] === "<"~ @@html:<font color='red'>@@æ£€æµ‹å¤±è´¥@@html:</font>@@

   å³ä¸€å¼€å§‹å¹¶ä¸ä¼šè¿›å…¥æ’å€¼å’Œæ ‡ç­¾è§£æä»£ç ï¼Œè€Œæ˜¯ç›´æ¥è¿›å…¥ [[#parse-parsetext][parseText(context, mode)]]
   ä¸­è§£ææ–‡æœ¬ï¼Œè§£ææ—¶å€™ç›´åˆ°é‡åˆ° ={{= ä¹‹å‰éƒ½ä¸€ç›´ä¼šå½“åšæ–‡æœ¬è§£æï¼Œè€Œä¹‹å‰çš„æ–‡æœ¬ä¸­åˆ
   ä¸åŒ…å« =decodeMap= ä¸­çš„å­—ç¬¦ï¼Œå› æ­¤çŸ¥é“é‡åˆ° ={= ä¹‹å‰ä¼šä¸€ç›´æ‰§è¡Œ while é‡Œé¢çš„ï¼š

   #+begin_src js
     if (!node) {
       node = parseText(context, mode);
     }

     if (Array.isArray(node)) {
       for (let i = 0; i < node.length; i++) {
         pushNode(nodes, node[i]);
       }
     } else {
       pushNode(nodes, node);
     }
   #+end_src

   è¿™æ®µä»£ç ï¼Œè€Œç”±äº "some " éƒ½æ˜¯æ™®é€šå­—ç¬¦ï¼Œæ¯ä¸ªå­—ç¬¦ä¸²ä¼šå¯¹åº”ä¸€ä¸ª node ï¼Œç„¶ååˆéƒ½æ˜¯
   æ™®é€šæ–‡æœ¬èŠ‚ç‚¹ï¼Œä¼šç»è¿‡ [[#parse-pushnode][pushNode(nodes, node[i])]] å¤„ç†æ‰ï¼Œè¿›è¡Œåˆå¹¶æœ€åæˆä¸ºä¸Šé¢çš„
   ä¸€ä¸ªå®Œæ•´çš„ "some " å¯¹åº”[[#x-1][æ–‡æœ¬èŠ‚ç‚¹ç»“æ„]]ã€‚

2. ~1: {type: 5, content: {â€¦}, loc: {â€¦}}~
   :PROPERTIES:
   :COLUMNS: %CUSTOM_ID[(Custom Id)]
   :CUSTOM_ID: x-2
   :END:
   èŠ‚ç‚¹ç»“æ„ï¼š

   #+begin_example
   1:
     content: // è¿™é‡Œçš„æ•°æ®æ˜¯ç»è¿‡æ’å€¼è§£æä¹‹åçš„æ¨¡æ¿å¯¹è±¡
       content: "foo + bar" // trim ä¹‹åçš„æ’å€¼å­—ç¬¦ä¸²ï¼Œæ²¡æœ‰ }} ???
       isConstant: false // éå¸¸é‡ç±»å‹
       isStatic: false // éé™æ€èŠ‚ç‚¹
       loc:  // è§£æä¹‹åçš„è¯¥èŠ‚ç‚¹åœ¨æ•´ä¸ªæ¨¡æ¿ä¸­çš„ä½ç½®ä¿¡æ¯
        // 17 -> r æ‰€åœ¨çš„ä½ç½®
         end: {column: 18, line: 1, offset: 17}
         source: "foo + bar"
        // 8 -> f æ‰€åœ¨çš„ä½ç½®ï¼Œå³ start -> end => 'f <-> r'
         start: {column: 9, line: 1, offset: 8}
       __proto__: Object
       type: 4 // æ’å€¼è¡¨è¾¾å¼ç±»å‹
       __proto__: Object
    loc: // è¿™é‡Œæ˜¯æ²¡ç»è¿‡å»å°¾éƒ¨ç©ºæ ¼çš„ä½ç½®ä¿¡æ¯
      // 20 -> 'some {{ foo + bar ' æœ€åä¸€ä¸ªç©ºæ ¼ä½ç½®
       end: {column: 21, line: 1, offset: 20}
       source: "{{ foo + bar }}"
      // 5 -> 'some ' ç¬¬ä¸€ä¸ª { ä½ç½®
       start: {column: 6, line: 1, offset: 5}
       __proto__: Object
     type: 5 // æ’å€¼ç±»å‹
     __proto__: Object
   #+end_example

   å¦‚ä¸Šæ‰€æ³¨é‡Šçš„ï¼Œç¬¬ä¸€çº§çš„ loc æ˜¯é€šè¿‡è§£æ *"{{ foo + bar}}"* åœ¨æ•´ä¸ªæ¨¡æ¿ä¸­çš„ä½ç½®
   ä¿¡æ¯ï¼Œcontent é‡Œé¢åŒ…å«çš„æ˜¯æ’å€¼å†…éƒ¨çš„ä¿¡æ¯ï¼Œå³çœŸæ­£çš„è¡¨è¾¾å¼ç»“æ„ä¿¡æ¯ã€‚

3. ~{type: 2, content: " text", loc: {â€¦}}~
   :PROPERTIES:
   :COLUMNS: %CUSTOM_ID[(Custom Id)]
   :CUSTOM_ID: x-3
   :END:

   å’Œç¬¬ä¸€æ­¥ä¸­ä¸€æ ·ï¼Œåªä¼šç»è¿‡ =parseText(context, mode)= è§£æå‡ºçº¯æ–‡æœ¬å†…å®¹ï¼š" text"ï¼Œæœ€åçš„ç»“æ„ï¼š
   #+begin_src json
     {
       type: 2,
       content: " text",
       loc: {
         // ä» text å‰é¢çš„ç©ºæ ¼å¼€å§‹è®°å½•ï¼Œ"some {{ foo + bar }}" é•¿åº¦ä¸º 20
         start: { column: 21, line: 1, offset: 20 },
         source: " text",
         end: { column: 26, line: 1, offset: 25}
       }
     }
   #+end_src

ä¸‰æ­¥åˆ†æå®Œä¹‹åï¼Œåˆ°ç°åœ¨æˆ‘ä»¬åº”è¯¥å…·å¤‡è„±ç¦»ä»£ç å°±å¯ä»¥ç›´æ¥æ ¹æ®æ¨¡æ¿å¾—åˆ°è§£æåå¯¹åº”çš„
children ç»“æ„ã€‚åˆ†æçš„é‡ç‚¹æ˜¯è¦å¾—åˆ°ä¸€ä¸ª ={ type, content, loc: { start, source, end }}= ç»“æ„çš„å¯¹è±¡ã€‚

#+begin_src json
  // start/end:
  {
    column/*è¯¥èŠ‚ç‚¹èµ·å§‹ç»“æŸçš„åˆ—ï¼Œä» 1 å¼€å§‹è®¡æ•°çš„å€¼*/,
    line/*è¯¥èŠ‚ç‚¹æ¨¡æ¿æ‰€åœ¨çš„è¡Œï¼Œä» 1 å¼€å§‹è®¡æ•°çš„å€¼*/,
    offset/*è¯¥èŠ‚ç‚¹èµ·å§‹ç»“æŸçš„ç´¢å¼•ï¼Œä» 0 å¼€å§‹è®¡æ•°çš„å€¼*/
  }
#+end_src

#+begin_export html
<font color="blue">PS: å¯¹äº foo å’Œ bar å˜é‡æ•°æ®è§£ææ‰§è¡Œç»“æœè¿™å—æš‚æ—¶ä¸è®¨è®ºï¼Œä¹Ÿä¸çŸ¥é“å¦‚ä½•åšåˆ°çš„ï¼Œç°é˜¶æ®µåªå…³å¿ƒæ¨¡æ¿çš„è§£æã€‚</font>
#+end_export

** parseTag(context, type, parent)
:PROPERTIES:
:COLUMNS:  %CUSTOM_ID[(Custom Id)]
:CUSTOM_ID: parse-parsetag
:END:

*** é˜¶æ®µä¸€([[#test-text-02][simple text<\/div>]])
:PROPERTIES:
:COLUMNS:  %CUSTOM_ID[(Custom Id)]
:CUSTOM_ID: parse-parsetag-01
:END:

1. ä¸ºä»€ä¹ˆåªåŒ¹é… =</div= è€Œå¿½ç•¥æ‰æœ€åä¸€ä¸ª =>=???
   å‚æ•°:
   #+begin_src typescript
     function parseTag(
         context: ParserContext, // è¦ç»§ç»­è§£æçš„æ¨¡æ¿å¯¹è±¡ simple text</div> é‡Œé¢çš„ </div>
         type: TagType, // Start(<div>), End(</div>)å¼€å§‹ç»“æŸæ ‡ç­¾
         parent: ElementNode | undefined // è¯¥æ ‡ç­¾çš„çˆ¶çº§
     ): ElementNode
   #+end_src

   å…·ä½“å®ç°ï¼š

   #+begin_src js
     function parseTag(context, type, parent) {
       // è·å–å½“å‰è§£æçš„èµ·å§‹ä½ç½®ï¼Œæ­¤æ—¶å€¼åº”è¯¥æ˜¯ simple text çš„é•¿åº¦
       const start = getCursor(context);
       // åŒ¹é… </div è¿‡æ»¤æ‰ç©ºæ ¼å­—ç¬¦ï¼Œä½†æ˜¯ä¸ºä»€ä¹ˆè¦æŠŠ > ç»™å¿½ç•¥æ‰???
       const match = /^<\/?([a-z][^\t\r\n\f />]*)/i.exec(context.source);
       const tag = match[1];
       const ns = context.options.getNamespace(tag, parent);
       // æ”¹å˜ä½ç§»ï¼Œå°† offset å®šä½åˆ° </div> çš„æœ€æœ‰ä¸€ä¸ª > ä¸Š
       advanceBy(context, match[0].length);
       // è¿‡æ»¤æ‰ç©ºæ ¼
       advanceSpaces(context);

       const cursor = getCursor(context);
       const currSource = context.source;
     }
   #+end_src

*** é˜¶æ®µäºŒ([[#test-text-05][test-text-05]])
:PROPERTIES:
:COLUMNS:  %CUSTOM_ID[(Custom Id)]
:CUSTOM_ID: parse-parsetag-02
:END:

æ»¡è¶³ç”¨ä¾‹ 5(=some <span>{{ foo < bar + foo }} text</span>=) çš„ä»£ç å®ç°ï¼Œè¿™é‡Œåªéœ€
è¦èƒ½è§£æ =<span> ... </span>= æ ‡ç­¾å°±å¯ä»¥ï¼Œæ²¡æœ‰ =pre=, =v-pre=, =<span/>è‡ªé—­åˆæ ‡
ç­¾= ï¼Œå› æ­¤ä¸‹é¢çœç•¥è¿™å‡ éƒ¨åˆ†æ£€æµ‹ä»£ç ã€‚

#+begin_src js
  function parseTag(context, type, parent) {
    // è·å–å½“å‰è§£æçš„èµ·å§‹ä½ç½®ï¼Œæ­¤æ—¶å€¼åº”è¯¥æ˜¯ some text çš„é•¿åº¦
    const start = getCursor(context)
    // åŒ¹é… </div è¿‡æ»¤æ‰ç©ºæ ¼å­—ç¬¦ï¼Œä½†æ˜¯ä¸ºä»€ä¹ˆè¦æŠŠ > ç»™å¿½ç•¥æ‰???
    const match = /^<\/?([a-z][^\t\r\n\f />]*)/i.exec(context.source)
    const tag = match[1]
    const ns = context.options.getNamespace(tag, parent)
    // log1: æ”¹å˜ä½ç§»ï¼Œå°† offset å®šä½åˆ° </div> çš„æœ€æœ‰ä¸€ä¸ª > ä¸Š
    // åœ¨è¿™é‡Œ context.offset = 10, context.line = 1
    advanceBy(context, match[0].length)
    // è¿‡æ»¤æ‰ç©ºæ ¼
    advanceSpaces(context)
    // log2: ç»è¿‡ advanceä¹‹å context.offset = 15, context.line = 1
    // æ­£å¥½è¿‡æ»¤ </div 5ä¸ªå­—ç¬¦
    const cursor = getCursor(context)
    const currSource = context.source

    // TODO-1 è§£ææ ‡ç­¾å…ƒç´ çš„å±æ€§

    // TODO-2 in pre ...

    // TODO-3 v-pre æŒ‡ä»¤

    // TODO-3 <div/> è‡ªé—­æ ‡ç­¾
    // è¿™é‡Œè¦å®ç°ï¼Œä¸ç„¶æœ€åè§£æå®Œæˆä¹‹å source ä¼šæ˜¯ï¼š>...</span>
    // éœ€è¦æ£€æµ‹ä¸‹æ˜¯ä¸æ˜¯è‡ªé—­åˆæ ‡ç­¾æ¥ç§»åŠ¨æŒ‡é’ˆä½ç½®
    let isSelfClosing = false
    if (context.source.length === 0) {
      emitError(context, ErrorCodes.EOF_IN_TAG)
    } else {
      // some <div> ... </div> åˆ°è¿™é‡Œçš„ source = > ... </div>
      // æ‰€ä»¥å¯ä»¥æ£€æµ‹æ˜¯ä¸æ˜¯ä»¥ /> å¼€å¤´çš„
      isSelfClosing = context.source.startsWith('/>')
      if (type === TagType.End && isSelfClosing) {
        emitError(context, ErrorCodes.END_TAG_WITH_TRAILING_SOLIDUS)
      }
      // å¦‚æœæ˜¯è‡ªé—­åˆæŒ‡é’ˆç§»åŠ¨ä¸¤ä½(/>)ï¼Œå¦åˆ™åªç§»åŠ¨ä¸€ä½(>)
      // åˆ°è¿™é‡Œ source = ... </div>
      advanceBy(context, isSelfClosing ? 2 : 1)
    }

    let tagType = ElementTypes.ELEMENT
    const options = context.options
    // ä¸æ˜¯ v-preï¼Œä¸”ä¸æ˜¯è‡ªå®šä¹‰ç»„ä»¶ï¼Œè¿™ä¸ª if ç›®çš„æ˜¯ä¸ºäº†æ£€æµ‹å¹¶æ”¹å˜
    // tagType æ ‡ç­¾ç±»å‹
    if (!context.inVPre && !options.isCustomElement(tag)) {
      // TODO-4 æ£€æµ‹ tagType
    }

    return {
      type: NodeTypes.ELEMENT,
      ns,
      tag,
      tagType,
      props,
      isSelfClosing: false, // TODO
      children: [],
      loc: getSelection(context, start),
      codegenNode: undefined
    }
  }
#+end_src

è¦èƒ½é€šè¿‡[[#test-text-05][ç”¨ä¾‹5]]å¿…é¡»æ­é… [[#parse-parseelement][parseElement(context, ancestors)]] æ‰è¡Œï¼Œå¹¶ä¸”é‡ç‚¹åœ¨
*parseElement* ä¸­ï¼Œå› ä¸ºæœ‰äº†å¼€å§‹æ ‡ç­¾æ‰ä¼šæœ‰ç»“æŸæ ‡ç­¾çš„è§£æï¼Œä¸ç„¶ä¼šè§¦å‘ç»“æŸæ ‡ç­¾è§£æåˆ†
æ”¯é‡Œé¢çš„ error:

#+begin_src js
  else if (/[a-z]/i.test(s[2])) {
    // è¿™é‡Œéƒ½å‡ºé”™äº†ï¼Œä¸ºå•¥åé¢è¿˜æœ‰ä¸ª parseTag ???
    emitError(context, ErrorCodes.X_INVALID_END_TAG)
    parseTag(context, TagType.End, parent)
    continue
  }
#+end_src

å› æ­¤å¦‚æœè¿™é‡Œä¸ä¼šè§¦å‘ X_INVALID_END_TAG é‚£å¿…å®šæ˜¯ parseElement é‡Œé¢åšäº†ä»€ä¹ˆå¤„ç†ï¼Œ
è¿™ä¸ªå®ç°äº† parseElement æ‰å¾—ä»¥çŸ¥æ™“(ç›®å‰åªæ˜¯çŒœæµ‹~~~)ï¼Œ[[#parse-parseelement][ä¼ é€é—¨ğŸšª>>>]]

*** é˜¶æ®µä¸‰([[#test-element-03][test-element-03]])
:PROPERTIES:
:COLUMNS:  %CUSTOM_ID[(Custom Id)]
:CUSTOM_ID: parse-parsetag-03
:END:

æ”¯æŒè‡ªé—­æ ‡ç­¾è§£æï¼Œå®ç°äº†é˜¶æ®µäºŒä¹‹åï¼Œè¿™é‡Œå…¶å®å¾ˆç®€å•ï¼Œåœ¨ä¸Šä¸€é˜¶æ®µä¸­çš„å®ç°åœ¨
parseTag ä¸­è¿”å›çš„æ—¶å€™ =isSelfClosing= å†™æ­»æˆäº† =false= ï¼Œè¦æ”¯æŒè¿™ä¸ªç”¨ä¾‹ï¼Œåªè¦å°†
å®ƒçš„å€¼èµ‹å€¼ä¸ºå®é™…çš„ =isSelfClosing= å°±å¯ä»¥äº†ã€‚

#+begin_src js
  parseTag() {
    // ...
    let isSelfClosing = false
    if (context.source.length === 0) {
      emitError(context, ErrorCodes.EOF_IN_TAG)
    } else {
      // some <div> ... </div> åˆ°è¿™é‡Œçš„ source = > ... </div>
      // æ‰€ä»¥å¯ä»¥æ£€æµ‹æ˜¯ä¸æ˜¯ä»¥ /> å¼€å¤´çš„
      isSelfClosing = context.source.startsWith('/>')
      if (type === TagType.End && isSelfClosing) {
        emitError(context, ErrorCodes.END_TAG_WITH_TRAILING_SOLIDUS)
      }
      // å¦‚æœæ˜¯è‡ªé—­åˆæŒ‡é’ˆç§»åŠ¨ä¸¤ä½(/>)ï¼Œå¦åˆ™åªç§»åŠ¨ä¸€ä½(>)
      // åˆ°è¿™é‡Œ source = ... </div>
      advanceBy(context, isSelfClosing ? 2 : 1)
    }
    // ...
  }
#+end_src

*** é˜¶æ®µå››(æ”¯æŒ template + v-if)
:PROPERTIES:
:COLUMNS:  %CUSTOM_ID[(Custom Id)]
:CUSTOM_ID: parse-parsetag-04
:END:

#+begin_src js
  function parseTag(context, type, parent) {
    // è·å–å½“å‰è§£æçš„èµ·å§‹ä½ç½®ï¼Œæ­¤æ—¶å€¼åº”è¯¥æ˜¯ some text çš„é•¿åº¦
    const start = getCursor(context)
    // åŒ¹é… <div æˆ– </div è¿‡æ»¤æ‰ç©ºæ ¼å­—ç¬¦ï¼Œä½†æ˜¯ä¸ºä»€ä¹ˆè¦æŠŠ > ç»™å¿½ç•¥æ‰???
    // å…¶å®ä¸æ˜¯å¿½ç•¥æ‰ > è€Œæ˜¯å› ä¸ºå¦‚æœæ˜¯ <div å¼€å¤´ï¼Œé‚£ä¹ˆåé¢æœ‰å¯èƒ½æ˜¯ < æˆ–
    // /> åé¢éœ€è¦å¤„ç†é—­åˆå’Œéé—­åˆé—®é¢˜
    const match = /^<\/?([a-z][^\t\r\n\f />]*)/i.exec(context.source)
    const tag = match[1]
    const ns = context.options.getNamespace(tag, parent)
    // log1: æ”¹å˜ä½ç§»ï¼Œå°† offset å®šä½åˆ° </div> çš„æœ€æœ‰ä¸€ä¸ª > ä¸Š
    // åœ¨è¿™é‡Œ context.offset = 10, context.line = 1
    advanceBy(context, match[0].length)
    // è¿‡æ»¤æ‰ç©ºæ ¼
    advanceSpaces(context)
    // log2: ç»è¿‡ advance ä¹‹å context.offset = 15, context.line = 1
    // æ­£å¥½è¿‡æ»¤ </div 5 ä¸ªå­—ç¬¦
    const cursor = getCursor(context)
    const currSource = context.source

    // è§£ææ ‡ç­¾å…ƒç´ çš„å±æ€§
    let props = parseAttributes(context, type)

    // TODO-2 in pre ...

    // TODO-3 v-pre æŒ‡ä»¤

    // ....

    let tagType = ElementTypes.ELEMENT
    const options = context.options
    // ä¸æ˜¯ v-preï¼Œä¸”ä¸æ˜¯è‡ªå®šä¹‰ç»„ä»¶ï¼Œè¿™ä¸ª if ç›®çš„æ˜¯ä¸ºäº†æ£€æµ‹å¹¶æ”¹å˜
    // tagType æ ‡ç­¾ç±»å‹
    // TODO-4 æ£€æµ‹ tagType
    if (!context.inVPre && !options.isCustomElement(tag)) {
      // æ˜¯å¦æœ‰ is æŒ‡ä»¤ï¼Ÿ
      const hasVIs = props.some(
        (p) => p.type === NodeTypes.DIRECTIVE && p.name === 'is'
      )

      if (options.isNativeTag && !hasVIs) {
        // æ²¡æœ‰ is æŒ‡ä»¤ï¼Œä¸”ä¸æ˜¯åŸç”Ÿæ ‡ç­¾ï¼Œé‚£å°±æ˜¯è‡ªå®šä¹‰çš„ç»„ä»¶äº†
        if (!options.isNativeTag(tag)) tagType = ElementTypes.COMPONENT
      } else if (
        hasVIs ||
          isCoreComponent(tag) ||
          options.isBuiltInComponent?.(tag) ||
          /^[A-Z]/.test(tag) ||
          tag === 'component'
      ) {
        // æœ‰ is æŒ‡ä»¤ || vue æ ¸å¿ƒç»„ä»¶(keep-alive...) || å†…ç½®ç»„ä»¶
        // || æ ‡ç­¾åå¤§å†™å¼€å¤´
        tagType === ElementTypes.COMPONENT
      }

      if (tag === 'slot') {
        tagType === ElementTypes.SLOT
      } else if (
        tag === 'template' &&
          props.some(
            (p) =>
            p.type === NodeTypes.DIRECTIVE && isSpecialTemplateDirective(p.name)
          )
      ) {
        // æ˜¯æ¨¡æ¿çš„å‰ææ˜¯æœ‰æŒ‡ä»¤ï¼Œå¹¶ä¸”æ˜¯ç‰¹æ®Šçš„æ¨¡æ¿æŒ‡ä»¤
        tagType = ElementTypes.TEMPLATE
      }
    }

    const val = {
      type: NodeTypes.ELEMENT,
      ns,
      tag,
      tagType,
      props: [], // TODO
      isSelfClosing,
      children: [],
      loc: getSelection(context, start),
      codegenNode: undefined
    }
    return val
  }
#+end_src

è¿™é‡Œçš„å®ç°æ¶‰åŠåˆ°å‡ ä¸ªæ–°çš„å‡½æ•°ï¼š

1. =options.isCustomElement(tag)= é»˜è®¤åœ¨ options é‡Œé¢æ˜¯ =NO=

2. =options.isNativeTag(tag)= ä½œä¸ºå¯é€‰ =OptionalOptions= é€‰é¡¹ç±»å‹ï¼Œå¹¶æ²¡é»˜è®¤å€¼

3. =isCoreComponent(tag)= vue å†…éƒ¨ä½œä¸ºæ ¸å¿ƒç»„ä»¶çš„æ ‡ç­¾

   #+begin_src json
     { // ä¸»è¦å°±è¿™å››ä¸ª
       Teleport: TELEPORT,
       Suspense: SUSPENSE,
       KeepAlive: KEEP_ALIVE,
       BaseTransition: BASE_TRANSITION
     }
   #+end_src

4. =options.isBuiltInComponent?.(tag)=  å’Œ =isNativeTag= ä¸€æ ·ä½œä¸ºå¯é€‰é€‰é¡¹ï¼Œæ— é»˜è®¤å€¼

5. =isSpecialTemplateDirective(p.name)= ç‰¹æ®Šçš„æ¨¡æ¿æŒ‡ä»¤

   #+begin_src typescript
     const isSpecialTemplateDirective = /*#__PURE__*/ makeMap(
         `if,else,else-if,for,slot`
     )
   #+end_src

   ä»ä¸Šé¢çš„ä»£ç å¯ä»¥çœ‹å‡ºï¼Œå¦‚æœè¦è¢«å®šä¹‰ä¸ºæ˜¯ =<template>= ç±»å‹å¿…é¡»åŒ…å«
   =if,else,else-if,for,slot= è¿™å…¶ä¸­çš„ä»»ä¸€ä¸ªæŒ‡ä»¤å±æ€§ï¼Œåˆ¤æ–­æ¡ä»¶ï¼š

   #+begin_src js
     if (
       tag === 'template' &&
         props.some(
           (p) =>
           // isSpecialTemplateDirective æ˜¯ä½¿ç”¨ makeMap åˆ›å»ºçš„å‡½æ•°
           // å³ key => true/false çš„ä¸€äº›å‡½æ•°
           p.type === NodeTypes.DIRECTIVE && isSpecialTemplateDirective(p.name)
         )
     ) {
       // æ˜¯æ¨¡æ¿çš„å‰ææ˜¯æœ‰æŒ‡ä»¤ï¼Œå¹¶ä¸”æ˜¯ç‰¹æ®Šçš„æ¨¡æ¿æŒ‡ä»¤(if, else, else-if, slot, for)
       tagType = ElementTypes.TEMPLATE
     }
   #+end_src

*** é˜¶æ®µäº”([[#test-element-12][<div ...></div>\n<div ...></div>]])
** parseText(context, mode)
:PROPERTIES:
:COLUMNS:  %CUSTOM_ID[(Custom Id)]
:CUSTOM_ID: parse-parsetext
:END:

è§£ææ–‡æœ¬èŠ‚ç‚¹ï¼Œç›´åˆ°é‡åˆ°ç»“æŸæ ‡è®°(=<=, ={{=, =]]>=)ã€‚

#+begin_src typescript
  function parseText(context: ParserContext, mode: TextModes): TextNode {
      __TEST__ && assert(context.source.length > 0)

      const endTokens = ['<', context.options.delimiters[0]]
      if (mode === TextModes.CDATA) {
          endTokens.push(']]>')
      }

      let endIndex = context.source.length
      for (let i = 0; i < endTokens.length; i++) {
          const index = context.source.indexOf(endTokens[i], 1)
          if (index !== -1 && endIndex > index) {
              endIndex = index
          }
      }

      __TEST__ && assert(endIndex > 0)

      const start = getCursor(context)
      // æ–‡æœ¬å†…å®¹å¯èƒ½åŒ…å« &gt; &lt; &amp; &apos; &quot; ç­‰htmlç¬¦å·ï¼Œéœ€è¦
      // å°†ä»–ä»¬æ›¿æ¢æˆå¯¹åº” >    <    &     '      "
      const content = parseTextData(context, endIndex, mode)

      return {
          type: NodeTypes.TEXT,
          content,
          loc: getSelection(context, start)
      }
  }
#+end_src

å¯¼å›¾ï¼š

[[/img/vue3/compiler-core/functions/parse-ts-parsetext.png]]

** parseTextData(context, length, mode)
:PROPERTIES:
:COLUMNS:  %CUSTOM_ID[(Custom Id)]
:CUSTOM_ID: parse-parsetextdata
:END:

æ–‡æœ¬èŠ‚ç‚¹å¯èƒ½åŒ…å«æ•°æ®ï¼Œé€šè¿‡ *context.options.decodeEntities(???)* æ¥è§£æã€‚

ä¸€äº›å­—ç¬¦çš„ html ä¹¦å†™æ ¼å¼ï¼Œæœ‰ =/&(gt|lt|amp|apos|quot);/= ï¼Œæœ€ç»ˆä¼šè¢«å¯¹åº”çš„å­—ç¬¦æ›¿æ¢æ‰ã€‚

=decodeEntities: (rawText: string): string => rawText.replace(decodeRE, (_, p1) => decodeMap[p1])=

å­—ç¬¦é›†ï¼š

#+begin_src typescript
  const decodeMap: Record<string, string> = {
      gt: '>',
      lt: '<',
      amp: '&',
      apos: "'",
      quot: '"'
  }
#+end_src

ä»£ç ï¼š

#+begin_src typescript
  /**
   ,* Get text data with a given length from the current location.
   ,* This translates HTML entities in the text data.
   ,*/
  function parseTextData(
      context: ParserContext,
      length: number,
      mode: TextModes
  ): string {
      const rawText = context.source.slice(0, length)
      advanceBy(context, length)
      if (
          mode === TextModes.RAWTEXT ||
              mode === TextModes.CDATA ||
              rawText.indexOf('&') === -1
      ) {
          return rawText // å¦‚æœä¸åŒ…å« &gt; &lt; ç­‰htmlæ ‡è®°
      } else {
          // DATA or RCDATA containing "&"". Entity decoding required.
          // å¦‚æœå­—ç¬¦ä¸²ä¸­åŒ…å«è¿™äº›å­—ç¬¦ï¼Œå¾—å»å°†ä»–ä»¬æ›¿æ¢æˆå¯¹åº”çš„æ˜æ–‡å­—ç¬¦ã€‚
          return context.options.decodeEntities(
              rawText,
              mode === TextModes.ATTRIBUTE_VALUE
          )
      }
  }
#+end_src

å¯¼å›¾ï¼š
[[/img/vue3/compiler-core/functions/parse-ts-parsetextdata.png]]

** parseAttributes(context, type)
:PROPERTIES:
:COLUMNS:  %CUSTOM_ID[(Custom Id)]
:CUSTOM_ID: parse-parseattributes
:END:

è¿™é‡Œå®šä¹‰ =props[]= æ•°ç»„ï¼ŒçœŸæ­£è§£æå•ä¸ªå±æ€§çš„åœ¨ [[#parse-parseattribute][parseAttribute]] ä¸­ï¼Œè§£æä¹‹åçš„å•ä¸ª
å±æ€§è§£æ„ä¿å­˜åˆ°æ•°ç»„ä¸­ï¼Œè¿”å›ç»™å½“å‰ç»„ä»¶ä½œä¸º =props= å±æ€§å­—æ®µå­˜åœ¨ï¼š

#+begin_src js

  // è§£ææ ‡ç­¾æ‰€æœ‰å±æ€§
  function parseAttributes(context, type) {
    const props = [];
    const attributeNames = new Set();
    while (
      context.source.length > 0 &&
        !context.source.startsWith(">") &&
        !context.source.startsWith("/>")
    ) {
      // éæ³•å±æ€§ï¼Œ <div /v-if="ok"></div>??
      if (context.source.startsWith("/")) {
        emitError(context, ErrorCodes.UNEXPECTED_SOLIDUS_IN_TAG);
        advanceBy(context, 1);
        advanceSpaces(context);
        continue;
      }

      // </div> ç»“æŸæ ‡ç­¾ï¼Œä»¥å±æ€§ç»“æŸçš„æ ‡ç­¾?
      if (type === TagType.End) {
        emitError(context, ErrorCodes.END_TAG_WITH_ATTRIBUTES);
      }

      // é€ä¸ªè§£æå±æ€§
      const attr = parseAttribute(context, attributeNames);
      if (type === TagType.Start) {
        props.push(attr);
      }

      if (/^[^\t\r\n\f />]/.test(context.source)) {
        emitError(context, ErrorCodes.MISSING_WHITESPACE_BETWEEN_ATTRIBUTES);
      }

      advanceSpaces(context);
    }

    return props;
  }
#+end_src
** parseAttribute(context, nameSet)
:PROPERTIES:
:COLUMNS:  %CUSTOM_ID[(Custom Id)]
:CUSTOM_ID: parse-parseattribute
:END:

è§£ææ ‡ç­¾å±æ€§æˆ–æŒ‡ä»¤ï¼š

#+begin_src js
  function parseAttribute(context, nameSet) {
    const start = getCursor(context)
    const match = /^[^\t\r\n\f />][^\t\r\n\f />=]*/.exec(context.source)
    const name = match[0]

    if (nameSet.has(name)) {
      // é‡å¤å±æ€§å
      emitError(context, ErrorCodes.DUPLICATE_ATTRIBUTE)
    }
    nameSet.add(name)

    if (name[0] === '=') {
      // =name=value ?
      emitError(context, ErrorCodes.UNEXPECTED_EQUALS_SIGN_BEFORE_ATTRIBUTE_NAME)
    }

    {
      const pattern = /["'<]/g
      let m
      while ((m = pater.exec(name))) {
        // ä¸åˆæ³•çš„å±æ€§å
        emitError(
          context,
          ErrorCodes.UNEXPECTED_CHARACTER_IN_ATTRIBUTE_NAME,
          m.index
        )
      }
    }

    // ç§»åŠ¨æŒ‡é’ˆ
    advanceBy(context, name.length)

    // type: { content, isQuoted, loc }
    let value

    // å»ç©ºæ ¼è§£æå±æ€§å€¼
    if (/^[\t\r\n\f ]*=/.test(context.source)) {
      // å±æ€§åä¸ = ä¹‹é—´å­˜åœ¨ç©ºæ ¼çš„æƒ…å†µï¼Œå»æ‰ç©ºæ ¼
      advanceSpaces(context)
      advanceBy(context, 1)
      advanceSpaces(context)
      // å»æ‰ç©ºæ ¼ä¹‹åè§£æå±æ€§å€¼
      value = parseAttributeValue(context)
      if (!value) {
        emitError(context, ErrorCodes.MISSING_ATTRIBUTE_VALUE)
      }
    }

    const loc = getSelection(context, start)

    // v-dir æˆ– ç¼©å†™
    if (!context.inVPre && /^(v-|:|@|#)/.test(name)) {
      // ?: éæ•è·ç»„
      // 1. (?:^v-([a-z0-9]+))? -> åŒ¹é… v-dir æŒ‡ä»¤ï¼Œéè´ªå©ªåŒ¹é…ï¼Œæ•è·æŒ‡ä»¤å
      //   ç§°([a-z0=9]+)
      // 2. (?:(?::|^@|^#)([^\.]+))? -> åŒ¹é… :,@,#
      // 3. (.+)?$ åŒ¹é…ä»»æ„å­—ç¬¦
      const match = /(?:^v-([a-z0-9]+))?(?:(?::|^@|^#)([^\.]+))?(.+)?$/i.exec(
        name
      )

      let arg

      // ([a-z0-9]+), ([^\.]+)
      if (match[2]) {
        const startOffset = name.indexOf(match[2])
        const loc = getSelection(
          context,
          getNewPosition(context, start, startOffset),
          getNewPosition(context, start, startOffset + match[2].length)
        )

        let content = match[2]
        let isStatic = true // é™æ€å±æ€§å

        // åŠ¨æ€å±æ€§åè§£æ
        if (content.startsWith('[')) {
          isStatic = false

          if (!content.endsWith(']')) {
            // å¦‚æœæ˜¯åŠ¨æ€å±æ€§åï¼Œå¿…é¡»æ˜¯ [varName] å½¢å¼
            emitError(
              context,
              ErrorCodes.X_MISSING_DYNAMIC_DIRECTIVE_ARGUMENT_END
            )
          }

          content = content.substr(1, content.length - 2)
        }

        arg = {
          type: NodeTypes.SIMPLE_EXPRESSION,
          content,
          isStatic,
          isConstant: isStatic,
          loc
        }
      }

      // å±æ€§æ˜¯å¦è¢«å¼•å·åŒ…èµ·æ¥
      if (value && value.isQuoted) {
        const valueLoc = value.loc
        valueLoc.start.offset++
        valueLoc.start.column++
        valueLoc.end = advancePositionWithClone(valueLoc.start, value.content)
        // å–å¼•å·å†…çš„æ‰€æœ‰å†…å®¹
        valueLoc.source = valueLoc.source.slice(1, -1)
      }

      return {
        type: NodeTypes.DIRECTIVE,
        // : -> v-bind, @ -> v-on, # -> v-slot çš„ç¼©å†™
        name:
        match[1] ||
          (name.startsWith(':') ? 'bind' : name.startsWith('@') ? 'on' : 'slot'),
        exp: value && {
          type: NodeTypes.SIMPLE_EXPRESSION,
          content: value.content,
          isStatic: false,
          isConstant: false,
          loc: value.loc
        },
        arg,
        // ä¿®é¥°ç¬¦å¤„ç†, v-bind.m1.m2 -> .m1.m2 -> ['m1', 'm2']
        modifiers: match[3] ? match[3].substr[1].split('.') : [],
        loc
      }
    }

    return {
      type: NodeTypes.ATTRIBUTE,
      name,
      value: value && {
        type: NodeTypes.TEXT,
        content: value.content,
        loc: value.loc
      },
      loc
    }
  }
#+end_src

è¯¥å‡½æ•°å®ç°ä¸»è¦æœ‰å‡ éƒ¨åˆ†(ä»¥ ~<div v-bind:keyup.enter.prevent="ok"></div>~ ä¸ºä¾‹)ï¼š

1. åŒ¹é…å±æ€§åï¼Œå…³é”®æ­£åˆ™ï¼š ~/^[^\t\r\n\f />][^\t\r\n\f />=]*/~ ä¼šå°†
   ~v-if="varname"~ ä¸­ç­‰å·å‰é¢çš„ ~v-bind:keyup.enter.prevent~ éƒ½åŒ¹é…å‡ºæ¥ã€‚
2. å°†åŒ¹é…åˆ°çš„å±æ€§åæ”¶é›†åˆ° =nameSet[]= ä¸­ï¼Œæ£€æµ‹é‡å¤æ€§ã€‚

   @@html:<font color='purple'>@@è¿™é‡Œéœ€è¦æ³¨æ„çš„æ˜¯ï¼Œå±æ€§ååŒ¹é…çš„ç»“æœä¼šå°†å˜é‡åï¼Œ
   ä¿®é¥°ç¬¦éƒ½åŒ¹é…åˆ°ï¼Œå¦‚ï¼š ~<div v-bind:keyup.enter.prevent="ok">~ ï¼Œæœ€å
   add åˆ° nameSet ä¸­çš„å®Œæ•´å±æ€§åä¸ºï¼š ~v-bind:keyup.enter.prevent~ ã€‚
   @@html:</font>@@

3. éæ³•å±æ€§åæ£€æµ‹(å¦‚ï¼š ~=name=value~ ï¼Œæˆ–å±æ€§åä¸­åŒ…å« =["'<]= å­—ç¬¦)ï¼Œå¼‚å¸¸
4. ç§»åŠ¨æŒ‡é’ˆ =advanceBy(context, name.length)= å®šä½åˆ°å±æ€§ååçš„ä½ç½®ï¼Œç›®çš„æ˜¯ä¸ºäº†å–
   å±æ€§å€¼ï¼Œå‰©ä¸‹ï¼š =="ok"= ã€‚
5. æ­£åˆ™ï¼š =/^[\t\r\n\f ]*=/= ï¼Œè§£æå±æ€§å€¼ï¼Œè°ƒç”¨ [[#pars-parseattributevalue][parseAttributeValue]] è§£æå‡ºå±æ€§å€¼æ¥
   1. æŒ‡é’ˆå½’ä½è‡³å¼€å§‹ä½ç½®ï¼Œå¦‚ï¼š ~v-bind:keyup.enter.prevent="ok"~ çš„å¼€å§‹ä½ç½®ä¸º
      ~v~ ä½ç½®ï¼Œè§£æä¿®é¥°ç¬¦ï¼Œå¾—åˆ° ~modifiers: []~ ï¼Œè¿™é‡Œçš„å…³é”®åœ¨äºæ­£
      åˆ™ï¼š ~/(?:^v-([a-z0-9]+))?(?:(?::|^@|^#)([^\.]+))?(.+)?$/i~ ï¼Œä¼šåŒ¹é… ~v-if,
      :, @, #...~ æŒ‡ä»¤å’ŒæŒ‡ä»¤ç¼©å†™ä»¥åŠä¿®é¥°ç¬¦ã€‚
   2. è§£ææŒ‡ä»¤åé¢çš„å˜é‡åç§°ï¼Œå¦‚ï¼š =keyup= ï¼Œæœ‰å¯èƒ½æ˜¯åŠ¨æ€å€¼ =v-bind:[varname]= ã€‚
   3. æ£€æµ‹å±æ€§å€¼æœ‰æ²¡è¢«å¼•å·åŒ…èµ·æ¥ï¼Œå¦‚æœæœ‰ï¼Œè¦æ›´æ–° =value.loc= ï¼Œåªå–å¼•å·å†…çš„å†…å®¹
      ~content.source = valueLoc.source.slice(1, -1)~
   4. è¿”å›æŒ‡ä»¤èŠ‚ç‚¹ç±»å‹å¯¹è±¡
6. å¦åˆ™è¿”å›æ™®é€šå±æ€§ç±»å‹èŠ‚ç‚¹

** parseAttributeValue(context)
:PROPERTIES:
:COLUMNS:  %CUSTOM_ID[(Custom Id)]
:CUSTOM_ID: parse-parseattributevalue
:END:

è§£æå±æ€§å€¼ã€‚

#+begin_src js
  function parseAttributeValue(context) {
    // ä¿å­˜æ¨¡æ¿å­—ç¬¦ä¸²æŒ‡é’ˆèµ·ç‚¹ä½ç½®
    const start = getCursor(context)

    let content

    const quote = context.source[0]
    const isQuoted = quote === `"` || quote === `'`
    if (isQuoted) {
      // æœ‰å¼•å·
      advanceBy(context, 1)
      const endIndex = context.source.indexOf(quote)
      // æ²¡æœ‰ç»“æŸå¼•å·??? æ•´ä¸ª source å½“åšæ–‡æœ¬æ•°æ®å¤„ç†???
      if ((endIndex = -1)) {
        content = parseTextData(
          context,
          context.source.length,
          TextModes.ATTRIBUTE_VALUE
        )
      } else {
        content = parseTextData(context, endIndex, TextModes.ATTRIBUTE_VALUE)
        advanceBy(context, 1)
      }
    } else {
      // æ²¡æœ‰å¼•å·
      const match = /^[^\t\r\n\f >]+/.exec(context.source)
      if (!match) {
        // æ— å±æ€§å€¼
        return undefined
      }

      const unexpectedChars = /["'<=`]/g
      let m
      while ((m = unexpectedChars.exec(match[0]))) {
        // æ— å¼•å·å€¼ä¸­éæ³•å­—ç¬¦æ£€æµ‹
        emitError(
          context,
          ErrorCodes.UNEXPECTED_CHARACTER_IN_UNQUOTED_ATTRIBUTE_VALUE
        )
      }

      // è§£ææ–‡æœ¬æ•°æ®
      content = parseTextData(context, match[0].length, TextModes.ATTRIBUTE_VALUE)
    }

    return { content, isQuoted, loc: getSelection(context, start) }
  }
#+end_src

** DONE parseCDATA(context, ancestors)
CLOSED: [2020-09-02 Wed 23:14]
:PROPERTIES:
:COLUMNS:  %CUSTOM_ID[(Custom Id)]
:CUSTOM_ID: parse-parsecdata
:END:

- State "DONE"       from "TODO"       [2020-09-02 Wed 23:14]
è§£æ ~<![CDATA[....]]~ xml ç±»å‹æ³¨é‡Šã€‚

#+begin_src js

  // <![CDATA[...
  function parseCDATA(context, ancestors) {
    advanceBy(context, 9); // `<![CDATA[`.length = 9
    const nodes = parseChildren(context, TextModes.CDATA, ancestors);
    if (context.source.length === 0) {
      emitError(context, ErrorCodes.EOF_IN_CDATA);
    } else {
      advanceBy(context, 3);
    }
    return nodes;
  }
#+end_src
** DONE parseBogusComment(context)
CLOSED: [2020-09-02 Wed 23:11]
:PROPERTIES:
:COLUMNS:  %CUSTOM_ID[(Custom Id)]
:CUSTOM_ID: parse-parseboguscomment
:END:

- State "DONE"       from "TODO"       [2020-09-02 Wed 23:11]

è§£æä¸€äº›æ³¨é‡Šæ€§çš„ç»“æ„ï¼Œå¦‚ï¼š ~<!DOCTYPE~ ã€‚

#+begin_src js

  function parseBogusComment(context) {
    const start = getCursor(context);

    const contentStart = context.source[1] === "?" ? 1 : 2;
    let content;

    const closeIndex = context.source.indexOf(">");

    if (closeIndex === -1) {
      // æ²¡æœ‰ç»“æŸç´¢å¼•ï¼Œåé¢æ‰€æœ‰çš„éƒ½å°†æˆä¸ºæ³¨é‡Š
      content = context.source.slice(contentStart);
      advanceBy(context, context.source.length);
    } else {
      content = context.source.slice(contentStart, closeIndex);
      // å®šä½åˆ°æ³¨é‡Šåé¢çš„å­—ç¬¦
      advanceBy(context, closeIndex + 1);
    }

    return {
      type: NodeTypes.COMMENT,
      content,
      loc: getSelection(context, start),
    };
  }
#+end_src
** pushNode(nodes, node)
:PROPERTIES:
:COLUMNS:  %CUSTOM_ID[(Custom Id)]
:CUSTOM_ID: parse-pushnode
:END:

1. æ³¨é‡ŠèŠ‚ç‚¹ä¸å¤„ç†
2. åˆå¹¶æ–‡æœ¬èŠ‚ç‚¹(å‰ææ˜¯ prev, node ä¸¤ä¸ªèŠ‚ç‚¹æ˜¯ç´§æŒ¨ç€çš„ï¼Œç”± =loc.end.offset= å’Œ
   =loc.start.offset= åˆ¤æ–­)
3. è¿”å›æ–°å¢ node çš„ nodes èŠ‚ç‚¹æ•°ç»„

#+begin_src js
  function pushNode(nodes: TemplateChildNode[], node: TemplateChildNode): void {
    // ignore comments in production
    /* istanbul ignore next */
    if (!__DEV__ && node.type === NodeTypes.COMMENT) {
      return
    }

    if (node.type === NodeTypes.TEXT) { // ä¸¤ä¸ªè¿ç€çš„æ–‡æœ¬èŠ‚ç‚¹ï¼Œæ‹¼å‡‘åˆ°ä¸€èµ·å»
      const prev = last(nodes)
      // Merge if both this and the previous node are text and those are
      // consecutive. This happens for cases like "a < b".
      if (
        prev &&
          prev.type === NodeTypes.TEXT &&
          prev.loc.end.offset === node.loc.start.offset
      ) {
        prev.content += node.content
        prev.loc.end = node.loc.end
        prev.loc.source += node.loc.source
        return
      }
    }

    nodes.push(node)
  }
#+end_src

** isEnd(context, mode, ancestors)
:PROPERTIES:
:COLUMNS:  %CUSTOM_ID[(Custom Id)]
:CUSTOM_ID: parse-isend
:END:

#+begin_src js
  function isEnd(
    context: ParserContext,
    mode: TextModes,
    ancestors: ElementNode[]
  ): boolean {
    const s = context.source

    switch (mode) {
      case TextModes.DATA:
        if (startsWith(s, '</')) {
          //TODO: probably bad performance
          for (let i = ancestors.length - 1; i >= 0; --i) {
            if (startsWithEndTagOpen(s, ancestors[i].tag)) {
              return true
            }
          }
        }
        break

      case TextModes.RCDATA:
      case TextModes.RAWTEXT: {
        const parent = last(ancestors)
        if (parent && startsWithEndTagOpen(s, parent.tag)) {
          return true
        }
        break
      }

      case TextModes.CDATA:
        if (startsWith(s, ']]>')) {
          return true
        }
        break
    }

    return !s
  }
#+end_src

** getCursor(context)
:PROPERTIES:
:COLUMNS:  %CUSTOM_ID[(Custom Id)]
:CUSTOM_ID: parse-getCursor
:END:

#+begin_src typescript
  function getCursor(context: ParserContext): Position {
      const { column, line, offset } = context
      return { column, line, offset }
  }
#+end_src

** getSelection(context, start, end?: Postion)
:PROPERTIES:
:COLUMNS:  %CUSTOM_ID[(Custom Id)]
:CUSTOM_ID: parse-getselection
:END:

å–å®æ—¶è§£æåçš„ sourceï¼Œstartï¼Œend çš„å€¼ã€‚

#+begin_src typescript
  function getSelection(
      context: ParserContext,
      start: Position,
      end?: Position
  ): SourceLocation {
      end = end || getCursor(context)
      return {
          start,
          end,
          source: context.originalSource.slice(start.offset, end.offset)
      }
  }
#+end_src

* é‡è¦ç±»å‹å£°æ˜

è¯¥æ¨¡å—æ‰€æœ‰ç±»å‹å£°æ˜ç»Ÿä¸€å½’ç±»åˆ°æ­¤ï¼Œé¡ºåºæŒ‰ç…§ç”¨ä¾‹è§£æé‡åˆ°çš„é¡ºåºä¸ºä¸»ã€‚
** defaultParserOptions

#+begin_src typescript
  // é»˜è®¤çš„è§£æå™¨é€‰é¡¹
  export const defaultParserOptions: MergedParserOptions = {
      delimiters: [`{{`, `}}`],
      getNamespace: () => Namespaces.HTML, // å‘½åç©ºé—´
      getTextMode: () => TextModes.DATA, // æ–‡æœ¬ç±»å‹
      isVoidTag: NO, // è‡ªå…³é—­æ ‡ç­¾???ï¼Œå¦‚ï¼š<img>, <hr> ...
      isPreTag: NO, // <pre> ä»£ç æ ‡ç­¾???ï¼Œéœ€è¦ä¿ç•™ç©ºæ ¼ä¿è¯ç¼©è¿›çš„
      isCustomElement: NO, // è‡ªå®šä¹‰æ ‡ç­¾ï¼Œå¦‚ï¼šTransition
      decodeEntities: (rawText: string): string =>
          // è§£ç å®ä¾‹ï¼Œä¸€äº›ç‰¹æ®Šç¬¦å·è¡¨ç¤ºï¼Œå¦‚ï¼š&gt;, &lt;, &amp;, &apos; &quot;
          rawText.replace(decodeRE, (_, p1) => decodeMap[p1]),
      onError: defaultOnError
  }
#+end_src

** TextModes
:PROPERTIES:
:COLUMNS:  %CUSTOM_ID[(Custom Id)]
:CUSTOM_ID: td-vars-textmodes
:END:

#+begin_src typescript
  export const enum TextModes {
      //          | Elements | Entities | End sign              | Inside of
      DATA, //    | âœ”        | âœ”        | End tags of ancestors |
      RCDATA, //  | âœ˜        | âœ”        | End tag of the parent | <textarea>
      RAWTEXT, // | âœ˜        | âœ˜        | End tag of the parent | <style>,<script>
      CDATA,
      ATTRIBUTE_VALUE
  }
#+end_src
** ParserOptions
:PROPERTIES:
:COLUMNS:  %CUSTOM_ID[(Custom Id)]
:CUSTOM_ID: td-parser-options
:END:

å®šä¹‰ä½ç½®ï¼š
#+begin_export html
<font color="purple"> src/options.ts</font>
#+end_export

æ¥å£å†…å®¹ï¼š
#+begin_src typescript
  export interface ParserOptions {
      /**
       ,* e.g. platform native elements, e.g. <div> for browsers
       ,*/
      isNativeTag?: (tag: string) => boolean
      /**
       ,* e.g. native elements that can self-close, e.g. <img>, <br>, <hr>
       ,*/
      isVoidTag?: (tag: string) => boolean
      /**
       ,* e.g. elements that should preserve whitespace inside, e.g. <pre>
       ,*/
      isPreTag?: (tag: string) => boolean
      /**
       ,* Platform-specific built-in components e.g. <Transition>
       ,*/
      isBuiltInComponent?: (tag: string) => symbol | void
      /**
       ,* Separate option for end users to extend the native elements list
       ,*/
      isCustomElement?: (tag: string) => boolean
      /**
       ,* Get tag namespace
       ,*/
      getNamespace?: (tag: string, parent: ElementNode | undefined) => Namespace
      /**
       ,* Get text parsing mode for this element
       ,*/
      getTextMode?: (
          node: ElementNode,
          parent: ElementNode | undefined
      ) => TextModes
      /**
       ,* @default ['{{', '}}']
       ,*/
      delimiters?: [string, string]
      /**
       ,* Only needed for DOM compilers
       ,*/
      decodeEntities?: (rawText: string, asAttr: boolean) => string
      onError?: (error: CompilerError) => void
  }
#+end_src

å­—æ®µè¯´æ˜ï¼š

1. ~isNativeTag?: (tag: string) => boolean~ ä¸€ä¸ªå‡½æ•°ï¼Œåˆ¤æ–­æ ‡ç­¾æ˜¯å¦æ˜¯åŸç”Ÿæ ‡ç­¾(å¦‚ï¼šli, div)
2. ~isVoidTag?: (tag: string) => boolean~,è‡ªå…³é—­æ ‡ç­¾ï¼Œå¦‚ï¼šimg, br, hr
3. ~isPreTag?: (tag: string) => boolean~ ï¼Œä»£ç æ ‡ç­¾ï¼Œéœ€è¦ç©ºæ ¼ç¼©è¿›çš„ï¼Œå¦‚ï¼špre
4. ~isBuiltInComponent?: (tag: string) => symbol | void~ ï¼Œå¹³å°ç›¸å…³çš„å†…ç½®ç»„ä»¶ï¼Œå¦‚ï¼šTransition
5. ~isCoustomElement?: (tag: string) => boolean~ ï¼Œç”¨æˆ·è‡ªå®šçš„æ ‡ç­¾
6. ~getNamespace?: (tag: string, parent: ElementNode | undefined) => Nâ„amespace~ ï¼Œè·å–æ ‡ç­¾å‘½åç©ºé—´
7. ~getTextMode?: (node: ElementNode, parent: ElementNode|undefined) =>
   TextModes~ è·å–æ–‡æœ¬è§£ææ¨¡å¼
8. ~delimiters?: [string, string]~ ï¼Œæ’å€¼åˆ†éš”ç¬¦ï¼Œé»˜è®¤ï¼š ~['{{', '}}']~
9. ~decodeEntities?: (rawText: string, asAttr: boolean) => string~ ï¼Œä»…ç”¨äº DOM compilers
10. ~onError?: (error: CompilerError) => void~

** ParserContext
:PROPERTIES:
:COLUMNS:  %CUSTOM_ID[(Custom Id)]
:CUSTOM_ID: td-parser-context
:END:

å®šä¹‰ä½ç½®ï¼š
#+begin_export html
<font color="purple"> src/parse.ts</font>
#+end_export

æ¥å£å†…å®¹ï¼š

#+begin_src typescript
  export interface ParserContext {
      options: MergedParserOptions // è§£æå™¨é€‰é¡¹ï¼Œå³åˆå¹¶ä¹‹åçš„å‚æ•°å¯¹è±¡
      readonly originalSource: string // æœ€åˆçš„æºç ï¼Œå³è§£æä¹‹å‰çš„æœ€åŸå§‹çš„å­—ç¬¦ä¸²ï¼Œåªè¯»ç‰ˆæœ¬
      source: string // è§£æä¸­çš„æºç å­—ç¬¦ä¸²ï¼Œä¼šå‘ç”Ÿå˜åŒ–çš„å­—ç¬¦ä¸²
      offset: number // è§£æçš„æŒ‡é’ˆä½ç½®ï¼Œç±»ä¼¼æ–‡ä»¶è¯»å–æ˜¯çš„æŒ‡é’ˆåç§»é‡
      line: number // è§£æä½ç½®åœ¨æºç ä¸­çš„å½“å‰è¡Œ
      column: number // è§£æä½ç½®åœ¨æºç ä¸­çš„å½“å‰åˆ—
      inPre: boolean // æ ‡è¯†æ˜¯ä¸æ˜¯ <pre> æ ‡ç­¾ï¼Œå¦‚æœæ˜¯éœ€è¦ä¿ç•™ç©ºæ ¼ä¿è¯ç¼©è¿›
      inVPre: boolean // v-pre æŒ‡ä»¤ï¼Œä¸å¤„ç†æŒ‡ä»¤å’Œæ’å€¼(v-xxx, {{...}})
  }
#+end_src

* utils.ts
** advancePositionWithMutation(pos,source, numberOfCharacters)
:PROPERTIES:
:COLUMNS:  %CUSTOM_ID[(Custom Id)]
:CUSTOM_ID: util-advancepositionwithmutation
:END:

æ›´æ–° context çš„ lineï¼Œcolumnï¼Œoffset çš„å€¼

#+begin_src typescript
  // advance by mutation without cloning (for performance reasons), since this
  // gets called a lot in the parser
  export function advancePositionWithMutation(
      pos: Position,
      source: string,
      numberOfCharacters: number = source.length
  ): Position {
      let linesCount = 0
      let lastNewLinePos = -1
      for (let i = 0; i < numberOfCharacters; i++) {
          if (source.charCodeAt(i) === 10 /* newline char code */) {
              linesCount++
              lastNewLinePos = i
          }
      }

      pos.offset += numberOfCharacters
      pos.line += linesCount
      pos.column =
          lastNewLinePos === -1
          ? pos.column + numberOfCharacters
          : numberOfCharacters - lastNewLinePos

      return pos
  }
#+end_src

* é˜¶æ®µä»£ç è®°å½•
:PROPERTIES:
:COLUMNS:  %CUSTOM_ID[(Custom Id)]
:CUSTOM_ID: stage_code
:END:

1. [[https://github.com/gcclll/vue-next-code-read/tree/master/bakups/compiler-core/text-test-01-some-text][text01: some text çš„ä»£ç å¤‡ä»½]]
   :PROPERTIES:
   :COLUMNS: %CUSTOM_ID[(Custom Id)]
   :CUSTOM_ID: link-01
   :END:
2. [[https://github.com/gcclll/vue-next-code-read/tree/master/bakups/compiler-core/text-test-02-some-text-div-01][text02: some text \<div> 01 ä»£ç å¤‡ä»½]]
   :PROPERTIES:
   :COLUMNS: %CUSTOM_ID[(Custom Id)]
   :CUSTOM_ID: link-02
   :END:
3. [[https://github.com/gcclll/vue-next-code-read/tree/master/bakups/compiler-core/text-test-02-some-text-div-02][text02: some text \<div> 02 ä»£ç å¤‡ä»½]]
   :PROPERTIES:
   :COLUMNS: %CUSTOM_ID[(Custom Id)]
   :CUSTOM_ID: link-03
   :END:
4. [[https://github.com/gcclll/vue-next-code-read/tree/master/bakups/compiler-core/text-test-03-interpolation][text03: some {{ foo + bar }} text ä»£ç å¤‡ä»½]]
   :PROPERTIES:
   :COLUMNS: %CUSTOM_ID[(Custom Id)]
   :CUSTOM_ID: link-04
   :END:
5. [[https://github.com/gcclll/vue-next-code-read/tree/master/bakups/compiler-core/text-test-03-interpolation][text04: some {{ a<b && c>d }} text ä»£ç å¤‡ä»½]]
   :PROPERTIES:
   :COLUMNS: %CUSTOM_ID[(Custom Id)]
   :CUSTOM_ID: link-05
   :END:
6. [[https://github.com/gcclll/vue-next-code-read/tree/master/bakups/compiler-core/comment-test][comment: <!--x-->æ³¨é‡Šè§£æä»£ç å¤‡ä»½]]
   :PROPERTIES:
   :COLUMNS: %CUSTOM_ID[(Custom Id)]
   :CUSTOM_ID: link-06
   :END:
7. [[#test-element-12][test-element-v-pre ä»£ç å¤‡ä»½]], æ”¯æŒ v-pre å’Œ ~<pre>~ æ ‡ç­¾ï¼Œä»¥åŠæ¢è¡Œ
   :PROPERTIES:
   :COLUMNS: %CUSTOM_ID[(Custom Id)]
   :CUSTOM_ID: link-07
   :END:


æ‰€æœ‰ç”¨ä¾‹å…¨éƒ¨é€šè¿‡ï¼š
:PROPERTIES:
:COLUMNS: %CUSTOM_ID[(Custom Id)]
:CUSTOM_ID: test-parse-all
:END:

#+begin_src js
  âœ  packages git:(master) âœ— jest compiler-core -u
  PASS  compiler-core/__tests__/parse.spec.js (5.287 s)
  compiler: parse
  Text
  âœ“ simple text (8 ms)
  âœ“ simple text with invalid end tag (3 ms)
  âœ“ text with interpolation (2 ms)
  âœ“ text with interpolation which has `<` (1 ms)
  âœ“ text with mix of tags and interpolations (2 ms)
  âœ“ lonly "<" don't separate nodes
        âœ“ lonly "{{" don't separate nodes
  Interpolation
  âœ“ simple interpolation (1 ms)
  âœ“ it can have tag-like notation (1 ms)
  âœ“ it can have tag-like notation (2) (1 ms)
  âœ“ it can have tag-like notation (3) (1 ms)
  âœ“ custom delimiters
  Comment
  âœ“ empty comment (1 ms)
  âœ“ simple comment (1 ms)
  âœ“ two comments
  Element
  âœ“ simple div
  âœ“ empty div (1 ms)
  âœ“ self closing (1 ms)
  âœ“ void element
  âœ“ template element with directives (2 ms)
  âœ“ template element without directives (1 ms)
  âœ“ native element with `isNativeTag` (1 ms)
  âœ“ native element without `isNativeTag` (1 ms)
  âœ“ v-is with `isNativeTag` (2 ms)
  âœ“ v-is without `isNativeTag` (5 ms)
  âœ“ custom element (1 ms)
  âœ“ attribute with no value (2 ms)
  âœ“ attribute with empty value, double quote (1 ms)
  âœ“ attribute with empty value, single quote (1 ms)
  âœ“ attribute with value, double quote (1 ms)
  âœ“ attribute with value, single quote (1 ms)
  âœ“ attribute with value, unquoted
  âœ“ multiple attributes (2 ms)
  âœ“ directive with no value (1 ms)
  âœ“ directive with value
  âœ“ directive with argument (1 ms)
  âœ“ directive with a modifier (1 ms)
  âœ“ directive with two modifiers
  âœ“ directive with argument and modifiers (1 ms)
  âœ“ v-bind shorthand (1 ms)
  âœ“ v-bind shorthand with modifier (1 ms)
  âœ“ v-on shorthand
  âœ“ v-on shorthand with modifier (1 ms)
  âœ“ v-slot shorthand (1 ms)
  âœ“ v-pre (1 ms)
  âœ“ end tags are case-insensitive. (1 ms)
  Others
  âœ“ self closing single tag (1 ms)
  âœ“ self closing multiple tag (5 ms)
  âœ“ valid html (5 ms)
  âœ“ invalid html (54 ms)
  âœ“ parse with correct location info (2 ms)
  decodeEntities option
  âœ“ use the given map (1 ms)
  whitespace management
  âœ“ should remove whitespaces at start/end inside an element
  âœ“ should remove whitespaces w/ newline between elements
  âœ“ should remove whitespaces adjacent to comments (3 ms)
  âœ“ should remove whitespaces w/ newline between comments and elements (1 ms)
  âœ“ should NOT remove whitespaces w/ newline between interpolations (1 ms)
  âœ“ should NOT remove whitespaces w/o newline between elements (1 ms)
  âœ“ should condense consecutive whitespaces in text (1 ms)
  Errors
  ABRUPT_CLOSING_OF_EMPTY_COMMENT
  âœ“ <template><!--></template> (3 ms)
  âœ“ <template><!---></template> (2 ms)
  âœ“ <template><!----></template> (1 ms)
  CDATA_IN_HTML_CONTENT
  âœ“ <template><![CDATA[cdata]]></template> (2 ms)
  âœ“ <template><svg><![CDATA[cdata]]></svg></template> (1 ms)
  DUPLICATE_ATTRIBUTE
  âœ“ <template><div id="" id=""></div></template> (3 ms)
  END_TAG_WITH_ATTRIBUTES
  âœ“ <template><div></div id=""></template> (1 ms)
  END_TAG_WITH_TRAILING_SOLIDUS
  âœ“ <template><div></div/></template> (2 ms)
  EOF_BEFORE_TAG_NAME
  âœ“ <template>< (1 ms)
  âœ“ <template></ (2 ms)
  EOF_IN_CDATA
  âœ“ <template><svg><![CDATA[cdata (2 ms)
                            âœ“ <template><svg><![CDATA[ (2 ms)
                                                       EOF_IN_COMMENT
                                                       âœ“ <template><!--comment (1 ms)
                                                       âœ“ <template><!-- (1 ms)
                                                       âœ“ <template><! (1 ms)
                                                       âœ“ <template><!- (2 ms)
                                                       âœ“ <template><!abc (1 ms)
                                                       EOF_IN_SCRIPT_HTML_COMMENT_LIKE_TEXT
                                                       âœ“ <script><!--console.log('hello') (2 ms)
                                                       âœ“ <script>console.log('hello') (3 ms)
                                                       EOF_IN_TAG
                                                       âœ“ <template><div (2 ms)
                                                       âœ“ <template><div  (2 ms)
                                                       âœ“ <template><div id (2 ms)
                                                       âœ“ <template><div id  (1 ms)
                                                       âœ“ <template><div id = (2 ms)
                                                       âœ“ <template><div id='abc (1 ms)
          âœ“ <template><div id="abc (2 ms)
          âœ“ <template><div id='abc' (2 ms)
          âœ“ <template><div id="abc" (4 ms)
          âœ“ <template><div id=abc (2 ms)
          âœ“ <template><div id='abc'/ (3 ms)
          âœ“ <template><div id="abc"/ (2 ms)
          âœ“ <template><div id=abc / (1 ms)
        INCORRECTLY_CLOSED_COMMENT
          âœ“ <template><!--comment--!></template> (1 ms)
        INCORRECTLY_OPENED_COMMENT
          âœ“ <template><!></template> (1 ms)
          âœ“ <template><!-></template> (2 ms)
          âœ“ <template><!ELEMENT br EMPTY></template> (3 ms)
          âœ“ <!DOCTYPE html> (2 ms)
        INVALID_FIRST_CHARACTER_OF_TAG_NAME
          âœ“ <template>a < b</template> (2 ms)
          âœ“ <template><ï¿½></template> (2 ms)
          âœ“ <template>a </ b</template> (1 ms)
          âœ“ <template></ï¿½></template> (1 ms)
          âœ“ <template>{{a < b}}</template> (1 ms)
        MISSING_ATTRIBUTE_VALUE
          âœ“ <template><div id=></div></template> (3 ms)
          âœ“ <template><div id= ></div></template> (2 ms)
          âœ“ <template><div id= /></div></template> (5 ms)
        MISSING_END_TAG_NAME
          âœ“ <template></></template> (1 ms)
        MISSING_WHITESPACE_BETWEEN_ATTRIBUTES
          âœ“ <template><div id="foo"class="bar"></div></template> (2 ms)
          âœ“ <template><div id="foo"\x0d;\x0a;class="bar"></div></template> (1 ms)
        NESTED_COMMENT
          âœ“ <template><!--a<!--b--></template> (2 ms)
          âœ“ <template><!--a<!--b<!--c--></template> (1 ms)
          âœ“ <template><!--a<!--></template> (1 ms)
          âœ“ <template><!--a<!-- (4 ms)
        UNEXPECTED_CHARACTER_IN_ATTRIBUTE_NAME
          âœ“ <template><div a"bc=''></div></template> (1 ms)
          âœ“ <template><div a'bc=''></div></template> (3 ms)
                                                       âœ“ <template><div a<bc=''></div></template> (3 ms)
                                                       UNEXPECTED_CHARACTER_IN_UNQUOTED_ATTRIBUTE_VALUE
                                                       âœ“ <template><div foo=bar"></div></template> (2 ms)
          âœ“ <template><div foo=bar'></div></template> (3 ms)
          âœ“ <template><div foo=bar<div></div></template> (2 ms)
          âœ“ <template><div foo=bar=baz></div></template> (2 ms)
          âœ“ <template><div foo=bar`></div></template> (2 ms)
        UNEXPECTED_EQUALS_SIGN_BEFORE_ATTRIBUTE_NAME
          âœ“ <template><div =foo=bar></div></template> (2 ms)
          âœ“ <template><div =></div></template> (1 ms)
        UNEXPECTED_QUESTION_MARK_INSTEAD_OF_TAG_NAME
          âœ“ <template><?xml?></template> (1 ms)
        UNEXPECTED_SOLIDUS_IN_TAG
          âœ“ <template><div a/b></div></template> (2 ms)
        X_INVALID_END_TAG
          âœ“ <template></div></template>
          âœ“ <template></div></div></template>
          âœ“ <template>{{'</div>'}}</template> (1 ms)
          âœ“ <textarea></div></textarea> (1 ms)
          âœ“ <svg><![CDATA[</div>]]></svg>
          âœ“ <svg><!--</div>--></svg>
        X_MISSING_END_TAG
          âœ“ <template><div></template> (1 ms)
          âœ“ <template><div> (1 ms)
        X_MISSING_INTERPOLATION_END
          âœ“ {{ foo (1 ms)
          âœ“ {{ (2 ms)
          âœ“ {{}}
        X_MISSING_DYNAMIC_DIRECTIVE_ARGUMENT_END
          âœ“ <div v-foo:[sef fsef] /> (1 ms)

  Test Suites: 1 passed, 1 total
  Tests:       135 passed, 135 total
  Snapshots:   79 passed, 79 total
  Time:        6.398 s, estimated 20 s
  Ran all test suites matching /compiler-core/i.
#+end_src

* é—®é¢˜/ç–‘é—®åˆ—è¡¨
:PROPERTIES:
:COLUMNS:  %CUSTOM_ID[(Custom Id)]
:CUSTOM_ID: issues
:END:


1. @@html:<font color='red'>@@å¦‚ä½•åŒºåˆ†å†…ç½®æ ‡ç­¾|å†…ç½®ç»„ä»¶|æ ¸å¿ƒç»„ä»¶|è‡ªå®šä¹‰ç»„ä»¶ï¼Ÿ[[#parse-parsetag-04][ğŸ›«]]@@html:</font>@@

2. @@html:<font color='red'>@@ä¸ºä»€ä¹ˆ [[#parse-parsetag][parseTag]] è§£æ =<div>= ä¹‹ååªä¼šå¾—
   åˆ° =<div= è€Œä¸ä¼šå°† =>= è§£æè¿›å»ï¼Ÿ[[#parse-parseelement][ğŸ›«]] @@html:</font>@@
  :PROPERTIES:
  :COLUMNS: %CUSTOM_ID[(Custom Id)]
  :CUSTOM_ID: issues-02
  :END: 

   #+begin_example
   ç­”ï¼šæ˜¯å› ä¸ºæ¼æ‰å®ç°äº†ä¸€éƒ¨åˆ†ä»£ç ï¼Œè‡ªé—­åˆæ ‡ç­¾çš„æ£€æµ‹ï¼Œç§»åŠ¨æŒ‡é’ˆ(2/1ä½)
   #+end_example

   å¦‚ä¸‹ï¼š
   #+begin_src js
     function parseTag(context, type) {
       // .... çœç•¥


       // TODO-3 <div/> è‡ªé—­æ ‡ç­¾
       // è¿™é‡Œè¦å®ç°ï¼Œä¸ç„¶æœ€åè§£æå®Œæˆä¹‹å source ä¼šæ˜¯ï¼š>...</span>
       // éœ€è¦æ£€æµ‹ä¸‹æ˜¯ä¸æ˜¯è‡ªé—­åˆæ ‡ç­¾æ¥ç§»åŠ¨æŒ‡é’ˆä½ç½®
       let isSelfClosing = false
       if (context.source.length === 0) {
         emitError(context, ErrorCodes.EOF_IN_TAG)
       } else {
         // some <div> ... </div> åˆ°è¿™é‡Œçš„ source = > ... </div>
         // æ‰€ä»¥å¯ä»¥æ£€æµ‹æ˜¯ä¸æ˜¯ä»¥ /> å¼€å¤´çš„
         isSelfClosing = context.source.startsWith('/>')
         if (type === TagType.End && isSelfClosing) {
           emitError(context, ErrorCodes.END_TAG_WITH_TRAILING_SOLIDUS)
         }
         // å¦‚æœæ˜¯è‡ªé—­åˆæŒ‡é’ˆç§»åŠ¨ä¸¤ä½(/>)ï¼Œå¦åˆ™åªç§»åŠ¨ä¸€ä½(>)
         // åˆ°è¿™é‡Œ source = ... </div>
         advanceBy(context, isSelfClosing ? 2 : 1)
       }

       // ... çœç•¥
     }
   #+end_src

3. @@html:<font color='red'>@@ä¸ºä»€ä¹ˆ [[#parse-parseelement][parseElement]]Â è§£æ children çš„æ—¶å€™å…ˆ
   ancestors.push(element) è§£æä¹‹ååˆ pop() æ‰ï¼Ÿ@@html:</font>@@
  :PROPERTIES:
  :COLUMNS: %CUSTOM_ID[(Custom Id)]
  :CUSTOM_ID: issues-03
  :END: 

   #+begin_example
   ç­”ï¼šè¦å›åˆ°è¿™ä¸ªé—®é¢˜è¦ä» parseChildren å’Œ parseElement ä¸¤ä¸ªå‡½æ•°ç»“åˆæ¥çœ‹ï¼Œå¦‚ä¸‹ä»£ç åˆ†æ
   #+end_example

   #+begin_src js
     // è§£ææµç¨‹(ç”¨ä¾‹5)ï¼š
     // 1. å…ˆ parseChildren(context, mode, ancestors)
     // è§£æ `some <span>{{ foo < bar + foo }} text</span>`
     //   1) é¦–å…ˆå¾—åˆ°çš„æ˜¯ `some ` æ–‡æœ¬èŠ‚ç‚¹
     //   2) æ£€æµ‹åˆ° <span> è¿›å…¥æ ‡ç­¾è§£æ parseElement(context, ancestors) æ³¨æ„è¿™é‡Œçš„     //				ancestorsï¼Œæ˜¯ç”± parseChildren ç»§æ‰¿è¿‡æ¥çš„
     // 2. è¿›å…¥ parseElement è§£æè¿›ç¨‹
     //     1) é‡åˆ° <span> è§£æå‡ºæ ‡ç­¾èŠ‚ç‚¹ span
     //     2) åœ¨è‡ªèº«å‡½æ•°å†…æ£€æµ‹åˆ°æ ‡ç­¾å†…è¿˜æœ‰å†…å®¹ï¼Œé‡æ–°è°ƒç”¨ parseChildren(..., ancestors)
     //    3) æ‰€ä»¥é‡ç‚¹æ¥äº†
     // ...
     // ...
     // ancestors æ˜¯ parseChildren ä¼ é€’è¿‡æ¥çš„ï¼ŒparseElement é‡Œé¢å°†
     // push çš„ç›®çš„ï¼šè®©å­èŠ‚ç‚¹æœ‰æ‰€ä¾èµ–ï¼ŒçŸ¥é“è‡ªå·±çš„çˆ¶çº§æ˜¯è°ï¼Œä½†å¥½åƒ parseChildren é‡Œé¢ç”¨åˆ°
     //     parent ä¹Ÿæ˜¯ä¸ºäº†è·å–å‘½åç©ºé—´å»ç”¨äº†
     // pop çš„ç›®çš„ï¼šéš¾é“æ˜¯ä¸ºäº†ä¸æ±¡æŸ“ ancestors ???
   #+end_src

   å¥½åƒè¿˜ä¸æ˜¯å¾ˆæ˜ç¡®ä¸ºä½•è¦ push->pop(DONE)ã€‚

   *æ›´æ–°ï¼š2020-09-02 16:57:35*

   åœ¨æµ‹è¯•ç”¨ä¾‹ [[#parse-test-other-01][parse-test-other-01]] æ—¶ï¼ŒåµŒå¥—æ ‡ç­¾è§£æçš„æ—¶å€™ ancestors ä¸­ä¿å­˜ç€å¤šçº§
   åµŒå¥—æ ‡ç­¾çš„çˆ¶çº§(å½“å‰è¢«è§£æçš„èŠ‚ç‚¹çš„çˆ¶çº§)ã€‚

   æ¯”å¦‚ï¼š ~<div><span>\n</div></span>~ è¿™ä¸ªæ˜¯åä¾‹å“ˆï¼Œè¿™é‡Œåªæ˜¯ä¸¾ä¾‹ã€‚
   #+begin_example
   ancestors: Array(2)
     0: {type: 1, ns: 0, tag: "div", tagType: 0, props: Array(0), â€¦}
     1: {type: 1, ns: 0, tag: "span", tagType: 0, props: Array(0), â€¦}
     length: 2
   #+end_example

   è§£æé¡ºåºï¼š div -> ~push:ancestors[0]~ -> span -> ~push:ancestors[1]~ -> ~\n~ è§£
   æå®Œæˆä¹‹åï¼Œå‘ç° parent æœ‰å†…å®¹ï¼Œé‚£ä¹ˆè¿™ä¸ªèŠ‚ç‚¹è§£æå®Œä¹‹åä¼šè¢« push åˆ°
   ~span.children~é‡Œé¢å»ï¼Œåˆ°è¿™é‡Œ span è§£æå®Œäº†ï¼Œæ‰€ä»¥è¦é€€å‡ºå½“å‰é€’å½’å›åˆ° div çš„è§£
   æï¼Œå› æ­¤éœ€è¦å°†~ancestors.pop()~ æ‰æœ€åä¸€ä¸ªï¼Œè¿™æ ·æ‰èƒ½ä¿è¯ div çš„ child èƒ½æ­£ç¡®
   push åˆ°~div.ancestors~ ä¸­å»ã€‚
