#+TITLE: Vue3.0 æºç ç³»åˆ—ï¼ˆäºŒï¼‰ç¼–è¯‘å™¨æ ¸å¿ƒ - Compiler core 1: parse.ts
#+DATE: <2020-08-31 22:11:55>
#+TAGS[]: vue, vue3, vuenext, compiler
#+CATEGORIES[]: vue
#+LANGUAGE: zh-cn
#+STARTUP: indent

#+begin_quote
è¯¥ç³»åˆ—æ–‡ç« ï¼Œå‡ä»¥æµ‹è¯•ç”¨ä¾‹é€šè¿‡ä¸ºåŸºå‡†ä¸€æ­¥æ­¥å®ç°ä¸€ä¸ª vue3 æºç å‰¯æœ¬(å­¦ä¹ )ã€‚
#+end_quote

@@html:<kbd>@@æ–‡å­—æ¯”è¾ƒé•¿ï¼Œå¦‚æœä¸æƒ³çœ‹æ–‡å­—å¯ç›´æ¥è½¬åˆ°[[/vue/vue-mind-map-house/][è¿™é‡Œ]]çœ‹è„‘å›¾@@html:</kbd>@@

#+begin_export html
<font color="#fc02ff">å¯èƒ½æ„Ÿå…´è¶£åˆ—è¡¨ï¼š</font>
#+end_export

1. [[#issues][æºç ç›¸å…³çš„ç–‘é—®/é—®é¢˜åˆ—è¡¨åŠå…¶è§£ç­”]] ğŸ›³ ğŸ›³ ğŸ›³ ğŸ›³ ğŸ›³
2. [[#stage_code][é˜¶æ®µæ€§çš„ä»£ç å¤‡ä»½(æ¯”å¦‚èƒ½ pass æŸä¸ªç”¨ä¾‹)]] ğŸš˜ ğŸš˜ ğŸš˜ ğŸš˜ ğŸš˜
* æµ‹è¯•ç”¨ä¾‹åˆ†æ
åŸæœ¬æ˜¯æƒ³ç›´æ¥æ ¹æ®æºç å»äº†è§£è¿™éƒ¨åˆ†çš„å®ç°åŸç†çš„ï¼Œä½†æ˜¯å‘ç°çº¯ç²¹çš„ä»£ç åˆ†ææœ‰ç‚¹å›°éš¾ï¼Œè¿™
éƒ¨åˆ†ä¸åƒ reactivity æ¨¡å—é‚£ä¹ˆç›´è§‚ï¼Œå¹¶ä¸”æ„Ÿè§‰è¿™å—æ¯” reactivity å¤æ‚çš„å¤šï¼Œå› æ­¤å…ˆæ¢ç©¶
å¦‚ä½•ä½¿ç”¨ï¼Œä»å¦‚ä½•ä½¿ç”¨åˆ°æ€ä¹ˆå®ç°å»é€æ­¥å®ç°ï¼Œåˆ†ææºä»£ç ã€‚

compiler-core æ¨¡å—çš„æµ‹è¯•ç”¨ä¾‹åŒ…å«ä»¥ä¸‹éƒ¨åˆ†ï¼Œå°†ä¾æ¬¡è¿›è¡Œåˆ†æï¼š

1. [ ] parse.spec.ts
2. [-] compile.spec.ts
3. [-] codegen.spec.ts
4. [-] scopeId.spec.ts
5. [-] transform.spec.ts
6. [ ] transforms/
   1. [ ] hoistStatic.spec.ts.
   2. [ ] noopDirectiveTransform.spec.ts
   3. [ ] transformElement.spec.ts
   4. [ ] transformExpressions.spec.ts
   5. [ ] transformSlotOutlet.spec.ts
   6. [ ] transformText.spec.ts
   7. [ ] vBind.spec.ts
   8. [ ] vFor.spec.ts
   9. [ ] vIf.spec.ts
   10. [ ] vModel.spec.ts
   11. [ ] vOn.spec.ts
   12. [ ] vOnce.spec.ts
   13. [ ] vSlot.spec.ts
7. [-] utils.spec.ts
8. [-] testUtils.ts
**  parse.spec.ts

æµ‹è¯•ç”¨ä¾‹ç»“æ„ï¼šcompiler: parse
*** Element å…ƒç´ æ ‡ç­¾è§£æ
**** 05-template element with directives
:PROPERTIES:
:COLUMNS:  %CUSTOM_ID[(Custom Id)]
:CUSTOM_ID: test-element-05
:END:

è¿™ä¸ªç”¨ä¾‹å¼€å§‹æ¨¡æ¿çš„è§£æã€‚

#+begin_src js
  test('template element with directives', () => {
    const ast = baseParse('<template v-if="ok"></template>')
    const element = ast.children[0]
    expect(element).toMatchObject({
      type: NodeTypes.ELEMENT,
      tagType: ElementTypes.TEMPLATE
    })
  }
#+end_src

~baseParse('<template v-if="ok"></template>')~ è§£æä¹‹åçš„ç»“æ„ï¼š

#+begin_src json
  {
    "type":0,
    "children":[
      { // <template> èŠ‚ç‚¹
        "type":1,
        "ns":0,
        "tag":"template",
        "tagType":3,
        "props":[
          {
            "type":7, // DIRECTIVE
            "name":"if",
            "exp":{
              "type":4, // SIMPLE_EXPRESSION
              "content":"ok",
              "isStatic":false,
              "isConstant":false,
              "loc":{
                // ... çœç•¥
              }
            },
            "modifiers":[
              // ä¿®é¥°ç¬¦
            ],
            "loc":{
              // çœç•¥
              "source":"v-if="ok""
            }
          }
        ],
        // ... çœç•¥
      }
    ],
    // ... çœå»
  }
#+end_src

ä¸ºäº†èƒ½è§£æå‡º ~v-if="ok"~ æˆ‘ä»¬éœ€è¦å»å®ç° [[#parse-parseattributes][parseAttributes(context, type)]] ->
[[#parse-parseattribute][parseAttribute]] -> [[#parse-parseattributevalue][parseAttributeValue]]

è¯¥ç”¨ä¾‹è€ƒå¯Ÿçš„å…¶å®å¹¶ä¸æ˜¯ ~<template>~ æ¨¡æ¿æ ‡ç­¾è§£æï¼Œè€Œæ˜¯æ ‡ç­¾ä¸Šçš„å±æ€§è§£æï¼Œå¯¹æ™®é€šçš„
~<div>~ æ ‡ç­¾ä¾ç„¶å¯ä»¥è§£æå‡ºå±æ€§ props[]ã€‚
**** 04-void element
:PROPERTIES:
:COLUMNS:  %CUSTOM_ID[(Custom Id)]
:CUSTOM_ID: test-element-04
:END:

ç©ºæ ‡ç­¾è§£æï¼Œå¦‚ï¼š~<img>~

å‰ææ˜¯æä¾›äº† ~isVoidTag()~ é€‰é¡¹ã€‚
#+begin_src js
  test('void element', () => {
    const ast = baseParse('<img>after', {
      isVoidTag: (tag) => tag === 'img'
    })
    const element = ast.children[0]

    expect(element).toStrictEqual({
      type: NodeTypes.ELEMENT,
      ns: Namespaces.HTML,
      tag: 'img',
      tagType: ElementTypes.ELEMENT,
      codegenNode: undefined,
      props: [],

      isSelfClosing: false,
      children: [],
      loc: {
        start: { offset: 0, line: 1, column: 1 },
        end: { offset: 5, line: 1, column: 6 },
        source: '<img>'
      }
    })
  }
#+end_src

è¯¥ç”¨ä¾‹å’Œ[[#test-element-03][è‡ªé—­æ ‡ç­¾]]ç±»ä¼¼éƒ½æ˜¯åœ¨ [[#parse-parsetag][parseTag]] è§£æå®Œä¹‹ååœ¨ [[#parse-parseelement][parseElement]] ä¸­ç»“æŸè§£æï¼Œä¸åŒç‚¹
åœ¨äºè°ƒç”¨ [[#parse-baseparse][baseParse]] çš„æ—¶å€™éœ€è¦ä¼ é€’ä¸€ä¸ªåŒ…å« ~isVoidTag()~ çš„é€‰é¡¹ ~{isVoidTag: tag
=> tag === 'img'}~ ç”¨æ¥å‘Šè¯‰è§£æå™¨ä»€ä¹ˆæ ·çš„æ ‡ç­¾å±äºç©ºæ ‡ç­¾ï¼Œå³ä¸æ˜¯ ~<img/>~ ä¹Ÿä¸æ˜¯
~<div></div>~ ç±»å‹ã€‚

[[#parse-parseelement][parseElement]] ä¸­è§£ææ¡ä»¶ï¼š

#+begin_src js
  parseElement(context, ancestors) {
    // ... parseTag ä¸­è§£æ <img ...>
    // è‡ªé—­åˆçš„åˆ°è¿™é‡Œå°±å¯ä»¥ç»“æŸäº†
    if (element.isSelfClosing || context.options.isVoidTag?.(element.tag)) {
      return element
    }
    // ...
  }
#+end_src

**** 03-self closing
:PROPERTIES:
:COLUMNS:  %CUSTOM_ID[(Custom Id)]
:CUSTOM_ID: test-element-03
:END:
#+begin_src js
  test('self closing', () => {
    const ast = baseParse('<div/>after')
    const element = ast.children[0]

    expect(element).toStrictEqual({
      type: NodeTypes.ELEMENT,
      ns: Namespaces.HTML,
      tag: 'div',
      tagType: ElementTypes.ELEMENT,
      codegenNode: undefined,
      props: [],

      isSelfClosing: true,
      children: [],
      loc: {
        start: { offset: 0, line: 1, column: 1 },
        end: { offset: 6, line: 1, column: 7 },
        source: '<div/>'
      }
    })
  }
#+end_src
**** 02-empty div
:PROPERTIES:
:COLUMNS:  %CUSTOM_ID[(Custom Id)]
:CUSTOM_ID: test-element-02
:END:

å’Œ [[#test-element-01][01-simple div]] ä¸€æ ·ï¼Œæ— éå°±æ˜¯æ²¡æœ‰ ~children[]~ å­èŠ‚ç‚¹äº†ã€‚åœ¨ [[#parse-parseelement][parseElement]] -> [[#parse-parsetag][parseTag]] è§£æå°±ç»“æŸäº†ã€‚

#+begin_src js
  test('empty div', () => {
    const ast = baseParse('<div></div>')
    const element = ast.children[0]

    expect(element).toStrictEqual({
      type: NodeTypes.ELEMENT,
      ns: Namespaces.HTML,
      tag: 'div',
      tagType: ElementTypes.ELEMENT,
      codegenNode: undefined,
      props: [],
      isSelfClosing: false,
      children: [],
      loc: {
        start: { offset: 0, line: 1, column: 1 },
        end: { offset: 11, line: 1, column: 12 },
        source: '<div></div>'
      }
    })
  }
#+end_src

**** 01-simple div
:PROPERTIES:
:COLUMNS:  %CUSTOM_ID[(Custom Id)]
:CUSTOM_ID: test-element-01
:END:

è§£æç»“æœæµç¨‹å›¾(xmind ç”»æµç¨‹å›¾çœŸå® low çš„ä¸è¡Œï¼ŒğŸ˜…)ï¼š

[[http://qiniu.ii6g.com/parse-test-element--01.png]]

drawer.io æµç¨‹å›¾ï¼š

[[http://qiniu.ii6g.com/test-parse-simple-tag.png]]

å› ä¸º [[#parse-parseelement][parseElement]] å·²ç»å®ç°ï¼Œå› æ­¤è¿™ä¸ªé¡ºåˆ©é€šè¿‡ï¼Œ~parseElement~ è§£æå…ˆæ£€æµ‹ ~</div>~
ç»“æŸæ ‡ç­¾ä½ç½®ï¼Œå¦‚æœæ²¡æœ‰åˆ™ä¸ºéæ³•æ— ç»“æŸæ ‡ç­¾è§¦å‘ ~ErrorCodes.EOF_IN_TAG~ å¼‚å¸¸ã€‚
#+begin_src js
  test('simple div', () => {
    const ast = baseParse('<div>hello</div>')
    const element = ast.children[0]

    expect(element).toStrictEqual({
      type: NodeTypes.ELEMENT,
      ns: Namespaces.HTML,
      tag: 'div',
      tagType: ElementTypes.ELEMENT,
      codegenNode: undefined,
      props: [],
      isSelfClosing: false, // <div åä¸º > ä¸ºéè‡ªé—­åˆæ ‡ç­¾
      children: [
        {
          type: NodeTypes.TEXT,
          content: 'hello',
          loc: {
            start: { offset: 5, line: 1, column: 6 }, // h ä½ç½®ç´¢å¼•
            end: { offset: 10, line: 1, column: 11 }, // o ä½ç½®ç´¢å¼•
            source: 'hello'
          }
        }
      ],
      loc: {
        start: { offset: 0, line: 1, column: 1 },
        end: { offset: 16, line: 1, column: 17 },
        // é‡åˆ°<div> ä¼šç›´æ¥åˆ¤æ–­æ˜¯å¦æœ‰ </div> ç„¶åæˆªå–`<div>...</div>
        source: '<div>hello</div>'
      }
    })
  })
#+end_src

æ ‡ç­¾çš„è§£æåœ¨ [[#parse-parsetag][parseTag]] ä¸­å®Œæˆï¼Œ å¦‚æœæ˜¯è‡ªé—­åˆæ ‡ç­¾ï¼Œä¼šç½®æ ‡å¿—ä½ ~isSelfClosing =
true~ ã€‚

å¹¶ä¸”è§£ææ ‡ç­¾åªä¼šè§£æåˆ° =<div>= ä¸­çš„ =<div= éƒ¨åˆ†å°±ç»“æŸï¼Œæ˜¯å› ä¸ºéœ€è¦æ£€æµ‹åé¢æ˜¯ =>=
è¿˜æ˜¯ =/>= å¦‚æœæ˜¯ =/>= åˆ™ä¸ºè‡ªé—­åˆæ ‡ç­¾éœ€è¦åŒºåˆ†å¤„ç†ï¼Œå› æ­¤è¿™é‡Œä¼šæœ‰ä¸ªåˆ¤æ–­æ¥å†³å®š
=advanceBy= 1 æˆ– 2 ä¸ªæŒ‡é’ˆä½ç½®ã€‚

#+begin_src js
  // parseTag
  let isSelfClosing = false
  if (context.source.length === 0) {
    emitError(context, ErrorCodes.EOF_IN_TAG)
  } else {
    // some <div> ... </div> åˆ°è¿™é‡Œçš„ source = > ... </div>
    // æ‰€ä»¥å¯ä»¥æ£€æµ‹æ˜¯ä¸æ˜¯ä»¥ /> å¼€å¤´çš„
    isSelfClosing = context.source.startsWith('/>')
    if (type === TagType.End && isSelfClosing) {
      emitError(context, ErrorCodes.END_TAG_WITH_TRAILING_SOLIDUS)
    }
    // å¦‚æœæ˜¯è‡ªé—­åˆæŒ‡é’ˆç§»åŠ¨ä¸¤ä½(/>)ï¼Œå¦åˆ™åªç§»åŠ¨ä¸€ä½(>)
    // åˆ°è¿™é‡Œ source = ... </div>
    advanceBy(context, isSelfClosing ? 2 : 1)
  }
#+end_src

*** Comment æ³¨é‡Šè§£æ

æ³¨é‡Šé£æ ¼ï¼š =<!-- ... -->= ï¼Œ[[#link-05][é˜¶æ®µ 5]] åŠä¹‹å‰è¿˜ä¸æ”¯æŒæ³¨é‡Šè§£æï¼Œå› ä¸ºè¿˜æ²¡å®ç° [[#parse-parsecomment][parseComment]]ã€‚

æ³¨é‡Šæµ‹è¯•ç”¨ä¾‹ä¸å­˜åœ¨é˜¶æ®µæ€§çš„å®ç°ï¼Œåªè¦å®ç°äº† [[#parse-parsecomment][parseComment]] å°±é¥¿éƒ½å¯ä»¥é€šè¿‡äº†ï¼Œå› æ­¤è¿™é‡Œæ”¾åœ¨ä¸€èµ·é€šè¿‡è®°å½•ã€‚

1. *empty comment* ç©ºæ³¨é‡ŠèŠ‚ç‚¹
2. *simple comment* æ­£å¸¸æ³¨é‡ŠèŠ‚ç‚¹
3. *two comments* å¤šä¸ªæ³¨é‡ŠèŠ‚ç‚¹

#+begin_src js
  describe('Comment', () => {
    test('empty comment', () => {
      const ast = baseParse('<!---->')
      const comment = ast.children[0]

      expect(comment).toStrictEqual({
        type: NodeTypes.COMMENT,
        content: '',
        loc: {
          start: { offset: 0, line: 1, column: 1 },
          end: { offset: 7, line: 1, column: 8 },
          source: '<!---->'
        }
      })
    }) // empty comment

    test('simple comment', () => {
      const ast = baseParse('<!--abc-->')
      const comment = ast.children[0]

      expect(comment).toStrictEqual({
        type: NodeTypes.COMMENT,
        content: 'abc',
        loc: {
          start: { offset: 0, line: 1, column: 1 },
          end: { offset: 10, line: 1, column: 11 },
          source: '<!--abc-->'
        }
      })
    }) // simple comment

    test('two comments', () => {
      const ast = baseParse('<!--abc--><!--def-->')
      const comment1 = ast.children[0]
      const comment2 = ast.children[1]

      expect(comment1).toStrictEqual({
        type: NodeTypes.COMMENT,
        content: 'abc',
        loc: {
          start: { offset: 0, line: 1, column: 1 },
          end: { offset: 10, line: 1, column: 11 },
          source: '<!--abc-->'
        }
      })
      expect(comment2).toStrictEqual({
        type: NodeTypes.COMMENT,
        content: 'def',
        loc: {
          start: { offset: 10, line: 1, column: 11 },
          end: { offset: 20, line: 1, column: 21 },
          source: '<!--def-->'
        }
      })
    }) // two comments
  })
#+end_src

è¿™é‡Œæ€»å…±æœ‰ä¸‰ä¸ªç”¨ä¾‹ï¼Œä¸€å¼€å§‹æµ‹è¯•å¹¶ä¸èƒ½é€šè¿‡ï¼Œæ˜¯å› ä¸ºå®ç° [[#parse-pushnode][pushNode]] çš„æ—¶å€™å¿˜è®°åŠ ä¸Š
=__DEV__= ç¯å¢ƒæ£€æµ‹äº†ï¼Œå› ä¸ºç”Ÿäº§ç¯å¢ƒæ˜¯ä¸éœ€è¦ä¿å­˜æ³¨é‡ŠèŠ‚ç‚¹çš„ï¼Œå¼€å‘ç¯å¢ƒä¸ºäº†æµ‹è¯•éœ€è¦æœ‰
è¿™ä¸ªä¿¡æ¯ã€‚

#+begin_src js
  function pushNode(nodes, node) {
    // è¿™é‡ŒåŠ ä¸Š __DEV__ æ£€æµ‹ï¼Œå¼€å‘çš„æ—¶å€™è¿˜æ˜¯éœ€è¦çš„
    // ä¸ç„¶ç”¨ä¾‹ä¼šé€šä¸è¿‡ï¼Œå› ä¸ºè¿™é‡Œç›´æ¥è¿”å› Undefined äº†ï¼Œå¯¼è‡´
    // parent.children[] é‡Œé¢å¹¶ä¸å­˜åœ¨è¿™ä¸ªæ³¨é‡ŠèŠ‚ç‚¹
    // åŠ ä¸Šå°±å¥½äº†
    if (!__DEV__ && node.type === NodeTypes.COMMENT) {
      // æ³¨é‡ŠèŠ‚ç‚¹ä¸å¤„ç†
      return
    }

    // ... çœç•¥
  }
#+end_src

*** Interpolation æ’å€¼è§£æ

**** 05-custom delimiters
:PROPERTIES:
:COLUMNS:  %CUSTOM_ID[(Custom Id)]
:CUSTOM_ID: test-interpolation-05
:END:

è‡ªå®šä¹‰æ’å€¼åˆ†éš”ç¬¦ï¼Œå…¶å®å¤„ç†æµç¨‹å’Œæ’å€¼å¤„ç†ä¸€æ ·ï¼Œæ‰€ä»¥æ²¡å•¥å¥½è®²çš„ï¼Œ[[#link-04][é˜¶æ®µä»£ç  4]] å°±æ”¯æŒè¯¥ç”¨ä¾‹é€šè¿‡ã€‚
#+begin_src js
  test('custom delimiters', () => {
    const ast = baseParse('<p>{msg}</p>', {
      delimiters: ['{', '}']
    })
    const element = ast.children[0]
    const interpolation = element.children[0]

    expect(interpolation).toStrictEqual({
      type: NodeTypes.INTERPOLATION,
      content: {
        type: NodeTypes.SIMPLE_EXPRESSION,
        content: `msg`,
        isStatic: false,
        isConstant: false,
        loc: {
          start: { offset: 4, line: 1, column: 5 },
          end: { offset: 7, line: 1, column: 8 },
          source: 'msg'
        }
      },
      loc: {
        start: { offset: 3, line: 1, column: 4 },
        end: { offset: 8, line: 1, column: 9 },
        source: '{msg}'
      }
    })
  })
#+end_src

**** 04-it can have tag-like notation (3)
:PROPERTIES:
:COLUMNS:  %CUSTOM_ID[(Custom Id)]
:CUSTOM_ID: test-interpolation-04
:END:

å‰é¢çš„ä¸¤ä¸ªç”¨ä¾‹å·²ç»è§£é‡Šè¿‡äº†ï¼Œæ’å€¼é‡Œé¢çš„å†…å®¹ä¼šåœ¨ [[#parse-parseinterpolation][parseInterpolation]] ä¸­ç›´æ¥å¤„ç†æˆæ’
å€¼çš„æ¨¡æ¿(source)ï¼Œä¸ä¼šè¿›å…¥åˆ° while å¾ªç¯è§¦å‘å¼‚å¸¸ã€‚

#+begin_src typescript
  test('it can have tag-like notation (3)', () => {
      const ast = baseParse('<div>{{ "</div>" }}</div>')
      // è¿™é‡Œè§£æå‡ºæ¥çš„æ˜¯ <div></div> è¿™ä¸ªå…ƒç´ èŠ‚ç‚¹
      const element = ast.children[0] as ElementNode
      // æ ‡ç­¾å†…éƒ¨çš„æ‰€æœ‰å†…å®¹åœ¨è§£æä¹‹åä¼šè¢«å½“åšå­èŠ‚ç‚¹å­˜æ”¾åˆ° children[] æ•°ç»„ä¸­
      // å› æ­¤è¿™é‡Œç¬¬ä¸€ä¸ªå­èŠ‚ç‚¹æ˜¯ä¸ªæ’å€¼æ¨¡æ¿
      const interpolation = element.children[0] as InterpolationNode

      expect(interpolation).toStrictEqual({
          type: NodeTypes.INTERPOLATION,
          content: {
              type: NodeTypes.SIMPLE_EXPRESSION,
              isStatic: false,
              // The `isConstant` is the default value and will be determined in `transformExpression`.
              isConstant: false,
              content: '"</div>"',
              loc: {
                  start: { offset: 8, line: 1, column: 9 },
                  end: { offset: 16, line: 1, column: 17 },
                  source: '"</div>"'
              }
          },
          loc: {
              start: { offset: 5, line: 1, column: 6 },
              end: { offset: 19, line: 1, column: 20 },
              source: '{{ "</div>" }}'
          }
      })
  })
#+end_src

**** 03-it can have tag-like notation(2)
:PROPERTIES:
:COLUMNS:  %CUSTOM_ID[(Custom Id)]
:CUSTOM_ID: test-interpolation-03
:END:

è¿™ä¸ªç”¨ä¾‹å…¶å®å’Œ [[#test-interpolation-02][ç”¨ä¾‹ 2]] æ˜¯ä¸€æ ·çš„ï¼Œåªä¸è¿‡æ˜¯è§£æäº†ä¸¤ä¸ªæ’å€¼è€Œå·²ï¼Œå…ˆè§£æ ={{ a<b }}=
ï¼Œæœ€åå‰©ä¸‹çš„ ={{ c>d }}= ä¼šåœ¨é€€å‡º [[#parse-parseinterpolation][parseInterpolation]] ä¹‹åå‰©ä½™çš„ context.source
ä¸º ={{ c>d }}= åœ¨ [[#parse-parsechildren][parseChildren]] é‡Œé¢ç»§ç»­è¿›è¡Œ while å¾ªç¯å¤„
ç†ï¼Œéšåˆæ£€æµ‹åˆ°æ˜¯æ’å€¼å†æ¬¡è°ƒç”¨ =parseInterpolation= è¿›è¡Œå¤„ç†å¾—åˆ°ç¬¬äºŒä¸ªæ’å€¼èŠ‚ç‚¹ã€‚
#+begin_src typescript
  test('it can have tag-like notation (2)', () => {
      const ast = baseParse('{{ a<b }}{{ c>d }}')
      const interpolation1 = ast.children[0] as InterpolationNode
      const interpolation2 = ast.children[1] as InterpolationNode

      expect(interpolation1).toStrictEqual({
          type: NodeTypes.INTERPOLATION,
          content: {
              type: NodeTypes.SIMPLE_EXPRESSION,
              content: `a<b`,
              isStatic: false,
              isConstant: false,
              loc: {
                  start: { offset: 3, line: 1, column: 4 },
                  end: { offset: 6, line: 1, column: 7 },
                  source: 'a<b'
              }
          },
          loc: {
              start: { offset: 0, line: 1, column: 1 },
              end: { offset: 9, line: 1, column: 10 },
              source: '{{ a<b }}'
          }
      })

      expect(interpolation2).toStrictEqual({
          type: NodeTypes.INTERPOLATION,
          content: {
              type: NodeTypes.SIMPLE_EXPRESSION,
              isStatic: false,
              isConstant: false,
              content: 'c>d',
              loc: {
                  start: { offset: 12, line: 1, column: 13 },
                  end: { offset: 15, line: 1, column: 16 },
                  source: 'c>d'
              }
          },
          loc: {
              start: { offset: 9, line: 1, column: 10 },
              end: { offset: 18, line: 1, column: 19 },
              source: '{{ c>d }}'
          }
      })
  }
#+end_src

[[#link-04][æ”¯æŒè¯¥ç”¨ä¾‹ä»£ç é“¾æ¥ğŸ›¬]]

**** 02-it can have tag-like notation(1)
:PROPERTIES:
:COLUMNS:  %CUSTOM_ID[(Custom Id)]
:CUSTOM_ID: test-interpolation-02
:END:

è¯¥ç”¨ä¾‹é‡Œé¢è™½ç„¶æœ‰ =<= ç¬¦å·ï¼Œä½†æ˜¯ç”±äºæ˜¯åœ¨æ’å€¼å†…éƒ¨ï¼Œä¼šè¿›å…¥ [[#parse-parseinterpolation][parseInterpolation]] ä¹‹å
å°±è¢«è§£ææˆæ’å€¼çš„ sourceï¼Œå¹¶ä¸ä¼šè¿›å…¥ while é‡Œé¢çš„ä½œä¸ºæ ‡ç­¾çš„å¼€å§‹ =<= æ¥è§£æã€‚

#+begin_src js
  test('it can have tag-like notation', () => {
    const ast = baseParse('{{ a<b }}')
    const interpolation = ast.children[0]

    expect(interpolation).toStrictEqual({
      type: NodeTypes.INTERPOLATION,
      content: {
        type: NodeTypes.SIMPLE_EXPRESSION,
        content: `a<b`, // content = preTrimContent.trim() å»æ‰å‰åç©ºæ ¼
        isStatic: false,
        isConstant: false,
        loc: {
          start: { offset: 3, line: 1, column: 4 },
          end: { offset: 6, line: 1, column: 7 },
          source: 'a<b'
        }
      },
      loc: {
        start: { offset: 0, line: 1, column: 1 },
        end: { offset: 9, line: 1, column: 10 },
        source: '{{ a<b }}'
      }
    })
  })
#+end_src

[[#link-04][é€šè¿‡è¯¥ç”¨ä¾‹ä»£ç é“¾æ¥ğŸ›¬]]

****  01- simple interpolation
:PROPERTIES:
:COLUMNS:  %CUSTOM_ID[(Custom Id)]
:CUSTOM_ID: test-interpolation-01
:END:

#+begin_src js
  test('simple interpolation', () => {
    const ast = baseParse('{{message}}')
    const interpolation = ast.children[0]

    expect(interpolation).toStrictEqual({
      type: NodeTypes.INTERPOLATION,
      content: {
        type: NodeTypes.SIMPLE_EXPRESSION,
        content: `message`,
        isStatic: false,
        isConstant: false,
        loc: {
          start: { offset: 2, line: 1, column: 3 }, // m ä½ç½®
          end: { offset: 9, line: 1, column: 10 }, // æœ€åä¸€ä¸ª e ä½ç½®
          source: `message`
        }
      },
      loc: {
        start: { offset: 0, line: 1, column: 1 }, // ç¬¬ä¸€ä¸ª { ä½ç½®
        end: { offset: 11, line: 1, column: 12 }, // æœ€åä¸€ä¸ª } ä½ç½®
        source: '{{message}}'
      }
    })
  }
#+end_src

*** Text æ–‡æœ¬è§£æ

**** 07-lonly "{{" don\'t separate nodes
:PROPERTIES:
:COLUMNS:  %CUSTOM_ID[(Custom Id)]
:CUSTOM_ID: test-text-06
:END:

è¿™ä¸ªç”¨ä¾‹æ˜¯ç”¨æ¥æ£€æµ‹æ’å€¼ä¸å®Œæ•´çš„æƒ…å†µï¼Œæ­£å¸¸ä¼šçˆ†å‡º =X_MISSING_INTERPOLATION_END= å¼‚
å¸¸ï¼Œåœ¨è¯¥ç”¨ä¾‹ä¸­é‡å†™äº†è¯¥å¼‚å¸¸å¤„ç†ï¼Œå› æ­¤ä¸ä¼šæŠ¥é”™ï¼Œç”¨ä¾‹ä¼šå¾ˆé¡ºåˆ©é€šè¿‡ï¼Œå› ä¸ºæ²¡æœ‰å¼‚å¸¸ï¼Œ
[[#parse-parseinterpolation][parseInterpolation]] ä¼šé€€å‡ºï¼Œæœ€å ={{= ä¼šè¢«å½“åšæ™®é€šæ–‡æœ¬å†…å®¹å¤„ç†ã€‚

#+begin_src js
  test('lonly "{{" don\'t separate nodes', () => {
    const ast = baseParse('a {{ b', {
      onError: (error) => {
        if (error.code !== ErrorCodes.X_MISSING_INTERPOLATION_END) {
          throw error
        }
      }
    })
    const text = ast.children[0]

    expect(text).toStrictEqual({
      type: NodeTypes.TEXT,
      content: 'a {{ b',
      loc: {
        start: { offset: 0, line: 1, column: 1 },
        end: { offset: 6, line: 1, column: 7 },
        source: 'a {{ b'
      }
    })
  }) // lonly "{{" don\'t separate nodes
#+end_src

[[#parse-parseInterpolation][parseInterpolation]] è¯¥ç”¨ä¾‹å¤„ç†ä»£ç ï¼š

#+begin_src js
  function parseInterpolation(context, mode) {
    // æ‰¾å‡ºæ’å€¼æ¨¡æ¿çš„å¼€å§‹å’Œç»“æŸç¬¦å·ï¼Œé»˜è®¤æ˜¯ {{ å’Œ }}
    const [open, close] = context.options.delimiters
    const closeIndex = context.source.indexOf(close, open.length)
    if (closeIndex === -1) {
      // è¿™é‡Œæ£€æµ‹åˆ°æ²¡æœ‰ }} é€€å‡ºï¼Œå¹¶ä¸”åˆ°è¿™é‡Œ context æŒ‡é’ˆä¿¡æ¯å¹¶æ²¡æœ‰æ”¹å˜
      // å› æ­¤é€€å‡ºä¹‹åï¼Œé‡æ–° while æœ€åè¿›å…¥æ–‡æœ¬è§£æ parseText
      emitError(context, ErrorCodes.X_MISSING_INTERPOLATION_END)
      return undefined
    }

    // ... çœç•¥
  }
#+end_src

test:

#+begin_example
  âœ  packages git:(master) âœ— jest compiler-core
   PASS  compiler-core/__tests__/parse.spec.js (19.233 s)
    compiler: parse
      Text
        âœ“ simple text (5 ms)
        âœ“ simple text with invalid end tag (2 ms)
        âœ“ text with interpolation (1 ms)
        âœ“ text with interpolation which has `<` (1 ms)
        âœ“ text with mix of tags and interpolations (1 ms)
        âœ“ lonly "<" don't separate nodes (7 ms)
        âœ“ lonly "{{" don't separate nodes

  Test Suites: 1 passed, 1 total
  Tests:       7 passed, 7 total
  Snapshots:   0 total
  Time:        23.277 s
  Ran all test suites matching /compiler-core/i
#+end_example

****  06-lonly "<" don\'t separate nodes
:PROPERTIES:
:COLUMNS:  %CUSTOM_ID[(Custom Id)]
:CUSTOM_ID: test-text-05
:END:

#+begin_src js
  test('lonly "<" don\'t separate nodes', () => {
    const ast = baseParse('a < b', {
      onError: (err) => {
        if (err.code !== ErrorCodes.INVALID_FIRST_CHARACTER_OF_TAG_NAME) {
          throw err
        }
      }
    })
    const text = ast.children[0]

    expect(text).toStrictEqual({
      type: NodeTypes.TEXT,
      content: 'a < b',
      loc: {
        start: { offset: 0, line: 1, column: 1 },
        end: { offset: 5, line: 1, column: 6 },
        source: 'a < b'
      }
    }) // lonly "<" don\'t separate nodes
  }
#+end_src

è¿™ä¸ªç”¨ä¾‹åœ¨å®ç°çš„ [[#test-text-05][test-05]] ä¹‹åå°±å¯ä»¥é€šè¿‡ï¼Œå› ä¸º =a < b= å¹¶ä¸æ˜¯æ’å€¼ä¸€éƒ¨åˆ†ï¼Œä¼šè¢«å½“åš
çº¯æ–‡æœ¬å¤„ç†ï¼Œè€Œä¸ºäº†é¿å…æŠ¥é”™ç”¨ä¾‹ä¸­é‡å†™äº† =onError=ï¼Œå› ä¸º while å¾ªç¯é‡Œåœ¨æ£€æµ‹åˆ° =<=
å¼€å¤´çš„ if æ¡ä»¶åˆ†æ”¯ä¸­ï¼Œç¬¬äºŒä¸ªå­—ç¬¦ä¸ºç©ºæ ¼çš„æƒ…å†µä¼šè¿›å…¥æœ€åçš„ else åˆ†æ”¯å¤„ç†ï¼Œå³è§¦å‘
=INVALID_FIRST_CHARACTER_OF_TAG_NAME= å¼‚å¸¸ã€‚

#+begin_src js
  else if (mode === TextModes.DATA && s[0] === '<') {
    // ... æ ‡ç­¾å¼€å¤´ <...
    if (s.length === 1) {
      emitError(context, ErrorCodes.EOF_BEFORE_TAG_NAME, 1)
    } else if (s[1] === '!') {
      // TODO æ³¨é‡Šå¤„ç†ï¼Œ<!-- ...
    } else if (s[1] === '/') {
      // ...
    } else if (/[a-z]/i.test(s[1])) {
      // ...
    } else if (s[1] === '?') {
      // ...
    } else {
      // ä¼šè¿›å…¥åˆ°è¿™é‡Œï¼Œè§¦å‘å¼‚å¸¸ï¼Œä½†æ˜¯ç”±äº options é‡Œæä¾›äº† onError é‡å†™äº†å®ƒ
      // å› æ­¤è¿™é‡Œä¸ä¼šè§¦å‘å¼‚å¸¸ï¼Œè€Œæ˜¯é€€å‡ºè¯¥åˆ†æ”¯è¿›å…¥ çº¯æ–‡æœ¬å¤„ç†ï¼Œåˆå¹¶æ–‡æœ¬ pushnode æ“ä½œ
      emitError(context, ErrorCodes.INVALID_FIRST_CHARACTER_OF_TAG_NAME, 1)
    }
  }
#+end_src

***  05-text with mix of tags and interpolations
:PROPERTIES:
:COLUMNS:  %CUSTOM_ID[(Custom Id)]
:CUSTOM_ID: test-text-05
:END:

#+begin_src typescript
  test('text with mix of tags and interpolations', () => {
      const ast = baseParse('some <span>{{ foo < bar + foo }} text</span>')
      const text1 = ast.children[0] as TextNode
      const text2 = (ast.children[1] as ElementNode).children![1] as TextNode

      expect(text1).toStrictEqual({
          type: NodeTypes.TEXT,
          content: 'some ',
          loc: {
              start: { offset: 0, line: 1, column: 1 },
              end: { offset: 5, line: 1, column: 6 },
              source: 'some '
          }
      })
      expect(text2).toStrictEqual({
          type: NodeTypes.TEXT,
          content: ' text',
          loc: {
              start: { offset: 32, line: 1, column: 33 },
              end: { offset: 37, line: 1, column: 38 },
              source: ' text'
          }
      })
  }
#+end_src

è¿™æ˜¯ä¸ªæ ‡ç­¾+æ’å€¼æ··åˆæ¨¡æ¿ï¼Œç°é˜¶æ®µçš„ä»£ç æ˜¯é€šä¸è¿‡è¯¥æµ‹è¯•çš„ï¼Œå› ä¸ºå®ƒä¼šè¿›å…¥åˆ°ä¸‹é¢è¿™ä¸ªåˆ†æ”¯ï¼š

#+begin_src js
  else if (/[a-z]/i.test(s[2])) {
    // è¿™é‡Œéƒ½å‡ºé”™äº†ï¼Œä¸ºå•¥åé¢è¿˜æœ‰ä¸ª parseTag ???
    // åˆ°è¿™é‡Œå°±ä¼šæŠ¥é”™
    emitError(context, ErrorCodes.X_INVALID_END_TAG)
    parseTag(context, TagType.End, parent)
    continue
  } else {
#+end_src

å¦‚æ§åˆ¶å°è¾“å‡ºï¼š

[[/img/1596638044.png]]

é”™è¯¯ä¸Šé¢çš„è¾“å‡ºå…¶å®æ˜¯ }} å’Œ {{ çš„è§£æä½ç½®ä¿¡æ¯ï¼Œå¹¶ä¸” =<div>= å¹¶æ²¡æœ‰è§£ææ˜¯å› ä¸ºæˆ‘ä»¬
è¿˜æ²¡å®ç° [[#parse-parseelement][parseElement]] åˆ†æ”¯é€»è¾‘ï¼Œæ‰€ä»¥ç›´æ¥è¿‡æ»¤æ‰å½“æˆæ–‡æœ¬å¤„ç†äº†ã€‚

1. @@html:<font color='blue'>@@å³è¾¹ï¼š offset=14 åˆšå¥½æ˜¯ `some <span>{{ ` å­—ç¬¦ä¸²é•¿åº¦ + 1 å³æ’å€¼å†…ç¬¬ä¸€ä¸ªç©ºæ ¼çš„ä½ç½®@@html:</font>@@

2. @@html:<font color='blue'>@@å·¦è¾¹ï¼šoffset=29 åˆšå¥½æ˜¯ 14 + `foo < bar + foo` é•¿åº¦ä½ç½®(slice ä¸åŒ…å« endIdx)ï¼Œ å³æ’å€¼å†…æœ€åä¸€ä¸ªç©ºæ ¼çš„ä½ç½®@@html:</font>@@

æ¥ä¸‹æ¥æˆ‘ä»¬å¾—çœ‹ä¸‹æ€ä¹ˆä¸æŠ¥é”™èƒ½è§£æ =</div>= ã€‚

@@html:<font color='green'>@@
å¤§æ¦‚çš„çŒœæƒ³æ˜¯åœ¨è§£æ =<div>= çš„æ—¶å€™å‘ç°æ˜¯æ ‡ç­¾ï¼Œå¯èƒ½ä¼šé‡å†™
=onError= ï¼Œé¿å…åœ¨è§£æ =</div>= è§¦å‘å¼‚å¸¸ï¼Œè€Œæ˜¯è¿›å…¥ [[#parse-parsetag][parseTag]]
è§£æç»“æŸæ ‡ç­¾ã€‚ä½†å¾ˆå¯æƒœä¸æ˜¯è¿™æ ·ï¼Œè€Œæ˜¯åœ¨ [[#parse-parselement][parseElement]] ä¸­é€’å½’
è°ƒç”¨ [[#parse-parsechildren][parseChildren]] è§£ææ ‡ç­¾å†…éƒ¨çš„æ¨¡æ¿ï¼Œè§£æå®Œæˆä¹‹åæ£€æµ‹
ç»“æŸæ ‡ç­¾ï¼Œæ— ç»“æŸæ ‡ç­¾ï¼Œéæ³•å¼‚å¸¸ï¼Œå…·ä½“å®ç°è¯·çœ‹ [[#parse-parseelement][parseElement æºç å®
ç°]]ã€‚
@@html:</font>@@

åœ¨å®ç°äº† [[#parse-parseelement][parseElement]] å’Œéƒ¨åˆ† [[#parse-parsetag][parseTag]] ä¹‹åç”¨ä¾‹é€šè¿‡ï¼š

#+begin_example
âœ  packages git:(master) âœ— jest compiler-core
 PASS  compiler-core/__tests__/parse.spec.js (14.492 s)
  compiler: parse
    Text
      âœ“ simple text (5 ms)
      âœ“ simple text with invalid end tag (2 ms)
      âœ“ text with interpolation (2 ms)
      âœ“ text with interpolation which has `<` (1 ms)
      âœ“ text with mix of tags and interpolations (2 ms)

Test Suites: 1 passed, 1 total
Tests:       5 passed, 5 total
Snapshots:   0 total
Time:        15.743 s
Ran all test suites matching /compiler-core/i.
#+end_example

æœŸé—´ç¢°åˆ°ä¸ªé—®é¢˜ï¼š

> Cannot find module 'core-js/modules/es6.string.iterator' from 'packages/compiler-core/parse.js'

è§£å†³æ–¹æ¡ˆï¼š[[https://github.com/babel/babel/issues/9796][æ˜¯ core-js é™çº§åˆ° 2]]
**** 04-text with interpolation which has `<`
:PROPERTIES:
:COLUMNS:  %CUSTOM_ID[(Custom Id)]
:CUSTOM_ID: test-text-04
:END:

#+begin_src typescript
  test('text with interpolation which has `<`', () => {
      const ast = baseParse('some {{ a<b && c>d }} text')
      const text1 = ast.children[0] as TextNode
      const text2 = ast.children[2] as TextNode

      expect(text1).toStrictEqual({
          type: NodeTypes.TEXT,
          content: 'some ',
          loc: {
              start: { offset: 0, line: 1, column: 1 },
              end: { offset: 5, line: 1, column: 6 },
              source: 'some '
          }
      })
      expect(text2).toStrictEqual({
          type: NodeTypes.TEXT,
          content: ' text',
          loc: {
              start: { offset: 21, line: 1, column: 22 },
              end: { offset: 26, line: 1, column: 27 },
              source: ' text'
          }
      })
  })
#+end_src

è¿™ä¸ªç”¨ä¾‹å…¶å®å’Œ [[#test-text-03][03-text with interpolation]] ç”¨ä¾‹åŸç†ä¸€æ ·ï¼Œè™½ç„¶æ’å€¼é‡Œé¢æœ‰ç‰¹æ®Šå­—ç¬¦
=<= ï¼Œä½†æ˜¯ç”±äºåœ¨ [[#parse-parseInterpolation][parseInterpolation]] å‡½æ•°è§£æè¿‡ç¨‹ä¸­æ˜¯é€šè¿‡æˆªå– {{ åˆ° }} ç›´æ¥çš„å…¨éƒ¨
å­—ç¬¦ä¸²å»è§£æçš„ã€‚
#+begin_src typescript
  function parseInterpolation(
      context: ParserContext,
      mode: TextModes
  ): InterpolationNode | undefined {
      // ... çœç•¥

      // ä¹Ÿå°±æ˜¯è¿™ä¸¤è¡Œï¼Œå°† {{ ... }} å†…çš„æ‰€æœ‰å†…å®¹ä¸€æ¬¡æ€§å–å‡ºæ¥è§£æäº†ï¼Œå› æ­¤å¹¶ä¸ä¼š
      // è¿›å…¥åˆ° parseChildren çš„ while å¾ªç¯ä¸­å¤„ç†ï¼Œä¹Ÿå°±ä¸ä¼šå‡ºç°å¼‚å¸¸æƒ…å†µ
      const rawContentLength = closeIndex - open.length
      const rawContent = context.source.slice(0, rawContentLength)

      // ... çœç•¥
  }
#+end_src

æ‰€ä»¥è¿™ä¸ªç”¨ä¾‹ä¼šå¾ˆé¡ºåˆ©çš„é€šè¿‡(åœ¨ 03 ç”¨ä¾‹é€šè¿‡çš„å‰æä¸‹)ã€‚

#+begin_example
 PASS  packages/compiler-core/__tests__/parse.spec.js (5.375 s)
  compiler: parse
    Text
      âœ“ simple text (5 ms)
      âœ“ simple text with invalid end tag (3 ms)
      âœ“ text with interpolation (41 ms)
      âœ“ text with interpolation which has `<` (3 ms)


#+end_example

**** 03-text with interpolation
:PROPERTIES:
:COLUMNS:  %CUSTOM_ID[(Custom Id)]
:CUSTOM_ID: test-text-03
:END:

[[#link-04][è¯¥ç”¨ä¾‹ä»£ç é“¾æ¥ ->]]

è¯¥ç”¨ä¾‹æ£€éªŒçš„å·®å€¼çš„å¤„ç†ã€‚
#+begin_src typescript
  test("text with interpolation", () => {
      const ast = baseParse("some {{ foo + bar }} text");
      const text1 = ast.children[0],
      text2 = ast.children[2];

      expect(text1).toStrictEqual({
          type: NodeTypes.TEXT,
          content: "some ",
          loc: {
              start: { offset: 0, line: 1, column: 1 },
              source: "some ",
              end: { offset: 5, line: 1, column: 6 },
          },
      });

      expect(text2).toStrictEqual({
          type: NodeTypes.TEXT,
          content: " text",
          loc: {
              start: { offset: 20, line: 1, column: 21 },
              source: " text",
              end: { offset: 25, line: 1, column: 26 },
          },
      });
  }
#+end_src

å·®å€¼çš„å¤„ç†åˆ†æ”¯åœ¨ parseChildren çš„

#+begin_src typescript
  if (!context.inVPre && startsWith(s, context.options.delimiters[0])) {
      // '{{'
      node = parseInterpolation(context, mode)
  }
#+end_src

å®Œæˆï¼Œå› ä¸ºéœ€è¦ [[#parse-parseInterpolation][parseInterpolation()]] çš„æ”¯æŒã€‚

ç”¨ä¾‹ç»“æœ(@@html:<font color='green'>@@OK@@html:</font>@@ )ï¼š

#+begin_example
âœ  vue-next-code-read git:(master) âœ— jest parse.spec
 PASS  packages/compiler-core/__tests__/parse.spec.js
  compiler: parse
    Text
      âœ“ simple text (4 ms)
      âœ“ simple text with invalid end tag (2 ms)
      âœ“ text with interpolation (47 ms)

  console.log
    { column: 18, line: 1, offset: 17 } { column: 9, line: 1, offset: 8 } 1

      at parseInterpolation (packages/compiler-core/parse.js:262:11)

Test Suites: 1 passed, 1 total
Tests:       3 passed, 3 total
Snapshots:   0 total
Time:        8.776 s
Ran all test suites matching /parse.spec/i.
âœ  vue-next-code-read git:(master) âœ—
#+end_example

**** 02-simple text\<div>
:PROPERTIES:
:COLUMNS:  %CUSTOM_ID[(Custom Id)]
:CUSTOM_ID: test-text-02
:END:

[[#link-03][è¯¥ç”¨ä¾‹ä»£ç é“¾æ¥->]]

åœ¨è·‘è¿™ä¸ªç”¨ä¾‹çš„æ—¶å€™å‡ºç°å†…å­˜æº¢å‡ºäº†ï¼ŒæŸ¥äº†ä¸‹åŸå› æ˜¯å› ä¸ºåªæ˜¯[[#link-02][å¢åŠ äº† while é‡Œé¢çš„å„ç§
if åˆ†æ”¯]]ï¼Œä½†æ˜¯å®é™…å¹¶æ²¡æœ‰å®ç°ï¼Œè¿™ä¸ªç”¨ä¾‹ä¼šèµ°åˆ°

#+begin_src js
  else if (mode === TextModes.DATA && s[0] === "<") {
    // ... æ ‡ç­¾å¼€å¤´ <...
    if (s.length === 1) {
      emitError(context, ErrorCodes.EOF_BEFORE_TAG_NAME, 1);
    } else if (s[1] === "!") {
      // TODO æ³¨é‡Šå¤„ç†ï¼Œ<!-- ...
    } else if (s[1] === "/") {
      // </...
      if (s.length === 2) {
        emitError(context, ErrorCodes.EOF_BEFORE_TAG_NAME, 2);
      } else if (s[2] === ">") {
        // ...
      } else if (/[a-z]/i.test(s[2])) {
        // ä¼šèµ°åˆ°è¿™ä¸ªåˆ†æ”¯é‡Œé¢ï¼Œä½†æ˜¯ç”±äºä¸‹é¢çš„ parseTag æœªå®ç°ï¼Œå› æ­¤ä¸€ç›´åœ¨è¿™ä¸ªåˆ†æ”¯é‡Œé¢å¾ªç¯
        // åŠ ä¸Šç”¨ä¾‹é‡Œé¢é‡å†™äº† onError ä¸ä¼š throw err ç»ˆæ­¢ï¼Œå› æ­¤ä¼šå‡ºç°æ­»å¾ªç¯
        emitError(context, ErrorCodes.X_INVALID_END_TAG);
        // ä½†æ˜¯ä¸Šé¢éƒ½æŠ¥é”™äº†ï¼Œä¸ºä»€ä¹ˆè¿™é‡Œè¿˜è¦åŠ ä¸ª parseTag??? æ­£å¸¸ç†è§£åº”è¯¥æ˜¯èµ°ä¸åˆ°è¿™é‡Œå•Š
        // é™¤éæœ‰é‡å†™ onError æŠ¥é”™æœºåˆ¶???
        // parseTag(context, TagType.End, parent);
        continue;
      } else {
        // ...
      }
#+end_src

å› æ­¤è¦é€šè¿‡è¿™ä¸ªç”¨ä¾‹ï¼Œå°±å¿…é¡»å¾—å®ç° =parseTag(context, TagType.End, parent)= å‡½æ•°è§£ææ ‡ç­¾ã€‚

#+begin_src js
  test("simple text with invalid end tag", () => {
    const onError = jest.fn();
    const ast = baseParse("some text</div>", {
      onError,
    });
    const text = ast.children[0];

    expect(onError).toBeCalled();
    expect(text).toStrictEqual({
      type: NodeTypes.TEXT,
      content: "some text",
      loc: {
        start: { offset: 0, line: 1, column: 1 },
        end: { offset: 9, line: 1, column: 10 },
        source: "some text",
      },
    });
  }
#+end_src

å› ä¸º baseparse è°ƒç”¨çš„æ—¶å€™æœ‰ä¼ é€’ onError è¦†ç›–æŠ¥é”™ä»£ç ï¼Œä¼šè¿›å…¥åˆ° parseTag è¿›è¡Œè§£æ
æ ‡ç­¾ï¼Œå¦‚æœä¸å®ç°ä¼šå¯¼è‡´æ­»å¾ªç¯ã€‚å› æ­¤è¿™é‡Œè¦é€šè¿‡è¿™ä¸ªç”¨ä¾‹å°±å¿…é¡»å®ç° [[#parse-parsetag][parseTag()]]:

#+begin_src js
  function parseTag(context, type, parent) {
    // è·å–å½“å‰è§£æçš„èµ·å§‹ä½ç½®ï¼Œæ­¤æ—¶å€¼åº”è¯¥æ˜¯ some text çš„é•¿åº¦
    const start = getCursor(context);
    // åŒ¹é… </div è¿‡æ»¤æ‰ç©ºæ ¼å­—ç¬¦ï¼Œä½†æ˜¯ä¸ºä»€ä¹ˆè¦æŠŠ > ç»™å¿½ç•¥æ‰???
    const match = /^<\/?([a-z][^\t\r\n\f />]*)/i.exec(context.source);
    const tag = match[1];
    const ns = context.options.getNamespace(tag, parent);
    // log1: æ”¹å˜ä½ç§»ï¼Œå°† offset å®šä½åˆ° </div> çš„æœ€æœ‰ä¸€ä¸ª > ä¸Š
    // åœ¨è¿™é‡Œ context.offset = 10, context.line = 1
    advanceBy(context, match[0].length);
    // è¿‡æ»¤æ‰ç©ºæ ¼
    advanceSpaces(context);
    // log2: ç»è¿‡ advance ä¹‹å context.offset = 15, context.line = 1
    // æ­£å¥½è¿‡æ»¤ </div 5 ä¸ªå­—ç¬¦
    const cursor = getCursor(context);
    const currSource = context.source;
  }
#+end_src

parseTag å®ç°åˆ°è¿™é‡Œå°±å¯ä»¥æ»¡è¶³é€šè¿‡æµ‹è¯•ç”¨ä¾‹çš„æ¡ä»¶äº†ï¼Œè¿™é‡Œé¢ä¼šå»åŒ¹é… =</div= ç„¶åå°†
å…¶è¿‡æ»¤æ‰(é€šè¿‡ advanceBy å’Œ advanceSpaces æ¥æ”¹å˜ context é‡Œé¢çš„ offset å’Œ line å€¼)ï¼Œ
è¾“å‡ºç»“æœ(log1 å’Œ log2 ä½ç½® context çš„è¾“å‡º)ï¼š

[[/img/1595444610.png]]

**** 01-simple text
:PROPERTIES:
:COLUMNS:  %CUSTOM_ID[(Custom Id)]
:CUSTOM_ID: test-text-01
:END:

è¿™é‡Œç”¨åˆ°çš„å°±ä¸€ä¸ª baseParse å‡½æ•°ï¼Œéœ€è¦æˆ‘ä»¬æ¥å®ç°å…¶åŸºæœ¬çš„åŠŸèƒ½ä»¥é€šè¿‡è¯¥ç”¨ä¾‹ã€‚

ç”¨ä¾‹æºç ï¼š

#+begin_src js
  test('simple text', () => {
    const ast = baseParse('some text')
    const text = ast.children[0] as TextNode

    expect(text).toStrictEqual({
      type: NodeTypes.TEXT,
      content: 'some text',
      loc: {
        start: { offset: 0, line: 1, column: 1 },
        end: { offset: 9, line: 1, column: 10 },
        source: 'some text'
      }
    })
  })
#+end_src

[[https://github.com/gcclll/vue-next-code-read/tree/master/bakups/compiler-core/test-01-some-text][ç”¨ä¾‹çš„åŸºæœ¬åŠŸèƒ½ï¼ŒéªŒè¯ baseParse è§£æå‡ºæ¥çš„æ–‡æœ¬èŠ‚ç‚¹å¯¹è±¡æ˜¯å¦æ»¡è¶³åŸºæœ¬è¦æ±‚ã€‚]]

æ”¯æŒè¯¥ç”¨ä¾‹çš„é‡è¦éƒ¨åˆ†ä»£ç ï¼š

1. createParseContext æ„å»ºè¢«è§£æçš„å†…å®¹çš„å¯¹è±¡ç»“æ„
   #+begin_src js
     function createParserContext(context, options) /*ParserContext*/ {
       return {
         options: {
           ...defaultParserOptions,
           ...options,
         },
         // åˆå§‹åŒ–ä»¥ä¸‹å†…å®¹
         column: 1,
         line: 1,
         offset: 0,
         originalSource: context,
         source: context,
         inPref: false,
         inVPref: false,
       };
     }
   #+end_src
2. parseChildren
   #+begin_src js
     function parseChildren(
       context /* ParserContext*/,
       mode /*TextModes*/,
       ancesotrs /*ElementNode[]*/
     ) {
       // ...
       const nodes /*TemplateChildNode[]*/ = [];

       while (!isEnd(context, mode, ancesotrs)) {
         // do sth

         const s = context.source;
         let node = undefined;

         // ç”±äº baseparse é‡Œé¢ä¼ è¿‡æ¥çš„æ˜¯ä¸ª DATA ç±»å‹ï¼Œå› æ­¤ä¼šèµ°åˆ°è¿™ä¸ª if é‡Œ
         // é¢å»è§£æ
         if (mode === TextModes.DATA || mode === TextModes.RCDATA) {
           // è¿‡ç•¥æ‰éæ–‡æœ¬çš„
           if (!context.inVPre && s.startsWith(context.options.delimiters[0])) {
             // ... æ’å€¼å¤„ç†{{}}
           } else if (mode === TextModes.DATA && s[0] === "<") {
             // ... æ ‡ç­¾å¼€å¤´ <...
           }

           // ... åˆ°è¿™é‡Œä¹Ÿå°±æ˜¯è¯´æ–‡æœ¬èŠ‚ç‚¹ä¸ä¼šè¢«è¿™ä¸ª if å¤„ç†ï¼Œè€Œæ˜¯ç›´æ¥åˆ°
           // !node ç»™ parseText è§£æ
         }

         if (!node) {
           // çº¯æ–‡æœ¬é‡ç‚¹åœ¨è¿™é‡Œé¢å¤„ç†ï¼Œæˆªå–å­—ç¬¦ç›´åˆ°é‡åˆ° <, {{, ]]> æ ‡å¿—ç»“æŸ
           // ç„¶åä¼ å…¥åˆ° parseTextData() åˆ¤æ–­æ˜¯å¦æ˜¯æ•°æ®ç»‘å®šçš„å˜é‡ï¼Œåœ¨
           // context.options.decodeEntities() ä¸­å¤„ç†
           node = parseText(context, mode);
         }

         if (Array.isArray(node)) {
           for (let i = 0; i < node.length; i++) {
             pushNode(nodes, node[i]);
           }
         } else {
           pushNode(nodes, node);
         }
       }

       let removedWhitespace = false;

       return removedWhitespace ? nodes.filter(Boolean) : nodes;
     }
   #+end_src
3. parseText
   #+begin_src js
     function parseText(context, mode) {
       // å­—ç¬¦ä¸²è§£æç›´åˆ°é‡åˆ° <, {{, ]]> ä¸ºæ­¢
       const endTokens = ["<", context.options.delimiters[0]];
       if (mode === TextModes.CDATA) {
         endTokens.push("]]>");
       }

       let endIndex = context.source.length;
       for (let i = 0; i < endTokens.length; i++) {
         const index = context.source.indexOf(endTokens[i], 1);
         if (index !== -1 && endIndex > index) {
           endIndex = index;
         }
       }

       const start = getCursor(context);
       // è§£æ & å¼€å¤´çš„ html è¯­ä¹‰çš„ç¬¦å·(>,<,&,',")
       const content = parseTextData(context, endIndex, mode);
       return {
         type: NodeTypes.TEXT,
         content,
         // loc:{ start, end, source}
         // start,end: { line, column, offset }
         loc: getSelection(context, start),
       };
     }
   #+end_src
4. parseTextData
   #+begin_src js
     // è§£ææ–‡æœ¬æ•°æ®ï¼Œçº¯æ–‡æœ¬å†…å®¹
     function parseTextData(context, length, mode) {
       const rawText = context.source.slice(0, length);
       // è§£ææ¢è¡Œï¼Œæ›´æ–° line, column, offsetï¼Œè¿”å›æ¢è¡Œä¹‹åçš„çš„ source
       advanceBy(context, length);
       if (
         mode === TextModes.RAWTEXT ||
           mode === TextModes.CDATA ||
           rawText.indexOf("&") === -1
       ) {
         return rawText;
       }

       return context.options.decodeEntities(
         rawText,
         mode === TextModes.ATTRIBUTE_VALUE
       );
     }
   #+end_src
5. advancedBy è§£æå¤šä¸ªå­—ç¬¦ä¹‹åæ›´æ–° =start,end(line,column,offset)= ï¼Œå°¤å…¶æ˜¯æ¢è¡Œç¬¦çš„ç‰¹æ®Šå¤„ç†ã€‚
   #+begin_src js
     function advanceBy(context, numberOfCharacters) {
       const { source } = context;
       advancePositionWithMutation(context, source, numberOfCharacters);
       context.source = source.slice(numberOfCharacters);
     }
   #+end_src
6. advancePositionWithMutation
   #+begin_src js
     export function advancePositionWithMutation(
       pos,
       source,
       numberOfCharacters = source.length
     ) {
       let linesCount = 0;
       let lastNewLinePos = -1;
       for (let i = 0; i < numberOfCharacters; i++) {
         if (source.charCodeAt(i) === 10 /* newline char code */) {
           linesCount++;
           lastNewLinePos = i;
         }
       }

       pos.offset += numberOfCharacters;
       pos.line += linesCount;
       pos.column =
         lastNewLinePos === -1
         ? pos.column + numberOfCharacters
         : numberOfCharacters - lastNewLinePos;

       return pos;
     }
   #+end_src

* å‡½æ•°åˆ—è¡¨
:PROPERTIES:
:COLUMNS:  %CUSTOM_ID[(Custom Id)]
:CUSTOM_ID: parse-funcs
:END:

** baseParse(context, options)
:PROPERTIES:
:COLUMNS:  %CUSTOM_ID[(Custom Id)]
:CUSTOM_ID: parse-baseparse
:END:

#+begin_src js
  function baseParse(content, options /* ParserOptions */) /*RootNode*/ {
    const context = createParserContext(content, options);
    const start = getCursor(context);
    return createRoot(
      parseChildren(context, TextModes.DATA, []),
      getSelection(context, start)
    );
  }
#+end_src

baseParse å†…éƒ¨å®ç°åŸºæœ¬å°±æ˜¯è°ƒç”¨å…¶ä»–æ–¹æ³•ï¼Œæ‰€ä»¥æ¥ä¸‹æ¥æˆ‘ä»¬å¾—é’ˆå¯¹å®ƒä½¿ç”¨çš„å‡ ä¸ªæ–¹æ³•å»é€ä¸€å®ç°ï¼š

1. [[#parse-createparsecontext][createParserContext]]ï¼Œåˆ›å»ºèŠ‚ç‚¹è§£æå¯¹è±¡ï¼ŒåŒ…å«è§£æè¿‡ç¨‹ä¸­éœ€è¦æˆ–éœ€è¦ä¿å­˜çš„æ•°æ®
2. [[#parse-getcursor][getCursor]]ï¼Œè·å– context ä¸­çš„ offset, line, column, start, end ç­‰ä¿¡æ¯
3. [[vue/vue3-source-code-compiler-core-ast_ts/#ast-createroot][createRoot]]ï¼Œåˆ›å»ºæ ¹èŠ‚ç‚¹
4. [[#parse-parsechildren][parseChildren]]ï¼Œè§£æå­èŠ‚ç‚¹
5. [[#parse-getselection][getSelection]]ï¼Œè·å–é€‰ä¸­çš„æœªè§£æçš„å†…å®¹

[[#parse-baseparse][baseParse]] å‡½æ•°å¤§ä½“ç»“æ„å’Œä»£ç è°ƒç”¨å›¾ç¤ºï¼š
:PROPERTIES:
:COLUMNS: %CUSTOM_ID[(Custom Id)]
:CUSTOM_ID: pic-baseparse
:END:

[[/img/parse-ts-baseparse-0.png]]

** createParseContext(context, options)
:PROPERTIES:
:COLUMNS:  %CUSTOM_ID[(Custom Id)]
:CUSTOM_ID: parse-createparsecontext
:END:

å‡½æ•°ä½œç”¨ï¼š*åˆ›å»ºè§£æå™¨ä¸Šä¸‹æ–‡å¯¹è±¡(åŒ…å«è§£æè¿‡ç¨‹ä¸­çš„ä¸€äº›è®°å½•ä¿¡æ¯)*

å‡½æ•°å£°æ˜ï¼š

=function createParserContext(context, options) /*ParserContext*/ {}=

å‚æ•°æ²¡ä»€ä¹ˆå¥½è®²çš„äº†ï¼Œä» baseParse ç»§æ‰¿è€Œæ¥ï¼Œè¿”å›çš„æ˜¯ä¸€ä¸ª [[#td-parser-context][ParserContext]] ç±»å‹ã€‚å…·ä½“
å®ç°å…¶å®å°±æ˜¯è¿”å›ä¸€ä¸ª ParserContext ç±»å‹çš„å¯¹è±¡ï¼Œé‡Œé¢åŒ…å«äº†æºç å­—ç¬¦ä¸²è¢«è§£ææ˜¯çš„ä¸€
äº›ä¿¡æ¯å­˜å‚¨ï¼Œæ¯”å¦‚ï¼šè§£ææ—¶æŒ‡é’ˆçš„ä½ç½® offsetï¼Œå½“å‰è¡Œåˆ—(line, column)ï¼ŒåŠå…¶ä»–ä¿¡æ¯ã€‚

#+begin_src typescript
  function createParserContext(
      content: string,
      options: ParserOptions
  ): ParserContext {
      return {
          options: {
              // è§£æå™¨çš„é»˜è®¤é€‰é¡¹ç»™äº†äº›é»˜è®¤å€¼ï¼Œæ¯”å¦‚ï¼šisVoidTag: No, isPreTag: NOï¼Œ ç­‰ç­‰
              ...defaultParserOptions,
              ...options
          },
          column: 1,
          line: 1,
          offset: 0,
          originalSource: content,
          source: content,
          inPre: false,
          inVPre: false
      }
  }
#+end_src

** parseChildren(context, mode, ancestors)
:PROPERTIES:
:COLUMNS:  %CUSTOM_ID[(Custom Id)]
:CUSTOM_ID: parse-parsechildren
:END:

#+begin_src js
  function parseChildren(
    context /* ParserContext*/,
    mode /*TextModes*/,
    ancesotrs /*ElementNode[]*/
  ) /* TemplateChildNode[] */{}
#+end_src

å‚æ•°åˆ—è¡¨ï¼š

1. contextï¼Œå¾…è§£æçš„æ¨¡æ¿å¯¹è±¡([[#td-parser-context][ParserContext]])
2. modeï¼Œæ–‡æœ¬æ¨¡å¼([[#td-vars-textmodes][TextModes]])
3. ancestorsï¼Œç¥–å…ˆå…ƒç´ ([[#td-ast-elementnode][ElementNode[]â€‹]])

è¿”å›ç»“æœï¼š [[/vue/vue3-source-code-compiler-core-ast_ts/#td-ast-tcn][TemplateChildNode[]â€‹]]

### é˜¶æ®µä¸€([[#test-01-sometext][test01 some text]])

å®ç° [[#parse-parsetext][parseText()]] ä¹‹åçš„ [[#parse-parsechildren][parseChildren() ]]ä»£ç ï¼š

#+begin_src js
  function parseChildren(
    context /* ParserContext*/,
    mode /*TextModes*/,
    ancesotrs /*ElementNode[]*/
  ) {
    // ...
    const nodes /*TemplateChildNode[]*/ = [];

    while (!isEnd(context, mode, ancesotrs)) {
      // do sth

      const s = context.source;
      let node = undefined;

      // ç”±äº baseparseé‡Œé¢ä¼ è¿‡æ¥çš„æ˜¯ä¸ª DATA ç±»å‹ï¼Œå› æ­¤ä¼šèµ°åˆ°è¿™ä¸ª if é‡Œ
      // é¢å»è§£æ
      if (mode === TextModes.DATA || mode === TextModes.RCDATA) {
        // è¿‡ç•¥æ‰éæ–‡æœ¬çš„
        if (!context.inVPre && s.startsWith(context.options.delimiters[0])) {
          // ... æ’å€¼å¤„ç†{{}}
        } else if (mode === TextModes.DATA && s[0] === "<") {
          // ... æ ‡ç­¾å¼€å¤´ <...
        }

        // ... åˆ°è¿™é‡Œä¹Ÿå°±æ˜¯è¯´æ–‡æœ¬èŠ‚ç‚¹ä¸ä¼šè¢«è¿™ä¸ª if å¤„ç†ï¼Œè€Œæ˜¯ç›´æ¥åˆ°
        // !node ç»™ parseText è§£æ
      }

      if (!node) {
        node = parseText(context, mode);
      }

      if (Array.isArray(node)) {
        for (let i = 0; i < node.length; i++) {
          pushNode(nodes, node[i]);
        }
      } else {
        pushNode(nodes, node);
      }
      console.log(context, "parse children");
    }

    let removedWhitespace = false;

    return removedWhitespace ? nodes.filter(Boolean) : nodes;
  }
#+end_src

æœ€åå¤„ç†å®Œä¹‹åæ–‡æœ¬èŠ‚ç‚¹å¯¹è±¡å†…å®¹å¦‚ä¸‹ï¼š

#+begin_src js
  {
    options: {
      delimiters: [ '{{', '}}' ],
      getNamespace: [Function: getNamespace],
      getTextMode: [Function: getTextMode],
      isVoidTag: false,
      isPreTag: false,
      isCustomElement: false,
      decodeEntities: [Function: decodeEntities],
      onError: null
    },
    // è¿™é‡Œå‘ç”Ÿäº†å˜æ¢
    // column: å®šä½åˆ°äº†å­—ç¬¦ä¸²æœ€åå³ 'simple text' çš„é•¿åº¦ + 1ï¼Œå³ç»“æŸä½ç½®
    // line: å› ä¸ºåªæœ‰ä¸€è¡Œï¼Œæ‰€ä»¥ line å¹¶æœªå‘ç”Ÿæ”¹å˜ï¼Œå¦‚æœå‘ç”Ÿäº†æ”¹å˜ä¼šåœ¨ advancedBy é‡Œé¢è¿›è¡Œå¤„ç†æ›´æ–°
    // offset: ç±»ä¼¼æ–‡ä»¶å¤„ç†æ—¶çš„æŒ‡é’ˆåç§»é‡ï¼Œå³å­—ç¬¦ä¸²é•¿åº¦
    column: 12,
    line: 1,
    offset: 11,
    // ä¼šå‘ç°å¤„ç†å®Œæˆä¹‹åï¼ŒoriginalSource ç»´æŒåŸæ ·
    originalSource: 'simple text',
    // source å˜æˆäº†ç©ºå­—ç¬¦ä¸²ï¼Œå› ä¸ºå¤„ç†å®Œäº†
    source: '',
    inPref: false,
    inVPref: false
  } // parse children
#+end_src

[[#parse-baseparse][baseParse]] ä¹‹åçš„ ast ç»“æ„ï¼š

#+begin_src js
  // è¿™ä¸ªç»“æ„çš„å½¢æˆæ˜¯ç»è¿‡ createRoot å¤„ç†ä¹‹åçš„ç»“æœ
  // ç»è¿‡ parseChildren ä¹‹åçš„ç»“æœä¼šè¢«å­˜æ”¾åˆ° root çš„children ä¸­ï¼Œå¦‚ä¸‹
  {
    type: 0,
    children: [
      {
        type: 2,
        content: '\nsimple text 1\n simple text 2\n',
        loc: [Object]
      }
    ],
    loc: {
      start: { column: 1, line: 1, offset: 0 },
      end: { column: 1, line: 4, offset: 30 },
      source: '\nsimple text 1\n simple text 2\n'
    },
    helpers: [],
    components: [],
    directives: [],
    hoists: [],
    imports: [],
    cached: 0,
    temps: 0,
    codegenNode: undefined
  } //// ast

  // ç¬¬ä¸€ä¸ª children ç»“æ„ï¼š
  {
    type: 2,
    content: '\nsimple text 1\n simple text 2\n',
    loc: {
      start: { column: 1, line: 1, offset: 0 },
      end: { column: 1, line: 4, offset: 30 },
      source: '\nsimple text 1\n simple text 2\n'
    }
  } //// ast
#+end_src

é˜¶æ®µä»£ç ï¼š[[#link-01][test-01-some-text æµ‹è¯•ç”¨ä¾‹é€šè¿‡]]

å›¾ç¤ºï¼šæ–‡æœ¬è§£æ

[[http://qiniu.ii6g.com/parse-ts-parsechildren-text-part.png][parseChildren-æ”¯æŒçº¯æ–‡æœ¬è§£æ]]

** parseComment(context)
:PROPERTIES:
:COLUMNS:  %CUSTOM_ID[(Custom Id)]
:CUSTOM_ID: parse-parsecomment
:END:

æ³¨é‡Šå¤„ç†å‡½æ•°ï¼Œè§£æåŸåˆ™æ˜¯åŒ¹é… =<!--= å¼€å¤´å’Œ =-->= ç»“å°¾ï¼Œä¸­é—´éƒ¨åˆ†ç»Ÿç»Ÿè§†ä¸ºæ³¨é‡Šï¼Œä¸­
é—´éœ€è¦è€ƒè™‘åµŒå¥—æ³¨é‡Šé—®é¢˜ã€‚

#+begin_src js
  function parseComment(context) /* CommentNode */ {
    const start = getCursor(context)
    let content

    const match = /--(\!)?>/.exec(context.source)
    if (!match) {
      // æ²¡æœ‰é—­åˆæ³¨é‡Šï¼Œåé¢çš„æ‰€æœ‰éƒ½ä¼šè¢«å½“åšæ³¨é‡Šå¤„ç†
      content = context.source.slice(4)
      advanceBy(context, context.source.length) // åé¢æ‰€æœ‰çš„éƒ½æˆä¸ºæ³¨é‡Š
      emitError(context, ErrorCodes.EOF_IN_COMMENT)
    } else {
      console.log(match)
      if (match.index <= 3) {
        // ç©ºæ³¨é‡Šä¹ŸæŠ¥é”™
        emitError(context, ErrorCodes.ABRUPT_CLOSING_OF_EMPTY_COMMENT)
      }

      // éæ³•ç»“æŸï¼Œæ¯”å¦‚ï¼š <!-xx--!>ï¼Œæ­£åˆ™é‡Œé¢æœ‰ä¸ª (\!)? æ•è·ç»„
      // match[1] å°±æ˜¯æŒ‡è¿™ä¸ªåŒ¹é…
      if (match[1]) {
        emitError(context, ErrorCodes.INCORRECTLY_CLOSED_COMMENT)
      }

      // å–æ³¨é‡Šå†…å®¹ï¼Œmatch.index å³ /--(\!)?>/ æ­£åˆ™åŒ¹é…çš„å¼€å§‹ç´¢å¼•ä½ç½®
      content = context.source.slice(4, match.index)

      // åµŒå¥—æ³¨é‡Š??? è¿™é‡Œslice ä¹‹åçš„ s ä¸åŒ…å«ç»“æŸ -->
      const s = context.source.slice(0, match.index)
      let prevIndex = 1,
          nestedIndex = 0

      console.log({ s })
      // é¦–å…ˆèƒ½è¿›å…¥ parseCommentï¼Œè¯´æ˜ source æ˜¯ä»¥ <!-- å¼€å¤´çš„ï¼Œä¸”æ˜¯åŒ…å« --> çš„
      // å¦åˆ™å‰é¢å°±ä¼šå‡ºç°å¼‚å¸¸ï¼Œå› æ­¤å¦‚æœåµŒå¥—é‚£å¯èƒ½æƒ…å†µåªæœ‰<!--x<!--y-->æ³¨é‡Šä¸­é—´
      // å‡ºç°è¿‡ <!--
      while ((nestedIndex = s.indexOf('<!--', prevIndex)) !== -1) {
        console.log({ nestedIndex, prevIndex, s, len: s.length })
        advanceBy(context, nestedIndex - prevIndex + 1)
        // + 4 å€¼æ˜¯ `<!--`.lengthï¼Œå¦‚æœå°äº s.lengthï¼Œè¯´æ˜åµŒå¥—äº†æ³¨é‡Š
        if (nestedIndex + 4 < s.length) {
          // éæ³•åµŒå¥—, å¦‚ï¼š<!--<!--x-->
          emitError(context, ErrorCodes.NESTED_COMMENT)
        }

        /// ç„¶åå®šä½åˆ°åµŒå¥—çš„ç¬¬ä¸€ä¸ª <!-- çš„ ! ç´¢å¼•ä¸Šï¼Œè¿›å…¥ä¸‹ä¸€è½®å¤„ç†ï¼Œç›´
        // åˆ°æ‰¾åˆ°æœ€åä¸€ä¸ªåˆæ³•çš„ <!--
        prevIndex = nestedIndex + 1
      }

      // è¿™é‡Œåº”è¯¥æ˜¯æ²¡åµŒå¥—çš„æƒ…å†µï¼Ÿï¼Ÿï¼Ÿ
      advanceBy(context, match.index + match[0].length - prevIndex + 1)
    }

    return {
      type: NodeTypes.COMMENT,
      content,
      loc: getSelection(context, start)
    }
  }
#+end_src
** parseElement(context, mode)
:PROPERTIES:
:COLUMNS:  %CUSTOM_ID[(Custom Id)]
:CUSTOM_ID: parse-parseelement
:END:

è¿™ä¸ªè§£æå‡½æ•°ï¼Œç”¨æ¥è§£æ =<div>= æ ‡ç­¾ã€‚

*** é˜¶æ®µä¸€([[#test-text-05][test-05]])

[[#test-text-05][some \<span>{{ foo < bar + foo }} text\</span>]]

æ­¤é˜¶æ®µåªå®ç°å¯¹ =<div>...</div>= çš„è§£æï¼Œä¸åŒ…å«å±æ€§ç­‰ç­‰å…¶ä»–å¤æ‚æƒ…å†µï¼Œå› ä¸ºåªéœ€è¦èƒ½
é€šè¿‡ç”¨ä¾‹ 5 å°±è¡Œã€‚

#+begin_src js
  function parseElement(context, ancestors) {
    // assert context.source æ˜¯ä»¥ <[a-z] å¼€å¤´çš„

    const wasInPre = context.inPre
    const wasInVPre = context.inVPre
    // å– ancestors æœ€åä¸€ä¸ªèŠ‚ç‚¹ node
    const parent = last(ancestors)
    const element = parseTag(context, TagType.Start, parent)

    // pre or v-pre
    const isPreBoundary = context.inPre && !wasInVPre
    const isVPreBoundary = context.inVPre && !wasInVPre

    // è‡ªé—­åˆçš„åˆ°è¿™é‡Œå°±å¯ä»¥ç»“æŸäº†
    if (element.isSelfClosing || context.options.isVoidTag?.(element.tag)) {
      return element
    }

    // å­å…ƒç´  childrenï¼Œè¢«æ¼æ‰çš„ä»£ç ï¼Œä¼šè¿›å…¥é€’å½’è°ƒç”¨ parseChildren å»è§£æ
    // <span>...</span> æ ‡ç­¾å†…çš„æ¨¡æ¿
    ancestors.push(element)
    const mode = context.options.getTextMode(element, parent)
    const children = parseChildren(context, mode, ancestors)

    ancestors.pop()
    element.children = children
    // P1.... è§£æä¹‹å children é‡Œé¢åº”è¯¥åŒ…å«ä¸¤ä¸ª node
    // node1: æ’å€¼å†…å®¹ `foo < bar + foo`
    // node2: æ–‡æœ¬èŠ‚ç‚¹ ` text`
    console.log(element)

    // ç»“æŸæ ‡ç­¾ï¼Ÿ <span></span> è¿™ç§ç±»å‹ï¼Ÿ
    // ä¸Šé¢ä¼šè§£ææ ‡ç­¾å†…çš„æ¨¡æ¿ï¼Œè§£æå®Œä¹‹å source æ­£å¸¸åº”è¯¥ä¼šæ˜¯ `</span> ....`
    // è¿›å…¥ if è§£æç»“æŸæ ‡ç­¾
    if (startsWithEndTagOpen(context.source, element.tag)) {
      parseTag(context, TagType.End, parent)
    } else {
      // ä¼šè¿›å…¥åˆ°è¿™é‡Œå‡ºç°æŠ¥é”™
      emitError(context, ErrorCodes.X_MISSING_END_TAG, 0, element.loc.start)
      if (context.source.length === 0 && element.tag.toLowerCase() === 'script') {
        const first = children[0]
        if (first && first.loc.source.startsWith('<!--')) {
          emitError(context, ErrorCodes.EOF_IN_SCRIPT_HTML_COMMENT_LIKE_TEXT)
        }
      }
    }

    element.loc = getSelection(context, element.loc.start)
    console.log(element, 'after')

    if (isPreBoundary) {
      context.inPre = false
    }

    if (isVPreBoundary) {
      context.inVPre = false
    }

    return element
  }
#+end_src

å®ç°åˆ°è¿™é‡Œæ˜¯ä¸ºäº†æƒ³çœ‹ä¸‹ç»è¿‡ [[#parse-parsetag][parseTag]] ä¹‹åçš„ element æ˜¯ä»€ä¹ˆï¼ŸparseTag é‡Œé¢æœ‰ä¸ªæ­£åˆ™
æ˜¯ç”¨æ¥åŒ¹é…å¼€å§‹æˆ–ç»“æŸæ ‡ç­¾çš„ï¼Œå³ï¼š =/^<\/?([a-z][^\t\r\n\f />]*)/i= è¿™ä¸ªæ—¢å¯ä»¥åŒ¹é…
å¼€å§‹æ ‡ç­¾ï¼Œä¹Ÿå¯ä»¥åŒ¹é…ç»“æŸæ ‡ç­¾ï¼Œå¹¶ä¸”è€ƒè™‘äº† =<div >= æœ‰ç©ºæ ¼çš„æƒ…å†µï¼Œå¿½ç•¥å¤§å°å†™ã€‚

æ­£åˆ™åŒ¹é…æµ‹è¯•ç»“æœï¼š

#+begin_example
/^<\/?([a-z][^\t\r\n\f />]*)/i.exec('<span>')
(2)Â ["<span", "span", index: 0, input: "<span>", groups: undefined]
#+end_example

æ‰€ä»¥è¿™é‡Œé¦–å…ˆåŒ¹é…è§£æçš„æ˜¯å¼€å§‹æ ‡ç­¾ =<div>= ã€‚

#+begin_src json
  // some <span>{{ foo < bar + foo }} text</span>
  // parseTag ä¹‹åçš„ element
  {
    "type":1, // èŠ‚ç‚¹ç±»å‹æ˜¯ NodeTypes.ELEMENT
    "ns":0, // å‘½åç©ºé—´å°±æ˜¯ HTML
    "tag":"span",
    "tagType":0, // æ ‡ç­¾ç±»å‹ ElementTypes.ELEMENT
    "props":[ // æ ‡ç­¾å±æ€§ï¼Œè¿™é‡Œæ²¡æœ‰
    ],
    "isSelfClosing":false, // æ˜¯ä¸æ˜¯è‡ªé—­åˆæ ‡ç­¾ï¼Œå¦‚ï¼š<img/>
    "children":[],
    "loc":{
      "start":{
        "column":6, // column ä¸æ¢è¡Œçš„æƒ…å†µä¸‹ä¸º offset + 1ï¼Œä» 1 å¼€å§‹è®¡æ•°
        "line":1, // æ²¡æ¢è¡Œç¬¦
        "offset":5 // <span> çš„ < å¼€å§‹ä½ç½®ç´¢å¼• `some `.length = 5
      },
      "end":{
        "column":12,
        "line":1,
        // è¿™é‡Œå€¼çš„å˜åŒ–åˆ†ä¸¤æ­¥
        // parseTag:start çš„æ—¶å€™
        // 1. è§£æå‡º <span ï¼Œè¿™ä¸ªæ—¶å€™ offset å…¶å®æ˜¯ 10
        // 2. æ£€æµ‹æ˜¯ä¸æ˜¯è‡ªé—­åˆæ ‡ç­¾ï¼Œå†³å®š advancedBy
        // ç§»åŠ¨æŒ‡é’ˆä½ç½®æ•°(è‡ªé—­åˆï¼š2ï¼Œéè‡ªé—­åˆï¼š1)ï¼Œåˆ°è¿™é‡Œ offset = 11
        "offset":11
      },
      "source":"<span>" // ä¸ºä»€ä¹ˆä¸æ˜¯ `<span>` ??? æ¼äº†è‡ªé—­åˆæ ‡ç­¾æ£€æµ‹æŒ‡é’ˆç§»ä½
    }
  }
#+end_src

è§£æä¹‹å context å†…å®¹å˜åŒ–ï¼š

#+begin_src json
  {
    "options":{
      // å¿½ç•¥é€‰é¡¹ï¼Œç›®å‰å¯¹æˆ‘ä»¬æ²¡å•¥ç”¨
    },
    "column":12,
    "line":1,
    "offset":11, // <span> åé¢çš„ > ç´¢å¼•
    "originalSource":"some <span>{{ foo < bar + foo }} text</span>",
    // è§£æä¹‹åçš„æ¨¡æ¿ï¼Œä¸ºä½• > æ²¡è¢«å»æ‰???ï¼Œè§ é—®é¢˜1
    "source":"{{ foo < bar + foo }} text</span>",
    "inPref":false,
    "inVPref":false
  }
#+end_src

åˆ°æ­¤æˆ‘ä»¬å·²ç»è§£æé™¤äº† =<span>= å¼€å§‹æ ‡ç­¾ï¼Œè¿™ä¸ªæ—¶å€™çš„ =node.childrens = []=ï¼Œä¸‹ä¸€æ­¥
è§£ææ ‡ç­¾é‡Œé¢çš„å†…å®¹ã€‚

åœ¨å®ç°å®Œæ•´çš„ parseElement ä¹‹åå‘ç°æ‰§è¡Œä¼šæŠ¥é”™ï¼Œå› ä¸ºè¿™ä¸ªç”¨ä¾‹å¹¶ä¸æ˜¯ =<span></span>=
æ ‡ç­¾å†…æ²¡ä¸œè¥¿ï¼Œæ‰€ä»¥ä¼šè¿›å…¥ else è§¦å‘ =emitError()= ï¼Œé‚£ä¸æ˜¯æ²¡æ³•å¾€ä¸‹èµ°äº†ï¼Ÿï¼Ÿï¼Ÿ

#+begin_src js
  // å­å…ƒç´  childrenï¼Œè¢«æ¼æ‰çš„ä»£ç ï¼Œä¼šè¿›å…¥é€’å½’è°ƒç”¨ parseChildren å»è§£æ
  // <span>...</span> æ ‡ç­¾å†…çš„æ¨¡æ¿
  ancestors.push(element)
  const mode = context.options.getTextMode(element, parent)
  const children = parseChildren(context, mode, ancestors)
  ancestors.pop()
  element.children = children
  // ...........â˜ğŸ».â˜ğŸ».â˜ğŸ».â˜ğŸ».â˜ğŸ»ï¼ŒåŠ å›å»

  if (startsWithEndTagOpen(context.source, element.tag)) {
    parseTag(context, TagType.End, parent)
  } else {
    emitError(context, ErrorCodes.X_MISSING_END_TAG, 0, element.loc.start)
    if (context.source.length === 0 && element.tag.toLowerCase() === 'script') {
      const first = children[0]
      if (first && first.loc.source.startsWith('<!--')) {
        emitError(context, ErrorCodes.EOF_IN_SCRIPT_HTML_COMMENT_LIKE_TEXT)
      }
    }
  }
#+end_src

é‚£æ˜¯å› ä¸ºå‰é¢æ¼äº†ä¸€æ®µä»£ç ã€‚

ä»£ç åŠ ä¸Šä¹‹åæœ€åä»£ç  P1 å‡ºçš„è¾“å‡º ancestors é‡Œé¢ä¼šæœ‰ä¸€ä¸ªå­èŠ‚ç‚¹(element)ï¼š

#+begin_src json
  // ancestors[{...}]ï¼Œancestors ç¬¬ä¸€ä¸ªèŠ‚ç‚¹æ˜¯ <span> è¿™ä¸ªèŠ‚ç‚¹
  // é‡ç‚¹æˆ‘ä»¬è¦çœ‹çš„æ˜¯è¿™ä¸ªèŠ‚ç‚¹çš„ children å› ä¸ºå…¶å†…éƒ¨æœ‰ `{{ foo < bar + foo }} text`
  // æ‰€ä»¥å®ƒ çš„ element åº”è¯¥æœ‰ä¸¤ä¸ªèŠ‚ç‚¹ï¼š`foo < bar + foo` å’Œ ` text`
  {
    // <span> èŠ‚ç‚¹æœ¬èº«çš„å±æ€§ï¼Œæˆ‘ä»¬é‡ç‚¹éœ€è¦å…³æ³¨çš„æ˜¯ children
    "children":[
      { // ç¬¬ä¸€ä¸ª child æ˜¯ {{ ... }} æ£€æµ‹åˆ°æ’å€¼è¿›å…¥ parseInterpolation åˆ†æ”¯
        // å¤„ç†ï¼Œå¾—åˆ°ä¸‹é¢çš„èŠ‚ç‚¹ç»“æ„ï¼Œæ’å€¼è§£æåœ¨ parseInterpolation ä¸€ç« æœ‰åˆ†æè¿‡äº†
        "type":5,
        "content":{
          "type":4,
          "isStatic":false,
          "isConstant":false,
          "content":"foo < bar + foo",
          "loc":{
            "start":{
              "column":15,
              "line":1,
              "offset":14
            },
            "end":{
              "column":30,
              "line":1,
              "offset":29
            },
            "source":"foo < bar + foo"
          }
        },
        "loc":{
          "start":{
            "column":12,
            "line":1,
            "offset":11
          },
          "end":{
            "column":33,
            "line":1,
            "offset":32
          },
          "source":"{{ foo < bar + foo }}"
        }
      },
      {
        "type":2,
        "content":" text",
        "loc":{
          "start":{
            "column":33,
            "line":1,
            "offset":32
          },
          "end":{
            "column":38,
            "line":1,
            "offset":37
          },
          "source":" text"
        }
      }
    ],
    // <span> æœ¬èº«èŠ‚ç‚¹çš„ loc
  }
#+end_src

è¿™é‡Œä¹Ÿæ²¡ä»€ä¹ˆå¥½è§£é‡Šçš„ï¼Œæ’å€¼åœ¨ [[#parse-parseinterpolation][parseInterpolation]] å¤„åˆ†æè¿‡äº†ï¼Œæ–‡æœ¬è§£æåœ¨ [[#parse-parsetext][parseText]]
å¤„åˆ†æäº†ã€‚

** parseInterpolation(context, mode)
:PROPERTIES:
:COLUMNS:  %CUSTOM_ID[(Custom Id)]
:CUSTOM_ID: parse-parseinterpolation
:END:

å‡½æ•°å£°æ˜ï¼š

#+begin_src typescript
  function parseInterpolation(
      context: ParserContext,
      mode: TextModes
  ): InterpolationNode | undefined {}
#+end_src

*context*: å°†è¢«è§£æçš„ä¸Šä¸‹æ–‡ï¼Œæ­¤æ—¶è¿™é‡Œçš„ source åº”è¯¥æ˜¯ä»¥å·®å€¼ (={{=)å¼€å§‹çš„å­—ç¬¦ä¸²ã€‚

*mode*: æ–‡æœ¬æ¨¡å¼ã€‚

#+begin_src js
  function parseInterpolation(context, mode) {
    // æ‰¾å‡ºæ’å€¼æ¨¡æ¿çš„å¼€å§‹å’Œç»“æŸç¬¦å·ï¼Œé»˜è®¤æ˜¯ {{ å’Œ }}
    const [open, close] = context.options.delimiters;
    const closeIndex = context.source.indexOf(close, open.length);
    if (closeIndex === -1) {
      emitError(context, ErrorCodes.X_MISSING_INTERPOLATION_END);
      return undefined;
    }

    const start = getCursor(context);
    advanceBy(context, open.length);

    // ä¸‹é¢æ˜¯ä» {{ ä¹‹åçš„å­—ç¬¦ä¸²å¼€å§‹è§£æ
    const innerStart = getCursor(context),
          innerEnd = getCursor(context),
          // æ’å€¼é‡Œé¢çš„å­—ç¬¦ä¸²é•¿åº¦
          rawContentLength = closeIndex - open.length,
          // æ’å€¼é‡Œé¢çš„å­—ç¬¦ä¸²å†…å®¹
          rawContent = context.source.slice(0, rawContentLength),
          preTrimContent = parseTextData(context, rawContentLength, mode),
          content = preTrimContent.trim(),
          startOffset = preTrimContent.indexOf(content);
    if (startOffset > 0) {
      advancePositionWithMutation(innerStart, rawContent, startOffset);
    }

    // {{ foo + bar }} ->
    // res = (' foo + bar '.length - 'foo + bar'.length - ' '.length)
    // æ’å€¼é‡Œé¢å­—ç¬¦ä¸²çš„é•¿åº¦ - å»æ‰ç©ºæ ¼åçš„é•¿åº¦ - èµ·å§‹ç©ºæ ¼çš„é•¿åº¦ï¼Œå¾—åˆ°çš„
    // å°±æ˜¯ç»“æŸä½ç½®çš„ offset
    const endOffset =
          rawContentLength - (preTrimContent.length - content.length - startOffset);
    advancePositionWithMutation(innerEnd, rawContent, endOffset);
    // å®šä½åˆ° }} ä½ç½®
    advanceBy(context, close.length);

    console.log(innerEnd, innerStart, "1");
    return {
      type: NodeTypes.INTERPOLATION,
      content: {
        type: NodeTypes.SIMPLE_EXPRESSION,
        isStatic: false,
        isConstant: false,
        content,
        loc: getSelection(context, innerStart, innerEnd),
      },
      loc: getSelection(context, start),
    };
  }
#+end_src

[[/img/1595570127.png]]

å›¾ä¸­æˆ‘ä»¬çœ‹åˆ°åœ¨ç»è¿‡è§£æä¹‹å innerStart å’Œ innerEnd éƒ½æ•°æ®éƒ½æ­£ç¡®å®šä½åˆ°äº†ç›¸åº”ä½ç½®ï¼Œ
innerStart æ˜¯è§£æåæ’å€¼å­—ç¬¦ä¸²çš„å¼€å§‹ä½ç½®(ç¬¬ä¸€ä¸ª ={= offset = 8(@@html:<font
color='red'>@@'some {{ 'çš„é•¿åº¦</font>))ï¼ŒinnerEnd æ˜¯è§£æåæ’å€¼å­—ç¬¦ä¸²çš„ç»“æŸä½ç½®
(æœ€åä¸€ä¸ª =}= offset = 17(<font color="purple">'some {{ foo + bar 'çš„é•¿
åº¦))@@html:</font>@@ã€‚

[[/img/parse-ts-parseinterpolation.png]]

è§£æä¹‹åå¾—åˆ°çš„ =ast.children= å°†ä¼šæœ‰ä¸‰ä¸ªèŠ‚ç‚¹ï¼š

#+begin_src json
  (3) [{â€¦}, {â€¦}, {â€¦}]
  0: {type: 2, content: "some ", loc: {â€¦}} // å·¦ä¾§æ–‡æœ¬
  1: {type: 5, content: {â€¦}, loc: {â€¦}} // æ’å€¼éƒ¨åˆ†
  2: {type: 2, content: " text", loc: {â€¦}} // å³ä¾§æ–‡æœ¬
  length: 3
  __proto__: Array(0)
#+end_src

è§£æå›é¡¾(åˆ†åˆ«è§£æå‡ºäº†ä¸‰ä¸ªèŠ‚ç‚¹å¯¹è±¡)ï¼š

1. =0: {type: 2, content: "some ", loc: {â€¦}}=
   :PROPERTIES:
   :COLUMNS: %CUSTOM_ID[(Custom Id)]
   :CUSTOM_ID: x-1
   :END:
   è¯¦ç»†ç»“æ„ï¼š

   #+begin_src json
     0:
     content: "some " // è§£æå‡ºçš„æ–‡æœ¬å†…å®¹
     loc: // ä½ç½®ä¿¡æ¯
     end: {column: 6, line: 1, offset: 5} // è¯¥èŠ‚ç‚¹åœ¨æ¨¡æ¿ä¸­çš„ä½ç½®ä¿¡æ¯
     source: "some " // æ–‡æœ¬æºå†…å®¹
     start: {column: 1, line: 1, offset: 0} // è¯¥èŠ‚ç‚¹åœ¨æ¨¡æ¿ä¸­çš„ç»“æŸä¿¡æ¯
     __proto__: Object
     type: 2 // èŠ‚ç‚¹ç±»å‹
     __proto__: Object
   #+end_src

   é‚£ä¹ˆæ˜¯å¦‚ä½•å¾—åˆ°ä¸Šé¢çš„ç»“æœçš„å‘¢ï¼Ÿï¼Ÿï¼Ÿé‚£å¾—ä» [[#parse-parsechildren][parseChildren]] è¯´èµ·äº†ï¼Œæ¨¡æ¿ï¼š

   @@html:<kbd>@@
   --->> "some {{ foo + bar }} text"
   @@html:</kbd>@@

   =(!context.inVPre && s.startsWith(context.options.delimiters[0]))=
   @@html:<font color='red'>@@æ£€æµ‹å¤±è´¥@@html:</font>@@

   ~mode === TextModes.DATA && s[0] === "<"~ @@html:<font color='red'>@@æ£€æµ‹å¤±è´¥@@html:</font>@@

   å³ä¸€å¼€å§‹å¹¶ä¸ä¼šè¿›å…¥æ’å€¼å’Œæ ‡ç­¾è§£æä»£ç ï¼Œè€Œæ˜¯ç›´æ¥è¿›å…¥ [[#parse-parsetext][parseText(context, mode)]]
   ä¸­è§£ææ–‡æœ¬ï¼Œè§£ææ—¶å€™ç›´åˆ°é‡åˆ° ={{= ä¹‹å‰éƒ½ä¸€ç›´ä¼šå½“åšæ–‡æœ¬è§£æï¼Œè€Œä¹‹å‰çš„æ–‡æœ¬ä¸­åˆ
   ä¸åŒ…å« =decodeMap= ä¸­çš„å­—ç¬¦ï¼Œå› æ­¤çŸ¥é“é‡åˆ° ={= ä¹‹å‰ä¼šä¸€ç›´æ‰§è¡Œ while é‡Œé¢çš„ï¼š

   #+begin_src js
     if (!node) {
       node = parseText(context, mode);
     }

     if (Array.isArray(node)) {
       for (let i = 0; i < node.length; i++) {
         pushNode(nodes, node[i]);
       }
     } else {
       pushNode(nodes, node);
     }
   #+end_src

   è¿™æ®µä»£ç ï¼Œè€Œç”±äº "some " éƒ½æ˜¯æ™®é€šå­—ç¬¦ï¼Œæ¯ä¸ªå­—ç¬¦ä¸²ä¼šå¯¹åº”ä¸€ä¸ª node ï¼Œç„¶ååˆéƒ½æ˜¯
   æ™®é€šæ–‡æœ¬èŠ‚ç‚¹ï¼Œä¼šç»è¿‡ [[#parse-pushnode][pushNode(nodes, node[i])]] å¤„ç†æ‰ï¼Œè¿›è¡Œåˆå¹¶æœ€åæˆä¸ºä¸Šé¢çš„
   ä¸€ä¸ªå®Œæ•´çš„ "some " å¯¹åº”[[#x-1][æ–‡æœ¬èŠ‚ç‚¹ç»“æ„]]ã€‚

2. ~1: {type: 5, content: {â€¦}, loc: {â€¦}}~
   :PROPERTIES:
   :COLUMNS: %CUSTOM_ID[(Custom Id)]
   :CUSTOM_ID: x-2
   :END:
   èŠ‚ç‚¹ç»“æ„ï¼š

   #+begin_example
   1:
     content: // è¿™é‡Œçš„æ•°æ®æ˜¯ç»è¿‡æ’å€¼è§£æä¹‹åçš„æ¨¡æ¿å¯¹è±¡
       content: "foo + bar" // trim ä¹‹åçš„æ’å€¼å­—ç¬¦ä¸²ï¼Œæ²¡æœ‰ }} ???
       isConstant: false // éå¸¸é‡ç±»å‹
       isStatic: false // éé™æ€èŠ‚ç‚¹
       loc:  // è§£æä¹‹åçš„è¯¥èŠ‚ç‚¹åœ¨æ•´ä¸ªæ¨¡æ¿ä¸­çš„ä½ç½®ä¿¡æ¯
        // 17 -> r æ‰€åœ¨çš„ä½ç½®
         end: {column: 18, line: 1, offset: 17}
         source: "foo + bar"
        // 8 -> f æ‰€åœ¨çš„ä½ç½®ï¼Œå³ start -> end => 'f <-> r'
         start: {column: 9, line: 1, offset: 8}
       __proto__: Object
       type: 4 // æ’å€¼è¡¨è¾¾å¼ç±»å‹
       __proto__: Object
    loc: // è¿™é‡Œæ˜¯æ²¡ç»è¿‡å»å°¾éƒ¨ç©ºæ ¼çš„ä½ç½®ä¿¡æ¯
      // 20 -> 'some {{ foo + bar ' æœ€åä¸€ä¸ªç©ºæ ¼ä½ç½®
       end: {column: 21, line: 1, offset: 20}
       source: "{{ foo + bar }}"
      // 5 -> 'some ' ç¬¬ä¸€ä¸ª { ä½ç½®
       start: {column: 6, line: 1, offset: 5}
       __proto__: Object
     type: 5 // æ’å€¼ç±»å‹
     __proto__: Object
   #+end_example

   å¦‚ä¸Šæ‰€æ³¨é‡Šçš„ï¼Œç¬¬ä¸€çº§çš„ loc æ˜¯é€šè¿‡è§£æ *"{{ foo + bar}}"* åœ¨æ•´ä¸ªæ¨¡æ¿ä¸­çš„ä½ç½®
   ä¿¡æ¯ï¼Œcontent é‡Œé¢åŒ…å«çš„æ˜¯æ’å€¼å†…éƒ¨çš„ä¿¡æ¯ï¼Œå³çœŸæ­£çš„è¡¨è¾¾å¼ç»“æ„ä¿¡æ¯ã€‚

3. ~{type: 2, content: " text", loc: {â€¦}}~
   :PROPERTIES:
   :COLUMNS: %CUSTOM_ID[(Custom Id)]
   :CUSTOM_ID: x-3
   :END:

   å’Œç¬¬ä¸€æ­¥ä¸­ä¸€æ ·ï¼Œåªä¼šç»è¿‡ =parseText(context, mode)= è§£æå‡ºçº¯æ–‡æœ¬å†…å®¹ï¼š" text"ï¼Œæœ€åçš„ç»“æ„ï¼š
   #+begin_src json
     {
       type: 2,
       content: " text",
       loc: {
         // ä» text å‰é¢çš„ç©ºæ ¼å¼€å§‹è®°å½•ï¼Œ"some {{ foo + bar }}" é•¿åº¦ä¸º 20
         start: { column: 21, line: 1, offset: 20 },
         source: " text",
         end: { column: 26, line: 1, offset: 25}
       }
     }
   #+end_src

ä¸‰æ­¥åˆ†æå®Œä¹‹åï¼Œåˆ°ç°åœ¨æˆ‘ä»¬åº”è¯¥å…·å¤‡è„±ç¦»ä»£ç å°±å¯ä»¥ç›´æ¥æ ¹æ®æ¨¡æ¿å¾—åˆ°è§£æåå¯¹åº”çš„
children ç»“æ„ã€‚åˆ†æçš„é‡ç‚¹æ˜¯è¦å¾—åˆ°ä¸€ä¸ª ={ type, content, loc: { start, source, end }}= ç»“æ„çš„å¯¹è±¡ã€‚

#+begin_src json
  // start/end:
  {
    column/*è¯¥èŠ‚ç‚¹èµ·å§‹ç»“æŸçš„åˆ—ï¼Œä» 1 å¼€å§‹è®¡æ•°çš„å€¼*/,
    line/*è¯¥èŠ‚ç‚¹æ¨¡æ¿æ‰€åœ¨çš„è¡Œï¼Œä» 1 å¼€å§‹è®¡æ•°çš„å€¼*/,
    offset/*è¯¥èŠ‚ç‚¹èµ·å§‹ç»“æŸçš„ç´¢å¼•ï¼Œä» 0 å¼€å§‹è®¡æ•°çš„å€¼*/
  }
#+end_src

#+begin_export html
<font color="blue">PS: å¯¹äº foo å’Œ bar å˜é‡æ•°æ®è§£ææ‰§è¡Œç»“æœè¿™å—æš‚æ—¶ä¸è®¨è®ºï¼Œä¹Ÿä¸çŸ¥é“å¦‚ä½•åšåˆ°çš„ï¼Œç°é˜¶æ®µåªå…³å¿ƒæ¨¡æ¿çš„è§£æã€‚</font>
#+end_export

** parseTag(context, type, parent)
:PROPERTIES:
:COLUMNS:  %CUSTOM_ID[(Custom Id)]
:CUSTOM_ID: parse-parsetag
:END:

*** é˜¶æ®µä¸€([[#test-text-02][simple text<\/div>]])
:PROPERTIES:
:COLUMNS:  %CUSTOM_ID[(Custom Id)]
:CUSTOM_ID: parse-parsetag-01
:END:

1. ä¸ºä»€ä¹ˆåªåŒ¹é… =</div= è€Œå¿½ç•¥æ‰æœ€åä¸€ä¸ª =>=???
   å‚æ•°:
   #+begin_src typescript
     function parseTag(
         context: ParserContext, // è¦ç»§ç»­è§£æçš„æ¨¡æ¿å¯¹è±¡ simple text</div> é‡Œé¢çš„ </div>
         type: TagType, // Start(<div>), End(</div>)å¼€å§‹ç»“æŸæ ‡ç­¾
         parent: ElementNode | undefined // è¯¥æ ‡ç­¾çš„çˆ¶çº§
     ): ElementNode
   #+end_src

   å…·ä½“å®ç°ï¼š

   #+begin_src js
     function parseTag(context, type, parent) {
       // è·å–å½“å‰è§£æçš„èµ·å§‹ä½ç½®ï¼Œæ­¤æ—¶å€¼åº”è¯¥æ˜¯ simple text çš„é•¿åº¦
       const start = getCursor(context);
       // åŒ¹é… </div è¿‡æ»¤æ‰ç©ºæ ¼å­—ç¬¦ï¼Œä½†æ˜¯ä¸ºä»€ä¹ˆè¦æŠŠ > ç»™å¿½ç•¥æ‰???
       const match = /^<\/?([a-z][^\t\r\n\f />]*)/i.exec(context.source);
       const tag = match[1];
       const ns = context.options.getNamespace(tag, parent);
       // æ”¹å˜ä½ç§»ï¼Œå°† offset å®šä½åˆ° </div> çš„æœ€æœ‰ä¸€ä¸ª > ä¸Š
       advanceBy(context, match[0].length);
       // è¿‡æ»¤æ‰ç©ºæ ¼
       advanceSpaces(context);

       const cursor = getCursor(context);
       const currSource = context.source;
     }
   #+end_src

*** é˜¶æ®µäºŒ([[#test-text-05][test-text-05]])
:PROPERTIES:
:COLUMNS:  %CUSTOM_ID[(Custom Id)]
:CUSTOM_ID: parse-parsetag-02
:END:

æ»¡è¶³ç”¨ä¾‹ 5(=some <span>{{ foo < bar + foo }} text</span>=) çš„ä»£ç å®ç°ï¼Œè¿™é‡Œåªéœ€
è¦èƒ½è§£æ =<span> ... </span>= æ ‡ç­¾å°±å¯ä»¥ï¼Œæ²¡æœ‰ =pre=, =v-pre=, =<span/>è‡ªé—­åˆæ ‡
ç­¾= ï¼Œå› æ­¤ä¸‹é¢çœç•¥è¿™å‡ éƒ¨åˆ†æ£€æµ‹ä»£ç ã€‚

#+begin_src js
  function parseTag(context, type, parent) {
    // è·å–å½“å‰è§£æçš„èµ·å§‹ä½ç½®ï¼Œæ­¤æ—¶å€¼åº”è¯¥æ˜¯ some text çš„é•¿åº¦
    const start = getCursor(context)
    // åŒ¹é… </div è¿‡æ»¤æ‰ç©ºæ ¼å­—ç¬¦ï¼Œä½†æ˜¯ä¸ºä»€ä¹ˆè¦æŠŠ > ç»™å¿½ç•¥æ‰???
    const match = /^<\/?([a-z][^\t\r\n\f />]*)/i.exec(context.source)
    const tag = match[1]
    const ns = context.options.getNamespace(tag, parent)
    // log1: æ”¹å˜ä½ç§»ï¼Œå°† offset å®šä½åˆ° </div> çš„æœ€æœ‰ä¸€ä¸ª > ä¸Š
    // åœ¨è¿™é‡Œ context.offset = 10, context.line = 1
    advanceBy(context, match[0].length)
    // è¿‡æ»¤æ‰ç©ºæ ¼
    advanceSpaces(context)
    // log2: ç»è¿‡ advanceä¹‹å context.offset = 15, context.line = 1
    // æ­£å¥½è¿‡æ»¤ </div 5ä¸ªå­—ç¬¦
    const cursor = getCursor(context)
    const currSource = context.source

    // TODO-1 è§£ææ ‡ç­¾å…ƒç´ çš„å±æ€§

    // TODO-2 in pre ...

    // TODO-3 v-pre æŒ‡ä»¤

    // TODO-3 <div/> è‡ªé—­æ ‡ç­¾
    // è¿™é‡Œè¦å®ç°ï¼Œä¸ç„¶æœ€åè§£æå®Œæˆä¹‹å source ä¼šæ˜¯ï¼š>...</span>
    // éœ€è¦æ£€æµ‹ä¸‹æ˜¯ä¸æ˜¯è‡ªé—­åˆæ ‡ç­¾æ¥ç§»åŠ¨æŒ‡é’ˆä½ç½®
    let isSelfClosing = false
    if (context.source.length === 0) {
      emitError(context, ErrorCodes.EOF_IN_TAG)
    } else {
      // some <div> ... </div> åˆ°è¿™é‡Œçš„ source = > ... </div>
      // æ‰€ä»¥å¯ä»¥æ£€æµ‹æ˜¯ä¸æ˜¯ä»¥ /> å¼€å¤´çš„
      isSelfClosing = context.source.startsWith('/>')
      if (type === TagType.End && isSelfClosing) {
        emitError(context, ErrorCodes.END_TAG_WITH_TRAILING_SOLIDUS)
      }
      // å¦‚æœæ˜¯è‡ªé—­åˆæŒ‡é’ˆç§»åŠ¨ä¸¤ä½(/>)ï¼Œå¦åˆ™åªç§»åŠ¨ä¸€ä½(>)
      // åˆ°è¿™é‡Œ source = ... </div>
      advanceBy(context, isSelfClosing ? 2 : 1)
    }

    let tagType = ElementTypes.ELEMENT
    const options = context.options
    // ä¸æ˜¯ v-preï¼Œä¸”ä¸æ˜¯è‡ªå®šä¹‰ç»„ä»¶ï¼Œè¿™ä¸ª if ç›®çš„æ˜¯ä¸ºäº†æ£€æµ‹å¹¶æ”¹å˜
    // tagType æ ‡ç­¾ç±»å‹
    if (!context.inVPre && !options.isCustomElement(tag)) {
      // TODO-4 æ£€æµ‹ tagType
    }

    return {
      type: NodeTypes.ELEMENT,
      ns,
      tag,
      tagType,
      props,
      isSelfClosing: false, // TODO
      children: [],
      loc: getSelection(context, start),
      codegenNode: undefined
    }
  }
#+end_src

è¦èƒ½é€šè¿‡[[#test-text-05][ç”¨ä¾‹5]]å¿…é¡»æ­é… [[#parse-parseelement][parseElement(context, ancestors)]] æ‰è¡Œï¼Œå¹¶ä¸”é‡ç‚¹åœ¨
*parseElement* ä¸­ï¼Œå› ä¸ºæœ‰äº†å¼€å§‹æ ‡ç­¾æ‰ä¼šæœ‰ç»“æŸæ ‡ç­¾çš„è§£æï¼Œä¸ç„¶ä¼šè§¦å‘ç»“æŸæ ‡ç­¾è§£æåˆ†
æ”¯é‡Œé¢çš„ error:

#+begin_src js
  else if (/[a-z]/i.test(s[2])) {
    // è¿™é‡Œéƒ½å‡ºé”™äº†ï¼Œä¸ºå•¥åé¢è¿˜æœ‰ä¸ª parseTag ???
    emitError(context, ErrorCodes.X_INVALID_END_TAG)
    parseTag(context, TagType.End, parent)
    continue
  }
#+end_src

å› æ­¤å¦‚æœè¿™é‡Œä¸ä¼šè§¦å‘ X_INVALID_END_TAG é‚£å¿…å®šæ˜¯ parseElement é‡Œé¢åšäº†ä»€ä¹ˆå¤„ç†ï¼Œ
è¿™ä¸ªå®ç°äº† parseElement æ‰å¾—ä»¥çŸ¥æ™“(ç›®å‰åªæ˜¯çŒœæµ‹~~~)ï¼Œ[[#parse-parseelement][ä¼ é€é—¨ğŸšª>>>]]

*** é˜¶æ®µä¸‰([[#test-element-03][test-element-03]])
:PROPERTIES:
:COLUMNS:  %CUSTOM_ID[(Custom Id)]
:CUSTOM_ID: parse-parsetag-03
:END:

æ”¯æŒè‡ªé—­æ ‡ç­¾è§£æï¼Œå®ç°äº†é˜¶æ®µäºŒä¹‹åï¼Œè¿™é‡Œå…¶å®å¾ˆç®€å•ï¼Œåœ¨ä¸Šä¸€é˜¶æ®µä¸­çš„å®ç°åœ¨
parseTag ä¸­è¿”å›çš„æ—¶å€™ =isSelfClosing= å†™æ­»æˆäº† =false= ï¼Œè¦æ”¯æŒè¿™ä¸ªç”¨ä¾‹ï¼Œåªè¦å°†
å®ƒçš„å€¼èµ‹å€¼ä¸ºå®é™…çš„ =isSelfClosing= å°±å¯ä»¥äº†ã€‚

#+begin_src js
  parseTag() {
    // ...
    let isSelfClosing = false
    if (context.source.length === 0) {
      emitError(context, ErrorCodes.EOF_IN_TAG)
    } else {
      // some <div> ... </div> åˆ°è¿™é‡Œçš„ source = > ... </div>
      // æ‰€ä»¥å¯ä»¥æ£€æµ‹æ˜¯ä¸æ˜¯ä»¥ /> å¼€å¤´çš„
      isSelfClosing = context.source.startsWith('/>')
      if (type === TagType.End && isSelfClosing) {
        emitError(context, ErrorCodes.END_TAG_WITH_TRAILING_SOLIDUS)
      }
      // å¦‚æœæ˜¯è‡ªé—­åˆæŒ‡é’ˆç§»åŠ¨ä¸¤ä½(/>)ï¼Œå¦åˆ™åªç§»åŠ¨ä¸€ä½(>)
      // åˆ°è¿™é‡Œ source = ... </div>
      advanceBy(context, isSelfClosing ? 2 : 1)
    }
    // ...
  }
#+end_src

*** é˜¶æ®µå››(æ”¯æŒ template + v-if)
:PROPERTIES:
:COLUMNS:  %CUSTOM_ID[(Custom Id)]
:CUSTOM_ID: parse-parsetag-04
:END:

#+begin_src js
  function parseTag(context, type, parent) {
    // è·å–å½“å‰è§£æçš„èµ·å§‹ä½ç½®ï¼Œæ­¤æ—¶å€¼åº”è¯¥æ˜¯ some text çš„é•¿åº¦
    const start = getCursor(context)
    // åŒ¹é… <div æˆ– </div è¿‡æ»¤æ‰ç©ºæ ¼å­—ç¬¦ï¼Œä½†æ˜¯ä¸ºä»€ä¹ˆè¦æŠŠ > ç»™å¿½ç•¥æ‰???
    // å…¶å®ä¸æ˜¯å¿½ç•¥æ‰ > è€Œæ˜¯å› ä¸ºå¦‚æœæ˜¯ <div å¼€å¤´ï¼Œé‚£ä¹ˆåé¢æœ‰å¯èƒ½æ˜¯ < æˆ–
    // /> åé¢éœ€è¦å¤„ç†é—­åˆå’Œéé—­åˆé—®é¢˜
    const match = /^<\/?([a-z][^\t\r\n\f />]*)/i.exec(context.source)
    const tag = match[1]
    const ns = context.options.getNamespace(tag, parent)
    // log1: æ”¹å˜ä½ç§»ï¼Œå°† offset å®šä½åˆ° </div> çš„æœ€æœ‰ä¸€ä¸ª > ä¸Š
    // åœ¨è¿™é‡Œ context.offset = 10, context.line = 1
    advanceBy(context, match[0].length)
    // è¿‡æ»¤æ‰ç©ºæ ¼
    advanceSpaces(context)
    // log2: ç»è¿‡ advance ä¹‹å context.offset = 15, context.line = 1
    // æ­£å¥½è¿‡æ»¤ </div 5 ä¸ªå­—ç¬¦
    const cursor = getCursor(context)
    const currSource = context.source

    // è§£ææ ‡ç­¾å…ƒç´ çš„å±æ€§
    let props = parseAttributes(context, type)

    // TODO-2 in pre ...

    // TODO-3 v-pre æŒ‡ä»¤

    // ....

    let tagType = ElementTypes.ELEMENT
    const options = context.options
    // ä¸æ˜¯ v-preï¼Œä¸”ä¸æ˜¯è‡ªå®šä¹‰ç»„ä»¶ï¼Œè¿™ä¸ª if ç›®çš„æ˜¯ä¸ºäº†æ£€æµ‹å¹¶æ”¹å˜
    // tagType æ ‡ç­¾ç±»å‹
    // TODO-4 æ£€æµ‹ tagType
    if (!context.inVPre && !options.isCustomElement(tag)) {
      // æ˜¯å¦æœ‰ is æŒ‡ä»¤ï¼Ÿ
      const hasVIs = props.some(
        (p) => p.type === NodeTypes.DIRECTIVE && p.name === 'is'
      )

      if (options.isNativeTag && !hasVIs) {
        // æ²¡æœ‰ is æŒ‡ä»¤ï¼Œä¸”ä¸æ˜¯åŸç”Ÿæ ‡ç­¾ï¼Œé‚£å°±æ˜¯è‡ªå®šä¹‰çš„ç»„ä»¶äº†
        if (!options.isNativeTag(tag)) tagType = ElementTypes.COMPONENT
      } else if (
        hasVIs ||
          isCoreComponent(tag) ||
          options.isBuiltInComponent?.(tag) ||
          /^[A-Z]/.test(tag) ||
          tag === 'component'
      ) {
        // æœ‰ is æŒ‡ä»¤ || vue æ ¸å¿ƒç»„ä»¶(keep-alive...) || å†…ç½®ç»„ä»¶
        // || æ ‡ç­¾åå¤§å†™å¼€å¤´
        tagType === ElementTypes.COMPONENT
      }

      if (tag === 'slot') {
        tagType === ElementTypes.SLOT
      } else if (
        tag === 'template' &&
          props.some(
            (p) =>
            p.type === NodeTypes.DIRECTIVE && isSpecialTemplateDirective(p.name)
          )
      ) {
        // æ˜¯æ¨¡æ¿çš„å‰ææ˜¯æœ‰æŒ‡ä»¤ï¼Œå¹¶ä¸”æ˜¯ç‰¹æ®Šçš„æ¨¡æ¿æŒ‡ä»¤
        tagType = ElementTypes.TEMPLATE
      }
    }

    const val = {
      type: NodeTypes.ELEMENT,
      ns,
      tag,
      tagType,
      props: [], // TODO
      isSelfClosing,
      children: [],
      loc: getSelection(context, start),
      codegenNode: undefined
    }
    return val
  }
#+end_src

è¿™é‡Œçš„å®ç°æ¶‰åŠåˆ°å‡ ä¸ªæ–°çš„å‡½æ•°ï¼š

1. =options.isCustomElement(tag)= é»˜è®¤åœ¨ options é‡Œé¢æ˜¯ =NO=

2. =options.isNativeTag(tag)= ä½œä¸ºå¯é€‰ =OptionalOptions= é€‰é¡¹ç±»å‹ï¼Œå¹¶æ²¡é»˜è®¤å€¼

3. =isCoreComponent(tag)= vue å†…éƒ¨ä½œä¸ºæ ¸å¿ƒç»„ä»¶çš„æ ‡ç­¾

   #+begin_src json
     { // ä¸»è¦å°±è¿™å››ä¸ª
       Teleport: TELEPORT,
       Suspense: SUSPENSE,
       KeepAlive: KEEP_ALIVE,
       BaseTransition: BASE_TRANSITION
     }
   #+end_src

4. =options.isBuiltInComponent?.(tag)=  å’Œ =isNativeTag= ä¸€æ ·ä½œä¸ºå¯é€‰é€‰é¡¹ï¼Œæ— é»˜è®¤å€¼

5. =isSpecialTemplateDirective(p.name)= ç‰¹æ®Šçš„æ¨¡æ¿æŒ‡ä»¤

   #+begin_src typescript
     const isSpecialTemplateDirective = /*#__PURE__*/ makeMap(
         `if,else,else-if,for,slot`
     )
   #+end_src

   ä»ä¸Šé¢çš„ä»£ç å¯ä»¥çœ‹å‡ºï¼Œå¦‚æœè¦è¢«å®šä¹‰ä¸ºæ˜¯ =<template>= ç±»å‹å¿…é¡»åŒ…å«
   =if,else,else-if,for,slot= è¿™å…¶ä¸­çš„ä»»ä¸€ä¸ªæŒ‡ä»¤å±æ€§ï¼Œåˆ¤æ–­æ¡ä»¶ï¼š

   #+begin_src js
     if (
       tag === 'template' &&
         props.some(
           (p) =>
           // isSpecialTemplateDirective æ˜¯ä½¿ç”¨ makeMap åˆ›å»ºçš„å‡½æ•°
           // å³ key => true/false çš„ä¸€äº›å‡½æ•°
           p.type === NodeTypes.DIRECTIVE && isSpecialTemplateDirective(p.name)
         )
     ) {
       // æ˜¯æ¨¡æ¿çš„å‰ææ˜¯æœ‰æŒ‡ä»¤ï¼Œå¹¶ä¸”æ˜¯ç‰¹æ®Šçš„æ¨¡æ¿æŒ‡ä»¤(if, else, else-if, slot, for)
       tagType = ElementTypes.TEMPLATE
     }
   #+end_src

** parseText(context, mode)
:PROPERTIES:
:COLUMNS: %CUSTOM_ID[(Custom Id)]
:CUSTOM_ID: parse-parsetext
:END: 

è§£ææ–‡æœ¬èŠ‚ç‚¹ï¼Œç›´åˆ°é‡åˆ°ç»“æŸæ ‡è®°(=<=, ={{=, =]]>=)ã€‚

#+begin_src typescript
  function parseText(context: ParserContext, mode: TextModes): TextNode {
      __TEST__ && assert(context.source.length > 0)

      const endTokens = ['<', context.options.delimiters[0]]
      if (mode === TextModes.CDATA) {
          endTokens.push(']]>')
      }

      let endIndex = context.source.length
      for (let i = 0; i < endTokens.length; i++) {
          const index = context.source.indexOf(endTokens[i], 1)
          if (index !== -1 && endIndex > index) {
              endIndex = index
          }
      }

      __TEST__ && assert(endIndex > 0)

      const start = getCursor(context)
      // æ–‡æœ¬å†…å®¹å¯èƒ½åŒ…å« &gt; &lt; &amp; &apos; &quot; ç­‰htmlç¬¦å·ï¼Œéœ€è¦
      // å°†ä»–ä»¬æ›¿æ¢æˆå¯¹åº” >    <    &     '      "
      const content = parseTextData(context, endIndex, mode)

      return {
          type: NodeTypes.TEXT,
          content,
          loc: getSelection(context, start)
      }
  }
#+end_src

å¯¼å›¾ï¼š

[[/img/parse-ts-parsetext.png]]

** parseTextData(context, length, mode)
:PROPERTIES:
:COLUMNS: %CUSTOM_ID[(Custom Id)]
:CUSTOM_ID: parse-parsetextdata
:END: 

æ–‡æœ¬èŠ‚ç‚¹å¯èƒ½åŒ…å«æ•°æ®ï¼Œé€šè¿‡ *context.options.decodeEntities(???)* æ¥è§£æã€‚

ä¸€äº›å­—ç¬¦çš„ html ä¹¦å†™æ ¼å¼ï¼Œæœ‰ =/&(gt|lt|amp|apos|quot);/= ï¼Œæœ€ç»ˆä¼šè¢«å¯¹åº”çš„å­—ç¬¦æ›¿æ¢æ‰ã€‚

=decodeEntities: (rawText: string): string => rawText.replace(decodeRE, (_, p1) => decodeMap[p1])=

å­—ç¬¦é›†ï¼š

#+begin_src typescript
  const decodeMap: Record<string, string> = {
      gt: '>',
      lt: '<',
      amp: '&',
      apos: "'",
      quot: '"'
  }
#+end_src

ä»£ç ï¼š

#+begin_src typescript
  /**
   ,* Get text data with a given length from the current location.
   ,* This translates HTML entities in the text data.
   ,*/
  function parseTextData(
      context: ParserContext,
      length: number,
      mode: TextModes
  ): string {
      const rawText = context.source.slice(0, length)
      advanceBy(context, length)
      if (
          mode === TextModes.RAWTEXT ||
              mode === TextModes.CDATA ||
              rawText.indexOf('&') === -1
      ) {
          return rawText // å¦‚æœä¸åŒ…å« &gt; &lt; ç­‰htmlæ ‡è®°
      } else {
          // DATA or RCDATA containing "&"". Entity decoding required.
          // å¦‚æœå­—ç¬¦ä¸²ä¸­åŒ…å«è¿™äº›å­—ç¬¦ï¼Œå¾—å»å°†ä»–ä»¬æ›¿æ¢æˆå¯¹åº”çš„æ˜æ–‡å­—ç¬¦ã€‚
          return context.options.decodeEntities(
              rawText,
              mode === TextModes.ATTRIBUTE_VALUE
          )
      }
  }
#+end_src

å¯¼å›¾ï¼š
[[/img/parse-ts-parsetextdata.png]]

* é‡è¦ç±»å‹å£°æ˜

è¯¥æ¨¡å—æ‰€æœ‰ç±»å‹å£°æ˜ç»Ÿä¸€å½’ç±»åˆ°æ­¤ï¼Œé¡ºåºæŒ‰ç…§ç”¨ä¾‹è§£æé‡åˆ°çš„é¡ºåºä¸ºä¸»ã€‚

** ParserOptions
:PROPERTIES:
:COLUMNS:  %CUSTOM_ID[(Custom Id)]
:CUSTOM_ID: td-parser-options
:END:

å®šä¹‰ä½ç½®ï¼š
#+begin_export html
<font color="purple"> src/options.ts</font>
#+end_export

æ¥å£å†…å®¹ï¼š
#+begin_src typescript
  export interface ParserOptions {
      /**
       ,* e.g. platform native elements, e.g. <div> for browsers
       ,*/
      isNativeTag?: (tag: string) => boolean
      /**
       ,* e.g. native elements that can self-close, e.g. <img>, <br>, <hr>
       ,*/
      isVoidTag?: (tag: string) => boolean
      /**
       ,* e.g. elements that should preserve whitespace inside, e.g. <pre>
       ,*/
      isPreTag?: (tag: string) => boolean
      /**
       ,* Platform-specific built-in components e.g. <Transition>
       ,*/
      isBuiltInComponent?: (tag: string) => symbol | void
      /**
       ,* Separate option for end users to extend the native elements list
       ,*/
      isCustomElement?: (tag: string) => boolean
      /**
       ,* Get tag namespace
       ,*/
      getNamespace?: (tag: string, parent: ElementNode | undefined) => Namespace
      /**
       ,* Get text parsing mode for this element
       ,*/
      getTextMode?: (
          node: ElementNode,
          parent: ElementNode | undefined
      ) => TextModes
      /**
       ,* @default ['{{', '}}']
       ,*/
      delimiters?: [string, string]
      /**
       ,* Only needed for DOM compilers
       ,*/
      decodeEntities?: (rawText: string, asAttr: boolean) => string
      onError?: (error: CompilerError) => void
  }
#+end_src

å­—æ®µè¯´æ˜ï¼š

1. ~isNativeTag?: (tag: string) => boolean~ ä¸€ä¸ªå‡½æ•°ï¼Œåˆ¤æ–­æ ‡ç­¾æ˜¯å¦æ˜¯åŸç”Ÿæ ‡ç­¾(å¦‚ï¼šli, div)
2. ~isVoidTag?: (tag: string) => boolean~,è‡ªå…³é—­æ ‡ç­¾ï¼Œå¦‚ï¼šimg, br, hr
3. ~isPreTag?: (tag: string) => boolean~ ï¼Œä»£ç æ ‡ç­¾ï¼Œéœ€è¦ç©ºæ ¼ç¼©è¿›çš„ï¼Œå¦‚ï¼špre
4. ~isBuiltInComponent?: (tag: string) => symbol | void~ ï¼Œå¹³å°ç›¸å…³çš„å†…ç½®ç»„ä»¶ï¼Œå¦‚ï¼šTransition
5. ~isCoustomElement?: (tag: string) => boolean~ ï¼Œç”¨æˆ·è‡ªå®šçš„æ ‡ç­¾
6. ~getNamespace?: (tag: string, parent: ElementNode | undefined) => Nâ„amespace~ ï¼Œè·å–æ ‡ç­¾å‘½åç©ºé—´
7. ~getTextMode?: (node: ElementNode, parent: ElementNode|undefined) =>
   TextModes~ è·å–æ–‡æœ¬è§£ææ¨¡å¼
8. ~delimiters?: [string, string]~ ï¼Œæ’å€¼åˆ†éš”ç¬¦ï¼Œé»˜è®¤ï¼š ~['{{', '}}']~
9. ~decodeEntities?: (rawText: string, asAttr: boolean) => string~ ï¼Œä»…ç”¨äº DOM compilers
10. ~onError?: (error: CompilerError) => void~

** ParserContext
:PROPERTIES:
:COLUMNS:  %CUSTOM_ID[(Custom Id)]
:CUSTOM_ID: td-parser-context
:END:

å®šä¹‰ä½ç½®ï¼š
#+begin_export html
<font color="purple"> src/parse.ts</font>
#+end_export

æ¥å£å†…å®¹ï¼š

#+begin_src typescript
  export interface ParserContext {
      options: MergedParserOptions // è§£æå™¨é€‰é¡¹ï¼Œå³åˆå¹¶ä¹‹åçš„å‚æ•°å¯¹è±¡
      readonly originalSource: string // æœ€åˆçš„æºç ï¼Œå³è§£æä¹‹å‰çš„æœ€åŸå§‹çš„å­—ç¬¦ä¸²ï¼Œåªè¯»ç‰ˆæœ¬
      source: string // è§£æä¸­çš„æºç å­—ç¬¦ä¸²ï¼Œä¼šå‘ç”Ÿå˜åŒ–çš„å­—ç¬¦ä¸²
      offset: number // è§£æçš„æŒ‡é’ˆä½ç½®ï¼Œç±»ä¼¼æ–‡ä»¶è¯»å–æ˜¯çš„æŒ‡é’ˆåç§»é‡
      line: number // è§£æä½ç½®åœ¨æºç ä¸­çš„å½“å‰è¡Œ
      column: number // è§£æä½ç½®åœ¨æºç ä¸­çš„å½“å‰åˆ—
      inPre: boolean // æ ‡è¯†æ˜¯ä¸æ˜¯ <pre> æ ‡ç­¾ï¼Œå¦‚æœæ˜¯éœ€è¦ä¿ç•™ç©ºæ ¼ä¿è¯ç¼©è¿›
      inVPre: boolean // v-pre æŒ‡ä»¤ï¼Œä¸å¤„ç†æŒ‡ä»¤å’Œæ’å€¼(v-xxx, {{...}})
  }
#+end_src

* utils.ts
** advancePositionWithMutation(pos,source, numberOfCharacters)
:PROPERTIES:
:COLUMNS:  %CUSTOM_ID[(Custom Id)]
:CUSTOM_ID: util-advancepositionwithmutation
:END:

æ›´æ–° context çš„ lineï¼Œcolumnï¼Œoffset çš„å€¼

#+begin_src typescript
  // advance by mutation without cloning (for performance reasons), since this
  // gets called a lot in the parser
  export function advancePositionWithMutation(
      pos: Position,
      source: string,
      numberOfCharacters: number = source.length
  ): Position {
      let linesCount = 0
      let lastNewLinePos = -1
      for (let i = 0; i < numberOfCharacters; i++) {
          if (source.charCodeAt(i) === 10 /* newline char code */) {
              linesCount++
              lastNewLinePos = i
          }
      }

      pos.offset += numberOfCharacters
      pos.line += linesCount
      pos.column =
          lastNewLinePos === -1
          ? pos.column + numberOfCharacters
          : numberOfCharacters - lastNewLinePos

      return pos
  }
#+end_src

* é˜¶æ®µä»£ç è®°å½•
:PROPERTIES:
:COLUMNS:  %CUSTOM_ID[(Custom Id)]
:CUSTOM_ID: stage_code
:END:

1. [[https://github.com/gcclll/vue-next-code-read/tree/master/bakups/compiler-core/text-test-01-some-text][text01: some text çš„ä»£ç å¤‡ä»½]]
:PROPERTIES:
:COLUMNS: %CUSTOM_ID[(Custom Id)]
:CUSTOM_ID: link-01
:END:
2. [[https://github.com/gcclll/vue-next-code-read/tree/master/bakups/compiler-core/text-test-02-some-text-div-01][text02: some text \<div> 01 ä»£ç å¤‡ä»½]]
:PROPERTIES:
:COLUMNS: %CUSTOM_ID[(Custom Id)]
:CUSTOM_ID: link-02
:END:
3. [[https://github.com/gcclll/vue-next-code-read/tree/master/bakups/compiler-core/text-test-02-some-text-div-02][text02: some text \<div> 02 ä»£ç å¤‡ä»½]]
:PROPERTIES:
:COLUMNS: %CUSTOM_ID[(Custom Id)]
:CUSTOM_ID: link-03
:END:
4. [[https://github.com/gcclll/vue-next-code-read/tree/master/bakups/compiler-core/text-test-03-interpolation][text03: some {{ foo + bar }} text ä»£ç å¤‡ä»½]]
:PROPERTIES:
:COLUMNS: %CUSTOM_ID[(Custom Id)]
:CUSTOM_ID: link-04
:END:
5. [[https://github.com/gcclll/vue-next-code-read/tree/master/bakups/compiler-core/text-test-03-interpolation][text04: some {{ a<b && c>d }} text ä»£ç å¤‡ä»½]]
:PROPERTIES:
:COLUMNS: %CUSTOM_ID[(Custom Id)]
:CUSTOM_ID: link-05
:END:
6. [[https://github.com/gcclll/vue-next-code-read/tree/master/bakups/compiler-core/comment-test][comment: <!--x-->æ³¨é‡Šè§£æä»£ç å¤‡ä»½]]
:PROPERTIES:
:COLUMNS: %CUSTOM_ID[(Custom Id)]
:CUSTOM_ID: link-06
:END:

* é—®é¢˜/ç–‘é—®åˆ—è¡¨
:PROPERTIES:
:COLUMNS:  %CUSTOM_ID[(Custom Id)]
:CUSTOM_ID: issues
:END:


1. @@html:<font color='red'>@@å¦‚ä½•åŒºåˆ†å†…ç½®æ ‡ç­¾|å†…ç½®ç»„ä»¶|æ ¸å¿ƒç»„ä»¶|è‡ªå®šä¹‰ç»„ä»¶ï¼Ÿ[[#parse-parsetag-04][ğŸ›«]]@@html:</font>@@

2. @@html:<font color='red'>@@ä¸ºä»€ä¹ˆ [parseTag](#parse-parsetag) è§£æ `<div>` ä¹‹ååªä¼šå¾—
   åˆ° `<div` è€Œä¸ä¼šå°† `>` è§£æè¿›å»ï¼Ÿ[ğŸ›«](#parse-parseelement)@@html:</font>@@

   #+begin_example
   ç­”ï¼šæ˜¯å› ä¸ºæ¼æ‰å®ç°äº†ä¸€éƒ¨åˆ†ä»£ç ï¼Œè‡ªé—­åˆæ ‡ç­¾çš„æ£€æµ‹ï¼Œç§»åŠ¨æŒ‡é’ˆ(2/1ä½)
   #+end_example

   å¦‚ä¸‹ï¼š
   #+begin_src js
     function parseTag(context, type) {
       // .... çœç•¥


       // TODO-3 <div/> è‡ªé—­æ ‡ç­¾
       // è¿™é‡Œè¦å®ç°ï¼Œä¸ç„¶æœ€åè§£æå®Œæˆä¹‹å source ä¼šæ˜¯ï¼š>...</span>
       // éœ€è¦æ£€æµ‹ä¸‹æ˜¯ä¸æ˜¯è‡ªé—­åˆæ ‡ç­¾æ¥ç§»åŠ¨æŒ‡é’ˆä½ç½®
       let isSelfClosing = false
       if (context.source.length === 0) {
         emitError(context, ErrorCodes.EOF_IN_TAG)
       } else {
         // some <div> ... </div> åˆ°è¿™é‡Œçš„ source = > ... </div>
         // æ‰€ä»¥å¯ä»¥æ£€æµ‹æ˜¯ä¸æ˜¯ä»¥ /> å¼€å¤´çš„
         isSelfClosing = context.source.startsWith('/>')
         if (type === TagType.End && isSelfClosing) {
           emitError(context, ErrorCodes.END_TAG_WITH_TRAILING_SOLIDUS)
         }
         // å¦‚æœæ˜¯è‡ªé—­åˆæŒ‡é’ˆç§»åŠ¨ä¸¤ä½(/>)ï¼Œå¦åˆ™åªç§»åŠ¨ä¸€ä½(>)
         // åˆ°è¿™é‡Œ source = ... </div>
         advanceBy(context, isSelfClosing ? 2 : 1)
       }

       // ... çœç•¥
     }
   #+end_src

3. @@html:<font color='red'>@@ä¸ºä»€ä¹ˆ [parseElement](#parse-parseelement)Â è§£æ children çš„æ—¶å€™å…ˆ ancestors.push(element) è§£æä¹‹ååˆ pop() æ‰ï¼Ÿ@@html:</font>@@

   #+begin_example
   ç­”ï¼šè¦å›åˆ°è¿™ä¸ªé—®é¢˜è¦ä» parseChildren å’Œ parseElement ä¸¤ä¸ªå‡½æ•°ç»“åˆæ¥çœ‹ï¼Œå¦‚ä¸‹ä»£ç åˆ†æ
   #+end_example

   #+begin_src js
     // è§£ææµç¨‹(ç”¨ä¾‹5)ï¼š
     // 1. å…ˆ parseChildren(context, mode, ancestors)
     // è§£æ `some <span>{{ foo < bar + foo }} text</span>`
     //   1) é¦–å…ˆå¾—åˆ°çš„æ˜¯ `some ` æ–‡æœ¬èŠ‚ç‚¹
     //   2) æ£€æµ‹åˆ° <span> è¿›å…¥æ ‡ç­¾è§£æ parseElement(context, ancestors) æ³¨æ„è¿™é‡Œçš„     //				ancestorsï¼Œæ˜¯ç”± parseChildren ç»§æ‰¿è¿‡æ¥çš„
     // 2. è¿›å…¥ parseElement è§£æè¿›ç¨‹
     //     1) é‡åˆ° <span> è§£æå‡ºæ ‡ç­¾èŠ‚ç‚¹ span
     //     2) åœ¨è‡ªèº«å‡½æ•°å†…æ£€æµ‹åˆ°æ ‡ç­¾å†…è¿˜æœ‰å†…å®¹ï¼Œé‡æ–°è°ƒç”¨ parseChildren(..., ancestors)
     //    3) æ‰€ä»¥é‡ç‚¹æ¥äº†
     // ...
     // ...
     // ancestors æ˜¯ parseChildren ä¼ é€’è¿‡æ¥çš„ï¼ŒparseElement é‡Œé¢å°†
     // push çš„ç›®çš„ï¼šè®©å­èŠ‚ç‚¹æœ‰æ‰€ä¾èµ–ï¼ŒçŸ¥é“è‡ªå·±çš„çˆ¶çº§æ˜¯è°ï¼Œä½†å¥½åƒ parseChildren é‡Œé¢ç”¨åˆ°
     //     parent ä¹Ÿæ˜¯ä¸ºäº†è·å–å‘½åç©ºé—´å»ç”¨äº†
     // pop çš„ç›®çš„ï¼šéš¾é“æ˜¯ä¸ºäº†ä¸æ±¡æŸ“ ancestors ???
   #+end_src

   å¥½åƒè¿˜ä¸æ˜¯å¾ˆæ˜ç¡®ä¸ºä½•è¦ push->popã€‚
