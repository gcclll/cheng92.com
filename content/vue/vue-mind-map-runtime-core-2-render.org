#+TITLE: Vue3 æºç å¤´è„‘é£æš´ä¹‹ 7 â˜ runtime-core(2) - render
#+DATE: <2021-01-26 14:14:35>
#+TAGS[]: vue, vue3, runtime-core, render
#+CATEGORIES[]: vue
#+LANGUAGE: zh-cn
#+STARTUP: indent shrink inlineimages

#+begin_export html
<link href="https://fonts.goo~gleapis.com/cs~s2?family=ZCOOL+XiaoWei&display=swap" rel="stylesheet">
<kbd>
<font color="blue" size="3" style="font-family: 'ZCOOL XiaoWei', serif;">
  è¯—å·ï¼šå…­é“åŒå ï¼Œé­”åŠ«ä¸‡åƒï¼Œå¼•æ¸¡å¦‚æ¥ã€‚
</font>
</kbd><br><br>
<script src="/js/vue/vue-next.js"></script>
<script src="https://unpkg.com/element-plus/lib/index.full.js"></script>
<script src="/js/utils.js"></script>
#+end_export

[[/img/bdx/yiyeshu-001.jpg]]

@@html:<kbd>@@
*[[https://github.com/gcclll/stb-vue-next][stb-vue-next]] å®Œå…¨æ‹·è´äº [[https://github.com/vuejs/vue-next][vue-next]] ï¼Œä¸»è¦ç›®çš„ç”¨äºå­¦ä¹ ã€‚*
@@html:</kbd>@@

#+begin_quote
*å£°æ˜* ï¼švue-next runtime-core ä¸­çš„ render å‡½æ•°éƒ¨åˆ†ï¼Œ
#+begin_export html
<font color='red'
size='2'>æœ¬ç¯‡æ‰€ä½¿ç”¨çš„çš„æµ‹è¯•ä¾‹å­æ˜¯æ™®
é€šçš„æ•°å­—æ•°ç»„ï¼Œå®é™…ä¸­æ¯ä¸ªèŠ‚ç‚¹éƒ½æ˜¯ VNode ç»“æ„ï¼Œä¹Ÿå°±æ˜¯è¯´æ˜¯å”¯ä¸€çš„ï¼Œæ‰€ä»¥ä¸å­˜åœ¨ä¸åŒèŠ‚
ç‚¹å…±äº«åŒä¸€ä¸ªå†…å­˜ç©ºé—´é—®é¢˜ï¼Œè¿™ä¹Ÿå°±æ˜¯ä¸ºä½•ç”¨ä¾‹ä¸­æ²¡æœ‰é‡å¤æ•°å­—çš„åŸå› ã€‚(_å°±ç®—æ˜¯é™æ€çš„å¯
å¤ç”¨èŠ‚ç‚¹ä¹Ÿä¼šæ‰§è¡Œ cloneVNode å…‹éš†å‡ºä¸€ä¸ªå…¨æ–°çš„å¯¹è±¡_)
</font>
#+end_export

*æ›´æ–°æ—¥å¿—&Todos* ï¼š
1. [2021-01-26 14:15:15] åˆ›å»º
#+end_quote

[[/img/tmp/20210126143153.png]]

#+begin_quote
2229 - 423 = 1806 ğŸ¤¦â€â™€ï¸ ä¸€ä¸ªå‡½æ•°å°±å°†è¿‘ä¸¤åƒè¡Œï¼ŒğŸ˜²ï¼ï¼

æ·å¾„ğŸ‘£ï¼š
1. [[#keyed-children][å¦‚æœåªæƒ³äº†è§£å¦‚ä½• diff ï¼Ÿ æ›´æ–°ï¼Ÿ]]
#+end_quote

* è„‘å›¾
_runtime-core/src/render.ts_ è„‘å›¾ï¼š

[[/img/vue3/runtime-core/vue-runtime-core-render-ts.svg]]

render å‡½æ•°åˆ›å»ºå‡½æ•° ~baseCreateRender(options, createHydrationFns?)~

[[/img/vue3/runtime-core/vue-runtime-core-render-baseCreateRender.svg]]

* init

[[https://github.com/gcclll/stb-vue-next/commit/fb9738c18c624fe7525afa48b12b6589a3ac0dfe][feat(init): render function Â· gcclll/stb-vue-next@fb9738c Â· GitHub]]


ä¸¤ä¸ª create render å‡½æ•°ï¼š

1. ~createRenderer(options)~
2. ~createHydrationRenderer(options)~

   è¿™ä¸ªè¿˜ä¸æ¸…æ¥šæ˜¯å¹²ä»€ä¹ˆçš„ï¼Œé€šè¿‡ä»£ç è§‚å¯Ÿè²Œä¼¼è·Ÿ SSR æœ‰å…³ï¼Œå…ˆæç½®å…ˆä¸ç®¡ã€‚


ä¸¤ä¸ªå‡½æ•°æœ€ç»ˆéƒ½æ˜¯è°ƒç”¨çš„ ~baseCreateRenderer(options, createHydrationFns)~

å¹¶ä¸”å°±æ˜¯è¿™ä¸ªå‡½æ•°å°†è¿‘ä¸¤åƒè¡Œ~~~~

#+begin_src typescript
export function createRenderer<
  HostNode = RendererNode,
  HostElement = RendererElement
>(options: RendererOptions<HostNode, HostElement>) {
  return baseCreateRenderer<HostNode, HostElement>(options);
}

export function createHydrationRenderer(
  options: RendererOptions<Node, Element>
) {
  return baseCreateRenderer(options, createHydrationFunctions);
}

// implementation
function baseCreateRenderer(
  options: RendererOptions,
  createHydrationFns?: typeof createHydrationFunctions
) {
  // TODO
}
#+end_src
* function list

[[https://github.com/gcclll/stb-vue-next/commit/b7f55a8fe0f70a58b6af48278f601777b8b3d36a][feat(init): renderer -> baseCreateRenderer TODOs Â· gcclll/stb-vue-next@b7f55a8 Â· GitHub]]

~baseCreateRenderer(options, createHydrationFns)~ ä¹‹æ‰€ä»¥è¿™ä¹ˆé•¿ï¼Œæ˜¯å› ä¸ºè¿™é‡Œé¢åŒ…å«
äº†ä¸‰åå‡ ä¸ªå‡½æ•°çš„å®šä¹‰ï¼Œä¸‹é¢å°†ä¸€ä¸ªä¸ªæŒ‰ç…§æµç¨‹é€ä¸€å®ç°ã€‚

| step                     | what?                | step               | what?        |
|--------------------------+----------------------+--------------------+--------------|
| options                  | è§£æ„                 | patch              | function     |
| processText              | æ–‡æœ¬å¤„ç†             | processCommentNode | æ³¨é‡ŠèŠ‚ç‚¹     |
| mountStaticNode          | åŠ è½½é™æ€èŠ‚ç‚¹         | patchStaticNode    | -            |
| moveStaticNode           | -                    | removeStaticNode   | åˆ é™¤é™æ€èŠ‚ç‚¹ |
| processElement           | -                    | *mountElement*       | -            |
| setScopeId               | -                    | *mountChildren*      | -            |
| patchElement             | -                    | patchBlockChildren | -            |
| patchProps               | -                    | processFragment    | -            |
| processComponent         | -                    | *mountComponent*     | -            |
| *updateComponent*        | -                    | setupRenderEffect  | -            |
| updateComponentPreRender | -                    | patchChildren      | -            |
| patchUnkeyedChildren     | -                    | patchKeyedChildren | -            |
| *move*                   |                      | *unmount*            |              |
| *remove*                 | -                    | removeFragment     | -            |
| unmountComponent         | -                    | *unmountChildren*    | -            |
| getNextHostNode          | -                    | *render*             | -            |
| internals                | object, ä¸Šè¿°å‡½æ•°åˆ«å | createHydrationFns | -            |

æœ€åå‡½æ•°è¿”å› ~{ render, hydrate, createApp }~
* render(vnode, container)

[[https://github.com/gcclll/stb-vue-next/commit/9f5b40b943cf24c21bb2ee01459254df0be42972][feat(init): baseCreateRender-> render Â· gcclll/stb-vue-next@9f5b40b Â· GitHub]]

[[https://github.com/gcclll/stb-vue-next/commit/d4e10d444605e1b8096a8e335262a2561f7376be][feat(init): baseCreateRender-> render with unmount Â· gcclll/stb-vue-next@d4e10d4
Â· GitHub]]

#+begin_src typescript
const render: RootRenderFunction = (vnode, container) => {
  // render(h('div'), root)
  if (vnode == null) {
    if (container._vnode) {
      unmount(container._vnode, null, null, true);
    }
  } else {
    patch(container._vnode || null, vnode, container);
  }
  // æ‰§è¡Œæ‰€æœ‰ post å¼‚æ­¥ä»»åŠ¡
  flushPostFlushCbs();
  container._vnode = vnode;
};
#+end_src

1. vnode ä¸ºç©ºï¼Œä¸” conatainer ä¸Šæœ‰æ³¨å†Œè¿‡ _vnodeï¼Œç»„è¦è¿›è¡Œå¸è½½

   å¦‚ï¼š ~render(ref.value ? h('div') : null)~

   ref.value = true æ—¶å€™è¿›å…¥ else -> patch

   ref.value = false æ—¶å€™è¿›å…¥ if -> unmount

2. å¦åˆ™æ‰§è¡Œ patch()ï¼Œå¹²ä»€ä¹ˆäº†?

3. ~flushPostFlushCbs()~ æ­¤æ—¶ç»„ä»¶åº”è¯¥ mounted äº†ï¼Œæ‰‹åŠ¨åˆ·æ‰æ‰€æœ‰ post cbs ã€‚

4. ä¿å­˜ _vnodeï¼Œæ–¹ä¾¿ä¸‹æ¬¡è¿›å…¥æ˜¯æ£€æµ‹


æ¥ä¸‹æ¥ï¼Œéœ€è¦ç»§ç»­å®ç° ~unmount()~ å’Œ ~patch()~
* patch(...args)
:PROPERTIES:
:COLUMNS: %CUSTOM_ID[(Custom Id)]
:CUSTOM_ID: fn-patch
:END:

[[https://github.com/gcclll/stb-vue-next/commit/eb48eb9b6a14b0654ed2a4eb966338c2bfe8afe1][feat(init): baseCreateRender-> patch -> processElement Â· gcclll/stb-vue-next@eb48eb9 Â· GitHub]]

å‚æ•°:

| å‚æ•°å          | æè¿°          |
|-----------------+---------------|
| n1              | VNode, è€èŠ‚ç‚¹ |
| n2              | VNode, æ–°èŠ‚ç‚¹ |
| container       | å®¹å™¨          |
| anchor          | ?             |
| parentComponent | çˆ¶çº§ç»„ä»¶      |
| parentSuspense  | Suspense ?    |
| isSVG           | ?             |
| optimized       | æ˜¯å¦ä¼˜åŒ–è¿‡ï¼Ÿ  |

1. æ£€æµ‹èŠ‚ç‚¹ç±»å‹æ˜¯ä¸æ˜¯ä¸€æ ·ï¼Œå¦‚æœä¸ä¸€æ ·ç›´æ¥å¸è½½è€çš„

   å› ä¸ºç±»å‹éƒ½ä¸ä¸€æ ·äº†ï¼Œå¯èƒ½æ•´ä¸ªğŸŒ²éƒ½å‘ç”Ÿäº†å˜åŒ–ï¼Œç›´æ¥å¸è½½è€çš„é‡æ–° patch æ–°çš„(*n2*)ã€‚

   #+begin_src typescript
   export function isSameVNodeType(n1: VNode, n2: VNode): boolean {
     if (
       __DEV__ &&
       n2.shapeFlag & ShapeFlags.COMPONENT &&
       hmrDirtyComponents.has(n2.type as ConcreteComponent)
     ) {
       // HMR only: if the component has been hot-updated, force a reload.
       // ç»„ä»¶è¢«çƒ­æ›´æ–°ï¼Œå¼ºåˆ¶é‡æ–°åŠ è½½
       return false;
     }
     return n1.type === n2.type && n1.key === n2.key;
   }
   #+end_src

   - ç»„ä»¶å‘ç”Ÿäº†çƒ­æ›´æ–°(HMRå¯ç”¨æƒ…å†µä¸‹)ï¼Œå¼ºåˆ¶é‡æ–°åŠ è½½ç»„ä»¶

   - åŒæ—¶åˆ¤æ–­ type å’Œ keyï¼Œæœ‰å¯èƒ½ type ä¸€æ ·(æ¯”å¦‚ï¼š ~ul>li~ åŒç±»å‹å…ƒç´ çš„åˆ é™¤ç§»åŠ¨æ“ä½œ)

2. switch -> n2.type æ ¹æ®ç±»å‹ä¸åŒèµ°ä¸åŒåˆ†æ”¯è¿›è¡Œå¤„ç†

   åªæ”¯æŒçš„ç±»å‹ï¼š ~Text|Comment|Static~ èŠ‚ç‚¹ç±»å‹

   ç»„ä»¶ç±»å‹(default åˆ†æ”¯): ~ELEMENT/TELEPORT/COMPONENT/SUSPENSE~
* patch->processElement(...args)

[[https://github.com/gcclll/stb-vue-next/commit/761db2b532ceaaf9554b7df07e2fffe686cd98f0][feat(init): baseCreateRender-> patch -> processElement imp Â·
gcclll/stb-vue-next@761db2b Â· GitHub]]

args åŒ [[#fn-patch][patch çš„ args]] ã€‚

#+begin_src typescript
const processElement = (
  n1: VNode | null,
  n2: VNode,
  container: RendererElement,
  anchor: RendererNode | null,
  parentComponent: ComponentInternalInstance | null,
  parentSuspense: SuspenseBoundary | null,
  isSVB: boolean,
  isSVG: boolean,
  optimized: boolean
) => {
  isSVG = isSVG || (n2.type as string) === "svg";
  if (n1 == null) {
    // no old
    mountElement(
      n2,
      container,
      anchor,
      parentComponent,
      parentSuspense,
      isSVG,
      optimized
    );
  } else {
    patchElement(n1, n2, parentComponent, parentSuspense, isSVG, optimized);
  }
};
#+end_src

1. æ²¡æœ‰ n1 è€èŠ‚ç‚¹ï¼Œç›´æ¥ mount æ–°çš„ n2 èŠ‚ç‚¹
2. å¦åˆ™ï¼Œè¿›è¡Œ patch æ“ä½œ


æ¥ä¸‹æ¥æŒ‰ç…§ [[#fn-patchElement][patchElement]] -> [[#fn-mountElement][mountElement]] é¡ºåºå®ç°ã€‚

* mountElement(...args)
:PROPERTIES:
:COLUMNS: %CUSTOM_ID[(Custom Id)]
:CUSTOM_ID: fn-patchElement
:END:

è¿›è¡Œåˆ°è¿™é‡Œæˆ‘ä»¬å¯ä»¥è¿›è¡Œåˆæ­¥çš„åˆ¤æ–­ï¼Œ patch å’Œ mount çš„åŒºåˆ«ï¼Œ

*patch*: éé¦–æ¬¡åŠ è½½ç»„ä»¶çš„æ—¶å€™ï¼Œç”¨ new å’Œ old vnode èŠ‚ç‚¹è¿›è¡Œæ¯”è¾ƒç„¶åå¯¹å‘ç”Ÿå˜æ›´çš„
èŠ‚ç‚¹è¿›è¡Œæ›¿æ¢æˆ–æ›´æ–°æ“ä½œã€‚

*mount*: å±äºé¦–æ¬¡åŠ è½½ç»„ä»¶çš„æ—¶å€™ï¼Œå±äºé‡æ–°åˆ›å»ºèŠ‚ç‚¹çš„æ“ä½œï¼Œä¸å­˜åœ¨æ¯”è¾ƒä»€ä¹ˆçš„ä¸€äº›æ“
ä½œã€‚

æ¯”å¦‚ï¼š ~render~ é‡Œé¢çš„æ ¹æ® vnode æ¥åˆ¤æ–­æ˜¯ Unmount è¿˜æ˜¯ patchï¼Œä»¥åŠ
processElement ä¸­æ ¹æ® old vnode æ¥æ£€æµ‹æ˜¯ä¸æ˜¯æœ‰æ—§çš„èŠ‚ç‚¹(éé¦–æ¬¡)æ¥åˆ¤å®šæ˜¯ç›´æ¥ Mount
ç»„ä»¶è¿˜æ˜¯ patch æ¯”è¾ƒæ›´æ–°ç»„ä»¶ã€‚

** default ELEMENT

[[https://github.com/gcclll/stb-vue-next/commit/81af3859c02379dac8aec3a08374c2936fdc4fe2][feat(add): patch element Â· gcclll/stb-vue-next@81af385 Â· GitHub]]

render å‡½æ•°å®ç°ï¼Œ vnode ä¸ºç©ºä¼šè¿›å…¥å¸è½½ unmount æµç¨‹ï¼Œå¦åˆ™æ‰§è¡Œçš„æ˜¯ patch ï¼Œè¿™ä¸ªåº”
è¯¥å°±æ˜¯é€šè¿‡ vnode èŠ‚ç‚¹ç»“æ„æ‰§è¡Œ diff å’Œ dom æ“ä½œçš„å…¥å£äº†ã€‚

#+begin_src typescript
const render: RootRenderFunction = (vnode, container) => {
    console.log('render.......xxx')
    // render(h('div'), root)
    if (vnode == null) {
      if (container._vnode) {
        unmount(container._vnode, null, null, true)
      }
    } else {
      patch(container._vnode || null, vnode, container)
    }
    // æ‰§è¡Œæ‰€æœ‰ post å¼‚æ­¥ä»»åŠ¡
    flushPostFlushCbs()
    container._vnode = vnode
  }
#+end_src

æ³¨æ„ä¸Šé¢çš„ ~flushPostFlushCbs()~ æ˜¯åœ¨ patch ä¹‹åæ‰§è¡Œçš„ï¼Œä¹Ÿå°±æ˜¯è¯´ post cbs ä¼šåœ¨ç»„
ä»¶ mount/unmount å®Œæˆä¹‹åçš„ä¸‹ä¸€ä¸ª tick å»æ‰§è¡Œçš„å›è°ƒã€‚

#+begin_src typescript
const patch: PatchFn = (
    n1,
    n2,
    container,
    anchor = null,
    parentComponent = null,
    parentSuspense = null,
    isSVG = false,
    optimized = false
  ) => {
    console.log('patching...')
    // ä¸åŒç±»å‹èŠ‚ç‚¹ï¼Œç›´æ¥å¸è½½è€çš„ğŸŒ²
    if (n1 && !isSameVNodeType(n1, n2)) {
      // TODO
    }

    // TODO patch bail, è¿›è¡Œå…¨æ¯”è¾ƒ(full diff)

    // æ–°èŠ‚ç‚¹å¤„ç†
    const { type, ref, shapeFlag } = n2
    switch (type) {
      default:
        // ELEMENT/COMPONENT/TELEPORT/SUSPENSE
        // é»˜è®¤åªæ”¯æŒè¿™å››ç§ç»„ä»¶
        if (shapeFlag & ShapeFlags.ELEMENT) {
          processElement(
            n1,
            n2,
            container,
            anchor,
            parentComponent,
            parentSuspense,
            isSVG,
            optimized
          )
        }
        break
    }

    if (ref != null && parentComponent) {
      // TODO set ref
    }
  }
#+end_src

patch å‡½æ•°é‡Œé¢é€šè¿‡ switch åˆ†æ”¯æ ¹æ® ~ShapeFlags~ çš„ç±»å‹ç±»è°ƒç”¨å¯¹åº”çš„  ~processXxx~
å‡½æ•°è¿›è¡Œå¤„ç† old/new vnode èŠ‚ç‚¹ï¼Œè€Œè¿™é‡Œçš„ ~ShapeFlags~ å€¼çš„ä¾æ®æ¥è‡ªå“ªé‡Œï¼Ÿæ˜¯åœ¨å“ª
é‡Œèµ‹å€¼çš„ï¼Œç”±ç”±ä»€ä¹ˆä½œç”¨ï¼Ÿ ã€‚

è¿™é‡Œä»¥æ™®é€šçš„ ELEMENT æ ‡ç­¾ä½œä¸ºåˆ‡å…¥ç‚¹æ¥å®ç°ä¸€ä¸ªå®Œæ•´çš„è¿‡ç¨‹ï¼Œè¿™é‡Œéœ€è¦ç”¨åˆ°
processElement ã€‚

#+begin_src typescript
const processElement = (
    n1: VNode | null,
    n2: VNode,
    container: RendererElement,
    anchor: RendererNode | null,
    parentComponent: ComponentInternalInstance | null,
    parentSuspense: SuspenseBoundary | null,
    isSVG: boolean,
    optimized: boolean
  ) => {
    isSVG = isSVG || (n2.type as string) === 'svg'
    if (n1 == null) {
      // no old
      mountElement(
        n2,
        container,
        anchor,
        parentComponent,
        parentSuspense,
        isSVG,
        optimized
      )
    } else {
      // è¯¥é˜¶æ®µè¿˜ä¸ä¼šåˆ°è¿™é‡Œ
      patchElement(n1, n2, parentComponent, parentSuspense, isSVG, optimized)
    }
  }
#+end_src

è¿™é‡Œå°±æ˜¯ä¸ªå¾ˆç®€å• if...else åˆ¤æ–­æ˜¯ä¸æ˜¯æœ‰æ—§çš„èŠ‚ç‚¹ï¼Œæ²¡æœ‰æ˜¯ mount æœ‰åˆ™æ˜¯ patch æ“ä½œï¼Œ
æ‰€ä»¥éœ€è¦å®Œæˆ mountElement
#+begin_src typescript
const mountElement = (
    vnode: VNode,
    container: RendererElement,
    anchor: RendererNode | null,
    parentComponent: ComponentInternalInstance | null,
    parentSuspense: SuspenseBoundary | null,
    isSVG: boolean,
    optimized: boolean
  ) => {
    console.log('mount element...')
    let el: RendererElement
    let vnodeHook: VNodeHook | undefined | null
    const { type, shapeFlag, patchFlag, props } = vnode

    if (
      !__DEV__ &&
      vnode.el &&
      hostCloneNode !== undefined &&
      patchFlag === PatchFlags.HOISTED
    ) {
      // TODO
    } else {
      el = vnode.el = hostCreateElement(
        vnode.type as string,
        isSVG,
        props && props.is
      )
    }

    // hostInsert
    hostInsert(el, container, anchor)
  }
#+end_src

mountElement é‡Œé¢ä¸¤ä¸ªæ ¸å¿ƒçš„å‡½æ•° ~hostCreateElement~ å’Œ ~hostInsert~ åˆ†åˆ«æ¥è‡ª
~baseCreateRender(option)~ çš„ option å‚æ•°ã€‚

è¿™é‡Œå°±éœ€è¦æ·±å…¥äº†è§£ ~runtime-test~ è¿™ä¸ªåŒ…ï¼Œå®ƒæ˜¯ä½œç”¨ä¸ºäº†èƒ½æµ‹è¯• runtime-core ç¼–å†™çš„
ä¸€ä¸ªæµ‹è¯•æŠ¥ï¼Œè¿™é‡ŒåŒ…å«äº†ä¸€äº›åˆ—çš„ DOM æ“ä½œå‡½æ•°ï¼Œè¿™äº›å‡½æ•°ä¹Ÿä¼šåœ¨å°è£… ~render~ çš„æ—¶å€™
ä¼ é€’ç»™ ~baseCreateRender(option)~ ï¼Œæ‰€ä»¥ä¸Šé¢çš„ hostElement å’Œ hostInsert å°±æ˜¯æ¥
è‡ª ~runtime-test~ ï¼Œ[[/vue/vue-mind-map-runtime-core/#runtime-test][è¿™é‡Œé“¾æ¥]]å¯ä»¥è·³è½¬æŸ¥çœ‹è¯¥åŒ…é‡Œé¢å…·ä½“åŒ…å«å“ªäº›å‡½æ•°ï¼Œåˆæ˜¯åšä»€ä¹ˆçš„ï¼Œ
è¿™é‡Œå°±ä¸å±•å¼€ç»†è®²ï¼Œä¸»è¦çœ‹ä¸‹ç›¸å…³çš„ä¸¤ä¸ªå‡½æ•°å®ç°ã€‚

#+begin_src typescript
function createElement(tag: string): TestElement {
  const node: TestElement = {
    id: nodeId++,
    type: NodeTypes.ELEMENT,
    tag,
    children: [],
    props: {},
    parentNode: null,
    eventListeners: null
  }
  // ... log
  // avoid test nodes from being observed
  markRaw(node)
  return node
}

function insert(child: TestNode, parent: TestElement, ref?: TestNode | null) {
  let refIndex
  if (ref) {
    refIndex = parent.children.indexOf(ref)
    if (refIndex === -1) {
      console.error('ref: ', ref)
      console.error('parent: ', parent)
      throw new Error('ref is not a child of parent')
    }
  }
  //...log
  // remove the node first, but don't log it as a REMOVE op
  remove(child, false)
  // re-calculate the ref index because the child's removal may have affected it
  refIndex = ref ? parent.children.indexOf(ref) : -1
  if (refIndex === -1) {
    parent.children.push(child)
    child.parentNode = parent
  } else {
    parent.children.splice(refIndex, 0, child)
    child.parentNode = parent
  }
}
#+end_src

æ‰€ä»¥è¯´ï¼Œæˆªè‡³ç›®å‰è¿˜å¹¶æ²¡æœ‰æ¶‰åŠåˆ°å®é™…çš„ DOM æ“ä½œï¼Œè¿˜åªæ˜¯åœ¨ vnode ç»“æ„ä¸Šè¿›è¡Œæ’å…¥åˆ é™¤
æ“ä½œã€‚

è¿™é‡Œå¼€å§‹åº”è¯¥å¯ä»¥æµ‹è¯•äº†ï¼š
#+begin_src js
const { log, runtime_test } = require(process.env.BLOG_DIR_VUE + "/lib.js");
log("xx");
runtime_test().then(
  ({ h, render, nodeOps, serializeInner: inner }) => {
    let root = nodeOps.createElement("div");
    log('>>> root ast, è¿™é‡Œ children é‡Œé¢åº”è¯¥è¿˜æ²¡æœ‰èŠ‚ç‚¹')
    log.f(root, ['type', 'children'])
    log.f(h("div"), ["type"]);
    log('>>> begin render...')
    render(h("div"), root);
    log('>>> after seririlize inner')
    log(inner(root), ['type', 'children']);
  },
  (e) => console.log(e.message)
);
#+end_src

#+RESULTS:
#+begin_example
xx
undefinedfalse
>>> root ast, è¿™é‡Œ children é‡Œé¢åº”è¯¥è¿˜æ²¡æœ‰èŠ‚ç‚¹
{ type: 'element', children: [] }
{ type: 'div' }
>>> begin render...
render.......xxx
patching...
mount element...
mountElment else...
el = vnode.el = hostCreateElement =  {
  id: 1,
  type: 'element',
  tag: 'div',
  children: [],
  props: {},
  parentNode: null,
  eventListeners: null
}
<ref *1> {
  id: 0,
  type: 'element',
  tag: 'div',
  children: [
    {
      id: 1,
      type: 'element',
      tag: 'div',
      children: [],
      props: {},
      parentNode: [Circular *1],
      eventListeners: null
    }
  ],
  props: {},
  parentNode: null,
  eventListeners: null
}
>>> after seririlize inner
<div></div>
#+end_example

æ³¨æ„çœ‹ä¸Šé¢çš„ç»“æœï¼Œæœ€å ~h('div')~ ç”Ÿæˆçš„èŠ‚ç‚¹åˆ« insert è¿›äº† ~root.children~ ä¸­ï¼Œ
ç„¶åæ³¨æ„ ~insert~ æœ€åçš„å®ç°æ’å…¥æ›¿æ¢éƒ¨åˆ†: *å½“æ²¡æœ‰æ‰¾åˆ°æ—¶ refIndex = -1ï¼Œç›´æ¥æ‰§è¡Œ
å°¾éƒ¨æ’å…¥æ“ä½œ ~push(...)~, å¦‚æœæ‰¾åˆ°äº†å°±æ‰§è¡Œ ~splice(refIndex, 1, child)~*

æ‰€ä»¥è¿™é‡Œç›´æ¥æ‰§è¡Œçš„æ˜¯ç›´æ¥å°¾éƒ¨æ’å…¥æ“ä½œã€‚

æœ€åè¾“å‡ºçš„ ~<div></div>~ æ˜¯ç”±äºè°ƒç”¨äº† ~serializeInner(root)~ ç»“æœï¼Œä¹Ÿæ˜¯ç›¸å½“äº
DOM æ“ä½œäº†(~serializeInner~ -> ~seririlize>children~ -> ~serializeElement~ -> æœ€åæ ¹æ®
tag, props, children é€’å½’è§£æç”Ÿæˆå¯¹åº”çš„ DOM å…ƒç´ ç»“æ„)ã€‚

serializeElement å®ç°ï¼š
#+begin_src typescript
function serializeElement(
  node: TestElement,
  indent: number,
  depth: number
): string {
  const props = Object.keys(node.props)
    .map(key => {
      const value = node.props[key]
      return isOn(key) || value == null
        ? ``
        : value === ``
          ? key
          : `${key}=${JSON.stringify(value)}`
    })
    .filter(Boolean)
    .join(' ')
  const padding = indent ? ` `.repeat(indent).repeat(depth) : ``
  return (
    `${padding}<${node.tag}${props ? ` ${props}` : ``}>` +
    `${serializeInner(node, indent, depth)}` +
    `${padding}</${node.tag}>`
  )
}
#+end_src

æ‰€ä»¥åˆ°æ­¤åº”è¯¥æ˜¯å®Œæˆäº†æœ€æ™®é€šçš„ ~ELEMENT~ ç±»å‹å…ƒç´ ä»

ast -> compiler-dom >> compiler-core >> compiler-sfc
vnode -> runtime-core >> runtime-test(æµ‹è¯•ç”¨)
render -> runtime-core >> baseCreateRender >> render >>
mount/unmount/patch ->
ç”Ÿæˆ DOM å…ƒç´ ç»“æ„è¾ƒä¸ºå®Œæ•´çš„ä»£ç ã€‚
** with props

[[https://github.com/gcclll/stb-vue-next/commit/46fc2a0ab59c591c3c1a737e3b604e0aece6cf0b][feat(add): baseRenderer->element with props Â· gcclll/stb-vue-next@46fc2a0 Â·
GitHub]]

#+begin_src js
const { log, f, runtime_test } = require(process.env.BLOG_DIR_VUE + "/lib.js");
import(process.env.BLOG_DIR_VUE + "/runtime-test.global.js").then(
  ({ h, render, nodeOps, serializeInner: inner }) => {
    const root = nodeOps.createElement("div");
    render(h("div", { id: "foo", class: "bar" }), root);
    log(inner(root));
  },
  (err) => {
    console.log(err.message);
  }
);
#+end_src

#+RESULTS:
: undefinedfalse
: render.......
: patching...
: mount element...
: mountElment else...
: <div id="foo" class="bar"></div>

æœ€åè¾“å‡ºç»“æœï¼š ~<div id="foo" class="bar"></div>~

è¿˜è®°å¾— [[/vue/vue-mind-map-runtime-core/#h-function][runtime-core > h function]] ä¸€èŠ‚æˆ‘ä»¬è¯¦ç»†æè¿°äº† h å‡½æ•°çš„ç”¨æ³•ï¼Œè¿™é‡Œç®€å•å›é¡¾ä¸‹

| h ç¬¬äºŒä¸ªå‚æ•°        | æè¿°                                                      |
|---------------------+-----------------------------------------------------------|
| æ™®é€šå¯¹è±¡            | å½“åš props å¤„ç†                                           |
| æ•°ç»„ç±»å‹            | å½“åš children å¤„ç†                                        |
| æ˜¯ä¸ª VNode ç±»å‹å¯¹è±¡ | å¸¦æœ‰ __v_isVNode = true å±æ€§ï¼Œ [vnode] å½“åš children å¤„ç† |

æ‰€ä»¥ä¸Šé¢çš„ ~{ id: 'foo', class: 'bar' }~ è¢«å½“åšå±æ€§ä¼ é€’ç»™ ~createVNode(type,
props, children ...)~ å‡½æ•°

æ–°å¢ä»£ç ï¼š
#+begin_src typescript
// mountElement å¢åŠ  props å¤„ç†é€»è¾‘
const mountElement = (
    vnode: VNode,
    container: RendererElement,
    anchor: RendererNode | null,
    parentComponent: ComponentInternalInstance | null,
    parentSuspense: SuspenseBoundary | null,
    isSVG: boolean,
    optimized: boolean
  ) => {
    console.log('mount element...')
    // TODO
    let el: RendererElement
    let vnodeHook: VNodeHook | undefined | null
    const { type, shapeFlag, patchFlag, props } = vnode

    if (
      !__DEV__ &&
      vnode.el &&
      hostCloneNode !== undefined &&
      patchFlag === PatchFlags.HOISTED
    ) {
      // ...
    } else {


      // æ–°å¢ start
      if (props) {
        for (const key in props) {
          // vue ä¿ç•™å±æ€§ ref/key/onVnodeXxx ç”Ÿå‘½å‘¨æœŸ
          if (!isReservedProp(key)) {
            hostPatchProp(
              el,
              key,
              null,
              props[key],
              isSVG,
              vnode.children as VNode[],
              parentComponent,
              parentSuspense,
              unmountChildren
            )
          }
        }

        if ((vnodeHook = props.onVnodeBeforeMount)) {
          // æ‰§è¡Œ before mount hook
          invokeVNodeHook(vnodeHook, parentComponent, vnode)
        }
      } // end æ–°å¢
    }


    // ...

  }
#+end_src

render -> patch -> case ELEMENT -> processElement -> mountElement

åœ¨ mountElement ä¸­å¢åŠ  props å¤„ç†é€»è¾‘ï¼Œé’ˆå¯¹æ¯ä¸ª prop æ£€æµ‹æ˜¯ä¸æ˜¯ä¿ç•™åå­—

~key/ref/onVnodeXxx~ ç­‰ç”Ÿå‘½å‘¨æœŸåï¼Œéä¿ç•™åå­—æ‰éœ€è¦å¤„ç†ï¼Œè°ƒç”¨ hostPatchProp() å¤„
ç†ï¼Œåé¢åŠ ä¸Š ~BeforeMount~ ç”Ÿå‘½å‘¨æœŸé’©å­å‡½æ•°è°ƒç”¨ã€‚

#+begin_src typescript
// runtime-test/src/patchProp.ts
export function patchProp(
  el: TestElement,
  key: string,
  prevValue: any,
  nextValue: any
) {
  logNodeOp({
    type: NodeOpTypes.PATCH,
    targetNode: el,
    propKey: key,
    propPrevValue: prevValue,
    propNextValue: nextValue
  })
  el.props[key] = nextValue
  if (isOn(key)) {
    const event = key.slice(2).toLowerCase()
    ;(el.eventListeners || (el.eventListeners = {}))[event] = nextValue
  }
}
#+end_src

æ™®é€šå±æ€§ç›´æ¥æ›´æ–°åˆ° ~el.props~ ä¸­ï¼Œå¦‚æœæ˜¯ ~onXxx~ ç±»å‹çš„äº‹ä»¶ï¼Œå–å‡º ~xxx~ ä½œä¸º
~el.eventListeners~ çš„ key å°†äº‹ä»¶åå’Œå…¶å¤„ç†å¥æŸ„ä¿å­˜èµ·æ¥ã€‚

è¿™é‡Œçš„ ~el~ å®é™…ä¸Šæ˜¯ä¸ª ast ç»“æ„ç±»å‹çš„å¯¹è±¡ï¼Œä¿å­˜è¿™æ¯ä¸ªèŠ‚ç‚¹çš„æ‰€æœ‰ä¿¡æ¯ã€‚
** with text children

*** çº¯æ–‡æœ¬å•èŠ‚ç‚¹ child

å°†çº¯æ–‡æœ¬åšä¸º child ï¼Œå°†ä¼šè¢« ~h~ å‡½æ•°è½¬æˆ ~[child]~ ä¼ é€’ç»™ ~createVNode(type,
props, children, ...)~ åšä¸ºå®ƒçš„children å‚æ•°å¤„ç†ã€‚

#+begin_src js
const { log, f, runtime_test } = require(process.env.BLOG_DIR_VUE + "/lib.js");
import(process.env.BLOG_DIR_VUE + "/runtime-test.global.js").then(
  ({ h, render, nodeOps, serializeInner: inner }) => {
    const _root = tag => nodeOps.createElement(tag || "div")
    log('>>> çº¯æ–‡æœ¬ä½œä¸º children')
    const r1 = _root()
    render(h('div', 'pure test as children'), r1);
    log(inner(r1));
  },
  (err) => {
    console.log(err.message);
  }
);
#+end_src

#+RESULTS:
: undefinedfalse
: >>> çº¯æ–‡æœ¬ä½œä¸º children
: render.......
: patching...
: mount element...
: mountElment else...
: <div>pure test as children</div>

ä¸Šé¢ç¤ºä¾‹æ˜¯å°†çº¯æ–‡æœ¬ä½œä¸º children å»æ¸²æŸ“è¿› root èŠ‚ç‚¹ï¼Œæ¶‰åŠä»£ç ä¿®æ”¹(~mountElement()~):

[[https://github.com/gcclll/stb-vue-next/commit/43b868e7f26f3e6ef1c0672d58bae842f1b8720f][feat(add): pure text as children to render Â· gcclll/stb-vue-next@43b868e Â·
GitHub]]


[[/img/tmp/diff-mountElement.png]]

*** æ•°ç»„ç±»å‹(å¤šä¸ª) children:

[[https://github.com/gcclll/stb-vue-next/commit/e6a5e619627bb080906eac4b84a0f1705888c551][feat(add): render->array children Â· gcclll/stb-vue-next@e6a5e61 Â· GitHub]]

å½“ h(type, propsOrChildren) ç¬¬äºŒä¸ªå‚æ•°ä¸ºæ•°ç»„æ—¶ä¼šè¢«å½“åš children ç»™ ~createVNode~
ã€‚

#+begin_src js
const { log, f, runtime_test } = require(process.env.BLOG_DIR_VUE + "/lib.js");
import(process.env.BLOG_DIR_VUE + "/runtime-test.global.js").then(
  ({ h, render, nodeOps, serializeInner: inner }) => {
    const root = nodeOps.createElement("div");
    render(h("div", ["foo", " ", "bar"]), root);
    log(inner(root));
  },
  (err) => {
    console.log(err.message);
  }
);
#+end_src

#+RESULTS:
#+begin_example
undefinedfalse
render.......
patching...
{ type: 'div', shapeFlag: 17 }
xxxx
case default...
process element...
mount element...
mountElment else...
patching...
{ type: Symbol(Text), shapeFlag: 8 }
process text...
patching...
{ type: Symbol(Text), shapeFlag: 8 }
process text...
patching...
{ type: Symbol(Text), shapeFlag: 8 }
process text...
<div>foo bar</div>
#+end_example

ä»ä¸Šé¢çš„è¾“å‡ºå¯å¾—å‡º ~render(h('div'), ['foo', ' ', 'bar']), root)~ å¤§æ¦‚æ‰§è¡Œæµç¨‹:

1. root->div

   - *render*, æ ¹æ® vnode ä¸ºç©ºæ£€æµ‹å†³å®šæ˜¯ unmount è¿˜æ˜¯ patch
   - *patch*, æ ¹æ® new vnode çš„ type(å››ç§ç±»
     å‹ ~Text|Comment|Fragment|Static|default~ ) å†³
     å®šè°ƒç”¨ä»€ä¹ˆ ~processXxx~ è¿›è¡Œå¤„ç†
   - *case default* ç”±äºè¿™é‡Œæ˜¯æ ¹èŠ‚ç‚¹ï¼Œä¸”æ˜¯ 'div' æ™®é€šç±»å‹å…ƒç´ ï¼Œè¿›å…¥ processElement
   - *processElement*, æ ¹æ® old vnode åˆ¤æ–­æ˜¯ mount è¿˜æ˜¯ patch æ“ä½œ
   - æ—  old vnode, æ²¡æœ‰æ—§çš„vnodeè¡¨ç¤ºæ˜¯æ–°èŠ‚ç‚¹ï¼Œéœ€è¦æ‰§è¡Œ mount æ“ä½œ
   - *mountElement*, éœ€è¦æ£€æµ‹ vnode.el æ¥åˆ¤æ–­æ˜¯ä¸æ˜¯é™æ€æå‡çš„èŠ‚ç‚¹ï¼Œå¦‚æœæ˜¯é™æ€èŠ‚ç‚¹
     å±äºå¯å¤ç”¨çš„èŠ‚ç‚¹ï¼Œéœ€è¦ cloneVNode å‡ºæ¥ä½¿ç”¨ï¼Œå¦åˆ™åˆ›å»ºæ–°çš„
   - *else: hostCreateElement* åˆ›å»ºæ–°çš„å…ƒç´ ï¼Œç„¶åé€šè¿‡ ~shapeFlag~ åˆ¤æ–­ children
     æ˜¯ä»€ä¹ˆç±»å‹è¿›å…¥ä¸åŒåˆ†æ”¯è¿›è¡Œå¤„ç†ï¼Œè¿™é‡Œæ˜¯æ•°ç»„(~ShapeFlags.ARRAY_CHILDREN~) æ‰€
     ä»¥ä¼šè°ƒç”¨ ~mountChildren(vnode.children, el, ...)~ å¼€å§‹ mount children.
   - *mountChldren* , ä¼šå¯¹ children è¿›è¡Œéå†ï¼Œå¦‚æœ child.el å­˜åœ¨è¯´æ˜æ˜¯å¯å¤ç”¨èŠ‚ç‚¹
     (é™æ€æå‡çš„)ï¼Œåˆ™å°† child clone å‡ºæ¥ä½¿ç”¨ï¼Œå¦åˆ™è¿›è¡Œ normailize å¤„ç†(å…¶å®ä¹Ÿå°±
     æ˜¯æ ¹æ® child æ•°æ®ç±»å‹ä¸åŒæ‰§è¡Œ createVNode è¿”å›æ–°çš„ vnode ç»™ child)ï¼Œæœ€åå°† child ä¼ å…¥ patch å›åˆ°ç¬¬
     äºŒæ­¥è¿›è¡Œé€’å½’ mount children

2. root->div->'foo'

   åœ¨ *1* æœ€åè¿›å…¥é€’å½’ä¹‹åï¼Œä¼šè¿›å…¥åˆ° patch æ£€æµ‹åˆ° type æ˜¯ Text ç±»å‹ï¼Œå»è°ƒç”¨
   ~processText()~ å¤„ç† ~'foo'~ å®Œæˆä¹‹åï¼Œå†å›æº¯é€’å½’å¤„ç†ä¸‹ä¸€ä¸ªå…ƒç´  ~' '~ ç›´åˆ°ç»“æŸã€‚

3. root->div->' ' åŒ *2*

4. root->idv->'bar' åŒ *2*


æ¶‰åŠä¿®æ”¹å†…å®¹(~renderer.ts -> baseCreateRender~)ï¼š

#+begin_src typescript
// patch()
// å¢åŠ  Text ç±»å‹åˆ†æ”¯å¤„ç† children: ['foo', ' ', 'bar']
switch (type) {
  case Text:
    processText(n1, n2, container, anchor);
    break;
}

// æ–°å¢ processText(n1, n2, container, anchor)
const processText: ProcessTextOrCommentFn = (n1, n2, container, anchor) => {
  console.log("process text...");
  if (n1 == null /* old */) {
    // æ–°èŠ‚ç‚¹ï¼Œæ’å…¥å¤„ç†
    hostInsert(
      (n2.el = hostCreateText(n2.children as string)),
      container,
      anchor
    );
  } else {
    // has old vnode, need to diff
  }
};

// hostInert -> å°† child insert åˆ° container.children ä¸­å»
// hostCreateText -> åˆ›å»º TEXT ç±»å‹çš„èŠ‚ç‚¹ç»“æ„
// runtime-test/src/nodeOps.ts -> createText
const node: TestText = {
  id: nodeId++,
  type: NodeTypes.TEXT,
  text,
  parentNode: null,
};

// processElement -> mountElement å¢åŠ  ARRAY_CHILDREN
// åˆ†æ”¯å¤„ç†ï¼Œ mountChildren
/* else */ if (shapeFlag & ShapeFlags.ARRAY_CHILDREN) {
  mountChildren(
    vnode.children as VNodeArrayChildren,
    el,
    null,
    parentComponent,
    parentSuspense,
    isSVG && type !== "foreignObject",
    optimized || !!vnode.dynamicChildren
  );
}

// mountChildren éå† vnode.children
// é€’å½’è°ƒç”¨ patch() å¤„ç†æ¯ä¸ª child
// cloneIfMounted æ˜¯éœ€è¦ä¼˜åŒ–(é™æ€æå‡çš„èŠ‚ç‚¹)ï¼Œå¯å¤ç”¨çš„èŠ‚ç‚¹
// å°†å…¶ clone å‡ºä¸€ä»½æ–°çš„ vnode å‡ºæ¥ä½¿ç”¨
// normailizeVNode æ˜¯æ ¹æ® child çš„æ•°æ®ç±»å‹ä¸åŒæ‰§è¡Œ createVNode è¿”å›
// æ–°çš„ vnode æˆ– child æœ¬èº«(vnode.el å­˜åœ¨çš„æƒ…å†µï¼Œè¢«å¤ç”¨äº†)
const mountChildren: MountChildrenFn = (
  children,
  container,
  anchor,
  parentComponent,
  parentSuspense,
  isSVG,
  optimized,
  start = 0
) => {
  for (let i = start; i < children.length; i++) {
    const child = (children[i] = optimized
      ? // è¿™é‡Œæ˜¯æ£€æµ‹ child.el æ˜¯ä¸æ˜¯å­˜åœ¨ï¼Œå¦‚æœå­˜åœ¨åˆ™æ˜¯å¯æœç”¨çš„ vnode
        // å³éœ€è¦æå‡çš„é™æ€èŠ‚ç‚¹ï¼Œåˆ™éœ€è¦è¿›è¡Œ cloneVNode ä¹‹åè¿”å›
        // æ–°çš„ vnode å¯¹è±¡
        cloneIfMounted(children[i] as VNode)
      : // æ ¹æ® child çš„ç±»å‹è¿›è¡Œæ‹†åˆ†å¤„ç†
        // 1. boolean, åˆ›å»ºä¸€ä¸ªç©ºçš„ Comment
        // 2. array, ä½¿ç”¨ Fragment å°† child åŒ…èµ·æ¥
        // 3. object, å¦‚æœæ˜¯å¯¹è±¡ï¼Œchild.el å­˜åœ¨ä¸å¦è¿›è¡Œ clone
        // 4. å…¶ä»–æƒ…å†µï¼Œå­—ç¬¦ä¸²æˆ–æ•°å­—ï¼Œå½“åš Text ç±»å‹å¤„ç†
        normalizeVNode(children[i]));
    // ç„¶åè¿›å…¥ patch é€’å½’å¤„ç† children
    patch(
      null,
      child,
      container,
      anchor,
      parentComponent,
      parentSuspense,
      isSVG,
      optimized
    );
  }
};

// cloneIfMounted æ˜¯æ£€æµ‹ vnode.el æ˜¯ä¸æ˜¯å­˜åœ¨ï¼Œå¦‚æœå­˜åœ¨è¯´æ˜æœ‰å¤ç”¨çš„æƒ…å†µ
// é’ˆå¯¹ template-compiled render fns åšçš„ä¼˜åŒ–
export function cloneIfMounted(child: VNode): VNode {
  // child.el å¦‚æœå­˜åœ¨çš„è¯ï¼Œchild å±äºé™æ€èŠ‚ç‚¹ä¼šè¢«é™æ€æå‡
  // æ‰€ä»¥éœ€è¦ clone ä¸€ä»½å‡ºæ¥ï¼Œå¦åˆ™ç›´æ¥è¿”å› child
  return child.el === null ? child : cloneVNode(child);
}
#+end_src
** children+props æ··åˆæµ‹è¯•

#+begin_src js
const { log, f, runtime_test } = require(process.env.BLOG_DIR_VUE + "/lib.js");
import(process.env.BLOG_DIR_VUE + "/runtime-test.global.js").then(
  ({ h, render, nodeOps, serializeInner: inner }) => {
    const root = nodeOps.createElement("div");
    render(h("div", { id: "foo", class: 'baz' }, ["bar", ' ', h('div')]), root);
    log(inner(root));
  },
  (err) => {
    console.log(err.message);
  }
);
#+end_src

#+RESULTS:
#+begin_example
undefinedfalse
render.......
patching...
{ type: 'div', shapeFlag: 17 }
xxxx
case default...
process element...
mount element...
mountElment else...
patching...
{ type: Symbol(Text), shapeFlag: 8 }
process text...
patching...
{ type: Symbol(Text), shapeFlag: 8 }
process text...
patching...
{ type: 'div', shapeFlag: 1 }
xxxx
case default...
process element...
mount element...
mountElment else...
<div id="foo" class="baz">bar <div></div></div>
#+end_example
** å°ç»“

æ‰§è¡Œæµç¨‹ï¼š

~render()~ -> ~vnode !== null~ -> ~patch()~ -> ~switch case~ ->

~default: processElement()~ -> ç”±äºæ˜¯é¦–æ¬¡åŠ è½½ old vnode ä¸º null ->

æ‰€ä»¥æ‰§è¡Œ ~mountElement()~ æ–°åˆ›å»ºå…ƒç´ è¿›è¡Œ mount æ“ä½œã€‚

~mountElement()~ é‡Œé¢åŒºåˆ†æ˜¯å¦æ˜¯å¯å¤ç”¨ç»„ä»¶(HOISTED, é™æ€æå‡çš„ç»„ä»¶)ï¼Œé€šè¿‡æ£€æµ‹
vnode.el æ˜¯å¦æœ‰å€¼ï¼Œå› ä¸ºå¦‚æœæ›¾ç»è¢«ä½¿ç”¨è¿‡å¿…å®šä¼šè¿›å…¥ mountElement -> else å¯¹
vnode.el è¿›è¡Œèµ‹å€¼æ“ä½œã€‚

å¦‚æœæ˜¯å¯å¤ç”¨çš„ç»„ä»¶ï¼Œç›´æ¥ clone ä¸€ä»½æ–°çš„ vnode å‡ºæ¥ä½¿ç”¨ï¼Œå¦åˆ™è¿›å…¥ else åˆ†æ”¯
~createElement~ åˆ›å»ºæ–°çš„èŠ‚ç‚¹ ~el = vnode.el = hostCreateElement(...)~ ã€‚

åœ¨ ~mountElement~ ä¸­ä¼˜å…ˆå¯¹ children è¿›è¡Œ mountï¼Œç„¶åå¤„ç† props ï¼Œå› ä¸ºæœ‰äº›æ—¶å€™
props éœ€è¦ä¾èµ– children æ˜¯ä¸æ˜¯åŠ è½½å®Œæˆäº†ï¼Œæ¯”å¦‚: ~<option value>~ å…ƒç´ ï¼Œéœ€è¦æ ¹æ®
~value~ æœ€ç»ˆçš„å€¼é€‰æ‹©ä½¿ç”¨å“ªä¸ª child(å‰ææ˜¯è¿™ä¸ª child å¿…é¡»å·²ç»åŠ è½½å®Œæˆäº†) ã€‚

children çš„å¤„ç†ï¼Œæœ‰ä¸¤ä¸ªç±»å‹åˆ†æ”¯å¤„ç†(~TEXT_CHILDREN~ å’Œ ~ARRAY_CHILDREN~)ï¼Œä¸ºä»€ä¹ˆ
åªæœ‰ä¸¤ä¸ªå‘¢ï¼Ÿ

è¿™æ˜¯å› ä¸ºåœ¨ ~createVNode()~ å‡½æ•°ä¸­ä¼šè°ƒç”¨ ~normalizeChildren()~ å¯¹ ~children~ è¿›è¡Œ
æ£€æµ‹ï¼Œåˆ†å‡ ç§æƒ…å†µå¤„ç†ï¼š

| children ç±»å‹        | type(~ShapeFlags~) | æè¿°                               |
|----------------------+--------------------+------------------------------------|
| ~Array~              | ~ARRAY_CHILDREN~   | -                                  |
| ~Object~             | ~SLOTS_CHILDREN~   | åŒºåˆ†æ˜¯ ELEMENT/TELEPORT æˆ–å…¶ä»–ç±»å‹ |
| ~Function~           | ~SLOTS_CHILDREN~   | å‡½æ•°ç›´æ¥å½“åšæ’æ§½å¤„ç†               |
| ~String~ æˆ– ~Number~ | ~TEXT_CHILDREN~    | å½“åšæ–‡æœ¬å¤„ç†                       |
|                      |                    |                                    |

ä¸Šé¢æœ‰ä¸ªæ’æ§½ç±»å‹ï¼Œè¿˜è®°å¾— compiler-core é‡Œé¢å¯¹æ’æ§½çš„ç¼–è¯‘ç»“æœå—ï¼Ÿ

[[/vue/vue-mind-map-compiler-core-transform-generate/#v-slot][compiler-core é˜¶æ®µå¯¹ slotæ ‡ç­¾å’Œ v-slot çš„è§£ææºç åˆ†æ ->]]

å¤§è‡´è§£æç»“æœå°±æ˜¯ç»„ä»¶å†…çš„æ‰€æœ‰å…ƒç´ æŒ‰ç…§ä¸€å®šçš„è§„åˆ™è§£ææˆæ’æ§½ï¼Œæœ€åç”Ÿæˆçš„ render å‡½æ•°
å¤§æ¦‚æ˜¯ï¼š

#+begin_src js
return (_openBlock(), _createBlock('Comp', null /* props */, {
  // é»˜è®¤æ’æ§½
  defualt: _withCtx(() => [ /* ...slot children... */ ]),
  [named]: _withCtx(() => [/* åŠ¨æ€å…·åæ’æ§½ */]),
  name: _withCtx(() => [/* å…·åæ’æ§½ */]),
}))
#+end_src

æ‰€ä»¥å½“ children æ˜¯ä¸ªå¯¹è±¡çš„æ—¶å€™åœ¨ ~createVNode()~ -> ~normalizeChildren()~ ä¸­ä¼šè¢«
å½“åšæ’æ§½æ¥å¤„ç†ã€‚

* patchElement
:PROPERTIES:
:COLUMNS: %CUSTOM_ID[(Custom Id)]
:CUSTOM_ID: fn-patchElement
:END:

~render()~ -> ~patch()~ -> ~processElement()~ ->

å½“æ£€æµ‹åˆ° old vnode å­˜åœ¨çš„æ—¶å€™ä¼šè¿›å…¥åˆ°è¿™ä¸ªå‡½æ•° ~patchElement()~ è¿›è¡Œæ›´æ–°æ“ä½œã€‚

#+begin_src typescript
const patchElement = (
    n1: VNode,
    n2: VNode,
    parentComponent: ComponentInternalInstance | null,
    parentSuspense: SuspenseBoundary | null,
    isSVG: boolean,
    optimized: boolean
  ) => {
    // æ—§çš„ el æ›¿æ¢æ‰æ–°çš„ el ?
    // const el = (n2.el = n1.el!)
    let { patchFlag, dynamicChildren } = n2
    // #1426 take the old vnode's patch flag into account since user may clone a
    // compiler-generated vnode, which de-opts to FULL_PROPS
    patchFlag |= n1.patchFlag & PatchFlags.FULL_PROPS
    // const oldProps = n1.props || EMPTY_OBJ
    // const newProps = n2.props || EMPTY_OBJ

    // TODO before update hooks

    // TODO dirs, æŒ‡ä»¤å¤„ç†

    // TODO HRM updating

    if (patchFlag > 0) {
      console.log(`patch flag > 0 ? ${patchFlag}`)
    } else if (!optimized && dynamicChildren == null) {
      console.log({ optimized, patchFlag })
    }

    // const areaChildrenSVG = isSVG && n2.type !== 'foreignObject'

    if (dynamicChildren) {
      console.log('dynamic children...')
    } else if (!optimized) {
      console.log('optimized null, éå¯å¤ç”¨èŠ‚ç‚¹')
    }

    // TODO vnode hook or dirs å¤„ç†
  }
#+end_src
å…ˆåšä¸ªæµ‹è¯•ï¼Œçœ‹ä¸‹ä»£ç æ‰§è¡Œæµç¨‹(~patchElement()~ é‡Œé¢åŠ äº†ç‚¹æ‰“å°)ï¼š

#+begin_src js
const { log, f, shuffle, toSpan: _toSpan, runtime_test } = require(process.env
  .BLOG_DIR_VUE + "/lib.js");
import(process.env.BLOG_DIR_VUE + "/runtime-test.global.js").then(
  ({ h, render, nodeOps, serializeInner: inner }) => {
    let elm
    let root = nodeOps.createElement("div");
    const toSpan = (v) => _toSpan(v, h);
    const renderChildren = (arr) => {
      // ç»™ root>div ä¸­æ’å…¥ children
      // <div><span>1</span>...</div>
      render(h("div", arr.map(toSpan)), root);
      return root.children[0];
    };
    // root ä¸ŠæŒ‚ä¸€ä¸ª '<div id="1">hello</div>'
    render(h("div", { id: 1 }, "hello"), root);

    // å¢åŠ ä¸€ä¸ª <span>1</span>
    elm = renderChildren([1])

    log(`elm.children.length = ${elm.children.length}`)
  },
  (err) => {
    console.log(err.message);
  }
);
#+end_src

#+RESULTS:
#+begin_example
undefinedfalse
render()...
patch()...
processElement()...
mountElement()...
mountElment else...
render()...
patch()...
processElement()...
patchElement()...
{ optimized: false, patchFlag: 0 }
optimized null, éå¯å¤ç”¨èŠ‚ç‚¹
patchChildren()...
patchChildren, é text children
patchChildren, é text children, é array children...
elm.children.length = 1
#+end_example

ä»ä¸Šé¢çš„ç»“æœå¯çŸ¥æˆ‘ä»¬è¯¥é˜¶æ®µéœ€è¦å®ç°çš„éƒ¨åˆ†ä»£ç ä¸ºï¼š

#+begin_src typescript
// patchElement()
// è¿™é‡Œæ˜¯ props å¤„ç†
/* else */ if (!optimized && dynamicChildren == null) {
  console.log({ optimized, patchFlag });
  // TODO patchProps
}

// å’Œ
/* else */ if (!optimized) {
  console.log("optimized null, éå¯å¤ç”¨èŠ‚ç‚¹");
}

// patchChildren()
/* else */ {
  console.log("patchChildren, old é text children");

  /* else */ {
    console.log(
      "patchChildren, old é text children, new é array children..."
    );
    // prev children was text or null
    // new children is array or null
    // è€çš„ children æ˜¯ textï¼Œæ–°çš„åˆæ˜¯æ•°ç»„æƒ…å†µ
    if (prevShapeFlag & ShapeFlags.TEXT_CHILDREN) {
      // å…ˆæ¸…ç©ºï¼Ÿ
      hostSetElementText(container, "");
    }
    // ç„¶åç›´æ¥é‡æ–°åŠ è½½æ–°çš„ array children -> c2
    // old children æ˜¯ array
    if (shapeFlag & ShapeFlags.ARRAY_CHILDREN) {
      mountChildren(
        c2 as VNodeArrayChildren,
        container,
        anchor,
        parentComponent,
        parentSuspense,
        isSVG,
        optimized
      );
    }
  }
}
#+end_src

é‡æ–°æµ‹è¯•ï¼š
#+begin_src js
const { log, f, shuffle, toSpan: _toSpan, runtime_test } = require(process.env
  .BLOG_DIR_VUE + "/lib.js");
import(process.env.BLOG_DIR_VUE + "/runtime-test.global.js").then(
  ({ h, render, nodeOps, serializeInner: inner }) => {
    let elm
    let root = nodeOps.createElement("div");
    const toSpan = (v) => _toSpan(v, h);
    const renderChildren = (arr) => {
      // ç»™ root>div ä¸­æ’å…¥ children
      // <div><span>1</span>...</div>
      render(h("div", arr.map(toSpan)), root);
      return root.children[0];
    };
    // root ä¸ŠæŒ‚ä¸€ä¸ª '<div id="1">hello</div>'
    render(h("div", { id: 1 }, "hello"), root);

    // å¢åŠ ä¸€ä¸ª <span>1</span>
    elm = renderChildren([1])

    log(`elm.children.length = ${elm.children.length}`)
  },
  (err) => {
    console.log(err.message);
  }
);
#+end_src

#+RESULTS:
#+begin_example
undefinedfalse
render()...
patch()...
processElement()...
mountElement()...
mountElment else...
render()...
patch()...
processElement()...
patchElement()...
{ optimized: false, patchFlag: 0 }
optimized null, éå¯å¤ç”¨èŠ‚ç‚¹
patchChildren()...
patchChildren, old é text children
patchChildren, old é text children, new é array children...
patch()...
processElement()...
mountElement()...
mountElment else...
elm.children.length = 1
#+end_example

å› æ­¤åˆ°è¿™é‡Œå°†ä¼šè¿›å…¥ patchChildren(n1, n2, ...) å»è§£æ ~"hello"~ è¿™ä¸ªæ–‡æœ¬å­©å­èŠ‚ç‚¹ã€‚

[[https://github.com/gcclll/stb-vue-next/commit/26d2bfdcdcfa74e16581f3a1e51439a9522e1d0e][feat(add): patchElement->patchChildren Â· gcclll/stb-vue-next@26d2bfd]]

* patchChildren(n1,n2,...)
:PROPERTIES:
:COLUMNS: %CUSTOM_ID[(Custom Id)]
:CUSTOM_ID: fn-patchChildren
:END:

[[/img/vue3/runtime-core/vue-runtime-core-renderer-patchChildren.jpg]]

ç®€åŒ–ä»£ç ï¼š

#+begin_src typescript
const patchChildren: PatchChildrenFn = (n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, optimized = false) {
  if (patchFlag > 0) {
    if (patchFlag & PatchFlags.KEYED_FRAGMENT) {
      // é’ˆå¯¹æœ‰ key å±æ€§è¢« fragment åŒ…è£¹èµ·æ¥çš„å…ƒç´ (ä¾‹å¦‚ï¼š v-for)
      // ... patchKeyedChildren(...)
      return
    } else if (patchFlag & PatchFlags.UNKEYED_FRAGMENT) {
      // ... patchUnkeyedChildren(...)
      return
    }
  }

  // children æœ‰ä¸‰ç§å¯èƒ½ï¼Œtext, array, æˆ–æ²¡æœ‰å­©å­èŠ‚ç‚¹
  if (shapeFlag & ShapeFlags.TEXT_CHILDREN) {
    // text children
    if (prevShapeFlag & ShapeFlags.ARRAY_CHILDREN) {
      // å¦‚æœæ˜¯æ•°ç»„ï¼Œç›´æ¥ unmount æ‰
      // unmountChildren(c1, ...)
    }
    if (c2 !== c1) {
      // hostSetElementText(container, c2) ç›´æ¥æ›¿æ¢æ–‡æœ¬
    }
  } else {
    // éæ–‡æœ¬èŠ‚ç‚¹å¤„ç†
    if (prevShapeFlag & ShapeFlags.ARRAY_CHILDREN)  {
      // ä¹‹å‰çš„ children æ˜¯ æ•°ç»„ç±»å‹
      if (shapeFlag & shapeFlag.ARRAY_CHILDREN) {
        // æ–°çš„ä¹Ÿæ˜¯æ•°ç»„ï¼Œç›´æ¥è¿›è¡Œ full diff
        // patchKeyedChildren(...)
      } else {
        // åˆ°è¿™é‡Œè¡¨ç¤ºæ²¡æœ‰æ–°çš„å­©å­èŠ‚ç‚¹ï¼Œç­‰ä»·äºåˆ é™¤æ“ä½œï¼Œç›´æ¥å¸è½½è€çš„å°±è¡Œ
        // unmountChildren(c1, ...)
      }
    } else {
      // è¿™ç§æƒ…å†µï¼Œold æ˜¯ text | null
      // æ–°çš„æ˜¯æ•°ç»„æˆ– null
      if (prevShapeFlag & ShapeFlags.TEXT_CHILDREN){
        // å…ˆæ¸…ç©ºè€çš„æ–‡æœ¬èŠ‚ç‚¹
        // hostSetElementText(container, '')
      }

      // å¦‚æœæ–°çš„æ˜¯æ•°ç»„ï¼Œç›´æ¥ mountï¼Œå› ä¸ºä¹‹å‰çš„å¦‚æœæ˜¯æ–‡æœ¬åœ¨ä¸Šé¢å·²ç»æ¸…ç©ºäº†
      if (shapeFlag & ShapeFlags.ARRAY_CHILDREN) {
        // mountChildren(c2, container, ...)
      }
    }
  }
}
#+end_src

æ‰€ä»¥æ€»ç»“ä¸‹æ¥æœ‰å‡ ç§æƒ…å†µçš„ç»„åˆï¼š

1. é¦–å…ˆæ˜¯ patchFlag > 0 æƒ…å†µï¼Œéœ€è¦å±€éƒ¨ diff update(æ¯”å¦‚ï¼š v-for)ï¼Œè¿™é‡Œéœ€è¦åŒºåˆ†æ˜¯
   å¦æœ‰ key å±æ€§

   1) keyed: [[#fn-patchKeyedChildren][patchKeyedChildren(c1, c2, ...)]]

   2) unkeyed: [[#fn-patchUnkeyedChildren][patchUnkeyedChildren(c1, c2, ...)]]

2. åˆ°è¿™é‡Œ patchFlag <= 0 ï¼Œéœ€è¦è¿›è¡Œ full diff çš„æƒ…å†µ

   è¿™ç§æƒ…å†µä¸‹åªæœ‰ä¸‰ç§å¯èƒ½çš„ children: ~text|array|null~

   è¿™ä¸‰ç§æƒ…å†µç»“åˆ old + new æœ‰å¤šé‡ç»„åˆéœ€è¦è€ƒè™‘ã€‚

   1) new text + old array: ç›´æ¥å¸è½½ old array, å°† parent å†…å®¹è®¾ç½®æˆ new text

   2) new array + old array: å½“åš keyed children è°ƒç”¨ [[#fn-patchKeyedChildren][patchKeyedChildren(c1, c2,
      ...)]] å¤„ç†

   3) new null + old array: ç›´æ¥å¸è½½ old array([[#fn-unmountChildren][unmountChildren(c1, ...)]])

   4) new array + old null: ç›´æ¥ mount new array([[#fn-mountChildren][mountChildren(c2, ...)]])


è¿™é‡Œæ¶‰åŠåˆ°å‡ ä¸ªç›¸å…³å‡½æ•°ï¼š

[[#fn-patchKeyedChildren][patchKeyedChildren(c1, c2, container, parentAnchor, parentComponent,
parentSuspense, isSVG, optimized)]]

[[#fn-patchUnkeyedChildren][patchUnkeyedChildren(c1, c2, container, parentAnchor, parentComponent,
parentSuspense, isSVG, optimized)]]

[[#fn-unmountChildren][unmountChildren(children, parentComponent, parentSuspense, doRemove, optimized, start)]]

[[#fn-mountChildren][mountChildren(children, container, anchor, parentComponent, parentSuspense,
isSVG, optimized, start)]]

æ ¹æ®ä¸Šé¢çš„åˆ†æï¼Œä¼šé€ä¸€å®ç°å„ç§æƒ…å†µã€‚

#+begin_src dot :file ../../static/img/tmp/jIpIofqUV448p8A.png
digraph G{
    rankdir=LR;
	  node[shape=box, style=filled, color=".7.3 1.0"];//ä¸€ä¸ªnodeçš„å±æ€§
	  size = "6, 4";//å›¾ç‰‡å¤§å°
    patch->processElement
    processElement->n1[label="èŠ‚ç‚¹å·²å­˜åœ¨?"]
    n1[shape=diamond];
    n1->mountElement[label="no"]
    n1->patchElement[label="yes"]
    mountElement->patch[style=dotted, color = red]
}
#+end_src

#+RESULTS:
[[/img/tmp/jIpIofqUV448p8A.png]]

** new text + old array

[[https://github.com/gcclll/stb-vue-next/commit/7019c9d52f59411cd8532da7e38eaee78db22410][feat(add): new text + old array Â· gcclll/stb-vue-next@7019c9d]]

patchChildren: å…ˆ unmountChildren(c1) -> hostSetElementText(container, c2)
#+begin_src typescript
// children æœ‰ä¸‰ç§å¯èƒ½ï¼š text, array, æˆ–æ²¡æœ‰ children
if (shapeFlag & ShapeFlags.TEXT_CHILDREN) {
  console.log("patchChildren, new text...");
  // text children fast path
  if (prevShapeFlag & ShapeFlags.ARRAY_CHILDREN) {
    unmountChildren(c1 as VNode[], parentComponent, parentSuspense);
  }

  if (c2 !== c1) {
    hostSetElementText(container, c2 as string);
  }
}
#+end_src

unmountChildren(...) -> éå† children è°ƒç”¨ unmount(children[i], ..)

unmount(vnode, ...) ä¸­é€’å½’è°ƒç”¨ unmountChildren(children, ...)

ä½†æ˜¯è¿™éƒ¨åˆ†é€»è¾‘è‡ªå§‹è‡³ç»ˆ doRemove éƒ½æ˜¯ falseï¼Œæ‰€ä»¥ä¸ä¼šæ‰§è¡Œ doRemove: remove(vnode)ï¼Œ
å› ä¸ºå¦‚ä¸Šé¢çš„ä»£ç ï¼Œåœ¨ c1 !== c2 çš„æ—¶å€™æ‰§è¡Œäº† [[/vue/vue-mind-map-runtime-core/#runtime-test][hostSetElementText(container, c2)]]è¿™
é‡Œé¢é¦–å…ˆä¼šç›´æ¥æ¸…ç©º ~container.children~ ç„¶åé‡æ–°èµ‹å€¼ï¼Œå› æ­¤ remove(vnode) æ²¡æœ‰æ‰§
è¡Œä¹Ÿä¼šå®ç°ç›´æ¥æ›¿æ¢æ“ä½œï¼Œè¿™é‡Œå±äº full diffã€‚

æµ‹è¯•:
#+begin_src js
const { log, f, shuffle, runtime_test } = require(process.env
  .BLOG_DIR_VUE + "/lib.js");
import(process.env.BLOG_DIR_VUE + "/runtime-test.global.js").then(
  ({ h, render, nodeOps, serializeInner: inner }) => {
    let elm
    let root = nodeOps.createElement("div");

    // root ä¸ŠæŒ‚ä¸€ä¸ª
    // '<div id="1"><span>1</span><span>2</span></div>'
    render(h("div", { id: 1 }, [ // #1
      h('span', '1'),
      h('span', '2')
    ]), root);

    // å¢åŠ ä¸€ä¸ª <span>1</span>
    log(['1. div children length = ', root.children[0].children.length])

    render(h('div', { id: 1 }, 'hello'), root) // #2
    log(['2. div children length = ', root.children[0].children.length])
  },
  (err) => {
    console.log(err.message);
  }
);
#+end_src

#+RESULTS:
#+begin_example
undefinedfalse
render()...
patch()...
processElement()...
mountElement()...
mountElment else...
patch()...
processElement()...
mountElement()...
mountElment else...
patch()...
processElement()...
mountElement()...
mountElment else...
1. div children length =  2
render()...
patch()...
processElement()...
patchElement()...
{ optimized: false, patchFlag: 0 }
optimized null, éå¯å¤ç”¨èŠ‚ç‚¹
patchChildren()...
patchChildren, new text...
2. div children length =  1
#+end_example

å¦‚ä¸Šç»“æœï¼Œæœ€å¼€å§‹æœ‰ä¸‰ä¸ªé€’å½’ï¼š

patch() -> processElement() -> mountElement() -> patch()

#+begin_src dot :file ../../static/img/tmp/J0XD2pb6FUK5Rs8.png
digraph G{
        rankdir=LR;
	size = "6, 4";//å›¾ç‰‡å¤§å°
	node[shape = box, style = filled, color = ".7.3 1.0"];//ä¸€ä¸ªnodeçš„å±æ€§
    patch->processElement;
    processElement->mountElement;
    mountElement->patch[style = dotted, color = red]
}
#+end_src

#+RESULTS:
[[/img/tmp/J0XD2pb6FUK5Rs8.png]]

*#1* æ¸²æŸ“è¿‡ç¨‹ä¸­ï¼Œåˆ†åˆ«å¤„ç† ~div -> span 1 -> span 2~ ã€‚

*#2* æ¸²æŸ“è¿‡ç¨‹ä¸­ï¼Œå±äº full diff æ“ä½œï¼Œæ£€æµ‹åˆ° old array, new textï¼Œæ‰€ä»¥ç›´æ¥æ¸…ç©º
  äº† ~div.children~ï¼Œç„¶åå¤åˆ¶ ~div.children = [text node]~
** new null + old array

[[https://github.com/gcclll/stb-vue-next/commit/3f45ac50d6123a1ae1abbd5af218de67689bb943][feat(add): patchChildren -> patch new null, old array Â·
gcclll/stb-vue-next@3f45ac5]]

æ–°å¢ä»£ç ï¼š

#+begin_src typescript
if (prevShapeFlag & ShapeFlags.ARRAY_CHILDREN) {
  if (shapeFlag & ShapeFlags.ARRAY_CHILDREN) {
    console.log("patchChildren, new array, old array...");
    // TODO patchKeyedChildren
  } else {
    // new null, old array ç›´æ¥å¸è½½ old
    unmountChildren(
      c1 as VNode[],
      parentComponent,
      parentSuspense,
      true /* doRemove */
    );
  }
}
#+end_src

å¦‚æœ new null ç›´æ¥å¸è½½ old array å°±å¥½äº†ï¼Œæ³¨æ„ç¬¬å››ä¸ªå‚æ•°ä¼ çš„æ˜¯ ~doRemove:true~ è¿™
æ · ~unmount()~ é‡Œé¢å°±ä¼šå»è°ƒç”¨ ~remove()~

æµ‹è¯•:

#+begin_src js
const { log, f, shuffle, runtime_test } = require(process.env
  .BLOG_DIR_VUE + "/lib.js");
import(process.env.BLOG_DIR_VUE + "/runtime-test.global.js").then(
  ({ h, render, nodeOps, serializeInner: inner }) => {
    let elm
    let root = nodeOps.createElement("div");

    // root ä¸ŠæŒ‚ä¸€ä¸ª
    // '<div id="1"><span>1</span><span>2</span></div>'
    render(h("div", { id: 1 }, [ // #1
      h('span', '1'),
      h('span', '2')
    ]), root);

    // å¢åŠ ä¸€ä¸ª <span>1</span>
    log(['1. div children length = ', root.children[0].children.length])

    render(h('div', { id: 1 }, null), root) // #2
    
    log(['2. div children length = ', root.children[0].children.length])
  },
  (err) => {
    console.log(err.message);
  }
);
#+end_src

#+RESULTS:
#+begin_example
undefinedfalse
render()...
patch()...
processElement()...
mountElement()...
mountElment else...
patch()...
processElement()...
mountElement()...
mountElment else...
patch()...
processElement()...
mountElement()...
mountElment else...
1. div children length =  2
render()...
patch()...
processElement()...
patchElement()...
{ optimized: false, patchFlag: 0 }
optimized null, éå¯å¤ç”¨èŠ‚ç‚¹
patchChildren()...
patchChildren, new not text...
patchChildren, new null, old array...
2. div children length =  0
#+end_example

#+begin_src dot :file ../../static/img/tmp/I666vpKZVdkMluo.svg
digraph G{
    rankdir=LR;
	size = "6, 4";//å›¾ç‰‡å¤§å°
	node[shape = box, style = filled, color = ".7.3 1.0"];//ä¸€ä¸ªnodeçš„å±æ€§
    render2,render1[shape=circle,fillcolor=red]
    render1->patch[label="two span"];
    patch->processElement;
    processElement->mountElement[label="èŠ‚ç‚¹ä¸å­˜åœ¨"];
    processElement->patchElement[label="èŠ‚ç‚¹å­˜åœ¨",color="blue"];
    mountElement->patch[style=dotted, color=red]
    render2->patch[label="null",color="blue"];
    patchElement->patchChildren[color="blue"];
    patchChildren->unmountChildren[label="new null",color="blue"]
    
}
#+end_src

#+RESULTS:
[[/img/tmp/I666vpKZVdkMluo.svg]]
** new array + old null/text

è¿™ç§æƒ…å†µï¼Œå¦‚æœæ˜¯ old textï¼Œä¼šå…ˆæ‰§è¡Œ
#+begin_src typescript
if (prevShapeFlag & ShapeFlags.TEXT_CHILDREN) {
  hostSetElementText(container, "");
}
#+end_src

å°† conteiner.children æ¸…ç©ºã€‚

ç„¶åæ‰§è¡Œ ~mountChidren(c2)~ æ’å…¥æ–°çš„ array node ã€‚

#+begin_src typescript
// prev children was text OR null
// new children is array OR null
if (prevShapeFlag & ShapeFlags.TEXT_CHILDREN) {
  hostSetElementText(container, "");
}
// mount new if array
if (shapeFlag & ShapeFlags.ARRAY_CHILDREN) {
  mountChildren(
    c2 as VNodeArrayChildren,
    container,
    anchor,
    parentComponent,
    parentSuspense,
    isSVG,
    optimized
  );
}
#+end_src

æµ‹è¯•ï¼š

#+begin_src js
const { log, f, shuffle, runtime_test } = require(process.env
  .BLOG_DIR_VUE + "/lib.js");
import(process.env.BLOG_DIR_VUE + "/runtime-test.global.js").then(
  ({ h, render, nodeOps, serializeInner: inner }) => {
    let elm
    let root = nodeOps.createElement("div");

    // root ä¸ŠæŒ‚ä¸€ä¸ª
    // '<div id="1"><span>1</span><span>2</span></div>'
    render(h("div", { id: 1 }, null), root);

    // å¢åŠ ä¸€ä¸ª <span>1</span>
    log(['1. div children length = ', root.children[0].children.length])

    render(h('div', { id: 1 }, [ // #1
      h('span', '1'),
      h('span', '2')
    ]), root) // #2

    log(['2. div children length = ', root.children[0].children.length])
  },
  (err) => {
    console.log(err.message);
  }
);
#+end_src

#+RESULTS:
#+begin_example
undefinedfalse
render()...
patch()...
processElement()...
mountElement()...
mountElment else...
1. div children length =  0
render()...
patch()...
processElement()...
patchElement()...
{ optimized: false, patchFlag: 0 }
optimized null, éå¯å¤ç”¨èŠ‚ç‚¹
patchChildren()...
patchChildren, new not text...
patchChildren, old text | null...
patchChildren, new array...
patch()...
processElement()...
mountElement()...
mountElment else...
patch()...
processElement()...
mountElement()...
mountElment else...
2. div children length =  2
#+end_example
** new array + old array
* patchKeyedChildren
:PROPERTIES:
:COLUMNS: %CUSTOM_ID[(Custom Id)]
:CUSTOM_ID: keyed-children
:END:

[[/img/vue3/runtime-core/vue-runtime-core-patch-keyed-children.jpg]]

[[https://github.com/gcclll/stb-vue-next/commit/4a6a1f2b59e938346f097ead660d68b3b2837323][feat(add): patchKeyedChildren Â· gcclll/stb-vue-next@4a6a1f2]]

ä»£ç ä¸­åˆ—å‡ºäº†å‡ ç§å¯èƒ½çš„æƒ…å†µï¼š

1. old, new nodes å¼€å¤´ç›¸åŒï¼Œä»å·¦åˆ°å³æ–¹å‘ä»¥ä¸åŒä½ç½®ä¸ºèµ·ç‚¹å¼€å§‹æ¯”è¾ƒ
2. old, new nodes ç»“å°¾ç›¸åŒï¼Œä»å³åˆ°å·¦æ–¹å‘ä»¥ä¸åŒä½ç½®ä¸ºèµ·ç‚¹å¼€å§‹æ¯”è¾ƒ
3. old âŠ‚ newï¼Œold ä¸º new çš„çœŸå­é›†ï¼Œè¿™ç§æƒ…å†µè§†ä¸ºæ–°å¢èŠ‚ç‚¹ï¼Œéœ€è¦å¯¹æ–°å¢çš„èŠ‚ç‚¹è¿›è¡Œ
   mount æ“ä½œ
4. old âŠƒ new , new ä¸º old çš„çœŸå­é›†ï¼Œè¿™ç§æƒ…å†µè§†ä¸ºåˆ é™¤èŠ‚ç‚¹ï¼Œéœ€è¦å¯¹å¤šä½™çš„èŠ‚ç‚¹è¿›è¡Œ
   unmount æ“ä½œ
5. old,new æ²¡æœ‰ç‰¹åˆ«æ˜æ˜¾çš„è§„å¾‹å¯éµå¾ªçš„ï¼Œå¤„ç†èµ·æ¥ä¼šæ¯”è¾ƒéº»çƒ¦

#+begin_src typescript
// 24. å¯èƒ½æ‰€æœ‰éƒ½æ˜¯ keyed ä¹Ÿå¯èƒ½éƒ¨åˆ†
const patchKeyedChildren = (
  c1: VNode[],
  c2: VNodeArrayChildren,
  container: RendererElement,
  parentAnchor: RendererNode | null,
  parentComponent: ComponentInternalInstance | null,
  parentSuspense: SuspenseBoundary | null,
  isSVG: boolean,
  optimized: boolean
) => {
  let i = 0;
  const l2 = c2.length;
  let e1 = c1.length - 1; // ä¸Šä¸€ä¸ªç»“æŸç´¢å¼•
  let e2 = l2 - 1; // ä¸‹ä¸€ä¸ªç»“æŸç´¢å¼•

  // 1. sync from start
  // (a b) c
  // (a b) d e
  while (i <= e1 && i <= e2) {
    // TODO
  }

  // 2. sync from end
  // a (b c)
  // d e (b c)
  while (i <= e1 && i <= e2) {
    // TODO
  }

  // 3. common sequence + mount
  // (a b)
  // (a b) c
  // i = 2, e1 = 1, e2 = 2
  // (a b)
  // c (a b)
  // i = 0, e1 = -1, e2 = 0
  if (i > e1) {
    // TODO
  }

  // 4. common sequence + unmount
  // (a b) c
  // (a b)
  // i = 2, e1 = 2, e2 = 1
  // a (b c)
  // (b c)
  // i = 0, e1 = 0, e2 = -1
  else if (i > e2) {
    // TODO
  }

  // 5. unknown sequence, æœªçŸ¥åºåˆ—
  // [i ... e1 + 1]: a b [c d e] f g
  // [i ... e2 + 1]: a b [e d c h] f g
  // i = 2, e1 = 4, e2 = 5
  else {
    // TODO
  }
};
#+end_src

ä¸‹é¢æ¥ä¸€ä¸ªä¸ªå®ç°ï¼Œæ­å¼€ diff -> patch çš„ç¥ç§˜é¢çº±ï¼ï¼ï¼

åœ¨è¿›è¡Œä¹‹å‰å…ˆçœ‹ä¸‹ä¸€ä¸ªå‡½æ•° ~isSameVNodeType(n1,n2)~ ï¼š

#+begin_src typescript
export function isSameVNodeType(n1: VNode, n2: VNode): boolean {
  if (
    __DEV__ &&
    n2.shapeFlag & ShapeFlags.COMPONENT &&
    hmrDirtyComponents.has(n2.type as ConcreteComponent)
  ) {
    // HMR only: if the component has been hot-updated, force a reload.
    // ç»„ä»¶è¢«çƒ­æ›´æ–°ï¼Œå¼ºåˆ¶é‡æ–°åŠ è½½
    return false
  }
  return n1.type === n2.type && n1.key === n2.key
}
#+end_src

è¿™ä¸ªå‡½æ•°ç”¨æ¥æ£€æµ‹ä¸¤ä¸ªèŠ‚ç‚¹æ˜¯ä¸æ˜¯ç±»ä¼¼èŠ‚ç‚¹(éœ€åŒæ—¶æ»¡è¶³ type å’Œ key ç›¸åŒ)ã€‚

#+begin_quote
æœ‰ç‚¹å¤æ‚ï¼Œæ•´çš„å¤´ç–¼ğŸ¤•ğŸ¤•ã€‚ã€‚ã€‚ä¼‘æ¯ä¼šğŸ˜´ğŸ˜´ï¼ï¼ï¼

[2021-02-24 18:16:56] é€šè¿‡ç”»å›¾ç»ˆäºæŠŠè¿™å—é€»è¾‘æå¾—æœ‰ç‚¹æ¸…æ¥šäº†ï¼ï¼ï¼
#+end_quote

å‰§æƒ…æœ‰ç‚¹å¤æ‚ï¼Œè¿˜æ˜¯æ ¹æ®å®˜æ–¹çš„æµ‹è¯•ç”¨ä¾‹æ¥é€æ­¥ç†Ÿæ‚‰å„ç§æƒ…å†µçš„ diff -> patch å§ã€‚

#+begin_quote
å£°æ˜ï¼š

1. æ‰€æœ‰ ~children [1,2,3]~ éƒ½å°†è‡ªèº«å€¼ä½œä¸ºèŠ‚ç‚¹çš„å±æ€§ key å€¼
2. ä¸‹é¢çš„æ‰€æœ‰ç”¨ä¾‹éƒ½åŸºäºèŠ‚ç‚¹æœ‰ ~key~ å±æ€§ä¸ºå‰æ
#+end_quote

[[https://github.com/gcclll/stb-vue-next/commit/b7edc1b0939f2faf88d1e939a749f31fabab99f2][fix: patchKeydChildren if Â· gcclll/stb-vue-next@b7edc1b]]


å¤§è‡´ç§»åŠ¨è§„åˆ™æµç¨‹å›¾ï¼š

[[/img/vue3/vue-router/vue-runtime-core-diff-move-rules.svg]]

** append([1] -> [1,2,3])

#+begin_src js
const { log, f, shuffle, runtime_test, renderChildren } = require(process.env
  .BLOG_DIR_VUE + "/lib.js");
import(process.env.BLOG_DIR_VUE + "/runtime-test.global.js").then(
  ({ h, render, nodeOps, serializeInner: inner }) => {
    let elm;
    let root = nodeOps.createElement("div");
    // <div>hello</div>
    render(h("div", { id: 1 }, "hello"), root);
    const rc = (arr) => renderChildren(render, root, h, arr);
    const logRoot = () => log("root: " + inner(root));

    logRoot();
    elm = rc([1]);
    log(">>> render [1] DONE.");
    logRoot();

    elm = rc([1, 2, 3]);
    log(">>> render [1,2,3] DONE.");
    logRoot();
  },
  (err) => {
    console.log(err.message);
  }
);
#+end_src

#+RESULTS:
: undefinedfalse
: root: <div id=1>hello</div>
: >>> render [1] DONE.
: root: <div id=1><span>1</span></div>
: patchKeyedChildren...
: while 1, sync from start...
: patch keyed æ–°å¢ ...
: >>> render [1,2,3] DONE.
: root: <div id=1><span>1</span><span>2</span><span>3</span></div>

å¦‚ä¸Šç»“æœï¼Œå½“æ‰§è¡Œ patchChildren çš„æ—¶å€™ï¼Œç”±äº old array ï¼Œ new array æ‰€ä»¥ä¼šæ‰§è¡Œ
~patchKeyedChildren~ å¯¹ä¸¤ä¸ª array è¿›è¡Œå¯¹æ¯”æ›´æ–°ã€‚

while 1: ä»å·¦åˆ°å³å¯¹åŒç±»å‹çš„ VNode è¿›è¡Œ patch ï¼Œæ‰€ä»¥è¿™é‡Œ ~1~ èŠ‚ç‚¹ä¼šåœ¨è¿™é‡Œè¢« patch
æ‰ ã€‚
#+begin_src typescript
while (i <= e1 && i <= e2) {
  console.log("while 1, sync from start...");
  const n1 = c1[i];
  const n2 = (c2[i] = optimized // é™æ€èŠ‚ç‚¹
    ? cloneIfMounted(c2[i] as VNode)
    : normalizeVNode(c2[i]));

  // type & key ç›¸åŒ
  if (isSameVNodeType(n1, n2)) {
    patch(
      n1,
      n2,
      container,
      null,
      parentComponent,
      parentSuspense,
      isSVG,
      optimized
    );
  } else {
    break;
  }
  i++;
}
#+end_src

ç„¶åï¼š ~i=1,e1=0,e2=2~ æ»¡è¶³ ~if(i>e1)~ æ–°å¢èŠ‚ç‚¹æ¡ä»¶ï¼Œå¯¹ ~[2,3]~ è¿›å…¥æ–°å¢èŠ‚ç‚¹é€»è¾‘
ä»£ç (~if~ åˆ†æ”¯)

#+begin_src typescript
if (i > e1) {
  console.log("patch keyed æ–°å¢ ...");
  if (i <= e2) {
    const nextPos = e2 + 1;
    const anchor = nextPos < l2 ? (c2[nextPos] as VNode).el : parentAnchor;
    while (i <= e2) {
      patch(
        null,
        (c2[i] = optimized
          ? cloneIfMounted(c2[i] as VNode)
          : normalizeVNode(c2[i])),
        container,
        anchor,
        parentComponent,
        parentSuspense,
        isSVG
      );
      i++;
    }
  }
}
#+end_src

é’ˆå¯¹ ~[2,3]~ åˆ†åˆ«æ‰§è¡Œï¼š

~patch(null, c2[i], container, anchor,...)~

æ³¨æ„è¿™é‡Œ ~anchor~ æ˜¯ ~[3]~ è¿™ä¸ªèŠ‚ç‚¹ï¼Œä½†æ˜¯ç”±äºåœ¨ ~container.children~ æ˜¯ä¸å­˜åœ¨çš„ï¼Œ
æ‰€ä»¥å¯¹äº ~[2]~ ä¼šæ‰§è¡Œ append æ“ä½œ(å…·ä½“è¯·æŸ¥çœ‹ [[https://github.com/vuejs/vue-next/blob/master/packages/runtime-test/src/nodeOps.ts][runtime-test/src/nodeOpts.ts:insert
å‡½æ•°å®ç°)]]ã€‚

ç›´åˆ°å…¨éƒ¨ append åˆ° ~container.children~ ç»“æŸã€‚

#+begin_quote
old: ~[1]~, new: ~[1,2,3]~

è¿™ç§æƒ…å†µè¿˜æ˜¯æ¯”è¾ƒç®€å•çš„ï¼Œç›´æ¥ append 2,3 å°±è¡Œäº†ã€‚
#+end_quote
** prepend([4,5]->[1,2,3,4,5])

å®ä¾‹åˆ†æï¼š ~n1=[4,5], n2=[1,2,3,4,5]~ ç»è¿‡ while1 ä»€ä¹ˆéƒ½æ²¡åšï¼Œç»è¿‡ while2 åŒåŒ–æ‰
å°¾éƒ¨ ~[4,5],i=0,e1=-1,e2=2=~ æ»¡è¶³ ~if(i>e1)&&if(i<e2)~ å±äºæ–°å¢èŠ‚ç‚¹æ“ä½œï¼Œæ’å…¥æ—¶
çš„å‚è€ƒèŠ‚ç‚¹ä¸º ~c2[e2+1]~ ï¼Œä¹‹å‰åˆ†æè¿‡å¦‚æœéœ€è¦ç»è¿‡å‰ä¸¤ä¸ª while å¤„ç†çš„èŠ‚ç‚¹éƒ½ä¼šåœ¨
patch çš„è¿‡ç¨‹ä¸­ç›´æ¥æ›¿æ¢æ‰ï¼Œæ¯”å¦‚è¿™é‡Œçš„ ~[4,5]~ ä¼šåœ¨ while2 ä¸­è¢«æ›¿æ¢æ‰(ä½“ç°åœ¨
~container.children~ ä¸­)ï¼Œæ–°çš„ ~[4,5]~ æ›¿æ¢æ‰è€çš„ ~[4,5]~ ï¼Œæ‰€ä»¥è¿™é‡Œå‘ç”Ÿæ’å…¥æ—¶çš„
anchor å®é™…æ˜¯å¯¹åº” ~container.children~ ä¸­çš„ ~[4]~ ä½ç½®ã€‚

#+begin_src js
const { log, f, shuffle, runtime_test, renderChildren } = require(process.env
  .BLOG_DIR_VUE + "/lib.js");
import(process.env.BLOG_DIR_VUE + "/runtime-test.global.js").then(
  ({ h, render, nodeOps, serializeInner: inner }) => {
    let elm;
    let root = nodeOps.createElement("div");
    // <div>hello</div>
    render(h("div", { id: 1 }, "hello"), root);
    const rc = (arr) => renderChildren(render, root, h, arr);
    const logRoot = () => log("root: " + inner(root));

    logRoot();
    elm = rc([4, 5]);
    log(">>> render [4,5] DONE.");
    logRoot();

    elm = rc([1, 2, 3, 4, 5]);
    log(">>> render [1,2,3,4,5] DONE.");
    logRoot();
  },
  (err) => {
    console.log(err.message);
  }
);
#+end_src

#+RESULTS:
#+begin_example
undefinedfalse
root: <div id=1>hello</div>
>>> render [4,5] DONE.
root: <div id=1><span>4</span><span>5</span></div>
patchKeyedChildren...
while 1, sync from start...
while 2, sync from end...
while 2, sync from end...
patch keyed æ–°å¢ ...
>>> render [1,2,3,4,5] DONE.
root: <div id=1><span>1</span><span>2</span><span>3</span><span>4</span><span>5</span></div>
#+end_example

ä¸Šé¢ä¸¤æ¬¡ while 2 åˆ†åˆ«å¯¹åº”çš„æ˜¯ /5->4/ åŒåŒ–è¿‡ç¨‹ã€‚


#+begin_quote
åŒç±»ç”¨ä¾‹ï¼Œä¸åšå¤šä½™åˆ†æäº†ï¼Œç›´æ¥çœ‹ç»“æœå§ï¼

1. ~[1,2,4,5]~ å’Œ ~[1,2,3,4,5]~ ç»è¿‡ while1(æ›¿æ¢12) å’Œ while2(æ›¿æ¢45) ä¹‹å
   ~i=2,e1=1,e2=2~ æ»¡è¶³~if(i>e1)&&if(i<=e2)~ æ’å…¥æ“ä½œï¼Œå‚è€ƒèŠ‚ç‚¹:
   ~anchor=c2[e2+1]=4~ æ‰€ä»¥æ‰§è¡Œ patchæ—¶å€™ä¼šåœ¨ 4(å› ä¸º anchor æœ‰å€¼) ä¹‹å‰æ’å…¥ 3 ã€‚
#+end_quote
** insert begin&end([2,3,4]->[1,2,3,4,5])

#+begin_src js
const { log, f, shuffle, runtime_test, renderChildren } = require(process.env
  .BLOG_DIR_VUE + "/lib.js");
import(process.env.BLOG_DIR_VUE + "/runtime-test.global.js").then(
  ({ h, render, nodeOps, serializeInner: inner }) => {
    let elm;
    let root = nodeOps.createElement("div");
    // <div>hello</div>
    render(h("div", { id: 1 }, "hello"), root);
    const rc = (arr) => renderChildren(render, root, h, arr);
    const logRoot = () => log("root: " + inner(root));

    logRoot();
    elm = rc([2,3,4]);
    log(">>> render [2,3,4] DONE.");
    logRoot();

    elm = rc([1, 2, 3, 4, 5]);
    log(">>> render [1,2,3,4,5] DONE.");
    logRoot();
  },
  (err) => {
    console.log(err.message);
  }
);
#+end_src

#+RESULTS:
: undefinedfalse
: root: <div id=1>hello</div>
: >>> render [4,5] DONE.
: root: <div id=1><span>2</span><span>3</span><span>4</span></div>
: patchKeyedChildren...
: while 1, sync from start...
: while 2, sync from end...
: >>> render [1,2,3,4,5] DONE.
: root: <div id=1><span>1</span><span>2</span><span>3</span><span>4</span><span>5</span></div>

~[2,3,4]~ å’Œ ~[1,2,3,4,5]~ ç»è¿‡ while1 å’Œ while2 ä»€ä¹ˆéƒ½æ²¡åšï¼Œ ~i=0,e1=2,e2=4~ æ—¢
ä¸æ»¡è¶³ ~if(i>e1)~ ä¹Ÿä¸æ»¡è¶³ ~elseif(i>e2)~ æ‰€ä»¥ä¼šè¿›å…¥ ~else~ çš„æ— è§„åˆ™æ¯”è¾ƒé˜¶æ®µã€‚æ ¹
æ®ä¹‹å‰è„‘å›¾åˆ†æç»“æœå¯çŸ¥ï¼Œ ~else~ æ‰§è¡Œçš„æ­¥éª¤å¤§è‡´æ˜¯ï¼š

1. éå† old children æ›¿æ¢ ~[2,3,4]~

   ç”¨ old ~[2,3,4]~ çš„æ¯ä¸ªå…ƒç´ çš„ key å» new ~[1,2,3,4,5]~ é‡Œé¢å»æ‰¾å¯¹åº”çš„
   key(type,keyç›¸ç­‰çš„èŠ‚ç‚¹)å»æ›¿æ¢è€çš„ï¼Œé‚£ä¹ˆè¿™é‡Œå°†ä¼šæ‰¾åˆ° ~[2,3,4]~ ï¼Œæ­¤æ—¶ç»è¿‡ä¸€ä¸ª
   for old children å¾ªç¯æ‰§è¡Œæ›¿æ¢ï¼Œè¿™é‡Œé‡ç‚¹åœ¨äº ~newIndexToOldIndexMap~ ç»“æœä¼šæ›´
   æ–°ä¸º ~[0,1,2,3,0]~ è¿™é‡Œçš„ 123 åˆ†åˆ«å¯¹åº” ~[2,3,4]~ åœ¨ old children ä¸­çš„ç´¢å¼• + 1
   çš„ç»“æœã€‚

2. éå† new children æ£€æµ‹ ~newIndexToOldIndexMap~

   è¿™ä¸€æ­¥çš„å¾ªç¯æ˜¯é’ˆå¯¹ new children è€Œè¨€ï¼Œä½œç”¨æ˜¯æ‰¾å‡º ~newIndexToOldIndexMap~ ä¸­ä¸
   ä¸º ~0~ çš„å…ƒç´ (ä¹Ÿå°±æ˜¯è¿˜æœªè¢«ä½¿ç”¨çš„å…ƒç´ )ï¼Œæ¥æ‰§è¡Œæ’å…¥æ“ä½œã€‚å¾ªç¯é¡ºåºä»å³åˆ°å·¦æ‰§è¡Œï¼Œ
   åˆ™æœ‰(i-é€’å‡ç´¢å¼•ï¼Œindex-newchild çš„ç´¢å¼•å€¼,el-newchild,val-ä½¿ç”¨çŠ¶æ€)ï¼š

   ~i=4,index=4,el=c2[index],val=0,anchor=null~:

   æœªä½¿ç”¨ï¼Œæ²¡æœ‰å‚è€ƒèŠ‚ç‚¹ï¼Œå±äºçº¯ append æ“ä½œã€‚

   ~i=3,2,1,val!==0~ å·²ç»è¢«ä½¿ç”¨äº†ï¼Œè·³è¿‡

   ~i=0,index=0,el=c2[index],val=0,anchor=c2[index+1]=1~:

   æœªä½¿ç”¨ï¼Œæ’å…¥èŠ‚ç‚¹ä¸º ~[1]~ å‚è€ƒèŠ‚ç‚¹ä¸º ~[2]~ å±äºæ’å…¥æ“ä½œï¼Œåœ¨ ~[1]~ ä¹‹å‰æ’å…¥ã€‚

   æœ€åå¾—åˆ°ç»“æœï¼š ~children=[1,2,3,4,5]~ å®Œæˆã€‚


#+begin_quote
å…¶å®è¿™é‡Œè¿˜æ˜¯æ¯”è¾ƒå®¹æ˜“ç†è§£çš„ï¼Œå› ä¸ºè¿˜æ²¡ç”¨åˆ°â€œæœ‰åºé€’å¢åºåˆ—â€ç®—æ³•ï¼Œå› ä¸º for old
children ä¸­çš„ key æ˜¯æœ‰åºçš„ä¸”æ˜¯ new children çš„å­é›†ï¼Œæ‰€ä»¥éå†è¿‡ç¨‹ä¸­ newIndex ä¸º
0,1,2 åé¢çš„æ€»æ˜¯æ¯”å‰é¢çš„å¤§ï¼Œå› æ­¤ ~maxNewIndexSoFar=2~ ç›´åˆ°ç»“æŸğŸ”šã€‚

ç±»ä¼¼ç”¨ä¾‹ï¼š

1. ~[]~ å’Œ ~[1,2,3,4,5]~ è¿™ç§æƒ…å†µç­‰äºæ˜¯ ~newIndexToOldIndexMap=[0,0,0,0,0]~ æ‰€æœ‰
   new child å…ƒç´ æ‰§è¡Œçš„éƒ½æ˜¯å°¾éƒ¨ append æ“ä½œã€‚
2. ~[1,2,3,4,5]~ å’Œ ~render(h('div'), root)~ ç­‰äºæ˜¯ ~children=[]~ ç›´æ¥åˆ é™¤ old
   children æ“ä½œ
3. ~[1,2,3,4,5]~ å’Œ ~[3,4,5]~ ç»è¿‡ while2 æ›¿æ¢æ‰ ~[3,4,5]~ å‰©ä¸‹ old ~[1,2]~ å› åœ¨
   new children ä¸­æ‰¾ä¸åˆ°å¯¹åº”çš„å…ƒç´ ï¼Œåˆ™ä¼šè¢«åˆ é™¤ã€‚
4. ~[1,2,3,4,5]~ å’Œ ~[1,2,3]~ ç»è¿‡ while1 æ›¿æ¢æ‰ ~[1,2,3]~ å‰©ä¸‹çš„ old ~[4,5]~ å› 
   æ‰¾ä¸åˆ°å¯¹åº”çš„ new child è¢«åˆ é™¤ã€‚
5. ~[1,2,3,4,5]~ å’Œ ~[1,2,4,5]~ ç»è¿‡ while1 æ›¿æ¢æ‰ ~[1,2]~ ç»è¿‡ while2 æ›¿æ¢æ‰
   ~[4,5]~ å‰©ä¸‹ ~[3]~ å› æ‰¾ä¸åˆ° new child è€Œè¢«åˆ é™¤ã€‚
#+end_quote
** move([1,2,3,4]->[2,3,1,4])

è¿™ç§æƒ…å†µä¼šè§¦å‘â€œæœ€é•¿é€’å¢åºåˆ—â€è§„åˆ™ï¼Œè¿›è¡Œæ›¿æ¢ï¼Œå› ä¸ºå‘ç”Ÿ diff-update çš„åŸåˆ™æ˜¯ï¼šæ›´æ–°
ä¹‹åçš„é¡ºåºè¦å’Œ new children é¡ºåºä¸€è‡´ï¼Œå³åŸæ¥æ˜¯ 1234 æ›´æ–°ä¹‹åè¦ä¿æŒ 2314 é¡ºåºã€‚

æ›´æ–°è¿‡ç¨‹ï¼š

1. ç»è¿‡ while1 ä»€ä¹ˆéƒ½ä¸å‘ç”Ÿï¼Œå› ä¸º ~[1]->[2]~ éåŒç±»èŠ‚ç‚¹
2. ç»è¿‡ while2 æ›¿æ¢æ‰ ~[4],i=0,e1=2,e2=2~
3. ~if(i>e1)~ ä¸æ»¡è¶³æ–°å¢æ¡ä»¶
4. ~elif(i>e2)~ ä¸æ»¡è¶³åˆ é™¤æ¡ä»¶
5. è¿›å…¥ else æ— è§„åˆ™æ¯”è¾ƒæ›´æ–°


æµ‹è¯•ï¼š

#+begin_src js
const { log, f, shuffle, runtime_test, renderChildren } = require(process.env
  .BLOG_DIR_VUE + "/lib.js");
import(process.env.BLOG_DIR_VUE + "/runtime-test.global.js").then(
  ({ h, render, nodeOps, serializeInner: inner }) => {
    let elm;
    let root = nodeOps.createElement("div");
    // <div>hello</div>
    render(h("div", { id: 1 }, "hello"), root);
    const rc = (arr) => renderChildren(render, root, h, arr);
    const logRoot = () => log("root: " + inner(root));

    logRoot();
    elm = rc([1,2,3,4]);
    log(">>> render [1,2,3,4] DONE.");
    logRoot();

    elm = rc([2,3,1,4]);
    log(">>> render [2,3,1,4] DONE.");
    logRoot();
  },
  (err) => {
    console.log(err.message);
  }
);
#+end_src

#+RESULTS:
#+begin_example
undefinedfalse
root: <div id=1>hello</div>
>>> render [1,2,3,4] DONE.
root: <div id=1><span>1</span><span>2</span><span>3</span><span>4</span></div>
patchKeyedChildren...
while 1, sync from start...
while 2, sync from end...
while 2, sync from end...
{ arr: [ 2, 3, 1 ] }
{ result: [ 2, 1 ] }
æœ€é•¿å¢é•¿åºåˆ—: 0,1
move äº¤æ¢...
>>> render [2,3,1,4] DONE.
root: <div id=1><span>2</span><span>3</span><span>1</span><span>4</span></div>
#+end_example

åœ¨ä¸Šé¢æ‰§è¡Œè¿‡ç¨‹ä¸­ï¼Œè¿›å…¥ else åˆ†æ”¯ï¼Œæ‰§è¡Œï¼š

1. for old children

   æ‰§è¡Œå®Œä¹‹å(~i=0,e1=2,e2=2~)ï¼Œ ~newIndexToOldIndexMap=[2,3,1]~ åˆ†åˆ«å¯¹åº” ~[1,2,3]~ åœ¨
   ~[2,3,1]~ ä¸­çš„ç´¢å¼•å€¼ + 1ï¼Œå› ä¸ºå­˜åœ¨ ~newIndex < maxNewIndexSoFar~ æ‰€ä»¥
   ~moved=true~ åœ¨éšåçš„æµç¨‹ä¸­ç”¨æ¥è§¦å‘â€œæœ€é•¿å¢é•¿åºåˆ—â€æ“ä½œã€‚

2. for new children

   åœ¨æ‰§è¡Œè¿™ä¸ªå¾ªç¯ä¹‹å‰ï¼Œæˆ‘ä»¬éœ€è¦ç”¨åˆ° ~newIndexToOldIndexMap=[2,3,1]~ å¹¶ä¸”ä»ä¸­æ‰¾
   åˆ°æœ€é•¿å¢é•¿åºåˆ—(~[2,3]~)ï¼Œç„¶è€Œ ~getSequence(arr)~ è¿”å›çš„æ˜¯å®ƒä»¬çš„ç´¢å¼•å€¼ï¼Œæ‰€ä»¥æ˜¯
   ~[0,1]~ æ‰€ä»¥æœ€å ~increasingNewIndexSequence=[0,1]~ ã€‚

   ç„¶ååœ¨ for toBePatched new children é‡Œé¢ï¼Œå› ä¸ºæ£€æµ‹åˆ° ~moved=true~ åˆ™ä¼šè¿›å…¥åˆ°
   ç§»åŠ¨äº¤æ¢æ“ä½œï¼Œè¿™é‡Œæ‰§è¡Œ ~move()~ ä¹Ÿæœ‰ä¸ªæ¡ä»¶ï¼š ~j<0 || i !== increasingNewIndexSequence[j]~ è¿™ä¸¤ä¸ªæ¡ä»¶
   æœ‰åˆ†åˆ«ä»£è¡¨ä¸¤ç§æƒ…å†µ(å‡è®¾ï¼š ~val=increasingNewIndexSequence[j]~)ï¼š

   - ~j<0~ ä»£è¡¨ increasingNewIndexSequence å¢é•¿åºåˆ—æ²¡æœ‰å†…å®¹ï¼Œè¿™è¯´æ˜ä»€ä¹ˆï¼Ÿè¯´æ˜
     ~newIndexToOldIndexMap~ æ˜¯ä¸ªå®Œå…¨é€’å‡æ•°ç»„ï¼Œå¦‚ï¼š ~[3,2,1]~ è¿™ç§æƒ…å†µæ¯ä¸ªå…ƒç´ éƒ½
     éœ€è¦è¿›è¡Œç§»åŠ¨ï¼Œæœ€åå˜æˆ ~[1,2,3]~ ï¼Œ 1ç§»åˆ°3ä½ç½®ï¼Œ2ä¸å˜ï¼Œ3ç§»åŠ¨1çš„ä½ç½®ã€‚

   - ~i!==val~

     æ¯”å¦‚è¿™é‡Œ(~newIndexToOldIndexMap=[2,3,1],old=[1,2,3,4],new=[2,3,1,4]~)

     ~i=2,val=1,nextchild=[1],anchor=[4]~ æ„å‘³ç€è¦åœ¨ ~[4]~ å‰é¢æ’å…¥ ~[1]~ è®°ä½è¿™
     é‡Œæ‰§è¡Œçš„ä¾æ—§æ˜¯æ’å…¥æ“ä½œï¼Œåªæ˜¯åœ¨æ’å…¥ä¹‹å‰ä¼šå°†åŸæ¥çš„ ~[1]~ ä» container.children
     ä¸­åˆ é™¤ï¼Œæ‰€ä»¥çœ‹ä¼¼æ˜¯äº¤æ¢å®é™…åªæ˜¯å˜ç›¸æ’å…¥è€Œå·²ã€‚

     ~i=1,val=1,nextchild=[3],anchor=[1]~ è¿™é‡Œ ~i===val~ æ‰€ä»¥æ‰§è¡Œ ~j--~

     ~i=0,val=0,nextchild=[2],anchor=[3]~ è¿™é‡Œ ~i===val~ æ‰€ä»¥æ‰§è¡Œ ~j--~

     åˆ°æ­¤ for å¾ªç¯å·²ç»é€€å‡ºäº†ï¼Œä¸Šé¢ä¸¤ä¸ª ~j--~ è¯´æ˜è§¦åŠçš„æ˜¯å¢é•¿åºåˆ—é‡Œé¢çš„å…ƒç´ å³ä¸
     éœ€è¦ç§»åŠ¨çš„å…ƒç´ ï¼Œæ‰€ä»¥æœ€å children ç”± ~[1,2,3,4]~ å˜æˆ ~[2,3,1,4]~, åªæ˜¯ 1 è¿›
     è¡Œäº†ç§»åŠ¨ã€‚


#+begin_quote
åªéœ€è¦ç§»åŠ¨ä¸€æ¬¡å°±å¯å®Œæˆã€‚ã€‚ã€‚ã€‚ã€‚ã€‚ã€‚æˆ‘æ˜¯åˆ†ç•Œç‚¹~~~~~~~~~
#+end_quote


åŒæ¡ˆä¾‹åˆ†æï¼š

1. ~[1, 2, 3, 4]~ å’Œ ~[1, 4, 2, 3]~

   åœ¨ç»è¿‡ while1 ä¹‹åå¼€å§‹è¿›å…¥ else åˆ†æ”¯ï¼Œ ~newIndexToOldIndexMap=[4,2,3]~ æœ€åå¾—
   åˆ°å¢é•¿åºåˆ—ï¼š ~[2,3]~å¯¹åº”çš„ç´¢å¼• ~[1,2]~ å³éœ€è¦æ‰§è¡Œæ’å…¥çš„é€»è¾‘æ˜¯ï¼š

   ~i=2,j=1,val=2,next=[3],anchor=null~ ï¼š i===val, j--

   ~i=1,j=0,val=1,next=[2],anchor=[3]~ : i===val, j--

   ~i=0,j=-1,val=undefined,next=[4],anchor=[2]~ : 4 è¦æ’å…¥åˆ° 2 å‰é¢ï¼Œ
   ~children=[1,4,2,3]~

   ~i=-1~ ç»“æŸã€‚

   æ‰€ä»¥åªéœ€è¦æ‰§è¡Œä¸€æ¬¡ç§»åŠ¨å°±å¯ä»¥äº†ï¼Œåœ¨é€’å¢åºåˆ—å†…çš„å…ƒç´ æ˜¯ä¸éœ€è¦åŠ¨çš„ã€‚

2. ~[1,2,3]~ å’Œ ~[2,3,1]~

   ç”±äºå‰åéƒ½ä¸ä¸€æ ·ï¼Œæ‰€ä»¥ while1,while2 éƒ½æ²¡å¤„ç†ï¼Œå¹¶ä¸”è¿›å…¥ else ä¹±åºæƒ…å†µå¤„ç†ã€‚

   ~newIndexToOldIndexMap=[2,4,1]~ å¢é•¿åºåˆ—= ~[2,4]~ ï¼Œç´¢å¼•ï¼š ~[0,1]~

   ~i=2,j=1,val=1,next=[1],anchor=null~ ï¼š ~1~ append åˆ°æœ€åï¼Œå˜æˆ ~children=[2,3,1]~

   ~i=1,j=1,val=1,next=[3],anchor=[1]~ : i===val, j--

   ~i=0,j=0,val=0,next=[2],anchor=[3]~ : i ===val, j--

   ~i=-1~ ç»“æŸ.

   åªéœ€è¦å°† ~[1]~ ç§»åˆ°æœ€åå°±å®Œæˆäº†äº¤æ¢ã€‚

3. ~[1,2,3,4]~ å’Œ ~[4,2,3,1]~

   ~newIndexToOldIndexMap=[4,2,3,1]~ å¢é•¿åºåˆ—ï¼š ~[2,3]~ ï¼Œç´¢å¼•ï¼š ~[1,2]~

   ~i=3,j=1,val=2,next=[1],anchor=null~ : ~[1]~ append åˆ°æœ€åï¼Œ ~children=[2,3,4,1]~

   ~i=2,j=1,val=2,next=[3],anchor=[1]~ : i===val, j--

   ~i=1,j=0,val=1,next=[2],anchor=[3]~ : i===val, j--

   ~i=0,j=-1,val=undefined,next=[4],anchor=[2]~: j<0, æ‰§è¡Œç§»åŠ¨ï¼Œ
   ~children=[4,2,3,1]~, å°† 4 ç§»åŠ¨åˆ° 2 å‰é¢ã€‚

   ~i=-1~ ç»“æŸã€‚

   è¿™é‡Œåªéœ€è¦æ‰§è¡Œä¸¤æ¬¡ç§»åŠ¨æ“ä½œï¼Œ 1<->4 äº¤æ¢ã€‚
** move&replace([1,2,3,4,5]->[4,1,2,3,6])

è¿™é‡Œéœ€è¦å®Œæˆçš„åŠ¨ä½œæœ‰ï¼š /ç”¨ 6 æ›¿æ¢ 5ï¼Œå°† 4ç§»åˆ° 1 å‰é¢/ ã€‚

æµ‹è¯•ï¼š

#+begin_src js
const { log, f, shuffle, runtime_test, renderChildren } = require(process.env
  .BLOG_DIR_VUE + "/lib.js");
import(process.env.BLOG_DIR_VUE + "/runtime-test.global.js").then(
  ({ h, render, nodeOps, serializeInner: inner }) => {
    let elm;
    let root = nodeOps.createElement("div");
    // <div>hello</div>
    render(h("div", { id: 1 }, "hello"), root);
    const rc = (arr) => renderChildren(render, root, h, arr);
    const logRoot = () => log("root: " + inner(root));

    logRoot();
    elm = rc([1,2,3,4,5]);
    log(">>> render [1,2,3,4,5] DONE.");
    logRoot();

    elm = rc([4,1,2,3,6]);
    log(">>> render [4,1,2,3,6] DONE.");
    logRoot();
  },
  (err) => {
    console.log(err.message);
  }
);
#+end_src

#+RESULTS:
#+begin_example
undefinedfalse
root: <div id=1>hello</div>
>>> render [1,2,3,4,5] DONE.
root: <div id=1><span>1</span><span>2</span><span>3</span><span>4</span><span>5</span></div>
patchKeyedChildren...
while 1, sync from start...
while 2, sync from end...
{ arr: [ 4, 1, 2, 3, 0 ] }
{ result: [ 1, 2, 3 ] }
{ toBePatched: 5 }
æœ€é•¿å¢é•¿åºåˆ—: 1,2,3
{ val: 3, i: 3, j: 2, toBePatched: 5 }
{ val: 2, i: 2, j: 1, toBePatched: 5 }
{ val: 1, i: 1, j: 0, toBePatched: 5 }
{ val: undefined, i: 0, j: -1, toBePatched: 5 }
moving...
move äº¤æ¢...
>>> render [4,1,2,3,6] DONE.
root: <div id=1><span>4</span><span>1</span><span>2</span><span>3</span><span>6</span></div>
#+end_example

*åˆ†æ* ï¼š

ç»è¿‡ while1, while2 å®é™…ä»€ä¹ˆéƒ½æ²¡åšï¼Œå› ä¸ºå‰åå¹¶æ²¡æœ‰å…±é€šèŠ‚ç‚¹ï¼Œä¹Ÿå› æ­¤ä¼šè¿›å…¥ else è¿›
è¡Œæ— åºåºåˆ—å¤„ç†ã€‚

~old=[1,2,3,4,5]~

~new=[4,1,2,3,6]~

~newIndexToOldIndexMap=[0,0,0,0,0]~ ç»è¿‡ for old ä¹‹å

~newIndexToOldIndexMap=[4,1,2,3,0]~ æœ€å 5 ç”±äºæ²¡æ‰¾åˆ°å¯¹åº” key çš„ new nodeæˆ–è€…æ— 
key çš„ new nodeè€Œ è¢«æ‰§è¡Œåˆ é™¤(~unmount()~)æ“ä½œã€‚

æ‰¾æœ€é•¿å¢é•¿åºåˆ—ï¼š ~[1,2,3]~ å¾—åˆ° ~newIndexToOldIndexMap~ ä¸­å¯¹åº”çš„ç´¢å¼• ~increasingNewIndexSequence=[1,2,3],j=2~

å¼€å§‹ä»å³åˆ°å·¦éå† new children(~val=increasingNewIndexSequence[j]~)ï¼š

~i=4,map=0,newchild=6~: ç”±äº index map ä¸­çš„å€¼ä¸º 0ï¼Œè¯´æ˜å¹¶æ²¡æœ‰å¯¹åº”çš„ old child å±
äºéœ€è¦æ–°å¢çš„èŠ‚ç‚¹ï¼Œæ‰§è¡Œ mount new èŠ‚ç‚¹æ“ä½œ ~children=[1,2,3,4,6]~ (*æ³¨æ„* ï¼š 5 åœ¨
ä¸Šé¢å·²ç»è¢« unmount æ‰äº†)

~i=3,j=2,val=3,next=3,anchor=6~ : i===val, j--

~i=2,j=1,val=2,next=2,anchor=3~ : i===val, j--

~i=1,j=0,val=1,next=1,anchor=2~ : i===val, j--

~i=0,j=-1,val=undefined,next=4,anchor=1~ : j<0, æ‰§è¡Œ ~move()~ ï¼Œå°† *4* ç§»åŠ¨åˆ°
*1* å‰é¢ï¼Œå˜æˆï¼š ~children=[4,1,2,3,6]~

~i=-1~ ç»“æŸã€‚

#+begin_quote
è¿™é‡Œå®é™…ä¸Šæœ‰ä¸‰ä¸ªåŠ¨ä½œï¼š

1. *5* åœ¨ new children ä¸­æ²¡æ‰¾åˆ° keyed childï¼Œä¹Ÿæ²¡æœ‰ non-keyed child æ‰€ä»¥è¢«
   unmount åˆ é™¤äº†;
2. *6* åœ¨ ~newIndexToOldIndexMap~ ä¸­å¯¹åº”çš„å€¼ä¸º 0ï¼Œè¯´æ˜å¹¶æ²¡æœ‰ old child ä¸ä¹‹å¯¹åº”ï¼Œ
   å±äºæ–°èŠ‚ç‚¹ï¼Œæ‰§è¡Œ mount new æ“ä½œ;
3. *4* èŠ‚ç‚¹æ»¡è¶³ move æ¡ä»¶ï¼Œå°†å…¶ç§»åŠ¨åˆ° *1* å‰é¢ã€‚
#+end_quote

*åŒæ¡ˆä¾‹åˆ†æ* ï¼š

1. ~[1,4,5]~ å’Œ ~[4,6]~

   for old æ—¶ 1 å’Œ 5 è¢« unmount æ‰

   ~newIndexToOldIndexMap=[2,0]~ å› ä¸ºä¸å­˜åœ¨ ~newIndex > maxNewIndexSoFar~ å¯¼è‡´
   ~moved=false~ éšä¹‹ ~increasingNewIndexSequence=[]~

   for new æ—¶ï¼Œç”±äºå¢é•¿åºåˆ—ä¸ºç©ºï¼Œæ‰€ä»¥åªä¼šè¿›å…¥ ~newIndexToOldIndexMap~ æ£€æµ‹æ˜¯å¦ä¸º
   0 çš„ if åˆ†æ”¯æ‰§è¡Œ mount new æ“ä½œï¼Œå³æ–°å¢ 6 è¿™ä¸ªèŠ‚ç‚¹ï¼š

   ~i=1,newIndexToOldIndexMap[i]===0~ è¿›å…¥ if mount new 6 node.

2. ~[2,4,5]~ å’Œ ~[4,5,3]~ åˆ é™¤ 2ï¼Œæ–°å¢ 3

3. ~[1,2,3,4,5,6,7,8]~ å’Œ ~[8,7,6,5,4,3,2,1]~

   è¿™åº”è¯¥æ˜¯æœ€ç³Ÿç³•çš„æƒ…å†µäº†

   ~newIndexToOldIndexMap=[8,7,6,5,4,3,2,1],moved=true~

   å¢é•¿åºåˆ—ä¸º ~[7]~ ï¼Œæ‰€ä»¥ ~increasingNewIndexSequence=[1],j=0~

   ~i=7,j=0,val=7,next=1,anchor=undefined~, i===val, j--, å³èŠ‚ç‚¹ ~[1]~ ä¸éœ€è¦åŠ¨

   ~i=6,j=-1,next=2,anchor=1~ ->2ç§»åˆ°1å‰é¢-> ~children=[3,4,5,6,7,8,2,1]~

   ~i=5,j=-1,next=3,anchor=2~ ->3ç§»åˆ°2å‰é¢-> ~children=[4,5,6,7,8,3,2,1]~

   ~i=4,j=-1,next=4,anchor=3~ ->4ç§»åˆ°3å‰é¢-> ~children=[5,6,7,8,4,3,2,1]~

   ~i=3,j=-1,next=5,anchor=4~ ->5ç§»åˆ°4å‰é¢-> ~children=[6,7,8,5,4,3,2,1]~

   ~i=2,j=-1,next=6,anchor=5~ ->6ç§»åˆ°5å‰é¢-> ~children=[7,8,6,5,4,3,2,1]~

   ~i=1,j=-1,next=7,anchor=6~ ->7ç§»åˆ°6å‰é¢-> ~children=[8,7,6,5,4,3,2,1]~

   ~i=0,j=-1,next=8,anchor=7~ è¿™é‡Œä¹Ÿä¼šæ‰§è¡Œä¸€æ¬¡æ’å…¥å—(å¦‚ä¸‹é¢æµ‹è¯•ç»“æœ)ï¼Ÿ

   ~i=-1~ ç»“æŸï¼Œå…±æ‰§è¡Œäº†ä¸ƒæ¬¡ç§»åŠ¨ã€‚

    #+begin_src js
    const { log, f, shuffle, runtime_test, renderChildren } = require(process.env
    .BLOG_DIR_VUE + "/lib.js");
    import(process.env.BLOG_DIR_VUE + "/runtime-test.global.js").then(
    ({ h, render, nodeOps, serializeInner: inner }) => {
    let elm;
    let root = nodeOps.createElement("div");
    // <div>hello</div>
    render(h("div", { id: 1 }, "hello"), root);
    const rc = (arr) => renderChildren(render, root, h, arr);
    const logRoot = () => log("root: " + inner(root));

    logRoot();
    elm = rc([1,2,3,4,5,6,7,8]);
    log(">>> render [1,2,3,4,5,6,7,8] DONE.");
    logRoot();

    elm = rc([1,2,3,4,5,6,7,8].reverse());
    log(">>> render [8,7,6,5,4,3,2,1] DONE.");
    logRoot();
    },
    (err) => {
    console.log(err.message);
    }
    );
    #+end_src

    #+RESULTS:
    #+begin_example
    undefinedfalse
    root: <div id=1>hello</div>
    >>> render [1,2,3,4,5,6,7,8] DONE.
    root: <div id=1><span>1</span><span>2</span><span>3</span><span>4</span><span>5</span><span>6</span><span>7</span><span>8</span></div>
    patchKeyedChildren...
    while 1, sync from start...
    while 2, sync from end...
    { arr: [
        8, 7, 6, 5,
        4, 3, 2, 1
    ] }
    { result: [ 7 ] }
    { toBePatched: 8 }
    æœ€é•¿å¢é•¿åºåˆ—: 7
    { val: 7, i: 7, j: 0, next: '1', anchor: null, toBePatched: 8 }
    { val: undefined, i: 6, j: -1, next: '2', anchor: '1', toBePatched: 8 }
    move äº¤æ¢...
    { val: undefined, i: 5, j: -1, next: '3', anchor: '2', toBePatched: 8 }
    move äº¤æ¢...
    { val: undefined, i: 4, j: -1, next: '4', anchor: '3', toBePatched: 8 }
    move äº¤æ¢...
    { val: undefined, i: 3, j: -1, next: '5', anchor: '4', toBePatched: 8 }
    move äº¤æ¢...
    { val: undefined, i: 2, j: -1, next: '6', anchor: '5', toBePatched: 8 }
    move äº¤æ¢...
    { val: undefined, i: 1, j: -1, next: '7', anchor: '6', toBePatched: 8 }
    move äº¤æ¢...
    { val: undefined, i: 0, j: -1, next: '8', anchor: '7', toBePatched: 8 }
    move äº¤æ¢...
    >>> render [8,7,6,5,4,3,2,1] DONE.
    root: <div id=1><span>8</span><span>7</span><span>6</span><span>5</span><span>4</span><span>3</span><span>2</span><span>1</span></div>
    #+end_example
* patchUnkeyedChildren
:PROPERTIES:
:COLUMNS: %CUSTOM_ID[(Custom Id)]
:CUSTOM_ID: patch-unkeyed-children
:END:

[[https://github.com/gcclll/stb-vue-next/commit/2d067109dc386b27fa4a6ef9c783262caf6d0f7a][feat(add): unkeyd children patch Â· gcclll/stb-vue-next@2d06710]]

å¯¹äºæ˜ç¡® unkeyed çš„ children å¤„ç†å’Œ keyed å¤„ç†åŒºåˆ«åœ¨äºï¼Œä¼šå°†å‰é¢çš„ children å…ˆè¿›
è¡Œ patch, å› ä¸ºåœ¨ [[#keyed-children][patchKeyedChildren]] ä¸€èŠ‚å·²ç»è¯¦ç»†åˆ†æè¿‡ï¼Œå¦‚æœæ²¡æœ‰ old child æ˜¯
unkeyed ä¼šä» new children ä¸­ä¾åºæ‰¾åˆ°ç¬¬ä¸€ä¸ªç¬¦åˆæ¡ä»¶çš„ unkeyed child å»æ›¿æ¢ã€‚

æ‰€ä»¥è¿™é‡Œåˆ†ä¸‰æ­¥èµ°ï¼š

1. æ‰¾åˆ°æœ€å°é•¿åº¦ï¼Œé’ˆå¯¹æ­¤é•¿åº¦å†…çš„ child è¿›è¡Œ patchï¼Œå› ä¸ºå¯¹äº unkeyed old child åª
   éœ€è¦æ‰¾åˆ°å¯¹åº”çš„ unkeyed new child æ›¿æ¢å°±è¡Œ
2. æ–°å¢çš„æƒ…å†µ new child len > old child len
3. å‡å°‘çš„æƒ…å†µ new child len < old child len

#+begin_src typescript
const patchUnkeyedChildren = (
  c1: VNode[],
  c2: VNodeArrayChildren,
  container: RendererElement,
  anchor: RendererNode | null,
  parentComponent: ComponentInternalInstance | null,
  parentSuspense: SuspenseBoundary | null,
  isSVG: boolean,
  optimized: boolean
) => {
  c1 = c1 || EMPTY_ARR;
  c2 = c2 || EMPTY_ARR;
  const oldLength = c1.length;
  const newLength = c2.length;
  const commonLength = Math.min(oldLength, newLength);
  let i;
  for (i = 0; i < commonLength; i++) {
    const nextChild = (c2[i] = optimized
      ? cloneIfMounted(c2[i] as VNode)
      : normalizeVNode(c2[i]));
    patch(
      c1[i],
      nextChild,
      container,
      null,
      parentComponent,
      parentSuspense,
      isSVG,
      optimized
    );
  }

  if (oldLength > newLength) {
    // remove old
    unmountChildren(
      c1,
      parentComponent,
      parentSuspense,
      true,
      false,
      commonLength
    );
  } else {
    // mount new
    mountChildren(
      c2,
      container,
      anchor,
      parentComponent,
      parentSuspense,
      isSVG,
      optimized,
      commonLength
    );
  }
};
#+end_src
* patch->processComponent(å¦‚ä½•patchç»„ä»¶çš„ï¼Ÿ)
:PROPERTIES:
:COLUMNS: %CUSTOM_ID[(Custom Id)]
:CUSTOM_ID: render-component
:END:




* æµ‹è¯•

#+begin_export html
<div id="tShhLU1P6z"></div>
<script src="/js/vue/tests/tShhLU1P6z.js"></script>
#+end_export
