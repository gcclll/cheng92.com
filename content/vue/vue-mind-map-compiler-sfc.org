#+TITLE: Vue3 æºç å¤´è„‘é£æš´ä¹‹ 5 â˜ compiler-sfc
#+DATE: <2020-12-19 16:07:57>
#+TAGS[]: vue, vue3, compiler-sfc
#+CATEGORIES[]: vue
#+LANGUAGE: zh-cn
#+STARTUP: indent shrink

#+begin_export html
<link href="https://fonts.goo~gleapis.com/cs~s2?family=ZCOOL+XiaoWei&display=swap" rel="stylesheet">
<kbd>
<font color="blue" size="3" style="font-family: 'ZCOOL XiaoWei', serif;">
  è¯—å·ï¼šå…­é“åŒå ï¼Œé­”åŠ«ä¸‡åƒï¼Œå¼•æ¸¡å¦‚æ¥ã€‚
</font>
</kbd><br><br>
#+end_export

[[/img/bdx/yiyeshu-001.jpg]]

@@html:<kbd>@@
*[[https://github.com/gcclll/stb-vue-next][stb-vue-next]] å®Œå…¨æ‹·è´äº [[https://github.com/vuejs/vue-next][vue-next]] ï¼Œä¸»è¦ç›®çš„ç”¨äºå­¦ä¹ ã€‚*
@@html:</kbd>@@

#+begin_quote
*å£°æ˜* ï¼švue-next compiler-sfc æ¨¡å—

*æ›´æ–°æ—¥å¿—&Todos* ï¼š
1. [2020-12-19 13:58:31] åˆ›å»º
#+end_quote

* é‡ç‚¹ã€ç‰¹æ€§ã€é—®é¢˜

1. [[#parse-func][ğŸ”—]] ~<style>~ æ ‡ç­¾ä¸­å¯é€šè¿‡ ~v-bind()~ å¼•ç”¨CSS æ¨¡å—åŒ–åçš„å˜é‡
* f21c84c init åˆå§‹åŒ–å·¥ä½œ

[[https://github.com/gcclll/stb-vue-next/commit/f21c84ca8a8488347aba243262be333f26ab2cef][feat(init): compiler-sfc Â· gcclll/stb-vue-next@f21c84c]]

cp compiler-sfc form vue-next:/packages/compiler-dom

åˆ é™¤ compiler-sfc/src/* ä¸‹æ‰€æœ‰æ–‡ä»¶

æ–°å»º compiler-sfc/src/index.ts å…¥å£æ–‡ä»¶

åˆå§‹åŒ– index.ts:

#+begin_src typescript
// API
export { generateCodeFrame } from '@vue/compiler-core'

// Types
export {
  CompilerOptions,
  CompilerError,
  BindingMetadata
} from '@vue/compiler-core'
#+end_src

-----

[[https://github.com/gcclll/stb-vue-next/commit/e7e1cc130e5c555b541be39b475b6546969b32dc][feat(init): parse function Â· gcclll/stb-vue-next@e7e1cc1]]

å£°æ˜ä¸€äº›åŸºæœ¬ç±»å‹ï¼Œæ¯”å¦‚ï¼š ~<template>, <script>, <style>~ è¿™ä¹Ÿæ˜¯ ~*.vue~ æ–‡ä»¶çš„ä¸‰
å¤§è¦ç´ ï¼Œè¿™é‡Œéœ€è¦å¤šå…³æ³¨ä¸€ç‚¹å°±æ˜¯ä¼šå‘ç° ~<script>~ æ ‡ç­¾é‡Œé¢å¤šæœ‰ä¸€ä¸ª ~setup~ å±æ€§ï¼Œ
è¿™ä¸ªæ˜¯ vue è‡ªèº«å®šä¹‰çš„ä¸€ç§æ ‡ç­¾ç±»å‹ï¼Œæ¯”å¦‚åœ¨è¿™é‡Œé¢å¯ä»¥ç›´æ¥ä½¿ç”¨ ~ref~ å£°æ˜å˜é‡ï¼Œè¿™é‡Œ
é¢çš„å˜é‡éƒ½ä¼šè‡ªåŠ¨å˜æˆå“åº”å¼çš„ç­‰ç­‰ã€‚

SFC å—ç±»å‹å®šä¹‰ï¼š
#+begin_src typescript
export interface SFCBlock {
  type: string
  content: string
  attrs: Record<string, string | true>
  loc: SourceLocation
  map?: RawSourceMap
  lang?: string
  src?: string
}
#+end_src

SFC ~<template>~ æ ‡ç­¾ç±»å‹å®šä¹‰ï¼š
#+begin_src typescript
export interface SFCTemplateBlock extends SFCBlock {
  type: 'template'
  ast: ElementNode
}
#+end_src

SFC ~<script>~ è„šæœ¬æ ‡ç­¾ç±»å‹å®šä¹‰
#+begin_src typescript
export interface SFCScriptBlock extends SFCBlock {
  type: 'script'
  setup?: string | boolean
  bindings?: BindingMetadata
  scriptAst?: Statement[]
  scriptSetupAst?: Statement[]
}
#+end_src

SFC ~<style>~ æ ·å¼æ ‡ç­¾ç±»å‹å®šä¹‰
#+begin_src typescript
export interface SFCStyleBlock extends SFCBlock {
  type: 'style' 
  scoped?: boolean // æŒ‡å®šæ˜¯ä¸æ˜¯åªèƒ½ç”¨äºå½“å‰æ–‡ä»¶
  module?: string | boolean // æ˜¯ä¸æ˜¯æ¨¡å—åŒ–æ ·å¼
}
#+end_src

SFC æ–‡ä»¶ç±»å‹å®šä¹‰
#+begin_src typescript
export interface SFCDescriptor {
  filename: string
  source: string
  template: SFCTemplateBlock | null
  script: SFCScriptBlock | null
  scriptSetup: SFCScriptBlock | null
  styles: SFCStyleBlock[]
  customBlocks: SFCBlock[]
  cssVars: string[]
}
#+end_src

parse å‡½æ•°å®šä¹‰ï¼š
#+begin_src typescript
export function parse(
  source: string,
  { sourceMap = true }: SFCParseOptions
): SFCParseResult {
  return {} as SFCParseResult
}
#+end_src
* 49ee210 parse function å®ç°éƒ¨åˆ†
:PROPERTIES:
:COLUMNS: %CUSTOM_ID[(Custom Id)]
:CUSTOM_ID: parse-func
:END: 

[[https://github.com/gcclll/stb-vue-next/commit/49ee210b898949dbc36dabb7b98555c6043c2a31][feat: sfc-> code parse function Â· gcclll/stb-vue-next@49ee210]]

å®ç° parse å‡½æ•°çš„åŸºæœ¬æ¶æ„:

1. ~sourceToSFC<key, source>~ ç”¨æ¥ç¼“å­˜ vueæ–‡ä»¶è§£æç»“æœï¼Œé¦–å…ˆå–ç¼“å­˜ç»“æœ
2. é€šè¿‡è°ƒç”¨ compiler-dom ä¸­çš„ compiler.parse å°†æ–‡ä»¶å†…å®¹ sourceè§£ææˆ AST
3. éå†æ‰€æœ‰ ast.children æ ¹æ® node.tag ç±»å‹å†³å®šèµ°ä»€ä¹ˆåˆ†æ”¯å¤„ç†

   ~<template>~ æ¨¡æ¿åˆ†æ”¯ï¼Œè¿™é‡Œé¢çš„æ‰€æœ‰å†…å®¹ä¼šè¢« parse ç»§ç»­è§£æå‡º ast

   ~<script [setup]>~ è„šæœ¬åˆ†æ”¯, å½“åš RAWDATA æ–‡æœ¬ç±»å‹å¤„ç†ï¼Œå¦‚æœæœ‰ ~setup~ å±æ€§ï¼Œ
   åˆ™æ‰€æœ‰ script éƒ½ä¸èƒ½å¸¦ src å±æ€§ï¼Œå³ä¸èƒ½å¼•ç”¨å¤–éƒ¨æ–‡ä»¶ï¼Œå› ä¸ºæ‰€æœ‰ script å†…å®¹ä¼šåˆ
   å¹¶åˆ°ä¸€èµ·å»å¤„ç†ã€‚

   ~<style [lang=""]>~  æ ·å¼åˆ†æ”¯ï¼Œå½“åš RAWDATA æ–‡æœ¬ç±»å‹å¤„ç†
4. é”™è¯¯ç”¨æ³•æ£€æµ‹ï¼Œä¸»è¦æ˜¯ ~<script setup>~ è„šæœ¬æ ‡ç­¾ä¸èƒ½æœ‰ src çš„æ£€æµ‹
5. ~souremap~ çš„å¤„ç†
6. ~descriptor.cssVars = parseCssVars(descriptor)~ CSS å˜é‡çš„è§£æï¼Œä¼šå…¨éƒ¨è§£æåˆ°
   æ•°ç»„ ~cssVars~ é‡Œé¢å»
7. ç¼“å­˜è§£æåçš„ç»“æœåˆ° ~sourceToSFC.set(sourceKey, result)~
8. å¯¹äº†ï¼Œåœ¨ ~switch case~ åˆ†æ”¯é‡Œé¢é»˜è®¤èµ°çš„æ˜¯è‡ªå®šä¹‰å—çš„å¤„ç†(vue æ–‡ä»¶ä¸­è¿˜å¯ä»¥è‡ªå®š
   ä¹‰ï¼Ÿ)


CSS vars å˜é‡å¤„ç†ï¼š
#+begin_src typescript
export const CSS_VARS_HELPER = `useCssVars`
export const cssVarRE = /\bv-bind\(\s*(?:'([^']+)'|"([^"]+)"|([^'"][^)]*))\s*\)/g

export function parseCssVars(sfc: SFCDescriptor): string[] {
  const vars: string[] = []
  sfc.styles.forEach(style => {
    let match
    // v-bind('xxx'), v-bind("xxx"), v-bind()
    while ((match = cssVarRE.exec(style.content))) {
      vars.push(match[1] || match[2] || match[3])
    }
  })
  return vars
}
#+end_src

è¿™é‡Œæœ‰ä¸ª cssVarRE æ­£åˆ™ï¼Œæ¥çœ‹ä¸‹ï¼š

[[/img/vue3/re/sfc-css-vars-re.svg]]

è¿™ä¸ªæ­£åˆ™å¯ä»¥åŒ¹é…ç»“æœï¼š ~v-bind('...'), v-bind("..."), v-bind(...)~

ä» ~compiler-src/__tests__/cssVars.spec.ts~ ç”¨ä¾‹ä¸­å¯çª¥è§è¿™ç§ç”¨æ³•ï¼š

#+begin_src js
`<script>const a = 1</script>\n` +
   `<style>div{
     color: v-bind(color);
     font-size: v-bind('font.size');
   }</style>`
#+end_src

#+begin_quote
ğŸ’Ÿ  ç°åœ¨å¯ä»¥ç›´æ¥åœ¨ ~<style>~ å˜è¿é‡Œé¢é€šè¿‡ ~v-bind()~ æ¥ç›´æ¥ä½¿ç”¨å¼•å…¥çš„ CSS å˜é‡ã€‚
#+end_quote

[[https://github.com/gcclll/stb-vue-next/commit/afd8044321de2e4396b8b81bf6e837beeb4ef8b1][feat(add): sfc->parse add sourcemap Â· gcclll/stb-vue-next@afd8044]]
** e32d508 parse <template> case

[[https://github.com/gcclll/stb-vue-next/commit/e32d508809cb7c49e04e4bdac63c26d0101f31a7][feat: sfc-> add <template> parse Â· gcclll/stb-vue-next@e32d508]]

ä¸»è¦å¢åŠ ä»£ç ï¼š switch case -> 'template':
[[http://qiniu.ii6g.com/img/20201219160507.png]]

å¢åŠ å‡½æ•°ï¼š ~createBlock()~ ç”¨æ¥å¤„ç† SFC æ ‡ç­¾çš„å±æ€§(å¦‚ï¼š ~lang, setup, src,
scoped, module~)

å›é¡¾ä¸‹ [[/vue/vue-mind-map-compiler-dom/][compiler-dom]], [[/vue/vue-mind-map-compiler-core-parser/][compiler-core]] å…¶å®å¯¹äº ~<template>~ æ ‡ç­¾çš„å¤„ç†å·¥ä½œä¾ç„¶é›†ä¸­
åœ¨è¿™ä¸¤ä¸ªåŒ…é‡Œé¢ï¼Œæ‰€ä»¥è¿™é‡Œå°±ä¸å†èµ˜è¿°æ¨¡æ¿ ast çš„è§£æäº†ã€‚

#+begin_src js

const {
  parse
} = require(process.env.PWD + '/../../static/js/vue/compiler-sfc.global.js')
 
const source = `
<template>
  <div>{{ test }}</div>
</template>
<script></script>
<style>
  div {
    color:v-bind('fontColor');
  }
</style>`
const res = parse(source)
console.log(res)
#+end_src

#+RESULTS:
#+begin_example
{
  descriptor: {
    filename: 'anonymous.vue',
    source: '\n' +
      '<template>\n' +
      '  <div>{{ test }}</div>\n' +
      '</template>\n' +
      '<script></script>\n' +
      '<style>\n' +
      '  div {\n' +
      "    color:v-bind('fontColor');\n" +
      '  }\n' +
      '</style>',
    template: {
      type: 'template',
      content: '\n  <div>{{ test }}</div>\n',
      loc: [Object],
      attrs: {},
      ast: [Object]
    },
    script: null,
    scriptSetup: null,
    styles: [],
    customBlocks: [],
    cssVars: []
  },
  errors: []
}
undefined
#+end_example

å¦‚ä¸Šï¼šä¸€ä¸ªæœ€ç®€å•çš„ SFC è§£æåçš„ç»“æ„ã€‚
** 3160fed parse <script> case

[[https://github.com/gcclll/stb-vue-next/commit/3160fedbf252ad5a71a16567ae44fa445a343fa8][feat(add): sfc-> script parse Â· gcclll/stb-vue-next@3160fed]]

å¢åŠ  switch case script é€»è¾‘ï¼š
#+begin_src typescript
case 'script': // è„šæœ¬æ ‡ç­¾å¤„ç†
    const scriptBlock = createBlock(node, source, pad) as SFCScriptBlock
    const isSetup = !!scriptBlock.attrs.setup
    if (isSetup && !descriptor.scriptSetup) {
        descriptor.scriptSetup = scriptBlock
        break
    }

    if (!isSetup && !descriptor.script) {
        descriptor.script = scriptBlock
        break
    }
    errors.push(createDuplicateBlockError(node, isSetup))
    break
break
#+end_src

createBlock() ä¸­å¢åŠ å„å±æ€§çš„è§£æå’Œè®¾ç½®ï¼š

~lang~ -> ~block.lang~

~src~ -> ~block.src~

~style > scoped~ -> ~block.scoped~

~style > module~ -> ~block.module~

~script > setup~ -> ~block.setup~

å¦å¤–å¢åŠ äº† ~padContent()~ æ£€æµ‹å›è½¦æ¢è¡Œç¬¦æ›¿æ¢ï¼Ÿ

æµ‹è¯•ï¼š
#+begin_src js
const {
  parse
} = require(process.env.PWD + '/../../static/js/vue/compiler-sfc.global.js')
 
const source = `
<script setup>
import { x } from './x'
let a = 1
const b = 2
function c() {}
class d {}
</script>`
const res = parse(source)
console.log(res.descriptor)
#+end_src

#+RESULTS:
#+begin_example
{
  filename: 'anonymous.vue',
  source: '\n' +
    '<script setup>\n' +
    "import { x } from './x'\n" +
    'let a = 1\n' +
    'const b = 2\n' +
    'function c() {}\n' +
    'class d {}\n' +
    '</script>',
  template: null,
  script: null,
  scriptSetup: {
    type: 'script',
    content: '\n' +
      "import { x } from './x'\n" +
      'let a = 1\n' +
      'const b = 2\n' +
      'function c() {}\n' +
      'class d {}\n',
    loc: {
      source: '\n' +
        "import { x } from './x'\n" +
        'let a = 1\n' +
        'const b = 2\n' +
        'function c() {}\n' +
        'class d {}\n',
      start: [Object],
      end: [Object]
    },
    attrs: { setup: true },
    setup: true
  },
  styles: [],
  customBlocks: [],
  cssVars: []
}
undefined
#+end_example
** aa037fe parse <style> case

[[https://github.com/gcclll/stb-vue-next/commit/aa037fef4476f27ce25a88480768cb81e10075da][feat(add): sfc-> parse <style> Â· gcclll/stb-vue-next@aa037fe]]

è§£æåçš„ç»“æœä¿å­˜åˆ° ~descriptor.styles.push(styleBlock)~ æ‰€ä»¥å¯ä»¥æœ‰å¤šä¸ª ~<style>~
å­˜åœ¨ã€‚

#+begin_quote
/Tip/: è¿™é‡Œè¿˜æœ‰ä¸€ä¸ª ~styleBlock.attrs.vars~ æ£€æµ‹ï¼Œéš¾ä¸æˆå°†æ¥ä¼šæ”¯æŒç›´æ¥ SFC é‡Œé¢
å£°æ˜ CSS å˜é‡?
#+end_quote

æµ‹è¯•ï¼š
#+begin_src js
const {
  parse
} = require(process.env.PWD + '/../../static/js/vue/compiler-sfc.global.js')
 
const source = `
<style scoped>
h1 {
  color: red;
  font-size: v-bind(fontSize);
  border: v-bind('border');
}
</style>`
const res = parse(source)
console.log(res.descriptor)
#+end_src

#+RESULTS:
#+begin_example
{
  filename: 'anonymous.vue',
  source: '\n' +
    '<style scoped>\n' +
    'h1 {\n' +
    '  color: red;\n' +
    '  font-size: v-bind(fontSize);\n' +
    "  border: v-bind('border');\n" +
    '}\n' +
    '</style>',
  template: null,
  script: null,
  scriptSetup: null,
  styles: [
    {
      type: 'style',
      content: '\n' +
        'h1 {\n' +
        '  color: red;\n' +
        '  font-size: v-bind(fontSize);\n' +
        "  border: v-bind('border');\n" +
        '}\n',
      loc: [Object],
      attrs: [Object],
      scoped: true
    }
  ],
  customBlocks: [],
  cssVars: [ 'fontSize', 'border' ]
}
undefined
#+end_example

å¯¹äº ~v-bind()~ å˜é‡çš„å¼•ç”¨ï¼Œä¸ç®¡æœ‰æ²¡å¼•å·ï¼Œéƒ½ä¼šå½“åšå˜é‡å¤„ç†ã€‚
* compile <template>

** c26e76c init compileTemplate

[[https://github.com/gcclll/stb-vue-next/commit/c26e76cb4e7ef260f3c500aa693581fca175cab4][feat(init): sfc->compile <template> Â· gcclll/stb-vue-next@c26e76c]]

å¢åŠ ä¸¤ä¸ªç±»å‹å’Œ compileTemplate å‡½æ•°å®šä¹‰ï¼š

SFCTemplateCompileResults æ¨¡æ¿ä¾¿åçš„ç»“æœç±»å‹
#+begin_src typescript
export interface SFCTemplateCompileResults {
  code: string
  ast?: RootNode
  preamble?: string
  source: string
  tips: string[]
  errors: (string | CompilerError)[]
  map?: RawSourceMap
}
#+end_src

SFCTemplateCompileOptions æ¨¡æ¿ç¼–è¯‘å™¨é€‰é¡¹
#+begin_src typescript

export interface SFCTemplateCompileOptions {
  source: string
  filename: string
  id: string
  scoped?: boolean
  isProd?: boolean
  ssr?: boolean
  ssrCssVars?: string[]
  inMap?: RawSourceMap
  compiler?: TemplateCompiler
  compilerOptions?: CompilerOptions
  preprocessLang?: string
  preprocessOptions?: any
  /**
   * In some cases, compiler-sfc may not be inside the project root (e.g. when
   * linked or globally installed). In such cases a custom `require` can be
   * passed to correctly resolve the preprocessors.
   */
  preprocessCustomRequire?: (id: string) => any
  /**
   * Configure what tags/attributes to transform into asset url imports,
   * or disable the transform altogether with `false`.
   */
  transformAssetUrls?: AssetURLOptions | AssetURLTagConfig | boolean
}
#+end_src

åŠ compileTemplate å‡½æ•°
#+begin_src typescript
export function compileTemplate(
  options: SFCTemplateCompileOptions
): SFCTemplateCompileResults {
  return {} as SFCTemplateCompileResults
}
#+end_src
** TODO 1b2965f coding compileTemplate

[[https://github.com/gcclll/stb-vue-next/commit/1b2965fb3d45c450f0b8af66c54834a0ecc8d219][feat: sfc->compile compileTemplate code Â· gcclll/stb-vue-next@1b2965f]]


è¿™ä¸ªå‡½æ•°ç›¸å…³çš„å†…å®¹ï¼š

1. preprocessLang
2. preprocessCustomRequire

TODO æ¨¡æ¿é¢„å¤„ç†å™¨ï¼Œæ²¡ææ˜ç™½è¿™é‡Œæ˜¯è¦åšä»€ä¹ˆï¼Ÿ

ä»£ç é€»è¾‘ï¼š

if preprocessor -> doCompileTemplate()

elseif preprocessLang -> ...

else -> doCompileTemplate()

#+begin_quote
â¹ ç­‰å¾…æ¢ç´¢......
#+end_quote
** 7b49db4 coding doCompileTemplate å‡½æ•°å®ç°

[[https://github.com/gcclll/stb-vue-next/commit/7b49db43ed8b1535d423b9143b3019fd5556be8a][feat(add): sfc->compile doCompileTemplate Â· gcclll/stb-vue-next@7b49db4]]

å‡½æ•°åŠŸèƒ½ï¼šæ”¶é›†ä¸¤ä¸ª transform ç»™ compiler.compile åœ¨æ¨¡æ¿ç¼–è¯‘æœŸé—´ä½¿ç”¨ã€‚

1. asset url èµ„æºåœ°å€è½¬æ¢ç”¨çš„ transform

   è¦å¤„ç†çš„æ ‡ç­¾å’Œå¯¹åº”çš„åŒ…å« url çš„å±æ€§:

   | tag        | prop with url        |
   |------------+----------------------|
   | ~<video>~  | 'src', 'poster'      |
   | ~<source>~ | 'src'                |
   | ~<img>~    | 'src'                |
   | ~<image>~  | 'xlink:href', 'href' |
   | ~<use>~    | 'xlink:href', 'href' |

2. img/source æ ‡ç­¾ src åœ°å€è½¬æ¢



é‡ç‚¹ä»£ç ï¼š
#+begin_src typescript
 const shortId = id.replace(/^data-v-/, '')
  const longId = `data-v-${shortId}`

  let { code, ast, preamble, map } = compiler.compile(source, {
    mode: 'module',
    prefixIdentifiers: true,
    hoistStatic: true,
    cacheHandlers: true,
    ssrCssVars:
      ssr && ssrCssVars && ssrCssVars.length
        ? '' /* TODO genCssVarsFromList(ssrCssVars, shortId, isProd) */
        : '',
    // css å±€éƒ¨ä½¿ç”¨ï¼ŒåŠ ä¸Šå¯¹åº”çš„å”¯ä¸€ id
    scopeId: scoped ? longId : undefined,
    ...compilerOptions,
    nodeTransforms: nodeTransforms.concat(compilerOptions.nodeTransforms || []),
    filename,
    sourceMap: true,
    onError: e => errors.push(e)
  })
#+end_src

å°† ~nodeTransforms: [transformAssetUrl, transformSrcset]~ ä¼ é€’ç»™ç¼–è¯‘å™¨å¤„ç†ã€‚

æ³¨æ„è¿™é‡Œè®¾ç½®äº†å‡ ä¸ªå±æ€§ï¼š ~mode = 'module', prefixIdentifiers = true~ æ‰€ä»¥è¿™ä¸ªåº”
è¯¥åªèƒ½è¿è¡Œåœ¨éæµè§ˆå™¨ç¯å¢ƒã€‚

ä¸‹é¢æ¥å®ç°ä¸€ä¸ªç›¸å¯¹ç®€å•çš„ ~transformAssetUrl()~ å‡½æ•° ......
** 2d82400 coding transformAssetUrl è½¬æ¢èµ„æº url

[[https://github.com/gcclll/stb-vue-next/commit/2d8240089e6d7642a0f2234b6addff8e0d9885cd][feat(add): sfc->compile templateTransformAssetUrl Â· gcclll/stb-vue-next@2d82400]]

[[https://github.com/gcclll/stb-vue-next/commit/e08f8059612591a6b38d6e813e305986fc7f646a][fix: sfc preprocess function Â· gcclll/stb-vue-next@e08f805]]

å‡ ç§URLä½¿ç”¨æƒ…å†µå’Œè½¬æ¢ç»“æœå¦‚ä¸‹å®ä¾‹ï¼š

#+begin_src js
const { compileTemplate } = require(process.env.VNEXT_PKG_SFC + '/dist/compiler-sfc.cjs.js')
const { code, ast } = compileTemplate({
  source: `<template><div id="test">
<img src="./test/test.png" />
<img src="./test/test.png" />
<img :src="imgUrl" />
<img src="" />
<img src="http://1.1.1.1:100/imgs/test/test.png" />
<img src="data:...." />
<img src="#test/test.png" />
<img src="~test/test.png" />
<img src="~/test/test.png" />
<img src="@test/test.png" />
<video src="./test/video.mp4" poster="./test/poster.png" />
<div src="./test/test.png" />

</div></template>`,
  id: '', filename: 'test.vue'
})
console.log(code)
#+end_src

#+RESULTS:
#+begin_example
import { createVNode as _createVNode, openBlock as _openBlock, createBlock as _createBlock } from "vue"
import _imports_0 from './test/test.png'
import _imports_1 from 'test/test.png'
import _imports_2 from '@test/test.png'
import _imports_3 from './test/video.mp4'
import _imports_4 from './test/poster.png'


const _hoisted_1 = { id: "test" }
const _hoisted_2 = /*#__PURE__*/_createVNode("img", { src: _imports_0 }, null, -1 /* HOISTED */)
const _hoisted_3 = /*#__PURE__*/_createVNode("img", { src: _imports_0 }, null, -1 /* HOISTED */)
const _hoisted_4 = /*#__PURE__*/_createVNode("img", { src: "" }, null, -1 /* HOISTED */)
const _hoisted_5 = /*#__PURE__*/_createVNode("img", { src: "http://1.1.1.1:100/imgs/test/test.png" }, null, -1 /* HOISTED */)
const _hoisted_6 = /*#__PURE__*/_createVNode("img", { src: "data:...." }, null, -1 /* HOISTED */)
const _hoisted_7 = /*#__PURE__*/_createVNode("img", { src: "#test/test.png" }, null, -1 /* HOISTED */)
const _hoisted_8 = /*#__PURE__*/_createVNode("img", { src: _imports_1 }, null, -1 /* HOISTED */)
const _hoisted_9 = /*#__PURE__*/_createVNode("img", { src: _imports_1 }, null, -1 /* HOISTED */)
const _hoisted_10 = /*#__PURE__*/_createVNode("img", { src: _imports_2 }, null, -1 /* HOISTED */)
const _hoisted_11 = /*#__PURE__*/_createVNode("video", {
  src: _imports_3,
  poster: _imports_4
}, null, -1 /* HOISTED */)
const _hoisted_12 = /*#__PURE__*/_createVNode("div", { src: "./test/test.png" }, null, -1 /* HOISTED */)

export function render(_ctx, _cache) {
  return (_openBlock(), _createBlock("template", null, [
    _createVNode("div", _hoisted_1, [
      _hoisted_2,
      _hoisted_3,
      _createVNode("img", { src: _ctx.imgUrl }, null, 8 /* PROPS */, ["src"]),
      _hoisted_4,
      _hoisted_5,
      _hoisted_6,
      _hoisted_7,
      _hoisted_8,
      _hoisted_9,
      _hoisted_10,
      _hoisted_11,
      _hoisted_12
    ])
  ]))
}
undefined
#+end_example

æ¨¡æ¿ä¸­èµ„æºURLä¸è½¬æ¢å‡ ç§æƒ…å†µï¼š

1. å±æ€§ä¸æ˜¯é™æ€å±æ€§(~NodeTypes.ATTRIBUTE~)
2. éç‰¹å®šæ ‡ç­¾çš„ä¸è½¬æ¢(æˆ–è€…é€šè¿‡ ~options.tags~ é‡ŒæŒ‡å®šçš„æ ‡ç­¾)

   #+begin_src json
   tags: {
     video: ['src', 'poster'],
     source: ['src'],
     img: ['src'],
     image: ['xlink:href', 'href'],
     use: ['xlink:href', 'href']
   }
   #+end_src
3. æ²¡æœ‰å±æ€§å€¼çš„å±æ€§
4. å¤–éƒ¨é“¾æ¥çš„URL(~https~ å¼€å¤´çš„)
5. ~data:~ å¼€å¤´çš„èµ„æºåœ°å€
6. å±æ€§å€¼ä»¥ ~#~ å¼€å¤´çš„åœ°å€
7. éç»å¯¹è·¯å¾„ä¸”è´¹ç›¸å¯¹è·¯å¾„çš„(ä»¥ï¼Œ ~.|~|@~ å¼€å¤´çš„åœ°å€)


éœ€è¦å¤„ç†çš„åˆåˆ†ä¸¤ç§æƒ…å†µï¼š

1. ç»™å®šäº† ~options.base~ åŸºåœ°å€çš„(~.|~|@~ ä¸ºç¬¬ä¸€ä¸ªå­—ç¬¦çš„)

   ç›´æ¥ç”¨ ~options.base + assert url~ å¤„ç†

2. é1ä¸­æ¸…ç©ºçš„ä½¿ç”¨ ~import imgName from '...img url'~ å¼•å…¥


#+begin_quote
PS. å¯¹äº CSS ä¸­çš„URLå¼•ç”¨æ”¾åˆ°åç»­ compileStyle ä¸­å»å±•ç¤ºã€‚
#+end_quote
* 56358a8 compile <style>

[[https://github.com/gcclll/stb-vue-next/commit/56358a8b2cf95ef6a2df125c672a455690785a84][feat(add): sfc-> compile style Â· gcclll/stb-vue-next@56358a8]]

è¿™éƒ¨åˆ†ä»£ç éƒ½æ˜¯ç›´æ¥ Ctrl-c, Ctrl-v æ¥çš„ï¼Œä¹Ÿæ²¡æ·±å…¥ç ”ç©¶ï¼Œæ‰€ä»¥è¿™èŠ‚ä¹Ÿæ²¡ä»€ä¹ˆå¥½è®²è¿°çš„ã€‚

å¾…åˆ°ä»¥åæœ‰æ—¶é—´å†æ¥ç ”ç©¶ã€‚

#+begin_src js
const { compileStyle } = require(process.env.VNEXT_PKG_SFC + '/dist/compiler-sfc.cjs.js')

const c = (source, option = {}) => compileStyle({
  source,
  filename: 'test.css',
  id: 'data-v-test',
  scoped: true,
  ...option
})

const log = console.log
const res = c(`
h1 { color: red; }
.foo { color: red; }
h1 .foo { color: red; }
h1 .foo, .bar, .baz { color: red; }
.foo:after { color: red; }
::selection { display: none; }
.abc, ::selection { color: red; }

:deep(.foo) { color: red; }
::v-deep(.foo) { color: red; }
::v-deep(.foo .bar) { color: red; }
.baz .qux ::v-deep(.foo .bar) { color: red; }

:slotted(.foo) { color: red; }
::v-slotted(.foo) { color: red; }
::v-slotted(.foo .bar) { color: red; }
.baz .qux ::v-slotted(.foo .bar) { color: red; }

:global(.foo) { color: red; }
::v-global(.foo) { color: red; }
::v-global(.foo .bar) { color: red; }
.baz .qux ::v-global(.foo .bar) { color: red; }

@media print { .foo { color: red }}
@supports(display: grid) { .foo { display: grid }}

.anim {
  animation: color 5s infinite, other 5s;
}
.anim-2 {
  animation-name: color;
  animation-duration: 5s;
}
.anim-3 {
  animation: 5s color infinite, 5s other;
}
.anim-multiple {
  animation: color 5s infinite, opacity 2s;
}
.anim-multiple-2 {
  animation-name: color, opacity;
  animation-duration: 5s, 2s;
}

@keyframes color {
  from { color: red; }
  to { color: green; }
}
@-webkit-keyframes color {
  from { color: red; }
  to { color: green; }
}
@keyframes opacity {
  from { opacity: 0; }
  to { opacity: 1; }
}
@-webkit-keyframes opacity {
  from { opacity: 0; }
  to { opacity: 1; }
}
`)
log(res.code)
#+end_src

#+RESULTS:
#+begin_example

h1[data-v-test] { color: red;
}
.foo[data-v-test] { color: red;
}
h1 .foo[data-v-test] { color: red;
}
h1 .foo[data-v-test], .bar[data-v-test], .baz[data-v-test] { color: red;
}
.foo[data-v-test]:after { color: red;
}
[data-v-test]::selection { display: none;
}
.abc[data-v-test],[data-v-test]::selection { color: red;
}
[data-v-test] .foo { color: red;
}
[data-v-test] .foo { color: red;
}
[data-v-test] .foo .bar { color: red;
}
.baz .qux[data-v-test] .foo .bar { color: red;
}
.foo[data-v-test-s] { color: red;
}
.foo[data-v-test-s] { color: red;
}
.foo .bar[data-v-test-s] { color: red;
}
.baz .qux .foo .bar[data-v-test-s] { color: red;
}
.foo { color: red;
}
.foo { color: red;
}
.foo .bar { color: red;
}
.foo .bar { color: red;
}
@media print {
.foo[data-v-test] { color: red
}}
@supports(display: grid) {
.foo[data-v-test] { display: grid
}}
.anim[data-v-test] {
  animation: color-test 5s infinite, other 5s;
}
.anim-2[data-v-test] {
  animation-name: color-test;
  animation-duration: 5s;
}
.anim-3[data-v-test] {
  animation: 5s color-test infinite, 5s other;
}
.anim-multiple[data-v-test] {
  animation: color-test 5s infinite,opacity-test 2s;
}
.anim-multiple-2[data-v-test] {
  animation-name: color-test,opacity-test;
  animation-duration: 5s, 2s;
}
@keyframes color-test {
from { color: red;
}
to { color: green;
}
}
@-webkit-keyframes color-test {
from { color: red;
}
to { color: green;
}
}
@keyframes opacity-test {
from { opacity: 0;
}
to { opacity: 1;
}
}
@-webkit-keyframes opacity-test {
from { opacity: 0;
}
to { opacity: 1;
}
}

undefined
#+end_example

#+begin_quote
PS. å¯¹äº CSS çš„è§£æéœ€è¦ postcss ä»¥åŠå„ç§é¢„å¤„ç†æ¥å¤„ç†ï¼Œè¿™é‡Œæš‚æ—¶ä¸å±•å¼€ã€‚
#+end_quote
* 4d66531 compile <script>^{é‡ç‚¹}

è¿™èŠ‚ä¼šæ˜¯é‡ç‚¹éƒ¨åˆ†ã€‚

[[/img/vue3/compiler-sfc/vue-compiler-sfc-compile-script.svg]]

** init compileScript function

åˆå§‹åŒ– ~compileScript()~ å‡½æ•°ä»¥åŠå‚æ•°é€‰é¡¹ç±»å‹ ~SFCScriptCompileOptions~

SFCScriptCompileOptions:

- ~id: string~, ä¼ é€’ç»™ ~compileStyle~ ç”¨äºä½œä¸º injected CSS å˜é‡å‰ç¼€ç”¨
- ~isProd?: boolean~ å†³å®šç”Ÿæˆçš„ CSS å˜é‡æ˜¯å¦è¦åŠ ä¸Š hash å€¼
- ~babelParserPlugins?: ParserPlugin[]~
- ~refSugar?: boolean~ ä½¿èƒ½ ~ref~ è¯­æ³•ç³–
- ~inlineTemplate?: boolean~ å†…è”æ¨¡æ¿ï¼Ÿï¼Ÿï¼Ÿ


compileScript:
#+begin_src typescript
/**
 * Compile `<script setup>`
 * It requires the whole SFC descriptor because we need to handle and merge
 * normal `<script>` + `<script setup>` if both are present.
 */
export function compileScript(
  sfc: SFCDescriptor,
  options: SFCScriptCompileOptions
): SFCScriptBlock {
  return {} as SFCScriptBlock
}
#+end_src

[[https://github.com/gcclll/stb-vue-next/commit/54ea72a4fd3d2ccdce268714f0ef205fa9e9b976][feat(add): sfc->script, compileScript steps comment Â·
gcclll/stb-vue-next@54ea72a]]

åˆ—å‡º compileScript() å°†è¦å®Œæˆçš„ä»»åŠ¡ï¼š

| No. | Desc                                                        | Link |
|-----+-------------------------------------------------------------+------|
|   0 | å‰ç½®å¤„ç†                                                    | -    |
|   1 | å¤„ç†å­˜åœ¨çš„ <script> ä»£ç ä½“                                  | -    |
|   2 | è§£æ <script setup>ï¼Œéå†ç½®é¡¶çš„è¯­å¥                         | -    |
|   3 | å°† refè®¿é—®è½¬æ¢æˆå¯¹ ref.value çš„å¼•ç”¨                         | -    |
|   4 | é‡Šæ”¾ setup ä¸Šä¸‹æ–‡ç±»å‹çš„è¿è¡Œæ—¶ props/emits ä»£ç               | -    |
|   5 | æ£€æŸ¥ç”¨æˆ·é€‰é¡¹(useOptions)å‚æ•°ï¼Œç¡®ä¿å®ƒæ²¡æœ‰å¼•ç”¨ setup ä¸‹çš„å˜é‡ | -    |
|   6 | åˆ é™¤ non-script çš„å†…å®¹                                      | -    |
|   7 | åˆ†æ binding metadata                                       | -    |
|   8 | æ³¨å…¥ `useCssVars` è°ƒç”¨                                      | -    |
|   9 | å®Œæˆ setup() å‚æ•°ç­¾å                                       | -    |
|  10 | ç”Ÿæˆè¿”å›è¯­å¥(return)                                        | -    |
|  11 | å®Œæˆ default export                                         | -    |
|  12 | å®Œæˆ Vue helpers imports                                    | -    |

æ¥ä¸‹æ¥å°±æ˜¯æŒ‰ç…§ä¸Šè¡¨çš„æ­¥éª¤æ¥ä¸€æ­¥æ­¥å®Œæˆ ~compileScript()~

#+begin_quote
PS. ä¸‹é¢æ¯ä¸ªå¯¹åº”ç« èŠ‚éƒ½æœ‰å¯¹åº”çš„åŸç‰ˆè‹±æ–‡æ³¨é‡Šï¼Œè‹±è¯­ä¸å¥½~~~~~ã€‚
#+end_quote

å¢åŠ ä¸€äº›é€»è¾‘æ— å…³çš„å˜é‡å£°æ˜ï¼š
[[https://github.com/gcclll/stb-vue-next/commit/06f1d95b352452cd2f3999e431b2a2bf60dc37c4][feat(add): sfc->script compileScript declarations Â· gcclll/stb-vue-next@06f1d95]]

åœ¨è¿›å…¥æ­£å¼æ­¥éª¤ä¹‹å‰ï¼Œæ¥ç®€å•çœ‹çœ‹ä½¿ç”¨åˆ°çš„ ~@babel/parser~ è¿™ä¸ªæ’ä»¶æ˜¯å¦‚ä½•ä½¿ç”¨çš„ï¼Œè¾“
å‡ºç»“æœåˆæ˜¯å•¥ï¼Ÿ

#+begin_src js
const { parse } = require(process.env.BABEL_DIR + '/parser/lib/index.js')
const log = console.log
let code = `
import { a } from './a.js';

const value = 1 * 10 + 100 - 20 / 30 + 1
export const name = a.getName();

export default { name }
`
const res = parse(code, { sourceType: 'module' })
console.log(res.program.body.map(body => body.type).join('\n'))
#+end_src

#+RESULTS:
: ImportDeclaration
: VariableDeclaration
: ExportNamedDeclaration
: ExportDefaultDeclaration
: undefined

ä»¥ä¸Šè¾“å‡ºæ˜¯æ¯ä¸ªè¯­å¥åœ¨ parser ä¸­å¯¹åº”çš„ AST ç±»å‹ã€‚

** 0âƒ£ d7369ae æ—  <script setup> æ—¶
:PROPERTIES:
:COLUMNS: %CUSTOM_ID[(Custom Id)]
:CUSTOM_ID: script-0
:END:

[[https://github.com/gcclll/stb-vue-next/commit/d7369ae572e45ea9f6f32aa6bdfe534b1f5dda39][feat(add): script without setup-script parse Â· gcclll/stb-vue-next@d7369ae]]

ä¸€å¼€å§‹ä¼šæ£€æµ‹æœ‰æ²¡æœ‰ ~script setup~ å¦‚æœæ²¡æœ‰ï¼Œç»§ç»­æ£€æµ‹ ~<script>~ æ™®é€šæ ‡ç­¾ï¼Œå¦‚æœä¸¤
è€…éƒ½ä¸å­˜åœ¨ï¼ŒæŠ›å‡ºå¼‚å¸¸ã€‚

å¦‚æœ ~<script>~ å­˜åœ¨ï¼Œåˆ™ç›´æ¥è°ƒç”¨ ~@babel/parser~ çš„ [[https://babeljs.io/docs/en/babel-parser#babelparserparsecode-options][parse]] å‡½æ•°è¿›è¡Œè§£æï¼Œå› æ­¤åé¢
ä¸€å¨ä»£ç åœ¨è¿™ç§æƒ…å†µä¸‹(åªæœ‰æ™®é€šçš„ ~script~ æ—¶)æ˜¯ä¸éœ€è¦çš„ã€‚

æ–°å¢ä»£ç ï¼š
#+begin_src typescript
const scriptAst = _parse(script.content, {
    plugins,
    sourceType: 'module'
}).program.body
const bindings = analyzeScriptBindings(scriptAst)
const needRewrite = cssVars.length || hasInheritAttrsFlag
let content = script.content
if (needRewrite) {
// TODO need rewrite
}
return {
    ...script,
    content,
    bindings,
    scriptAst
}
#+end_src

æµ‹è¯•:
#+begin_src js
const { compileScript, parse } = require(process.env.VNEXT_PKG_SFC + '/dist/compiler-sfc.cjs.js')

const compile = (src, options) => {
  const { descriptor } = parse(src)
  return compileScript(descriptor, { ...options, id: 'xxxx' })
}

const code = `
<script>
import { a } from './a.js';
</script>
`
const res = compile(code)
console.log(res.type, '\n', res.scriptAst)
#+end_src

#+RESULTS:
#+begin_example
script 
 [
  Node {
    type: 'ImportDeclaration',
    start: 1,
    end: 28,
    loc: SourceLocation {
      start: [Position],
      end: [Position],
      filename: undefined,
      identifierName: undefined
    },
    range: undefined,
    leadingComments: undefined,
    trailingComments: undefined,
    innerComments: undefined,
    extra: undefined,
    specifiers: [ [Node] ],
    source: Node {
      type: 'StringLiteral',
      start: 19,
      end: 27,
      loc: [SourceLocation],
      range: undefined,
      leadingComments: undefined,
      trailingComments: undefined,
      innerComments: undefined,
      extra: [Object],
      value: './a.js'
    }
  }
]
undefined
#+end_example

ç¤ºä¾‹ï¼š
#+begin_src js
const { compileScript, parse } = require(process.env.VNEXT_PKG_SFC + '/dist/compiler-sfc.cjs.js')
const { log } = require(process.env.BLOG_JS + '/utils.js')
const compile = (src, options) => {
  const { descriptor } = parse(src)
  return compileScript(descriptor, { ...options, id: 'xxxx' })
}

const code = `
<script>
  export default {
    props: ['foo', 'bar']
  }
</script>`
const { type, scriptAst: ast } = compile(code)
// é¦–å…ˆæ˜¯ä¸ª ExportDefaultDeclaration ç±»å‹
// export çš„å€¼ä¸ºä¸€ä¸ª ObjectExpression ç±»å‹
log(`>>> <script> è§£æåçš„ç±»å‹`)
console.log(type)
const node = ast[0]
log(`>>> export default è§£æåçš„ç±»å‹`)
log(node.type)
log(`>>> { props : ... } è§£æåçš„ ast åŒ…å«çš„ keys`)
log(Object.keys(node.declaration))
log(`> properties ä¸º ObjectExpression å¯¹è±¡çš„æˆå‘˜åˆ—è¡¨ï¼Œå¦‚ï¼š props`)
log.props(node.declaration.properties[0], ['type', 'key', 'value'])
log(node.declaration.properties[0].value.elements)
#+end_src

+RESULTS: ç²¾ç®€ä¹‹åçš„è¾“å‡º
#+begin_example
>>> <script> è§£æåçš„ç±»å‹
script
>>> export default è§£æåçš„ç±»å‹
ExportDefaultDeclaration
>>> { props : ... } è§£æåçš„ ast åŒ…å«çš„ keys
[
  'type',
  'start',
  'end',
  'loc',
  'range',
  'leadingComments',
  'trailingComments',
  'innerComments',
  'extra',
  'properties'
]
> properties ä¸º ObjectExpression å¯¹è±¡çš„æˆå‘˜åˆ—è¡¨ï¼Œå¦‚ï¼š props
{
  type: 'ObjectProperty',
  key: Node {
    type: 'Identifier',
    name: 'props'
  },
  value: Node {
    type: 'ArrayExpression',
    elements: [ [Node], [Node] ]
  }
}
[
  Node {
    type: 'StringLiteral',
    extra: { rawValue: 'foo', raw: "'foo'" },
    value: 'foo'
  },
  Node {
    type: 'StringLiteral',
    extra: { rawValue: 'bar', raw: "'bar'" },
    value: 'bar'
  }
]
#+end_example

** 819a413 export default {} è§£æ

[[https://github.com/gcclll/stb-vue-next/commit/819a413020da1584de0c73b7f67ed0aec0d9cb86][feat(add): sfc->script, parse export default members into bindings Â· gcclll/stb-vue-next@819a413]]

~(property.type === 'ObjectMethod' &&property.key.type === 'Identifier' &&(property.key.name === 'setup' || property.key.name === 'data'))~

æˆå‘˜æœ€ååœ¨ ~bindings~ é‡Œé¢å­˜åœ¨ç±»å‹å€¼ï¼š
| name       | type(~BindingTypes~) | value             |
|------------+----------------------+-------------------|
| ~props~    | 'PROPS'              | 'props'           |
| ~inject~   | 'PROPS'              | 'props'           |
| ~computed~ | 'OPTIONS'            | 'options'         |
| ~methods~  | 'OPTIONS'            | 'options'         |
|------------+----------------------+-------------------|
| ~setup~    | SETUP_MAYBE_REF      | 'setup-maybe-ref' |
| ~data~     | SETUP_MAYBE_REF      | 'setup-maybe-ref' |
|            |                      |                   |

åˆ°è¿™é‡Œè¿˜åªæ˜¯å€ŸåŠ© ~@babel/parser~ è¿›è¡Œäº†è§£æï¼Œvue è‡ªèº«çš„ä¸€äº›ç‰¹æ€§å¤„ç†åœ¨
~analyzeScriptBindings()~ ä¸­ï¼Œè¿™ä¸ªå‡½æ•°è§£æçš„ç±»å‹æ˜¯ ~ExportDefaultDeclaration~ ä¹Ÿ
å°±æ˜¯ ~export default {}~ çš„ä»£ç éƒ¨åˆ†ã€‚


ç„¶åè°ƒç”¨ ~analyzeBindingsFromOptions(node.declaration)~ è§£æå¯¹è±¡æˆå‘˜ï¼Œè¿™é‡Œè¦å¤„ç†
çš„ä¸»è¦æœ‰ä¸¤ç§ï¼š

1. ~ObjectProperty~ å±æ€§ç±»å‹æˆå‘˜

   ~(property.type === 'ObjectProperty' &&!property.computed &&property.key.type === 'Identifier')~

   #+begin_src js
const { compileScript, parse } =
  require(process.env.VNEXT_PKG_SFC + '/dist/compiler-sfc.cjs.js')
const { log } = require(process.env.BLOG_JS + '/utils.js')
const compile = (src, options) => {
  const { descriptor } = parse(src)
  return compileScript(descriptor, { ...options, id: 'xxxx' })
}

const res = compile(`
<script>
  export default {
    props: ['firstName', 'secondName'],
    inject: { foo: {} },
    computed: {
      fullName() {
        return this.firstName + this.secondName + this.thirdName
      }
    },
    methods: {
      getName() {
        return this.fullName
      }
    }
  }
</script>
`)

console.log(res.bindings)
   #+end_src

   #+RESULTS:
   : {
   :   firstName: 'props',
   :   secondName: 'props',
   :   foo: 'options',
   :   fullName: 'options',
   :   getName: 'options'
   : }
   : undefined

2. ~ObjectMethod~ æ–¹æ³•ç±»å‹æˆå‘˜ï¼Œä¸”åªå¤„ç† ~setup~ å’Œ ~data~ æ–¹æ³•

   [[https://github.com/gcclll/stb-vue-next/commit/c7b617bdad949c6db98ab6eb71caa00dbc7dec26][feat(add): sfc->script, parse export default data&setup into bingdings Â· gcclll/stb-vue-next@c7b617b]]

   éœ€è¦å¢åŠ ä»£ç ï¼š
   #+begin_src typescript
   if (
      property.type === 'ObjectMethod' &&
      property.key.type === 'Identifier' &&
      (property.key.name === 'setup' || property.key.name === 'data')
    ) {
      for (const bodyItem of property.body.body) {
        // setup() {
        //   return {
        //     foo: null
        //   }
        // }
        if (
          bodyItem.type === 'ReturnStatement' &&
          bodyItem.argument &&
          bodyItem.argument.type === 'ObjectExpression'
        ) {
          for (const key of getObjectExpressionKeys(bodyItem.argument)) {
            bindings[key] = property.key.name = 'setup'
              ? BindingTypes.SETUP_MAYBE_REF
              : BindingTypes.DATA
          }
        }
      }
    }
   #+end_src

   æµ‹è¯•ï¼š
   #+begin_src js
const { compileScript, parse } =
  require(process.env.VNEXT_PKG_SFC + '/dist/compiler-sfc.cjs.js')
const { log } = require(process.env.BLOG_JS + '/utils.js')
const compile = (src, options) => {
  const { descriptor } = parse(src)
  return compileScript(descriptor, { ...options, id: 'xxxx' })
}

const code = `
<script>
export default {
  setup() {
    return {
      foo: null
    }
  },
  data() {
    return {
      bar: null
    }
  },
  props: ['baz']
}
</script>`
const res = compile(code)
log(res.bindings)
   #+end_src

   #+RESULTS:
   : { foo: 'setup-maybe-ref', bar: 'setup-maybe-ref', baz: 'props' }
   : undefined
** æµ‹è¯•

#+begin_src js
const { compileScript, parse } =
  require(process.env.VNEXT_PKG_SFC + '/dist/compiler-sfc.cjs.js')
const { log } = require(process.env.BLOG_JS + '/utils.js')
const compile = (src, options) => {
  const { descriptor } = parse(src)
  return compileScript(descriptor, { ...options, id: 'xxxx' })
}

log(`>>> setup return`)
log(compile(`
<script>
const bar = 2
  export default {
    setup() {
    return {
        foo: 1,
        bar
    }
  }
}
</script>`).bindings)
log(`>>> async setup return`)
log(compile(`
<script>
const bar = 2
  export default {
    async setup() {
      return {
        foo: 1,
        bar
      }
  }
}
</script>`).bindings)
log(`>>> computeds`)
log(compile(`
    <script>
    export default {
      computed: {
        foo() {},
        bar: {
            get() {},
            set() {},
        }
      }
    }
    </script>
`).bindings)
log(`>>> æ··åˆ bindings`)
log(compile(`
    <script>
    export default {
      inject: ['foo'],
        props: {
        bar: String,
      },
      setup() {
        return {
            baz: null,
        }
      },
      data() {
        return {
            qux: null
        }
      },
      methods: {
        quux() {}
      },
      computed: {
        quuz() {}
      }
    }
    </script>
`).bindings)
#+end_src

#+RESULTS:
#+begin_example
>>> setup return
{ foo: 'setup-maybe-ref', bar: 'setup-maybe-ref' }
>>> async setup return
{ foo: 'setup-maybe-ref', bar: 'setup-maybe-ref' }
>>> computeds
{ foo: 'options', bar: 'options' }
>>> æ··åˆ bindings
{
  foo: 'options',
  bar: 'props',
  baz: 'setup-maybe-ref',
  qux: 'setup-maybe-ref',
  quux: 'options',
  quuz: 'options'
}
undefined
#+end_example

** 1âƒ£  è§£ææ™®é€šçš„ <script>

#+begin_comment
process normal <script> first if it exists
#+end_comment

ç”¨åˆ°çš„æ’ä»¶ï¼š
| Plugin                |
|-----------------------|
| [[https://babeljs.io/docs/en/babel-parser][@babel/parser Â· Babel]] |
|                       |

è¿™ä¸€èŠ‚ä¸­çš„æ™®é€š <script> å‰ææ˜¯ï¼Œè‡³å°‘æœ‰ä¸€ä¸ª ~<script setup>~ å­˜åœ¨ï¼Œå¦åˆ™ä¼šç›´æ¥åœ¨
[[#script-0][ä¸Šä¸€èŠ‚]] å°±é€€å‡ºè§£æäº†ã€‚

@babel/parser è§£æ import ç»“æœå¯¹ç…§è¡¨
| æ®µ                        | ç±»å‹                | å€¼                                 |
|---------------------------+---------------------+------------------------------------|
| ~import { a } from './x'~ | ~ImportDeclaration~ | ...                                |
| ~a~                       | ~ImportSpecifier~   | ~node.specifiers[i].imported.name~ |
| ~'./x'~                   | ~StringLiteral~     | ~node.source.value~                |

#+begin_src js
const { parse } = require(process.env.BABEL_DIR + '/parser/lib/index.js')

const code = `
import { a } from './x'`
const res = parse(code, { sourceType: 'module' }).program.body
const node = res[0]
const spec = node.specifiers[0]
console.log(`>>> node type > ${node.type}`)
console.log(`>>> node source type > ${node.source.type}`)
console.log(`>>> node source value > ${node.source.value}`)
console.log(`>>> spec type > ${spec.type}`)
console.log(`>>> spec imported type > ${spec.imported.type}`)
console.log(`>>> spec imported name > ${spec.imported.name}`)
#+end_src

#+RESULTS:
: >>> node type > ImportDeclaration
: >>> node source type > StringLiteral
: >>> node source value > ./x
: >>> spec type > ImportSpecifier
: >>> spec imported type > Identifier
: >>> spec imported name > a

æ‰€ä»¥å°±æœ‰äº†ä¸‹é¢æ–°å¢çš„ä»£ç å¤„ç†é€»è¾‘ï¼š
#+begin_src typescript
// import ... from './x' è¯­å¥ç±»å‹
if (node.type === 'ImportDeclaration') {
      // record imports for dedupe
  // import è¿›æ¥çš„å˜é‡åˆ—è¡¨
  for (const specifier of node.specifiers) {
    // å˜é‡å
    const imported =
      specifier.type === 'ImportSpecifier' &&
      specifier.imported.type === 'Identifier' &&
      specifier.imported.name
    // æ³¨å†Œåˆ° userImports[local] = { isType, imported, source } ä¸­
    registerUserImport(
      node.source.value,
      specifier.local.name,
      imported,
      node.importKind === 'type'
    )
  }
}
#+end_src

æµ‹è¯•ï¼š
#+begin_src js

const {
  compileScript,
  parse
} = require(process.env.VNEXT_PKG_CS + '/dist/compiler-sfc.cjs.js')

const res = compileScript(`
<script>
import { a } from './x'
</script>
`, { id: 'xxx' })
console.log(res)
#+end_src

#+RESULTS:
