#+TITLE: Vue3 源码头脑风暴之 7 ☞ runtime-core(1)
#+DATE: <2021-01-08 10:12:32>
#+TAGS[]: vue, vue3, runtime-core
#+CATEGORIES[]: vue
#+LANGUAGE: zh-cn
#+STARTUP: indent shrink


#+begin_export html
<link href="https://fonts.goo~gleapis.com/cs~s2?family=ZCOOL+XiaoWei&display=swap" rel="stylesheet">
<kbd>
<font color="blue" size="3" style="font-family: 'ZCOOL XiaoWei', serif;">
  诗号：六道同坠，魔劫万千，引渡如来。
</font>
</kbd><br><br>
#+end_export

[[/img/bdx/yiyeshu-001.jpg]]

@@html:<kbd>@@
*[[https://github.com/gcclll/stb-vue-next][stb-vue-next]] 完全拷贝于 [[https://github.com/vuejs/vue-next][vue-next]] ，主要目的用于学习。*
@@html:</kbd>@@

#+begin_quote
*声明* ：vue-next runtime-core 运行时核心代码，这部分内容较多，可能会分为几篇来
叙述, ~f~ 过滤掉对象空值属性。

*更新日志&Todos* ：
1. [2021-01-08 10:12:50] 创建
2. DONE [2021-01-15 10:24:00] scheduler
3. TODO apiWatch -> post cb & ssr
4. TODO STATEFUL_COMONENT
5. TODO patchFlag 测试和用途
6. TODO transformVNodeArgs
7. TODO Suspense 组件
8. TODO shouldTrack, currentBlock 和 [[#block-related][block 相关函数]]的作用
#+end_quote

模块初始化： [[https://github.com/gcclll/stb-vue-next/commit/b22b4db3506bf1ba4b266dcf9ff21f1e0b925a81][feat(init): runtime-core · gcclll/stb-vue-next@b22b4db · GitHub]]

[[/img/vue3/runtime-core/vue-runtime-core.svg]]

* Tips
1. class 支持数组(~['foo', 'bar']~)，对象(~{foo:true,bar:false}~)，字符串(~'foo bar'~)
2. style 支持数组(~['color:red', {foo:'foo'}]~)，对象(~{color:'red',foo:'foo'}~)，字符串(~color:red~)
3. class component 条件：
   1) function
   2) 含 ~__vccOpts = { template: '<div />'}~
4. [[#test-vnode-ref][vnode ref 属性合并处理逻辑？]]
5. [[#test-vnode-key][vnode key 属性简单的值覆盖操作？]]
6. [[#scheduler][scheduler, vue-next 中的任务调度器如何实现？]]
7. [[#api-watch][api watch(source, cb, option)]] 中的 source 只能是 ~reactive/ref/function/array~ 类型，
   如果是数组时其元素只能是 ~reactive/ref/function~
8. [[#api-watch-deep][api watch(..., { deep: true }) 是如何做到深度监听的？]]
9. [[#watch-shallow-ref][api watch(shallowRef, /*cb*/ (newVal) => {}) 是如何直接使用 newVal.a 的？]]

   #+begin_src js
   var obj = shallowRef({ a: 0 });
   watch(shallowRef, (newVal) => {
     dummy = newVal.a; // 这里为什么可以直接访问 obj.a，obj 又是什么？
   });
   #+end_src
* init

导出已完成模块(reactiviy)里的 Apis:
[[https://github.com/gcclll/stb-vue-next/commit/38e91a877635b51b56a2918ff173a48638b8760a][feat(init): runtime-core> add exports from @vue/reactivity · gcclll/stb-vue-next@38e91a8 · GitHub]]

这部分代码有点多，所以这里事先将所有类型定义添加好：

[[https://github.com/gcclll/stb-vue-next/commit/e3f7b94ef39cf389aaf25f55ea81877941860f56][feat(add): runtime-core>all types · gcclll/stb-vue-next@e3f7b94 · GitHub]]

有关类型定义请移步[[#defines][最后一节]](纯贴代码的，所以放到最后)
* h function

[[https://github.com/gcclll/stb-vue-next/commit/e48d5e28c4e1b55c6d6a326bcf0808047e23ceeb][feat(add): runtime-core>h function · gcclll/stb-vue-next@e48d5e2 · GitHub]]

~h~, render 函数初始化。

#+begin_src typescript
// Actual implementation
export function h(type: any, propsOrChildgen?: any, children?: any): VNode {
  // TODO
  return {} as VNode;
}
#+end_src

实现：
#+begin_src typescript
// Actual implementation
export function h(type: any, propsOrChildgen?: any, children?: any): VNode {
  const l = arguments.length;
  if (l === 2) {
    if (isObject(propsOrChildgen) && !isArray(propsOrChildgen)) {
      // 没有 props 的 单节点(single vnode)
      if (isVNode(propsOrChildgen)) {
        return createVNode(type, null, [propsOrChildgen]);
      }
      // 有 props 没有 children
      return createVNode(type, propsOrChildgen);
    } else {
      // omit props
      return createVNode(type, null, propsOrChildgen);
    }
  } else {
    // 从第三个参数开始全当做孩子节点处理
    if (l > 3) {
      children = Array.prototype.slice.call(arguments, 2);
    } else if (l === 3 && isVNode(children)) {
      children = [children];
    }
    return createVNode(type, propsOrChildgen, children);
  }
}
#+end_src

h, 接受不定参数

逻辑脑图:

[[/img/tmp/20210108152508.png]]

从脑图分支得出支持的情况代码示例：

1. ~h('div')~ 无参数无孩子
2. ~h('div', { id: 'foo' })~ 有 props 无 children
3. ~h('div', ['foo'])~ 数组当做 chilren
4. ~h('div', vnode)~ 有 __v_isVNode 标识当做 children，并转成数组 ~[vnode]~
5. ~h('div', {}, ['foo'])~ 有 props 有 children
6. ~h('div', {}, vnode)~ 有 props, 有 children 且 = ~[vnode]~

接下来需要具体去实现 ~createVNode~ 函数。
* createVNode function

[[https://github.com/gcclll/stb-vue-next/commit/194f72fee239da947ef82a4da099c23c758d3d84][feat(add): rc->createVNode · gcclll/stb-vue-next@194f72f · GitHub]]

这个函数最终是构造了 vnode: VNode 虚拟节点结构，返回。

这里面分为以下几个步骤实现：

1. type 是 vnode 时候处理
2. class 组件处理
3. props 处理
4. shapeFlag 检测，是什么类型 的 vnode
5. 组件对象不应该 reactive(有状态的组件, STATEFUL_COMONENT)
6. 构建 vnode: VNode 对象
7. 检测 vnode.key 是不是 ~NaN~
8. normalize children
9. normalize suspense children
10. currentBlock 处理
11. 返回 vnode 节点

#+begin_src js
// 源文件：/js/vue/lib.js
const {
  rc: { h, createVNode, reactive },
  f,
  log,
} = require(process.env.BLOG_JS + "/vue/lib.js");
const _h = (...args) => f(h(...args));

log([">>> type only\n", _h("div")]);
log([">>> type + props\n", _h("div", { id: "foo" })]);
log([">>> type + omit props\n", _h("div", ["foo"])]);
#+end_src

#+RESULTS:
#+begin_example
>>> type only
 { __v_isVNode: true, __v_skip: true, type: 'div', shapeFlag: 1 }
>>> type + props
 {
  __v_isVNode: true,
  __v_skip: true,
  type: 'div',
  props: { id: 'foo' },
  shapeFlag: 1
}
>>> type + omit props
 { __v_isVNode: true, __v_skip: true, type: 'div', shapeFlag: 1 }
>>> default slot
 {
  __v_isVNode: true,
  __v_skip: true,
  type: { template: '<br />' },
  shapeFlag: 4
}
undefined
#+end_example

** d3c6563 props

[[https://github.com/gcclll/stb-vue-next/commit/d3c656331e3e5a9206f0341dd2ca960a300f96ba][feat(add): rc->createVNode, props · gcclll/stb-vue-next@d3c6563 · GitHub]]

处理 class 和 style 属性。

#+begin_src typescript
 // 3. props 处理, class & style normalization
 if (props) {
   // for reactive or proxy objects, we need to clone it to enable mutation.
   if (isProxy(props) || InternalObjectKey in props) {
     props = extend({}, props);
   }
   let { class: klass, style } = props;
   if (klass && !isString(klass)) {
     // 1. string -> klass
     // 'foo' -> 'foo'
     // 2. array -> '' + arr.join(' ')
     // ['foo', 'bar'] -> 'foo bar'
     // 3. object -> '' + value ? ' value' : ''
     // { foo: true, bar: false, baz: true } -> 'foo baz'
     props.class = normalizeClass(klass);
   }

   if (isObject(style)) {
     // reactive state objects need to be cloned since they are likely to be
     // mutated
     if (isProxy(style) && !isArray(style)) {
       style = extend({}, style);
     }
     // 1. array -> object
     // [{ color: 'red' }, 'font-size:10px;height:100px;'] ->
     // { color: 'red', 'font-size': '10px', height: '100px' }
     // 2. object -> object 原样返回
     props.style = normalizeStyle(style);
   }
 }
#+end_src

1. class 数组，对象，字符串？

   数组： 合并成字符串， ~['foo', 'bar']~ -> 'foo bar'

   对象： 合并成字符串， ~{foo: true, bar: false, baz: true}~ -> 'foo baz'

   字符串： 原样输出

   #+begin_src typescript
   export function normalizeClass(value: unknown): string {
     let res = "";
     if (isString(value)) {
       res = value;
     } else if (isArray(value)) {
       for (let i = 0; i < value.length; i++) {
         res += normalizeClass(value[i]) + " ";
       }
     } else if (isObject(value)) {
       for (const name in value) {
         if (value[name]) {
           res += name + " ";
         }
       }
     }
     return res.trim();
   }
   #+end_src

2. style 数组，对象，字符串？

   数组： 合并成对象， ~['color:red', { 'font-size': '10px', height: '100px' }]~ -> ~{color:
   'red', 'font-size': '10px', height: '100px'}~

   对象： 原样返回

   字符串：解析成对象， 如数组内字符串部分

   #+begin_src typescript
    export function normalizeStyle(value: unknown): NormalizedStyle | undefined {
      if (isArray(value)) {
        const res: Record<string, string | number> = {};
        for (let i = 0; i < value.length; i++) {
          const item = value[i];
          const normalized = normalizeStyle(
            isString(item) ? parseStringStyle(item) : item
          );
          if (normalized) {
            for (const key in normalized) {
              res[key] = normalized[key];
            }
          }
        }
        return res;
      } else if (isObject(value)) {
        return value;
      }
    }
   #+end_src


测试：

#+begin_src js

// 源文件：/js/vue/lib.js
const { rc: { h, createVNode: c }, f, log } = require(process.env.BLOG_JS + '/vue/lib.js')
let _h = (...args) => f(c(...args), 'props')

// class 合并成字符串
log(['>>> class: string\n', _h('p', { class: 'foo baz' })])
log(['>>> class: array\n', _h('p', { class: ['foo', 'baz'] })])
log(['>>> class: array<object|string>\n', _h('p', { class: [{ foo:  'foo' }, 'baz', { baz: 'baz' }] })])
log(['>>> class: object\n', _h('p', { class: {'foo': true, 'baz': false, 'bar': true} })])

// style 合并成对象
log(['>>> style: array\n', _h('p', { style: [{ foo: 'foo' }, { baz: 'baz' }] })])
log(['>>> style: object\n', _h('p', {
  style: { foo: 'foo', baz: 'baz' }
})])
log(['>>> style: array<object|string>\n', _h('p', {
  style: [{ foo: 'foo' }, 'color:red', { baz: 'baz' }]
})])
#+end_src

#+RESULTS:
#+begin_example
>>> class: string
 { props: { class: 'foo baz' } }
>>> class: array
 { props: { class: 'foo baz' } }
>>> class: array<object|string>
 { props: { class: 'foo baz baz' } }
>>> class: object
 { props: { class: 'foo bar' } }
>>> style: array
 { props: { style: { foo: 'foo', baz: 'baz' } } }
>>> style: object
 { props: { style: { foo: 'foo', baz: 'baz' } } }
>>> style: array<object|string>
 { props: { style: { foo: 'foo', color: 'red', baz: 'baz' } } }
undefined
#+end_example
** class component

是类组件前提是：

1. 必须是函数
2. 必须包含 ~__vccOpts~ 属性

#+begin_src typescript
  // 2. class component
  if (isClassComponent(type)) {
    type = type.__vccOpts;
  }

  export function isClassComponent(value: unknown): value is ClassComponent {
    return isFunction(value) && "__vccOpts" in value;
  }
#+end_src

测试：
#+begin_src js

// 源文件：/js/vue/lib.js
const { rc: { h, createVNode: c }, f, log } = require(process.env.BLOG_JS + '/vue/lib.js')
const _h = (...args) => f(c(...args))

class Component {
  $props

  static __vccOpts = { template: '<div />' }
}
log(_h(Component))
#+end_src

#+RESULTS:
: {
:   __v_isVNode: true,
:   __v_skip: true,
:   type: { template: '<div />' },
:   shapeFlag: 4 // STATEFUL_COMPONENT
: }
: undefined

** TODO stateful component & key NaN

有状态的组件？

即 type 为对象时候视为有状态的组件。

如果是 STATEFUL_COMPONENT 且是个 proxy 的时候，开发模式下给出警告⚠️。

#+begin_src js

// 源文件：/js/vue/lib.js
const { rc: { h, createVNode: c, reactive:r }, f, log } = require(process.env.BLOG_JS + '/vue/lib.js')
const _h = (...args) => f(c(...args))

log(_h('div', { key: NaN }))
#+end_src

#+RESULTS:
: {
:   __v_isVNode: true,
:   __v_skip: true,
:   type: 'div',
:   props: { key: NaN },
:   shapeFlag: 1
: }
: undefined

** 88eaf09 type is vnode

[[https://github.com/gcclll/stb-vue-next/commit/88eaf090c3d1767bc4a1ca576eef449abf7d62d2][feat(add): rc->createVNode, type is vnode · gcclll/stb-vue-next@88eaf09 · GitHub]]

#+begin_src typescript
  // > in createVNode
  // 1. type is vnode
  if (isVNode(type)) {
    // createVNode receiving an existing vnode. This happens in cases like
    // <component :is="vnode"/>
    // #2078 make sure to merge refs during the clone instead of overwriting it
    const cloned = cloneVNode(type, props, true /* mergeRef: true */);
    if (children) {
      normalizeChildren(cloned, children);
    }
    return cloned;
  }

  // cloneVNode
  // 省略直接取 vnode 值部分
  export function cloneVNode<T, U>(
    vnode: VNode<T, U>,
    extraProps?: (Data & VNodeProps) | null,
    mergeRef = false
  ): VNode<T, U> {
    // This is intentionally NOT using spread or extend to avoid the runtime
    // key enumeration cost.
    const { props, ref, patchFlag } = vnode;
    const mergedProps = extraProps ? mergeProps(props || {}, extraProps) : props;
    return {
      __v_isVNode: true,
      [ReactiveFlags.SKIP]: true,
      type: vnode.type,
      props: mergedProps,
      key: mergedProps && normalizeKey(mergedProps),
      ref:
        extraProps && extraProps.ref
          ? // #2078 in the case of <component :is="vnode" ref="extra"/>
            // if the vnode itself already has a ref, cloneVNode will need to merge
            // the refs so the single vnode can be set on multiple refs
            mergeRef && ref
            ? isArray(ref)
              ? ref.concat(normalizeRef(extraProps)!)
              : [ref, normalizeRef(extraProps)!]
            : normalizeRef(extraProps)
          : ref,
      // if the vnode is cloned with extra props, we can no longer assume its
      // existing patch flag to be reliable and need to add the FULL_PROPS flag.
      // note: perserve flag for fragments since they use the flag for children
      // fast paths only.
      patchFlag:
        extraProps && vnode.type !== Fragment
          ? patchFlag === -1 // hoisted node
            ? PatchFlags.FULL_PROPS
            : patchFlag | PatchFlags.FULL_PROPS
          : patchFlag,

      ssContent: vnode.ssContent && cloneVNode(vnode.ssContent),
      ssFallback: vnode.ssFallback && cloneVNode(vnode.ssFallback),
    };
  }
#+end_src

cloneVNode 绝大部分属性都是直接引用自 vnode，上面列出的都是需要处理的属性，比如：

1. props 会将 vnode 和 cloneVNode 传入的 props 进行合并，并且是传入的 props 覆盖 vnode.props。
2. key 属性，取合并之后的 key([[#test-vnode-key][测试->]])

   #+begin_src typescript
    // normalize 合并后的 key
    const key = mergedProps && normalizeKey(mergedProps);

    const normalizeKey = ({ key }: VNodeProps): VNode["key"] =>
      key != null ? key : null;
   #+end_src
3. ref 属性，合并规则([[#test-vnode-ref][测试->]])：

   #+begin_src typescript
    // 1. mergeRef: boolean 可以手动指定是否需要合并
    // 2. extraProps.ref 调用 cloneVNode 时候传入的 props ref
    // 3. ref 如果是数组，加上新的 ref 扩展原数组
    // 4. ref 不是数组，用 ref 和 extra ref 合并成新数组
    // 5. 如果 ref null, 则直接用 extra ref normalize 出新的 ref
    const ref =
      extraProps && extraProps.ref
        ? // #2078 in the case of <component :is="vnode" ref="extra"/>
          // if the vnode itself already has a ref, cloneVNode will need to merge
          // the refs so the single vnode can be set on multiple refs
          mergeRef && ref
          ? isArray(ref)
            ? ref.concat(normalizeRef(extraProps)!)
            : [ref, normalizeRef(extraProps)!]
          : normalizeRef(extraProps)
        : ref;

    // normalization
    const normalizeRef = ({ ref }: VNodeProps): VNodeNormalizedRefAtom | null => {
      return (ref != null
        ? isString(ref) || isRef(ref) || isFunction(ref)
          ? { i: currentRenderingInstance, r: ref }
          : ref
        : null) as any;
    };
   #+end_src
4. patchFlag 属性([[#test-vnode-patchflag][测试->]])

   #+begin_src typescript
    const patchFlag =
      extraProps && vnode.type !== Fragment
        ? patchFlag === -1 // hoisted node
          ? PatchFlags.FULL_PROPS
          : patchFlag | PatchFlags.FULL_PROPS
        : patchFlag;
   #+end_src
5. ssContent 递归调用 ~cloneVNode(vnode.ssContent)~
6. ssFallback 递归调用 ~cloneVNode(vnode.ssFallback)~


测试：
#+begin_src js
// 源文件：/js/vue/lib.js
const {
  rc: { h, createVNode: c, cloneVNode: cv },
  f,
  log,
} = require(process.env.BLOG_JS + "/vue/lib.js");
const _h = (...args) => f(c(...args));

const node1 = _h("div", { foo: 1 }, null /* children */);
log([">>> vnode 1\n", node1]);

const node2 = _h({}, null, [node1]);
const cloned2 = cv(node2);
// cloneVNode 只是一次浅拷贝
log([">>> node2 == cloned2\n", f(cloned2), "\n > node2 \n", node2]);
#+end_src

#+RESULTS:
#+begin_example
>>> vnode 1
 {
  __v_isVNode: true,
  __v_skip: true,
  type: 'div',
  props: { foo: 1 },
  shapeFlag: 1
}
>>> node2 == cloned2
 {
  __v_isVNode: true,
  __v_skip: true,
  type: {},
  children: [
    {
      __v_isVNode: true,
      __v_skip: true,
      type: 'div',
      props: [Object],
      shapeFlag: 1
    }
  ],
  shapeFlag: 20
}
 > node2
 {
  __v_isVNode: true,
  __v_skip: true,
  type: {},
  children: [
    {
      __v_isVNode: true,
      __v_skip: true,
      type: 'div',
      props: [Object],
      shapeFlag: 1
    }
  ],
  shapeFlag: 20
}
undefined
#+end_example

[[https://github.com/gcclll/stb-vue-next/commit/4fbd98f4be00f3fdfcb14839d29ed4a5f45a179c][feat(add): rc->createVNode, currentRenderingInstance · gcclll/stb-vue-next@4fbd98f · GitHub]]

*** key test
:PROPERTIES:
:COLUMNS: %CUSTOM_ID[(Custom Id)]
:CUSTOM_ID: test-vnode-key
:END:

vnode.key 的 clone 操作，属于单纯的值覆盖操作。

#+begin_src js
// 源文件：/js/vue/lib.js
const {
  rc: { h, createVNode: c, cloneVNode: cv },
  f,
  log,
} = require(process.env.BLOG_JS + "/vue/lib.js");
const _h = (...args) => f(c(...args));

log([">>> 保留 vnode.key 值\n", f(cv(c("div", { key: 1 })), "key")]);
log([
  ">>> 替换 vnode.key 值\n",
  f(cv(c("div", { key: 1 }), { key: 2 }), "key"),
]);
log([">>> 新 props.key 值\n", f(cv(c("div"), { key: 2 }), "key")]);

log(">>> 测试 vnode.key 各种情况值");
for (const key of ["", "a", 0, 1, NaN]) {
  log(f(c("div", { key }), "key"));
}
#+end_src

#+RESULTS:
#+begin_example
>>> 保留 vnode.key 值
 { key: 1 }
>>> 替换 vnode.key 值
 { key: 2 }
>>> 新 props.key 值
 { key: 2 }
>>> 测试 vnode.key 各种情况值
{}
{ key: 'a' }
{}
{ key: 1 }
[Vue warn]: VNode created with invalid key (NaN). VNode type:div
{}
undefined
#+end_example

*** ref test
:PROPERTIES:
:COLUMNS: %CUSTOM_ID[(Custom Id)]
:CUSTOM_ID: test-vnode-ref
:END:

流程脑图：
[[/img/vue3/runtime-core/vue-runtime-core-vnode-ref.svg]]

测试
#+begin_src js
// 源文件：/js/vue/lib.js
const {
  rc: {
    h,
    createVNode: c,
    cloneVNode: cv,
    ssrUtils: { setCurrentRenderingInstance: s },
  },
  f,
  log,
} = require(process.env.BLOG_JS + "/vue/lib.js");
const _h = (...args) => f(c(...args));

const mockIns1 = { ins: 1 },
  mockIns2 = { ins: 2 };
s(mockIns1);

let original = c("div", { ref: "foo" });
// 本身没有的时候会将 extraProps.ref 作为新的 vnode.ref 值
log([">>> 1. vnode 本身无 ref\n", f(original, "ref")]);
let cloned1 = cv(original);
log([">>> 2. 保留原有的 vnode.ref\n", f(cloned1, "ref")]);
// 这里没指定 mergeProp 所以会替换原来的
let cloned2 = cv(original, { ref: "bar" });
log(['>>> 3. ref: "bar" 替换原有的 vnode.ref\n', f(cloned2, "ref")]);
let original2 = c("div");
let cloned3 = cv(original2, { ref: "bar" });
log([">>> 4. 没有 vnode.ref 情况，新增 ref\n", f(cloned3, "ref")]);

s(mockIns2);
// 应该保留原有的 context instance
let cloned4 = cv(original);
log([">>> 5. 应该保留原有的 context instance\n", f(cloned4, "ref")]);
// ref 覆盖，使用新的 context instance: mockIns2
let cloned5 = cv(original, { ref: "bar" });
log([">>> 6. ref 改变，使用新的 context instance\n", f(cloned5, "ref")]);
s(null); // 置空 context instance

log('\n\n// mergeRef 情况测试\n')
s(mockIns1)
original = c('div', { ref: 'foo' })
s(mockIns2)
cloned1 = cv(original, { ref: 'bar' }, true)
log(['>>> mergeRef: true 合并 vnode.ref\n', f(cloned1, 'ref')])
log(cloned1.ref[0])
log(cloned1.ref[1])
#+end_src

#+RESULTS:
#+begin_example
>>> 1. vnode 本身无 ref
 { ref: { i: { ins: 1 }, r: 'foo' } }
>>> 2. 保留原有的 vnode.ref
 { ref: { i: { ins: 1 }, r: 'foo' } }
>>> 3. ref: "bar" 替换原有的 vnode.ref
 { ref: { i: { ins: 1 }, r: 'bar' } }
>>> 4. 没有 vnode.ref 情况，新增 ref
 { ref: { i: { ins: 1 }, r: 'bar' } }
>>> 5. 应该保留原有的 context instance
 { ref: { i: { ins: 1 }, r: 'foo' } }
>>> 6. ref 改变，使用新的 context instance
 { ref: { i: { ins: 2 }, r: 'bar' } }


// mergeRef 情况测试

>>> mergeRef: true 合并 vnode.ref
 { ref: [ { i: [Object], r: 'foo' }, { i: [Object], r: 'bar' } ] }
{ i: { ins: 1 }, r: 'foo' }
{ i: { ins: 2 }, r: 'bar' }
undefined
#+end_example
*** TODO patchFlag test
:PROPERTIES:
:COLUMNS: %CUSTOM_ID[(Custom Id)]
:CUSTOM_ID: test-vnode-patchflag
:END:

TODO need openBlock&createBlock support.

#+begin_src js
// 源文件：/js/vue/lib.js
const {
  rc: {
    h,
    createVNode: c,
    cloneVNode: cv,
    ssrUtils: { setCurrentRenderingInstance: s },
  },
  f,
  log,
} = require(process.env.BLOG_JS + "/vue/lib.js");
const _h = (...args) => f(c(...args));

const hoist = c('div') // 静态节点
let vnode1
const vnode = (openBlock(), createBlock('div'))
#+end_src
*** shapeFlag test

#+begin_src js
// 源文件：/js/vue/lib.js
const {
  rc: { h, createVNode: c, cloneVNode: cv, Text },
  f,
  log,
} = require(process.env.BLOG_JS + "/vue/lib.js");
const _h = (...args) => f(c(...args));

log([">>> ELEMENT\n", f(c("div"), "shapeFlag")]);
log([">>> STATEFUL_COMONENT\n", f(c({}), "shapeFlag")]);
log([
  ">>> FUNCTION_COMONENT\n",
  f(
    c(() => {}),
    "shapeFlag"
  ),
]);
log([">>> Text\n", f(c(Text), "shapeFlag")]);
#+end_src

#+RESULTS:
: >>> ELEMENT
:  { shapeFlag: 1 }
: >>> STATEFUL_COMONENT
:  { shapeFlag: 4 }
: >>> FUNCTION_COMONENT
:  { shapeFlag: 2 }
: >>> Text
:  { shapeFlag: 0 }
: undefined
*** mergeProps test

#+begin_src js
// 源文件：/js/vue/lib.js
const {
  rc: { h, createVNode: c, cloneVNode: cv, Text, mergeProps },
  f,
  log,
} = require(process.env.BLOG_JS + "/vue/lib.js");

let p1 = { class: "c" };
let p2 = { class: ["cc"] };
let p3 = { class: [{ ccc: true }] };
let p4 = { class: { cccc: true } };
log([">>> merge class\n", mergeProps(p1, p2, p3, p4)]);
let ps1 = {
  style: { color: "red", fontSize: 10 },
};
let ps2 = {
  style: [
    { color: "blue", width: "200px" },
    {
      width: "300px",
      height: "300px",
      fontSize: 30,
    },
  ],
};
let ps3 = { style: 'width:100px;right:10;top:10' }
log([">>> merge style\n", mergeProps(ps1, ps2, ps3)]);
let clickHandler1  = function(){}
let clickHandler2  = function(){}
let focusHandler3  = function(){}
let ph1 = { onClick: clickHandler1 }
let ph2 = { onClick: clickHandler2, onFocus: focusHandler3 }
log(['>>> merge handlers\n', mergeProps(ph1, ph2)])
#+end_src

#+RESULTS:
#+begin_example
>>> merge class
 { class: 'c cc ccc cccc' }
>>> merge style
 {
  style: {
    color: 'blue',
    fontSize: 30,
    width: '100px',
    height: '300px',
    right: '10',
    top: '10'
  }
}
>>> merge handlers
 {
  onClick: [ [Function: clickHandler1], [Function: clickHandler2] ],
  onFocus: [Function: focusHandler3]
}
undefined
#+end_example
*** TODO dynamic children test

> need openBlock&createBlock support

#+begin_src js
const {
  rc: { h, createVNode: c, cloneVNode: cv, Text, mergeProps },
  f,
  log,
} = require(process.env.BLOG_JS + "/vue/lib.js");

const hoist = createVNode('div')
let vnode1
#+end_src
*** TODO transformVNodeArgs test
** TODO 7ec1d30 suspense component

[[https://github.com/gcclll/stb-vue-next/commit/7ec1d3053a5881d476e535923edce07f36fe77f0][feat(add): rc->createVNode, type is suspense component · gcclll/stb-vue-next@7ec1d30 · GitHub]]

Suspense 的 children 必须有且只有一个根节点。

#+begin_src typescript
  // 7. normalize suspense children
  if (__FEATURE_SUSPENSE__ && shapeFlag & ShapeFlags.SUSPENSE) {
    const { content, fallback } = normalizeSuspenseChildren(vnode);
    vnode.ssContent = content;
    vnode.ssFallback = fallback;
  }

  // normalizeSuspenseChildren
  export function normalizeSuspenseChildren(
    vnode: VNode
  ): {
    content: VNode;
    fallback: VNode;
  } {
    const { shapeFlag, children } = vnode;
    let content: VNode, fallback: VNode;

    if (shapeFlag & ShapeFlags.SLOTS_CHILDREN) {
      content = normalizeSuspenseSlot((children as Slots).default);
      fallback = normalizeSuspenseSlot((children as Slots).fallback);
    } else {
      content = normalizeSuspenseSlot(children as VNodeChild);
      fallback = normalizeVNode(null);
    }

    return {
      content,
      fallback,
    };
  }

// >>> normalizeSuspenseSlot
function normalizeSuspenseSlot(s: any) {
  if (isFunction(s)) {
    s = s()
  }
  if (isArray(s)) {
    // ROOT 必须是单节点 <div>...</div>
    const singleChild = filterSingleRoot(s)
    if (__DEV__ && !singleChild) {
      warn(`<Suspense> slots expect a single root node.`)
    }
    s = singleChild
  }
  return normalizeVNode(s)
}

// normalizeVNode
export function normalizeVNode(child: VNodeChild): VNode {
  if (child == null || typeof child === 'boolean') {
    // empty placeholder
    return createVNode(Comment)
  } else if (isArray(child)) {
    // fragment
    return createVNode(Fragment, null, child)
  } else if (typeof child === 'object') {
    // already vnode, this should be the most common since compiled templates
    // always produce all-vnode children arrays
    // 这是最常用的情况，因为使用模板的时候最后生成的 children 是数组
    return child.el === null ? child : cloneVNode(child)
  } else {
    // strings and numbers
    return createVNode(Text, null, String(child))
  }
}
#+end_src

检测是不是 single root 函数： ~filterSingleRoot~
#+begin_src typescript
export function filterSingleRoot(
  children: VNodeArrayChildren
): VNode | undefined {
  let singleRoot;
  for (let i = 0; i < children.length; i++) {
    const child = children[i];
    if (isVNode(child)) {
      // ignore user comment
      if (child.type !== Comment || child.children === "v-if") {
        if (singleRoot) {
          // has more than 1 non-comment child, return now

          return;
        } else {
          singleRoot = child;
        }
      }
    } else {
      return;
    }
  }
  return singleRoot;
}
#+end_src
** TODO 23fc943 currentBlock 优化
:PROPERTIES:
:COLUMNS: %CUSTOM_ID[(Custom Id)]
:CUSTOM_ID: vnode-currentBlock
:END:

[[https://github.com/gcclll/stb-vue-next/commit/23fc9437e9fba7bb562f79a51410ef59e6b82f8c][feat(add): rc->createVNode, optimize diff, currentBlock ·
gcclll/stb-vue-next@23fc943 · GitHub]]

#+begin_quote
这里的处理没怎么搞明白❓
#+end_quote

注意这里增加的几个变量‼

blockStack, currentBlock:
#+begin_src typescript

// Since v-if and v-for are the two possible ways node structure can dynamically
// change, once we consider v-if branches and each v-for fragment a block, we
// can divide a template into nested blocks, and within each block the node
// structure would be stable. This allows us to skip most children diffing
// and only worry about the dynamic nodes (indicated by patch flags).
// 针对 v-if, v-for 动态性做的由于，减少对静态节点的 diff ，只需要关心动态节点即可
export const blockStack: (VNode[] | null)[] = []
let currentBlock: VNode[] | null = null
#+end_src

shouldTrack:
#+begin_src typescript
// Whether we should be tracking dynamic child nodes inside a block.
// Only tracks when this value is > 0
// We are not using a simple boolean because this value may need to be
// incremented/decremented by nested usage of v-once (see below)
// 是否应该 tracking block 内动态的孩子节点
let shouldTrack = 1;
#+end_src

新增处理逻辑：
#+begin_src typescript
 // 8. currentBlock
 if (
   shouldTrack > 0 &&
   // 避免 block 节点 tracking 自己
   !isBlockNode &&
   // has current parent block
   currentBlock &&
   // presence of a patch flag indicates this node needs patching on updates.
   // component nodes also should always be patched, because even if the
   // component doesn't need to update, it needs to persist the instance on to
   // the next vnode so that it can be properly unmounted later.
   (patchFlag > 0 || shapeFlag & ShapeFlags.COMPONENT) &&
   // the EVENTS flag is only for hydration and if it is the only flag, the
   // vnode should not be considered dynamic due to handler caching.
   patchFlag !== PatchFlags.HYDRATE_EVENTS
 ) {
   currentBlock.push(vnode);
 }
#+end_src

跟这几个变量有关的函数：
* TODO block related(open/close/create)
:PROPERTIES:
:COLUMNS: %CUSTOM_ID[(Custom Id)]
:CUSTOM_ID: block-related
:END:

[[https://github.com/gcclll/stb-vue-next/commit/a2afc70cc89fc0bb7c1b1f6810bea73ab4e40c82][feat(add): rc->block related, open/create/closeBlock · gcclll/stb-vue-next@a2afc70 · GitHub]]

这里的所有函数都和 [[#vnode-currentBlock][createVNode 里面的 currentBlock]] 有关。

openBlock:
#+begin_src typescript
/**
 ,* Open a block.
 ,* This must be called before `createBlock`. It cannot be part of `createBlock`
 ,* because the children of the block are evaluated before `createBlock` itself
 ,* is called. The generated code typically looks like this:
 ,*
 ,* ```js
 ,* function render() {
 ,*   return (openBlock(),createBlock('div', null, [...]))
 ,* }
 ,* ```
 ,* disableTracking is true when creating a v-for fragment block, since a v-for
 ,* fragment always diffs its children.
 ,*
 ,* @private
 ,*/
export function openBlock(disableTracking = false) {
  blockStack.push((currentBlock = disableTracking ? null : []));
}
#+end_src

closeBlock:
#+begin_src typescript
export function closeBlock() {
  blockStack.pop();
  currentBlock = blockStack[blockStack.length - 1] || null;
}
#+end_src

setBlockTracking:
#+begin_src typescript
/**
 * Block tracking sometimes needs to be disabled, for example during the
 * creation of a tree that needs to be cached by v-once. The compiler generates
 * code like this:
 *
 * ``` js
 * _cache[1] || (
 *   setBlockTracking(-1),
 *   _cache[1] = createVNode(...),
 *   setBlockTracking(1),
 *   _cache[1]
 * )
 * ```
 *
 * @private
 */
export function setBlockTracking(value: number) {
  shouldTrack += value
}
#+end_src

createBlock:
#+begin_src typescript
/**
 * Create a block root vnode. Takes the same exact arguments as `createVNode`.
 * A block root keeps track of dynamic nodes within the block in the
 * `dynamicChildren` array.
 *
 * @private
 */
export function createBlock(
  type: VNodeTypes | ClassComponent,
  props?: Record<string, any> | null,
  children?: any,
  patchFlag?: number,
  dynamicProps?: string[]
): VNode {
  const vnode = createVNode(
    type,
    props,
    children,
    patchFlag,
    dynamicProps,
    true /* isBlock: prevent a block from tracking itself */
  );
  // save current block children on the block vnode
  vnode.dynamicChildren = currentBlock || (EMPTY_ARR as any);
  // close block
  closeBlock();
  // a block is always going to be patched, so track it as a child of its
  // parent block
  if (shouldTrack > 0 && currentBlock) {
    currentBlock.push(vnode);
  }
  return vnode;
}
#+end_src

相关脑图：
[[/img/vue3/runtime-core/vue-runtime-core-block-shouldtrack.svg]]

* normalizeChildren function

shapeFlag 初始值检测：
#+begin_src typescript
// encode the vnode type information into a bitmap
const shapeFlag = isString(type)
  ? ShapeFlags.ELEMENT // 1
  : __FEATURE_SUSPENSE__ && isSuspense(type)
  ? ShapeFlags.SUSPENSE // 1 << 7, 128
  : isTeleport(type)
  ? ShapeFlags.TELEPORT // 1 << 6, 64
  : isObject(type)
  ? ShapeFlags.STATEFUL_COMPONENT // 1 << 2, 4
  : isFunction(type)
  ? ShapeFlags.FUNCTIONAL_COMPONENT // 1 << 1, 2
  : 0;
#+end_src

测试:
#+begin_src js
// 源文件：/js/vue/lib.js
const { rc: { h, createVNode: c }, f, log } = require(process.env.BLOG_JS + '/vue/lib.js')
const _h = (...args) => f(c(...args))

log(['>>> only tag\n', _h('p')])
log(['>>> tag + props\n', _h('p', { foo: 'foo' })])
log(['>>> tag + props + children\n', _h('p', { foo: 'foo' }, ['foo'])])
#+end_src

#+RESULTS:
#+begin_example
>>> only tag
 { __v_isVNode: true, __v_skip: true, type: 'p', shapeFlag: 1 }
>>> tag + props
 {
  __v_isVNode: true,
  __v_skip: true,
  type: 'p',
  props: { foo: 'foo' },
  shapeFlag: 1
}
>>> tag + props + children
 {
  __v_isVNode: true,
  __v_skip: true,
  type: 'p',
  props: { foo: 'foo' },
  children: [ 'foo' ],
  shapeFlag: 17
}
undefined
#+end_example

** children is function

[[https://github.com/gcclll/stb-vue-next/commit/28d4a55250c6f02264bbb77ca04a87770d358c7c][feat(add): rc->propsOrChildren is function · gcclll/stb-vue-next@28d4a55 · GitHub]]

如果是函数，当做 slot 的 children 处理。

normalizeChildren:
#+begin_src typescript
export function normalizeChildren(vnode: VNode, children: unknown) {
  let type = 0
  if (children == null) {
    children = null
  } else if (false /*array*/) {
    // TODO
  } else if (false /*object*/) {
    // TODO
  } else if (isFunction(children)) {
    // 如果是函数当做 slot children ?
    children = { default: children, _ctx: currentRenderingInstance }
    type = ShapeFlags.SLOTS_CHILDREN
  } else {
    // TODO 普通类型
  }

  vnode.children = children as VNodeNormalizedChildren
  vnode.shapeFlag |= type
}
#+end_src

测试：
#+begin_src js

// 源文件：/js/vue/lib.js
const { rc: { h, createVNode:c }, log, f } = require(process.env.BLOG_JS + '/vue/lib.js')
const _h = (...args) => f(h(...args));
const _c = (...args) => f(c(...args));

const Component = { template: '<br />' }
const slot = () => {}
log(['>>> default slot\n', _h(Component, slot)])
log(['>>> children is function\n', _c('div', {}, slot)])
#+end_src

#+RESULTS:
#+begin_example
>>> default slot
 {
  __v_isVNode: true,
  __v_skip: true,
  type: { template: '<br />' },
  children: { default: [Function: slot], _ctx: null },
  shapeFlag: 36
}
>>> children is function
 {
  __v_isVNode: true,
  __v_skip: true,
  type: 'div',
  props: {},
  children: { default: [Function: slot], _ctx: null },
  shapeFlag: 33
}
undefined
#+end_example
** children is array or 普通类型

[[https://github.com/gcclll/stb-vue-next/commit/850c0bc0d8b74e1b88d2158df505c83cb9a71408][feat(add): rc->createVNode, children is array or primitive ·
gcclll/stb-vue-next@850c0bc · GitHub]]

#+begin_src typescript
// 数组类型
if (isArray(children)) {
  type = ShapeFlags.ARRAY_CHILDREN;
}

// 非对象，数组，函数的普通类型处理
{
  children = String(children);
  // force teleport children to array so it can be moved around
  if (shapeFlag & ShapeFlags.TELEPORT) {
    type = ShapeFlags.ARRAY_CHILDREN;
    children = [createTextVNode(children as string)];
  } else {
    type = ShapeFlags.TEXT_CHILDREN;
  }
}

// createTextVNode
export function createTextVNode(text: string = " ", flag: number = 0): VNode {
  return createVNode(Text, null, text, flag);
}

export const Text = Symbol(__DEV__ ? 'Text' : undefined)
#+end_src

普通类型处理中如果是 ~ShapeFlags.TELETPORT~ 当做 ~ARRAY_CHILDREN~ 处理，且
children 按照文本节点处理。

#+begin_src js
const {
  rc: { h, createVNode: c },
  f,
  log,
} = require(process.env.BLOG_JS + "/vue/lib.js");
const _h = (...args) => f(h(...args));
const _c = (...args) => f(c(...args));

log([`>>> array will be children(${1 | (1 << 4)})\n`, _h("div", ["foo"])]);
log([">>> string will be children()\n", _h("div", "foo")]);
#+end_src

#+RESULTS:
#+begin_example
>>> array will be children(17)
 {
  __v_isVNode: true,
  __v_skip: true,
  type: 'div',
  children: [ 'foo' ],
  shapeFlag: 17
}
>>> string will be children()
 {
  __v_isVNode: true,
  __v_skip: true,
  type: 'div',
  children: 'foo',
  shapeFlag: 9
}
undefined
#+end_example
** children is object

[[https://github.com/gcclll/stb-vue-next/commit/959879e825fb225b39c7fb219ec7e46feb6c7537][feat(add): rc->createVNode, normalizeChildren is object · gcclll/stb-vue-next@959879e · GitHub]]

shapeFlag 可能是 ~ShapeFlags.ELEMENT~ 或者 ~ShapeFalgs.TELEPORT~ 。

这里先测试 ELEMENT 情况，因为 TELEPORT 还需要实现 components/Teleport 。

如果 type 是 对象， shapeFlag 初始类型会是 ~ShapeFlags.STATEFULL_COMPONENT, 1 <<
2~

#+begin_src js
// 源文件：/js/vue/lib.js
const {
  rc: { h, createVNode: c },
  f,
  log,
} = require(process.env.BLOG_JS + "/vue/lib.js");
const _h = (...args) => f(c(...args));

// 因为 type = {} , shapeFlag = 1 << 2, 4
// 所以在 normalizeChildren 里面 isObject 分支会进入 else
// 进行处理，经过处理之后成为 4 | SLOTS_CHILDREN,2<<5,32 = 36
log([">>> object\n", _h({}, null, { foo: "foo" })]);
#+end_src

#+RESULTS:
: >>> object
:  {
:   __v_isVNode: true,
:   __v_skip: true,
:   type: {},
:   children: { foo: 'foo', _ctx: null },
:   shapeFlag: 36
: }
: undefined
* api watch(source, cb, options)
:PROPERTIES:
:COLUMNS: %CUSTOM_ID[(Custom Id)]
:CUSTOM_ID: api-watch
:END:

[[https://github.com/gcclll/stb-vue-next/commit/4f0301ea5d7839e8ce5274ea170dd09bd129f5ee][feat(add): api watch TODOs · gcclll/stb-vue-next@4f0301e · GitHub]]

脑图：
[[/img/vue3/runtime-core/vue-runtime-core-api-watch.svg]]

#+begin_quote
为了更好的完成 apiWatch， 需要先完成了 [[#scheduler][scheduler]] 任务调度部分。
#+end_quote

~watch(source, cb, options)~ 函数以下种使用方式(下面的 cb 均可选参数)：

1. ~watch(fn)~ 等价于 ~watchEffect(fn)~, 无 cb
2. ~watch(fn, cb)~ 监听函数
3. ~watch(ref(0), cb)~
4. ~watch(reactive({ count: 0}), cb)~ , reactive 对象默认 ~deep = true~
5. ~watch([ref(0), reactive({count: 0})], cb)~
6. ~watch(fn, cb, { immediate: true })~ 此时， cb 必须为函数， job->fn 被立即执
   行一次， cb 接受新旧值
7. ~watch(ref({ count: 0}), cb, { deep: true })~ 手动指定 ~deep: true~ 深度监听
8. ...

执行具体实现的函数： ~doWatch()~

| Arg      | value                                           | description    |
|----------+-------------------------------------------------+----------------|
| source   | WatchSource, WatchSource[], WatchEffect, object | object watched |
| cb       | WatchCallback or null                           | callback       |
|----------+-------------------------------------------------+----------------|
| options  | WatchOptions = EMPTY_OBJ                        |                |
|          | immediate                                       |                |
|          | deep                                            |                |
|          | flush                                           |                |
|          | onTrack                                         |                |
|          | onTrigger                                       |                |
|----------+-------------------------------------------------+----------------|
| instance | currentInstance                                 | -              |
|          |                                                 |                |

#+begin_quote
~watch(source, cb, options?)~ 函数中的 cb 是必选项，如果想直接 watch effect，可使
用 ~watchEffect(fn, options?)~ api 。
#+end_quote

watch 函数基本流程：

1. cb, immediate, deep 检测
2. getter， 根据 source 不同类型设置 getter
3. cb + deep: true
4. SSR node env
5. 将 cb 封装成 job
6. ~runner = effect(getter, option)~
7. runner 如何执行？
8. stop, remove，函数返回一个 stop+remove 该 runner 操作的函数


下面章节中测试的用例分析脑图：
[[/img/vue3/runtime-core/vue-runtime-core-api-watch-tests.svg]]
** source is ref

[[https://github.com/gcclll/stb-vue-next/commit/b9b7ac6aa908cc375d698fd5762e0ff9a52dbcc5][feat(add): apiWatch->no cb, getter is ref · gcclll/stb-vue-next@b9b7ac6 · GitHub]]

[[https://github.com/gcclll/stb-vue-next/commit/67523262e127d72237f50e3c437210cc5c2e3d76][fix: watch->source is ref, cb -> job · gcclll/stb-vue-next@6752326 · GitHub]]
测试:
#+begin_src js
// 源文件：/js/vue/lib.js
const {
  rc: { ref, nextTick, watch },
  log,
} = require(process.env.BLOG_JS + "/vue/lib.js");
const run = async () => {
  const count = ref(0);
  let dummy,
    i = 0;
  watch(count, (count, prevCount) => {
    log("\nvalue changed: " + i++);
    dummy = [count, prevCount];
    count + 1;
    if (prevCount) {
      prevCount + 1;
    }
  });
  count.value++;
  await nextTick();
  log(dummy);
};
run();
#+end_src

#+RESULTS:
: undefined
: value changed: 0
: 1 0

有关代码(doWatch):
#+begin_src typescript
// -> getter
let getter: () => any;
let forceTrigger = false;
// 2.1 source is ref
if (isRef(source)) {
  getter = () => (source as Ref).value;
  forceTrigger = !!(source as Ref)._shallow;
}

// cb -> job 封装
let oldValue = isArray(source) ? [] : INITIAL_WATCHER_VALUE;
const job: SchedulerJob = () => {
  if (cb) {
    // watch(source, cb)
    const newValue = runner();
    if (deep || forceTrigger || hasChanged(newValue, oldValue)) {
      // cleanup
      if (cleanup) cleanup();
      callWithAsyncErrorHandling(cb, instance, ErrorCodes.WATCH_CALLBACK, [
        newValue,
        // pass undefined as the old value when it's changed for the first time
        // 第一次的时候 oldValue 为 undefined
        oldValue === INITIAL_WATCHER_VALUE ? undefined : oldValue,
        onInvalidate,
      ]);
      oldValue = newValue;
    }
  } else {
    // TODO
  }
};

// scheduler 封装
scheduler = () => {
  if (!instance || instance.isMounted) {
    queuePreFlushCb(job);
  } else {
  }
};

// 什么方式执行 runner?
// 8. TODO runner 如何执行？
if (cb) {
  if (immediate) {
    // TODO
  } else {
    oldValue = runner();
  }
} else if (false /*flush->post*/) {
} else {
  runner();
}
#+end_src
** source is reactive

如果要 watch 的对象是个 reactive ，需要进行递归 watch ，得到 getter.

[[https://github.com/gcclll/stb-vue-next/commit/697f7f25d2bdafdda09a76ee8b00c949e61d6acb][fix: watch->source is reactive · gcclll/stb-vue-next@697f7f2 · GitHub]]

新增相关代码：

#+begin_src typescript
// 1. 如果是 reactive，需要深度监听
if (isReactive(source)) {
  getter = () => source;
  deep = true;
}

// 2. deep: true
if (cb && deep) {
  const baseGetter = getter;
  // a. deep: true
  // b. source is reactive
  getter = () => traverse(baseGetter());
}

// traverse 函数
function traverse(value: unknown, seen: Set<unknown> = new Set()) {
  if (!isObject(value) || seen.has(value)) {
    return value;
  }
  seen.add(value);
  if (isRef(value)) {
    traverse(value.value, seen);
  } else if (isArray(value)) {
    for (let i = 0; i < value.length; i++) {
      traverse(value[i], seen);
    }
  } else if (isSet(value) || isMap(value)) {
    value.forEach((v: any) => {
      traverse(v, seen);
    });
  } else {
    for (const key in value) {
      traverse(value[key], seen);
    }
  }
  return value;
}
#+end_src

递归监听 reactive 对象任意层级上的属性变化。

#+begin_src js
// 源文件：/js/vue/lib.js
const {
  rc: { nextTick, watchEffect, reactive, watch },
  log,
} = require(process.env.BLOG_JS + "/vue/lib.js");

const run = async () => {
  const state = reactive({ count: 0, r1: { count: 10 } });
  let dummy;
  watch(state, (newVal, preVal) => {
    dummy = [newVal, preVal];
  });
  state.count++;
  await nextTick();
  log.br(dummy);
  state.r1.count--
  await nextTick()
  log.br(dummy)
};
run();
#+end_src

#+RESULTS:
: undefined
:
: { count: 1, r1: { count: 10 } } { count: 1, r1: { count: 10 } }
:
:
: { count: 1, r1: { count: 9 } } { count: 1, r1: { count: 9 } }

#+begin_quote
*注意*: newVal 和 preVal 返回的是整个 state 而非当前所发生变更的属性
(count/r1.count)，因为在 job 里面执行  runner() 得到新值是在
traverse(baseGetter()) 之前发生的，此时取到的值是 state 自身。
#+end_quote

[[/img/tmp/20210115141244.png]]
** soure is array
:PROPERTIES:
:COLUMNS: %CUSTOM_ID[(Custom Id)]
:CUSTOM_ID: watch-array
:END:

[[https://github.com/gcclll/stb-vue-next/commit/af1e590b3bb528f8fb9db4a06ead3978426130c1][feat(add): apiWatch->source is array · gcclll/stb-vue-next@af1e590 · GitHub]]

如果要监听的对象是个数组的时候，需要检测数组元素的类型，针对不同类型进行处理。

要点：
1. 数组元素不能是除 ref/reactive/function 之外的类型
2. 对数组元素设值时必须通过元素原始设值方式进行(比如： ref 要 ~ref.value = xxx~)，
   因为该数组本身不是 reactive 的

#+begin_src typescript
if (isArray(source)) {
  getter = () =>
    source.map((s) => {
      if (isRef(s)) {
        return s.value;
      } else if (isReactive(s)) {
        return traverse(s);
      } else if (isFunction(s)) {
        return callWithErrorHandling(s, instance, ErrorCodes.WATCH_GETTER);
      } else {
        // TODO warn invalid source
      }
    });
}
#+end_src

1. isRef -> 监听 item.value
2. isReactive -> traverse(item) 递归
3. isFunction -> callWithErrorHandling(item, instance, ...) 监听函数返回值
4. 其他类型不支持 -> warn invalid source

测试：
#+begin_src js
// 源文件：/js/vue/lib.js
const {
  rc: { ref, watch, nextTick, reactive },
  log,
} = require(process.env.BLOG_JS + "/vue/lib.js");

const run = async () => {
  const array = reactive([]);
  let dummy;
  watch(array, (newArr, preArr) => {
    dummy = [newArr, "\n"];
  });
  array.push(1);
  await nextTick();
  log.br(dummy);
};
run();
#+end_src

#+RESULTS:
: undefined
:
: [ 1 ]
:

数组混合模式(元素只支持 ref, reactive, function)：
#+begin_src js
const {
  rc: { ref, watch, nextTick, reactive, effect },
  log,
} = require(process.env.BLOG_JS + "/vue/lib.js");

let dummy,
  val = reactive([10, 1]);
effect(() => {
  dummy = val[0];
});
val[0]++;
log(`dummy = ${dummy}\n`);

console.warn("---");
const run = async () => {
  const state = reactive({ count: 1 });
  const status = ref(false);
  let dummy;
  watch([() => state.count, status], (vals, oldVals) => {
    dummy = [vals, oldVals];
  });
  state.count++;
  status.value = true;
  await nextTick();
  log.br(dummy);
};
run();
#+end_src

#+RESULTS:
: dummy = 11
:
: undefined
:  [ [ 2, true ], [ 1, false ] ]

#+begin_quote
Tip. watch 数组的时候，需要通过数组元素原来的对象去操作值的变更，如果通过数组下
标设值是不会成功的，因为这个数组本身不是 reactive 的。

比如： ~array[0]++~ 并不会改变 ~state.count~

只有通过 ~state.count++~ 自身赋值操作才会触发更新。
#+end_quote
** source is function

[[https://github.com/gcclll/stb-vue-next/commit/694a389fdeca9e3aaa8e70673da22f74552319fc][feat(add): rc->api watch->source is function · gcclll/stb-vue-next@694a389 ·
GitHub]]

当要 watch 的对象是个函数的时候，无论是否有 cb 最后的 getter 都是通过

~callWithErrorHandling(source, instance, ErrorCodes.WATCH_GETTER)~

或无 cb 时等价于普通的 effect 函数

~callWithErrorHandling(source, instance,ErrorCodes.WATCH_CALLBACK,[onInvalidate])~

直接执行这个函数去收集依赖。

[[/img/tmp/20210115180348.png]]

新增代码：
#+begin_src typescript
if (isFunction(source)) {
  // 如果是函数，直接执行取得函数执行结果
  if (cb) {
    // getter with cb
    getter = () =>
      callWithErrorHandling(source, instance, ErrorCodes.WATCH_GETTER);
  } else {
    // no cb -> simple effect
    getter = () => {
      if (instance && instance.isUnmounted) {
        // 组件已经卸载了
        return;
      }

      if (cleanup) cleanup();

      return callWithErrorHandling(
        source,
        instance,
        ErrorCodes.WATCH_CALLBACK,
        [onInvalidate]
      );
    };
  }
}
#+end_src

[[https://github.com/gcclll/stb-vue-next/commit/9565b4aa7a9d05e5551777254c385c7e79f9b840][feat(add): rc->api watch->source is function without cb ·
gcclll/stb-vue-next@9565b4a · GitHub]]

测试：
#+begin_src js
// 源文件：/js/vue/lib.js
const {
  rc: { nextTick, watchEffect, watch, ref },
  log,
} = require(process.env.BLOG_JS + "/vue/lib.js");

const run = async () => {
  let dummy,
    val = ref(0);
  watch(() => (dummy = val.value));
  val.value++;
  await nextTick();
  log.br({ dummy });

  log("with cb\n");
  // function with cb
  watch(
    () => val.value,
    (val, oldVal) => {
      dummy = [val, oldVal];
    }
  );
  val.value = 100;
  await nextTick();
  log([dummy, "\n"]);
};
run();
#+end_src

#+RESULTS:
: undefined
:
: { dummy: 1 }
: with cb
:
: [ 100, 1 ]
:

[[https://github.com/gcclll/stb-vue-next/commit/11ee8ef39efe740a5154939352fe7b3193e3d4c2][feat(add): rc->api watch->source invalid warning · gcclll/stb-vue-next@11ee8ef · GitHub]]

#+begin_quote
Q. 这里有个容易搞混淆的地方， ~watch(fn, cb)~ 的时候，虽然 fn 和 cb 都是函数，但
   是要区分开这两者，并搞清楚他们是啥和关系是啥。

   1. fn 是被检测的对象，如果是 function 那在被监听之前需要先执行它，等于是监听
      函数里面的内容，比如：函数内有访问某个 reactive 变量

   2. 而 cb 是属于回调性质，且是当数据有更新的时候的回调函数，它只会在一个地方被
      执行，即封装 job 的时候，需要将数据更新前后的变化值通过它传递出来(如下面👇的
      代码)

#+end_quote

#+begin_src typescript
const job: SchedulerJob = () => {
  if (cb) {
    // watch(source, cb)
    const newValue = runner();
    if (deep || forceTrigger || hasChanged(newValue, oldValue)) {
      // cleanup
      if (cleanup) cleanup();
      callWithAsyncErrorHandling(cb, instance, ErrorCodes.WATCH_CALLBACK, [
        newValue,
        // pass undefined as the old value when it's changed for the first time
        // 第一次的时候 oldValue 为 undefined
        oldValue === INITIAL_WATCHER_VALUE ? undefined : oldValue,
        onInvalidate,
      ]);
      oldValue = newValue;
    }
  } else {
    // watchEffect, no cb
    runner();
  }
};
#+end_src
** option deep
:PROPERTIES:
:COLUMNS: %CUSTOM_ID[(Custom Id)]
:CUSTOM_ID: api-watch-deep
:END:

对于深度监听主要是因为 ~traverse()~ 函数对 reactive 对象进行了递归遍历，对每个属
性进行了访问，从而让它收集到当前的 effect 作为依赖，这样将来这些被遍历到的值发生
改变时就会触发这个收集到的 effect 执行，达到深度监听效果。

#+begin_src typescript
 // 3. cb + deep: true
 if (cb && deep) {
   const baseGetter = getter;
   // a. deep: true

   // b. source is reactive
   getter = () => traverse(baseGetter());
 }
#+end_src

#+begin_quote
~traverse()~ 作用就是递归遍历所有属性通过 ~return value~ 来执行 get 操作收集依赖。
#+end_quote

测试：
#+begin_src js
// 源文件：/js/vue/lib.js
const {
  rc: { ref, reactive, watch, nextTick },
  log,
} = require(process.env.BLOG_JS + "/vue/lib.js");

const run = async () => {
  const count = ref(0);

  const state = reactive({
    nested: { count },
    array: [1, 2, 3],
    map: new Map([
      ["a", 1],
      ["b", 2],
    ]),
    set: new Set([1, 2, 3]),
  });

  let dummy;
  watch(
    () => state,
    (state) => {
      dummy = [
        state.nested.count,
        state.array[0],
        state.map.get("a"),
        state.set.has(1),
      ];
    },
    { deep: true }
  );

  state.nested.count++;
  await nextTick();
  log(["\n", dummy]);

  state.array[0] = 2;
  await nextTick();
  log(["\n", dummy]);

  state.map.set("a", 100);
  await nextTick();
  log(["\n", dummy]);

  state.set.delete(1);
  await nextTick();
  log(["\n", dummy]);
};
run();
#+end_src

#+RESULTS:
: undefined
:  [ 1, 1, 1, true ]
:
:  [ 1, 2, 1, true ]
:
:  [ 1, 2, 100, true ]
:
:  [ 1, 2, 100, false ]

*** TODO deep ref
** option immediate

[[https://github.com/gcclll/stb-vue-next/commit/204ce6824b3f645d79f77f350b78a70bc3a47980][feat(add): rc->api watch->immediate option · gcclll/stb-vue-next@204ce68 ·
GitHub]]

*immediate* 选项，会让 cb/job 立即执行一次，而不是在队列中等待异步执行。

新增代码只需要加一行：
#+begin_src typescript
if (cb) {
  if (immediate) {
    job(); // 这里直接调用 Job
  } else {
    oldValue = runner();
  }
} else if (false /*flush->post*/) {
} else {
  runner();
}
#+end_src

测试：
#+begin_src js
// 源文件：/js/vue/lib.js
const {
  rc: { nextTick, watch, ref },
  log,
} = require(process.env.BLOG_JS + "/vue/lib.js");

const run = async () => {
  const _log = (desc, newline) =>
    log([newline ? "\n" : "", `${desc} > dummy = ${dummy}`]);
  const cb = (val) => (dummy = val);
  const option = { immediate: true };

  const count = ref(0);
  let dummy;
  watch(count, cb, option);

  _log("改变值之前");
  count.value++;
  await nextTick();
  _log("改变值之后", true);

  const nul = ref(null);
  watch(() => nul.value, cb, option);
  _log("当初始值为 null");

  const undef = ref();
  watch(() => undef.value, cb, option);
  _log("当初始值为 undefined");
  undef.value = 3;
  await nextTick();
  _log("当初始值为 undefined, set 3");
  undef.value = undefined;
  await nextTick();
  _log("当初始值为 undefined, set undefined");
  // undefined === undefined -> hasChanged() -> false
  undef.value = undefined;
  await nextTick();
  _log("当初始值为 undefined, set undefined");
};
run();
#+end_src

#+RESULTS:
:  改变值之前 > dummy = 0
: undefined
:  改变值之后 > dummy = 1
:  当初始值为 null > dummy = null
:  当初始值为 undefined > dummy = undefined
:  当初始值为 undefined, set 3 > dummy = 3
:  当初始值为 undefined, set undefined > dummy = undefined
:  当初始值为 undefined, set undefined > dummy = undefined

如上结果， cb 会立即执行。

在使用 deep 和 immediate 选项的时候如果没有 cb 会给出警告，直接看源码吧:
#+begin_src typescript
// 1. cb, immediate, deep 检测
if (__DEV__ && !cb) {
  if (immediate !== undefined) {
    warn(
      `watch() "immediate" option is only respected when using the ` +
        `watch(source, callback, options?) signature.`
    );
  }
  if (deep !== undefined) {
    warn(
      `watch() "deep" option is only respected when using the ` +
        `watch(source, callback, options?) signature.`
    );
  }
}
#+end_src

#+begin_quote
也就是说， ~deep~ 和 ~immediate~ 建议在 ~watch(s, cb, options)~ 形式下使用，即在
有 cb 参数的情况下使用。

那为什么呢？
#+end_quote
** option onTrack + onTrigger

这部分实现逻辑主要在 [[/vue/vue-mind-map-house-reactivity][reactivity]] 模块。

onTrack 在 reactivity 中使用的，用来在触发 get 取值操作时调用 [[/vue/vue-mind-map-house-reactivity/#r-track][track()]] 函数收集依
赖时的一个自定义事件回调。

#+begin_src typescript
// track() 函授最后 add 操作之后
if (!dep.has(activeEffect)) {
  dep.add(activeEffect);
  // 自身保存一份被依赖者名单
  activeEffect.deps.push(dep);
  if (__DEV__ && activeEffect.options.onTrack) {
    activeEffect.options.onTrack({
      effect: activeEffect,
      target,
      type,
      key,
    });
  }
}

// trigger() 函数中实现
if (effect.options.onTrigger) {
  effect.options.onTrigger({
    effect,
    target,
    key,
    type,
    newValue,
    oldValue,
    oldTarget,
  });
}
#+end_src

这里会将 当前 target 的 key 属性所收集的依赖 activeEffect 暴露出来。

测试：
#+begin_src js
// 源文件：/js/vue/lib.js
const {
  rc: { nextTick, watchEffect, reactive },
  log,
} = require(process.env.BLOG_JS + "/vue/lib.js");

const run = async () => {
  const trackEvents = [];
  const triggerEvents = [];
  let dummy;
  const onTrack = (e /* activeEffect */) => trackEvents.push(e);
  const onTrigger = (e /* effect */) => triggerEvents.push(e);
  const obj = reactive({ foo: 1, bar: 2 });
  watchEffect(
    () => {
      dummy = [obj.foo, "bar" in obj, Object.keys(obj)];
    },
    { onTrack, onTrigger }
  );

  await nextTick();
  log(["\n", dummy]);
  // 有多少个就等于呗调用了多少次
  log("track events count = " + trackEvents.length);
  trackEvents.forEach((e) => log.props(e, ["target", "type", "key", "deps"]));

  obj.foo = 3;
  obj.bar = 4;
  log("trigger events count = " + triggerEvents.length);
  triggerEvents.forEach((e) =>
    log.props(e, ["type", "key", "oldValue", "newValue"])
  );
};
run();
#+end_src

#+RESULTS:
: undefined
:  [ 1, true, [ 'foo', 'bar' ] ]
: track events count = 3
: { target: { foo: 1, bar: 2 }, type: 'get', key: 'foo' }
: { target: { foo: 1, bar: 2 }, type: 'has', key: 'bar' }
: { target: { foo: 1, bar: 2 }, type: 'iterate', key: Symbol(iterate) }
: trigger events count = 2
: { key: 'foo', type: 'set', newValue: 3, oldValue: 1 }
: { key: 'bar', type: 'set', newValue: 4, oldValue: 2 }


#+begin_comment
这里还需要开发环境才能测试 onTrack，只能改一改去掉 ~__DEV__~ 试试。
#+end_comment

** stop & cleanup

*stop*: watch() 的返回值，用来停掉 effect 使其 effect.active = false，让 effect 失效。

#+begin_src typescript
// 9. return runner->stop, remove runner from instance.effects
return () => {
  stop(runner);
  if (instance) {
    remove(instance.effects!, runner);
  }
};
#+end_src

*cleanup*: 清理工作，这有两个被调用的地方(cleanup + onStop它们被注册了同一个函数)，
一个是调动 cb/fn 之前，一个是 runner effect 调用 stop 的时候。

#+begin_src typescript
let cleanup: () => void;
const onInvalidate: InvalidateCbRegistrator = (fn: () => void) => {
  cleanup = runner.options.onStop = () => {
    callWithErrorHandling(fn, instance, ErrorCodes.WATCH_CLEANUP);
  };
};
#+end_src

*** stop
stop 是 watch 调用的返回值，里面会 stop runner 然后将 runner 从 ~instance.effects~
里面删除。

#+begin_src js
// 源文件：/js/vue/lib.js
const {
  rc: { reactive, nextTick, watch },
  log,
} = require(process.env.BLOG_JS + "/vue/lib.js");

const run = async () => {
  const state = reactive({ count: 0 });
  let dummy;
  const stop = watch(
    () => state.count,
    (count) => {
      dummy = count;
    }
  );

  state.count++;
  await nextTick();
  log.br({ dummy });

  stop();
  state.count = 100;
  await nextTick();
  log({ dummy });
};
run();
#+end_src

#+RESULTS:
: undefined
:  { dummy: 1 }
: { dummy: 1 }

可以看到 stop 之后两次输出结果是一样，即 stop 后面的 state.count 失效了，因为
stop effect 会将 effect.active 置为  false ，有如下代码被执行:

#+begin_src typescript
// reactivity/src/effect.ts -> createReactiveEffect()
if (!effect.active) {
  return options.scheduler ? undefined : fn();
}
#+end_src

又， watch 函数里面无论如何 scheduler 都是有值的，所以当 effect 为非激活状态，什
么都不会干。

*** cleanup(无 cb)

cleanup 相关源码，可能有点绕:

#+begin_src typescript
// cleanup 和注册 cleanup 的一个函数
// 如下，cleanup 和 effect onStop 是同一个函数，清理 effect 用
let cleanup: () => void;
const onInvalidate: InvalidateCbRegistrator = (fn: () => void) => {
  cleanup = runner.options.onStop = () => {
    callWithErrorHandling(fn, instance, ErrorCodes.WATCH_CLEANUP);
  };
};

// runtime-core/src/apiWatch.ts:watch(source, cb, option)
// Job 封装中和 cleanup 有关的
const job: SchedulerJob = () => {
  if (!runner.active) {
    return;
  }
  if (cb) {
    // watch(source, cb)
    const newValue = runner();
    if (deep || forceTrigger || hasChanged(newValue, oldValue)) {
      // cleanup，在执行 cb 之前先执行 cleanup
      if (cleanup) cleanup();
      // call cb with catch error
      // 这里等价于 cb(newValue, oldValue, onInvalidate)
      oldValue = newValue;
    }
  } /* else... */
};

// 然后还有个地方与 cleanup 有关，且这里要讲到的内容会在这部分执行
// 获取 getter函数时候，如果 source 是函数等价于
// watchEffect(source)
if (isFunction(source)) {
  // 如果是函数，直接执行取得函数执行结果
  if (cb) {
    // ...
  } else {
    // no cb -> simple effect
    getter = () => {
      if (instance && instance.isUnmounted) {
        // 组件已经卸载了
        return;
      }

      if (cleanup) cleanup();
      // 等价于 return source(onInvalidate)
    };
  }
}
#+end_src

测试：
#+begin_src js
// 源文件：/js/vue/lib.js
const {
  rc: { reactive, nextTick, watchEffect },
  log,
} = require(process.env.BLOG_JS + "/vue/lib.js");

const run = async () => {
  const state = reactive({ count: 0 });
  let n = 0;
  const cleanup = () => log(`\ncalled ${++n} times.`);
  let dummy;
  const stop = watchEffect((onCleanup) => {
    // 这里执行的实际上是 onInvalidate 函数，将cleanup 封装后注册到
    // cleanup 和 onStop 上，在 cb 执行之前或 effect stop 时候调用
    onCleanup(cleanup);
    dummy = state.count;
  });

  state.count++;
  await nextTick();
  // 这里会输出一次 'called 1 times.'
  // 因为 cb 之前之前进行了清理工作(cleanup())
  log.br({ dummy });

  // 这里会输出一次 'called 2 times.'
  // 这里是 effect stop 的 onStop 触发的
  stop();
};
run();
#+end_src

#+RESULTS:
: undefined
: called 1 times.
:
:  { dummy: 1 }
:
: called 2 times.

#+begin_quote
即. 如果想在 effect fn 之前或停止的时候进行清理工作，可以使用
~watchEffect(effect)~ 的参数 effect 函数的第一个参数来注册 一个函数作为清理工作
或做其他事情。
如： ~watchEffect((onCleanup) => { onCleanup(cleanup) ... }~
#+end_quote

*** cleanup(有 cb)

当有 cb 的时候： ~watch(source, cb, ...)~ ，将 onCleanup 注册函数从 cb 的第三个参数暴露出来
#+begin_src js
// 源文件：/js/vue/lib.js
const {
  rc: { nextTick, watch, ref },
  log,
} = require(process.env.BLOG_JS + "/vue/lib.js");

const run = async () => {
  const count = ref(0);
  let n = 0;
  const cleanup = () => log(`\ncalled ${++n} times, dummy = ${dummy}`);
  let dummy;
  const stop = watch(count, (newVal, oldVal, onCleanup) => {
    onCleanup(cleanup);
    dummy = newVal;
  });
// 这里 cleanup 尚不会执行
// 因为第一次执行是注册 cleanup 行为
  count.value++;
  await nextTick();

// 这里会执行一次 cleanup ，因为第一次赋值时注册过了
  count.value = 100;
  await nextTick();

// stop 时候执行一次，所以总共会执行两次 cleanup, n = 2
  stop();
  log({n})
};
run();
#+end_src

#+RESULTS:
: undefined
: called 1 times, dummy = 1
:
: called 2 times, dummy = 100
: { n: 2 }

脑图分析：

[[/img/vue3/runtime-core/vue-runtime-core-api-watch-cleanup.jpg]]

文字分析：

1. cleanup 注册时机分为两种情况

   - 一是无 cb 的 ~watchEffect(fn)~ ，是在 getter 设置阶段封装到 getter 函数里面
     注册的，此时作为 fn 的第一个参数暴露出来 ~fn(onCleanUp)~ ，

   - 二是有 cb 的 ~watch(ref(0), cb)~ , 在 job 封装期间在调用 cb 的时候注册，此
     时作为 cb 的第三个参数暴露出来 ~cb(newVal, oldVal, onCleanup)~

   #+begin_quote
   *两者区别* ： watchEffect 由于无 cb 会立即执行一次 runner, 此时就收集到了 cleanup，
   而 watch 有 cb 时则是会在第一次值更新触发 runner 执行才开始收集 cleanup。
   #+end_quote

2. 执行时机，该阶段和注册时机相辅相成，且在 cb/fn 执行之前就会被执行，因此 cb/fn
   的第一次执行都属于对 cleanup 的注册
** flush sync

[[https://github.com/gcclll/stb-vue-next/commit/e1436f2cfe78cdc64c31c03d876c5b743a44fc18][feat(add): rc->api watch->option flush=sync · gcclll/stb-vue-next@e1436f2 · GitHub]]

支持同步代码，即所有任务立即执行（在值发生改变之后），而不是进入队列异步执行。

只需要增加一行代码就行：
#+begin_src typescript
// 6. TODO scheduler 设置
let scheduler: ReactiveEffectOptions["scheduler"];
// 6.1 flush is 'sync'
if (flush === "sync") {
  scheduler = job;  // 新增
}
// 6.2 TODO flush is 'post'
else if (false /* post */) {
}
// 6.3 TODO flush is 'pre'(default)
else {
  // default: 'pre'
  scheduler = () => {
    if (!instance || instance.isMounted) {
      queuePreFlushCb(job);
    } else {
      // 带 { pre: true } 选项，第一次调用必须发生在组件 mounted 之前
      // 从而使他被同步调用，立即执行一次
      job();
    }
  };
}
#+end_src

新增 ~scheduler = job~ 直接让任务函数赋值给调度器，这个时候如果有值发生变化，会
触发 effect> ~trigger()~ 在这里面会检测是不是有 ~option.scheduler~ 如果有会立即执行这
个函数。

#+begin_src typescript
// reactivity/effect.ts>trigger()
if (effect.options.scheduler) {
  effect.options.scheduler(effect);
} else {
  effect();
}
#+end_src

测试:
#+begin_src js
// 源文件：/js/vue/lib.js
const {
  rc: { watch, ref },
  log,
} = require(process.env.BLOG_JS + "/vue/lib.js");

const run = async () => {
  const value = ref(0);
  let calls = 0;
  watch(value, () => ++calls, { flush: "sync" });

  log({ calls }); // -> 0
  value.value = 100;
  log({ calls }); // -> 1
};
run();
#+end_src

#+RESULTS:
: { calls: 0 }
: { calls: 1 }
: undefined

注意看上面的测试用例并没有用 ~await nextTick()~ ，而是同步代码执行。
** shallow ref
:PROPERTIES:
:COLUMNS: %CUSTOM_ID[(Custom Id)]
:CUSTOM_ID: watch-shallow-ref
:END:

#+begin_src js
// 源文件：/js/vue/lib.js
const {
  rc: { watch, shallowRef, nextTick, triggerRef },
  f,
  log,
} = require(process.env.BLOG_JS + "/vue/lib.js");

const run = async () => {
  const v = shallowRef({ a: 1 }); // #1
  let sideEffect = 0;
  watch(v, (obj) => { // #2 cb -> cb(newVal, oldVal, onCleanUp)
    sideEffect = obj.a;
  });

  v.value = v.value; // #3
  await nextTick();
  log(["\nshould not trigger: ", sideEffect]); // #4

  v.value.a++; // #5
  await nextTick();
  log(["\nshould not trigger: ", sideEffect]); // #6

  triggerRef(v); // #7
  await nextTick();
  log(["\nshould trigger now: ", sideEffect]); // #8
};
run();
#+end_src

#+RESULTS:
: undefined
: should not trigger:  0
:
: should not trigger:  0
:
: should trigger now:  2

#+begin_quote
ref 这一块还没深入去分析过，先暂停⏸去完成下这部分。

1. DONE [2021-01-20 15:18:37] [[/vue/vue-mind-map-house-reactivity/#ref][ref 完成，可以往下继续了]]
#+end_quote

triggerRef 作用是手动触发 ref.value 上收集的所有依赖。

结果分析：
1. *#1* shallowRef 意味着 ~{a: 1}~ 中的属性 a 非 reactive
2. *#2* watch v 基于 *1* 所以只是对 ref value 进行了监听，后面是值变更回调
3. *#3* 值没发生改变，所有 *#4* 输出还是 0
4. *#5* 由于 ~a~ 属性非 reactive 所以它没有依赖收集所以不会执行 cb，所以 *#6* 出
   依然是 0
5. *#7* 这里手动调用 ~triggerRef(v)~ 等价于 ~trigger(v, SET, 'value')~ 触发 ref
   value 的依赖执行，此时 cb 会得到执行，sideEffect 被赋值新的 ~v.a~ 值

   这里有一点需要注意，在 cb 里面是用的 v.a 而不是 v.value.a 因为在
   ~watch(s,cb,option)~ 里面检测到如果 ~s~ 是 ref 类型，会将 getter 设置为
   ~getter = () => s.value~

   而在执行 cb 之前取新值是通过 ~newVal = runner()~ 得到的，而这个 ~runner =
   effect(getter, {...})~ 所以等于是 ~effect(() => s.value, {...})~

   所以对于 ref 类型 effect 封装的其实是 ~() => s.value~ 这个函
   数，那么对于 ~s.value~ 的依赖列表中就会有这个箭头函数。

   然后在 watch 里面会将 cb 的执行封装进 job ，然后根据情况将 job 封装或直接赋值
   给 scheduler ，这个会作为 ~effect(, { scheduler })~ 的选项传递进去。

   那么在 trigger 的时候检测到提供了 scheduler 就会调用它，所以最终调用
   triggerRef(v) 会触发 cb 的调用将 ~obj.a~复制给 ~sideEffect~ ，这个 obj 就是
   runner() 执行的返回值也就是 ~() => s.value~ 这个函数执行的返回值。

** TODO flush pre(default) cb
** TODO flush post cb

[[https://github.com/gcclll/stb-vue-next/commit/ec14879bf13deb83cea3401279ea75e1cf44eaf6][feat(add): rc->watch->flush = 'post' · gcclll/stb-vue-next@ec14879 · GitHub]]

[[https://github.com/gcclll/stb-vue-next/commit/9f3ac7dff18926df602a7f0eff08da4b253e26a7][feat(add): rc->watch->cb->flush = 'post' · gcclll/stb-vue-next@9f3ac7d · GitHub]]

新增代码：
#+begin_src typescript
// apiWatch.ts -> scheduler when flush=post
if (flush === "post") {
  scheduler = () => queuePostRenderEffect(job, instance && instance.suspense);
}

// renderer.ts -> queuePostRenderEffect
// 将任务加入到 suspense.effects 或 调用 queuePostFlushCb
// 加入到 pendingPostFlushCbs
export const queuePostRenderEffect = __FEATURE_SUSPENSE__
  ? queueEffectWithSuspense
  : queuePostFlushCb;

// components/Suspense.ts
export function queueEffectWithSuspense(
  fn: Function | Function[],
  suspense: SuspenseBoundary | null
): void {
  if (suspense && suspense.pendingBranch) {
    if (isArray(fn)) {
      suspense.effects.push(...fn);
    } else {
      suspense.effects.push(fn);
    }
  } else {
    queuePostFlushCb(fn);
  }
}
#+end_src
** TODO ssr support
** TODO instance watch

[[https://github.com/gcclll/stb-vue-next/commit/9ec5d5131019fe67bcc7232e39bde1cfe239dbca][feat(add): rc->watch->instance watch · gcclll/stb-vue-next@9ec5d51 · GitHub]]

#+begin_src typescript
// this.$watch
export function instanceWatch(
  this: ComponentInternalInstance,
  source: string | Function,
  cb: WatchCallback,
  options?: WatchOptions
): WatchStopHandle {
  const publicThis = this.proxy as any
  const getter = isString(source)
    ? () => publicThis[source]
    : source.bind(publicThis)
  return doWatch(getter, cb.bind(publicThis), options, this)
}
#+end_src

将监听源，与当前实例绑定，如果是字符串转成函数。
* scheduler 任务调度机制
:PROPERTIES:
:COLUMNS: %CUSTOM_ID[(Custom Id)]
:CUSTOM_ID: scheduler
:END:

让我们跟着 ~scheduler.spec.ts~ 测试用例来逐步属性 scheduler 的调度机制。

在做这个之前先把 scheduler.ts 中逻辑代码全清空，这个文件还是相对独立的

[[https://github.com/gcclll/stb-vue-next/commit/a54cc00ee93057839de620a152ca1fe691671f63][feat: rc->reset scheduler.ts · gcclll/stb-vue-next@a54cc00 · GitHub]]

我们从零开始一步步来分析实现。

[[/img/vue3/runtime-core/vue-runtime-core-scheduler.svg]]

这部分包含三种任务的 flush 逻辑代码：

1. queue jobs -> ~flushIndex~ -> ~queue[]~ -> ~queueJob()~ -> ~queueFlush()~ -> ~flushJobs()~
2. pre jobs -> ~preFlushIndex~ -> ~pendingPreFlushCbs[]~ -> ~activePreFlushCbs[]~ ->
   ~queuePreFlushCb()~ -> ~flushPreFlushCbs()~ -> ~flushJobs()~
3. TODO post jobs -> ...
** nextTick
:PROPERTIES:
:COLUMNS: %CUSTOM_ID[(Custom Id)]
:CUSTOM_ID: nexttick
:END:

[[https://github.com/gcclll/stb-vue-next/commit/32b482762b074d3123906887df35231efea7dcc7][feat(add): rc->scheduler -> nextTick · gcclll/stb-vue-next@32b4827 · GitHub]]

在 queue 所有队列清空之后执行的一个异步操作，有重要关联的两个变量：

1. resolvedPromise，一个空的 promise then
2. currentFlushPromise，当 queue 队列中的所有任务执行完成之后返回的一个 promise

   是的，是所有 queue jobs 完成之后，因为 flushJobs 函数里面都是同步操作，重要代
   码：

   #+begin_src typescript
   for (flushIndex = 0; flushIndex < queue.length; flushIndex++) {
     const job = queue[flushIndex];
     if (job) {
       // TODO DEV -> 检查递归更新问题
       callWithErrorHandling(job, null, ErrorCodes.SCHEDULER);
     }
   }
   #+end_src


#+begin_quote
所以 nextTick 任务总是在 queue jobs 所有任务完成之后执行。
#+end_quote

#+begin_src typescript
const resolvedPromise: Promise<any> = Promise.resolve();
// 当前正在被执行的 promise 任务
let currentFlushPromise: Promise<void> | null = null;

export function nextTick(
  this: ComponentPublicInstance | void,
  fn?: () => void
): Promise<void> {
  const p = currentFlushPromise || resolvedPromise;
  return fn ? p.then(this ? fn.bind(this) : fn) : p;
}
#+end_src

函数作用：在当前正在执行的 job promise 之后执行 nextTick 的任务，等于说 nextTick
属于个插队任务。

#+begin_src js
// 源文件：/js/vue/lib.js
const {
  rc: { nextTick },
  log,
} = require(process.env.BLOG_JS + "/vue/lib.js");

const run = async () => {
  const calls = [];
  const pr = Promise.resolve();
  const dummyThen = Promise.resolve().then();
  const job1 = () => calls.push("job1");
  const job2 = () => calls.push("job2");
  nextTick(job1);
  job2();
  log(["\nbefore await, ", calls.length, "\n"]);
  await dummyThen;
  log(["\nafter await, ", calls.length, "\n"]);
  log(calls.join("-"));
};

run();
#+end_src

#+RESULTS:
:
: before await,  1
:
: after await,  2
:
: job2-job1

#+begin_quote
Tip. nextTick() 异步代码执行，经过 babel 转换后的代码，请查看 [[#q-nexttick][nextTick question]]
#+end_quote

** queueJob
:PROPERTIES:
:COLUMNS: %CUSTOM_ID[(Custom Id)]
:CUSTOM_ID: job-queue-job
:END:

[[https://github.com/gcclll/stb-vue-next/commit/eb33b40b7e8e87165fa2149b1a1354d078f33c40][feat(add): rc->scheduler->queueJob · gcclll/stb-vue-next@eb33b40 · GitHub]]

[[/img/vue3/runtime-core/vue-runtime-core-scheduler.svg]]

#+begin_src typescript
export function queueJob(job: SchedulerJob) {
  // the dedupe search uses the startIndex argument of Array.includes()
  // by default the search index includes the current job that is being run
  // so it cannot recursively trigger itself again.
  // if the job is a watch() callback, the search will start with a +1 index to
  // allow it recursively trigger itself - it is the user's responsibility to
  // ensure it doesn't end up in an infinite loop.
  if (
    (!queue.length ||
      !queue.includes(
        job,
        isFlushing && job.allowRecurse ? flushIndex + 1 : flushIndex
      )) &&
    job !== currentPreFlushParentJob
  ) {
    queue.push(job)
    queueFlush
  }
}

function queueFlush() {
  if (!isFlushing && !isFlushPending) {
    isFlushPending = true
    currentFlushPromise = resolvedPromise.then(flushJobs)
  }
}

// 请查看下一节的实现
function flushJobs(seen?: CountMap) {
  // TODO
}
#+end_src

需要 flushJobs 支持，请到 flushJobs(👇) 一节查看测试情况。

** flushJobs

[[https://github.com/gcclll/stb-vue-next/commit/e23be119f8b67f8c828f01f031f2488afa55c0c9][feat(add): rc->scheduler->flushJobs function · gcclll/stb-vue-next@e23be11 · GitHub]]

1. isFlushPending, isFlushing 标识重置
2. [[#job-flush-pre][flushPreFlushCbs]], 对 pre 类型的 jobs 进行 flush 操作，有关函数
   ~flushPreFlushCbs(flush函数)~ 和 ~queuePreFlushCb(入列函数)~
3. flush 之前进行排序
4. try -> callWithErrorHandling 执行任务回调
5. finally -> 重置，清空 queue 队列内容和标识
6. TODO flushPostFlushCbs, 对 post 类型的 jobs 进行 flush 操作，有关函数
   ~flushPostFlushCbs~ 和 ~queuePostFlushCb~

#+begin_src typescript
function flushJobs(seen?: CountMap) {
  isFlushPending = false;
  isFlushing = true;

  if (__DEV__) {
    seen = seen || new Map();
  }

  // flushPreFLushCbs(seen)，默认的 job 类型

  // flush 之前对 queue 排序
  // 1. 组件更新顺序：parent -> child，因为 parent 总是在 child 之前
  //    被创建，因此 parent render effect 有更低的优先级数字(数字越小越先创建？)
  // 2. 如果组件在 parent 更新期间被卸载了，那么它的更新都会被忽略掉

  queue.sort((a, b) => getId(a) - getId(b));

  // 开始 flush
  try {
    for (flushIndex = 0; flushIndex < queue.length; flushIndex++) {
      const job = queue[flushIndex];
      if (job) {
        // TODO DEV -> 检查递归更新问题
        callWithErrorHandling(job, null, ErrorCodes.SCHEDULER);
      }
    }
  } finally {
    // 情况队列
    flushIndex = 0;
    queue.length = 0;

    // TODO flush `post` 类型的 flush cbs

    isFlushing = false;
    currentFlushPromise = null;

    // TDOO 代码执行到当前 tick 的时候，有可能有新的 job 加入
    // some postFlushCb queued jobs!
    // keep flushing until it drains.
  }
}
#+end_src

测试：
#+begin_src js
// 源文件：/js/vue/lib.js
const {
  rc: { queueJob, nextTick },
  log,
} = require(process.env.BLOG_JS + "/vue/lib.js");
const run = async () => {
  const calls = [];
  const job1 = () => { // #1
    log.newline("job1 running");
    calls.push("job1");
  };
  const job2 = () => { // #2
    log.newline("job2 running");
    calls.push("job2");
  };
// 支持去重
  queueJob(job1); // #3
  queueJob(job2); // #4
  queueJob(job1);
  queueJob(job2);
  log("before await  " + calls); // #5
  await nextTick(); // #6
  log("after await  " + calls); // #7
};

run();
#+end_src

#+RESULTS:
: before await
: undefined
:
: job1 running
:
:
: job2 running
: after await  job1,job2

如果在没有 *#6* 的情况下，在所有 Log 之后会立即执行 queue jobs。

#+begin_src typescript
function queueFlush() {
  if (!isFlushing && !isFlushPending) {
    isFlushPending = true;
    currentFlushPromise = resolvedPromise.then(flushJobs);
  }
}
#+end_src

这里 nextTick() 调用并没有传递 fn ，因此 ~await nextTick()~ 在这里的作用就是等
~resolvedPromise~ 执行完成(此时并没有正在执行的 promise)

~const resolvedPromise: Promise<any> = Promise.resolve()~

再执行后面的代码。

queueJob 函数分为两步：

1. push 收集任务 ~queue.push(job)~ ，同步执行
2. 随后立即调用 ~queueFlush()~ 刷掉任务，任务异步 flush

在这个实例中，按照同步执行顺序，

1. ~queueJob(job1)~ 执行，将 job1 -> push -> queue 中， queueFlush 中的 promise 等待
2. ~queueJob(job2)~ 执行，将 job2 -> push -> queue 中，
   queueFlush 中的 promise 继续等待
3. ~log before~ 执行，由于 job 虽然已经在 queue 中了，但是需要等待 queueFlush 去
   异步执行他们，所以这里 calls 依旧是空的
4. ~await nextTick()~ 异步操作

   这一句目的只是为了让后面的 log 在 job1,job2 后面执行。

   #+begin_src typescript
    const p = currentFlushPromise || resolvedPromise;
    return fn ? p.then(this ? fn.bind(this) : fn) : p;
   #+end_src

  nextTick 会在刚刚执行完毕的 promise 后面取执行后面的任务，所以 log after 肯定是后于 job1,job2 的执行的。

5. 所有同步任务执行完成，开始进入异步任务执行，由于 job1,job2 先入队列，在事件循
   环中会先于 log after 执行，然后在执行 log after，所以就有了上面的输出结果。


实例执行脑图：

[[/img/tmp/20210112173934.png]]

** queueJob while flushing

当 queue 中 jobs 正在被执行的时候调用 queueJob 进入新的任务。

#+begin_src js
// 源文件：/js/vue/lib.js
const {
  rc: { queueJob, nextTick },
  log,
} = require(process.env.BLOG_JS + "/vue/lib.js");
const run = async () => {
  const calls = [];
  const job1 = () => {
    calls.push("job1");
    // job2 任务会在 job1 执行到这里的时候加入到了 queue
    // 但是它的执行需等到 queue 中的任务执行完成之后再执行
    // 因为任务收集是同步的，任务执行是异步的，而 queue flush 操作又是同步的
    queueJob(job2);
  };
  const job2 = () => calls.push("job2");
  queueJob(job1);
  await nextTick();
  log(["\nafter await\n", calls]);
};
run();
#+end_src

#+RESULTS:
: undefined
: after await
:  [ 'job1', 'job2' ]

看下面的测试代码（在 for 循环过程中改变数组长度，会检测到这种改变）：
#+begin_src js
const nums = [1, 2, 3];
const add = (i) => nums.push(++i);
for (let i = 0; i < nums.length; i++) {
  if (i === 1) add(i);
  console.log({ i, v: nums[i], l: nums.length });
}
#+end_src

#+RESULTS:
: { i: 0, v: 1, l: 3 }
: { i: 1, v: 2, l: 4 }
: { i: 2, v: 3, l: 4 }
: { i: 3, v: 2, l: 4 }
: undefined

所以上面的 Job 实例，就很好理解了

在 for queue jobs 过程中发现有新的 job 进入，之前说过了  queue 的入列操作是同步
的，所以会立即执行改变 queue 长度，最后加入的任务会在 for 循环过程中最后得到执行。
** queuePreFlushCb

[[https://github.com/gcclll/stb-vue-next/commit/2c72cdc8734a3317041e4b14f288732379b4f1d2][feat(add): rc->scheduler->queuePreFlushCb -> pre jobs, pendingPreFlus… · gcclll/stb-vue-next@2c72cdc · GitHub]]

新增代码：

1. ~queuePreFlushCb~, 入列 pre jobs 函数
2. ~flushPreFlushCbs~, flush pre jobs 函数
3. ~flushJobs~ 中调用 ~flushPreFlushCbs()~ 刷掉 pre jobs

这个是用来收集和 flush pre 类型(默认类型的任务)的队列 ~pendingPreFlushCbs[]~  的函数。

逻辑脑图：
[[/img/tmp/20210113103504.png]]

相关代码：
#+begin_src typescript
export function queuePreFlushCb(cb: SchedulerCb) {
  queueCb(cb, activePreFlushCbs, pendingPreFlushCbs, preFlushIndex);
}

function queueCb(
  cb: SchedulerCbs,
  activeQueue: SchedulerCb[] | null,
  pendingQueue: SchedulerCb[],
  index: number
) {
  if (!isArray(cb)) {
    if (
      !activeQueue ||
      !activeQueue.includes(
        cb,
        (cb as SchedulerJob).allowRecurse ? index + 1 : index
      )
    ) {
      pendingQueue.push(cb);
    }
  } else {
    pendingQueue.push(...cb);
  }
  queueFlush();
}
#+end_src

对比 queueCb 和 queueJob 会发现两者没多大的差别，先同步收集再异步 flush，两者判
断条件有细微差别，另外 queueJob 支持数组形式的 cb：
#+begin_src typescript
// queueJob
if (
  (!queue.length ||
    !queue.includes(
      job,
      isFlushing && job.allowRecurse ? flushIndex + 1 : flushIndex
    )) &&
  job !== currentPreFlushParentJob
) {
  queue.push(job);
  queueFlush();
}
#+end_src

最后也都是调用 queueFlush() -> flushJobs() 来清空队列 pendingQueue/queue 。

所以下面还需要在 flushJobs() 里面去实现对 pre -> pendingQueue 类型队列 flush 操
作(~flushPreFlushCbs()~)。
** flushPreFlushCbs
:PROPERTIES:
:COLUMNS: %CUSTOM_ID[(Custom Id)]
:CUSTOM_ID: job-flush-pre
:END:

有关函数和变量

| name                 | type     | description                                                      |
|----------------------+----------+------------------------------------------------------------------|
| ~preFlushIndex~      | number   | used in `for` to flush pre jobs                                    |
| ~pendingPreFlushCbs~ | array    | the queue to store pre jobs                                      |
| ~activePreFlushCbs~  | array    | the non-repeat copy of ~pendingPreFlushCbs~, used to flushing    |
| ~queuePreFlushCb~    | function | 与 flushPreFlushCbs 对应的 pre job 入列函数                      |
| ~queueFlush~         | function | 执行队列任务的函数，三个类型的任务都在这里面执行(pre,post,queue) |
| ~flushJobs~          | function | 具体执行任务的函数，三种任务执行顺序是： pre -> queue -> post    |

#+begin_quote
*Tip*. ~activePreFlushCbs~ 和 ~pendingPreFlushCbs~ 的关系： 前者是后者的一个拷贝，
拷贝完会立即清空 pending, 目的是为了让 pending 在 active flushing 期间能继续收集
新的任务，这样如果在执行期间有新的任务入列，那么在函数最后的递归操作会对这些新入
列的任务继续 flush 掉，直到再也没有新的任务入列为止。

*注意点* ：当 ~queuePreFlushCb~ 在 queueJob 中使用时不会主动触发 cbs 执行，如果
需要立即执行这些 cbs 需要手动调用 ~flushPreFlushCbs(seen, parentJob)~ 去刷掉 pre
cbs 任务，或者等到当前 job 执行完了下一个 ~flushJobs()~ 调用中执行，因为
~queueJob()~ 执行期间 ~isFlushing = true~ ，而在 ~queueFlush()~ 中有检测这个值，
如果正在执行 flushing 是不会继续执行的，更多详情查看后面的测试和分析。
#+end_quote

源码：
#+begin_src typescript
export function flushPreFlushCbs(
  seen?: CountMap,
  parentJob: SchedulerJob | null = null
) {
  if (pendingPreFlushCbs.length) {
    currentPreFlushParentJob = parentJob;
    activePreFlushCbs = [...new Set(pendingPreFlushCbs)];
    pendingPreFlushCbs.length = 0;
    if (__DEV__) {
      seen = seen || new Map();
    }

    for (
      preFlushIndex = 0;
      preFlushIndex < activePreFlushCbs.length;
      preFlushIndex++
    ) {
      // TODO 检查递归更新问题
      activePreFlushCbs[preFlushIndex]();
    }

    activePreFlushCbs = null;
    preFlushIndex = 0;
    currentPreFlushParentJob = null;
    // 递归 flush 直到所有 pre jobs 被执行完成
    flushPreFlushCbs(seen, parentJob);
  }
}
#+end_src

用途： api watch 里面对默认类型(~pre~)的任务的入列操作，如下代码：
#+begin_src typescript
// default: 'pre'
function doWatch(
  source: WatchSource | WatchSource[] | WatchEffect | object,
  cb: WatchCallback | null,
  { immediate, deep, flush, onTrack, onTrigger }: WatchOptions = EMPTY_OBJ,
  instance = currentInstance
): WatchStopHandle {
  // ...
  let scheduler: ReactiveEffectOptions["scheduler"];
  if (flush === "sync") {
    // ...
  } else if (flush === "post") {
    // ...
  } else {
    // default: 'pre'
    scheduler = () => {
      if (!instance || instance.isMounted) {
        queuePreFlushCb(job);
      } else {
        // with 'pre' option, the first call must happen before
        // the component is mounted so it is called synchronously.
        job();
      }
    };
  }
  // ...
}
#+end_src

测试：
#+begin_src js
// 源文件：/js/vue/lib.js
const {
  rc: { queueJob, queuePreFlushCb, flushPreFlushCbs, nextTick },
  log,
} = require(process.env.BLOG_JS + "/vue/lib.js");

const run = async () => {
  const calls = [];
  const job1 = () => { // #1
    queuePreFlushCb(cb1); // #2
    queuePreFlushCb(cb2); // #3
    // 手动触发 cb1, cb2
    flushPreFlushCbs(undefined, job1); // #4
    calls.push("job1"); // #5
  };
  const cb1 = () => calls.push("cb1"); // #6
  const cb2 = () => calls.push("cb2"); // #7

  queueJob(job1); // #8
  await nextTick(); // #9
  log.newline(calls); // #10
};
run();
#+end_src

#+RESULTS:
: undefined
:
: cb1 cb2 job1

测试分析代码脑图：
[[/img/vue3/runtime-core/vue-runtime-core-test-preflush-inside-queuejob.jpg]]

文字分析：
1. *#8* 先执行， queueJob -> push job1 -> queue:[job1] -> queueFlush()

   在 queueFlush() 中调用 ~resolvedPromise.then(flushJobs)~ 异步执行 flushJobs()
   函数刷掉所有任务(pre/job/post)

   并且记录当前 tick 下的 promise: ~currentFlushPromise~

   此时的 ~pendingPreFlushCbs[]~ 中是没有任何任务的，所以继续执行 try{...} 开始
   flush queue[] jobs，这个时候 flushIndex = 0 得到 job1，开始按顺序执行 job1

2. *#1* 开始执行

3. *#2* 将 cb1 push -> ~pendingPreFlushCbs=[cb1]~

4. *#3* 将 cb2 push -> ~pendingPreFlushCbs=[cb1, cb2]~

5. *#4* 手动 flush pre cbs

   在 ~flushPreFlushCbs(undefind, job1)~ 中会记录 ~currentPreFlushParentJob =
   job1~ 这个变量将会在 ~queueJob(job)~ 中用来检测 job 是不是当前的 job1 如果是
   就不允许 push，因为 job1 下有子任务正在执行，必须等这些子任务(cb1, cb2) 执行完。

6. *#6* 开始执行， push 'cb1' -> calls: ['cb1']

7. *#7* 开始执行， push 'cb2' -> calls: ['cb1', 'cb2']

8. *#5* 开始执行， push 'job1' -> alls: ['cb1', 'cb2', 'job1']

9. *#9* 开始执行，因为 nextTick()

   #+begin_src typescript
   export function nextTick(
     this: ComponentPublicInstance | void,
     fn?: () => void
   ): Promise<void> {
     const p = currentFlushPromise || resolvedPromise;
     return fn ? p.then(this ? fn.bind(this) : fn) : p;
   }
   #+end_src

   这里的 await 会等 job1 queueFlush() 触发的 promise.then(flushJobs) 返回的
   promise 完成之后再执行后面的代码。

10. *#10* log 输出 ~'cb1,cb2,job1'~

** queuePostFlushCb + flushPostFlushCbs

[[https://github.com/gcclll/stb-vue-next/commit/845c21bfc0ef1797d39a9fd789d79a4fdc3bd399][feat(add): rc->scheduler->queuePostFlushCb+flushPostFlushCbs · gcclll/stb-vue-next@845c21b · GitHub]]

逻辑脑图：
[[/img/tmp/20210113143628.png]]

有了 queue job 和 pre cb 的基础分析，这部分也就很好理解了。

#+begin_src typescript
export function queuePostFlushCb(cb: SchedulerCbs) {
  queueCb(cb, activePostFlushCbs, pendingPostFlushCbs, postFlushIndex);
}

export function flushPostFlushCbs(seen?: CountMap) {
  if (pendingPostFlushCbs.length) {
    const deduped = [...new Set(pendingPostFlushCbs)];
    pendingPostFlushCbs.length = 0;

    // #1947 already has active queue, nested flushPostFlushCbs call
    if (activePostFlushCbs) {
      activePostFlushCbs.push(...deduped);
      return;
    }

    activePostFlushCbs = deduped;
    if (__DEV__) {
      seen = seen || new Map();
    }

    activePostFlushCbs.sort((a, b) => getId(a) - getId(b));

    for (
      postFlushIndex = 0;
      postFlushIndex < activePostFlushCbs.length;
      postFlushIndex++
    ) {
      // TODO 递归 update 检查
      activePostFlushCbs[postFlushIndex]();
    }

    activePostFlushCbs = null;
    postFlushIndex = 0;
  }
}
#+end_src

和 pre cb 的处理有两个不同点：
1. 非回调形式处理 flushing 期间接受到的新任务，而是通过改变执行器
   activePostFlushCbs 来实现(和 queue job 类似)
2. 没有递归回调形式处理后续的新任务，参考 *1*

测试：
#+begin_src js
// 源文件：/js/vue/lib.js
const {
  rc: { queuePostFlushCb, nextTick, queueJob },
  log,
} = require(process.env.BLOG_JS + "/vue/lib.js");

// len = activePostFlushCbs.length
const run = async () => {
  const calls = [];
  const cb1 = () => {
    calls.push("cb1");
    // 会在同一个 tick 期间执行，因为它在for flushing 期间改变了
    // activePostFlushCbs，并且紧随 cb1,cb2,cb3 之后执行
    queuePostFlushCb(cb4);
  };
  const cb2 = () => calls.push("cb2");
  const cb3 = () => calls.push("cb3");
  // job1 会在 cb4 之后执行，因为 flushJobs 在按顺序执行完
  // pre -> job -> post 最后的 finally 里面对 queue 进行了检测
  // 此时 queue = [job1] 随意会递归调用 flushJobs() 继续刷
  // 但是为什么 cb5 会在 job1 之后呢？？？
  // 因为 queuePostFlushCb push 的是 pendingPostFlushCbs 而不是
  // activePostFlushCbs，所以在 queuePostFlushCb 中调用自身增加的新
  // cbs 会在 finally 后面的检测递归 flushJobs() 调用中执行
  // 而 post 的优先级又低于 job 所以 job1 会优先输出
  const cb4 = () => (queuePostFlushCb(cb5), queueJob(job1), calls.push("cb4"));
  // 会在 job1,cb5 之后执行
  const job1 = () => (queuePostFlushCb(cb6), calls.push("job1"));
  const cb5 = () => calls.push("cb5");
  const cb6 = () => calls.push("cb6");

  queuePostFlushCb([cb1, cb2]);
  queuePostFlushCb(cb3);

  // 应该去重
  queuePostFlushCb([cb1, cb3]);
  queuePostFlushCb(cb2);
  await nextTick();
  log.newline(calls);
};
run();
#+end_src

#+RESULTS:
: undefined
:
: cb1 cb2 cb3 cb4 job1 cb5 cb6

#+begin_quote
对于 ~queuePostFlushCb~ 和 ~queueJob~ 的混用只要记住一点， ~queuePostFlushCb~ 不
会触发 ~activePostFlushCbs~ 改变，因为 isFlushing = true，所以只会在当前
~flushJobs()~ 执行到最后递归检测的时候才会进入下一次的 post+job 调用。
#+end_quote

** test nested(pre/job/post)

完整的测试用例，结合 pre, post, queue 三种类型的任务进行测试。

#+begin_src js
// 源文件：/js/vue/lib.js
const {
  rc: { queueJob, queuePreFlushCb, nextTick, flushPreFlushCbs },
  log,
} = require(process.env.BLOG_JS + "/vue/lib.js");

const run = async () => {
  const calls = [];
  const cb1 = () => {
    calls.push("cb1");
  };
  const cb2 = () => {
    calls.push("cb2");
    // queueJob 和 queuePreFlushCb 结合使用
    queueJob(job1);
  };
  const cb3 = () => {
    calls.push("cb3");
    // 链式使用，cb4 会在 cb1,2,3 执行完成之后才会执行
    queuePreFlushCb(cb4);
  };
  const cb4 = () => {
    calls.push("cb4");
  };
  const cb5 = () => {
    calls.push("cb5");
  };
  const job1 = () => {
    calls.push("job1");
    // queuePreFlushCb 在 queueJob 中调用
    // pre cbs 在 job 中调用的时候不会被执行，除非在这后面手动 flush
    // 或者有新的任务进来，发起 flushJobs 调用才会执行
    queuePreFlushCb(cb5);
    // 必须手动触发, 这样 cb5 才会输出
    flushPreFlushCbs(undefined, job1 /* currentPreFlushParentJob */);
  };
  const cb6 = () => {
    calls.push("cb6");
  };

  queuePreFlushCb(cb1);
  queuePreFlushCb(cb2);
  queuePreFlushCb(cb1);
  queuePreFlushCb(cb2);
  queuePreFlushCb(cb3);

  await nextTick();
  log("\n" + calls);
};
run();
#+end_src

#+RESULTS:
: undefined
: cb1,cb2,cb3,cb4,job1,cb5

1. pendingPreFlushCbs 虽然是个数组，但是 flush 期间通过 ~[...new
   Set(pendingPreFlushCbs)]~ 进行了去重操作。
2. 链式操作，因为在执行期间使用的是 ~activePreFlushCbs~ 且此时的
   ~pendingPreFlushCbs~ 清空了，等待新任务入列

   在执行 cb3 期间，调用 ~queuePreFlushCb(cb4)~ 此时 push cb4 ->
   ~pendingPreFlushCbs~ ，但实际不会影响本次的 for 循环执行

   [[#job-queue-job][这点和 queueJob 有点不同，它直接使用的是 queue -> for 所以有新的任务入列会改
   变 for 的执行长度(queue.length)]]

   pre 处理会等到 activePreFlushCbs for 执行循环结束后，在函数的最后递归调用
   ~flushPreFlushCbs()~ 来刷掉新入列的任务(如： *cb4*)
3. queueJob 在 queuePreFlushCb 中调用的时候， queue job 总是在 pre cb 之后被执行，这也
   是 flushJobs 中处理代码应体现出的结果。

  #+begin_src typescript
  function flushJobs() {
    // 1. flush pre -> flushPreFlushCbs()
    // 2. for -> queue job -> callWithErrorHandling(job, ...)
    // 3. flush post -> flushPostFlushCbs()
  }
  #+end_src

  并且如上面实例结果 cb4 嵌套在 cb3 ，job1 嵌套在了 cb2 中，但是最后还是 cb4 先
   得到执行了，job1 再执行。

   #+begin_quote
   Tip. 因此，对于 pre cbs 和 queue jobs 两个类型的任务，不管什么时机入列的，都会
   是先执行 pre cbs 再执行 queue jobs
   #+end_quote
4. queuePreFlushCb 在 queueJob 中调用的时候，新的 pre job 会在 queue job 后执行

   [[https://github.com/gcclll/stb-vue-next/commit/b0155c5405deba3da37c60d2beb8d08a377f699d][fix: rc->scheduler->flushJobs recursive · gcclll/stb-vue-next@b0155c5 ·
   GitHub]]

   原因： ~flushPreFlushCbs~ 先于 queue jobs 执行，因此 queue jobs(~job1~) 执行
   的时候 ~queuePreFlushCb()~ 加入的任务(~cb5~)此时不会执行，而是等 queue jobs
   都执行完之后在finally 里面会做一次检测

   #+begin_src typescript
   if (queue.length || pendingPreFlushCbs.length) {
      flushJobs(seen)
    }
   #+end_src

   这个时候会去递归 ~flushJobs()~ 此时才发现有新的 ~pendingPreFlushCbs~ (如：
   ~cb5~)，则将执行他们，所以结果是 ~job1,cb5~ 。

** invalidateJob(job)

[[https://github.com/gcclll/stb-vue-next/commit/24808b106cfaad8af29a7343918a21836f1aff5d][feat(add): rc->scheduler->invalidateJob · gcclll/stb-vue-next@24808b1 · GitHub]]

是任务失效，其实就是单纯的将 Job 从 queue 中删除了。

#+begin_src typescript
export function invalidateJob(job: SchedulerJob) {
  const i = queue.indexOf(job);
  if (i > -1) {
    queue.splice(i, 1);
  }
}
#+end_src

测试:
#+begin_src js
// 源文件：/js/vue/lib.js
const {
  rc: { queueJob, queuePostFlushCb, invalidateJob, nextTick },
  log,
} = require(process.env.BLOG_JS + "/vue/lib.js");

const run = async () => {
  const calls = [];
  const job1 = () => {
    calls.push("job1");
    invalidateJob(job2); // 这里将 job2 从 queue[] 中删除了
    job2(); // 注释这个结果会是： job1 job3 job4
  };
  const job2 = () => {
    calls.push("job2");
  };
  const job3 = () => {
    calls.push("job3");
  };
  const job4 = () => {
    calls.push("job4");
  };

  queueJob(job1);
  queueJob(job2);
  queueJob(job3);
  queuePostFlushCb(job4);
  await nextTick();
  log.newline(calls);
};
run();
#+end_src

#+RESULTS:
: undefined
:
: job1 job2 job3 job4
** job sort id 任务可以排序

只有 post 和 job 支持排序。

测试：
#+begin_src js
// 源文件：/js/vue/lib.js
const {
  rc: { queueJob, queuePostFlushCb, nextTick },
  log,
} = require(process.env.BLOG_JS + "/vue/lib.js");

const run = async () => {
  const calls = [];
  const job1 = () => calls.push("job1");
  const job2 = () => calls.push("job2");
  const job3 = () => calls.push("job3");
  // job1 no id
  job2.id = 2;
  job3.id = 1;

  const cb1 = () => calls.push("cb1");
  const cb2 = () => calls.push("cb2");
  const cb3 = () => calls.push("cb3");
  cb1.id = 2;
  // cb2 no id
  cb3.id = 1;

  queueJob(job1);
  queueJob(job2);
  queueJob(job3);
  queuePostFlushCb(cb1);
  queuePostFlushCb(cb2);
  queuePostFlushCb(cb3);
  await nextTick();
  log.newline(calls);
};
run();
#+end_src

#+RESULTS:
: undefined
:
: job3 job2 job1 cb3 cb1 cb2
** allowRecurse 自身递归

用 job.allowRecurse 来控制 job 是否可以自己触发自己执行(PS. pre/job/post 都支持
该属性)。

[[/img/vue3/runtime-core/vue-runtime-core-job-allowRecurse.jpg]]

#+begin_src js
// 源文件：/js/vue/lib.js
const {
  rc: { queueJob, nextTick },
  log,
} = require(process.env.BLOG_JS + "/vue/lib.js");

const run = async () => {
  let count = 0;
  const job = () => {
    if (count < 3) {
      count++;
      queueJob(job);
    }
  };
  queueJob(job);
  queueJob(job);
  await nextTick();
  log.newline("before count: " + count);
  // 设置 allowRecurse = true 允许自我调度
  count = 0;
  job.allowRecurse = true;
  // 重复入列同一个任务会在 push 阶段就检测和自身递归调用不同
  queueJob(job);
  queueJob(job);
  await nextTick();
  log.newline("after count: " + count);
};
run();
#+end_src

#+RESULTS:
: undefined
:
: before count: 1
:
:
: after count: 3
** checkRecursiveUpdates

[[https://github.com/gcclll/stb-vue-next/commit/7bcc14b6be11693ddb0cc9d4202727f2ebc83995][feat(add): rc->scheduler->checkRecursiveUpdates · gcclll/stb-vue-next@7bcc14b ·
GitHub]]

限制调用自身的次数，在 allowRecurse = true 情况下使用。

#+begin_src js
// 源文件：/js/vue/lib.js
const {
  rc: { queueJob, nextTick },
  log,
} = require(process.env.BLOG_JS + "/vue/lib.js");

const run = async () => {
  let count = 0;
  const job = () => {
    if (count < 101) {
      count++;
      queueJob(job);
    }
  };
  job.allowRecurse = true;
  queueJob(job);
  try {
    await nextTick();
  } catch (e) {
    log.newline(e.message);
  }
};
run();
#+end_src

#+RESULTS:
: undefined
:
: Maximum recursive updates exceeded. This means you have a reactive effect that is mutating its own dependencies and thus recursively triggering itself. Possible sources include component template, render function, updated hook or watcher source function.
** 小结

[[/img/vue3/runtime-core/vue-runtime-core-scheduler-comparation.jpg]]

*pre cbs*: 执行优先级最高，在同一 tick 中会递归调用自身清空 ~pendingPreFlushCbs~
 中的任务，在 ~queueJob~ 中调用时不会自动触发需要手动触发执行，因为此时
 ~isFlushing = true~ 。

*job*: 执行优先级次之，在同一 tick 中同一个 for queue -> flushIndex 下会处理此
  时接受到的新任务，在 pre cbs 中调用时会在所有 pre cbs 执行之后执行。

*post cbs*: 执行优先级最低，在同一 tick 同一次 ~flushPostFlushCbs()~ 调用中不会
 处理新的 post 任务，而是在 ~flushJobs()~ 执行到最后 finally 部分检
 测 ~pendingPostFlushCbs~ 任务队列来处理当前 tick 下新接受到的任务，
 在 ~queuePreFlushCb()~ 和 ~queueJob()~ 中调用的时候会在他们的任务之后执行。
* BUGs fix & Questions

[[https://github.com/gcclll/stb-vue-next/commit/2a1ab0448919ea75c5794410a03265bd99e05d75][fix: no import EMPTY_ARR · gcclll/stb-vue-next@2a1ab04 · GitHub]]

** nextTick() 后面的代码最后执行？
:PROPERTIES:
:COLUMNS: %CUSTOM_ID[(Custom Id)]
:CUSTOM_ID: q-nexttick
:END:

测试代码： [[#nexttick][nextTick]]

先看一段代码，以及 [[https://babeljs.io/repl][babeljs.io]] 转换之后的结果：

babel 之前：
#+begin_src js
const run = async () => {
  const p = Promise.resolve().then();

  const p1 = p.then(() => console.log("before await"));
  console.log("between await and p1");
  await p1;
  console.log("after await");
  const p2 = Promise.resolve().then();
  await p2;
  console.log("after p2");
};
run();
#+end_src

babel 之后(只贴出核心部分)：
#+begin_src js
while (1) {
  switch ((_context.prev = _context.next)) {
    case 0:
      p = Promise.resolve().then();
      p1 = p.then(function () {
        return console.log("before await");
      });
      console.log("between await and p1");
      _context.next = 5;
      return p1;

    case 5:
      console.log("after await");
      p2 = Promise.resolve().then();
      _context.next = 9;
      return p2;

    case 9:
      console.log("after p2");

    case 10:
    case "end":
      return _context.stop();
  }
}
#+end_src

即上面的代码被转换之后变成了一个 switch，里面是一个 while 循环，异步代码最终的顺
序执行由 _context.next 来衔接。

~case 0~ -> ~next = 5~ -> ~case 5~ -> ~next = 9~ -> ...

所以说 nextTick() 后面的代码都会被放到异步代码
* runtime-test 模块简介

这里测试需要用到这个模块，所以简单用脑图描述下这里面有哪些东西和干什么的。

[[/img/vue3/runtime-core/vue-runtime-test.svg]]

* 重要类型声明

:PROPERTIES:
:COLUMNS: %CUSTOM_ID[(Custom Id)]
:CUSTOM_ID: defines
:END:
1. 异步组件选项

    #+begin_src typescript
    export interface AsyncComponentOptions<T = any> {
    loader: AsyncComponentLoader<T>
    loadingComponent?: Component
    errorComponent?: Component
    delay?: number
    timeout?: number
    suspensible?: boolean
    onError?: (
        error: Error,
        retry: () => void,
        fail: () => void,
        attempts: number
    ) => any
    }
    #+end_src

2. Vue App 类型

   #+begin_src typescript
    export interface App<HostElement = any> {
      version: string;
      config: AppConfig;
      use(plugin: Plugin, ...options: any[]): this;
      mixin(mixin: ComponentOptions): this;
      component(name: string): Component | undefined;
      component(name: string, component: Component): this;
      directive(name: string): Directive | undefined;
      directive(name: string, directive: Directive): this;
      mount(
        rootContainer: HostElement | string,
        isHydrate?: boolean
      ): ComponentPublicInstance;
      unmount(rootContainer: HostElement | string): void;
      provide<T>(key: InjectionKey<T> | string, value: T): this;

      // internal, but we need to expose these for the server-renderer and devtools
      _uid: number;
      _component: ConcreteComponent;
      _props: Data | null;
      _container: HostElement | null;
      _context: AppContext;
    }
   #+end_src

   App 配置:

   #+begin_src typescript
    export interface AppConfig {
      // @private
      readonly isNativeTag?: (tag: string) => boolean;

      performance: boolean;
      optionMergeStrategies: Record<string, OptionMergeFunction>;
      globalProperties: Record<string, any>;
      isCustomElement: (tag: string) => boolean;
      errorHandler?: (
        err: unknown,
        instance: ComponentPublicInstance | null,
        info: string
      ) => void;
      warnHandler?: (
        msg: string,
        instance: ComponentPublicInstance | null,
        trace: string
      ) => void;
    }
   #+end_src

   Vue 插件类型：

   #+begin_src typescript
    type PluginInstallFunction = (app: App, ...options: any[]) => any;
    export type Plugin =
      | (PluginInstallFunction & { install?: PluginInstallFunction })
      | {
          install: PluginInstallFunction;
        };
   #+end_src

3. api watch 类型

   #+begin_src typescript
    export interface WatchOptionsBase {
      flush?: "pre" | "post" | "sync";
      onTrack?: ReactiveEffectOptions["onTrack"];
      onTrigger?: ReactiveEffectOptions["onTrigger"];
    }

    export interface WatchOptions<Immediate = boolean> extends WatchOptionsBase {
      immediate?: Immediate;
      deep?: boolean;
    }
   #+end_src

4. component 组件类型

   #+begin_src typescript
    // 内部选项
    export interface ComponentInternalOptions {
      /**
    ,* @internal
    ,*/
      __props?: NormalizedPropsOptions;
      /**
    ,* @internal
    ,*/
      __emits?: ObjectEmitsOptions | null;
      /**
    ,* @internal
    ,*/
      __scopeId?: string;
      /**
    ,* @internal
    ,*/
      __cssModules?: Data;
      /**
    ,* @internal
    ,*/
      __hmrId?: string;
      /**
    ,* This one should be exposed so that devtools can make use of it
    ,*/
      __file?: string;
    }

    // 函数式组件
    export interface FunctionalComponent<P = {}, E extends EmitsOptions = {}>
      extends ComponentInternalOptions {
      // use of any here is intentional so it can be a valid JSX Element constructor
      (props: P, ctx: Omit<SetupContext<E>, "expose">): any;
      props?: ComponentPropsOptions<P>;
      emits?: E | (keyof E)[];
      inheritAttrs?: boolean;
      displayName?: string;
    }

    // 类组件
    export interface ClassComponent {
      new (...args: any[]): ComponentPublicInstance<any, any, any, any, any>;
      __vccOpts: ComponentOptions;
    }

    // 生命周期函数缩写
    export const enum LifecycleHooks {
      BEFORE_CREATE = "bc",
      CREATED = "c",
      BEFORE_MOUNT = "bm",
      MOUNTED = "m",
      BEFORE_UPDATE = "bu",
      UPDATED = "u",
      BEFORE_UNMOUNT = "bum",
      UNMOUNTED = "um",
      DEACTIVATED = "da",
      ACTIVATED = "a",
      RENDER_TRIGGERED = "rtg",
      RENDER_TRACKED = "rtc",
      ERROR_CAPTURED = "ec",
    }

    // setup 函数
    export interface SetupContext<E = EmitsOptions> {
      attrs: Data;
      slots: Slots;
      emit: EmitFn<E>;
      expose: (exposed: Record<string, any>) => void;
    }
   #+end_src

5. component internal instance

   这里涵盖了一个组件都有哪些属性：

   ~uid, type, parent, root, appContext, vnode, next, subTree, update~,

   ~render, ssrRender, provides, effects, accessCache, renderCache~,

   ~components, directives, propsOptions, emitsOptions~,

   ~proxy, exposed, withProxy, ctx~,

   ~data, props, attrs, slots, refs, emit~,

   ~emitted, setupState, devtoolsRawSetupState, setupContext~,

   ~suspense, suspenseId, asyncDep, asyncResolved~,

   ~isMounted, isUnmounted, isDeactivated~,

   ~bc, c, bm, m, bu, u, bum, um, da, a, rtg, rtc, ec~
   #+begin_src typescript
    export const enum LifecycleHooks {
      BEFORE_CREATE = "bc",
      CREATED = "c",
      BEFORE_MOUNT = "bm",
      MOUNTED = "m",
      BEFORE_UPDATE = "bu",
      UPDATED = "u",
      BEFORE_UNMOUNT = "bum",
      UNMOUNTED = "um",
      DEACTIVATED = "da",
      ACTIVATED = "a",
      RENDER_TRIGGERED = "rtg",
      RENDER_TRACKED = "rtc",
      ERROR_CAPTURED = "ec",
    }
   #+end_src

   类型：
   #+begin_src typescript
    /**
     * We expose a subset of properties on the internal instance as they are
     * useful for advanced external libraries and tools.
     */
    export interface ComponentInternalInstance {
      uid: number;
      type: ConcreteComponent;
      parent: ComponentInternalInstance | null;
      root: ComponentInternalInstance;
      appContext: AppContext;
      /**
       * Vnode representing this component in its parent's vdom tree
       */
      vnode: VNode;
      /**
       * The pending new vnode from parent updates
       * @internal
       */
      next: VNode | null;
      /**
       * Root vnode of this component's own vdom tree
       */
      subTree: VNode;
      /**
       * The reactive effect for rendering and patching the component. Callable.
       */
      update: ReactiveEffect;
      /**
       * The render function that returns vdom tree.
       * @internal
       */
      render: InternalRenderFunction | null;
      /**
       * SSR render function
       * @internal
       */
      ssrRender?: Function | null;
      /**
       * Object containing values this component provides for its descendents
       * @internal
       */
      provides: Data;
      /**
       * Tracking reactive effects (e.g. watchers) associated with this component
       * so that they can be automatically stopped on component unmount
       * @internal
       */
      effects: ReactiveEffect[] | null;
      /**
       * cache for proxy access type to avoid hasOwnProperty calls
       * @internal
       */
      accessCache: Data | null;
      /**
       * cache for render function values that rely on _ctx but won't need updates
       * after initialized (e.g. inline handlers)
       * @internal
       */
      renderCache: (Function | VNode)[];

      /**
       * Resolved component registry, only for components with mixins or extends
       * @internal
       */
      components: Record<string, ConcreteComponent> | null;
      /**
       * Resolved directive registry, only for components with mixins or extends
       * @internal
       */
      directives: Record<string, Directive> | null;
      /**
       * reoslved props options
       * @internal
       */
      propsOptions: NormalizedPropsOptions;
      /**
       * resolved emits options
       * @internal
       */
      emitsOptions: ObjectEmitsOptions | null;

      // the rest are only for stateful components ---------------------------------

      // main proxy that serves as the public instance (`this`)
      proxy: ComponentPublicInstance | null;

      // exposed properties via expose()
      exposed: Record<string, any> | null;

      /**
       * alternative proxy used only for runtime-compiled render functions using
       * `with` block
       * @internal
       */
      withProxy: ComponentPublicInstance | null;
      /**
       * This is the target for the public instance proxy. It also holds properties
       * injected by user options (computed, methods etc.) and user-attached
       * custom properties (via `this.x = ...`)
       * @internal
       */
      ctx: Data;

      // state
      data: Data;
      props: Data;
      attrs: Data;
      slots: InternalSlots;
      refs: Data;
      emit: EmitFn;
      /**
       * used for keeping track of .once event handlers on components
       * @internal
       */
      emitted: Record<string, boolean> | null;

      /**
       * setup related
       * @internal
       */
      setupState: Data;
      /**
       * devtools access to additional info
       * @internal
       */
      devtoolsRawSetupState?: any;
      /**
       * @internal
       */
      setupContext: SetupContext | null;

      /**
       * suspense related
       * @internal
       */
      suspense: SuspenseBoundary | null;
      /**
       * suspense pending batch id
       * @internal
       */
      suspenseId: number;
      /**
       * @internal
       */
      asyncDep: Promise<any> | null;
      /**
       * @internal
       */
      asyncResolved: boolean;

      // lifecycle
      isMounted: boolean;
      isUnmounted: boolean;
      isDeactivated: boolean;
      /**
       * @internal
       */
      [LifecycleHooks.BEFORE_CREATE]: LifecycleHook;
      /**
       * @internal
       */
      [LifecycleHooks.CREATED]: LifecycleHook;
      /**
       * @internal
       */
      [LifecycleHooks.BEFORE_MOUNT]: LifecycleHook;
      /**
       * @internal
       */
      [LifecycleHooks.MOUNTED]: LifecycleHook;
      /**
       * @internal
       */
      [LifecycleHooks.BEFORE_UPDATE]: LifecycleHook;
      /**
       * @internal
       */
      [LifecycleHooks.UPDATED]: LifecycleHook;
      /**
       * @internal
       */
      [LifecycleHooks.BEFORE_UNMOUNT]: LifecycleHook;
      /**
       * @internal
       */
      [LifecycleHooks.UNMOUNTED]: LifecycleHook;
      /**
       * @internal
       */
      [LifecycleHooks.RENDER_TRACKED]: LifecycleHook;
      /**
       * @internal
       */
      [LifecycleHooks.RENDER_TRIGGERED]: LifecycleHook;
      /**
       * @internal
       */
      [LifecycleHooks.ACTIVATED]: LifecycleHook;
      /**
       * @internal
       */
      [LifecycleHooks.DEACTIVATED]: LifecycleHook;
      /**
       * @internal
       */
      [LifecycleHooks.ERROR_CAPTURED]: LifecycleHook;
    }
   #+end_src

6. emit fn 事件

   #+begin_src typescript
    export type EmitFn<
      Options = ObjectEmitsOptions,
      Event extends keyof Options = keyof Options
    > = Options extends Array<infer V>
      ? (event: V, ...args: any[]) => void
      : {} extends Options // if the emit is empty object (usually the default value for emit) should be converted to function
      ? (event: string, ...args: any[]) => void
      : UnionToIntersection<
          {
            [key in Event]: Options[key] extends (...args: infer Args) => any
              ? (event: key, ...args: Args) => void
              : (event: key, ...args: any[]) => void;
          }[Event]
        >;
   #+end_src
