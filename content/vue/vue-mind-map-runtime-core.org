#+TITLE: Vue3 æºç å¤´è„‘é£æš´ä¹‹ 7 â˜ runtime-core(1)
#+DATE: <2021-01-08 10:12:32>
#+TAGS[]: vue, vue3, runtime-core
#+CATEGORIES[]: vue
#+LANGUAGE: zh-cn
#+STARTUP: indent shrink


#+begin_export html
<link href="https://fonts.goo~gleapis.com/cs~s2?family=ZCOOL+XiaoWei&display=swap" rel="stylesheet">
<kbd>
<font color="blue" size="3" style="font-family: 'ZCOOL XiaoWei', serif;">
  è¯—å·ï¼šå…­é“åŒå ï¼Œé­”åŠ«ä¸‡åƒï¼Œå¼•æ¸¡å¦‚æ¥ã€‚
</font>
</kbd><br><br>
#+end_export

[[/img/bdx/yiyeshu-001.jpg]]

@@html:<kbd>@@
*[[https://github.com/gcclll/stb-vue-next][stb-vue-next]] å®Œå…¨æ‹·è´äº [[https://github.com/vuejs/vue-next][vue-next]] ï¼Œä¸»è¦ç›®çš„ç”¨äºå­¦ä¹ ã€‚*
@@html:</kbd>@@

#+begin_quote
*å£°æ˜* ï¼švue-next runtime-core è¿è¡Œæ—¶æ ¸å¿ƒä»£ç ï¼Œè¿™éƒ¨åˆ†å†…å®¹è¾ƒå¤šï¼Œå¯èƒ½ä¼šåˆ†ä¸ºå‡ ç¯‡æ¥
å™è¿°, ~f~ è¿‡æ»¤æ‰å¯¹è±¡ç©ºå€¼å±æ€§ã€‚

*æ›´æ–°æ—¥å¿—&Todos* ï¼š
1. [2021-01-08 10:12:50] åˆ›å»º
2. DONE [2021-01-15 10:24:00] scheduler
3. TODO apiWatch -> post cb & ssr
4. TODO STATEFUL_COMONENT
5. TODO patchFlag æµ‹è¯•å’Œç”¨é€”
6. TODO transformVNodeArgs
7. TODO Suspense ç»„ä»¶
8. TODO shouldTrack, currentBlock å’Œ [[#block-related][block ç›¸å…³å‡½æ•°]]çš„ä½œç”¨
#+end_quote

æ¨¡å—åˆå§‹åŒ–ï¼š [[https://github.com/gcclll/stb-vue-next/commit/b22b4db3506bf1ba4b266dcf9ff21f1e0b925a81][feat(init): runtime-core Â· gcclll/stb-vue-next@b22b4db Â· GitHub]]

[[/img/vue3/runtime-core/vue-runtime-core.svg]]

* Tips
1. class æ”¯æŒæ•°ç»„(~['foo', 'bar']~)ï¼Œå¯¹è±¡(~{foo:true,bar:false}~)ï¼Œå­—ç¬¦ä¸²(~'foo bar'~)
2. style æ”¯æŒæ•°ç»„(~['color:red', {foo:'foo'}]~)ï¼Œå¯¹è±¡(~{color:'red',foo:'foo'}~)ï¼Œå­—ç¬¦ä¸²(~color:red~)
3. class component æ¡ä»¶ï¼š
   1) function
   2) å« ~__vccOpts = { template: '<div />'}~
4. [[#test-vnode-ref][vnode ref å±æ€§åˆå¹¶å¤„ç†é€»è¾‘ï¼Ÿ]]
5. [[#test-vnode-key][vnode key å±æ€§ç®€å•çš„å€¼è¦†ç›–æ“ä½œï¼Ÿ]]
6. [[#scheduler][scheduler, vue-next ä¸­çš„ä»»åŠ¡è°ƒåº¦å™¨å¦‚ä½•å®ç°ï¼Ÿ]]
7. [[#api-watch][api watch(source, cb, option)]] ä¸­çš„ source åªèƒ½æ˜¯ ~reactive/ref/function/array~ ç±»å‹ï¼Œ
   å¦‚æœæ˜¯æ•°ç»„æ—¶å…¶å…ƒç´ åªèƒ½æ˜¯ ~reactive/ref/function~
8. [[#api-watch-deep][api watch(..., { deep: true }) æ˜¯å¦‚ä½•åšåˆ°æ·±åº¦ç›‘å¬çš„ï¼Ÿ]]
9. [[#watch-shallow-ref][api watch(shallowRef, /*cb*/ (newVal) => {}) æ˜¯å¦‚ä½•ç›´æ¥ä½¿ç”¨ newVal.a çš„ï¼Ÿ]]

   #+begin_src js
   var obj = shallowRef({ a: 0 });
   watch(shallowRef, (newVal) => {
     dummy = newVal.a; // è¿™é‡Œä¸ºä»€ä¹ˆå¯ä»¥ç›´æ¥è®¿é—® obj.aï¼Œobj åˆæ˜¯ä»€ä¹ˆï¼Ÿ
   });
   #+end_src
* init

å¯¼å‡ºå·²å®Œæˆæ¨¡å—(reactiviy)é‡Œçš„ Apis:
[[https://github.com/gcclll/stb-vue-next/commit/38e91a877635b51b56a2918ff173a48638b8760a][feat(init): runtime-core> add exports from @vue/reactivity Â· gcclll/stb-vue-next@38e91a8 Â· GitHub]]

è¿™éƒ¨åˆ†ä»£ç æœ‰ç‚¹å¤šï¼Œæ‰€ä»¥è¿™é‡Œäº‹å…ˆå°†æ‰€æœ‰ç±»å‹å®šä¹‰æ·»åŠ å¥½ï¼š

[[https://github.com/gcclll/stb-vue-next/commit/e3f7b94ef39cf389aaf25f55ea81877941860f56][feat(add): runtime-core>all types Â· gcclll/stb-vue-next@e3f7b94 Â· GitHub]]

æœ‰å…³ç±»å‹å®šä¹‰è¯·ç§»æ­¥[[#defines][æœ€åä¸€èŠ‚]](çº¯è´´ä»£ç çš„ï¼Œæ‰€ä»¥æ”¾åˆ°æœ€å)
* h function

[[https://github.com/gcclll/stb-vue-next/commit/e48d5e28c4e1b55c6d6a326bcf0808047e23ceeb][feat(add): runtime-core>h function Â· gcclll/stb-vue-next@e48d5e2 Â· GitHub]]

~h~, render å‡½æ•°åˆå§‹åŒ–ã€‚

#+begin_src typescript
// Actual implementation
export function h(type: any, propsOrChildgen?: any, children?: any): VNode {
  // TODO
  return {} as VNode;
}
#+end_src

å®ç°ï¼š
#+begin_src typescript
// Actual implementation
export function h(type: any, propsOrChildgen?: any, children?: any): VNode {
  const l = arguments.length;
  if (l === 2) {
    if (isObject(propsOrChildgen) && !isArray(propsOrChildgen)) {
      // æ²¡æœ‰ props çš„ å•èŠ‚ç‚¹(single vnode)
      if (isVNode(propsOrChildgen)) {
        return createVNode(type, null, [propsOrChildgen]);
      }
      // æœ‰ props æ²¡æœ‰ children
      return createVNode(type, propsOrChildgen);
    } else {
      // omit props
      return createVNode(type, null, propsOrChildgen);
    }
  } else {
    // ä»ç¬¬ä¸‰ä¸ªå‚æ•°å¼€å§‹å…¨å½“åšå­©å­èŠ‚ç‚¹å¤„ç†
    if (l > 3) {
      children = Array.prototype.slice.call(arguments, 2);
    } else if (l === 3 && isVNode(children)) {
      children = [children];
    }
    return createVNode(type, propsOrChildgen, children);
  }
}
#+end_src

h, æ¥å—ä¸å®šå‚æ•°

é€»è¾‘è„‘å›¾:

[[/img/tmp/20210108152508.png]]

ä»è„‘å›¾åˆ†æ”¯å¾—å‡ºæ”¯æŒçš„æƒ…å†µä»£ç ç¤ºä¾‹ï¼š

1. ~h('div')~ æ— å‚æ•°æ— å­©å­
2. ~h('div', { id: 'foo' })~ æœ‰ props æ—  children
3. ~h('div', ['foo'])~ æ•°ç»„å½“åš chilren
4. ~h('div', vnode)~ æœ‰ __v_isVNode æ ‡è¯†å½“åš childrenï¼Œå¹¶è½¬æˆæ•°ç»„ ~[vnode]~
5. ~h('div', {}, ['foo'])~ æœ‰ props æœ‰ children
6. ~h('div', {}, vnode)~ æœ‰ props, æœ‰ children ä¸” = ~[vnode]~

æ¥ä¸‹æ¥éœ€è¦å…·ä½“å»å®ç° ~createVNode~ å‡½æ•°ã€‚
* createVNode function

[[https://github.com/gcclll/stb-vue-next/commit/194f72fee239da947ef82a4da099c23c758d3d84][feat(add): rc->createVNode Â· gcclll/stb-vue-next@194f72f Â· GitHub]]

è¿™ä¸ªå‡½æ•°æœ€ç»ˆæ˜¯æ„é€ äº† vnode: VNode è™šæ‹ŸèŠ‚ç‚¹ç»“æ„ï¼Œè¿”å›ã€‚

è¿™é‡Œé¢åˆ†ä¸ºä»¥ä¸‹å‡ ä¸ªæ­¥éª¤å®ç°ï¼š

1. type æ˜¯ vnode æ—¶å€™å¤„ç†
2. class ç»„ä»¶å¤„ç†
3. props å¤„ç†
4. shapeFlag æ£€æµ‹ï¼Œæ˜¯ä»€ä¹ˆç±»å‹ çš„ vnode
5. ç»„ä»¶å¯¹è±¡ä¸åº”è¯¥ reactive(æœ‰çŠ¶æ€çš„ç»„ä»¶, STATEFUL_COMONENT)
6. æ„å»º vnode: VNode å¯¹è±¡
7. æ£€æµ‹ vnode.key æ˜¯ä¸æ˜¯ ~NaN~
8. normalize children
9. normalize suspense children
10. currentBlock å¤„ç†
11. è¿”å› vnode èŠ‚ç‚¹

#+begin_src js
// æºæ–‡ä»¶ï¼š/js/vue/lib.js
const {
  rc: { h, createVNode, reactive },
  f,
  log,
} = require(process.env.BLOG_JS + "/vue/lib.js");
const _h = (...args) => f(h(...args));

log([">>> type only\n", _h("div")]);
log([">>> type + props\n", _h("div", { id: "foo" })]);
log([">>> type + omit props\n", _h("div", ["foo"])]);
#+end_src

#+RESULTS:
#+begin_example
>>> type only
 { __v_isVNode: true, __v_skip: true, type: 'div', shapeFlag: 1 }
>>> type + props
 {
  __v_isVNode: true,
  __v_skip: true,
  type: 'div',
  props: { id: 'foo' },
  shapeFlag: 1
}
>>> type + omit props
 { __v_isVNode: true, __v_skip: true, type: 'div', shapeFlag: 1 }
>>> default slot
 {
  __v_isVNode: true,
  __v_skip: true,
  type: { template: '<br />' },
  shapeFlag: 4
}
undefined
#+end_example

** d3c6563 props

[[https://github.com/gcclll/stb-vue-next/commit/d3c656331e3e5a9206f0341dd2ca960a300f96ba][feat(add): rc->createVNode, props Â· gcclll/stb-vue-next@d3c6563 Â· GitHub]]

å¤„ç† class å’Œ style å±æ€§ã€‚

#+begin_src typescript
 // 3. props å¤„ç†, class & style normalization
 if (props) {
   // for reactive or proxy objects, we need to clone it to enable mutation.
   if (isProxy(props) || InternalObjectKey in props) {
     props = extend({}, props);
   }
   let { class: klass, style } = props;
   if (klass && !isString(klass)) {
     // 1. string -> klass
     // 'foo' -> 'foo'
     // 2. array -> '' + arr.join(' ')
     // ['foo', 'bar'] -> 'foo bar'
     // 3. object -> '' + value ? ' value' : ''
     // { foo: true, bar: false, baz: true } -> 'foo baz'
     props.class = normalizeClass(klass);
   }

   if (isObject(style)) {
     // reactive state objects need to be cloned since they are likely to be
     // mutated
     if (isProxy(style) && !isArray(style)) {
       style = extend({}, style);
     }
     // 1. array -> object
     // [{ color: 'red' }, 'font-size:10px;height:100px;'] ->
     // { color: 'red', 'font-size': '10px', height: '100px' }
     // 2. object -> object åŸæ ·è¿”å›
     props.style = normalizeStyle(style);
   }
 }
#+end_src

1. class æ•°ç»„ï¼Œå¯¹è±¡ï¼Œå­—ç¬¦ä¸²ï¼Ÿ

   æ•°ç»„ï¼š åˆå¹¶æˆå­—ç¬¦ä¸²ï¼Œ ~['foo', 'bar']~ -> 'foo bar'

   å¯¹è±¡ï¼š åˆå¹¶æˆå­—ç¬¦ä¸²ï¼Œ ~{foo: true, bar: false, baz: true}~ -> 'foo baz'

   å­—ç¬¦ä¸²ï¼š åŸæ ·è¾“å‡º

   #+begin_src typescript
   export function normalizeClass(value: unknown): string {
     let res = "";
     if (isString(value)) {
       res = value;
     } else if (isArray(value)) {
       for (let i = 0; i < value.length; i++) {
         res += normalizeClass(value[i]) + " ";
       }
     } else if (isObject(value)) {
       for (const name in value) {
         if (value[name]) {
           res += name + " ";
         }
       }
     }
     return res.trim();
   }
   #+end_src

2. style æ•°ç»„ï¼Œå¯¹è±¡ï¼Œå­—ç¬¦ä¸²ï¼Ÿ

   æ•°ç»„ï¼š åˆå¹¶æˆå¯¹è±¡ï¼Œ ~['color:red', { 'font-size': '10px', height: '100px' }]~ -> ~{color:
   'red', 'font-size': '10px', height: '100px'}~

   å¯¹è±¡ï¼š åŸæ ·è¿”å›

   å­—ç¬¦ä¸²ï¼šè§£ææˆå¯¹è±¡ï¼Œ å¦‚æ•°ç»„å†…å­—ç¬¦ä¸²éƒ¨åˆ†

   #+begin_src typescript
    export function normalizeStyle(value: unknown): NormalizedStyle | undefined {
      if (isArray(value)) {
        const res: Record<string, string | number> = {};
        for (let i = 0; i < value.length; i++) {
          const item = value[i];
          const normalized = normalizeStyle(
            isString(item) ? parseStringStyle(item) : item
          );
          if (normalized) {
            for (const key in normalized) {
              res[key] = normalized[key];
            }
          }
        }
        return res;
      } else if (isObject(value)) {
        return value;
      }
    }
   #+end_src


æµ‹è¯•ï¼š

#+begin_src js

// æºæ–‡ä»¶ï¼š/js/vue/lib.js
const { rc: { h, createVNode: c }, f, log } = require(process.env.BLOG_JS + '/vue/lib.js')
let _h = (...args) => f(c(...args), 'props')

// class åˆå¹¶æˆå­—ç¬¦ä¸²
log(['>>> class: string\n', _h('p', { class: 'foo baz' })])
log(['>>> class: array\n', _h('p', { class: ['foo', 'baz'] })])
log(['>>> class: array<object|string>\n', _h('p', { class: [{ foo:  'foo' }, 'baz', { baz: 'baz' }] })])
log(['>>> class: object\n', _h('p', { class: {'foo': true, 'baz': false, 'bar': true} })])

// style åˆå¹¶æˆå¯¹è±¡
log(['>>> style: array\n', _h('p', { style: [{ foo: 'foo' }, { baz: 'baz' }] })])
log(['>>> style: object\n', _h('p', {
  style: { foo: 'foo', baz: 'baz' }
})])
log(['>>> style: array<object|string>\n', _h('p', {
  style: [{ foo: 'foo' }, 'color:red', { baz: 'baz' }]
})])
#+end_src

#+RESULTS:
#+begin_example
>>> class: string
 { props: { class: 'foo baz' } }
>>> class: array
 { props: { class: 'foo baz' } }
>>> class: array<object|string>
 { props: { class: 'foo baz baz' } }
>>> class: object
 { props: { class: 'foo bar' } }
>>> style: array
 { props: { style: { foo: 'foo', baz: 'baz' } } }
>>> style: object
 { props: { style: { foo: 'foo', baz: 'baz' } } }
>>> style: array<object|string>
 { props: { style: { foo: 'foo', color: 'red', baz: 'baz' } } }
undefined
#+end_example
** class component

æ˜¯ç±»ç»„ä»¶å‰ææ˜¯ï¼š

1. å¿…é¡»æ˜¯å‡½æ•°
2. å¿…é¡»åŒ…å« ~__vccOpts~ å±æ€§

#+begin_src typescript
  // 2. class component
  if (isClassComponent(type)) {
    type = type.__vccOpts;
  }

  export function isClassComponent(value: unknown): value is ClassComponent {
    return isFunction(value) && "__vccOpts" in value;
  }
#+end_src

æµ‹è¯•ï¼š
#+begin_src js

// æºæ–‡ä»¶ï¼š/js/vue/lib.js
const { rc: { h, createVNode: c }, f, log } = require(process.env.BLOG_JS + '/vue/lib.js')
const _h = (...args) => f(c(...args))

class Component {
  $props

  static __vccOpts = { template: '<div />' }
}
log(_h(Component))
#+end_src

#+RESULTS:
: {
:   __v_isVNode: true,
:   __v_skip: true,
:   type: { template: '<div />' },
:   shapeFlag: 4 // STATEFUL_COMPONENT
: }
: undefined

** TODO stateful component & key NaN

æœ‰çŠ¶æ€çš„ç»„ä»¶ï¼Ÿ

å³ type ä¸ºå¯¹è±¡æ—¶å€™è§†ä¸ºæœ‰çŠ¶æ€çš„ç»„ä»¶ã€‚

å¦‚æœæ˜¯ STATEFUL_COMPONENT ä¸”æ˜¯ä¸ª proxy çš„æ—¶å€™ï¼Œå¼€å‘æ¨¡å¼ä¸‹ç»™å‡ºè­¦å‘Šâš ï¸ã€‚

#+begin_src js

// æºæ–‡ä»¶ï¼š/js/vue/lib.js
const { rc: { h, createVNode: c, reactive:r }, f, log } = require(process.env.BLOG_JS + '/vue/lib.js')
const _h = (...args) => f(c(...args))

log(_h('div', { key: NaN }))
#+end_src

#+RESULTS:
: {
:   __v_isVNode: true,
:   __v_skip: true,
:   type: 'div',
:   props: { key: NaN },
:   shapeFlag: 1
: }
: undefined

** 88eaf09 type is vnode

[[https://github.com/gcclll/stb-vue-next/commit/88eaf090c3d1767bc4a1ca576eef449abf7d62d2][feat(add): rc->createVNode, type is vnode Â· gcclll/stb-vue-next@88eaf09 Â· GitHub]]

#+begin_src typescript
  // > in createVNode
  // 1. type is vnode
  if (isVNode(type)) {
    // createVNode receiving an existing vnode. This happens in cases like
    // <component :is="vnode"/>
    // #2078 make sure to merge refs during the clone instead of overwriting it
    const cloned = cloneVNode(type, props, true /* mergeRef: true */);
    if (children) {
      normalizeChildren(cloned, children);
    }
    return cloned;
  }

  // cloneVNode
  // çœç•¥ç›´æ¥å– vnode å€¼éƒ¨åˆ†
  export function cloneVNode<T, U>(
    vnode: VNode<T, U>,
    extraProps?: (Data & VNodeProps) | null,
    mergeRef = false
  ): VNode<T, U> {
    // This is intentionally NOT using spread or extend to avoid the runtime
    // key enumeration cost.
    const { props, ref, patchFlag } = vnode;
    const mergedProps = extraProps ? mergeProps(props || {}, extraProps) : props;
    return {
      __v_isVNode: true,
      [ReactiveFlags.SKIP]: true,
      type: vnode.type,
      props: mergedProps,
      key: mergedProps && normalizeKey(mergedProps),
      ref:
        extraProps && extraProps.ref
          ? // #2078 in the case of <component :is="vnode" ref="extra"/>
            // if the vnode itself already has a ref, cloneVNode will need to merge
            // the refs so the single vnode can be set on multiple refs
            mergeRef && ref
            ? isArray(ref)
              ? ref.concat(normalizeRef(extraProps)!)
              : [ref, normalizeRef(extraProps)!]
            : normalizeRef(extraProps)
          : ref,
      // if the vnode is cloned with extra props, we can no longer assume its
      // existing patch flag to be reliable and need to add the FULL_PROPS flag.
      // note: perserve flag for fragments since they use the flag for children
      // fast paths only.
      patchFlag:
        extraProps && vnode.type !== Fragment
          ? patchFlag === -1 // hoisted node
            ? PatchFlags.FULL_PROPS
            : patchFlag | PatchFlags.FULL_PROPS
          : patchFlag,

      ssContent: vnode.ssContent && cloneVNode(vnode.ssContent),
      ssFallback: vnode.ssFallback && cloneVNode(vnode.ssFallback),
    };
  }
#+end_src

cloneVNode ç»å¤§éƒ¨åˆ†å±æ€§éƒ½æ˜¯ç›´æ¥å¼•ç”¨è‡ª vnodeï¼Œä¸Šé¢åˆ—å‡ºçš„éƒ½æ˜¯éœ€è¦å¤„ç†çš„å±æ€§ï¼Œæ¯”å¦‚ï¼š

1. props ä¼šå°† vnode å’Œ cloneVNode ä¼ å…¥çš„ props è¿›è¡Œåˆå¹¶ï¼Œå¹¶ä¸”æ˜¯ä¼ å…¥çš„ props è¦†ç›– vnode.propsã€‚
2. key å±æ€§ï¼Œå–åˆå¹¶ä¹‹åçš„ key([[#test-vnode-key][æµ‹è¯•->]])

   #+begin_src typescript
    // normalize åˆå¹¶åçš„ key
    const key = mergedProps && normalizeKey(mergedProps);

    const normalizeKey = ({ key }: VNodeProps): VNode["key"] =>
      key != null ? key : null;
   #+end_src
3. ref å±æ€§ï¼Œåˆå¹¶è§„åˆ™([[#test-vnode-ref][æµ‹è¯•->]])ï¼š

   #+begin_src typescript
    // 1. mergeRef: boolean å¯ä»¥æ‰‹åŠ¨æŒ‡å®šæ˜¯å¦éœ€è¦åˆå¹¶
    // 2. extraProps.ref è°ƒç”¨ cloneVNode æ—¶å€™ä¼ å…¥çš„ props ref
    // 3. ref å¦‚æœæ˜¯æ•°ç»„ï¼ŒåŠ ä¸Šæ–°çš„ ref æ‰©å±•åŸæ•°ç»„
    // 4. ref ä¸æ˜¯æ•°ç»„ï¼Œç”¨ ref å’Œ extra ref åˆå¹¶æˆæ–°æ•°ç»„
    // 5. å¦‚æœ ref null, åˆ™ç›´æ¥ç”¨ extra ref normalize å‡ºæ–°çš„ ref
    const ref =
      extraProps && extraProps.ref
        ? // #2078 in the case of <component :is="vnode" ref="extra"/>
          // if the vnode itself already has a ref, cloneVNode will need to merge
          // the refs so the single vnode can be set on multiple refs
          mergeRef && ref
          ? isArray(ref)
            ? ref.concat(normalizeRef(extraProps)!)
            : [ref, normalizeRef(extraProps)!]
          : normalizeRef(extraProps)
        : ref;

    // normalization
    const normalizeRef = ({ ref }: VNodeProps): VNodeNormalizedRefAtom | null => {
      return (ref != null
        ? isString(ref) || isRef(ref) || isFunction(ref)
          ? { i: currentRenderingInstance, r: ref }
          : ref
        : null) as any;
    };
   #+end_src
4. patchFlag å±æ€§([[#test-vnode-patchflag][æµ‹è¯•->]])

   #+begin_src typescript
    const patchFlag =
      extraProps && vnode.type !== Fragment
        ? patchFlag === -1 // hoisted node
          ? PatchFlags.FULL_PROPS
          : patchFlag | PatchFlags.FULL_PROPS
        : patchFlag;
   #+end_src
5. ssContent é€’å½’è°ƒç”¨ ~cloneVNode(vnode.ssContent)~
6. ssFallback é€’å½’è°ƒç”¨ ~cloneVNode(vnode.ssFallback)~


æµ‹è¯•ï¼š
#+begin_src js
// æºæ–‡ä»¶ï¼š/js/vue/lib.js
const {
  rc: { h, createVNode: c, cloneVNode: cv },
  f,
  log,
} = require(process.env.BLOG_JS + "/vue/lib.js");
const _h = (...args) => f(c(...args));

const node1 = _h("div", { foo: 1 }, null /* children */);
log([">>> vnode 1\n", node1]);

const node2 = _h({}, null, [node1]);
const cloned2 = cv(node2);
// cloneVNode åªæ˜¯ä¸€æ¬¡æµ…æ‹·è´
log([">>> node2 == cloned2\n", f(cloned2), "\n > node2 \n", node2]);
#+end_src

#+RESULTS:
#+begin_example
>>> vnode 1
 {
  __v_isVNode: true,
  __v_skip: true,
  type: 'div',
  props: { foo: 1 },
  shapeFlag: 1
}
>>> node2 == cloned2
 {
  __v_isVNode: true,
  __v_skip: true,
  type: {},
  children: [
    {
      __v_isVNode: true,
      __v_skip: true,
      type: 'div',
      props: [Object],
      shapeFlag: 1
    }
  ],
  shapeFlag: 20
}
 > node2
 {
  __v_isVNode: true,
  __v_skip: true,
  type: {},
  children: [
    {
      __v_isVNode: true,
      __v_skip: true,
      type: 'div',
      props: [Object],
      shapeFlag: 1
    }
  ],
  shapeFlag: 20
}
undefined
#+end_example

[[https://github.com/gcclll/stb-vue-next/commit/4fbd98f4be00f3fdfcb14839d29ed4a5f45a179c][feat(add): rc->createVNode, currentRenderingInstance Â· gcclll/stb-vue-next@4fbd98f Â· GitHub]]

*** key test
:PROPERTIES:
:COLUMNS: %CUSTOM_ID[(Custom Id)]
:CUSTOM_ID: test-vnode-key
:END:

vnode.key çš„ clone æ“ä½œï¼Œå±äºå•çº¯çš„å€¼è¦†ç›–æ“ä½œã€‚

#+begin_src js
// æºæ–‡ä»¶ï¼š/js/vue/lib.js
const {
  rc: { h, createVNode: c, cloneVNode: cv },
  f,
  log,
} = require(process.env.BLOG_JS + "/vue/lib.js");
const _h = (...args) => f(c(...args));

log([">>> ä¿ç•™ vnode.key å€¼\n", f(cv(c("div", { key: 1 })), "key")]);
log([
  ">>> æ›¿æ¢ vnode.key å€¼\n",
  f(cv(c("div", { key: 1 }), { key: 2 }), "key"),
]);
log([">>> æ–° props.key å€¼\n", f(cv(c("div"), { key: 2 }), "key")]);

log(">>> æµ‹è¯• vnode.key å„ç§æƒ…å†µå€¼");
for (const key of ["", "a", 0, 1, NaN]) {
  log(f(c("div", { key }), "key"));
}
#+end_src

#+RESULTS:
#+begin_example
>>> ä¿ç•™ vnode.key å€¼
 { key: 1 }
>>> æ›¿æ¢ vnode.key å€¼
 { key: 2 }
>>> æ–° props.key å€¼
 { key: 2 }
>>> æµ‹è¯• vnode.key å„ç§æƒ…å†µå€¼
{}
{ key: 'a' }
{}
{ key: 1 }
[Vue warn]: VNode created with invalid key (NaN). VNode type:div
{}
undefined
#+end_example

*** ref test
:PROPERTIES:
:COLUMNS: %CUSTOM_ID[(Custom Id)]
:CUSTOM_ID: test-vnode-ref
:END:

æµç¨‹è„‘å›¾ï¼š
[[/img/vue3/runtime-core/vue-runtime-core-vnode-ref.svg]]

æµ‹è¯•
#+begin_src js
// æºæ–‡ä»¶ï¼š/js/vue/lib.js
const {
  rc: {
    h,
    createVNode: c,
    cloneVNode: cv,
    ssrUtils: { setCurrentRenderingInstance: s },
  },
  f,
  log,
} = require(process.env.BLOG_JS + "/vue/lib.js");
const _h = (...args) => f(c(...args));

const mockIns1 = { ins: 1 },
  mockIns2 = { ins: 2 };
s(mockIns1);

let original = c("div", { ref: "foo" });
// æœ¬èº«æ²¡æœ‰çš„æ—¶å€™ä¼šå°† extraProps.ref ä½œä¸ºæ–°çš„ vnode.ref å€¼
log([">>> 1. vnode æœ¬èº«æ—  ref\n", f(original, "ref")]);
let cloned1 = cv(original);
log([">>> 2. ä¿ç•™åŸæœ‰çš„ vnode.ref\n", f(cloned1, "ref")]);
// è¿™é‡Œæ²¡æŒ‡å®š mergeProp æ‰€ä»¥ä¼šæ›¿æ¢åŸæ¥çš„
let cloned2 = cv(original, { ref: "bar" });
log(['>>> 3. ref: "bar" æ›¿æ¢åŸæœ‰çš„ vnode.ref\n', f(cloned2, "ref")]);
let original2 = c("div");
let cloned3 = cv(original2, { ref: "bar" });
log([">>> 4. æ²¡æœ‰ vnode.ref æƒ…å†µï¼Œæ–°å¢ ref\n", f(cloned3, "ref")]);

s(mockIns2);
// åº”è¯¥ä¿ç•™åŸæœ‰çš„ context instance
let cloned4 = cv(original);
log([">>> 5. åº”è¯¥ä¿ç•™åŸæœ‰çš„ context instance\n", f(cloned4, "ref")]);
// ref è¦†ç›–ï¼Œä½¿ç”¨æ–°çš„ context instance: mockIns2
let cloned5 = cv(original, { ref: "bar" });
log([">>> 6. ref æ”¹å˜ï¼Œä½¿ç”¨æ–°çš„ context instance\n", f(cloned5, "ref")]);
s(null); // ç½®ç©º context instance

log('\n\n// mergeRef æƒ…å†µæµ‹è¯•\n')
s(mockIns1)
original = c('div', { ref: 'foo' })
s(mockIns2)
cloned1 = cv(original, { ref: 'bar' }, true)
log(['>>> mergeRef: true åˆå¹¶ vnode.ref\n', f(cloned1, 'ref')])
log(cloned1.ref[0])
log(cloned1.ref[1])
#+end_src

#+RESULTS:
#+begin_example
>>> 1. vnode æœ¬èº«æ—  ref
 { ref: { i: { ins: 1 }, r: 'foo' } }
>>> 2. ä¿ç•™åŸæœ‰çš„ vnode.ref
 { ref: { i: { ins: 1 }, r: 'foo' } }
>>> 3. ref: "bar" æ›¿æ¢åŸæœ‰çš„ vnode.ref
 { ref: { i: { ins: 1 }, r: 'bar' } }
>>> 4. æ²¡æœ‰ vnode.ref æƒ…å†µï¼Œæ–°å¢ ref
 { ref: { i: { ins: 1 }, r: 'bar' } }
>>> 5. åº”è¯¥ä¿ç•™åŸæœ‰çš„ context instance
 { ref: { i: { ins: 1 }, r: 'foo' } }
>>> 6. ref æ”¹å˜ï¼Œä½¿ç”¨æ–°çš„ context instance
 { ref: { i: { ins: 2 }, r: 'bar' } }


// mergeRef æƒ…å†µæµ‹è¯•

>>> mergeRef: true åˆå¹¶ vnode.ref
 { ref: [ { i: [Object], r: 'foo' }, { i: [Object], r: 'bar' } ] }
{ i: { ins: 1 }, r: 'foo' }
{ i: { ins: 2 }, r: 'bar' }
undefined
#+end_example
*** TODO patchFlag test
:PROPERTIES:
:COLUMNS: %CUSTOM_ID[(Custom Id)]
:CUSTOM_ID: test-vnode-patchflag
:END:

TODO need openBlock&createBlock support.

#+begin_src js
// æºæ–‡ä»¶ï¼š/js/vue/lib.js
const {
  rc: {
    h,
    createVNode: c,
    cloneVNode: cv,
    ssrUtils: { setCurrentRenderingInstance: s },
  },
  f,
  log,
} = require(process.env.BLOG_JS + "/vue/lib.js");
const _h = (...args) => f(c(...args));

const hoist = c('div') // é™æ€èŠ‚ç‚¹
let vnode1
const vnode = (openBlock(), createBlock('div'))
#+end_src
*** shapeFlag test

#+begin_src js
// æºæ–‡ä»¶ï¼š/js/vue/lib.js
const {
  rc: { h, createVNode: c, cloneVNode: cv, Text },
  f,
  log,
} = require(process.env.BLOG_JS + "/vue/lib.js");
const _h = (...args) => f(c(...args));

log([">>> ELEMENT\n", f(c("div"), "shapeFlag")]);
log([">>> STATEFUL_COMONENT\n", f(c({}), "shapeFlag")]);
log([
  ">>> FUNCTION_COMONENT\n",
  f(
    c(() => {}),
    "shapeFlag"
  ),
]);
log([">>> Text\n", f(c(Text), "shapeFlag")]);
#+end_src

#+RESULTS:
: >>> ELEMENT
:  { shapeFlag: 1 }
: >>> STATEFUL_COMONENT
:  { shapeFlag: 4 }
: >>> FUNCTION_COMONENT
:  { shapeFlag: 2 }
: >>> Text
:  { shapeFlag: 0 }
: undefined
*** mergeProps test

#+begin_src js
// æºæ–‡ä»¶ï¼š/js/vue/lib.js
const {
  rc: { h, createVNode: c, cloneVNode: cv, Text, mergeProps },
  f,
  log,
} = require(process.env.BLOG_JS + "/vue/lib.js");

let p1 = { class: "c" };
let p2 = { class: ["cc"] };
let p3 = { class: [{ ccc: true }] };
let p4 = { class: { cccc: true } };
log([">>> merge class\n", mergeProps(p1, p2, p3, p4)]);
let ps1 = {
  style: { color: "red", fontSize: 10 },
};
let ps2 = {
  style: [
    { color: "blue", width: "200px" },
    {
      width: "300px",
      height: "300px",
      fontSize: 30,
    },
  ],
};
let ps3 = { style: 'width:100px;right:10;top:10' }
log([">>> merge style\n", mergeProps(ps1, ps2, ps3)]);
let clickHandler1  = function(){}
let clickHandler2  = function(){}
let focusHandler3  = function(){}
let ph1 = { onClick: clickHandler1 }
let ph2 = { onClick: clickHandler2, onFocus: focusHandler3 }
log(['>>> merge handlers\n', mergeProps(ph1, ph2)])
#+end_src

#+RESULTS:
#+begin_example
>>> merge class
 { class: 'c cc ccc cccc' }
>>> merge style
 {
  style: {
    color: 'blue',
    fontSize: 30,
    width: '100px',
    height: '300px',
    right: '10',
    top: '10'
  }
}
>>> merge handlers
 {
  onClick: [ [Function: clickHandler1], [Function: clickHandler2] ],
  onFocus: [Function: focusHandler3]
}
undefined
#+end_example
*** TODO dynamic children test

> need openBlock&createBlock support

#+begin_src js
const {
  rc: { h, createVNode: c, cloneVNode: cv, Text, mergeProps },
  f,
  log,
} = require(process.env.BLOG_JS + "/vue/lib.js");

const hoist = createVNode('div')
let vnode1
#+end_src
*** TODO transformVNodeArgs test
** TODO 7ec1d30 suspense component

[[https://github.com/gcclll/stb-vue-next/commit/7ec1d3053a5881d476e535923edce07f36fe77f0][feat(add): rc->createVNode, type is suspense component Â· gcclll/stb-vue-next@7ec1d30 Â· GitHub]]

Suspense çš„ children å¿…é¡»æœ‰ä¸”åªæœ‰ä¸€ä¸ªæ ¹èŠ‚ç‚¹ã€‚

#+begin_src typescript
  // 7. normalize suspense children
  if (__FEATURE_SUSPENSE__ && shapeFlag & ShapeFlags.SUSPENSE) {
    const { content, fallback } = normalizeSuspenseChildren(vnode);
    vnode.ssContent = content;
    vnode.ssFallback = fallback;
  }

  // normalizeSuspenseChildren
  export function normalizeSuspenseChildren(
    vnode: VNode
  ): {
    content: VNode;
    fallback: VNode;
  } {
    const { shapeFlag, children } = vnode;
    let content: VNode, fallback: VNode;

    if (shapeFlag & ShapeFlags.SLOTS_CHILDREN) {
      content = normalizeSuspenseSlot((children as Slots).default);
      fallback = normalizeSuspenseSlot((children as Slots).fallback);
    } else {
      content = normalizeSuspenseSlot(children as VNodeChild);
      fallback = normalizeVNode(null);
    }

    return {
      content,
      fallback,
    };
  }

// >>> normalizeSuspenseSlot
function normalizeSuspenseSlot(s: any) {
  if (isFunction(s)) {
    s = s()
  }
  if (isArray(s)) {
    // ROOT å¿…é¡»æ˜¯å•èŠ‚ç‚¹ <div>...</div>
    const singleChild = filterSingleRoot(s)
    if (__DEV__ && !singleChild) {
      warn(`<Suspense> slots expect a single root node.`)
    }
    s = singleChild
  }
  return normalizeVNode(s)
}

// normalizeVNode
export function normalizeVNode(child: VNodeChild): VNode {
  if (child == null || typeof child === 'boolean') {
    // empty placeholder
    return createVNode(Comment)
  } else if (isArray(child)) {
    // fragment
    return createVNode(Fragment, null, child)
  } else if (typeof child === 'object') {
    // already vnode, this should be the most common since compiled templates
    // always produce all-vnode children arrays
    // è¿™æ˜¯æœ€å¸¸ç”¨çš„æƒ…å†µï¼Œå› ä¸ºä½¿ç”¨æ¨¡æ¿çš„æ—¶å€™æœ€åç”Ÿæˆçš„ children æ˜¯æ•°ç»„
    return child.el === null ? child : cloneVNode(child)
  } else {
    // strings and numbers
    return createVNode(Text, null, String(child))
  }
}
#+end_src

æ£€æµ‹æ˜¯ä¸æ˜¯ single root å‡½æ•°ï¼š ~filterSingleRoot~
#+begin_src typescript
export function filterSingleRoot(
  children: VNodeArrayChildren
): VNode | undefined {
  let singleRoot;
  for (let i = 0; i < children.length; i++) {
    const child = children[i];
    if (isVNode(child)) {
      // ignore user comment
      if (child.type !== Comment || child.children === "v-if") {
        if (singleRoot) {
          // has more than 1 non-comment child, return now

          return;
        } else {
          singleRoot = child;
        }
      }
    } else {
      return;
    }
  }
  return singleRoot;
}
#+end_src
** TODO 23fc943 currentBlock ä¼˜åŒ–
:PROPERTIES:
:COLUMNS: %CUSTOM_ID[(Custom Id)]
:CUSTOM_ID: vnode-currentBlock
:END:

[[https://github.com/gcclll/stb-vue-next/commit/23fc9437e9fba7bb562f79a51410ef59e6b82f8c][feat(add): rc->createVNode, optimize diff, currentBlock Â·
gcclll/stb-vue-next@23fc943 Â· GitHub]]

#+begin_quote
è¿™é‡Œçš„å¤„ç†æ²¡æ€ä¹ˆææ˜ç™½â“
#+end_quote

æ³¨æ„è¿™é‡Œå¢åŠ çš„å‡ ä¸ªå˜é‡â€¼

blockStack, currentBlock:
#+begin_src typescript

// Since v-if and v-for are the two possible ways node structure can dynamically
// change, once we consider v-if branches and each v-for fragment a block, we
// can divide a template into nested blocks, and within each block the node
// structure would be stable. This allows us to skip most children diffing
// and only worry about the dynamic nodes (indicated by patch flags).
// é’ˆå¯¹ v-if, v-for åŠ¨æ€æ€§åšçš„ç”±äºï¼Œå‡å°‘å¯¹é™æ€èŠ‚ç‚¹çš„ diff ï¼Œåªéœ€è¦å…³å¿ƒåŠ¨æ€èŠ‚ç‚¹å³å¯
export const blockStack: (VNode[] | null)[] = []
let currentBlock: VNode[] | null = null
#+end_src

shouldTrack:
#+begin_src typescript
// Whether we should be tracking dynamic child nodes inside a block.
// Only tracks when this value is > 0
// We are not using a simple boolean because this value may need to be
// incremented/decremented by nested usage of v-once (see below)
// æ˜¯å¦åº”è¯¥ tracking block å†…åŠ¨æ€çš„å­©å­èŠ‚ç‚¹
let shouldTrack = 1;
#+end_src

æ–°å¢å¤„ç†é€»è¾‘ï¼š
#+begin_src typescript
 // 8. currentBlock
 if (
   shouldTrack > 0 &&
   // é¿å… block èŠ‚ç‚¹ tracking è‡ªå·±
   !isBlockNode &&
   // has current parent block
   currentBlock &&
   // presence of a patch flag indicates this node needs patching on updates.
   // component nodes also should always be patched, because even if the
   // component doesn't need to update, it needs to persist the instance on to
   // the next vnode so that it can be properly unmounted later.
   (patchFlag > 0 || shapeFlag & ShapeFlags.COMPONENT) &&
   // the EVENTS flag is only for hydration and if it is the only flag, the
   // vnode should not be considered dynamic due to handler caching.
   patchFlag !== PatchFlags.HYDRATE_EVENTS
 ) {
   currentBlock.push(vnode);
 }
#+end_src

è·Ÿè¿™å‡ ä¸ªå˜é‡æœ‰å…³çš„å‡½æ•°ï¼š
* TODO block related(open/close/create)
:PROPERTIES:
:COLUMNS: %CUSTOM_ID[(Custom Id)]
:CUSTOM_ID: block-related
:END:

[[https://github.com/gcclll/stb-vue-next/commit/a2afc70cc89fc0bb7c1b1f6810bea73ab4e40c82][feat(add): rc->block related, open/create/closeBlock Â· gcclll/stb-vue-next@a2afc70 Â· GitHub]]

è¿™é‡Œçš„æ‰€æœ‰å‡½æ•°éƒ½å’Œ [[#vnode-currentBlock][createVNode é‡Œé¢çš„ currentBlock]] æœ‰å…³ã€‚

openBlock:
#+begin_src typescript
/**
 ,* Open a block.
 ,* This must be called before `createBlock`. It cannot be part of `createBlock`
 ,* because the children of the block are evaluated before `createBlock` itself
 ,* is called. The generated code typically looks like this:
 ,*
 ,* ```js
 ,* function render() {
 ,*   return (openBlock(),createBlock('div', null, [...]))
 ,* }
 ,* ```
 ,* disableTracking is true when creating a v-for fragment block, since a v-for
 ,* fragment always diffs its children.
 ,*
 ,* @private
 ,*/
export function openBlock(disableTracking = false) {
  blockStack.push((currentBlock = disableTracking ? null : []));
}
#+end_src

closeBlock:
#+begin_src typescript
export function closeBlock() {
  blockStack.pop();
  currentBlock = blockStack[blockStack.length - 1] || null;
}
#+end_src

setBlockTracking:
#+begin_src typescript
/**
 * Block tracking sometimes needs to be disabled, for example during the
 * creation of a tree that needs to be cached by v-once. The compiler generates
 * code like this:
 *
 * ``` js
 * _cache[1] || (
 *   setBlockTracking(-1),
 *   _cache[1] = createVNode(...),
 *   setBlockTracking(1),
 *   _cache[1]
 * )
 * ```
 *
 * @private
 */
export function setBlockTracking(value: number) {
  shouldTrack += value
}
#+end_src

createBlock:
#+begin_src typescript
/**
 * Create a block root vnode. Takes the same exact arguments as `createVNode`.
 * A block root keeps track of dynamic nodes within the block in the
 * `dynamicChildren` array.
 *
 * @private
 */
export function createBlock(
  type: VNodeTypes | ClassComponent,
  props?: Record<string, any> | null,
  children?: any,
  patchFlag?: number,
  dynamicProps?: string[]
): VNode {
  const vnode = createVNode(
    type,
    props,
    children,
    patchFlag,
    dynamicProps,
    true /* isBlock: prevent a block from tracking itself */
  );
  // save current block children on the block vnode
  vnode.dynamicChildren = currentBlock || (EMPTY_ARR as any);
  // close block
  closeBlock();
  // a block is always going to be patched, so track it as a child of its
  // parent block
  if (shouldTrack > 0 && currentBlock) {
    currentBlock.push(vnode);
  }
  return vnode;
}
#+end_src

ç›¸å…³è„‘å›¾ï¼š
[[/img/vue3/runtime-core/vue-runtime-core-block-shouldtrack.svg]]

* normalizeChildren function

shapeFlag åˆå§‹å€¼æ£€æµ‹ï¼š
#+begin_src typescript
// encode the vnode type information into a bitmap
const shapeFlag = isString(type)
  ? ShapeFlags.ELEMENT // 1
  : __FEATURE_SUSPENSE__ && isSuspense(type)
  ? ShapeFlags.SUSPENSE // 1 << 7, 128
  : isTeleport(type)
  ? ShapeFlags.TELEPORT // 1 << 6, 64
  : isObject(type)
  ? ShapeFlags.STATEFUL_COMPONENT // 1 << 2, 4
  : isFunction(type)
  ? ShapeFlags.FUNCTIONAL_COMPONENT // 1 << 1, 2
  : 0;
#+end_src

æµ‹è¯•:
#+begin_src js
// æºæ–‡ä»¶ï¼š/js/vue/lib.js
const { rc: { h, createVNode: c }, f, log } = require(process.env.BLOG_JS + '/vue/lib.js')
const _h = (...args) => f(c(...args))

log(['>>> only tag\n', _h('p')])
log(['>>> tag + props\n', _h('p', { foo: 'foo' })])
log(['>>> tag + props + children\n', _h('p', { foo: 'foo' }, ['foo'])])
#+end_src

#+RESULTS:
#+begin_example
>>> only tag
 { __v_isVNode: true, __v_skip: true, type: 'p', shapeFlag: 1 }
>>> tag + props
 {
  __v_isVNode: true,
  __v_skip: true,
  type: 'p',
  props: { foo: 'foo' },
  shapeFlag: 1
}
>>> tag + props + children
 {
  __v_isVNode: true,
  __v_skip: true,
  type: 'p',
  props: { foo: 'foo' },
  children: [ 'foo' ],
  shapeFlag: 17
}
undefined
#+end_example

** children is function

[[https://github.com/gcclll/stb-vue-next/commit/28d4a55250c6f02264bbb77ca04a87770d358c7c][feat(add): rc->propsOrChildren is function Â· gcclll/stb-vue-next@28d4a55 Â· GitHub]]

å¦‚æœæ˜¯å‡½æ•°ï¼Œå½“åš slot çš„ children å¤„ç†ã€‚

normalizeChildren:
#+begin_src typescript
export function normalizeChildren(vnode: VNode, children: unknown) {
  let type = 0
  if (children == null) {
    children = null
  } else if (false /*array*/) {
    // TODO
  } else if (false /*object*/) {
    // TODO
  } else if (isFunction(children)) {
    // å¦‚æœæ˜¯å‡½æ•°å½“åš slot children ?
    children = { default: children, _ctx: currentRenderingInstance }
    type = ShapeFlags.SLOTS_CHILDREN
  } else {
    // TODO æ™®é€šç±»å‹
  }

  vnode.children = children as VNodeNormalizedChildren
  vnode.shapeFlag |= type
}
#+end_src

æµ‹è¯•ï¼š
#+begin_src js

// æºæ–‡ä»¶ï¼š/js/vue/lib.js
const { rc: { h, createVNode:c }, log, f } = require(process.env.BLOG_JS + '/vue/lib.js')
const _h = (...args) => f(h(...args));
const _c = (...args) => f(c(...args));

const Component = { template: '<br />' }
const slot = () => {}
log(['>>> default slot\n', _h(Component, slot)])
log(['>>> children is function\n', _c('div', {}, slot)])
#+end_src

#+RESULTS:
#+begin_example
>>> default slot
 {
  __v_isVNode: true,
  __v_skip: true,
  type: { template: '<br />' },
  children: { default: [Function: slot], _ctx: null },
  shapeFlag: 36
}
>>> children is function
 {
  __v_isVNode: true,
  __v_skip: true,
  type: 'div',
  props: {},
  children: { default: [Function: slot], _ctx: null },
  shapeFlag: 33
}
undefined
#+end_example
** children is array or æ™®é€šç±»å‹

[[https://github.com/gcclll/stb-vue-next/commit/850c0bc0d8b74e1b88d2158df505c83cb9a71408][feat(add): rc->createVNode, children is array or primitive Â·
gcclll/stb-vue-next@850c0bc Â· GitHub]]

#+begin_src typescript
// æ•°ç»„ç±»å‹
if (isArray(children)) {
  type = ShapeFlags.ARRAY_CHILDREN;
}

// éå¯¹è±¡ï¼Œæ•°ç»„ï¼Œå‡½æ•°çš„æ™®é€šç±»å‹å¤„ç†
{
  children = String(children);
  // force teleport children to array so it can be moved around
  if (shapeFlag & ShapeFlags.TELEPORT) {
    type = ShapeFlags.ARRAY_CHILDREN;
    children = [createTextVNode(children as string)];
  } else {
    type = ShapeFlags.TEXT_CHILDREN;
  }
}

// createTextVNode
export function createTextVNode(text: string = " ", flag: number = 0): VNode {
  return createVNode(Text, null, text, flag);
}

export const Text = Symbol(__DEV__ ? 'Text' : undefined)
#+end_src

æ™®é€šç±»å‹å¤„ç†ä¸­å¦‚æœæ˜¯ ~ShapeFlags.TELETPORT~ å½“åš ~ARRAY_CHILDREN~ å¤„ç†ï¼Œä¸”
children æŒ‰ç…§æ–‡æœ¬èŠ‚ç‚¹å¤„ç†ã€‚

#+begin_src js
const {
  rc: { h, createVNode: c },
  f,
  log,
} = require(process.env.BLOG_JS + "/vue/lib.js");
const _h = (...args) => f(h(...args));
const _c = (...args) => f(c(...args));

log([`>>> array will be children(${1 | (1 << 4)})\n`, _h("div", ["foo"])]);
log([">>> string will be children()\n", _h("div", "foo")]);
#+end_src

#+RESULTS:
#+begin_example
>>> array will be children(17)
 {
  __v_isVNode: true,
  __v_skip: true,
  type: 'div',
  children: [ 'foo' ],
  shapeFlag: 17
}
>>> string will be children()
 {
  __v_isVNode: true,
  __v_skip: true,
  type: 'div',
  children: 'foo',
  shapeFlag: 9
}
undefined
#+end_example
** children is object

[[https://github.com/gcclll/stb-vue-next/commit/959879e825fb225b39c7fb219ec7e46feb6c7537][feat(add): rc->createVNode, normalizeChildren is object Â· gcclll/stb-vue-next@959879e Â· GitHub]]

shapeFlag å¯èƒ½æ˜¯ ~ShapeFlags.ELEMENT~ æˆ–è€… ~ShapeFalgs.TELEPORT~ ã€‚

è¿™é‡Œå…ˆæµ‹è¯• ELEMENT æƒ…å†µï¼Œå› ä¸º TELEPORT è¿˜éœ€è¦å®ç° components/Teleport ã€‚

å¦‚æœ type æ˜¯ å¯¹è±¡ï¼Œ shapeFlag åˆå§‹ç±»å‹ä¼šæ˜¯ ~ShapeFlags.STATEFULL_COMPONENT, 1 <<
2~

#+begin_src js
// æºæ–‡ä»¶ï¼š/js/vue/lib.js
const {
  rc: { h, createVNode: c },
  f,
  log,
} = require(process.env.BLOG_JS + "/vue/lib.js");
const _h = (...args) => f(c(...args));

// å› ä¸º type = {} , shapeFlag = 1 << 2, 4
// æ‰€ä»¥åœ¨ normalizeChildren é‡Œé¢ isObject åˆ†æ”¯ä¼šè¿›å…¥ else
// è¿›è¡Œå¤„ç†ï¼Œç»è¿‡å¤„ç†ä¹‹åæˆä¸º 4 | SLOTS_CHILDREN,2<<5,32 = 36
log([">>> object\n", _h({}, null, { foo: "foo" })]);
#+end_src

#+RESULTS:
: >>> object
:  {
:   __v_isVNode: true,
:   __v_skip: true,
:   type: {},
:   children: { foo: 'foo', _ctx: null },
:   shapeFlag: 36
: }
: undefined
* api watch(source, cb, options)
:PROPERTIES:
:COLUMNS: %CUSTOM_ID[(Custom Id)]
:CUSTOM_ID: api-watch
:END:

[[https://github.com/gcclll/stb-vue-next/commit/4f0301ea5d7839e8ce5274ea170dd09bd129f5ee][feat(add): api watch TODOs Â· gcclll/stb-vue-next@4f0301e Â· GitHub]]

è„‘å›¾ï¼š
[[/img/vue3/runtime-core/vue-runtime-core-api-watch.svg]]

#+begin_quote
ä¸ºäº†æ›´å¥½çš„å®Œæˆ apiWatchï¼Œ éœ€è¦å…ˆå®Œæˆäº† [[#scheduler][scheduler]] ä»»åŠ¡è°ƒåº¦éƒ¨åˆ†ã€‚
#+end_quote

~watch(source, cb, options)~ å‡½æ•°ä»¥ä¸‹ç§ä½¿ç”¨æ–¹å¼(ä¸‹é¢çš„ cb å‡å¯é€‰å‚æ•°)ï¼š

1. ~watch(fn)~ ç­‰ä»·äº ~watchEffect(fn)~, æ—  cb
2. ~watch(fn, cb)~ ç›‘å¬å‡½æ•°
3. ~watch(ref(0), cb)~
4. ~watch(reactive({ count: 0}), cb)~ , reactive å¯¹è±¡é»˜è®¤ ~deep = true~
5. ~watch([ref(0), reactive({count: 0})], cb)~
6. ~watch(fn, cb, { immediate: true })~ æ­¤æ—¶ï¼Œ cb å¿…é¡»ä¸ºå‡½æ•°ï¼Œ job->fn è¢«ç«‹å³æ‰§
   è¡Œä¸€æ¬¡ï¼Œ cb æ¥å—æ–°æ—§å€¼
7. ~watch(ref({ count: 0}), cb, { deep: true })~ æ‰‹åŠ¨æŒ‡å®š ~deep: true~ æ·±åº¦ç›‘å¬
8. ...

æ‰§è¡Œå…·ä½“å®ç°çš„å‡½æ•°ï¼š ~doWatch()~

| Arg      | value                                           | description    |
|----------+-------------------------------------------------+----------------|
| source   | WatchSource, WatchSource[], WatchEffect, object | object watched |
| cb       | WatchCallback or null                           | callback       |
|----------+-------------------------------------------------+----------------|
| options  | WatchOptions = EMPTY_OBJ                        |                |
|          | immediate                                       |                |
|          | deep                                            |                |
|          | flush                                           |                |
|          | onTrack                                         |                |
|          | onTrigger                                       |                |
|----------+-------------------------------------------------+----------------|
| instance | currentInstance                                 | -              |
|          |                                                 |                |

#+begin_quote
~watch(source, cb, options?)~ å‡½æ•°ä¸­çš„ cb æ˜¯å¿…é€‰é¡¹ï¼Œå¦‚æœæƒ³ç›´æ¥ watch effectï¼Œå¯ä½¿
ç”¨ ~watchEffect(fn, options?)~ api ã€‚
#+end_quote

watch å‡½æ•°åŸºæœ¬æµç¨‹ï¼š

1. cb, immediate, deep æ£€æµ‹
2. getterï¼Œ æ ¹æ® source ä¸åŒç±»å‹è®¾ç½® getter
3. cb + deep: true
4. SSR node env
5. å°† cb å°è£…æˆ job
6. ~runner = effect(getter, option)~
7. runner å¦‚ä½•æ‰§è¡Œï¼Ÿ
8. stop, removeï¼Œå‡½æ•°è¿”å›ä¸€ä¸ª stop+remove è¯¥ runner æ“ä½œçš„å‡½æ•°


ä¸‹é¢ç« èŠ‚ä¸­æµ‹è¯•çš„ç”¨ä¾‹åˆ†æè„‘å›¾ï¼š
[[/img/vue3/runtime-core/vue-runtime-core-api-watch-tests.svg]]
** source is ref

[[https://github.com/gcclll/stb-vue-next/commit/b9b7ac6aa908cc375d698fd5762e0ff9a52dbcc5][feat(add): apiWatch->no cb, getter is ref Â· gcclll/stb-vue-next@b9b7ac6 Â· GitHub]]

[[https://github.com/gcclll/stb-vue-next/commit/67523262e127d72237f50e3c437210cc5c2e3d76][fix: watch->source is ref, cb -> job Â· gcclll/stb-vue-next@6752326 Â· GitHub]]
æµ‹è¯•:
#+begin_src js
// æºæ–‡ä»¶ï¼š/js/vue/lib.js
const {
  rc: { ref, nextTick, watch },
  log,
} = require(process.env.BLOG_JS + "/vue/lib.js");
const run = async () => {
  const count = ref(0);
  let dummy,
    i = 0;
  watch(count, (count, prevCount) => {
    log("\nvalue changed: " + i++);
    dummy = [count, prevCount];
    count + 1;
    if (prevCount) {
      prevCount + 1;
    }
  });
  count.value++;
  await nextTick();
  log(dummy);
};
run();
#+end_src

#+RESULTS:
: undefined
: value changed: 0
: 1 0

æœ‰å…³ä»£ç (doWatch):
#+begin_src typescript
// -> getter
let getter: () => any;
let forceTrigger = false;
// 2.1 source is ref
if (isRef(source)) {
  getter = () => (source as Ref).value;
  forceTrigger = !!(source as Ref)._shallow;
}

// cb -> job å°è£…
let oldValue = isArray(source) ? [] : INITIAL_WATCHER_VALUE;
const job: SchedulerJob = () => {
  if (cb) {
    // watch(source, cb)
    const newValue = runner();
    if (deep || forceTrigger || hasChanged(newValue, oldValue)) {
      // cleanup
      if (cleanup) cleanup();
      callWithAsyncErrorHandling(cb, instance, ErrorCodes.WATCH_CALLBACK, [
        newValue,
        // pass undefined as the old value when it's changed for the first time
        // ç¬¬ä¸€æ¬¡çš„æ—¶å€™ oldValue ä¸º undefined
        oldValue === INITIAL_WATCHER_VALUE ? undefined : oldValue,
        onInvalidate,
      ]);
      oldValue = newValue;
    }
  } else {
    // TODO
  }
};

// scheduler å°è£…
scheduler = () => {
  if (!instance || instance.isMounted) {
    queuePreFlushCb(job);
  } else {
  }
};

// ä»€ä¹ˆæ–¹å¼æ‰§è¡Œ runner?
// 8. TODO runner å¦‚ä½•æ‰§è¡Œï¼Ÿ
if (cb) {
  if (immediate) {
    // TODO
  } else {
    oldValue = runner();
  }
} else if (false /*flush->post*/) {
} else {
  runner();
}
#+end_src
** source is reactive

å¦‚æœè¦ watch çš„å¯¹è±¡æ˜¯ä¸ª reactive ï¼Œéœ€è¦è¿›è¡Œé€’å½’ watch ï¼Œå¾—åˆ° getter.

[[https://github.com/gcclll/stb-vue-next/commit/697f7f25d2bdafdda09a76ee8b00c949e61d6acb][fix: watch->source is reactive Â· gcclll/stb-vue-next@697f7f2 Â· GitHub]]

æ–°å¢ç›¸å…³ä»£ç ï¼š

#+begin_src typescript
// 1. å¦‚æœæ˜¯ reactiveï¼Œéœ€è¦æ·±åº¦ç›‘å¬
if (isReactive(source)) {
  getter = () => source;
  deep = true;
}

// 2. deep: true
if (cb && deep) {
  const baseGetter = getter;
  // a. deep: true
  // b. source is reactive
  getter = () => traverse(baseGetter());
}

// traverse å‡½æ•°
function traverse(value: unknown, seen: Set<unknown> = new Set()) {
  if (!isObject(value) || seen.has(value)) {
    return value;
  }
  seen.add(value);
  if (isRef(value)) {
    traverse(value.value, seen);
  } else if (isArray(value)) {
    for (let i = 0; i < value.length; i++) {
      traverse(value[i], seen);
    }
  } else if (isSet(value) || isMap(value)) {
    value.forEach((v: any) => {
      traverse(v, seen);
    });
  } else {
    for (const key in value) {
      traverse(value[key], seen);
    }
  }
  return value;
}
#+end_src

é€’å½’ç›‘å¬ reactive å¯¹è±¡ä»»æ„å±‚çº§ä¸Šçš„å±æ€§å˜åŒ–ã€‚

#+begin_src js
// æºæ–‡ä»¶ï¼š/js/vue/lib.js
const {
  rc: { nextTick, watchEffect, reactive, watch },
  log,
} = require(process.env.BLOG_JS + "/vue/lib.js");

const run = async () => {
  const state = reactive({ count: 0, r1: { count: 10 } });
  let dummy;
  watch(state, (newVal, preVal) => {
    dummy = [newVal, preVal];
  });
  state.count++;
  await nextTick();
  log.br(dummy);
  state.r1.count--
  await nextTick()
  log.br(dummy)
};
run();
#+end_src

#+RESULTS:
: undefined
:
: { count: 1, r1: { count: 10 } } { count: 1, r1: { count: 10 } }
:
:
: { count: 1, r1: { count: 9 } } { count: 1, r1: { count: 9 } }

#+begin_quote
*æ³¨æ„*: newVal å’Œ preVal è¿”å›çš„æ˜¯æ•´ä¸ª state è€Œéå½“å‰æ‰€å‘ç”Ÿå˜æ›´çš„å±æ€§
(count/r1.count)ï¼Œå› ä¸ºåœ¨ job é‡Œé¢æ‰§è¡Œ  runner() å¾—åˆ°æ–°å€¼æ˜¯åœ¨
traverse(baseGetter()) ä¹‹å‰å‘ç”Ÿçš„ï¼Œæ­¤æ—¶å–åˆ°çš„å€¼æ˜¯ state è‡ªèº«ã€‚
#+end_quote

[[/img/tmp/20210115141244.png]]
** soure is array
:PROPERTIES:
:COLUMNS: %CUSTOM_ID[(Custom Id)]
:CUSTOM_ID: watch-array
:END:

[[https://github.com/gcclll/stb-vue-next/commit/af1e590b3bb528f8fb9db4a06ead3978426130c1][feat(add): apiWatch->source is array Â· gcclll/stb-vue-next@af1e590 Â· GitHub]]

å¦‚æœè¦ç›‘å¬çš„å¯¹è±¡æ˜¯ä¸ªæ•°ç»„çš„æ—¶å€™ï¼Œéœ€è¦æ£€æµ‹æ•°ç»„å…ƒç´ çš„ç±»å‹ï¼Œé’ˆå¯¹ä¸åŒç±»å‹è¿›è¡Œå¤„ç†ã€‚

è¦ç‚¹ï¼š
1. æ•°ç»„å…ƒç´ ä¸èƒ½æ˜¯é™¤ ref/reactive/function ä¹‹å¤–çš„ç±»å‹
2. å¯¹æ•°ç»„å…ƒç´ è®¾å€¼æ—¶å¿…é¡»é€šè¿‡å…ƒç´ åŸå§‹è®¾å€¼æ–¹å¼è¿›è¡Œ(æ¯”å¦‚ï¼š ref è¦ ~ref.value = xxx~)ï¼Œ
   å› ä¸ºè¯¥æ•°ç»„æœ¬èº«ä¸æ˜¯ reactive çš„

#+begin_src typescript
if (isArray(source)) {
  getter = () =>
    source.map((s) => {
      if (isRef(s)) {
        return s.value;
      } else if (isReactive(s)) {
        return traverse(s);
      } else if (isFunction(s)) {
        return callWithErrorHandling(s, instance, ErrorCodes.WATCH_GETTER);
      } else {
        // TODO warn invalid source
      }
    });
}
#+end_src

1. isRef -> ç›‘å¬ item.value
2. isReactive -> traverse(item) é€’å½’
3. isFunction -> callWithErrorHandling(item, instance, ...) ç›‘å¬å‡½æ•°è¿”å›å€¼
4. å…¶ä»–ç±»å‹ä¸æ”¯æŒ -> warn invalid source

æµ‹è¯•ï¼š
#+begin_src js
// æºæ–‡ä»¶ï¼š/js/vue/lib.js
const {
  rc: { ref, watch, nextTick, reactive },
  log,
} = require(process.env.BLOG_JS + "/vue/lib.js");

const run = async () => {
  const array = reactive([]);
  let dummy;
  watch(array, (newArr, preArr) => {
    dummy = [newArr, "\n"];
  });
  array.push(1);
  await nextTick();
  log.br(dummy);
};
run();
#+end_src

#+RESULTS:
: undefined
:
: [ 1 ]
:

æ•°ç»„æ··åˆæ¨¡å¼(å…ƒç´ åªæ”¯æŒ ref, reactive, function)ï¼š
#+begin_src js
const {
  rc: { ref, watch, nextTick, reactive, effect },
  log,
} = require(process.env.BLOG_JS + "/vue/lib.js");

let dummy,
  val = reactive([10, 1]);
effect(() => {
  dummy = val[0];
});
val[0]++;
log(`dummy = ${dummy}\n`);

console.warn("---");
const run = async () => {
  const state = reactive({ count: 1 });
  const status = ref(false);
  let dummy;
  watch([() => state.count, status], (vals, oldVals) => {
    dummy = [vals, oldVals];
  });
  state.count++;
  status.value = true;
  await nextTick();
  log.br(dummy);
};
run();
#+end_src

#+RESULTS:
: dummy = 11
:
: undefined
:  [ [ 2, true ], [ 1, false ] ]

#+begin_quote
Tip. watch æ•°ç»„çš„æ—¶å€™ï¼Œéœ€è¦é€šè¿‡æ•°ç»„å…ƒç´ åŸæ¥çš„å¯¹è±¡å»æ“ä½œå€¼çš„å˜æ›´ï¼Œå¦‚æœé€šè¿‡æ•°ç»„ä¸‹
æ ‡è®¾å€¼æ˜¯ä¸ä¼šæˆåŠŸçš„ï¼Œå› ä¸ºè¿™ä¸ªæ•°ç»„æœ¬èº«ä¸æ˜¯ reactive çš„ã€‚

æ¯”å¦‚ï¼š ~array[0]++~ å¹¶ä¸ä¼šæ”¹å˜ ~state.count~

åªæœ‰é€šè¿‡ ~state.count++~ è‡ªèº«èµ‹å€¼æ“ä½œæ‰ä¼šè§¦å‘æ›´æ–°ã€‚
#+end_quote
** source is function

[[https://github.com/gcclll/stb-vue-next/commit/694a389fdeca9e3aaa8e70673da22f74552319fc][feat(add): rc->api watch->source is function Â· gcclll/stb-vue-next@694a389 Â·
GitHub]]

å½“è¦ watch çš„å¯¹è±¡æ˜¯ä¸ªå‡½æ•°çš„æ—¶å€™ï¼Œæ— è®ºæ˜¯å¦æœ‰ cb æœ€åçš„ getter éƒ½æ˜¯é€šè¿‡

~callWithErrorHandling(source, instance, ErrorCodes.WATCH_GETTER)~

æˆ–æ—  cb æ—¶ç­‰ä»·äºæ™®é€šçš„ effect å‡½æ•°

~callWithErrorHandling(source, instance,ErrorCodes.WATCH_CALLBACK,[onInvalidate])~

ç›´æ¥æ‰§è¡Œè¿™ä¸ªå‡½æ•°å»æ”¶é›†ä¾èµ–ã€‚

[[/img/tmp/20210115180348.png]]

æ–°å¢ä»£ç ï¼š
#+begin_src typescript
if (isFunction(source)) {
  // å¦‚æœæ˜¯å‡½æ•°ï¼Œç›´æ¥æ‰§è¡Œå–å¾—å‡½æ•°æ‰§è¡Œç»“æœ
  if (cb) {
    // getter with cb
    getter = () =>
      callWithErrorHandling(source, instance, ErrorCodes.WATCH_GETTER);
  } else {
    // no cb -> simple effect
    getter = () => {
      if (instance && instance.isUnmounted) {
        // ç»„ä»¶å·²ç»å¸è½½äº†
        return;
      }

      if (cleanup) cleanup();

      return callWithErrorHandling(
        source,
        instance,
        ErrorCodes.WATCH_CALLBACK,
        [onInvalidate]
      );
    };
  }
}
#+end_src

[[https://github.com/gcclll/stb-vue-next/commit/9565b4aa7a9d05e5551777254c385c7e79f9b840][feat(add): rc->api watch->source is function without cb Â·
gcclll/stb-vue-next@9565b4a Â· GitHub]]

æµ‹è¯•ï¼š
#+begin_src js
// æºæ–‡ä»¶ï¼š/js/vue/lib.js
const {
  rc: { nextTick, watchEffect, watch, ref },
  log,
} = require(process.env.BLOG_JS + "/vue/lib.js");

const run = async () => {
  let dummy,
    val = ref(0);
  watch(() => (dummy = val.value));
  val.value++;
  await nextTick();
  log.br({ dummy });

  log("with cb\n");
  // function with cb
  watch(
    () => val.value,
    (val, oldVal) => {
      dummy = [val, oldVal];
    }
  );
  val.value = 100;
  await nextTick();
  log([dummy, "\n"]);
};
run();
#+end_src

#+RESULTS:
: undefined
:
: { dummy: 1 }
: with cb
:
: [ 100, 1 ]
:

[[https://github.com/gcclll/stb-vue-next/commit/11ee8ef39efe740a5154939352fe7b3193e3d4c2][feat(add): rc->api watch->source invalid warning Â· gcclll/stb-vue-next@11ee8ef Â· GitHub]]

#+begin_quote
Q. è¿™é‡Œæœ‰ä¸ªå®¹æ˜“ææ··æ·†çš„åœ°æ–¹ï¼Œ ~watch(fn, cb)~ çš„æ—¶å€™ï¼Œè™½ç„¶ fn å’Œ cb éƒ½æ˜¯å‡½æ•°ï¼Œä½†
   æ˜¯è¦åŒºåˆ†å¼€è¿™ä¸¤è€…ï¼Œå¹¶ææ¸…æ¥šä»–ä»¬æ˜¯å•¥å’Œå…³ç³»æ˜¯å•¥ã€‚

   1. fn æ˜¯è¢«æ£€æµ‹çš„å¯¹è±¡ï¼Œå¦‚æœæ˜¯ function é‚£åœ¨è¢«ç›‘å¬ä¹‹å‰éœ€è¦å…ˆæ‰§è¡Œå®ƒï¼Œç­‰äºæ˜¯ç›‘å¬
      å‡½æ•°é‡Œé¢çš„å†…å®¹ï¼Œæ¯”å¦‚ï¼šå‡½æ•°å†…æœ‰è®¿é—®æŸä¸ª reactive å˜é‡

   2. è€Œ cb æ˜¯å±äºå›è°ƒæ€§è´¨ï¼Œä¸”æ˜¯å½“æ•°æ®æœ‰æ›´æ–°çš„æ—¶å€™çš„å›è°ƒå‡½æ•°ï¼Œå®ƒåªä¼šåœ¨ä¸€ä¸ªåœ°æ–¹è¢«
      æ‰§è¡Œï¼Œå³å°è£… job çš„æ—¶å€™ï¼Œéœ€è¦å°†æ•°æ®æ›´æ–°å‰åçš„å˜åŒ–å€¼é€šè¿‡å®ƒä¼ é€’å‡ºæ¥(å¦‚ä¸‹é¢ğŸ‘‡çš„
      ä»£ç )

#+end_quote

#+begin_src typescript
const job: SchedulerJob = () => {
  if (cb) {
    // watch(source, cb)
    const newValue = runner();
    if (deep || forceTrigger || hasChanged(newValue, oldValue)) {
      // cleanup
      if (cleanup) cleanup();
      callWithAsyncErrorHandling(cb, instance, ErrorCodes.WATCH_CALLBACK, [
        newValue,
        // pass undefined as the old value when it's changed for the first time
        // ç¬¬ä¸€æ¬¡çš„æ—¶å€™ oldValue ä¸º undefined
        oldValue === INITIAL_WATCHER_VALUE ? undefined : oldValue,
        onInvalidate,
      ]);
      oldValue = newValue;
    }
  } else {
    // watchEffect, no cb
    runner();
  }
};
#+end_src
** option deep
:PROPERTIES:
:COLUMNS: %CUSTOM_ID[(Custom Id)]
:CUSTOM_ID: api-watch-deep
:END:

å¯¹äºæ·±åº¦ç›‘å¬ä¸»è¦æ˜¯å› ä¸º ~traverse()~ å‡½æ•°å¯¹ reactive å¯¹è±¡è¿›è¡Œäº†é€’å½’éå†ï¼Œå¯¹æ¯ä¸ªå±
æ€§è¿›è¡Œäº†è®¿é—®ï¼Œä»è€Œè®©å®ƒæ”¶é›†åˆ°å½“å‰çš„ effect ä½œä¸ºä¾èµ–ï¼Œè¿™æ ·å°†æ¥è¿™äº›è¢«éå†åˆ°çš„å€¼å‘ç”Ÿ
æ”¹å˜æ—¶å°±ä¼šè§¦å‘è¿™ä¸ªæ”¶é›†åˆ°çš„ effect æ‰§è¡Œï¼Œè¾¾åˆ°æ·±åº¦ç›‘å¬æ•ˆæœã€‚

#+begin_src typescript
 // 3. cb + deep: true
 if (cb && deep) {
   const baseGetter = getter;
   // a. deep: true

   // b. source is reactive
   getter = () => traverse(baseGetter());
 }
#+end_src

#+begin_quote
~traverse()~ ä½œç”¨å°±æ˜¯é€’å½’éå†æ‰€æœ‰å±æ€§é€šè¿‡ ~return value~ æ¥æ‰§è¡Œ get æ“ä½œæ”¶é›†ä¾èµ–ã€‚
#+end_quote

æµ‹è¯•ï¼š
#+begin_src js
// æºæ–‡ä»¶ï¼š/js/vue/lib.js
const {
  rc: { ref, reactive, watch, nextTick },
  log,
} = require(process.env.BLOG_JS + "/vue/lib.js");

const run = async () => {
  const count = ref(0);

  const state = reactive({
    nested: { count },
    array: [1, 2, 3],
    map: new Map([
      ["a", 1],
      ["b", 2],
    ]),
    set: new Set([1, 2, 3]),
  });

  let dummy;
  watch(
    () => state,
    (state) => {
      dummy = [
        state.nested.count,
        state.array[0],
        state.map.get("a"),
        state.set.has(1),
      ];
    },
    { deep: true }
  );

  state.nested.count++;
  await nextTick();
  log(["\n", dummy]);

  state.array[0] = 2;
  await nextTick();
  log(["\n", dummy]);

  state.map.set("a", 100);
  await nextTick();
  log(["\n", dummy]);

  state.set.delete(1);
  await nextTick();
  log(["\n", dummy]);
};
run();
#+end_src

#+RESULTS:
: undefined
:  [ 1, 1, 1, true ]
:
:  [ 1, 2, 1, true ]
:
:  [ 1, 2, 100, true ]
:
:  [ 1, 2, 100, false ]

*** TODO deep ref
** option immediate

[[https://github.com/gcclll/stb-vue-next/commit/204ce6824b3f645d79f77f350b78a70bc3a47980][feat(add): rc->api watch->immediate option Â· gcclll/stb-vue-next@204ce68 Â·
GitHub]]

*immediate* é€‰é¡¹ï¼Œä¼šè®© cb/job ç«‹å³æ‰§è¡Œä¸€æ¬¡ï¼Œè€Œä¸æ˜¯åœ¨é˜Ÿåˆ—ä¸­ç­‰å¾…å¼‚æ­¥æ‰§è¡Œã€‚

æ–°å¢ä»£ç åªéœ€è¦åŠ ä¸€è¡Œï¼š
#+begin_src typescript
if (cb) {
  if (immediate) {
    job(); // è¿™é‡Œç›´æ¥è°ƒç”¨ Job
  } else {
    oldValue = runner();
  }
} else if (false /*flush->post*/) {
} else {
  runner();
}
#+end_src

æµ‹è¯•ï¼š
#+begin_src js
// æºæ–‡ä»¶ï¼š/js/vue/lib.js
const {
  rc: { nextTick, watch, ref },
  log,
} = require(process.env.BLOG_JS + "/vue/lib.js");

const run = async () => {
  const _log = (desc, newline) =>
    log([newline ? "\n" : "", `${desc} > dummy = ${dummy}`]);
  const cb = (val) => (dummy = val);
  const option = { immediate: true };

  const count = ref(0);
  let dummy;
  watch(count, cb, option);

  _log("æ”¹å˜å€¼ä¹‹å‰");
  count.value++;
  await nextTick();
  _log("æ”¹å˜å€¼ä¹‹å", true);

  const nul = ref(null);
  watch(() => nul.value, cb, option);
  _log("å½“åˆå§‹å€¼ä¸º null");

  const undef = ref();
  watch(() => undef.value, cb, option);
  _log("å½“åˆå§‹å€¼ä¸º undefined");
  undef.value = 3;
  await nextTick();
  _log("å½“åˆå§‹å€¼ä¸º undefined, set 3");
  undef.value = undefined;
  await nextTick();
  _log("å½“åˆå§‹å€¼ä¸º undefined, set undefined");
  // undefined === undefined -> hasChanged() -> false
  undef.value = undefined;
  await nextTick();
  _log("å½“åˆå§‹å€¼ä¸º undefined, set undefined");
};
run();
#+end_src

#+RESULTS:
:  æ”¹å˜å€¼ä¹‹å‰ > dummy = 0
: undefined
:  æ”¹å˜å€¼ä¹‹å > dummy = 1
:  å½“åˆå§‹å€¼ä¸º null > dummy = null
:  å½“åˆå§‹å€¼ä¸º undefined > dummy = undefined
:  å½“åˆå§‹å€¼ä¸º undefined, set 3 > dummy = 3
:  å½“åˆå§‹å€¼ä¸º undefined, set undefined > dummy = undefined
:  å½“åˆå§‹å€¼ä¸º undefined, set undefined > dummy = undefined

å¦‚ä¸Šç»“æœï¼Œ cb ä¼šç«‹å³æ‰§è¡Œã€‚

åœ¨ä½¿ç”¨ deep å’Œ immediate é€‰é¡¹çš„æ—¶å€™å¦‚æœæ²¡æœ‰ cb ä¼šç»™å‡ºè­¦å‘Šï¼Œç›´æ¥çœ‹æºç å§:
#+begin_src typescript
// 1. cb, immediate, deep æ£€æµ‹
if (__DEV__ && !cb) {
  if (immediate !== undefined) {
    warn(
      `watch() "immediate" option is only respected when using the ` +
        `watch(source, callback, options?) signature.`
    );
  }
  if (deep !== undefined) {
    warn(
      `watch() "deep" option is only respected when using the ` +
        `watch(source, callback, options?) signature.`
    );
  }
}
#+end_src

#+begin_quote
ä¹Ÿå°±æ˜¯è¯´ï¼Œ ~deep~ å’Œ ~immediate~ å»ºè®®åœ¨ ~watch(s, cb, options)~ å½¢å¼ä¸‹ä½¿ç”¨ï¼Œå³åœ¨
æœ‰ cb å‚æ•°çš„æƒ…å†µä¸‹ä½¿ç”¨ã€‚

é‚£ä¸ºä»€ä¹ˆå‘¢ï¼Ÿ
#+end_quote
** option onTrack + onTrigger

è¿™éƒ¨åˆ†å®ç°é€»è¾‘ä¸»è¦åœ¨ [[/vue/vue-mind-map-house-reactivity][reactivity]] æ¨¡å—ã€‚

onTrack åœ¨ reactivity ä¸­ä½¿ç”¨çš„ï¼Œç”¨æ¥åœ¨è§¦å‘ get å–å€¼æ“ä½œæ—¶è°ƒç”¨ [[/vue/vue-mind-map-house-reactivity/#r-track][track()]] å‡½æ•°æ”¶é›†ä¾
èµ–æ—¶çš„ä¸€ä¸ªè‡ªå®šä¹‰äº‹ä»¶å›è°ƒã€‚

#+begin_src typescript
// track() å‡½æˆæœ€å add æ“ä½œä¹‹å
if (!dep.has(activeEffect)) {
  dep.add(activeEffect);
  // è‡ªèº«ä¿å­˜ä¸€ä»½è¢«ä¾èµ–è€…åå•
  activeEffect.deps.push(dep);
  if (__DEV__ && activeEffect.options.onTrack) {
    activeEffect.options.onTrack({
      effect: activeEffect,
      target,
      type,
      key,
    });
  }
}

// trigger() å‡½æ•°ä¸­å®ç°
if (effect.options.onTrigger) {
  effect.options.onTrigger({
    effect,
    target,
    key,
    type,
    newValue,
    oldValue,
    oldTarget,
  });
}
#+end_src

è¿™é‡Œä¼šå°† å½“å‰ target çš„ key å±æ€§æ‰€æ”¶é›†çš„ä¾èµ– activeEffect æš´éœ²å‡ºæ¥ã€‚

æµ‹è¯•ï¼š
#+begin_src js
// æºæ–‡ä»¶ï¼š/js/vue/lib.js
const {
  rc: { nextTick, watchEffect, reactive },
  log,
} = require(process.env.BLOG_JS + "/vue/lib.js");

const run = async () => {
  const trackEvents = [];
  const triggerEvents = [];
  let dummy;
  const onTrack = (e /* activeEffect */) => trackEvents.push(e);
  const onTrigger = (e /* effect */) => triggerEvents.push(e);
  const obj = reactive({ foo: 1, bar: 2 });
  watchEffect(
    () => {
      dummy = [obj.foo, "bar" in obj, Object.keys(obj)];
    },
    { onTrack, onTrigger }
  );

  await nextTick();
  log(["\n", dummy]);
  // æœ‰å¤šå°‘ä¸ªå°±ç­‰äºå‘—è°ƒç”¨äº†å¤šå°‘æ¬¡
  log("track events count = " + trackEvents.length);
  trackEvents.forEach((e) => log.props(e, ["target", "type", "key", "deps"]));

  obj.foo = 3;
  obj.bar = 4;
  log("trigger events count = " + triggerEvents.length);
  triggerEvents.forEach((e) =>
    log.props(e, ["type", "key", "oldValue", "newValue"])
  );
};
run();
#+end_src

#+RESULTS:
: undefined
:  [ 1, true, [ 'foo', 'bar' ] ]
: track events count = 3
: { target: { foo: 1, bar: 2 }, type: 'get', key: 'foo' }
: { target: { foo: 1, bar: 2 }, type: 'has', key: 'bar' }
: { target: { foo: 1, bar: 2 }, type: 'iterate', key: Symbol(iterate) }
: trigger events count = 2
: { key: 'foo', type: 'set', newValue: 3, oldValue: 1 }
: { key: 'bar', type: 'set', newValue: 4, oldValue: 2 }


#+begin_comment
è¿™é‡Œè¿˜éœ€è¦å¼€å‘ç¯å¢ƒæ‰èƒ½æµ‹è¯• onTrackï¼Œåªèƒ½æ”¹ä¸€æ”¹å»æ‰ ~__DEV__~ è¯•è¯•ã€‚
#+end_comment

** stop & cleanup

*stop*: watch() çš„è¿”å›å€¼ï¼Œç”¨æ¥åœæ‰ effect ä½¿å…¶ effect.active = falseï¼Œè®© effect å¤±æ•ˆã€‚

#+begin_src typescript
// 9. return runner->stop, remove runner from instance.effects
return () => {
  stop(runner);
  if (instance) {
    remove(instance.effects!, runner);
  }
};
#+end_src

*cleanup*: æ¸…ç†å·¥ä½œï¼Œè¿™æœ‰ä¸¤ä¸ªè¢«è°ƒç”¨çš„åœ°æ–¹(cleanup + onStopå®ƒä»¬è¢«æ³¨å†Œäº†åŒä¸€ä¸ªå‡½æ•°)ï¼Œ
ä¸€ä¸ªæ˜¯è°ƒåŠ¨ cb/fn ä¹‹å‰ï¼Œä¸€ä¸ªæ˜¯ runner effect è°ƒç”¨ stop çš„æ—¶å€™ã€‚

#+begin_src typescript
let cleanup: () => void;
const onInvalidate: InvalidateCbRegistrator = (fn: () => void) => {
  cleanup = runner.options.onStop = () => {
    callWithErrorHandling(fn, instance, ErrorCodes.WATCH_CLEANUP);
  };
};
#+end_src

*** stop
stop æ˜¯ watch è°ƒç”¨çš„è¿”å›å€¼ï¼Œé‡Œé¢ä¼š stop runner ç„¶åå°† runner ä» ~instance.effects~
é‡Œé¢åˆ é™¤ã€‚

#+begin_src js
// æºæ–‡ä»¶ï¼š/js/vue/lib.js
const {
  rc: { reactive, nextTick, watch },
  log,
} = require(process.env.BLOG_JS + "/vue/lib.js");

const run = async () => {
  const state = reactive({ count: 0 });
  let dummy;
  const stop = watch(
    () => state.count,
    (count) => {
      dummy = count;
    }
  );

  state.count++;
  await nextTick();
  log.br({ dummy });

  stop();
  state.count = 100;
  await nextTick();
  log({ dummy });
};
run();
#+end_src

#+RESULTS:
: undefined
:  { dummy: 1 }
: { dummy: 1 }

å¯ä»¥çœ‹åˆ° stop ä¹‹åä¸¤æ¬¡è¾“å‡ºç»“æœæ˜¯ä¸€æ ·ï¼Œå³ stop åé¢çš„ state.count å¤±æ•ˆäº†ï¼Œå› ä¸º
stop effect ä¼šå°† effect.active ç½®ä¸º  false ï¼Œæœ‰å¦‚ä¸‹ä»£ç è¢«æ‰§è¡Œ:

#+begin_src typescript
// reactivity/src/effect.ts -> createReactiveEffect()
if (!effect.active) {
  return options.scheduler ? undefined : fn();
}
#+end_src

åˆï¼Œ watch å‡½æ•°é‡Œé¢æ— è®ºå¦‚ä½• scheduler éƒ½æ˜¯æœ‰å€¼çš„ï¼Œæ‰€ä»¥å½“ effect ä¸ºéæ¿€æ´»çŠ¶æ€ï¼Œä»€
ä¹ˆéƒ½ä¸ä¼šå¹²ã€‚

*** cleanup(æ—  cb)

cleanup ç›¸å…³æºç ï¼Œå¯èƒ½æœ‰ç‚¹ç»•:

#+begin_src typescript
// cleanup å’Œæ³¨å†Œ cleanup çš„ä¸€ä¸ªå‡½æ•°
// å¦‚ä¸‹ï¼Œcleanup å’Œ effect onStop æ˜¯åŒä¸€ä¸ªå‡½æ•°ï¼Œæ¸…ç† effect ç”¨
let cleanup: () => void;
const onInvalidate: InvalidateCbRegistrator = (fn: () => void) => {
  cleanup = runner.options.onStop = () => {
    callWithErrorHandling(fn, instance, ErrorCodes.WATCH_CLEANUP);
  };
};

// runtime-core/src/apiWatch.ts:watch(source, cb, option)
// Job å°è£…ä¸­å’Œ cleanup æœ‰å…³çš„
const job: SchedulerJob = () => {
  if (!runner.active) {
    return;
  }
  if (cb) {
    // watch(source, cb)
    const newValue = runner();
    if (deep || forceTrigger || hasChanged(newValue, oldValue)) {
      // cleanupï¼Œåœ¨æ‰§è¡Œ cb ä¹‹å‰å…ˆæ‰§è¡Œ cleanup
      if (cleanup) cleanup();
      // call cb with catch error
      // è¿™é‡Œç­‰ä»·äº cb(newValue, oldValue, onInvalidate)
      oldValue = newValue;
    }
  } /* else... */
};

// ç„¶åè¿˜æœ‰ä¸ªåœ°æ–¹ä¸ cleanup æœ‰å…³ï¼Œä¸”è¿™é‡Œè¦è®²åˆ°çš„å†…å®¹ä¼šåœ¨è¿™éƒ¨åˆ†æ‰§è¡Œ
// è·å– getterå‡½æ•°æ—¶å€™ï¼Œå¦‚æœ source æ˜¯å‡½æ•°ç­‰ä»·äº
// watchEffect(source)
if (isFunction(source)) {
  // å¦‚æœæ˜¯å‡½æ•°ï¼Œç›´æ¥æ‰§è¡Œå–å¾—å‡½æ•°æ‰§è¡Œç»“æœ
  if (cb) {
    // ...
  } else {
    // no cb -> simple effect
    getter = () => {
      if (instance && instance.isUnmounted) {
        // ç»„ä»¶å·²ç»å¸è½½äº†
        return;
      }

      if (cleanup) cleanup();
      // ç­‰ä»·äº return source(onInvalidate)
    };
  }
}
#+end_src

æµ‹è¯•ï¼š
#+begin_src js
// æºæ–‡ä»¶ï¼š/js/vue/lib.js
const {
  rc: { reactive, nextTick, watchEffect },
  log,
} = require(process.env.BLOG_JS + "/vue/lib.js");

const run = async () => {
  const state = reactive({ count: 0 });
  let n = 0;
  const cleanup = () => log(`\ncalled ${++n} times.`);
  let dummy;
  const stop = watchEffect((onCleanup) => {
    // è¿™é‡Œæ‰§è¡Œçš„å®é™…ä¸Šæ˜¯ onInvalidate å‡½æ•°ï¼Œå°†cleanup å°è£…åæ³¨å†Œåˆ°
    // cleanup å’Œ onStop ä¸Šï¼Œåœ¨ cb æ‰§è¡Œä¹‹å‰æˆ– effect stop æ—¶å€™è°ƒç”¨
    onCleanup(cleanup);
    dummy = state.count;
  });

  state.count++;
  await nextTick();
  // è¿™é‡Œä¼šè¾“å‡ºä¸€æ¬¡ 'called 1 times.'
  // å› ä¸º cb ä¹‹å‰ä¹‹å‰è¿›è¡Œäº†æ¸…ç†å·¥ä½œ(cleanup())
  log.br({ dummy });

  // è¿™é‡Œä¼šè¾“å‡ºä¸€æ¬¡ 'called 2 times.'
  // è¿™é‡Œæ˜¯ effect stop çš„ onStop è§¦å‘çš„
  stop();
};
run();
#+end_src

#+RESULTS:
: undefined
: called 1 times.
:
:  { dummy: 1 }
:
: called 2 times.

#+begin_quote
å³. å¦‚æœæƒ³åœ¨ effect fn ä¹‹å‰æˆ–åœæ­¢çš„æ—¶å€™è¿›è¡Œæ¸…ç†å·¥ä½œï¼Œå¯ä»¥ä½¿ç”¨
~watchEffect(effect)~ çš„å‚æ•° effect å‡½æ•°çš„ç¬¬ä¸€ä¸ªå‚æ•°æ¥æ³¨å†Œ ä¸€ä¸ªå‡½æ•°ä½œä¸ºæ¸…ç†å·¥ä½œ
æˆ–åšå…¶ä»–äº‹æƒ…ã€‚
å¦‚ï¼š ~watchEffect((onCleanup) => { onCleanup(cleanup) ... }~
#+end_quote

*** cleanup(æœ‰ cb)

å½“æœ‰ cb çš„æ—¶å€™ï¼š ~watch(source, cb, ...)~ ï¼Œå°† onCleanup æ³¨å†Œå‡½æ•°ä» cb çš„ç¬¬ä¸‰ä¸ªå‚æ•°æš´éœ²å‡ºæ¥
#+begin_src js
// æºæ–‡ä»¶ï¼š/js/vue/lib.js
const {
  rc: { nextTick, watch, ref },
  log,
} = require(process.env.BLOG_JS + "/vue/lib.js");

const run = async () => {
  const count = ref(0);
  let n = 0;
  const cleanup = () => log(`\ncalled ${++n} times, dummy = ${dummy}`);
  let dummy;
  const stop = watch(count, (newVal, oldVal, onCleanup) => {
    onCleanup(cleanup);
    dummy = newVal;
  });
// è¿™é‡Œ cleanup å°šä¸ä¼šæ‰§è¡Œ
// å› ä¸ºç¬¬ä¸€æ¬¡æ‰§è¡Œæ˜¯æ³¨å†Œ cleanup è¡Œä¸º
  count.value++;
  await nextTick();

// è¿™é‡Œä¼šæ‰§è¡Œä¸€æ¬¡ cleanup ï¼Œå› ä¸ºç¬¬ä¸€æ¬¡èµ‹å€¼æ—¶æ³¨å†Œè¿‡äº†
  count.value = 100;
  await nextTick();

// stop æ—¶å€™æ‰§è¡Œä¸€æ¬¡ï¼Œæ‰€ä»¥æ€»å…±ä¼šæ‰§è¡Œä¸¤æ¬¡ cleanup, n = 2
  stop();
  log({n})
};
run();
#+end_src

#+RESULTS:
: undefined
: called 1 times, dummy = 1
:
: called 2 times, dummy = 100
: { n: 2 }

è„‘å›¾åˆ†æï¼š

[[/img/vue3/runtime-core/vue-runtime-core-api-watch-cleanup.jpg]]

æ–‡å­—åˆ†æï¼š

1. cleanup æ³¨å†Œæ—¶æœºåˆ†ä¸ºä¸¤ç§æƒ…å†µ

   - ä¸€æ˜¯æ—  cb çš„ ~watchEffect(fn)~ ï¼Œæ˜¯åœ¨ getter è®¾ç½®é˜¶æ®µå°è£…åˆ° getter å‡½æ•°é‡Œé¢
     æ³¨å†Œçš„ï¼Œæ­¤æ—¶ä½œä¸º fn çš„ç¬¬ä¸€ä¸ªå‚æ•°æš´éœ²å‡ºæ¥ ~fn(onCleanUp)~ ï¼Œ

   - äºŒæ˜¯æœ‰ cb çš„ ~watch(ref(0), cb)~ , åœ¨ job å°è£…æœŸé—´åœ¨è°ƒç”¨ cb çš„æ—¶å€™æ³¨å†Œï¼Œæ­¤
     æ—¶ä½œä¸º cb çš„ç¬¬ä¸‰ä¸ªå‚æ•°æš´éœ²å‡ºæ¥ ~cb(newVal, oldVal, onCleanup)~

   #+begin_quote
   *ä¸¤è€…åŒºåˆ«* ï¼š watchEffect ç”±äºæ—  cb ä¼šç«‹å³æ‰§è¡Œä¸€æ¬¡ runner, æ­¤æ—¶å°±æ”¶é›†åˆ°äº† cleanupï¼Œ
   è€Œ watch æœ‰ cb æ—¶åˆ™æ˜¯ä¼šåœ¨ç¬¬ä¸€æ¬¡å€¼æ›´æ–°è§¦å‘ runner æ‰§è¡Œæ‰å¼€å§‹æ”¶é›† cleanupã€‚
   #+end_quote

2. æ‰§è¡Œæ—¶æœºï¼Œè¯¥é˜¶æ®µå’Œæ³¨å†Œæ—¶æœºç›¸è¾…ç›¸æˆï¼Œä¸”åœ¨ cb/fn æ‰§è¡Œä¹‹å‰å°±ä¼šè¢«æ‰§è¡Œï¼Œå› æ­¤ cb/fn
   çš„ç¬¬ä¸€æ¬¡æ‰§è¡Œéƒ½å±äºå¯¹ cleanup çš„æ³¨å†Œ
** flush sync

[[https://github.com/gcclll/stb-vue-next/commit/e1436f2cfe78cdc64c31c03d876c5b743a44fc18][feat(add): rc->api watch->option flush=sync Â· gcclll/stb-vue-next@e1436f2 Â· GitHub]]

æ”¯æŒåŒæ­¥ä»£ç ï¼Œå³æ‰€æœ‰ä»»åŠ¡ç«‹å³æ‰§è¡Œï¼ˆåœ¨å€¼å‘ç”Ÿæ”¹å˜ä¹‹åï¼‰ï¼Œè€Œä¸æ˜¯è¿›å…¥é˜Ÿåˆ—å¼‚æ­¥æ‰§è¡Œã€‚

åªéœ€è¦å¢åŠ ä¸€è¡Œä»£ç å°±è¡Œï¼š
#+begin_src typescript
// 6. TODO scheduler è®¾ç½®
let scheduler: ReactiveEffectOptions["scheduler"];
// 6.1 flush is 'sync'
if (flush === "sync") {
  scheduler = job;  // æ–°å¢
}
// 6.2 TODO flush is 'post'
else if (false /* post */) {
}
// 6.3 TODO flush is 'pre'(default)
else {
  // default: 'pre'
  scheduler = () => {
    if (!instance || instance.isMounted) {
      queuePreFlushCb(job);
    } else {
      // å¸¦ { pre: true } é€‰é¡¹ï¼Œç¬¬ä¸€æ¬¡è°ƒç”¨å¿…é¡»å‘ç”Ÿåœ¨ç»„ä»¶ mounted ä¹‹å‰
      // ä»è€Œä½¿ä»–è¢«åŒæ­¥è°ƒç”¨ï¼Œç«‹å³æ‰§è¡Œä¸€æ¬¡
      job();
    }
  };
}
#+end_src

æ–°å¢ ~scheduler = job~ ç›´æ¥è®©ä»»åŠ¡å‡½æ•°èµ‹å€¼ç»™è°ƒåº¦å™¨ï¼Œè¿™ä¸ªæ—¶å€™å¦‚æœæœ‰å€¼å‘ç”Ÿå˜åŒ–ï¼Œä¼š
è§¦å‘ effect> ~trigger()~ åœ¨è¿™é‡Œé¢ä¼šæ£€æµ‹æ˜¯ä¸æ˜¯æœ‰ ~option.scheduler~ å¦‚æœæœ‰ä¼šç«‹å³æ‰§è¡Œè¿™
ä¸ªå‡½æ•°ã€‚

#+begin_src typescript
// reactivity/effect.ts>trigger()
if (effect.options.scheduler) {
  effect.options.scheduler(effect);
} else {
  effect();
}
#+end_src

æµ‹è¯•:
#+begin_src js
// æºæ–‡ä»¶ï¼š/js/vue/lib.js
const {
  rc: { watch, ref },
  log,
} = require(process.env.BLOG_JS + "/vue/lib.js");

const run = async () => {
  const value = ref(0);
  let calls = 0;
  watch(value, () => ++calls, { flush: "sync" });

  log({ calls }); // -> 0
  value.value = 100;
  log({ calls }); // -> 1
};
run();
#+end_src

#+RESULTS:
: { calls: 0 }
: { calls: 1 }
: undefined

æ³¨æ„çœ‹ä¸Šé¢çš„æµ‹è¯•ç”¨ä¾‹å¹¶æ²¡æœ‰ç”¨ ~await nextTick()~ ï¼Œè€Œæ˜¯åŒæ­¥ä»£ç æ‰§è¡Œã€‚
** shallow ref
:PROPERTIES:
:COLUMNS: %CUSTOM_ID[(Custom Id)]
:CUSTOM_ID: watch-shallow-ref
:END:

#+begin_src js
// æºæ–‡ä»¶ï¼š/js/vue/lib.js
const {
  rc: { watch, shallowRef, nextTick, triggerRef },
  f,
  log,
} = require(process.env.BLOG_JS + "/vue/lib.js");

const run = async () => {
  const v = shallowRef({ a: 1 }); // #1
  let sideEffect = 0;
  watch(v, (obj) => { // #2 cb -> cb(newVal, oldVal, onCleanUp)
    sideEffect = obj.a;
  });

  v.value = v.value; // #3
  await nextTick();
  log(["\nshould not trigger: ", sideEffect]); // #4

  v.value.a++; // #5
  await nextTick();
  log(["\nshould not trigger: ", sideEffect]); // #6

  triggerRef(v); // #7
  await nextTick();
  log(["\nshould trigger now: ", sideEffect]); // #8
};
run();
#+end_src

#+RESULTS:
: undefined
: should not trigger:  0
:
: should not trigger:  0
:
: should trigger now:  2

#+begin_quote
ref è¿™ä¸€å—è¿˜æ²¡æ·±å…¥å»åˆ†æè¿‡ï¼Œå…ˆæš‚åœâ¸å»å®Œæˆä¸‹è¿™éƒ¨åˆ†ã€‚

1. DONE [2021-01-20 15:18:37] [[/vue/vue-mind-map-house-reactivity/#ref][ref å®Œæˆï¼Œå¯ä»¥å¾€ä¸‹ç»§ç»­äº†]]
#+end_quote

triggerRef ä½œç”¨æ˜¯æ‰‹åŠ¨è§¦å‘ ref.value ä¸Šæ”¶é›†çš„æ‰€æœ‰ä¾èµ–ã€‚

ç»“æœåˆ†æï¼š
1. *#1* shallowRef æ„å‘³ç€ ~{a: 1}~ ä¸­çš„å±æ€§ a é reactive
2. *#2* watch v åŸºäº *1* æ‰€ä»¥åªæ˜¯å¯¹ ref value è¿›è¡Œäº†ç›‘å¬ï¼Œåé¢æ˜¯å€¼å˜æ›´å›è°ƒ
3. *#3* å€¼æ²¡å‘ç”Ÿæ”¹å˜ï¼Œæ‰€æœ‰ *#4* è¾“å‡ºè¿˜æ˜¯ 0
4. *#5* ç”±äº ~a~ å±æ€§é reactive æ‰€ä»¥å®ƒæ²¡æœ‰ä¾èµ–æ”¶é›†æ‰€ä»¥ä¸ä¼šæ‰§è¡Œ cbï¼Œæ‰€ä»¥ *#6* å‡º
   ä¾ç„¶æ˜¯ 0
5. *#7* è¿™é‡Œæ‰‹åŠ¨è°ƒç”¨ ~triggerRef(v)~ ç­‰ä»·äº ~trigger(v, SET, 'value')~ è§¦å‘ ref
   value çš„ä¾èµ–æ‰§è¡Œï¼Œæ­¤æ—¶ cb ä¼šå¾—åˆ°æ‰§è¡Œï¼ŒsideEffect è¢«èµ‹å€¼æ–°çš„ ~v.a~ å€¼

   è¿™é‡Œæœ‰ä¸€ç‚¹éœ€è¦æ³¨æ„ï¼Œåœ¨ cb é‡Œé¢æ˜¯ç”¨çš„ v.a è€Œä¸æ˜¯ v.value.a å› ä¸ºåœ¨
   ~watch(s,cb,option)~ é‡Œé¢æ£€æµ‹åˆ°å¦‚æœ ~s~ æ˜¯ ref ç±»å‹ï¼Œä¼šå°† getter è®¾ç½®ä¸º
   ~getter = () => s.value~

   è€Œåœ¨æ‰§è¡Œ cb ä¹‹å‰å–æ–°å€¼æ˜¯é€šè¿‡ ~newVal = runner()~ å¾—åˆ°çš„ï¼Œè€Œè¿™ä¸ª ~runner =
   effect(getter, {...})~ æ‰€ä»¥ç­‰äºæ˜¯ ~effect(() => s.value, {...})~

   æ‰€ä»¥å¯¹äº ref ç±»å‹ effect å°è£…çš„å…¶å®æ˜¯ ~() => s.value~ è¿™ä¸ªå‡½
   æ•°ï¼Œé‚£ä¹ˆå¯¹äº ~s.value~ çš„ä¾èµ–åˆ—è¡¨ä¸­å°±ä¼šæœ‰è¿™ä¸ªç®­å¤´å‡½æ•°ã€‚

   ç„¶ååœ¨ watch é‡Œé¢ä¼šå°† cb çš„æ‰§è¡Œå°è£…è¿› job ï¼Œç„¶åæ ¹æ®æƒ…å†µå°† job å°è£…æˆ–ç›´æ¥èµ‹å€¼
   ç»™ scheduler ï¼Œè¿™ä¸ªä¼šä½œä¸º ~effect(, { scheduler })~ çš„é€‰é¡¹ä¼ é€’è¿›å»ã€‚

   é‚£ä¹ˆåœ¨ trigger çš„æ—¶å€™æ£€æµ‹åˆ°æä¾›äº† scheduler å°±ä¼šè°ƒç”¨å®ƒï¼Œæ‰€ä»¥æœ€ç»ˆè°ƒç”¨
   triggerRef(v) ä¼šè§¦å‘ cb çš„è°ƒç”¨å°† ~obj.a~å¤åˆ¶ç»™ ~sideEffect~ ï¼Œè¿™ä¸ª obj å°±æ˜¯
   runner() æ‰§è¡Œçš„è¿”å›å€¼ä¹Ÿå°±æ˜¯ ~() => s.value~ è¿™ä¸ªå‡½æ•°æ‰§è¡Œçš„è¿”å›å€¼ã€‚

** TODO flush pre(default) cb
** TODO flush post cb

[[https://github.com/gcclll/stb-vue-next/commit/ec14879bf13deb83cea3401279ea75e1cf44eaf6][feat(add): rc->watch->flush = 'post' Â· gcclll/stb-vue-next@ec14879 Â· GitHub]]

[[https://github.com/gcclll/stb-vue-next/commit/9f3ac7dff18926df602a7f0eff08da4b253e26a7][feat(add): rc->watch->cb->flush = 'post' Â· gcclll/stb-vue-next@9f3ac7d Â· GitHub]]

æ–°å¢ä»£ç ï¼š
#+begin_src typescript
// apiWatch.ts -> scheduler when flush=post
if (flush === "post") {
  scheduler = () => queuePostRenderEffect(job, instance && instance.suspense);
}

// renderer.ts -> queuePostRenderEffect
// å°†ä»»åŠ¡åŠ å…¥åˆ° suspense.effects æˆ– è°ƒç”¨ queuePostFlushCb
// åŠ å…¥åˆ° pendingPostFlushCbs
export const queuePostRenderEffect = __FEATURE_SUSPENSE__
  ? queueEffectWithSuspense
  : queuePostFlushCb;

// components/Suspense.ts
export function queueEffectWithSuspense(
  fn: Function | Function[],
  suspense: SuspenseBoundary | null
): void {
  if (suspense && suspense.pendingBranch) {
    if (isArray(fn)) {
      suspense.effects.push(...fn);
    } else {
      suspense.effects.push(fn);
    }
  } else {
    queuePostFlushCb(fn);
  }
}
#+end_src
** TODO ssr support
** TODO instance watch

[[https://github.com/gcclll/stb-vue-next/commit/9ec5d5131019fe67bcc7232e39bde1cfe239dbca][feat(add): rc->watch->instance watch Â· gcclll/stb-vue-next@9ec5d51 Â· GitHub]]

#+begin_src typescript
// this.$watch
export function instanceWatch(
  this: ComponentInternalInstance,
  source: string | Function,
  cb: WatchCallback,
  options?: WatchOptions
): WatchStopHandle {
  const publicThis = this.proxy as any
  const getter = isString(source)
    ? () => publicThis[source]
    : source.bind(publicThis)
  return doWatch(getter, cb.bind(publicThis), options, this)
}
#+end_src

å°†ç›‘å¬æºï¼Œä¸å½“å‰å®ä¾‹ç»‘å®šï¼Œå¦‚æœæ˜¯å­—ç¬¦ä¸²è½¬æˆå‡½æ•°ã€‚
* scheduler ä»»åŠ¡è°ƒåº¦æœºåˆ¶
:PROPERTIES:
:COLUMNS: %CUSTOM_ID[(Custom Id)]
:CUSTOM_ID: scheduler
:END:

è®©æˆ‘ä»¬è·Ÿç€ ~scheduler.spec.ts~ æµ‹è¯•ç”¨ä¾‹æ¥é€æ­¥å±æ€§ scheduler çš„è°ƒåº¦æœºåˆ¶ã€‚

åœ¨åšè¿™ä¸ªä¹‹å‰å…ˆæŠŠ scheduler.ts ä¸­é€»è¾‘ä»£ç å…¨æ¸…ç©ºï¼Œè¿™ä¸ªæ–‡ä»¶è¿˜æ˜¯ç›¸å¯¹ç‹¬ç«‹çš„

[[https://github.com/gcclll/stb-vue-next/commit/a54cc00ee93057839de620a152ca1fe691671f63][feat: rc->reset scheduler.ts Â· gcclll/stb-vue-next@a54cc00 Â· GitHub]]

æˆ‘ä»¬ä»é›¶å¼€å§‹ä¸€æ­¥æ­¥æ¥åˆ†æå®ç°ã€‚

[[/img/vue3/runtime-core/vue-runtime-core-scheduler.svg]]

è¿™éƒ¨åˆ†åŒ…å«ä¸‰ç§ä»»åŠ¡çš„ flush é€»è¾‘ä»£ç ï¼š

1. queue jobs -> ~flushIndex~ -> ~queue[]~ -> ~queueJob()~ -> ~queueFlush()~ -> ~flushJobs()~
2. pre jobs -> ~preFlushIndex~ -> ~pendingPreFlushCbs[]~ -> ~activePreFlushCbs[]~ ->
   ~queuePreFlushCb()~ -> ~flushPreFlushCbs()~ -> ~flushJobs()~
3. TODO post jobs -> ...
** nextTick
:PROPERTIES:
:COLUMNS: %CUSTOM_ID[(Custom Id)]
:CUSTOM_ID: nexttick
:END:

[[https://github.com/gcclll/stb-vue-next/commit/32b482762b074d3123906887df35231efea7dcc7][feat(add): rc->scheduler -> nextTick Â· gcclll/stb-vue-next@32b4827 Â· GitHub]]

åœ¨ queue æ‰€æœ‰é˜Ÿåˆ—æ¸…ç©ºä¹‹åæ‰§è¡Œçš„ä¸€ä¸ªå¼‚æ­¥æ“ä½œï¼Œæœ‰é‡è¦å…³è”çš„ä¸¤ä¸ªå˜é‡ï¼š

1. resolvedPromiseï¼Œä¸€ä¸ªç©ºçš„ promise then
2. currentFlushPromiseï¼Œå½“ queue é˜Ÿåˆ—ä¸­çš„æ‰€æœ‰ä»»åŠ¡æ‰§è¡Œå®Œæˆä¹‹åè¿”å›çš„ä¸€ä¸ª promise

   æ˜¯çš„ï¼Œæ˜¯æ‰€æœ‰ queue jobs å®Œæˆä¹‹åï¼Œå› ä¸º flushJobs å‡½æ•°é‡Œé¢éƒ½æ˜¯åŒæ­¥æ“ä½œï¼Œé‡è¦ä»£
   ç ï¼š

   #+begin_src typescript
   for (flushIndex = 0; flushIndex < queue.length; flushIndex++) {
     const job = queue[flushIndex];
     if (job) {
       // TODO DEV -> æ£€æŸ¥é€’å½’æ›´æ–°é—®é¢˜
       callWithErrorHandling(job, null, ErrorCodes.SCHEDULER);
     }
   }
   #+end_src


#+begin_quote
æ‰€ä»¥ nextTick ä»»åŠ¡æ€»æ˜¯åœ¨ queue jobs æ‰€æœ‰ä»»åŠ¡å®Œæˆä¹‹åæ‰§è¡Œã€‚
#+end_quote

#+begin_src typescript
const resolvedPromise: Promise<any> = Promise.resolve();
// å½“å‰æ­£åœ¨è¢«æ‰§è¡Œçš„ promise ä»»åŠ¡
let currentFlushPromise: Promise<void> | null = null;

export function nextTick(
  this: ComponentPublicInstance | void,
  fn?: () => void
): Promise<void> {
  const p = currentFlushPromise || resolvedPromise;
  return fn ? p.then(this ? fn.bind(this) : fn) : p;
}
#+end_src

å‡½æ•°ä½œç”¨ï¼šåœ¨å½“å‰æ­£åœ¨æ‰§è¡Œçš„ job promise ä¹‹åæ‰§è¡Œ nextTick çš„ä»»åŠ¡ï¼Œç­‰äºè¯´ nextTick
å±äºä¸ªæ’é˜Ÿä»»åŠ¡ã€‚

#+begin_src js
// æºæ–‡ä»¶ï¼š/js/vue/lib.js
const {
  rc: { nextTick },
  log,
} = require(process.env.BLOG_JS + "/vue/lib.js");

const run = async () => {
  const calls = [];
  const pr = Promise.resolve();
  const dummyThen = Promise.resolve().then();
  const job1 = () => calls.push("job1");
  const job2 = () => calls.push("job2");
  nextTick(job1);
  job2();
  log(["\nbefore await, ", calls.length, "\n"]);
  await dummyThen;
  log(["\nafter await, ", calls.length, "\n"]);
  log(calls.join("-"));
};

run();
#+end_src

#+RESULTS:
:
: before await,  1
:
: after await,  2
:
: job2-job1

#+begin_quote
Tip. nextTick() å¼‚æ­¥ä»£ç æ‰§è¡Œï¼Œç»è¿‡ babel è½¬æ¢åçš„ä»£ç ï¼Œè¯·æŸ¥çœ‹ [[#q-nexttick][nextTick question]]
#+end_quote

** queueJob
:PROPERTIES:
:COLUMNS: %CUSTOM_ID[(Custom Id)]
:CUSTOM_ID: job-queue-job
:END:

[[https://github.com/gcclll/stb-vue-next/commit/eb33b40b7e8e87165fa2149b1a1354d078f33c40][feat(add): rc->scheduler->queueJob Â· gcclll/stb-vue-next@eb33b40 Â· GitHub]]

[[/img/vue3/runtime-core/vue-runtime-core-scheduler.svg]]

#+begin_src typescript
export function queueJob(job: SchedulerJob) {
  // the dedupe search uses the startIndex argument of Array.includes()
  // by default the search index includes the current job that is being run
  // so it cannot recursively trigger itself again.
  // if the job is a watch() callback, the search will start with a +1 index to
  // allow it recursively trigger itself - it is the user's responsibility to
  // ensure it doesn't end up in an infinite loop.
  if (
    (!queue.length ||
      !queue.includes(
        job,
        isFlushing && job.allowRecurse ? flushIndex + 1 : flushIndex
      )) &&
    job !== currentPreFlushParentJob
  ) {
    queue.push(job)
    queueFlush
  }
}

function queueFlush() {
  if (!isFlushing && !isFlushPending) {
    isFlushPending = true
    currentFlushPromise = resolvedPromise.then(flushJobs)
  }
}

// è¯·æŸ¥çœ‹ä¸‹ä¸€èŠ‚çš„å®ç°
function flushJobs(seen?: CountMap) {
  // TODO
}
#+end_src

éœ€è¦ flushJobs æ”¯æŒï¼Œè¯·åˆ° flushJobs(ğŸ‘‡) ä¸€èŠ‚æŸ¥çœ‹æµ‹è¯•æƒ…å†µã€‚

** flushJobs

[[https://github.com/gcclll/stb-vue-next/commit/e23be119f8b67f8c828f01f031f2488afa55c0c9][feat(add): rc->scheduler->flushJobs function Â· gcclll/stb-vue-next@e23be11 Â· GitHub]]

1. isFlushPending, isFlushing æ ‡è¯†é‡ç½®
2. [[#job-flush-pre][flushPreFlushCbs]], å¯¹ pre ç±»å‹çš„ jobs è¿›è¡Œ flush æ“ä½œï¼Œæœ‰å…³å‡½æ•°
   ~flushPreFlushCbs(flushå‡½æ•°)~ å’Œ ~queuePreFlushCb(å…¥åˆ—å‡½æ•°)~
3. flush ä¹‹å‰è¿›è¡Œæ’åº
4. try -> callWithErrorHandling æ‰§è¡Œä»»åŠ¡å›è°ƒ
5. finally -> é‡ç½®ï¼Œæ¸…ç©º queue é˜Ÿåˆ—å†…å®¹å’Œæ ‡è¯†
6. TODO flushPostFlushCbs, å¯¹ post ç±»å‹çš„ jobs è¿›è¡Œ flush æ“ä½œï¼Œæœ‰å…³å‡½æ•°
   ~flushPostFlushCbs~ å’Œ ~queuePostFlushCb~

#+begin_src typescript
function flushJobs(seen?: CountMap) {
  isFlushPending = false;
  isFlushing = true;

  if (__DEV__) {
    seen = seen || new Map();
  }

  // flushPreFLushCbs(seen)ï¼Œé»˜è®¤çš„ job ç±»å‹

  // flush ä¹‹å‰å¯¹ queue æ’åº
  // 1. ç»„ä»¶æ›´æ–°é¡ºåºï¼šparent -> childï¼Œå› ä¸º parent æ€»æ˜¯åœ¨ child ä¹‹å‰
  //    è¢«åˆ›å»ºï¼Œå› æ­¤ parent render effect æœ‰æ›´ä½çš„ä¼˜å…ˆçº§æ•°å­—(æ•°å­—è¶Šå°è¶Šå…ˆåˆ›å»ºï¼Ÿ)
  // 2. å¦‚æœç»„ä»¶åœ¨ parent æ›´æ–°æœŸé—´è¢«å¸è½½äº†ï¼Œé‚£ä¹ˆå®ƒçš„æ›´æ–°éƒ½ä¼šè¢«å¿½ç•¥æ‰

  queue.sort((a, b) => getId(a) - getId(b));

  // å¼€å§‹ flush
  try {
    for (flushIndex = 0; flushIndex < queue.length; flushIndex++) {
      const job = queue[flushIndex];
      if (job) {
        // TODO DEV -> æ£€æŸ¥é€’å½’æ›´æ–°é—®é¢˜
        callWithErrorHandling(job, null, ErrorCodes.SCHEDULER);
      }
    }
  } finally {
    // æƒ…å†µé˜Ÿåˆ—
    flushIndex = 0;
    queue.length = 0;

    // TODO flush `post` ç±»å‹çš„ flush cbs

    isFlushing = false;
    currentFlushPromise = null;

    // TDOO ä»£ç æ‰§è¡Œåˆ°å½“å‰ tick çš„æ—¶å€™ï¼Œæœ‰å¯èƒ½æœ‰æ–°çš„ job åŠ å…¥
    // some postFlushCb queued jobs!
    // keep flushing until it drains.
  }
}
#+end_src

æµ‹è¯•ï¼š
#+begin_src js
// æºæ–‡ä»¶ï¼š/js/vue/lib.js
const {
  rc: { queueJob, nextTick },
  log,
} = require(process.env.BLOG_JS + "/vue/lib.js");
const run = async () => {
  const calls = [];
  const job1 = () => { // #1
    log.newline("job1 running");
    calls.push("job1");
  };
  const job2 = () => { // #2
    log.newline("job2 running");
    calls.push("job2");
  };
// æ”¯æŒå»é‡
  queueJob(job1); // #3
  queueJob(job2); // #4
  queueJob(job1);
  queueJob(job2);
  log("before await  " + calls); // #5
  await nextTick(); // #6
  log("after await  " + calls); // #7
};

run();
#+end_src

#+RESULTS:
: before await
: undefined
:
: job1 running
:
:
: job2 running
: after await  job1,job2

å¦‚æœåœ¨æ²¡æœ‰ *#6* çš„æƒ…å†µä¸‹ï¼Œåœ¨æ‰€æœ‰ Log ä¹‹åä¼šç«‹å³æ‰§è¡Œ queue jobsã€‚

#+begin_src typescript
function queueFlush() {
  if (!isFlushing && !isFlushPending) {
    isFlushPending = true;
    currentFlushPromise = resolvedPromise.then(flushJobs);
  }
}
#+end_src

è¿™é‡Œ nextTick() è°ƒç”¨å¹¶æ²¡æœ‰ä¼ é€’ fn ï¼Œå› æ­¤ ~await nextTick()~ åœ¨è¿™é‡Œçš„ä½œç”¨å°±æ˜¯ç­‰
~resolvedPromise~ æ‰§è¡Œå®Œæˆ(æ­¤æ—¶å¹¶æ²¡æœ‰æ­£åœ¨æ‰§è¡Œçš„ promise)

~const resolvedPromise: Promise<any> = Promise.resolve()~

å†æ‰§è¡Œåé¢çš„ä»£ç ã€‚

queueJob å‡½æ•°åˆ†ä¸ºä¸¤æ­¥ï¼š

1. push æ”¶é›†ä»»åŠ¡ ~queue.push(job)~ ï¼ŒåŒæ­¥æ‰§è¡Œ
2. éšåç«‹å³è°ƒç”¨ ~queueFlush()~ åˆ·æ‰ä»»åŠ¡ï¼Œä»»åŠ¡å¼‚æ­¥ flush

åœ¨è¿™ä¸ªå®ä¾‹ä¸­ï¼ŒæŒ‰ç…§åŒæ­¥æ‰§è¡Œé¡ºåºï¼Œ

1. ~queueJob(job1)~ æ‰§è¡Œï¼Œå°† job1 -> push -> queue ä¸­ï¼Œ queueFlush ä¸­çš„ promise ç­‰å¾…
2. ~queueJob(job2)~ æ‰§è¡Œï¼Œå°† job2 -> push -> queue ä¸­ï¼Œ
   queueFlush ä¸­çš„ promise ç»§ç»­ç­‰å¾…
3. ~log before~ æ‰§è¡Œï¼Œç”±äº job è™½ç„¶å·²ç»åœ¨ queue ä¸­äº†ï¼Œä½†æ˜¯éœ€è¦ç­‰å¾… queueFlush å»
   å¼‚æ­¥æ‰§è¡Œä»–ä»¬ï¼Œæ‰€ä»¥è¿™é‡Œ calls ä¾æ—§æ˜¯ç©ºçš„
4. ~await nextTick()~ å¼‚æ­¥æ“ä½œ

   è¿™ä¸€å¥ç›®çš„åªæ˜¯ä¸ºäº†è®©åé¢çš„ log åœ¨ job1,job2 åé¢æ‰§è¡Œã€‚

   #+begin_src typescript
    const p = currentFlushPromise || resolvedPromise;
    return fn ? p.then(this ? fn.bind(this) : fn) : p;
   #+end_src

  nextTick ä¼šåœ¨åˆšåˆšæ‰§è¡Œå®Œæ¯•çš„ promise åé¢å–æ‰§è¡Œåé¢çš„ä»»åŠ¡ï¼Œæ‰€ä»¥ log after è‚¯å®šæ˜¯åäº job1,job2 çš„æ‰§è¡Œçš„ã€‚

5. æ‰€æœ‰åŒæ­¥ä»»åŠ¡æ‰§è¡Œå®Œæˆï¼Œå¼€å§‹è¿›å…¥å¼‚æ­¥ä»»åŠ¡æ‰§è¡Œï¼Œç”±äº job1,job2 å…ˆå…¥é˜Ÿåˆ—ï¼Œåœ¨äº‹ä»¶å¾ª
   ç¯ä¸­ä¼šå…ˆäº log after æ‰§è¡Œï¼Œç„¶ååœ¨æ‰§è¡Œ log afterï¼Œæ‰€ä»¥å°±æœ‰äº†ä¸Šé¢çš„è¾“å‡ºç»“æœã€‚


å®ä¾‹æ‰§è¡Œè„‘å›¾ï¼š

[[/img/tmp/20210112173934.png]]

** queueJob while flushing

å½“ queue ä¸­ jobs æ­£åœ¨è¢«æ‰§è¡Œçš„æ—¶å€™è°ƒç”¨ queueJob è¿›å…¥æ–°çš„ä»»åŠ¡ã€‚

#+begin_src js
// æºæ–‡ä»¶ï¼š/js/vue/lib.js
const {
  rc: { queueJob, nextTick },
  log,
} = require(process.env.BLOG_JS + "/vue/lib.js");
const run = async () => {
  const calls = [];
  const job1 = () => {
    calls.push("job1");
    // job2 ä»»åŠ¡ä¼šåœ¨ job1 æ‰§è¡Œåˆ°è¿™é‡Œçš„æ—¶å€™åŠ å…¥åˆ°äº† queue
    // ä½†æ˜¯å®ƒçš„æ‰§è¡Œéœ€ç­‰åˆ° queue ä¸­çš„ä»»åŠ¡æ‰§è¡Œå®Œæˆä¹‹åå†æ‰§è¡Œ
    // å› ä¸ºä»»åŠ¡æ”¶é›†æ˜¯åŒæ­¥çš„ï¼Œä»»åŠ¡æ‰§è¡Œæ˜¯å¼‚æ­¥çš„ï¼Œè€Œ queue flush æ“ä½œåˆæ˜¯åŒæ­¥çš„
    queueJob(job2);
  };
  const job2 = () => calls.push("job2");
  queueJob(job1);
  await nextTick();
  log(["\nafter await\n", calls]);
};
run();
#+end_src

#+RESULTS:
: undefined
: after await
:  [ 'job1', 'job2' ]

çœ‹ä¸‹é¢çš„æµ‹è¯•ä»£ç ï¼ˆåœ¨ for å¾ªç¯è¿‡ç¨‹ä¸­æ”¹å˜æ•°ç»„é•¿åº¦ï¼Œä¼šæ£€æµ‹åˆ°è¿™ç§æ”¹å˜ï¼‰ï¼š
#+begin_src js
const nums = [1, 2, 3];
const add = (i) => nums.push(++i);
for (let i = 0; i < nums.length; i++) {
  if (i === 1) add(i);
  console.log({ i, v: nums[i], l: nums.length });
}
#+end_src

#+RESULTS:
: { i: 0, v: 1, l: 3 }
: { i: 1, v: 2, l: 4 }
: { i: 2, v: 3, l: 4 }
: { i: 3, v: 2, l: 4 }
: undefined

æ‰€ä»¥ä¸Šé¢çš„ Job å®ä¾‹ï¼Œå°±å¾ˆå¥½ç†è§£äº†

åœ¨ for queue jobs è¿‡ç¨‹ä¸­å‘ç°æœ‰æ–°çš„ job è¿›å…¥ï¼Œä¹‹å‰è¯´è¿‡äº†  queue çš„å…¥åˆ—æ“ä½œæ˜¯åŒæ­¥
çš„ï¼Œæ‰€ä»¥ä¼šç«‹å³æ‰§è¡Œæ”¹å˜ queue é•¿åº¦ï¼Œæœ€ååŠ å…¥çš„ä»»åŠ¡ä¼šåœ¨ for å¾ªç¯è¿‡ç¨‹ä¸­æœ€åå¾—åˆ°æ‰§è¡Œã€‚
** queuePreFlushCb

[[https://github.com/gcclll/stb-vue-next/commit/2c72cdc8734a3317041e4b14f288732379b4f1d2][feat(add): rc->scheduler->queuePreFlushCb -> pre jobs, pendingPreFlusâ€¦ Â· gcclll/stb-vue-next@2c72cdc Â· GitHub]]

æ–°å¢ä»£ç ï¼š

1. ~queuePreFlushCb~, å…¥åˆ— pre jobs å‡½æ•°
2. ~flushPreFlushCbs~, flush pre jobs å‡½æ•°
3. ~flushJobs~ ä¸­è°ƒç”¨ ~flushPreFlushCbs()~ åˆ·æ‰ pre jobs

è¿™ä¸ªæ˜¯ç”¨æ¥æ”¶é›†å’Œ flush pre ç±»å‹(é»˜è®¤ç±»å‹çš„ä»»åŠ¡)çš„é˜Ÿåˆ— ~pendingPreFlushCbs[]~  çš„å‡½æ•°ã€‚

é€»è¾‘è„‘å›¾ï¼š
[[/img/tmp/20210113103504.png]]

ç›¸å…³ä»£ç ï¼š
#+begin_src typescript
export function queuePreFlushCb(cb: SchedulerCb) {
  queueCb(cb, activePreFlushCbs, pendingPreFlushCbs, preFlushIndex);
}

function queueCb(
  cb: SchedulerCbs,
  activeQueue: SchedulerCb[] | null,
  pendingQueue: SchedulerCb[],
  index: number
) {
  if (!isArray(cb)) {
    if (
      !activeQueue ||
      !activeQueue.includes(
        cb,
        (cb as SchedulerJob).allowRecurse ? index + 1 : index
      )
    ) {
      pendingQueue.push(cb);
    }
  } else {
    pendingQueue.push(...cb);
  }
  queueFlush();
}
#+end_src

å¯¹æ¯” queueCb å’Œ queueJob ä¼šå‘ç°ä¸¤è€…æ²¡å¤šå¤§çš„å·®åˆ«ï¼Œå…ˆåŒæ­¥æ”¶é›†å†å¼‚æ­¥ flushï¼Œä¸¤è€…åˆ¤
æ–­æ¡ä»¶æœ‰ç»†å¾®å·®åˆ«ï¼Œå¦å¤– queueJob æ”¯æŒæ•°ç»„å½¢å¼çš„ cbï¼š
#+begin_src typescript
// queueJob
if (
  (!queue.length ||
    !queue.includes(
      job,
      isFlushing && job.allowRecurse ? flushIndex + 1 : flushIndex
    )) &&
  job !== currentPreFlushParentJob
) {
  queue.push(job);
  queueFlush();
}
#+end_src

æœ€åä¹Ÿéƒ½æ˜¯è°ƒç”¨ queueFlush() -> flushJobs() æ¥æ¸…ç©ºé˜Ÿåˆ— pendingQueue/queue ã€‚

æ‰€ä»¥ä¸‹é¢è¿˜éœ€è¦åœ¨ flushJobs() é‡Œé¢å»å®ç°å¯¹ pre -> pendingQueue ç±»å‹é˜Ÿåˆ— flush æ“
ä½œ(~flushPreFlushCbs()~)ã€‚
** flushPreFlushCbs
:PROPERTIES:
:COLUMNS: %CUSTOM_ID[(Custom Id)]
:CUSTOM_ID: job-flush-pre
:END:

æœ‰å…³å‡½æ•°å’Œå˜é‡

| name                 | type     | description                                                      |
|----------------------+----------+------------------------------------------------------------------|
| ~preFlushIndex~      | number   | used in `for` to flush pre jobs                                    |
| ~pendingPreFlushCbs~ | array    | the queue to store pre jobs                                      |
| ~activePreFlushCbs~  | array    | the non-repeat copy of ~pendingPreFlushCbs~, used to flushing    |
| ~queuePreFlushCb~    | function | ä¸ flushPreFlushCbs å¯¹åº”çš„ pre job å…¥åˆ—å‡½æ•°                      |
| ~queueFlush~         | function | æ‰§è¡Œé˜Ÿåˆ—ä»»åŠ¡çš„å‡½æ•°ï¼Œä¸‰ä¸ªç±»å‹çš„ä»»åŠ¡éƒ½åœ¨è¿™é‡Œé¢æ‰§è¡Œ(pre,post,queue) |
| ~flushJobs~          | function | å…·ä½“æ‰§è¡Œä»»åŠ¡çš„å‡½æ•°ï¼Œä¸‰ç§ä»»åŠ¡æ‰§è¡Œé¡ºåºæ˜¯ï¼š pre -> queue -> post    |

#+begin_quote
*Tip*. ~activePreFlushCbs~ å’Œ ~pendingPreFlushCbs~ çš„å…³ç³»ï¼š å‰è€…æ˜¯åè€…çš„ä¸€ä¸ªæ‹·è´ï¼Œ
æ‹·è´å®Œä¼šç«‹å³æ¸…ç©º pending, ç›®çš„æ˜¯ä¸ºäº†è®© pending åœ¨ active flushing æœŸé—´èƒ½ç»§ç»­æ”¶é›†
æ–°çš„ä»»åŠ¡ï¼Œè¿™æ ·å¦‚æœåœ¨æ‰§è¡ŒæœŸé—´æœ‰æ–°çš„ä»»åŠ¡å…¥åˆ—ï¼Œé‚£ä¹ˆåœ¨å‡½æ•°æœ€åçš„é€’å½’æ“ä½œä¼šå¯¹è¿™äº›æ–°å…¥
åˆ—çš„ä»»åŠ¡ç»§ç»­ flush æ‰ï¼Œç›´åˆ°å†ä¹Ÿæ²¡æœ‰æ–°çš„ä»»åŠ¡å…¥åˆ—ä¸ºæ­¢ã€‚

*æ³¨æ„ç‚¹* ï¼šå½“ ~queuePreFlushCb~ åœ¨ queueJob ä¸­ä½¿ç”¨æ—¶ä¸ä¼šä¸»åŠ¨è§¦å‘ cbs æ‰§è¡Œï¼Œå¦‚æœ
éœ€è¦ç«‹å³æ‰§è¡Œè¿™äº› cbs éœ€è¦æ‰‹åŠ¨è°ƒç”¨ ~flushPreFlushCbs(seen, parentJob)~ å»åˆ·æ‰ pre
cbs ä»»åŠ¡ï¼Œæˆ–è€…ç­‰åˆ°å½“å‰ job æ‰§è¡Œå®Œäº†ä¸‹ä¸€ä¸ª ~flushJobs()~ è°ƒç”¨ä¸­æ‰§è¡Œï¼Œå› ä¸º
~queueJob()~ æ‰§è¡ŒæœŸé—´ ~isFlushing = true~ ï¼Œè€Œåœ¨ ~queueFlush()~ ä¸­æœ‰æ£€æµ‹è¿™ä¸ªå€¼ï¼Œ
å¦‚æœæ­£åœ¨æ‰§è¡Œ flushing æ˜¯ä¸ä¼šç»§ç»­æ‰§è¡Œçš„ï¼Œæ›´å¤šè¯¦æƒ…æŸ¥çœ‹åé¢çš„æµ‹è¯•å’Œåˆ†æã€‚
#+end_quote

æºç ï¼š
#+begin_src typescript
export function flushPreFlushCbs(
  seen?: CountMap,
  parentJob: SchedulerJob | null = null
) {
  if (pendingPreFlushCbs.length) {
    currentPreFlushParentJob = parentJob;
    activePreFlushCbs = [...new Set(pendingPreFlushCbs)];
    pendingPreFlushCbs.length = 0;
    if (__DEV__) {
      seen = seen || new Map();
    }

    for (
      preFlushIndex = 0;
      preFlushIndex < activePreFlushCbs.length;
      preFlushIndex++
    ) {
      // TODO æ£€æŸ¥é€’å½’æ›´æ–°é—®é¢˜
      activePreFlushCbs[preFlushIndex]();
    }

    activePreFlushCbs = null;
    preFlushIndex = 0;
    currentPreFlushParentJob = null;
    // é€’å½’ flush ç›´åˆ°æ‰€æœ‰ pre jobs è¢«æ‰§è¡Œå®Œæˆ
    flushPreFlushCbs(seen, parentJob);
  }
}
#+end_src

ç”¨é€”ï¼š api watch é‡Œé¢å¯¹é»˜è®¤ç±»å‹(~pre~)çš„ä»»åŠ¡çš„å…¥åˆ—æ“ä½œï¼Œå¦‚ä¸‹ä»£ç ï¼š
#+begin_src typescript
// default: 'pre'
function doWatch(
  source: WatchSource | WatchSource[] | WatchEffect | object,
  cb: WatchCallback | null,
  { immediate, deep, flush, onTrack, onTrigger }: WatchOptions = EMPTY_OBJ,
  instance = currentInstance
): WatchStopHandle {
  // ...
  let scheduler: ReactiveEffectOptions["scheduler"];
  if (flush === "sync") {
    // ...
  } else if (flush === "post") {
    // ...
  } else {
    // default: 'pre'
    scheduler = () => {
      if (!instance || instance.isMounted) {
        queuePreFlushCb(job);
      } else {
        // with 'pre' option, the first call must happen before
        // the component is mounted so it is called synchronously.
        job();
      }
    };
  }
  // ...
}
#+end_src

æµ‹è¯•ï¼š
#+begin_src js
// æºæ–‡ä»¶ï¼š/js/vue/lib.js
const {
  rc: { queueJob, queuePreFlushCb, flushPreFlushCbs, nextTick },
  log,
} = require(process.env.BLOG_JS + "/vue/lib.js");

const run = async () => {
  const calls = [];
  const job1 = () => { // #1
    queuePreFlushCb(cb1); // #2
    queuePreFlushCb(cb2); // #3
    // æ‰‹åŠ¨è§¦å‘ cb1, cb2
    flushPreFlushCbs(undefined, job1); // #4
    calls.push("job1"); // #5
  };
  const cb1 = () => calls.push("cb1"); // #6
  const cb2 = () => calls.push("cb2"); // #7

  queueJob(job1); // #8
  await nextTick(); // #9
  log.newline(calls); // #10
};
run();
#+end_src

#+RESULTS:
: undefined
:
: cb1 cb2 job1

æµ‹è¯•åˆ†æä»£ç è„‘å›¾ï¼š
[[/img/vue3/runtime-core/vue-runtime-core-test-preflush-inside-queuejob.jpg]]

æ–‡å­—åˆ†æï¼š
1. *#8* å…ˆæ‰§è¡Œï¼Œ queueJob -> push job1 -> queue:[job1] -> queueFlush()

   åœ¨ queueFlush() ä¸­è°ƒç”¨ ~resolvedPromise.then(flushJobs)~ å¼‚æ­¥æ‰§è¡Œ flushJobs()
   å‡½æ•°åˆ·æ‰æ‰€æœ‰ä»»åŠ¡(pre/job/post)

   å¹¶ä¸”è®°å½•å½“å‰ tick ä¸‹çš„ promise: ~currentFlushPromise~

   æ­¤æ—¶çš„ ~pendingPreFlushCbs[]~ ä¸­æ˜¯æ²¡æœ‰ä»»ä½•ä»»åŠ¡çš„ï¼Œæ‰€ä»¥ç»§ç»­æ‰§è¡Œ try{...} å¼€å§‹
   flush queue[] jobsï¼Œè¿™ä¸ªæ—¶å€™ flushIndex = 0 å¾—åˆ° job1ï¼Œå¼€å§‹æŒ‰é¡ºåºæ‰§è¡Œ job1

2. *#1* å¼€å§‹æ‰§è¡Œ

3. *#2* å°† cb1 push -> ~pendingPreFlushCbs=[cb1]~

4. *#3* å°† cb2 push -> ~pendingPreFlushCbs=[cb1, cb2]~

5. *#4* æ‰‹åŠ¨ flush pre cbs

   åœ¨ ~flushPreFlushCbs(undefind, job1)~ ä¸­ä¼šè®°å½• ~currentPreFlushParentJob =
   job1~ è¿™ä¸ªå˜é‡å°†ä¼šåœ¨ ~queueJob(job)~ ä¸­ç”¨æ¥æ£€æµ‹ job æ˜¯ä¸æ˜¯å½“å‰çš„ job1 å¦‚æœæ˜¯
   å°±ä¸å…è®¸ pushï¼Œå› ä¸º job1 ä¸‹æœ‰å­ä»»åŠ¡æ­£åœ¨æ‰§è¡Œï¼Œå¿…é¡»ç­‰è¿™äº›å­ä»»åŠ¡(cb1, cb2) æ‰§è¡Œå®Œã€‚

6. *#6* å¼€å§‹æ‰§è¡Œï¼Œ push 'cb1' -> calls: ['cb1']

7. *#7* å¼€å§‹æ‰§è¡Œï¼Œ push 'cb2' -> calls: ['cb1', 'cb2']

8. *#5* å¼€å§‹æ‰§è¡Œï¼Œ push 'job1' -> alls: ['cb1', 'cb2', 'job1']

9. *#9* å¼€å§‹æ‰§è¡Œï¼Œå› ä¸º nextTick()

   #+begin_src typescript
   export function nextTick(
     this: ComponentPublicInstance | void,
     fn?: () => void
   ): Promise<void> {
     const p = currentFlushPromise || resolvedPromise;
     return fn ? p.then(this ? fn.bind(this) : fn) : p;
   }
   #+end_src

   è¿™é‡Œçš„ await ä¼šç­‰ job1 queueFlush() è§¦å‘çš„ promise.then(flushJobs) è¿”å›çš„
   promise å®Œæˆä¹‹åå†æ‰§è¡Œåé¢çš„ä»£ç ã€‚

10. *#10* log è¾“å‡º ~'cb1,cb2,job1'~

** queuePostFlushCb + flushPostFlushCbs

[[https://github.com/gcclll/stb-vue-next/commit/845c21bfc0ef1797d39a9fd789d79a4fdc3bd399][feat(add): rc->scheduler->queuePostFlushCb+flushPostFlushCbs Â· gcclll/stb-vue-next@845c21b Â· GitHub]]

é€»è¾‘è„‘å›¾ï¼š
[[/img/tmp/20210113143628.png]]

æœ‰äº† queue job å’Œ pre cb çš„åŸºç¡€åˆ†æï¼Œè¿™éƒ¨åˆ†ä¹Ÿå°±å¾ˆå¥½ç†è§£äº†ã€‚

#+begin_src typescript
export function queuePostFlushCb(cb: SchedulerCbs) {
  queueCb(cb, activePostFlushCbs, pendingPostFlushCbs, postFlushIndex);
}

export function flushPostFlushCbs(seen?: CountMap) {
  if (pendingPostFlushCbs.length) {
    const deduped = [...new Set(pendingPostFlushCbs)];
    pendingPostFlushCbs.length = 0;

    // #1947 already has active queue, nested flushPostFlushCbs call
    if (activePostFlushCbs) {
      activePostFlushCbs.push(...deduped);
      return;
    }

    activePostFlushCbs = deduped;
    if (__DEV__) {
      seen = seen || new Map();
    }

    activePostFlushCbs.sort((a, b) => getId(a) - getId(b));

    for (
      postFlushIndex = 0;
      postFlushIndex < activePostFlushCbs.length;
      postFlushIndex++
    ) {
      // TODO é€’å½’ update æ£€æŸ¥
      activePostFlushCbs[postFlushIndex]();
    }

    activePostFlushCbs = null;
    postFlushIndex = 0;
  }
}
#+end_src

å’Œ pre cb çš„å¤„ç†æœ‰ä¸¤ä¸ªä¸åŒç‚¹ï¼š
1. éå›è°ƒå½¢å¼å¤„ç† flushing æœŸé—´æ¥å—åˆ°çš„æ–°ä»»åŠ¡ï¼Œè€Œæ˜¯é€šè¿‡æ”¹å˜æ‰§è¡Œå™¨
   activePostFlushCbs æ¥å®ç°(å’Œ queue job ç±»ä¼¼)
2. æ²¡æœ‰é€’å½’å›è°ƒå½¢å¼å¤„ç†åç»­çš„æ–°ä»»åŠ¡ï¼Œå‚è€ƒ *1*

æµ‹è¯•ï¼š
#+begin_src js
// æºæ–‡ä»¶ï¼š/js/vue/lib.js
const {
  rc: { queuePostFlushCb, nextTick, queueJob },
  log,
} = require(process.env.BLOG_JS + "/vue/lib.js");

// len = activePostFlushCbs.length
const run = async () => {
  const calls = [];
  const cb1 = () => {
    calls.push("cb1");
    // ä¼šåœ¨åŒä¸€ä¸ª tick æœŸé—´æ‰§è¡Œï¼Œå› ä¸ºå®ƒåœ¨for flushing æœŸé—´æ”¹å˜äº†
    // activePostFlushCbsï¼Œå¹¶ä¸”ç´§éš cb1,cb2,cb3 ä¹‹åæ‰§è¡Œ
    queuePostFlushCb(cb4);
  };
  const cb2 = () => calls.push("cb2");
  const cb3 = () => calls.push("cb3");
  // job1 ä¼šåœ¨ cb4 ä¹‹åæ‰§è¡Œï¼Œå› ä¸º flushJobs åœ¨æŒ‰é¡ºåºæ‰§è¡Œå®Œ
  // pre -> job -> post æœ€åçš„ finally é‡Œé¢å¯¹ queue è¿›è¡Œäº†æ£€æµ‹
  // æ­¤æ—¶ queue = [job1] éšæ„ä¼šé€’å½’è°ƒç”¨ flushJobs() ç»§ç»­åˆ·
  // ä½†æ˜¯ä¸ºä»€ä¹ˆ cb5 ä¼šåœ¨ job1 ä¹‹åå‘¢ï¼Ÿï¼Ÿï¼Ÿ
  // å› ä¸º queuePostFlushCb push çš„æ˜¯ pendingPostFlushCbs è€Œä¸æ˜¯
  // activePostFlushCbsï¼Œæ‰€ä»¥åœ¨ queuePostFlushCb ä¸­è°ƒç”¨è‡ªèº«å¢åŠ çš„æ–°
  // cbs ä¼šåœ¨ finally åé¢çš„æ£€æµ‹é€’å½’ flushJobs() è°ƒç”¨ä¸­æ‰§è¡Œ
  // è€Œ post çš„ä¼˜å…ˆçº§åˆä½äº job æ‰€ä»¥ job1 ä¼šä¼˜å…ˆè¾“å‡º
  const cb4 = () => (queuePostFlushCb(cb5), queueJob(job1), calls.push("cb4"));
  // ä¼šåœ¨ job1,cb5 ä¹‹åæ‰§è¡Œ
  const job1 = () => (queuePostFlushCb(cb6), calls.push("job1"));
  const cb5 = () => calls.push("cb5");
  const cb6 = () => calls.push("cb6");

  queuePostFlushCb([cb1, cb2]);
  queuePostFlushCb(cb3);

  // åº”è¯¥å»é‡
  queuePostFlushCb([cb1, cb3]);
  queuePostFlushCb(cb2);
  await nextTick();
  log.newline(calls);
};
run();
#+end_src

#+RESULTS:
: undefined
:
: cb1 cb2 cb3 cb4 job1 cb5 cb6

#+begin_quote
å¯¹äº ~queuePostFlushCb~ å’Œ ~queueJob~ çš„æ··ç”¨åªè¦è®°ä½ä¸€ç‚¹ï¼Œ ~queuePostFlushCb~ ä¸
ä¼šè§¦å‘ ~activePostFlushCbs~ æ”¹å˜ï¼Œå› ä¸º isFlushing = trueï¼Œæ‰€ä»¥åªä¼šåœ¨å½“å‰
~flushJobs()~ æ‰§è¡Œåˆ°æœ€åé€’å½’æ£€æµ‹çš„æ—¶å€™æ‰ä¼šè¿›å…¥ä¸‹ä¸€æ¬¡çš„ post+job è°ƒç”¨ã€‚
#+end_quote

** test nested(pre/job/post)

å®Œæ•´çš„æµ‹è¯•ç”¨ä¾‹ï¼Œç»“åˆ pre, post, queue ä¸‰ç§ç±»å‹çš„ä»»åŠ¡è¿›è¡Œæµ‹è¯•ã€‚

#+begin_src js
// æºæ–‡ä»¶ï¼š/js/vue/lib.js
const {
  rc: { queueJob, queuePreFlushCb, nextTick, flushPreFlushCbs },
  log,
} = require(process.env.BLOG_JS + "/vue/lib.js");

const run = async () => {
  const calls = [];
  const cb1 = () => {
    calls.push("cb1");
  };
  const cb2 = () => {
    calls.push("cb2");
    // queueJob å’Œ queuePreFlushCb ç»“åˆä½¿ç”¨
    queueJob(job1);
  };
  const cb3 = () => {
    calls.push("cb3");
    // é“¾å¼ä½¿ç”¨ï¼Œcb4 ä¼šåœ¨ cb1,2,3 æ‰§è¡Œå®Œæˆä¹‹åæ‰ä¼šæ‰§è¡Œ
    queuePreFlushCb(cb4);
  };
  const cb4 = () => {
    calls.push("cb4");
  };
  const cb5 = () => {
    calls.push("cb5");
  };
  const job1 = () => {
    calls.push("job1");
    // queuePreFlushCb åœ¨ queueJob ä¸­è°ƒç”¨
    // pre cbs åœ¨ job ä¸­è°ƒç”¨çš„æ—¶å€™ä¸ä¼šè¢«æ‰§è¡Œï¼Œé™¤éåœ¨è¿™åé¢æ‰‹åŠ¨ flush
    // æˆ–è€…æœ‰æ–°çš„ä»»åŠ¡è¿›æ¥ï¼Œå‘èµ· flushJobs è°ƒç”¨æ‰ä¼šæ‰§è¡Œ
    queuePreFlushCb(cb5);
    // å¿…é¡»æ‰‹åŠ¨è§¦å‘, è¿™æ · cb5 æ‰ä¼šè¾“å‡º
    flushPreFlushCbs(undefined, job1 /* currentPreFlushParentJob */);
  };
  const cb6 = () => {
    calls.push("cb6");
  };

  queuePreFlushCb(cb1);
  queuePreFlushCb(cb2);
  queuePreFlushCb(cb1);
  queuePreFlushCb(cb2);
  queuePreFlushCb(cb3);

  await nextTick();
  log("\n" + calls);
};
run();
#+end_src

#+RESULTS:
: undefined
: cb1,cb2,cb3,cb4,job1,cb5

1. pendingPreFlushCbs è™½ç„¶æ˜¯ä¸ªæ•°ç»„ï¼Œä½†æ˜¯ flush æœŸé—´é€šè¿‡ ~[...new
   Set(pendingPreFlushCbs)]~ è¿›è¡Œäº†å»é‡æ“ä½œã€‚
2. é“¾å¼æ“ä½œï¼Œå› ä¸ºåœ¨æ‰§è¡ŒæœŸé—´ä½¿ç”¨çš„æ˜¯ ~activePreFlushCbs~ ä¸”æ­¤æ—¶çš„
   ~pendingPreFlushCbs~ æ¸…ç©ºäº†ï¼Œç­‰å¾…æ–°ä»»åŠ¡å…¥åˆ—

   åœ¨æ‰§è¡Œ cb3 æœŸé—´ï¼Œè°ƒç”¨ ~queuePreFlushCb(cb4)~ æ­¤æ—¶ push cb4 ->
   ~pendingPreFlushCbs~ ï¼Œä½†å®é™…ä¸ä¼šå½±å“æœ¬æ¬¡çš„ for å¾ªç¯æ‰§è¡Œ

   [[#job-queue-job][è¿™ç‚¹å’Œ queueJob æœ‰ç‚¹ä¸åŒï¼Œå®ƒç›´æ¥ä½¿ç”¨çš„æ˜¯ queue -> for æ‰€ä»¥æœ‰æ–°çš„ä»»åŠ¡å…¥åˆ—ä¼šæ”¹
   å˜ for çš„æ‰§è¡Œé•¿åº¦(queue.length)]]

   pre å¤„ç†ä¼šç­‰åˆ° activePreFlushCbs for æ‰§è¡Œå¾ªç¯ç»“æŸåï¼Œåœ¨å‡½æ•°çš„æœ€åé€’å½’è°ƒç”¨
   ~flushPreFlushCbs()~ æ¥åˆ·æ‰æ–°å…¥åˆ—çš„ä»»åŠ¡(å¦‚ï¼š *cb4*)
3. queueJob åœ¨ queuePreFlushCb ä¸­è°ƒç”¨çš„æ—¶å€™ï¼Œ queue job æ€»æ˜¯åœ¨ pre cb ä¹‹åè¢«æ‰§è¡Œï¼Œè¿™ä¹Ÿ
   æ˜¯ flushJobs ä¸­å¤„ç†ä»£ç åº”ä½“ç°å‡ºçš„ç»“æœã€‚

  #+begin_src typescript
  function flushJobs() {
    // 1. flush pre -> flushPreFlushCbs()
    // 2. for -> queue job -> callWithErrorHandling(job, ...)
    // 3. flush post -> flushPostFlushCbs()
  }
  #+end_src

  å¹¶ä¸”å¦‚ä¸Šé¢å®ä¾‹ç»“æœ cb4 åµŒå¥—åœ¨ cb3 ï¼Œjob1 åµŒå¥—åœ¨äº† cb2 ä¸­ï¼Œä½†æ˜¯æœ€åè¿˜æ˜¯ cb4 å…ˆ
   å¾—åˆ°æ‰§è¡Œäº†ï¼Œjob1 å†æ‰§è¡Œã€‚

   #+begin_quote
   Tip. å› æ­¤ï¼Œå¯¹äº pre cbs å’Œ queue jobs ä¸¤ä¸ªç±»å‹çš„ä»»åŠ¡ï¼Œä¸ç®¡ä»€ä¹ˆæ—¶æœºå…¥åˆ—çš„ï¼Œéƒ½ä¼š
   æ˜¯å…ˆæ‰§è¡Œ pre cbs å†æ‰§è¡Œ queue jobs
   #+end_quote
4. queuePreFlushCb åœ¨ queueJob ä¸­è°ƒç”¨çš„æ—¶å€™ï¼Œæ–°çš„ pre job ä¼šåœ¨ queue job åæ‰§è¡Œ

   [[https://github.com/gcclll/stb-vue-next/commit/b0155c5405deba3da37c60d2beb8d08a377f699d][fix: rc->scheduler->flushJobs recursive Â· gcclll/stb-vue-next@b0155c5 Â·
   GitHub]]

   åŸå› ï¼š ~flushPreFlushCbs~ å…ˆäº queue jobs æ‰§è¡Œï¼Œå› æ­¤ queue jobs(~job1~) æ‰§è¡Œ
   çš„æ—¶å€™ ~queuePreFlushCb()~ åŠ å…¥çš„ä»»åŠ¡(~cb5~)æ­¤æ—¶ä¸ä¼šæ‰§è¡Œï¼Œè€Œæ˜¯ç­‰ queue jobs
   éƒ½æ‰§è¡Œå®Œä¹‹ååœ¨finally é‡Œé¢ä¼šåšä¸€æ¬¡æ£€æµ‹

   #+begin_src typescript
   if (queue.length || pendingPreFlushCbs.length) {
      flushJobs(seen)
    }
   #+end_src

   è¿™ä¸ªæ—¶å€™ä¼šå»é€’å½’ ~flushJobs()~ æ­¤æ—¶æ‰å‘ç°æœ‰æ–°çš„ ~pendingPreFlushCbs~ (å¦‚ï¼š
   ~cb5~)ï¼Œåˆ™å°†æ‰§è¡Œä»–ä»¬ï¼Œæ‰€ä»¥ç»“æœæ˜¯ ~job1,cb5~ ã€‚

** invalidateJob(job)

[[https://github.com/gcclll/stb-vue-next/commit/24808b106cfaad8af29a7343918a21836f1aff5d][feat(add): rc->scheduler->invalidateJob Â· gcclll/stb-vue-next@24808b1 Â· GitHub]]

æ˜¯ä»»åŠ¡å¤±æ•ˆï¼Œå…¶å®å°±æ˜¯å•çº¯çš„å°† Job ä» queue ä¸­åˆ é™¤äº†ã€‚

#+begin_src typescript
export function invalidateJob(job: SchedulerJob) {
  const i = queue.indexOf(job);
  if (i > -1) {
    queue.splice(i, 1);
  }
}
#+end_src

æµ‹è¯•:
#+begin_src js
// æºæ–‡ä»¶ï¼š/js/vue/lib.js
const {
  rc: { queueJob, queuePostFlushCb, invalidateJob, nextTick },
  log,
} = require(process.env.BLOG_JS + "/vue/lib.js");

const run = async () => {
  const calls = [];
  const job1 = () => {
    calls.push("job1");
    invalidateJob(job2); // è¿™é‡Œå°† job2 ä» queue[] ä¸­åˆ é™¤äº†
    job2(); // æ³¨é‡Šè¿™ä¸ªç»“æœä¼šæ˜¯ï¼š job1 job3 job4
  };
  const job2 = () => {
    calls.push("job2");
  };
  const job3 = () => {
    calls.push("job3");
  };
  const job4 = () => {
    calls.push("job4");
  };

  queueJob(job1);
  queueJob(job2);
  queueJob(job3);
  queuePostFlushCb(job4);
  await nextTick();
  log.newline(calls);
};
run();
#+end_src

#+RESULTS:
: undefined
:
: job1 job2 job3 job4
** job sort id ä»»åŠ¡å¯ä»¥æ’åº

åªæœ‰ post å’Œ job æ”¯æŒæ’åºã€‚

æµ‹è¯•ï¼š
#+begin_src js
// æºæ–‡ä»¶ï¼š/js/vue/lib.js
const {
  rc: { queueJob, queuePostFlushCb, nextTick },
  log,
} = require(process.env.BLOG_JS + "/vue/lib.js");

const run = async () => {
  const calls = [];
  const job1 = () => calls.push("job1");
  const job2 = () => calls.push("job2");
  const job3 = () => calls.push("job3");
  // job1 no id
  job2.id = 2;
  job3.id = 1;

  const cb1 = () => calls.push("cb1");
  const cb2 = () => calls.push("cb2");
  const cb3 = () => calls.push("cb3");
  cb1.id = 2;
  // cb2 no id
  cb3.id = 1;

  queueJob(job1);
  queueJob(job2);
  queueJob(job3);
  queuePostFlushCb(cb1);
  queuePostFlushCb(cb2);
  queuePostFlushCb(cb3);
  await nextTick();
  log.newline(calls);
};
run();
#+end_src

#+RESULTS:
: undefined
:
: job3 job2 job1 cb3 cb1 cb2
** allowRecurse è‡ªèº«é€’å½’

ç”¨ job.allowRecurse æ¥æ§åˆ¶ job æ˜¯å¦å¯ä»¥è‡ªå·±è§¦å‘è‡ªå·±æ‰§è¡Œ(PS. pre/job/post éƒ½æ”¯æŒ
è¯¥å±æ€§)ã€‚

[[/img/vue3/runtime-core/vue-runtime-core-job-allowRecurse.jpg]]

#+begin_src js
// æºæ–‡ä»¶ï¼š/js/vue/lib.js
const {
  rc: { queueJob, nextTick },
  log,
} = require(process.env.BLOG_JS + "/vue/lib.js");

const run = async () => {
  let count = 0;
  const job = () => {
    if (count < 3) {
      count++;
      queueJob(job);
    }
  };
  queueJob(job);
  queueJob(job);
  await nextTick();
  log.newline("before count: " + count);
  // è®¾ç½® allowRecurse = true å…è®¸è‡ªæˆ‘è°ƒåº¦
  count = 0;
  job.allowRecurse = true;
  // é‡å¤å…¥åˆ—åŒä¸€ä¸ªä»»åŠ¡ä¼šåœ¨ push é˜¶æ®µå°±æ£€æµ‹å’Œè‡ªèº«é€’å½’è°ƒç”¨ä¸åŒ
  queueJob(job);
  queueJob(job);
  await nextTick();
  log.newline("after count: " + count);
};
run();
#+end_src

#+RESULTS:
: undefined
:
: before count: 1
:
:
: after count: 3
** checkRecursiveUpdates

[[https://github.com/gcclll/stb-vue-next/commit/7bcc14b6be11693ddb0cc9d4202727f2ebc83995][feat(add): rc->scheduler->checkRecursiveUpdates Â· gcclll/stb-vue-next@7bcc14b Â·
GitHub]]

é™åˆ¶è°ƒç”¨è‡ªèº«çš„æ¬¡æ•°ï¼Œåœ¨ allowRecurse = true æƒ…å†µä¸‹ä½¿ç”¨ã€‚

#+begin_src js
// æºæ–‡ä»¶ï¼š/js/vue/lib.js
const {
  rc: { queueJob, nextTick },
  log,
} = require(process.env.BLOG_JS + "/vue/lib.js");

const run = async () => {
  let count = 0;
  const job = () => {
    if (count < 101) {
      count++;
      queueJob(job);
    }
  };
  job.allowRecurse = true;
  queueJob(job);
  try {
    await nextTick();
  } catch (e) {
    log.newline(e.message);
  }
};
run();
#+end_src

#+RESULTS:
: undefined
:
: Maximum recursive updates exceeded. This means you have a reactive effect that is mutating its own dependencies and thus recursively triggering itself. Possible sources include component template, render function, updated hook or watcher source function.
** å°ç»“

[[/img/vue3/runtime-core/vue-runtime-core-scheduler-comparation.jpg]]

*pre cbs*: æ‰§è¡Œä¼˜å…ˆçº§æœ€é«˜ï¼Œåœ¨åŒä¸€ tick ä¸­ä¼šé€’å½’è°ƒç”¨è‡ªèº«æ¸…ç©º ~pendingPreFlushCbs~
 ä¸­çš„ä»»åŠ¡ï¼Œåœ¨ ~queueJob~ ä¸­è°ƒç”¨æ—¶ä¸ä¼šè‡ªåŠ¨è§¦å‘éœ€è¦æ‰‹åŠ¨è§¦å‘æ‰§è¡Œï¼Œå› ä¸ºæ­¤æ—¶
 ~isFlushing = true~ ã€‚

*job*: æ‰§è¡Œä¼˜å…ˆçº§æ¬¡ä¹‹ï¼Œåœ¨åŒä¸€ tick ä¸­åŒä¸€ä¸ª for queue -> flushIndex ä¸‹ä¼šå¤„ç†æ­¤
  æ—¶æ¥å—åˆ°çš„æ–°ä»»åŠ¡ï¼Œåœ¨ pre cbs ä¸­è°ƒç”¨æ—¶ä¼šåœ¨æ‰€æœ‰ pre cbs æ‰§è¡Œä¹‹åæ‰§è¡Œã€‚

*post cbs*: æ‰§è¡Œä¼˜å…ˆçº§æœ€ä½ï¼Œåœ¨åŒä¸€ tick åŒä¸€æ¬¡ ~flushPostFlushCbs()~ è°ƒç”¨ä¸­ä¸ä¼š
 å¤„ç†æ–°çš„ post ä»»åŠ¡ï¼Œè€Œæ˜¯åœ¨ ~flushJobs()~ æ‰§è¡Œåˆ°æœ€å finally éƒ¨åˆ†æ£€
 æµ‹ ~pendingPostFlushCbs~ ä»»åŠ¡é˜Ÿåˆ—æ¥å¤„ç†å½“å‰ tick ä¸‹æ–°æ¥å—åˆ°çš„ä»»åŠ¡ï¼Œ
 åœ¨ ~queuePreFlushCb()~ å’Œ ~queueJob()~ ä¸­è°ƒç”¨çš„æ—¶å€™ä¼šåœ¨ä»–ä»¬çš„ä»»åŠ¡ä¹‹åæ‰§è¡Œã€‚
* BUGs fix & Questions

[[https://github.com/gcclll/stb-vue-next/commit/2a1ab0448919ea75c5794410a03265bd99e05d75][fix: no import EMPTY_ARR Â· gcclll/stb-vue-next@2a1ab04 Â· GitHub]]

** nextTick() åé¢çš„ä»£ç æœ€åæ‰§è¡Œï¼Ÿ
:PROPERTIES:
:COLUMNS: %CUSTOM_ID[(Custom Id)]
:CUSTOM_ID: q-nexttick
:END:

æµ‹è¯•ä»£ç ï¼š [[#nexttick][nextTick]]

å…ˆçœ‹ä¸€æ®µä»£ç ï¼Œä»¥åŠ [[https://babeljs.io/repl][babeljs.io]] è½¬æ¢ä¹‹åçš„ç»“æœï¼š

babel ä¹‹å‰ï¼š
#+begin_src js
const run = async () => {
  const p = Promise.resolve().then();

  const p1 = p.then(() => console.log("before await"));
  console.log("between await and p1");
  await p1;
  console.log("after await");
  const p2 = Promise.resolve().then();
  await p2;
  console.log("after p2");
};
run();
#+end_src

babel ä¹‹å(åªè´´å‡ºæ ¸å¿ƒéƒ¨åˆ†)ï¼š
#+begin_src js
while (1) {
  switch ((_context.prev = _context.next)) {
    case 0:
      p = Promise.resolve().then();
      p1 = p.then(function () {
        return console.log("before await");
      });
      console.log("between await and p1");
      _context.next = 5;
      return p1;

    case 5:
      console.log("after await");
      p2 = Promise.resolve().then();
      _context.next = 9;
      return p2;

    case 9:
      console.log("after p2");

    case 10:
    case "end":
      return _context.stop();
  }
}
#+end_src

å³ä¸Šé¢çš„ä»£ç è¢«è½¬æ¢ä¹‹åå˜æˆäº†ä¸€ä¸ª switchï¼Œé‡Œé¢æ˜¯ä¸€ä¸ª while å¾ªç¯ï¼Œå¼‚æ­¥ä»£ç æœ€ç»ˆçš„é¡º
åºæ‰§è¡Œç”± _context.next æ¥è¡”æ¥ã€‚

~case 0~ -> ~next = 5~ -> ~case 5~ -> ~next = 9~ -> ...

æ‰€ä»¥è¯´ nextTick() åé¢çš„ä»£ç éƒ½ä¼šè¢«æ”¾åˆ°å¼‚æ­¥ä»£ç 
* runtime-test æ¨¡å—ç®€ä»‹

è¿™é‡Œæµ‹è¯•éœ€è¦ç”¨åˆ°è¿™ä¸ªæ¨¡å—ï¼Œæ‰€ä»¥ç®€å•ç”¨è„‘å›¾æè¿°ä¸‹è¿™é‡Œé¢æœ‰å“ªäº›ä¸œè¥¿å’Œå¹²ä»€ä¹ˆçš„ã€‚

[[/img/vue3/runtime-core/vue-runtime-test.svg]]

* é‡è¦ç±»å‹å£°æ˜

:PROPERTIES:
:COLUMNS: %CUSTOM_ID[(Custom Id)]
:CUSTOM_ID: defines
:END:
1. å¼‚æ­¥ç»„ä»¶é€‰é¡¹

    #+begin_src typescript
    export interface AsyncComponentOptions<T = any> {
    loader: AsyncComponentLoader<T>
    loadingComponent?: Component
    errorComponent?: Component
    delay?: number
    timeout?: number
    suspensible?: boolean
    onError?: (
        error: Error,
        retry: () => void,
        fail: () => void,
        attempts: number
    ) => any
    }
    #+end_src

2. Vue App ç±»å‹

   #+begin_src typescript
    export interface App<HostElement = any> {
      version: string;
      config: AppConfig;
      use(plugin: Plugin, ...options: any[]): this;
      mixin(mixin: ComponentOptions): this;
      component(name: string): Component | undefined;
      component(name: string, component: Component): this;
      directive(name: string): Directive | undefined;
      directive(name: string, directive: Directive): this;
      mount(
        rootContainer: HostElement | string,
        isHydrate?: boolean
      ): ComponentPublicInstance;
      unmount(rootContainer: HostElement | string): void;
      provide<T>(key: InjectionKey<T> | string, value: T): this;

      // internal, but we need to expose these for the server-renderer and devtools
      _uid: number;
      _component: ConcreteComponent;
      _props: Data | null;
      _container: HostElement | null;
      _context: AppContext;
    }
   #+end_src

   App é…ç½®:

   #+begin_src typescript
    export interface AppConfig {
      // @private
      readonly isNativeTag?: (tag: string) => boolean;

      performance: boolean;
      optionMergeStrategies: Record<string, OptionMergeFunction>;
      globalProperties: Record<string, any>;
      isCustomElement: (tag: string) => boolean;
      errorHandler?: (
        err: unknown,
        instance: ComponentPublicInstance | null,
        info: string
      ) => void;
      warnHandler?: (
        msg: string,
        instance: ComponentPublicInstance | null,
        trace: string
      ) => void;
    }
   #+end_src

   Vue æ’ä»¶ç±»å‹ï¼š

   #+begin_src typescript
    type PluginInstallFunction = (app: App, ...options: any[]) => any;
    export type Plugin =
      | (PluginInstallFunction & { install?: PluginInstallFunction })
      | {
          install: PluginInstallFunction;
        };
   #+end_src

3. api watch ç±»å‹

   #+begin_src typescript
    export interface WatchOptionsBase {
      flush?: "pre" | "post" | "sync";
      onTrack?: ReactiveEffectOptions["onTrack"];
      onTrigger?: ReactiveEffectOptions["onTrigger"];
    }

    export interface WatchOptions<Immediate = boolean> extends WatchOptionsBase {
      immediate?: Immediate;
      deep?: boolean;
    }
   #+end_src

4. component ç»„ä»¶ç±»å‹

   #+begin_src typescript
    // å†…éƒ¨é€‰é¡¹
    export interface ComponentInternalOptions {
      /**
    ,* @internal
    ,*/
      __props?: NormalizedPropsOptions;
      /**
    ,* @internal
    ,*/
      __emits?: ObjectEmitsOptions | null;
      /**
    ,* @internal
    ,*/
      __scopeId?: string;
      /**
    ,* @internal
    ,*/
      __cssModules?: Data;
      /**
    ,* @internal
    ,*/
      __hmrId?: string;
      /**
    ,* This one should be exposed so that devtools can make use of it
    ,*/
      __file?: string;
    }

    // å‡½æ•°å¼ç»„ä»¶
    export interface FunctionalComponent<P = {}, E extends EmitsOptions = {}>
      extends ComponentInternalOptions {
      // use of any here is intentional so it can be a valid JSX Element constructor
      (props: P, ctx: Omit<SetupContext<E>, "expose">): any;
      props?: ComponentPropsOptions<P>;
      emits?: E | (keyof E)[];
      inheritAttrs?: boolean;
      displayName?: string;
    }

    // ç±»ç»„ä»¶
    export interface ClassComponent {
      new (...args: any[]): ComponentPublicInstance<any, any, any, any, any>;
      __vccOpts: ComponentOptions;
    }

    // ç”Ÿå‘½å‘¨æœŸå‡½æ•°ç¼©å†™
    export const enum LifecycleHooks {
      BEFORE_CREATE = "bc",
      CREATED = "c",
      BEFORE_MOUNT = "bm",
      MOUNTED = "m",
      BEFORE_UPDATE = "bu",
      UPDATED = "u",
      BEFORE_UNMOUNT = "bum",
      UNMOUNTED = "um",
      DEACTIVATED = "da",
      ACTIVATED = "a",
      RENDER_TRIGGERED = "rtg",
      RENDER_TRACKED = "rtc",
      ERROR_CAPTURED = "ec",
    }

    // setup å‡½æ•°
    export interface SetupContext<E = EmitsOptions> {
      attrs: Data;
      slots: Slots;
      emit: EmitFn<E>;
      expose: (exposed: Record<string, any>) => void;
    }
   #+end_src

5. component internal instance

   è¿™é‡Œæ¶µç›–äº†ä¸€ä¸ªç»„ä»¶éƒ½æœ‰å“ªäº›å±æ€§ï¼š

   ~uid, type, parent, root, appContext, vnode, next, subTree, update~,

   ~render, ssrRender, provides, effects, accessCache, renderCache~,

   ~components, directives, propsOptions, emitsOptions~,

   ~proxy, exposed, withProxy, ctx~,

   ~data, props, attrs, slots, refs, emit~,

   ~emitted, setupState, devtoolsRawSetupState, setupContext~,

   ~suspense, suspenseId, asyncDep, asyncResolved~,

   ~isMounted, isUnmounted, isDeactivated~,

   ~bc, c, bm, m, bu, u, bum, um, da, a, rtg, rtc, ec~
   #+begin_src typescript
    export const enum LifecycleHooks {
      BEFORE_CREATE = "bc",
      CREATED = "c",
      BEFORE_MOUNT = "bm",
      MOUNTED = "m",
      BEFORE_UPDATE = "bu",
      UPDATED = "u",
      BEFORE_UNMOUNT = "bum",
      UNMOUNTED = "um",
      DEACTIVATED = "da",
      ACTIVATED = "a",
      RENDER_TRIGGERED = "rtg",
      RENDER_TRACKED = "rtc",
      ERROR_CAPTURED = "ec",
    }
   #+end_src

   ç±»å‹ï¼š
   #+begin_src typescript
    /**
     * We expose a subset of properties on the internal instance as they are
     * useful for advanced external libraries and tools.
     */
    export interface ComponentInternalInstance {
      uid: number;
      type: ConcreteComponent;
      parent: ComponentInternalInstance | null;
      root: ComponentInternalInstance;
      appContext: AppContext;
      /**
       * Vnode representing this component in its parent's vdom tree
       */
      vnode: VNode;
      /**
       * The pending new vnode from parent updates
       * @internal
       */
      next: VNode | null;
      /**
       * Root vnode of this component's own vdom tree
       */
      subTree: VNode;
      /**
       * The reactive effect for rendering and patching the component. Callable.
       */
      update: ReactiveEffect;
      /**
       * The render function that returns vdom tree.
       * @internal
       */
      render: InternalRenderFunction | null;
      /**
       * SSR render function
       * @internal
       */
      ssrRender?: Function | null;
      /**
       * Object containing values this component provides for its descendents
       * @internal
       */
      provides: Data;
      /**
       * Tracking reactive effects (e.g. watchers) associated with this component
       * so that they can be automatically stopped on component unmount
       * @internal
       */
      effects: ReactiveEffect[] | null;
      /**
       * cache for proxy access type to avoid hasOwnProperty calls
       * @internal
       */
      accessCache: Data | null;
      /**
       * cache for render function values that rely on _ctx but won't need updates
       * after initialized (e.g. inline handlers)
       * @internal
       */
      renderCache: (Function | VNode)[];

      /**
       * Resolved component registry, only for components with mixins or extends
       * @internal
       */
      components: Record<string, ConcreteComponent> | null;
      /**
       * Resolved directive registry, only for components with mixins or extends
       * @internal
       */
      directives: Record<string, Directive> | null;
      /**
       * reoslved props options
       * @internal
       */
      propsOptions: NormalizedPropsOptions;
      /**
       * resolved emits options
       * @internal
       */
      emitsOptions: ObjectEmitsOptions | null;

      // the rest are only for stateful components ---------------------------------

      // main proxy that serves as the public instance (`this`)
      proxy: ComponentPublicInstance | null;

      // exposed properties via expose()
      exposed: Record<string, any> | null;

      /**
       * alternative proxy used only for runtime-compiled render functions using
       * `with` block
       * @internal
       */
      withProxy: ComponentPublicInstance | null;
      /**
       * This is the target for the public instance proxy. It also holds properties
       * injected by user options (computed, methods etc.) and user-attached
       * custom properties (via `this.x = ...`)
       * @internal
       */
      ctx: Data;

      // state
      data: Data;
      props: Data;
      attrs: Data;
      slots: InternalSlots;
      refs: Data;
      emit: EmitFn;
      /**
       * used for keeping track of .once event handlers on components
       * @internal
       */
      emitted: Record<string, boolean> | null;

      /**
       * setup related
       * @internal
       */
      setupState: Data;
      /**
       * devtools access to additional info
       * @internal
       */
      devtoolsRawSetupState?: any;
      /**
       * @internal
       */
      setupContext: SetupContext | null;

      /**
       * suspense related
       * @internal
       */
      suspense: SuspenseBoundary | null;
      /**
       * suspense pending batch id
       * @internal
       */
      suspenseId: number;
      /**
       * @internal
       */
      asyncDep: Promise<any> | null;
      /**
       * @internal
       */
      asyncResolved: boolean;

      // lifecycle
      isMounted: boolean;
      isUnmounted: boolean;
      isDeactivated: boolean;
      /**
       * @internal
       */
      [LifecycleHooks.BEFORE_CREATE]: LifecycleHook;
      /**
       * @internal
       */
      [LifecycleHooks.CREATED]: LifecycleHook;
      /**
       * @internal
       */
      [LifecycleHooks.BEFORE_MOUNT]: LifecycleHook;
      /**
       * @internal
       */
      [LifecycleHooks.MOUNTED]: LifecycleHook;
      /**
       * @internal
       */
      [LifecycleHooks.BEFORE_UPDATE]: LifecycleHook;
      /**
       * @internal
       */
      [LifecycleHooks.UPDATED]: LifecycleHook;
      /**
       * @internal
       */
      [LifecycleHooks.BEFORE_UNMOUNT]: LifecycleHook;
      /**
       * @internal
       */
      [LifecycleHooks.UNMOUNTED]: LifecycleHook;
      /**
       * @internal
       */
      [LifecycleHooks.RENDER_TRACKED]: LifecycleHook;
      /**
       * @internal
       */
      [LifecycleHooks.RENDER_TRIGGERED]: LifecycleHook;
      /**
       * @internal
       */
      [LifecycleHooks.ACTIVATED]: LifecycleHook;
      /**
       * @internal
       */
      [LifecycleHooks.DEACTIVATED]: LifecycleHook;
      /**
       * @internal
       */
      [LifecycleHooks.ERROR_CAPTURED]: LifecycleHook;
    }
   #+end_src

6. emit fn äº‹ä»¶

   #+begin_src typescript
    export type EmitFn<
      Options = ObjectEmitsOptions,
      Event extends keyof Options = keyof Options
    > = Options extends Array<infer V>
      ? (event: V, ...args: any[]) => void
      : {} extends Options // if the emit is empty object (usually the default value for emit) should be converted to function
      ? (event: string, ...args: any[]) => void
      : UnionToIntersection<
          {
            [key in Event]: Options[key] extends (...args: infer Args) => any
              ? (event: key, ...args: Args) => void
              : (event: key, ...args: any[]) => void;
          }[Event]
        >;
   #+end_src
