#+TITLE: Vue3 æºç å¤´è„‘é£æš´ä¹‹ 7 â˜ runtime-core(1)
#+DATE: <2021-01-08 10:12:32>
#+TAGS[]: vue, vue3, runtime-core
#+CATEGORIES[]: vue
#+LANGUAGE: zh-cn
#+STARTUP: indent shrink


#+begin_export html
<link href="https://fonts.goo~gleapis.com/cs~s2?family=ZCOOL+XiaoWei&display=swap" rel="stylesheet">
<kbd>
<font color="blue" size="3" style="font-family: 'ZCOOL XiaoWei', serif;">
  è¯—å·ï¼šå…­é“åŒå ï¼Œé­”åŠ«ä¸‡åƒï¼Œå¼•æ¸¡å¦‚æ¥ã€‚
</font>
</kbd><br><br>
#+end_export

[[/img/bdx/yiyeshu-001.jpg]]

@@html:<kbd>@@
*[[https://github.com/gcclll/stb-vue-next][stb-vue-next]] å®Œå…¨æ‹·è´äº [[https://github.com/vuejs/vue-next][vue-next]] ï¼Œä¸»è¦ç›®çš„ç”¨äºå­¦ä¹ ã€‚*
@@html:</kbd>@@

#+begin_quote
*å£°æ˜* ï¼švue-next runtime-core è¿è¡Œæ—¶æ ¸å¿ƒä»£ç ï¼Œè¿™éƒ¨åˆ†å†…å®¹è¾ƒå¤šï¼Œå¯èƒ½ä¼šåˆ†ä¸ºå‡ ç¯‡æ¥
å™è¿°, ~f~ è¿‡æ»¤æ‰å¯¹è±¡ç©ºå€¼å±æ€§ã€‚

*æ›´æ–°æ—¥å¿—&Todos* ï¼š
1. [2021-01-08 10:12:50] åˆ›å»º
2. TODO STATEFUL_COMONENT
3. TODO patchFlag æµ‹è¯•å’Œç”¨é€”
4. TODO transformVNodeArgs
5. TODO Suspense ç»„ä»¶
6. TODO shouldTrack, currentBlock å’Œ [[#block-related][block ç›¸å…³å‡½æ•°]]çš„ä½œç”¨
#+end_quote

æ¨¡å—åˆå§‹åŒ–ï¼š [[https://github.com/gcclll/stb-vue-next/commit/b22b4db3506bf1ba4b266dcf9ff21f1e0b925a81][feat(init): runtime-core Â· gcclll/stb-vue-next@b22b4db Â· GitHub]]

[[/img/vue3/runtime-core/vue-runtime-core.svg]]

* Tips
1. class æ”¯æŒæ•°ç»„(~['foo', 'bar']~)ï¼Œå¯¹è±¡(~{foo:true,bar:false}~)ï¼Œå­—ç¬¦ä¸²(~'foo bar'~)
2. style æ”¯æŒæ•°ç»„(~['color:red', {foo:'foo'}]~)ï¼Œå¯¹è±¡(~{color:'red',foo:'foo'}~)ï¼Œå­—ç¬¦ä¸²(~color:red~)
3. class component æ¡ä»¶ï¼š 1) function 2) å« ~__vccOpts = { template: '<div />'}~
4. vnode ref å±æ€§å¤„ç†é€»è¾‘ [[#test-vnode-ref][é“¾æ¥-->]]
5. vnode key å±æ€§ä¸ºç®€å•çš„å€¼è¦†ç›–æ“ä½œ [[#test-vnode-key][é“¾æ¥-->]]
* init

å¯¼å‡ºå·²å®Œæˆæ¨¡å—(reactiviy)é‡Œçš„ Apis:
[[https://github.com/gcclll/stb-vue-next/commit/38e91a877635b51b56a2918ff173a48638b8760a][feat(init): runtime-core> add exports from @vue/reactivity Â· gcclll/stb-vue-next@38e91a8 Â· GitHub]]

è¿™éƒ¨åˆ†ä»£ç æœ‰ç‚¹å¤šï¼Œæ‰€ä»¥è¿™é‡Œäº‹å…ˆå°†æ‰€æœ‰ç±»å‹å®šä¹‰æ·»åŠ å¥½ï¼š

[[https://github.com/gcclll/stb-vue-next/commit/e3f7b94ef39cf389aaf25f55ea81877941860f56][feat(add): runtime-core>all types Â· gcclll/stb-vue-next@e3f7b94 Â· GitHub]]

æœ‰å…³ç±»å‹å®šä¹‰è¯·ç§»æ­¥[[#defines][æœ€åä¸€èŠ‚]](çº¯è´´ä»£ç çš„ï¼Œæ‰€ä»¥æ”¾åˆ°æœ€å)
* h function

[[https://github.com/gcclll/stb-vue-next/commit/e48d5e28c4e1b55c6d6a326bcf0808047e23ceeb][feat(add): runtime-core>h function Â· gcclll/stb-vue-next@e48d5e2 Â· GitHub]]

~h~, render å‡½æ•°åˆå§‹åŒ–ã€‚

#+begin_src typescript
// Actual implementation
export function h(type: any, propsOrChildgen?: any, children?: any): VNode {
  // TODO
  return {} as VNode;
}
#+end_src

å®ç°ï¼š
#+begin_src typescript
// Actual implementation
export function h(type: any, propsOrChildgen?: any, children?: any): VNode {
  const l = arguments.length;
  if (l === 2) {
    if (isObject(propsOrChildgen) && !isArray(propsOrChildgen)) {
      // æ²¡æœ‰ props çš„ å•èŠ‚ç‚¹(single vnode)
      if (isVNode(propsOrChildgen)) {
        return createVNode(type, null, [propsOrChildgen]);
      }
      // æœ‰ props æ²¡æœ‰ children
      return createVNode(type, propsOrChildgen);
    } else {
      // omit props
      return createVNode(type, null, propsOrChildgen);
    }
  } else {
    // ä»ç¬¬ä¸‰ä¸ªå‚æ•°å¼€å§‹å…¨å½“åšå­©å­èŠ‚ç‚¹å¤„ç†
    if (l > 3) {
      children = Array.prototype.slice.call(arguments, 2);
    } else if (l === 3 && isVNode(children)) {
      children = [children];
    }
    return createVNode(type, propsOrChildgen, children);
  }
}
#+end_src

h, æ¥å—ä¸å®šå‚æ•°

é€»è¾‘è„‘å›¾:

[[http://qiniu.ii6g.com/img/20210108152508.png]]

ä»è„‘å›¾åˆ†æ”¯å¾—å‡ºæ”¯æŒçš„æƒ…å†µä»£ç ç¤ºä¾‹ï¼š

1. ~h('div')~ æ— å‚æ•°æ— å­©å­
2. ~h('div', { id: 'foo' })~ æœ‰ props æ—  children
3. ~h('div', ['foo'])~ æ•°ç»„å½“åš chilren
4. ~h('div', vnode)~ æœ‰ __v_isVNode æ ‡è¯†å½“åš childrenï¼Œå¹¶è½¬æˆæ•°ç»„ ~[vnode]~
5. ~h('div', {}, ['foo'])~ æœ‰ props æœ‰ children
6. ~h('div', {}, vnode)~ æœ‰ props, æœ‰ children ä¸” = ~[vnode]~

æ¥ä¸‹æ¥éœ€è¦å…·ä½“å»å®ç° ~createVNode~ å‡½æ•°ã€‚
* createVNode function

[[https://github.com/gcclll/stb-vue-next/commit/194f72fee239da947ef82a4da099c23c758d3d84][feat(add): rc->createVNode Â· gcclll/stb-vue-next@194f72f Â· GitHub]]

è¿™ä¸ªå‡½æ•°æœ€ç»ˆæ˜¯æ„é€ äº† vnode: VNode è™šæ‹ŸèŠ‚ç‚¹ç»“æ„ï¼Œè¿”å›ã€‚

è¿™é‡Œé¢åˆ†ä¸ºä»¥ä¸‹å‡ ä¸ªæ­¥éª¤å®ç°ï¼š

1. type æ˜¯ vnode æ—¶å€™å¤„ç†
2. class ç»„ä»¶å¤„ç†
3. props å¤„ç†
4. shapeFlag æ£€æµ‹ï¼Œæ˜¯ä»€ä¹ˆç±»å‹ çš„ vnode
5. ç»„ä»¶å¯¹è±¡ä¸åº”è¯¥ reactive(æœ‰çŠ¶æ€çš„ç»„ä»¶, STATEFUL_COMONENT)
6. æ„å»º vnode: VNode å¯¹è±¡
7. æ£€æµ‹ vnode.key æ˜¯ä¸æ˜¯ ~NaN~
8. normalize children
9. normalize suspense children
10. currentBlock å¤„ç†
11. è¿”å› vnode èŠ‚ç‚¹

#+begin_src js
// æºæ–‡ä»¶ï¼š/js/vue/lib.js
const {
  rc: { h, createVNode, reactive },
  f,
  log,
} = require(process.env.BLOG_JS + "/vue/lib.js");
const _h = (...args) => f(h(...args));

log([">>> type only\n", _h("div")]);
log([">>> type + props\n", _h("div", { id: "foo" })]);
log([">>> type + omit props\n", _h("div", ["foo"])]);
#+end_src

#+RESULTS:
#+begin_example
>>> type only
 { __v_isVNode: true, __v_skip: true, type: 'div', shapeFlag: 1 }
>>> type + props
 {
  __v_isVNode: true,
  __v_skip: true,
  type: 'div',
  props: { id: 'foo' },
  shapeFlag: 1
}
>>> type + omit props
 { __v_isVNode: true, __v_skip: true, type: 'div', shapeFlag: 1 }
>>> default slot
 {
  __v_isVNode: true,
  __v_skip: true,
  type: { template: '<br />' },
  shapeFlag: 4
}
undefined
#+end_example

** d3c6563 props

[[https://github.com/gcclll/stb-vue-next/commit/d3c656331e3e5a9206f0341dd2ca960a300f96ba][feat(add): rc->createVNode, props Â· gcclll/stb-vue-next@d3c6563 Â· GitHub]]

å¤„ç† class å’Œ style å±æ€§ã€‚

#+begin_src typescript
 // 3. props å¤„ç†, class & style normalization
 if (props) {
   // for reactive or proxy objects, we need to clone it to enable mutation.
   if (isProxy(props) || InternalObjectKey in props) {
     props = extend({}, props);
   }
   let { class: klass, style } = props;
   if (klass && !isString(klass)) {
     // 1. string -> klass
     // 'foo' -> 'foo'
     // 2. array -> '' + arr.join(' ')
     // ['foo', 'bar'] -> 'foo bar'
     // 3. object -> '' + value ? ' value' : ''
     // { foo: true, bar: false, baz: true } -> 'foo baz'
     props.class = normalizeClass(klass);
   }

   if (isObject(style)) {
     // reactive state objects need to be cloned since they are likely to be
     // mutated
     if (isProxy(style) && !isArray(style)) {
       style = extend({}, style);
     }
     // 1. array -> object
     // [{ color: 'red' }, 'font-size:10px;height:100px;'] ->
     // { color: 'red', 'font-size': '10px', height: '100px' }
     // 2. object -> object åŸæ ·è¿”å›
     props.style = normalizeStyle(style);
   }
 }
#+end_src

1. class æ•°ç»„ï¼Œå¯¹è±¡ï¼Œå­—ç¬¦ä¸²ï¼Ÿ

   æ•°ç»„ï¼š åˆå¹¶æˆå­—ç¬¦ä¸²ï¼Œ ~['foo', 'bar']~ -> 'foo bar'

   å¯¹è±¡ï¼š åˆå¹¶æˆå­—ç¬¦ä¸²ï¼Œ ~{foo: true, bar: false, baz: true}~ -> 'foo baz'

   å­—ç¬¦ä¸²ï¼š åŸæ ·è¾“å‡º

   #+begin_src typescript
   export function normalizeClass(value: unknown): string {
     let res = "";
     if (isString(value)) {
       res = value;
     } else if (isArray(value)) {
       for (let i = 0; i < value.length; i++) {
         res += normalizeClass(value[i]) + " ";
       }
     } else if (isObject(value)) {
       for (const name in value) {
         if (value[name]) {
           res += name + " ";
         }
       }
     }
     return res.trim();
   }
   #+end_src

2. style æ•°ç»„ï¼Œå¯¹è±¡ï¼Œå­—ç¬¦ä¸²ï¼Ÿ

   æ•°ç»„ï¼š åˆå¹¶æˆå¯¹è±¡ï¼Œ ~['color:red', { 'font-size': '10px', height: '100px' }]~ -> ~{color:
   'red', 'font-size': '10px', height: '100px'}~

   å¯¹è±¡ï¼š åŸæ ·è¿”å›

   å­—ç¬¦ä¸²ï¼šè§£ææˆå¯¹è±¡ï¼Œ å¦‚æ•°ç»„å†…å­—ç¬¦ä¸²éƒ¨åˆ†

   #+begin_src typescript
    export function normalizeStyle(value: unknown): NormalizedStyle | undefined {
      if (isArray(value)) {
        const res: Record<string, string | number> = {};
        for (let i = 0; i < value.length; i++) {
          const item = value[i];
          const normalized = normalizeStyle(
            isString(item) ? parseStringStyle(item) : item
          );
          if (normalized) {
            for (const key in normalized) {
              res[key] = normalized[key];
            }
          }
        }
        return res;
      } else if (isObject(value)) {
        return value;
      }
    }
   #+end_src


æµ‹è¯•ï¼š

#+begin_src js

// æºæ–‡ä»¶ï¼š/js/vue/lib.js
const { rc: { h, createVNode: c }, f, log } = require(process.env.BLOG_JS + '/vue/lib.js')
let _h = (...args) => f(c(...args), 'props')

// class åˆå¹¶æˆå­—ç¬¦ä¸²
log(['>>> class: string\n', _h('p', { class: 'foo baz' })])
log(['>>> class: array\n', _h('p', { class: ['foo', 'baz'] })])
log(['>>> class: array<object|string>\n', _h('p', { class: [{ foo:  'foo' }, 'baz', { baz: 'baz' }] })])
log(['>>> class: object\n', _h('p', { class: {'foo': true, 'baz': false, 'bar': true} })])

// style åˆå¹¶æˆå¯¹è±¡
log(['>>> style: array\n', _h('p', { style: [{ foo: 'foo' }, { baz: 'baz' }] })])
log(['>>> style: object\n', _h('p', {
  style: { foo: 'foo', baz: 'baz' }
})])
log(['>>> style: array<object|string>\n', _h('p', {
  style: [{ foo: 'foo' }, 'color:red', { baz: 'baz' }]
})])
#+end_src

#+RESULTS:
#+begin_example
>>> class: string
 { props: { class: 'foo baz' } }
>>> class: array
 { props: { class: 'foo baz' } }
>>> class: array<object|string>
 { props: { class: 'foo baz baz' } }
>>> class: object
 { props: { class: 'foo bar' } }
>>> style: array
 { props: { style: { foo: 'foo', baz: 'baz' } } }
>>> style: object
 { props: { style: { foo: 'foo', baz: 'baz' } } }
>>> style: array<object|string>
 { props: { style: { foo: 'foo', color: 'red', baz: 'baz' } } }
undefined
#+end_example
** class component

æ˜¯ç±»ç»„ä»¶å‰ææ˜¯ï¼š

1. å¿…é¡»æ˜¯å‡½æ•°
2. å¿…é¡»åŒ…å« ~__vccOpts~ å±æ€§

#+begin_src typescript
  // 2. class component
  if (isClassComponent(type)) {
    type = type.__vccOpts;
  }

  export function isClassComponent(value: unknown): value is ClassComponent {
    return isFunction(value) && "__vccOpts" in value;
  }
#+end_src

æµ‹è¯•ï¼š
#+begin_src js

// æºæ–‡ä»¶ï¼š/js/vue/lib.js
const { rc: { h, createVNode: c }, f, log } = require(process.env.BLOG_JS + '/vue/lib.js')
const _h = (...args) => f(c(...args))

class Component {
  $props

  static __vccOpts = { template: '<div />' }
}
log(_h(Component))
#+end_src

#+RESULTS:
: {
:   __v_isVNode: true,
:   __v_skip: true,
:   type: { template: '<div />' },
:   shapeFlag: 4 // STATEFUL_COMPONENT
: }
: undefined

** TODO stateful component & key NaN

æœ‰çŠ¶æ€çš„ç»„ä»¶ï¼Ÿ

å³ type ä¸ºå¯¹è±¡æ—¶å€™è§†ä¸ºæœ‰çŠ¶æ€çš„ç»„ä»¶ã€‚

å¦‚æœæ˜¯ STATEFUL_COMPONENT ä¸”æ˜¯ä¸ª proxy çš„æ—¶å€™ï¼Œå¼€å‘æ¨¡å¼ä¸‹ç»™å‡ºè­¦å‘Šâš ï¸ã€‚

#+begin_src js

// æºæ–‡ä»¶ï¼š/js/vue/lib.js
const { rc: { h, createVNode: c, reactive:r }, f, log } = require(process.env.BLOG_JS + '/vue/lib.js')
const _h = (...args) => f(c(...args))

log(_h('div', { key: NaN }))
#+end_src

#+RESULTS:
: {
:   __v_isVNode: true,
:   __v_skip: true,
:   type: 'div',
:   props: { key: NaN },
:   shapeFlag: 1
: }
: undefined

** 88eaf09 type is vnode

[[https://github.com/gcclll/stb-vue-next/commit/88eaf090c3d1767bc4a1ca576eef449abf7d62d2][feat(add): rc->createVNode, type is vnode Â· gcclll/stb-vue-next@88eaf09 Â· GitHub]]

#+begin_src typescript
  // > in createVNode
  // 1. type is vnode
  if (isVNode(type)) {
    // createVNode receiving an existing vnode. This happens in cases like
    // <component :is="vnode"/>
    // #2078 make sure to merge refs during the clone instead of overwriting it
    const cloned = cloneVNode(type, props, true /* mergeRef: true */);
    if (children) {
      normalizeChildren(cloned, children);
    }
    return cloned;
  }

  // cloneVNode
  // çœç•¥ç›´æ¥å– vnode å€¼éƒ¨åˆ†
  export function cloneVNode<T, U>(
    vnode: VNode<T, U>,
    extraProps?: (Data & VNodeProps) | null,
    mergeRef = false
  ): VNode<T, U> {
    // This is intentionally NOT using spread or extend to avoid the runtime
    // key enumeration cost.
    const { props, ref, patchFlag } = vnode;
    const mergedProps = extraProps ? mergeProps(props || {}, extraProps) : props;
    return {
      __v_isVNode: true,
      [ReactiveFlags.SKIP]: true,
      type: vnode.type,
      props: mergedProps,
      key: mergedProps && normalizeKey(mergedProps),
      ref:
        extraProps && extraProps.ref
          ? // #2078 in the case of <component :is="vnode" ref="extra"/>
            // if the vnode itself already has a ref, cloneVNode will need to merge
            // the refs so the single vnode can be set on multiple refs
            mergeRef && ref
            ? isArray(ref)
              ? ref.concat(normalizeRef(extraProps)!)
              : [ref, normalizeRef(extraProps)!]
            : normalizeRef(extraProps)
          : ref,
      // if the vnode is cloned with extra props, we can no longer assume its
      // existing patch flag to be reliable and need to add the FULL_PROPS flag.
      // note: perserve flag for fragments since they use the flag for children
      // fast paths only.
      patchFlag:
        extraProps && vnode.type !== Fragment
          ? patchFlag === -1 // hoisted node
            ? PatchFlags.FULL_PROPS
            : patchFlag | PatchFlags.FULL_PROPS
          : patchFlag,

      ssContent: vnode.ssContent && cloneVNode(vnode.ssContent),
      ssFallback: vnode.ssFallback && cloneVNode(vnode.ssFallback),
    };
  }
#+end_src

cloneVNode ç»å¤§éƒ¨åˆ†å±æ€§éƒ½æ˜¯ç›´æ¥å¼•ç”¨è‡ª vnodeï¼Œä¸Šé¢åˆ—å‡ºçš„éƒ½æ˜¯éœ€è¦å¤„ç†çš„å±æ€§ï¼Œæ¯”å¦‚ï¼š

1. props ä¼šå°† vnode å’Œ cloneVNode ä¼ å…¥çš„ props è¿›è¡Œåˆå¹¶ï¼Œå¹¶ä¸”æ˜¯ä¼ å…¥çš„ props è¦†ç›– vnode.propsã€‚
2. key å±æ€§ï¼Œå–åˆå¹¶ä¹‹åçš„ key([[#test-vnode-key][æµ‹è¯•->]])

   #+begin_src typescript
    // normalize åˆå¹¶åçš„ key
    const key = mergedProps && normalizeKey(mergedProps);

    const normalizeKey = ({ key }: VNodeProps): VNode["key"] =>
      key != null ? key : null;
   #+end_src
3. ref å±æ€§ï¼Œåˆå¹¶è§„åˆ™([[#test-vnode-ref][æµ‹è¯•->]])ï¼š

   #+begin_src typescript
    // 1. mergeRef: boolean å¯ä»¥æ‰‹åŠ¨æŒ‡å®šæ˜¯å¦éœ€è¦åˆå¹¶
    // 2. extraProps.ref è°ƒç”¨ cloneVNode æ—¶å€™ä¼ å…¥çš„ props ref
    // 3. ref å¦‚æœæ˜¯æ•°ç»„ï¼ŒåŠ ä¸Šæ–°çš„ ref æ‰©å±•åŸæ•°ç»„
    // 4. ref ä¸æ˜¯æ•°ç»„ï¼Œç”¨ ref å’Œ extra ref åˆå¹¶æˆæ–°æ•°ç»„
    // 5. å¦‚æœ ref null, åˆ™ç›´æ¥ç”¨ extra ref normalize å‡ºæ–°çš„ ref
    const ref =
      extraProps && extraProps.ref
        ? // #2078 in the case of <component :is="vnode" ref="extra"/>
          // if the vnode itself already has a ref, cloneVNode will need to merge
          // the refs so the single vnode can be set on multiple refs
          mergeRef && ref
          ? isArray(ref)
            ? ref.concat(normalizeRef(extraProps)!)
            : [ref, normalizeRef(extraProps)!]
          : normalizeRef(extraProps)
        : ref;

    // normalization
    const normalizeRef = ({ ref }: VNodeProps): VNodeNormalizedRefAtom | null => {
      return (ref != null
        ? isString(ref) || isRef(ref) || isFunction(ref)
          ? { i: currentRenderingInstance, r: ref }
          : ref
        : null) as any;
    };
   #+end_src
4. patchFlag å±æ€§([[#test-vnode-patchflag][æµ‹è¯•->]])

   #+begin_src typescript
    const patchFlag =
      extraProps && vnode.type !== Fragment
        ? patchFlag === -1 // hoisted node
          ? PatchFlags.FULL_PROPS
          : patchFlag | PatchFlags.FULL_PROPS
        : patchFlag;
   #+end_src
5. ssContent é€’å½’è°ƒç”¨ ~cloneVNode(vnode.ssContent)~
6. ssFallback é€’å½’è°ƒç”¨ ~cloneVNode(vnode.ssFallback)~


æµ‹è¯•ï¼š
#+begin_src js
// æºæ–‡ä»¶ï¼š/js/vue/lib.js
const {
  rc: { h, createVNode: c, cloneVNode: cv },
  f,
  log,
} = require(process.env.BLOG_JS + "/vue/lib.js");
const _h = (...args) => f(c(...args));

const node1 = _h("div", { foo: 1 }, null /* children */);
log([">>> vnode 1\n", node1]);

const node2 = _h({}, null, [node1]);
const cloned2 = cv(node2);
// cloneVNode åªæ˜¯ä¸€æ¬¡æµ…æ‹·è´
log([">>> node2 == cloned2\n", f(cloned2), "\n > node2 \n", node2]);
#+end_src

#+RESULTS:
#+begin_example
>>> vnode 1
 {
  __v_isVNode: true,
  __v_skip: true,
  type: 'div',
  props: { foo: 1 },
  shapeFlag: 1
}
>>> node2 == cloned2
 {
  __v_isVNode: true,
  __v_skip: true,
  type: {},
  children: [
    {
      __v_isVNode: true,
      __v_skip: true,
      type: 'div',
      props: [Object],
      shapeFlag: 1
    }
  ],
  shapeFlag: 20
}
 > node2
 {
  __v_isVNode: true,
  __v_skip: true,
  type: {},
  children: [
    {
      __v_isVNode: true,
      __v_skip: true,
      type: 'div',
      props: [Object],
      shapeFlag: 1
    }
  ],
  shapeFlag: 20
}
undefined
#+end_example

[[https://github.com/gcclll/stb-vue-next/commit/4fbd98f4be00f3fdfcb14839d29ed4a5f45a179c][feat(add): rc->createVNode, currentRenderingInstance Â· gcclll/stb-vue-next@4fbd98f Â· GitHub]]

*** key test
:PROPERTIES:
:COLUMNS: %CUSTOM_ID[(Custom Id)]
:CUSTOM_ID: test-vnode-key
:END:

vnode.key çš„ clone æ“ä½œï¼Œå±äºå•çº¯çš„å€¼è¦†ç›–æ“ä½œã€‚

#+begin_src js
// æºæ–‡ä»¶ï¼š/js/vue/lib.js
const {
  rc: { h, createVNode: c, cloneVNode: cv },
  f,
  log,
} = require(process.env.BLOG_JS + "/vue/lib.js");
const _h = (...args) => f(c(...args));

log([">>> ä¿ç•™ vnode.key å€¼\n", f(cv(c("div", { key: 1 })), "key")]);
log([
  ">>> æ›¿æ¢ vnode.key å€¼\n",
  f(cv(c("div", { key: 1 }), { key: 2 }), "key"),
]);
log([">>> æ–° props.key å€¼\n", f(cv(c("div"), { key: 2 }), "key")]);

log(">>> æµ‹è¯• vnode.key å„ç§æƒ…å†µå€¼");
for (const key of ["", "a", 0, 1, NaN]) {
  log(f(c("div", { key }), "key"));
}
#+end_src

#+RESULTS:
#+begin_example
>>> ä¿ç•™ vnode.key å€¼
 { key: 1 }
>>> æ›¿æ¢ vnode.key å€¼
 { key: 2 }
>>> æ–° props.key å€¼
 { key: 2 }
>>> æµ‹è¯• vnode.key å„ç§æƒ…å†µå€¼
{}
{ key: 'a' }
{}
{ key: 1 }
[Vue warn]: VNode created with invalid key (NaN). VNode type:div
{}
undefined
#+end_example

*** ref test
:PROPERTIES:
:COLUMNS: %CUSTOM_ID[(Custom Id)]
:CUSTOM_ID: test-vnode-ref
:END:

æµç¨‹è„‘å›¾ï¼š
[[/img/vue3/runtime-core/vue-runtime-core-vnode-ref.svg]]

æµ‹è¯•
#+begin_src js
// æºæ–‡ä»¶ï¼š/js/vue/lib.js
const {
  rc: {
    h,
    createVNode: c,
    cloneVNode: cv,
    ssrUtils: { setCurrentRenderingInstance: s },
  },
  f,
  log,
} = require(process.env.BLOG_JS + "/vue/lib.js");
const _h = (...args) => f(c(...args));

const mockIns1 = { ins: 1 },
  mockIns2 = { ins: 2 };
s(mockIns1);

let original = c("div", { ref: "foo" });
// æœ¬èº«æ²¡æœ‰çš„æ—¶å€™ä¼šå°† extraProps.ref ä½œä¸ºæ–°çš„ vnode.ref å€¼
log([">>> 1. vnode æœ¬èº«æ—  ref\n", f(original, "ref")]);
let cloned1 = cv(original);
log([">>> 2. ä¿ç•™åŸæœ‰çš„ vnode.ref\n", f(cloned1, "ref")]);
// è¿™é‡Œæ²¡æŒ‡å®š mergeProp æ‰€ä»¥ä¼šæ›¿æ¢åŸæ¥çš„
let cloned2 = cv(original, { ref: "bar" });
log(['>>> 3. ref: "bar" æ›¿æ¢åŸæœ‰çš„ vnode.ref\n', f(cloned2, "ref")]);
let original2 = c("div");
let cloned3 = cv(original2, { ref: "bar" });
log([">>> 4. æ²¡æœ‰ vnode.ref æƒ…å†µï¼Œæ–°å¢ ref\n", f(cloned3, "ref")]);

s(mockIns2);
// åº”è¯¥ä¿ç•™åŸæœ‰çš„ context instance
let cloned4 = cv(original);
log([">>> 5. åº”è¯¥ä¿ç•™åŸæœ‰çš„ context instance\n", f(cloned4, "ref")]);
// ref è¦†ç›–ï¼Œä½¿ç”¨æ–°çš„ context instance: mockIns2
let cloned5 = cv(original, { ref: "bar" });
log([">>> 6. ref æ”¹å˜ï¼Œä½¿ç”¨æ–°çš„ context instance\n", f(cloned5, "ref")]);
s(null); // ç½®ç©º context instance

log('\n\n// mergeRef æƒ…å†µæµ‹è¯•\n')
s(mockIns1)
original = c('div', { ref: 'foo' })
s(mockIns2)
cloned1 = cv(original, { ref: 'bar' }, true)
log(['>>> mergeRef: true åˆå¹¶ vnode.ref\n', f(cloned1, 'ref')])
log(cloned1.ref[0])
log(cloned1.ref[1])
#+end_src

#+RESULTS:
#+begin_example
>>> 1. vnode æœ¬èº«æ—  ref
 { ref: { i: { ins: 1 }, r: 'foo' } }
>>> 2. ä¿ç•™åŸæœ‰çš„ vnode.ref
 { ref: { i: { ins: 1 }, r: 'foo' } }
>>> 3. ref: "bar" æ›¿æ¢åŸæœ‰çš„ vnode.ref
 { ref: { i: { ins: 1 }, r: 'bar' } }
>>> 4. æ²¡æœ‰ vnode.ref æƒ…å†µï¼Œæ–°å¢ ref
 { ref: { i: { ins: 1 }, r: 'bar' } }
>>> 5. åº”è¯¥ä¿ç•™åŸæœ‰çš„ context instance
 { ref: { i: { ins: 1 }, r: 'foo' } }
>>> 6. ref æ”¹å˜ï¼Œä½¿ç”¨æ–°çš„ context instance
 { ref: { i: { ins: 2 }, r: 'bar' } }


// mergeRef æƒ…å†µæµ‹è¯•

>>> mergeRef: true åˆå¹¶ vnode.ref
 { ref: [ { i: [Object], r: 'foo' }, { i: [Object], r: 'bar' } ] }
{ i: { ins: 1 }, r: 'foo' }
{ i: { ins: 2 }, r: 'bar' }
undefined
#+end_example
*** TODO patchFlag test
:PROPERTIES:
:COLUMNS: %CUSTOM_ID[(Custom Id)]
:CUSTOM_ID: test-vnode-patchflag
:END:

TODO need openBlock&createBlock support.

#+begin_src js
// æºæ–‡ä»¶ï¼š/js/vue/lib.js
const {
  rc: {
    h,
    createVNode: c,
    cloneVNode: cv,
    ssrUtils: { setCurrentRenderingInstance: s },
  },
  f,
  log,
} = require(process.env.BLOG_JS + "/vue/lib.js");
const _h = (...args) => f(c(...args));

const hoist = c('div') // é™æ€èŠ‚ç‚¹
let vnode1
const vnode = (openBlock(), createBlock('div'))
#+end_src
*** shapeFlag test

#+begin_src js
// æºæ–‡ä»¶ï¼š/js/vue/lib.js
const {
  rc: { h, createVNode: c, cloneVNode: cv, Text },
  f,
  log,
} = require(process.env.BLOG_JS + "/vue/lib.js");
const _h = (...args) => f(c(...args));

log([">>> ELEMENT\n", f(c("div"), "shapeFlag")]);
log([">>> STATEFUL_COMONENT\n", f(c({}), "shapeFlag")]);
log([
  ">>> FUNCTION_COMONENT\n",
  f(
    c(() => {}),
    "shapeFlag"
  ),
]);
log([">>> Text\n", f(c(Text), "shapeFlag")]);
#+end_src

#+RESULTS:
: >>> ELEMENT
:  { shapeFlag: 1 }
: >>> STATEFUL_COMONENT
:  { shapeFlag: 4 }
: >>> FUNCTION_COMONENT
:  { shapeFlag: 2 }
: >>> Text
:  { shapeFlag: 0 }
: undefined
*** mergeProps test

#+begin_src js
// æºæ–‡ä»¶ï¼š/js/vue/lib.js
const {
  rc: { h, createVNode: c, cloneVNode: cv, Text, mergeProps },
  f,
  log,
} = require(process.env.BLOG_JS + "/vue/lib.js");

let p1 = { class: "c" };
let p2 = { class: ["cc"] };
let p3 = { class: [{ ccc: true }] };
let p4 = { class: { cccc: true } };
log([">>> merge class\n", mergeProps(p1, p2, p3, p4)]);
let ps1 = {
  style: { color: "red", fontSize: 10 },
};
let ps2 = {
  style: [
    { color: "blue", width: "200px" },
    {
      width: "300px",
      height: "300px",
      fontSize: 30,
    },
  ],
};
let ps3 = { style: 'width:100px;right:10;top:10' }
log([">>> merge style\n", mergeProps(ps1, ps2, ps3)]);
let clickHandler1  = function(){}
let clickHandler2  = function(){}
let focusHandler3  = function(){}
let ph1 = { onClick: clickHandler1 }
let ph2 = { onClick: clickHandler2, onFocus: focusHandler3 }
log(['>>> merge handlers\n', mergeProps(ph1, ph2)])
#+end_src

#+RESULTS:
#+begin_example
>>> merge class
 { class: 'c cc ccc cccc' }
>>> merge style
 {
  style: {
    color: 'blue',
    fontSize: 30,
    width: '100px',
    height: '300px',
    right: '10',
    top: '10'
  }
}
>>> merge handlers
 {
  onClick: [ [Function: clickHandler1], [Function: clickHandler2] ],
  onFocus: [Function: focusHandler3]
}
undefined
#+end_example
*** TODO dynamic children test

> need openBlock&createBlock support

#+begin_src js
const {
  rc: { h, createVNode: c, cloneVNode: cv, Text, mergeProps },
  f,
  log,
} = require(process.env.BLOG_JS + "/vue/lib.js");

const hoist = createVNode('div')
let vnode1
#+end_src
*** TODO transformVNodeArgs test
** TODO 7ec1d30 suspense component

[[https://github.com/gcclll/stb-vue-next/commit/7ec1d3053a5881d476e535923edce07f36fe77f0][feat(add): rc->createVNode, type is suspense component Â· gcclll/stb-vue-next@7ec1d30 Â· GitHub]]

Suspense çš„ children å¿…é¡»æœ‰ä¸”åªæœ‰ä¸€ä¸ªæ ¹èŠ‚ç‚¹ã€‚

#+begin_src typescript
  // 7. normalize suspense children
  if (__FEATURE_SUSPENSE__ && shapeFlag & ShapeFlags.SUSPENSE) {
    const { content, fallback } = normalizeSuspenseChildren(vnode);
    vnode.ssContent = content;
    vnode.ssFallback = fallback;
  }

  // normalizeSuspenseChildren
  export function normalizeSuspenseChildren(
    vnode: VNode
  ): {
    content: VNode;
    fallback: VNode;
  } {
    const { shapeFlag, children } = vnode;
    let content: VNode, fallback: VNode;

    if (shapeFlag & ShapeFlags.SLOTS_CHILDREN) {
      content = normalizeSuspenseSlot((children as Slots).default);
      fallback = normalizeSuspenseSlot((children as Slots).fallback);
    } else {
      content = normalizeSuspenseSlot(children as VNodeChild);
      fallback = normalizeVNode(null);
    }

    return {
      content,
      fallback,
    };
  }

// >>> normalizeSuspenseSlot
function normalizeSuspenseSlot(s: any) {
  if (isFunction(s)) {
    s = s()
  }
  if (isArray(s)) {
    // ROOT å¿…é¡»æ˜¯å•èŠ‚ç‚¹ <div>...</div>
    const singleChild = filterSingleRoot(s)
    if (__DEV__ && !singleChild) {
      warn(`<Suspense> slots expect a single root node.`)
    }
    s = singleChild
  }
  return normalizeVNode(s)
}

// normalizeVNode
export function normalizeVNode(child: VNodeChild): VNode {
  if (child == null || typeof child === 'boolean') {
    // empty placeholder
    return createVNode(Comment)
  } else if (isArray(child)) {
    // fragment
    return createVNode(Fragment, null, child)
  } else if (typeof child === 'object') {
    // already vnode, this should be the most common since compiled templates
    // always produce all-vnode children arrays
    // è¿™æ˜¯æœ€å¸¸ç”¨çš„æƒ…å†µï¼Œå› ä¸ºä½¿ç”¨æ¨¡æ¿çš„æ—¶å€™æœ€åç”Ÿæˆçš„ children æ˜¯æ•°ç»„
    return child.el === null ? child : cloneVNode(child)
  } else {
    // strings and numbers
    return createVNode(Text, null, String(child))
  }
}
#+end_src

æ£€æµ‹æ˜¯ä¸æ˜¯ single root å‡½æ•°ï¼š ~filterSingleRoot~
#+begin_src typescript
export function filterSingleRoot(
  children: VNodeArrayChildren
): VNode | undefined {
  let singleRoot;
  for (let i = 0; i < children.length; i++) {
    const child = children[i];
    if (isVNode(child)) {
      // ignore user comment
      if (child.type !== Comment || child.children === "v-if") {
        if (singleRoot) {
          // has more than 1 non-comment child, return now

          return;
        } else {
          singleRoot = child;
        }
      }
    } else {
      return;
    }
  }
  return singleRoot;
}
#+end_src
** TODO 23fc943 currentBlock ä¼˜åŒ–
:PROPERTIES:
:COLUMNS: %CUSTOM_ID[(Custom Id)]
:CUSTOM_ID: vnode-currentBlock
:END:

[[https://github.com/gcclll/stb-vue-next/commit/23fc9437e9fba7bb562f79a51410ef59e6b82f8c][feat(add): rc->createVNode, optimize diff, currentBlock Â·
gcclll/stb-vue-next@23fc943 Â· GitHub]]

#+begin_quote
è¿™é‡Œçš„å¤„ç†æ²¡æ€ä¹ˆææ˜ç™½â“
#+end_quote

æ³¨æ„è¿™é‡Œå¢åŠ çš„å‡ ä¸ªå˜é‡â€¼

blockStack, currentBlock:
#+begin_src typescript

// Since v-if and v-for are the two possible ways node structure can dynamically
// change, once we consider v-if branches and each v-for fragment a block, we
// can divide a template into nested blocks, and within each block the node
// structure would be stable. This allows us to skip most children diffing
// and only worry about the dynamic nodes (indicated by patch flags).
// é’ˆå¯¹ v-if, v-for åŠ¨æ€æ€§åšçš„ç”±äºï¼Œå‡å°‘å¯¹é™æ€èŠ‚ç‚¹çš„ diff ï¼Œåªéœ€è¦å…³å¿ƒåŠ¨æ€èŠ‚ç‚¹å³å¯
export const blockStack: (VNode[] | null)[] = []
let currentBlock: VNode[] | null = null
#+end_src

shouldTrack:
#+begin_src typescript
// Whether we should be tracking dynamic child nodes inside a block.
// Only tracks when this value is > 0
// We are not using a simple boolean because this value may need to be
// incremented/decremented by nested usage of v-once (see below)
// æ˜¯å¦åº”è¯¥ tracking block å†…åŠ¨æ€çš„å­©å­èŠ‚ç‚¹
let shouldTrack = 1;
#+end_src

æ–°å¢å¤„ç†é€»è¾‘ï¼š
#+begin_src typescript
 // 8. currentBlock
 if (
   shouldTrack > 0 &&
   // é¿å… block èŠ‚ç‚¹ tracking è‡ªå·±
   !isBlockNode &&
   // has current parent block
   currentBlock &&
   // presence of a patch flag indicates this node needs patching on updates.
   // component nodes also should always be patched, because even if the
   // component doesn't need to update, it needs to persist the instance on to
   // the next vnode so that it can be properly unmounted later.
   (patchFlag > 0 || shapeFlag & ShapeFlags.COMPONENT) &&
   // the EVENTS flag is only for hydration and if it is the only flag, the
   // vnode should not be considered dynamic due to handler caching.
   patchFlag !== PatchFlags.HYDRATE_EVENTS
 ) {
   currentBlock.push(vnode);
 }
#+end_src

è·Ÿè¿™å‡ ä¸ªå˜é‡æœ‰å…³çš„å‡½æ•°ï¼š
* TODO block related(open/close/create)
:PROPERTIES:
:COLUMNS: %CUSTOM_ID[(Custom Id)]
:CUSTOM_ID: block-related
:END:

[[https://github.com/gcclll/stb-vue-next/commit/a2afc70cc89fc0bb7c1b1f6810bea73ab4e40c82][feat(add): rc->block related, open/create/closeBlock Â· gcclll/stb-vue-next@a2afc70 Â· GitHub]]

è¿™é‡Œçš„æ‰€æœ‰å‡½æ•°éƒ½å’Œ [[#vnode-currentBlock][createVNode é‡Œé¢çš„ currentBlock]] æœ‰å…³ã€‚

openBlock:
#+begin_src typescript
/**
 ,* Open a block.
 ,* This must be called before `createBlock`. It cannot be part of `createBlock`
 ,* because the children of the block are evaluated before `createBlock` itself
 ,* is called. The generated code typically looks like this:
 ,*
 ,* ```js
 ,* function render() {
 ,*   return (openBlock(),createBlock('div', null, [...]))
 ,* }
 ,* ```
 ,* disableTracking is true when creating a v-for fragment block, since a v-for
 ,* fragment always diffs its children.
 ,*
 ,* @private
 ,*/
export function openBlock(disableTracking = false) {
  blockStack.push((currentBlock = disableTracking ? null : []));
}
#+end_src

closeBlock:
#+begin_src typescript
export function closeBlock() {
  blockStack.pop();
  currentBlock = blockStack[blockStack.length - 1] || null;
}
#+end_src

setBlockTracking:
#+begin_src typescript
/**
 * Block tracking sometimes needs to be disabled, for example during the
 * creation of a tree that needs to be cached by v-once. The compiler generates
 * code like this:
 *
 * ``` js
 * _cache[1] || (
 *   setBlockTracking(-1),
 *   _cache[1] = createVNode(...),
 *   setBlockTracking(1),
 *   _cache[1]
 * )
 * ```
 *
 * @private
 */
export function setBlockTracking(value: number) {
  shouldTrack += value
}
#+end_src

createBlock:
#+begin_src typescript
/**
 * Create a block root vnode. Takes the same exact arguments as `createVNode`.
 * A block root keeps track of dynamic nodes within the block in the
 * `dynamicChildren` array.
 *
 * @private
 */
export function createBlock(
  type: VNodeTypes | ClassComponent,
  props?: Record<string, any> | null,
  children?: any,
  patchFlag?: number,
  dynamicProps?: string[]
): VNode {
  const vnode = createVNode(
    type,
    props,
    children,
    patchFlag,
    dynamicProps,
    true /* isBlock: prevent a block from tracking itself */
  );
  // save current block children on the block vnode
  vnode.dynamicChildren = currentBlock || (EMPTY_ARR as any);
  // close block
  closeBlock();
  // a block is always going to be patched, so track it as a child of its
  // parent block
  if (shouldTrack > 0 && currentBlock) {
    currentBlock.push(vnode);
  }
  return vnode;
}
#+end_src

ç›¸å…³è„‘å›¾ï¼š
[[/img/vue3/runtime-core/vue-runtime-core-block-shouldtrack.svg]]

* normalizeChildren function

shapeFlag åˆå§‹å€¼æ£€æµ‹ï¼š
#+begin_src typescript
// encode the vnode type information into a bitmap
const shapeFlag = isString(type)
  ? ShapeFlags.ELEMENT // 1
  : __FEATURE_SUSPENSE__ && isSuspense(type)
  ? ShapeFlags.SUSPENSE // 1 << 7, 128
  : isTeleport(type)
  ? ShapeFlags.TELEPORT // 1 << 6, 64
  : isObject(type)
  ? ShapeFlags.STATEFUL_COMPONENT // 1 << 2, 4
  : isFunction(type)
  ? ShapeFlags.FUNCTIONAL_COMPONENT // 1 << 1, 2
  : 0;
#+end_src

æµ‹è¯•:
#+begin_src js
// æºæ–‡ä»¶ï¼š/js/vue/lib.js
const { rc: { h, createVNode: c }, f, log } = require(process.env.BLOG_JS + '/vue/lib.js')
const _h = (...args) => f(c(...args))

log(['>>> only tag\n', _h('p')])
log(['>>> tag + props\n', _h('p', { foo: 'foo' })])
log(['>>> tag + props + children\n', _h('p', { foo: 'foo' }, ['foo'])])
#+end_src

#+RESULTS:
#+begin_example
>>> only tag
 { __v_isVNode: true, __v_skip: true, type: 'p', shapeFlag: 1 }
>>> tag + props
 {
  __v_isVNode: true,
  __v_skip: true,
  type: 'p',
  props: { foo: 'foo' },
  shapeFlag: 1
}
>>> tag + props + children
 {
  __v_isVNode: true,
  __v_skip: true,
  type: 'p',
  props: { foo: 'foo' },
  children: [ 'foo' ],
  shapeFlag: 17
}
undefined
#+end_example

** children is function

[[https://github.com/gcclll/stb-vue-next/commit/28d4a55250c6f02264bbb77ca04a87770d358c7c][feat(add): rc->propsOrChildren is function Â· gcclll/stb-vue-next@28d4a55 Â· GitHub]]

å¦‚æœæ˜¯å‡½æ•°ï¼Œå½“åš slot çš„ children å¤„ç†ã€‚

normalizeChildren:
#+begin_src typescript
export function normalizeChildren(vnode: VNode, children: unknown) {
  let type = 0
  if (children == null) {
    children = null
  } else if (false /*array*/) {
    // TODO
  } else if (false /*object*/) {
    // TODO
  } else if (isFunction(children)) {
    // å¦‚æœæ˜¯å‡½æ•°å½“åš slot children ?
    children = { default: children, _ctx: currentRenderingInstance }
    type = ShapeFlags.SLOTS_CHILDREN
  } else {
    // TODO æ™®é€šç±»å‹
  }

  vnode.children = children as VNodeNormalizedChildren
  vnode.shapeFlag |= type
}
#+end_src

æµ‹è¯•ï¼š
#+begin_src js

// æºæ–‡ä»¶ï¼š/js/vue/lib.js
const { rc: { h, createVNode:c }, log, f } = require(process.env.BLOG_JS + '/vue/lib.js')
const _h = (...args) => f(h(...args));
const _c = (...args) => f(c(...args));

const Component = { template: '<br />' }
const slot = () => {}
log(['>>> default slot\n', _h(Component, slot)])
log(['>>> children is function\n', _c('div', {}, slot)])
#+end_src

#+RESULTS:
#+begin_example
>>> default slot
 {
  __v_isVNode: true,
  __v_skip: true,
  type: { template: '<br />' },
  children: { default: [Function: slot], _ctx: null },
  shapeFlag: 36
}
>>> children is function
 {
  __v_isVNode: true,
  __v_skip: true,
  type: 'div',
  props: {},
  children: { default: [Function: slot], _ctx: null },
  shapeFlag: 33
}
undefined
#+end_example
** children is array or æ™®é€šç±»å‹

[[https://github.com/gcclll/stb-vue-next/commit/850c0bc0d8b74e1b88d2158df505c83cb9a71408][feat(add): rc->createVNode, children is array or primitive Â·
gcclll/stb-vue-next@850c0bc Â· GitHub]]

#+begin_src typescript
// æ•°ç»„ç±»å‹
if (isArray(children)) {
  type = ShapeFlags.ARRAY_CHILDREN;
}

// éå¯¹è±¡ï¼Œæ•°ç»„ï¼Œå‡½æ•°çš„æ™®é€šç±»å‹å¤„ç†
{
  children = String(children);
  // force teleport children to array so it can be moved around
  if (shapeFlag & ShapeFlags.TELEPORT) {
    type = ShapeFlags.ARRAY_CHILDREN;
    children = [createTextVNode(children as string)];
  } else {
    type = ShapeFlags.TEXT_CHILDREN;
  }
}

// createTextVNode
export function createTextVNode(text: string = " ", flag: number = 0): VNode {
  return createVNode(Text, null, text, flag);
}

export const Text = Symbol(__DEV__ ? 'Text' : undefined)
#+end_src

æ™®é€šç±»å‹å¤„ç†ä¸­å¦‚æœæ˜¯ ~ShapeFlags.TELETPORT~ å½“åš ~ARRAY_CHILDREN~ å¤„ç†ï¼Œä¸”
children æŒ‰ç…§æ–‡æœ¬èŠ‚ç‚¹å¤„ç†ã€‚

#+begin_src js
const {
  rc: { h, createVNode: c },
  f,
  log,
} = require(process.env.BLOG_JS + "/vue/lib.js");
const _h = (...args) => f(h(...args));
const _c = (...args) => f(c(...args));

log([`>>> array will be children(${1 | (1 << 4)})\n`, _h("div", ["foo"])]);
log([">>> string will be children()\n", _h("div", "foo")]);
#+end_src

#+RESULTS:
#+begin_example
>>> array will be children(17)
 {
  __v_isVNode: true,
  __v_skip: true,
  type: 'div',
  children: [ 'foo' ],
  shapeFlag: 17
}
>>> string will be children()
 {
  __v_isVNode: true,
  __v_skip: true,
  type: 'div',
  children: 'foo',
  shapeFlag: 9
}
undefined
#+end_example
** children is object

[[https://github.com/gcclll/stb-vue-next/commit/959879e825fb225b39c7fb219ec7e46feb6c7537][feat(add): rc->createVNode, normalizeChildren is object Â· gcclll/stb-vue-next@959879e Â· GitHub]]

shapeFlag å¯èƒ½æ˜¯ ~ShapeFlags.ELEMENT~ æˆ–è€… ~ShapeFalgs.TELEPORT~ ã€‚

è¿™é‡Œå…ˆæµ‹è¯• ELEMENT æƒ…å†µï¼Œå› ä¸º TELEPORT è¿˜éœ€è¦å®ç° components/Teleport ã€‚

å¦‚æœ type æ˜¯ å¯¹è±¡ï¼Œ shapeFlag åˆå§‹ç±»å‹ä¼šæ˜¯ ~ShapeFlags.STATEFULL_COMPONENT, 1 <<
2~

#+begin_src js
// æºæ–‡ä»¶ï¼š/js/vue/lib.js
const {
  rc: { h, createVNode: c },
  f,
  log,
} = require(process.env.BLOG_JS + "/vue/lib.js");
const _h = (...args) => f(c(...args));

// å› ä¸º type = {} , shapeFlag = 1 << 2, 4
// æ‰€ä»¥åœ¨ normalizeChildren é‡Œé¢ isObject åˆ†æ”¯ä¼šè¿›å…¥ else
// è¿›è¡Œå¤„ç†ï¼Œç»è¿‡å¤„ç†ä¹‹åæˆä¸º 4 | SLOTS_CHILDREN,2<<5,32 = 36
log([">>> object\n", _h({}, null, { foo: "foo" })]);
#+end_src

#+RESULTS:
: >>> object
:  {
:   __v_isVNode: true,
:   __v_skip: true,
:   type: {},
:   children: { foo: 'foo', _ctx: null },
:   shapeFlag: 36
: }
: undefined
* api watch

[[https://github.com/gcclll/stb-vue-next/commit/c41441a1c53b5059410c32d36e46e21e7258480c][feat(add): rc->api watch Â· gcclll/stb-vue-next@c41441a Â· GitHub]]

[[https://github.com/gcclll/stb-vue-next/commit/8c41f0f03b6f00fa88dad3389621ec089f3b6eb5][feat(add): rc->api watch -> watchEffect Â· gcclll/stb-vue-next@8c41f0f Â· GitHub]]

~watch(source, cb, options)~ å‡½æ•°ä»¥ä¸‹ç§ä½¿ç”¨æ–¹å¼ï¼š

1. ~sources + cb~ æ–¹å¼ï¼Œå¤šä¸ªè¢«ç›‘å¬å¯¹è±¡ï¼ŒæŒ‡å®šå›è°ƒ
2. ~watch([foo, bar] as const, () => {})~
3. single source + cb
4. watch reactive object

æ‰§è¡Œå…·ä½“å®ç°çš„å‡½æ•°ï¼š ~doWatch()~

| Arg      | value                                           | description    |
|----------+-------------------------------------------------+----------------|
| source   | WatchSource, WatchSource[], WatchEffect, object | object watched |
| cb       | WatchCallback or null                           | callback       |
|----------+-------------------------------------------------+----------------|
| options  | WatchOptions = EMPTY_OBJ                        |                |
|          | immediate                                       |                |
|          | deep                                            |                |
|          | flush                                           |                |
|          | onTrack                                         |                |
|          | onTrigger                                       |                |
|----------+-------------------------------------------------+----------------|
| instance | currentInstance                                 | -              |
|          |                                                 |                |

#+begin_quote
~watch(source, cb, options?)~ å‡½æ•°ä¸­çš„ cb æ˜¯å¿…é€‰é¡¹ï¼Œå¦‚æœæƒ³ç›´æ¥ watch effectï¼Œå¯ä½¿
ç”¨ ~watchEffect(fn, options?)~ api ã€‚
#+end_quote

å¤„ç†æ­¥éª¤ï¼š

1. æ£€æµ‹è·å– getter å‡½æ•°å’Œ forceTrigger æ ‡è¯†

   #+begin_src typescript
   let getter: () => any;
   let forceTrigger = false;
   if (isRef(source)) {
     getter = () => (source as Ref).value;
     forceTrigger = !!(source as Ref)._shallow;
   } else if (isReactive(source)) {
     getter = () => source;
     deep = true;
   } else if (isArray(source)) {
     getter = () =>
       source.map((s) => {
         if (isRef(s)) {
           return s.value;
         } else if (isReactive(s)) {
           return traverse(s);
         } else if (isFunction(s)) {
           return callWithErrorHandling(s, instance, ErrorCodes.WATCH_GETTER);
         } else {
           __DEV__ && warnInvalidSource(s);
         }
       });
   } else if (isFunction(source)) {
     if (cb) {
       // getter with cb
       getter = () =>
         callWithErrorHandling(source, instance, ErrorCodes.WATCH_GETTER);
     } else {
       // no cb -> simple effect
       getter = () => {
         if (instance && instance.isUnmounted) {
           return;
         }
         if (cleanup) {
           cleanup();
         }
         return callWithErrorHandling(
           source,
           instance,
           ErrorCodes.WATCH_CALLBACK,
           [onInvalidate]
         );
       };
     }
   } else {
     getter = NOOP;
     __DEV__ && warnInvalidSource(source);
   }
   #+end_src
2. cb && deep æ£€æµ‹æ˜¯å¦æ‰§è¡Œæ·±åº¦ç›‘å¬ï¼Œè°ƒç”¨ traverse(baseGetter) éå†æ·±åº¦ç›‘å¬

   #+begin_src typescript
   if (cb && deep) {
     const baseGetter = getter;
     getter = () => traverse(baseGetter());
   }
   #+end_src
3. scheduler job -> set scheduler æ‰‹åŠ¨è§¦å‘ effect

   #+begin_src typescript
    let oldValue = isArray(source) ? [] : INITIAL_WATCHER_VALUE;
    const job: SchedulerJob = () => {
      if (!runner.active) {
        return;
      }
      if (cb) {
        // watch(source, cb)
        const newValue = runner();
        if (deep || forceTrigger || hasChanged(newValue, oldValue)) {
          // cleanup before running cb again
          if (cleanup) {
            cleanup();
          }
          callWithAsyncErrorHandling(cb, instance, ErrorCodes.WATCH_CALLBACK, [
            newValue,
            // pass undefined as the old value when it's changed for the first time
            oldValue === INITIAL_WATCHER_VALUE ? undefined : oldValue,
            onInvalidate,
          ]);
          oldValue = newValue;
        }
      } else {
        // watchEffect
        runner();
      }
    };

    // important: mark the job as a watcher callback so that scheduler knows
    // it is allowed to self-trigger (#1727)
    job.allowRecurse = !!cb;

    let scheduler: ReactiveEffectOptions["scheduler"];
    if (flush === "sync") {
      scheduler = job;
    } else if (flush === "post") {
      scheduler = () => queuePostRenderEffect(job, instance && instance.suspense);
    } else {
      // default: 'pre'
      scheduler = () => {
        if (!instance || instance.isMounted) {
          queuePreFlushCb(job);
        } else {
          // with 'pre' option, the first call must happen before
          // the component is mounted so it is called synchronously.
          job();
        }
      };
    }
   #+end_src
4. runner = effect(getter, ...) å°è£… getter å‡½æ•°ï¼Œå¾…æ‰§è¡Œï¼Œè¿™é‡Œä½¿ç”¨äº† lazy:true
   ï¼Œæ‰€ä»¥ä¸ä¼šç«‹å³æ‰§è¡Œ

   ~{lazy: true, onTrack, onTrigger, scheduler}~

   #+begin_src typescript
   const runner = effect(getter, {
     lazy: true,
     onTrack,
     onTrigger,
     scheduler,
   });
   #+end_src
5. record instance bound effect -> runner -> instance

   å…¶å®å°±æ˜¯è®² effect å¢åŠ åˆ° instance.effects[] ä¸­ã€‚

   #+begin_src typescript
   // record effects created during a component's setup() so that they can be
   // stopped when the component unmounts
   // è®°å½•åœ¨ç»„ä»¶ setup() æœŸé—´ç»‘å®šäº†å“ªäº› effectsï¼Œæ–¹ä¾¿å½“ç»„ä»¶å¸è½½çš„æ—¶å€™å»åœæ‰ä»–ä»¬
   export function recordInstanceBoundEffect(
     effect: ReactiveEffect,
     instance = currentInstance
   ) {
     if (instance) {
       (instance.effects || (instance.effects = [])).push(effect);
     }
   }
   #+end_src
6. ä»¥ä»€ä¹ˆæ–¹å¼æ‰§è¡Œ runner ?

   #+begin_src typescript
   // initial run
   if (cb) {
     if (immediate) {
       job();
     } else {
       oldValue = runner();
     }
   } else if (flush === "post") {
     queuePostRenderEffect(runner, instance && instance.suspense);
   } else {
     runner();
   }
   #+end_src
7. è¿”å› stop runner å‡½æ•°

   #+begin_src typescript
   return () => {
    stop(runner)
    if (instance) {
      remove(instance.effects!, runner)
    }
  }
   #+end_src


#+begin_src js
// æºæ–‡ä»¶ï¼š/js/vue/lib.js
const {
  rc: { h, createVNode: c, reactive, watchEffect, nextTick },
  f,
  log,
} = require(process.env.BLOG_JS + "/vue/lib.js");
const _h = (...args) => f(h(...args));

const state = reactive({ count: 0 });
let dummy;
const res = watchEffect(() => {
console.log('xx')
  dummy = state.count;
});
log(`before update, dummy = ${dummy}`);
state.count++;
log(`after update, dummy = ${dummy}`);
#+end_src

#+RESULTS:
: before update, dummy = undefined
: after update, dummy = undefined
: undefined

æµ‹è¯•å¤±è´¥ï¼Œå› ä¸º ~watchEffect(fn)~ ç­‰ä»·äº ~watch(fn, null, options)~

è¿›å…¥ getter å¤„ç†æ­¥éª¤çš„ isFunction-> else
#+begin_src typescript
if (isFunction(source)) {
  if (cb) {
    // getter with cb
    getter = () =>
      callWithErrorHandling(source, instance, ErrorCodes.WATCH_GETTER);
  } else {
    // no cb -> simple effect
    getter = () => {
      // TODO
    };
  }
}
#+end_src

ç„¶å else å¹¶æ²¡æœ‰å®ç°ï¼Œæ‰€æœ‰ getter èµ‹å€¼äº†ä¸€ä¸ªç©ºå‡½æ•°ã€‚

** watch effect without cb
:PROPERTIES:
:COLUMNS: %CUSTOM_ID[(Custom Id)]
:CUSTOM_ID: watch-no-cb
:END:

å¢åŠ ç›¸å…³ä»£ç 
[[https://github.com/gcclll/stb-vue-next/commit/dd4224046bc99fd60e1ef4a467d95f98ffeb912e][feat(add): rc->api watchEffect->source is fn & cb is null Â· gcclll/stb-vue-next@dd42240 Â· GitHub]]
åç»§ç»­æµ‹è¯•ï¼š
#+begin_src js
// æºæ–‡ä»¶ï¼š/js/vue/lib.js
const {
  rc: { h, createVNode: c, reactive, watchEffect, nextTick },
  f,
  log,
} = require(process.env.BLOG_JS + "/vue/lib.js");
const _h = (...args) => f(h(...args));

const state = reactive({ count: 0 });
let dummy;
const res = watchEffect(() => {
  dummy = state.count;
});
log(`before update, dummy = ${dummy}`);
state.count++;
log(`after update, dummy = ${dummy}`);
#+end_src

#+RESULTS:
: before update, dummy = 0
: after update, dummy = 1
: undefined

ç»“æœæ­£å¸¸ã€‚
** watch single source: getter

source å€¼ä¸ºä¸€ä¸ªå•çº¯çš„å‡½æ•°ï¼Œæ­£å¥½å’Œ [[#watch-no-cb][watch effect without cb]] ç›¸åï¼Œä¼šè¿›å…¥
isFunction>if å¤„ç†ã€‚

#+begin_src js
// æºæ–‡ä»¶ï¼š/js/vue/lib.js
const {
  rc: { h, createVNode: c, reactive, watch },
  f,
  log,
} = require(process.env.BLOG_JS + "/vue/lib.js");

const state = reactive({ count: 0 });
let dummy;
watch(
  () => state.count,
  (count, prevCount) => {
    dummy = [count, prevCount];
    count + 1;
    if (prevCount) {
      prevCount + 1;
    }
  }
);
state.count++;
log(dummy);
#+end_src

#+RESULTS:
: undefined
: undefined

ç»“æœä¸º ~undefined~ åˆå¤±è´¥äº†ï¼ŒğŸ˜­

å¾ˆæ˜æ˜¾ä¼šæ‰§è¡Œä¸‹é¢çš„ä»£ç ï¼š
#+begin_src typescript
if (cb) {
  // getter with cb
  getter = () =>
    callWithErrorHandling(source, instance, ErrorCodes.WATCH_GETTER);
}
#+end_src
ä½†è¿™æ®µä»£ç è²Œä¼¼å’Œ cb æ²¡ä»»ä½•å…³ç³»å•Šï¼Œæ€ä¹ˆå®ç°å’Œ cb ç»‘å®šçš„å‘¢ï¼Ÿï¼Ÿï¼Ÿ

#+begin_quote
åœ¨ [[/vue/vue-mind-map-house-reactivity/#r-trigger][reactivity trigger]] ä¸­åˆ†æè¿‡ï¼Œ effect fn çš„æ‰§è¡Œå‰ææ˜¯æ²¡æœ‰æä¾› scheduler é€‰é¡¹ï¼Œå¦‚æœæœ‰å‘¢ï¼Ÿ
#+end_quote

ç›´æ¥ä¸Šä»£ç ï¼š
#+begin_src typescript
  const run = (effect: ReactiveEffect) => {
    if (__DEV__ && effect.options.onTrigger) {
      effect.options.onTrigger({
        effect,
        target,
        key,
        type,
        newValue,
        oldValue,
        oldTarget,
      });
    }

    if (effect.options.scheduler) {
      effect.options.scheduler(effect);
    } else {
      effect();
    }
  };
#+end_src

å¦‚ä¸Šé¢çš„ effect è¢«å°è£…æˆ run ï¼Œé‡Œé¢å°±æœ‰æ£€æµ‹æ˜¯ä¸æ˜¯æœ‰ scheduler ï¼

å› æ­¤æˆ‘ä»¬å¯ä»¥çŒœæƒ³ è¿™ä¸ª cb è‚¯å®šæ˜¯é€šè¿‡è¿™ä¸ª options.scheduler æ¥è°ƒç”¨å’Œ source å‘ç”Ÿå…³
ç³»çš„ã€‚

æ·»åŠ ä»£ç 
[[https://github.com/gcclll/stb-vue-next/commit/6766eb9066052a3608d892f3e9853627e3623043][feat(add): rc->api watch->queue scheduler for default:pre Â· gcclll/stb-vue-next@6766eb9 Â· GitHub]]
ä¹‹åï¼Œæµ‹è¯•ä»£ç è€ƒä¸‹æ¥åœ¨æµ‹è¯•éï¼š
#+begin_src js
// æºæ–‡ä»¶ï¼š/js/vue/lib.js
const {
  rc: { h, createVNode: c, reactive, watch, nextTick },
  f,
  log,
} = require(process.env.BLOG_JS + "/vue/lib.js");

const run = async () => {
  const state = reactive({ count: 0 });
  let dummy;
  watch(
    () => state.count,
    (count, prevCount) => {
      dummy = [count, prevCount];
      count + 1;
      if (prevCount) {
        prevCount + 1;
      }
    }
  );
  state.count++;
  await nextTick();
  log(["\n", dummy]);
};

run();
#+end_src

#+RESULTS:
: undefined
:  [ 1, 0 ]


ç»“æœå°±å¯¹äº†ï¼

#+begin_quote
Tip. ç„¶åï¼Œ[[https://github.com/gcclll/stb-vue-next/commit/6766eb9066052a3608d892f3e9853627e3623043][è¿™é‡Œ]]å¢åŠ çš„ä»£ç å…¨åœ¨ scheduler.ts ä¸­ï¼Œè¿™é‡Œé¢éƒ½æ˜¯ vue-next é‡Œé¢å…³äº effect
trigger ä»»ä½•çš„è°ƒåº¦æœºåˆ¶ï¼Œéœ€è¦å½»åº•å¼„æ‡‚è¿™ä¸€å—ï¼Œæ‰€ä»¥è¿™é‡Œå…ˆæš‚åœä¸€ä¼šï¼Œå…ˆå®Œæˆ [[#scheduler][scheduler
ä»»åŠ¡è°ƒåº¦æœºåˆ¶]] å†å›é¡¾å¤´æ¥ç»§ç»­ã€‚
#+end_quote

* scheduler ä»»åŠ¡è°ƒåº¦æœºåˆ¶
:PROPERTIES:
:COLUMNS: %CUSTOM_ID[(Custom Id)]
:CUSTOM_ID: scheduler
:END:

è®©æˆ‘ä»¬è·Ÿç€ ~scheduler.spec.ts~ æµ‹è¯•ç”¨ä¾‹æ¥é€æ­¥å±æ€§ scheduler çš„è°ƒåº¦æœºåˆ¶ã€‚

åœ¨åšè¿™ä¸ªä¹‹å‰å…ˆæŠŠ scheduler.ts ä¸­é€»è¾‘ä»£ç å…¨æ¸…ç©ºï¼Œè¿™ä¸ªæ–‡ä»¶è¿˜æ˜¯ç›¸å¯¹ç‹¬ç«‹çš„

[[https://github.com/gcclll/stb-vue-next/commit/a54cc00ee93057839de620a152ca1fe691671f63][feat: rc->reset scheduler.ts Â· gcclll/stb-vue-next@a54cc00 Â· GitHub]]

æˆ‘ä»¬ä»é›¶å¼€å§‹ä¸€æ­¥æ­¥æ¥åˆ†æå®ç°ã€‚

[[/img/vue3/runtime-core/vue-runtime-core-scheduler.svg]]

è¿™éƒ¨åˆ†åŒ…å«ä¸‰ç§ä»»åŠ¡çš„ flush é€»è¾‘ä»£ç ï¼š

1. queue jobs -> ~flushIndex~ -> ~queue[]~ -> ~queueJob()~ -> ~queueFlush()~ -> ~flushJobs()~
2. pre jobs -> ~preFlushIndex~ -> ~pendingPreFlushCbs[]~ -> ~activePreFlushCbs[]~ ->
   ~queuePreFlushCb()~ -> ~flushPreFlushCbs()~ -> ~flushJobs()~
3. TODO post jobs -> ...
** nextTick
:PROPERTIES:
:COLUMNS: %CUSTOM_ID[(Custom Id)]
:CUSTOM_ID: nexttick
:END:

[[https://github.com/gcclll/stb-vue-next/commit/32b482762b074d3123906887df35231efea7dcc7][feat(add): rc->scheduler -> nextTick Â· gcclll/stb-vue-next@32b4827 Â· GitHub]]

åœ¨ queue æ‰€æœ‰é˜Ÿåˆ—æ¸…ç©ºä¹‹åæ‰§è¡Œçš„ä¸€ä¸ªå¼‚æ­¥æ“ä½œï¼Œæœ‰é‡è¦å…³è”çš„ä¸¤ä¸ªå˜é‡ï¼š

1. resolvedPromiseï¼Œä¸€ä¸ªç©ºçš„ promise then
2. currentFlushPromiseï¼Œå½“ queue é˜Ÿåˆ—ä¸­çš„æ‰€æœ‰ä»»åŠ¡æ‰§è¡Œå®Œæˆä¹‹åè¿”å›çš„ä¸€ä¸ª promise

   æ˜¯çš„ï¼Œæ˜¯æ‰€æœ‰ queue jobs å®Œæˆä¹‹åï¼Œå› ä¸º flushJobs å‡½æ•°é‡Œé¢éƒ½æ˜¯åŒæ­¥æ“ä½œï¼Œé‡è¦ä»£
   ç ï¼š

   #+begin_src typescript
   for (flushIndex = 0; flushIndex < queue.length; flushIndex++) {
     const job = queue[flushIndex];
     if (job) {
       // TODO DEV -> æ£€æŸ¥é€’å½’æ›´æ–°é—®é¢˜
       callWithErrorHandling(job, null, ErrorCodes.SCHEDULER);
     }
   }
   #+end_src


#+begin_quote
æ‰€ä»¥ nextTick ä»»åŠ¡æ€»æ˜¯åœ¨ queue jobs æ‰€æœ‰ä»»åŠ¡å®Œæˆä¹‹åæ‰§è¡Œã€‚
#+end_quote

#+begin_src typescript
const resolvedPromise: Promise<any> = Promise.resolve();
// å½“å‰æ­£åœ¨è¢«æ‰§è¡Œçš„ promise ä»»åŠ¡
let currentFlushPromise: Promise<void> | null = null;

export function nextTick(
  this: ComponentPublicInstance | void,
  fn?: () => void
): Promise<void> {
  const p = currentFlushPromise || resolvedPromise;
  return fn ? p.then(this ? fn.bind(this) : fn) : p;
}
#+end_src

å‡½æ•°ä½œç”¨ï¼šåœ¨å½“å‰æ­£åœ¨æ‰§è¡Œçš„ job promise ä¹‹åæ‰§è¡Œ nextTick çš„ä»»åŠ¡ï¼Œç­‰äºè¯´ nextTick
å±äºä¸ªæ’é˜Ÿä»»åŠ¡ã€‚

#+begin_src js
// æºæ–‡ä»¶ï¼š/js/vue/lib.js
const {
  rc: { nextTick },
  log,
} = require(process.env.BLOG_JS + "/vue/lib.js");

const run = async () => {
  const calls = [];
  const pr = Promise.resolve();
  const dummyThen = Promise.resolve().then();
  const job1 = () => calls.push("job1");
  const job2 = () => calls.push("job2");
  nextTick(job1);
  job2();
  log(["\nbefore await, ", calls.length, "\n"]);
  await dummyThen;
  log(["\nafter await, ", calls.length, "\n"]);
  log(calls.join("-"));
};

run();
#+end_src

#+RESULTS:
:
: before await,  1
:
: after await,  2
:
: job2-job1

#+begin_quote
Tip. nextTick() å¼‚æ­¥ä»£ç æ‰§è¡Œï¼Œç»è¿‡ babel è½¬æ¢åçš„ä»£ç ï¼Œè¯·æŸ¥çœ‹ [[#q-nexttick][nextTick question]]
#+end_quote

** queueJob
:PROPERTIES:
:COLUMNS: %CUSTOM_ID[(Custom Id)]
:CUSTOM_ID: job-queue-job
:END:

[[https://github.com/gcclll/stb-vue-next/commit/eb33b40b7e8e87165fa2149b1a1354d078f33c40][feat(add): rc->scheduler->queueJob Â· gcclll/stb-vue-next@eb33b40 Â· GitHub]]

[[/img/vue3/runtime-core/vue-runtime-core-scheduler.svg]]

#+begin_src typescript
export function queueJob(job: SchedulerJob) {
  // the dedupe search uses the startIndex argument of Array.includes()
  // by default the search index includes the current job that is being run
  // so it cannot recursively trigger itself again.
  // if the job is a watch() callback, the search will start with a +1 index to
  // allow it recursively trigger itself - it is the user's responsibility to
  // ensure it doesn't end up in an infinite loop.
  if (
    (!queue.length ||
      !queue.includes(
        job,
        isFlushing && job.allowRecurse ? flushIndex + 1 : flushIndex
      )) &&
    job !== currentPreFlushParentJob
  ) {
    queue.push(job)
    queueFlush
  }
}

function queueFlush() {
  if (!isFlushing && !isFlushPending) {
    isFlushPending = true
    currentFlushPromise = resolvedPromise.then(flushJobs)
  }
}

// è¯·æŸ¥çœ‹ä¸‹ä¸€èŠ‚çš„å®ç°
function flushJobs(seen?: CountMap) {
  // TODO
}
#+end_src

éœ€è¦ flushJobs æ”¯æŒï¼Œè¯·åˆ° flushJobs(ğŸ‘‡) ä¸€èŠ‚æŸ¥çœ‹æµ‹è¯•æƒ…å†µã€‚

** flushJobs

[[https://github.com/gcclll/stb-vue-next/commit/e23be119f8b67f8c828f01f031f2488afa55c0c9][feat(add): rc->scheduler->flushJobs function Â· gcclll/stb-vue-next@e23be11 Â· GitHub]]

1. isFlushPending, isFlushing æ ‡è¯†é‡ç½®
2. [[#job-flush-pre][flushPreFlushCbs]], å¯¹ pre ç±»å‹çš„ jobs è¿›è¡Œ flush æ“ä½œï¼Œæœ‰å…³å‡½æ•°
   ~flushPreFlushCbs(flushå‡½æ•°)~ å’Œ ~queuePreFlushCb(å…¥åˆ—å‡½æ•°)~
3. flush ä¹‹å‰è¿›è¡Œæ’åº
4. try -> callWithErrorHandling æ‰§è¡Œä»»åŠ¡å›è°ƒ
5. finally -> é‡ç½®ï¼Œæ¸…ç©º queue é˜Ÿåˆ—å†…å®¹å’Œæ ‡è¯†
6. TODO flushPostFlushCbs, å¯¹ post ç±»å‹çš„ jobs è¿›è¡Œ flush æ“ä½œï¼Œæœ‰å…³å‡½æ•°
   ~flushPostFlushCbs~ å’Œ ~queuePostFlushCb~

#+begin_src typescript
function flushJobs(seen?: CountMap) {
  isFlushPending = false;
  isFlushing = true;

  if (__DEV__) {
    seen = seen || new Map();
  }

  // flushPreFLushCbs(seen)ï¼Œé»˜è®¤çš„ job ç±»å‹

  // flush ä¹‹å‰å¯¹ queue æ’åº
  // 1. ç»„ä»¶æ›´æ–°é¡ºåºï¼šparent -> childï¼Œå› ä¸º parent æ€»æ˜¯åœ¨ child ä¹‹å‰
  //    è¢«åˆ›å»ºï¼Œå› æ­¤ parent render effect æœ‰æ›´ä½çš„ä¼˜å…ˆçº§æ•°å­—(æ•°å­—è¶Šå°è¶Šå…ˆåˆ›å»ºï¼Ÿ)
  // 2. å¦‚æœç»„ä»¶åœ¨ parent æ›´æ–°æœŸé—´è¢«å¸è½½äº†ï¼Œé‚£ä¹ˆå®ƒçš„æ›´æ–°éƒ½ä¼šè¢«å¿½ç•¥æ‰

  queue.sort((a, b) => getId(a) - getId(b));

  // å¼€å§‹ flush
  try {
    for (flushIndex = 0; flushIndex < queue.length; flushIndex++) {
      const job = queue[flushIndex];
      if (job) {
        // TODO DEV -> æ£€æŸ¥é€’å½’æ›´æ–°é—®é¢˜
        callWithErrorHandling(job, null, ErrorCodes.SCHEDULER);
      }
    }
  } finally {
    // æƒ…å†µé˜Ÿåˆ—
    flushIndex = 0;
    queue.length = 0;

    // TODO flush `post` ç±»å‹çš„ flush cbs

    isFlushing = false;
    currentFlushPromise = null;

    // TDOO ä»£ç æ‰§è¡Œåˆ°å½“å‰ tick çš„æ—¶å€™ï¼Œæœ‰å¯èƒ½æœ‰æ–°çš„ job åŠ å…¥
    // some postFlushCb queued jobs!
    // keep flushing until it drains.
  }
}
#+end_src

æµ‹è¯•ï¼š
#+begin_src js
// æºæ–‡ä»¶ï¼š/js/vue/lib.js
const {
  rc: { queueJob, nextTick },
  log,
} = require(process.env.BLOG_JS + "/vue/lib.js");
const run = async () => {
  const calls = [];
  const job1 = () => { // #1
    log.newline("job1 running");
    calls.push("job1");
  };
  const job2 = () => { // #2
    log.newline("job2 running");
    calls.push("job2");
  };
// æ”¯æŒå»é‡
  queueJob(job1); // #3
  queueJob(job2); // #4
  queueJob(job1);
  queueJob(job2);
  log("before await  " + calls); // #5
  await nextTick(); // #6
  log("after await  " + calls); // #7
};

run();
#+end_src

#+RESULTS:
: before await
: undefined
:
: job1 running
:
:
: job2 running
: after await  job1,job2

å¦‚æœåœ¨æ²¡æœ‰ *#6* çš„æƒ…å†µä¸‹ï¼Œåœ¨æ‰€æœ‰ Log ä¹‹åä¼šç«‹å³æ‰§è¡Œ queue jobsã€‚

#+begin_src typescript
function queueFlush() {
  if (!isFlushing && !isFlushPending) {
    isFlushPending = true;
    currentFlushPromise = resolvedPromise.then(flushJobs);
  }
}
#+end_src

è¿™é‡Œ nextTick() è°ƒç”¨å¹¶æ²¡æœ‰ä¼ é€’ fn ï¼Œå› æ­¤ ~await nextTick()~ åœ¨è¿™é‡Œçš„ä½œç”¨å°±æ˜¯ç­‰
~resolvedPromise~ æ‰§è¡Œå®Œæˆ(æ­¤æ—¶å¹¶æ²¡æœ‰æ­£åœ¨æ‰§è¡Œçš„ promise)

~const resolvedPromise: Promise<any> = Promise.resolve()~

å†æ‰§è¡Œåé¢çš„ä»£ç ã€‚

queueJob å‡½æ•°åˆ†ä¸ºä¸¤æ­¥ï¼š

1. push æ”¶é›†ä»»åŠ¡ ~queue.push(job)~ ï¼ŒåŒæ­¥æ‰§è¡Œ
2. éšåç«‹å³è°ƒç”¨ ~queueFlush()~ åˆ·æ‰ä»»åŠ¡ï¼Œä»»åŠ¡å¼‚æ­¥ flush

åœ¨è¿™ä¸ªå®ä¾‹ä¸­ï¼ŒæŒ‰ç…§åŒæ­¥æ‰§è¡Œé¡ºåºï¼Œ

1. ~queueJob(job1)~ æ‰§è¡Œï¼Œå°† job1 -> push -> queue ä¸­ï¼Œ queueFlush ä¸­çš„ promise ç­‰å¾…
2. ~queueJob(job2)~ æ‰§è¡Œï¼Œå°† job2 -> push -> queue ä¸­ï¼Œ
   queueFlush ä¸­çš„ promise ç»§ç»­ç­‰å¾…
3. ~log before~ æ‰§è¡Œï¼Œç”±äº job è™½ç„¶å·²ç»åœ¨ queue ä¸­äº†ï¼Œä½†æ˜¯éœ€è¦ç­‰å¾… queueFlush å»
   å¼‚æ­¥æ‰§è¡Œä»–ä»¬ï¼Œæ‰€ä»¥è¿™é‡Œ calls ä¾æ—§æ˜¯ç©ºçš„
4. ~await nextTick()~ å¼‚æ­¥æ“ä½œ

   è¿™ä¸€å¥ç›®çš„åªæ˜¯ä¸ºäº†è®©åé¢çš„ log åœ¨ job1,job2 åé¢æ‰§è¡Œã€‚

   #+begin_src typescript
    const p = currentFlushPromise || resolvedPromise;
    return fn ? p.then(this ? fn.bind(this) : fn) : p;
   #+end_src

  nextTick ä¼šåœ¨åˆšåˆšæ‰§è¡Œå®Œæ¯•çš„ promise åé¢å–æ‰§è¡Œåé¢çš„ä»»åŠ¡ï¼Œæ‰€ä»¥ log after è‚¯å®šæ˜¯åäº job1,job2 çš„æ‰§è¡Œçš„ã€‚

5. æ‰€æœ‰åŒæ­¥ä»»åŠ¡æ‰§è¡Œå®Œæˆï¼Œå¼€å§‹è¿›å…¥å¼‚æ­¥ä»»åŠ¡æ‰§è¡Œï¼Œç”±äº job1,job2 å…ˆå…¥é˜Ÿåˆ—ï¼Œåœ¨äº‹ä»¶å¾ª
   ç¯ä¸­ä¼šå…ˆäº log after æ‰§è¡Œï¼Œç„¶ååœ¨æ‰§è¡Œ log afterï¼Œæ‰€ä»¥å°±æœ‰äº†ä¸Šé¢çš„è¾“å‡ºç»“æœã€‚


å®ä¾‹æ‰§è¡Œè„‘å›¾ï¼š

[[http://qiniu.ii6g.com/img/20210112173934.png]]

** queueJob while flushing

å½“ queue ä¸­ jobs æ­£åœ¨è¢«æ‰§è¡Œçš„æ—¶å€™è°ƒç”¨ queueJob è¿›å…¥æ–°çš„ä»»åŠ¡ã€‚

#+begin_src js
// æºæ–‡ä»¶ï¼š/js/vue/lib.js
const {
  rc: { queueJob, nextTick },
  log,
} = require(process.env.BLOG_JS + "/vue/lib.js");
const run = async () => {
  const calls = [];
  const job1 = () => {
    calls.push("job1");
    // job2 ä»»åŠ¡ä¼šåœ¨ job1 æ‰§è¡Œåˆ°è¿™é‡Œçš„æ—¶å€™åŠ å…¥åˆ°äº† queue
    // ä½†æ˜¯å®ƒçš„æ‰§è¡Œéœ€ç­‰åˆ° queue ä¸­çš„ä»»åŠ¡æ‰§è¡Œå®Œæˆä¹‹åå†æ‰§è¡Œ
    // å› ä¸ºä»»åŠ¡æ”¶é›†æ˜¯åŒæ­¥çš„ï¼Œä»»åŠ¡æ‰§è¡Œæ˜¯å¼‚æ­¥çš„ï¼Œè€Œ queue flush æ“ä½œåˆæ˜¯åŒæ­¥çš„
    queueJob(job2);
  };
  const job2 = () => calls.push("job2");
  queueJob(job1);
  await nextTick();
  log(["\nafter await\n", calls]);
};
run();
#+end_src

#+RESULTS:
: undefined
: after await
:  [ 'job1', 'job2' ]

çœ‹ä¸‹é¢çš„æµ‹è¯•ä»£ç ï¼ˆåœ¨ for å¾ªç¯è¿‡ç¨‹ä¸­æ”¹å˜æ•°ç»„é•¿åº¦ï¼Œä¼šæ£€æµ‹åˆ°è¿™ç§æ”¹å˜ï¼‰ï¼š
#+begin_src js
const nums = [1, 2, 3];
const add = (i) => nums.push(++i);
for (let i = 0; i < nums.length; i++) {
  if (i === 1) add(i);
  console.log({ i, v: nums[i], l: nums.length });
}
#+end_src

#+RESULTS:
: { i: 0, v: 1, l: 3 }
: { i: 1, v: 2, l: 4 }
: { i: 2, v: 3, l: 4 }
: { i: 3, v: 2, l: 4 }
: undefined

æ‰€ä»¥ä¸Šé¢çš„ Job å®ä¾‹ï¼Œå°±å¾ˆå¥½ç†è§£äº†

åœ¨ for queue jobs è¿‡ç¨‹ä¸­å‘ç°æœ‰æ–°çš„ job è¿›å…¥ï¼Œä¹‹å‰è¯´è¿‡äº†  queue çš„å…¥åˆ—æ“ä½œæ˜¯åŒæ­¥
çš„ï¼Œæ‰€ä»¥ä¼šç«‹å³æ‰§è¡Œæ”¹å˜ queue é•¿åº¦ï¼Œæœ€ååŠ å…¥çš„ä»»åŠ¡ä¼šåœ¨ for å¾ªç¯è¿‡ç¨‹ä¸­æœ€åå¾—åˆ°æ‰§è¡Œã€‚
** queuePreFlushCb

[[https://github.com/gcclll/stb-vue-next/commit/2c72cdc8734a3317041e4b14f288732379b4f1d2][feat(add): rc->scheduler->queuePreFlushCb -> pre jobs, pendingPreFlusâ€¦ Â· gcclll/stb-vue-next@2c72cdc Â· GitHub]]

æ–°å¢ä»£ç ï¼š

1. ~queuePreFlushCb~, å…¥åˆ— pre jobs å‡½æ•°
2. ~flushPreFlushCbs~, flush pre jobs å‡½æ•°
3. ~flushJobs~ ä¸­è°ƒç”¨ ~flushPreFlushCbs()~ åˆ·æ‰ pre jobs

è¿™ä¸ªæ˜¯ç”¨æ¥æ”¶é›†å’Œ flush pre ç±»å‹(é»˜è®¤ç±»å‹çš„ä»»åŠ¡)çš„é˜Ÿåˆ— ~pendingPreFlushCbs[]~  çš„å‡½æ•°ã€‚

é€»è¾‘è„‘å›¾ï¼š
[[http://qiniu.ii6g.com/img/20210113103504.png]]

ç›¸å…³ä»£ç ï¼š
#+begin_src typescript
export function queuePreFlushCb(cb: SchedulerCb) {
  queueCb(cb, activePreFlushCbs, pendingPreFlushCbs, preFlushIndex);
}

function queueCb(
  cb: SchedulerCbs,
  activeQueue: SchedulerCb[] | null,
  pendingQueue: SchedulerCb[],
  index: number
) {
  if (!isArray(cb)) {
    if (
      !activeQueue ||
      !activeQueue.includes(
        cb,
        (cb as SchedulerJob).allowRecurse ? index + 1 : index
      )
    ) {
      pendingQueue.push(cb);
    }
  } else {
    pendingQueue.push(...cb);
  }
  queueFlush();
}
#+end_src

å¯¹æ¯” queueCb å’Œ queueJob ä¼šå‘ç°ä¸¤è€…æ²¡å¤šå¤§çš„å·®åˆ«ï¼Œå…ˆåŒæ­¥æ”¶é›†å†å¼‚æ­¥ flushï¼Œä¸¤è€…åˆ¤
æ–­æ¡ä»¶æœ‰ç»†å¾®å·®åˆ«ï¼Œå¦å¤– queueJob æ”¯æŒæ•°ç»„å½¢å¼çš„ cbï¼š
#+begin_src typescript
// queueJob
if (
  (!queue.length ||
    !queue.includes(
      job,
      isFlushing && job.allowRecurse ? flushIndex + 1 : flushIndex
    )) &&
  job !== currentPreFlushParentJob
) {
  queue.push(job);
  queueFlush();
}
#+end_src

æœ€åä¹Ÿéƒ½æ˜¯è°ƒç”¨ queueFlush() -> flushJobs() æ¥æ¸…ç©ºé˜Ÿåˆ— pendingQueue/queue ã€‚

æ‰€ä»¥ä¸‹é¢è¿˜éœ€è¦åœ¨ flushJobs() é‡Œé¢å»å®ç°å¯¹ pre -> pendingQueue ç±»å‹é˜Ÿåˆ— flush æ“
ä½œ(~flushPreFlushCbs()~)ã€‚
** flushPreFlushCbs
:PROPERTIES:
:COLUMNS: %CUSTOM_ID[(Custom Id)]
:CUSTOM_ID: job-flush-pre
:END:

æœ‰å…³å‡½æ•°å’Œå˜é‡

| name                 | type     | description                                                      |
|----------------------+----------+------------------------------------------------------------------|
| ~preFlushIndex~      | number   | used in `for` to flush pre jobs                                    |
| ~pendingPreFlushCbs~ | array    | the queue to store pre jobs                                      |
| ~activePreFlushCbs~  | array    | the non-repeat copy of ~pendingPreFlushCbs~, used to flushing    |
| ~queuePreFlushCb~    | function | ä¸ flushPreFlushCbs å¯¹åº”çš„ pre job å…¥åˆ—å‡½æ•°                      |
| ~queueFlush~         | function | æ‰§è¡Œé˜Ÿåˆ—ä»»åŠ¡çš„å‡½æ•°ï¼Œä¸‰ä¸ªç±»å‹çš„ä»»åŠ¡éƒ½åœ¨è¿™é‡Œé¢æ‰§è¡Œ(pre,post,queue) |
| ~flushJobs~          | function | å…·ä½“æ‰§è¡Œä»»åŠ¡çš„å‡½æ•°ï¼Œä¸‰ç§ä»»åŠ¡æ‰§è¡Œé¡ºåºæ˜¯ï¼š pre -> queue -> post    |

#+begin_quote
Tip. ~activePreFlushCbs~ å’Œ ~pendingPreFlushCbs~ çš„å…³ç³»ï¼š å‰è€…æ˜¯åè€…çš„ä¸€ä¸ªæ‹·è´ï¼Œ
æ‹·è´å®Œä¼šç«‹å³æ¸…ç©º pending, ç›®çš„æ˜¯ä¸ºäº†è®© pending åœ¨ active flushing æœŸé—´èƒ½ç»§ç»­æ”¶é›†
æ–°çš„ä»»åŠ¡ï¼Œè¿™æ ·å¦‚æœåœ¨æ‰§è¡ŒæœŸé—´æœ‰æ–°çš„ä»»åŠ¡å…¥åˆ—ï¼Œé‚£ä¹ˆåœ¨å‡½æ•°æœ€åçš„é€’å½’æ“ä½œä¼šå¯¹è¿™äº›æ–°å…¥
åˆ—çš„ä»»åŠ¡ç»§ç»­ flush æ‰ï¼Œç›´åˆ°å†ä¹Ÿæ²¡æœ‰æ–°çš„ä»»åŠ¡å…¥åˆ—ä¸ºæ­¢ã€‚
#+end_quote


æºç ï¼š
#+begin_src typescript
export function flushPreFlushCbs(
  seen?: CountMap,
  parentJob: SchedulerJob | null = null
) {
  if (pendingPreFlushCbs.length) {
    currentPreFlushParentJob = parentJob;
    activePreFlushCbs = [...new Set(pendingPreFlushCbs)];
    pendingPreFlushCbs.length = 0;
    if (__DEV__) {
      seen = seen || new Map();
    }

    for (
      preFlushIndex = 0;
      preFlushIndex < activePreFlushCbs.length;
      preFlushIndex++
    ) {
      // TODO æ£€æŸ¥é€’å½’æ›´æ–°é—®é¢˜
      activePreFlushCbs[preFlushIndex]();
    }

    activePreFlushCbs = null;
    preFlushIndex = 0;
    currentPreFlushParentJob = null;
    // é€’å½’ flush ç›´åˆ°æ‰€æœ‰ pre jobs è¢«æ‰§è¡Œå®Œæˆ
    flushPreFlushCbs(seen, parentJob);
  }
}
#+end_src

ç”¨é€”ï¼š api watch é‡Œé¢å¯¹é»˜è®¤ç±»å‹(~pre~)çš„ä»»åŠ¡çš„å…¥åˆ—æ“ä½œï¼Œå¦‚ä¸‹ä»£ç ï¼š
#+begin_src typescript
// default: 'pre'
function doWatch(
  source: WatchSource | WatchSource[] | WatchEffect | object,
  cb: WatchCallback | null,
  { immediate, deep, flush, onTrack, onTrigger }: WatchOptions = EMPTY_OBJ,
  instance = currentInstance
): WatchStopHandle {
  // ...
  let scheduler: ReactiveEffectOptions["scheduler"];
  if (flush === "sync") {
    // ...
  } else if (flush === "post") {
    // ...
  } else {
    // default: 'pre'
    scheduler = () => {
      if (!instance || instance.isMounted) {
        queuePreFlushCb(job);
      } else {
        // with 'pre' option, the first call must happen before
        // the component is mounted so it is called synchronously.
        job();
      }
    };
  }
  // ...
}
#+end_src
** queuePostFlushCb + flushPostFlushCbs

[[https://github.com/gcclll/stb-vue-next/commit/845c21bfc0ef1797d39a9fd789d79a4fdc3bd399][feat(add): rc->scheduler->queuePostFlushCb+flushPostFlushCbs Â· gcclll/stb-vue-next@845c21b Â· GitHub]]

é€»è¾‘è„‘å›¾ï¼š
[[http://qiniu.ii6g.com/img/20210113143628.png]]

æœ‰äº† queue job å’Œ pre cb çš„åŸºç¡€åˆ†æï¼Œè¿™éƒ¨åˆ†ä¹Ÿå°±å¾ˆå¥½ç†è§£äº†ã€‚

#+begin_src typescript
export function queuePostFlushCb(cb: SchedulerCbs) {
  queueCb(cb, activePostFlushCbs, pendingPostFlushCbs, postFlushIndex);
}

export function flushPostFlushCbs(seen?: CountMap) {
  if (pendingPostFlushCbs.length) {
    const deduped = [...new Set(pendingPostFlushCbs)];
    pendingPostFlushCbs.length = 0;

    // #1947 already has active queue, nested flushPostFlushCbs call
    if (activePostFlushCbs) {
      activePostFlushCbs.push(...deduped);
      return;
    }

    activePostFlushCbs = deduped;
    if (__DEV__) {
      seen = seen || new Map();
    }

    activePostFlushCbs.sort((a, b) => getId(a) - getId(b));

    for (
      postFlushIndex = 0;
      postFlushIndex < activePostFlushCbs.length;
      postFlushIndex++
    ) {
      // TODO é€’å½’ update æ£€æŸ¥
      activePostFlushCbs[postFlushIndex]();
    }

    activePostFlushCbs = null;
    postFlushIndex = 0;
  }
}
#+end_src

å’Œ pre cb çš„å¤„ç†æœ‰ä¸¤ä¸ªä¸åŒç‚¹ï¼š
1. éå›è°ƒå½¢å¼å¤„ç† flushing æœŸé—´æ¥å—åˆ°çš„æ–°ä»»åŠ¡ï¼Œè€Œæ˜¯é€šè¿‡æ”¹å˜æ‰§è¡Œå™¨
   activePostFlushCbs æ¥å®ç°(å’Œ queue job ç±»ä¼¼)
2. æ²¡æœ‰é€’å½’å›è°ƒå½¢å¼å¤„ç†åç»­çš„æ–°ä»»åŠ¡ï¼Œå‚è€ƒ *1*
** test

å®Œæ•´çš„æµ‹è¯•ç”¨ä¾‹ï¼Œç»“åˆ pre, post, queue ä¸‰ç§ç±»å‹çš„ä»»åŠ¡è¿›è¡Œæµ‹è¯•ã€‚

#+begin_src js
// æºæ–‡ä»¶ï¼š/js/vue/lib.js
const {
  rc: { queueJob, queuePreFlushCb, nextTick },
  log,
} = require(process.env.BLOG_JS + "/vue/lib.js");

const run = async () => {
  const calls = [];
  const cb1 = () => {
    log("\ncb1 running...");
    calls.push("cb1");
  };
  const cb2 = () => {
    log("\ncb2 running...");
    calls.push("cb2");
    // queueJob å’Œ queuePreFlushCb ç»“åˆä½¿ç”¨
    queueJob(job1);
  };
  const cb3 = () => {
    log("\ncb3 running...");
    calls.push("cb3");
    // é“¾å¼ä½¿ç”¨ï¼Œcb4 ä¼šåœ¨ cb1,2,3 æ‰§è¡Œå®Œæˆä¹‹åæ‰ä¼šæ‰§è¡Œ
    queuePreFlushCb(cb4);
  };
  const cb4 = () => {
    log("\ncb4 running...");
    calls.push("cb4");
  };
  const cb5 = () => {
    log("\ncb5 running...");
    calls.push("cb5");
  };
  const job1 = () => {
    log("\njob1 running...");
    calls.push("job1");
    // queuePreFlushCb åœ¨ queueJob ä¸­è°ƒç”¨
    queuePreFlushCb(cb5);
  };

  queuePreFlushCb(cb1);
  queuePreFlushCb(cb2);
  queuePreFlushCb(cb1);
  queuePreFlushCb(cb2);
  queuePreFlushCb(cb3);

  log("\nbefore await, " + calls);
  await nextTick();
  log("\nafter await, " + calls);
};
run();
#+end_src

#+RESULTS:
#+begin_example

before await,
undefined
cb1 running...

cb2 running...

cb3 running...

cb4 running...

job1 running...

cb5 running...

after await, cb1,cb2,cb3,cb4,job1,cb5
#+end_example

1. pendingPreFlushCbs è™½ç„¶æ˜¯ä¸ªæ•°ç»„ï¼Œä½†æ˜¯ flush æœŸé—´é€šè¿‡ ~[...new
   Set(pendingPreFlushCbs)]~ è¿›è¡Œäº†å»é‡æ“ä½œã€‚
2. é“¾å¼æ“ä½œï¼Œå› ä¸ºåœ¨æ‰§è¡ŒæœŸé—´ä½¿ç”¨çš„æ˜¯ ~activePreFlushCbs~ ä¸”æ­¤æ—¶çš„
   ~pendingPreFlushCbs~ æ¸…ç©ºäº†ï¼Œç­‰å¾…æ–°ä»»åŠ¡å…¥åˆ—

   åœ¨æ‰§è¡Œ cb3 æœŸé—´ï¼Œè°ƒç”¨ ~queuePreFlushCb(cb4)~ æ­¤æ—¶ push cb4 ->
   ~pendingPreFlushCbs~ ï¼Œä½†å®é™…ä¸ä¼šå½±å“æœ¬æ¬¡çš„ for å¾ªç¯æ‰§è¡Œ

   [[#job-queue-job][è¿™ç‚¹å’Œ queueJob æœ‰ç‚¹ä¸åŒï¼Œå®ƒç›´æ¥ä½¿ç”¨çš„æ˜¯ queue -> for æ‰€ä»¥æœ‰æ–°çš„ä»»åŠ¡å…¥åˆ—ä¼šæ”¹
   å˜ for çš„æ‰§è¡Œé•¿åº¦(queue.length)]]

   pre å¤„ç†ä¼šç­‰åˆ° activePreFlushCbs for æ‰§è¡Œå¾ªç¯ç»“æŸåï¼Œåœ¨å‡½æ•°çš„æœ€åé€’å½’è°ƒç”¨
   ~flushPreFlushCbs()~ æ¥åˆ·æ‰æ–°å…¥åˆ—çš„ä»»åŠ¡(å¦‚ï¼š *cb4*)
3. queueJob åœ¨ queuePreFlushCb ä¸­è°ƒç”¨çš„æ—¶å€™ï¼Œ queue job æ€»æ˜¯åœ¨ pre cb ä¹‹åè¢«æ‰§è¡Œï¼Œè¿™ä¹Ÿ
   æ˜¯ flushJobs ä¸­å¤„ç†ä»£ç åº”ä½“ç°å‡ºçš„ç»“æœã€‚

  #+begin_src typescript
  function flushJobs() {
    // 1. flush pre -> flushPreFlushCbs()
    // 2. for -> queue job -> callWithErrorHandling(job, ...)
    // 3. flush post -> flushPostFlushCbs()
  }
  #+end_src

  å¹¶ä¸”å¦‚ä¸Šé¢å®ä¾‹ç»“æœ cb4 åµŒå¥—åœ¨ cb3 ï¼Œjob1 åµŒå¥—åœ¨äº† cb2 ä¸­ï¼Œä½†æ˜¯æœ€åè¿˜æ˜¯ cb4 å…ˆ
   å¾—åˆ°æ‰§è¡Œäº†ï¼Œjob1 å†æ‰§è¡Œã€‚

   #+begin_quote
   Tip. å› æ­¤ï¼Œå¯¹äº pre cbs å’Œ queue jobs ä¸¤ä¸ªç±»å‹çš„ä»»åŠ¡ï¼Œä¸ç®¡ä»€ä¹ˆæ—¶æœºå…¥åˆ—çš„ï¼Œéƒ½ä¼š
   æ˜¯å…ˆæ‰§è¡Œ pre cbs å†æ‰§è¡Œ queue jobs
   #+end_quote
4. queuePreFlushCb åœ¨ queueJob ä¸­è°ƒç”¨çš„æ—¶å€™ï¼Œæ–°çš„ pre job ä¼šåœ¨ queue job åæ‰§è¡Œ

   [[https://github.com/gcclll/stb-vue-next/commit/b0155c5405deba3da37c60d2beb8d08a377f699d][fix: rc->scheduler->flushJobs recursive Â· gcclll/stb-vue-next@b0155c5 Â·
   GitHub]]

   åŸå› ï¼š ~flushPreFlushCbs~ å…ˆäº queue jobs æ‰§è¡Œï¼Œå› æ­¤ queue jobs(~job1~) æ‰§è¡Œ
   çš„æ—¶å€™ ~queuePreFlushCb()~ åŠ å…¥çš„ä»»åŠ¡(~cb5~)æ­¤æ—¶ä¸ä¼šæ‰§è¡Œï¼Œè€Œæ˜¯ç­‰ queue jobs
   éƒ½æ‰§è¡Œå®Œä¹‹ååœ¨finally é‡Œé¢ä¼šåšä¸€æ¬¡æ£€æµ‹

   #+begin_src typescript
   if (queue.length || pendingPreFlushCbs.length) {
      flushJobs(seen)
    }
   #+end_src

   è¿™ä¸ªæ—¶å€™ä¼šå»é€’å½’ ~flushJobs()~ æ­¤æ—¶æ‰å‘ç°æœ‰æ–°çš„ ~pendingPreFlushCbs~ (å¦‚ï¼š
   ~cb5~)ï¼Œåˆ™å°†æ‰§è¡Œä»–ä»¬ï¼Œæ‰€ä»¥ç»“æœæ˜¯ ~job1,cb5~ ã€‚



* BUGs fix & Questions

[[https://github.com/gcclll/stb-vue-next/commit/2a1ab0448919ea75c5794410a03265bd99e05d75][fix: no import EMPTY_ARR Â· gcclll/stb-vue-next@2a1ab04 Â· GitHub]]

** nextTick() åé¢çš„ä»£ç æœ€åæ‰§è¡Œï¼Ÿ
:PROPERTIES:
:COLUMNS: %CUSTOM_ID[(Custom Id)]
:CUSTOM_ID: q-nexttick
:END:

æµ‹è¯•ä»£ç ï¼š [[#nexttick][nextTick]]

å…ˆçœ‹ä¸€æ®µä»£ç ï¼Œä»¥åŠ [[https://babeljs.io/repl][babeljs.io]] è½¬æ¢ä¹‹åçš„ç»“æœï¼š

babel ä¹‹å‰ï¼š
#+begin_src js
const run = async () => {
  const p = Promise.resolve().then();

  const p1 = p.then(() => console.log("before await"));
  console.log("between await and p1");
  await p1;
  console.log("after await");
  const p2 = Promise.resolve().then();
  await p2;
  console.log("after p2");
};
run();
#+end_src

babel ä¹‹å(åªè´´å‡ºæ ¸å¿ƒéƒ¨åˆ†)ï¼š
#+begin_src js
while (1) {
  switch ((_context.prev = _context.next)) {
    case 0:
      p = Promise.resolve().then();
      p1 = p.then(function () {
        return console.log("before await");
      });
      console.log("between await and p1");
      _context.next = 5;
      return p1;

    case 5:
      console.log("after await");
      p2 = Promise.resolve().then();
      _context.next = 9;
      return p2;

    case 9:
      console.log("after p2");

    case 10:
    case "end":
      return _context.stop();
  }
}
#+end_src

å³ä¸Šé¢çš„ä»£ç è¢«è½¬æ¢ä¹‹åå˜æˆäº†ä¸€ä¸ª switchï¼Œé‡Œé¢æ˜¯ä¸€ä¸ª while å¾ªç¯ï¼Œå¼‚æ­¥ä»£ç æœ€ç»ˆçš„é¡º
åºæ‰§è¡Œç”± _context.next æ¥è¡”æ¥ã€‚

~case 0~ -> ~next = 5~ -> ~case 5~ -> ~next = 9~ -> ...

æ‰€ä»¥è¯´ nextTick() åé¢çš„ä»£ç éƒ½ä¼šè¢«æ”¾åˆ°å¼‚æ­¥ä»£ç 

* runtime-core ç±»å‹å£°æ˜

:PROPERTIES:
:COLUMNS: %CUSTOM_ID[(Custom Id)]
:CUSTOM_ID: defines
:END:
1. å¼‚æ­¥ç»„ä»¶é€‰é¡¹

    #+begin_src typescript
    export interface AsyncComponentOptions<T = any> {
    loader: AsyncComponentLoader<T>
    loadingComponent?: Component
    errorComponent?: Component
    delay?: number
    timeout?: number
    suspensible?: boolean
    onError?: (
        error: Error,
        retry: () => void,
        fail: () => void,
        attempts: number
    ) => any
    }
    #+end_src

2. Vue App ç±»å‹

   #+begin_src typescript
    export interface App<HostElement = any> {
      version: string;
      config: AppConfig;
      use(plugin: Plugin, ...options: any[]): this;
      mixin(mixin: ComponentOptions): this;
      component(name: string): Component | undefined;
      component(name: string, component: Component): this;
      directive(name: string): Directive | undefined;
      directive(name: string, directive: Directive): this;
      mount(
        rootContainer: HostElement | string,
        isHydrate?: boolean
      ): ComponentPublicInstance;
      unmount(rootContainer: HostElement | string): void;
      provide<T>(key: InjectionKey<T> | string, value: T): this;

      // internal, but we need to expose these for the server-renderer and devtools
      _uid: number;
      _component: ConcreteComponent;
      _props: Data | null;
      _container: HostElement | null;
      _context: AppContext;
    }
   #+end_src

   App é…ç½®:

   #+begin_src typescript
    export interface AppConfig {
      // @private
      readonly isNativeTag?: (tag: string) => boolean;

      performance: boolean;
      optionMergeStrategies: Record<string, OptionMergeFunction>;
      globalProperties: Record<string, any>;
      isCustomElement: (tag: string) => boolean;
      errorHandler?: (
        err: unknown,
        instance: ComponentPublicInstance | null,
        info: string
      ) => void;
      warnHandler?: (
        msg: string,
        instance: ComponentPublicInstance | null,
        trace: string
      ) => void;
    }
   #+end_src

   Vue æ’ä»¶ç±»å‹ï¼š

   #+begin_src typescript
    type PluginInstallFunction = (app: App, ...options: any[]) => any;
    export type Plugin =
      | (PluginInstallFunction & { install?: PluginInstallFunction })
      | {
          install: PluginInstallFunction;
        };
   #+end_src

3. api watch ç±»å‹

   #+begin_src typescript
    export interface WatchOptionsBase {
      flush?: "pre" | "post" | "sync";
      onTrack?: ReactiveEffectOptions["onTrack"];
      onTrigger?: ReactiveEffectOptions["onTrigger"];
    }

    export interface WatchOptions<Immediate = boolean> extends WatchOptionsBase {
      immediate?: Immediate;
      deep?: boolean;
    }
   #+end_src

4. component ç»„ä»¶ç±»å‹

   #+begin_src typescript
    // å†…éƒ¨é€‰é¡¹
    export interface ComponentInternalOptions {
      /**
    ,* @internal
    ,*/
      __props?: NormalizedPropsOptions;
      /**
    ,* @internal
    ,*/
      __emits?: ObjectEmitsOptions | null;
      /**
    ,* @internal
    ,*/
      __scopeId?: string;
      /**
    ,* @internal
    ,*/
      __cssModules?: Data;
      /**
    ,* @internal
    ,*/
      __hmrId?: string;
      /**
    ,* This one should be exposed so that devtools can make use of it
    ,*/
      __file?: string;
    }

    // å‡½æ•°å¼ç»„ä»¶
    export interface FunctionalComponent<P = {}, E extends EmitsOptions = {}>
      extends ComponentInternalOptions {
      // use of any here is intentional so it can be a valid JSX Element constructor
      (props: P, ctx: Omit<SetupContext<E>, "expose">): any;
      props?: ComponentPropsOptions<P>;
      emits?: E | (keyof E)[];
      inheritAttrs?: boolean;
      displayName?: string;
    }

    // ç±»ç»„ä»¶
    export interface ClassComponent {
      new (...args: any[]): ComponentPublicInstance<any, any, any, any, any>;
      __vccOpts: ComponentOptions;
    }

    // ç”Ÿå‘½å‘¨æœŸå‡½æ•°ç¼©å†™
    export const enum LifecycleHooks {
      BEFORE_CREATE = "bc",
      CREATED = "c",
      BEFORE_MOUNT = "bm",
      MOUNTED = "m",
      BEFORE_UPDATE = "bu",
      UPDATED = "u",
      BEFORE_UNMOUNT = "bum",
      UNMOUNTED = "um",
      DEACTIVATED = "da",
      ACTIVATED = "a",
      RENDER_TRIGGERED = "rtg",
      RENDER_TRACKED = "rtc",
      ERROR_CAPTURED = "ec",
    }

    // setup å‡½æ•°
    export interface SetupContext<E = EmitsOptions> {
      attrs: Data;
      slots: Slots;
      emit: EmitFn<E>;
      expose: (exposed: Record<string, any>) => void;
    }
   #+end_src

5. component internal instance

   è¿™é‡Œæ¶µç›–äº†ä¸€ä¸ªç»„ä»¶éƒ½æœ‰å“ªäº›å±æ€§ï¼š

   ~uid, type, parent, root, appContext, vnode, next, subTree, update~,

   ~render, ssrRender, provides, effects, accessCache, renderCache~,

   ~components, directives, propsOptions, emitsOptions~,

   ~proxy, exposed, withProxy, ctx~,

   ~data, props, attrs, slots, refs, emit~,

   ~emitted, setupState, devtoolsRawSetupState, setupContext~,

   ~suspense, suspenseId, asyncDep, asyncResolved~,

   ~isMounted, isUnmounted, isDeactivated~,

   ~bc, c, bm, m, bu, u, bum, um, da, a, rtg, rtc, ec~
   #+begin_src typescript
    export const enum LifecycleHooks {
      BEFORE_CREATE = "bc",
      CREATED = "c",
      BEFORE_MOUNT = "bm",
      MOUNTED = "m",
      BEFORE_UPDATE = "bu",
      UPDATED = "u",
      BEFORE_UNMOUNT = "bum",
      UNMOUNTED = "um",
      DEACTIVATED = "da",
      ACTIVATED = "a",
      RENDER_TRIGGERED = "rtg",
      RENDER_TRACKED = "rtc",
      ERROR_CAPTURED = "ec",
    }
   #+end_src

   ç±»å‹ï¼š
   #+begin_src typescript
    /**
     * We expose a subset of properties on the internal instance as they are
     * useful for advanced external libraries and tools.
     */
    export interface ComponentInternalInstance {
      uid: number;
      type: ConcreteComponent;
      parent: ComponentInternalInstance | null;
      root: ComponentInternalInstance;
      appContext: AppContext;
      /**
       * Vnode representing this component in its parent's vdom tree
       */
      vnode: VNode;
      /**
       * The pending new vnode from parent updates
       * @internal
       */
      next: VNode | null;
      /**
       * Root vnode of this component's own vdom tree
       */
      subTree: VNode;
      /**
       * The reactive effect for rendering and patching the component. Callable.
       */
      update: ReactiveEffect;
      /**
       * The render function that returns vdom tree.
       * @internal
       */
      render: InternalRenderFunction | null;
      /**
       * SSR render function
       * @internal
       */
      ssrRender?: Function | null;
      /**
       * Object containing values this component provides for its descendents
       * @internal
       */
      provides: Data;
      /**
       * Tracking reactive effects (e.g. watchers) associated with this component
       * so that they can be automatically stopped on component unmount
       * @internal
       */
      effects: ReactiveEffect[] | null;
      /**
       * cache for proxy access type to avoid hasOwnProperty calls
       * @internal
       */
      accessCache: Data | null;
      /**
       * cache for render function values that rely on _ctx but won't need updates
       * after initialized (e.g. inline handlers)
       * @internal
       */
      renderCache: (Function | VNode)[];

      /**
       * Resolved component registry, only for components with mixins or extends
       * @internal
       */
      components: Record<string, ConcreteComponent> | null;
      /**
       * Resolved directive registry, only for components with mixins or extends
       * @internal
       */
      directives: Record<string, Directive> | null;
      /**
       * reoslved props options
       * @internal
       */
      propsOptions: NormalizedPropsOptions;
      /**
       * resolved emits options
       * @internal
       */
      emitsOptions: ObjectEmitsOptions | null;

      // the rest are only for stateful components ---------------------------------

      // main proxy that serves as the public instance (`this`)
      proxy: ComponentPublicInstance | null;

      // exposed properties via expose()
      exposed: Record<string, any> | null;

      /**
       * alternative proxy used only for runtime-compiled render functions using
       * `with` block
       * @internal
       */
      withProxy: ComponentPublicInstance | null;
      /**
       * This is the target for the public instance proxy. It also holds properties
       * injected by user options (computed, methods etc.) and user-attached
       * custom properties (via `this.x = ...`)
       * @internal
       */
      ctx: Data;

      // state
      data: Data;
      props: Data;
      attrs: Data;
      slots: InternalSlots;
      refs: Data;
      emit: EmitFn;
      /**
       * used for keeping track of .once event handlers on components
       * @internal
       */
      emitted: Record<string, boolean> | null;

      /**
       * setup related
       * @internal
       */
      setupState: Data;
      /**
       * devtools access to additional info
       * @internal
       */
      devtoolsRawSetupState?: any;
      /**
       * @internal
       */
      setupContext: SetupContext | null;

      /**
       * suspense related
       * @internal
       */
      suspense: SuspenseBoundary | null;
      /**
       * suspense pending batch id
       * @internal
       */
      suspenseId: number;
      /**
       * @internal
       */
      asyncDep: Promise<any> | null;
      /**
       * @internal
       */
      asyncResolved: boolean;

      // lifecycle
      isMounted: boolean;
      isUnmounted: boolean;
      isDeactivated: boolean;
      /**
       * @internal
       */
      [LifecycleHooks.BEFORE_CREATE]: LifecycleHook;
      /**
       * @internal
       */
      [LifecycleHooks.CREATED]: LifecycleHook;
      /**
       * @internal
       */
      [LifecycleHooks.BEFORE_MOUNT]: LifecycleHook;
      /**
       * @internal
       */
      [LifecycleHooks.MOUNTED]: LifecycleHook;
      /**
       * @internal
       */
      [LifecycleHooks.BEFORE_UPDATE]: LifecycleHook;
      /**
       * @internal
       */
      [LifecycleHooks.UPDATED]: LifecycleHook;
      /**
       * @internal
       */
      [LifecycleHooks.BEFORE_UNMOUNT]: LifecycleHook;
      /**
       * @internal
       */
      [LifecycleHooks.UNMOUNTED]: LifecycleHook;
      /**
       * @internal
       */
      [LifecycleHooks.RENDER_TRACKED]: LifecycleHook;
      /**
       * @internal
       */
      [LifecycleHooks.RENDER_TRIGGERED]: LifecycleHook;
      /**
       * @internal
       */
      [LifecycleHooks.ACTIVATED]: LifecycleHook;
      /**
       * @internal
       */
      [LifecycleHooks.DEACTIVATED]: LifecycleHook;
      /**
       * @internal
       */
      [LifecycleHooks.ERROR_CAPTURED]: LifecycleHook;
    }
   #+end_src

6. emit fn äº‹ä»¶

   #+begin_src typescript
    export type EmitFn<
      Options = ObjectEmitsOptions,
      Event extends keyof Options = keyof Options
    > = Options extends Array<infer V>
      ? (event: V, ...args: any[]) => void
      : {} extends Options // if the emit is empty object (usually the default value for emit) should be converted to function
      ? (event: string, ...args: any[]) => void
      : UnionToIntersection<
          {
            [key in Event]: Options[key] extends (...args: infer Args) => any
              ? (event: key, ...args: Args) => void
              : (event: key, ...args: any[]) => void;
          }[Event]
        >;
   #+end_src
