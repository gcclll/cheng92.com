#+TITLE: Vue3.0æºç ç³»åˆ— -- çŸ¥è¯†ç‚¹åŠé—®é¢˜æ±‡æ€»
#+DATE: <2020-09-01 21:40:31>
#+TAGS[]: vue, vue3, vuenext
#+CATEGORIES[]: vue
#+LANGUAGE: zh-cn
#+STARTUP: indent

#+begin_export html
<link href="https://fonts.goo~gleapis.com/cs~s2?family=ZCOOL+XiaoWei&display=swap" rel="stylesheet">
<kbd>
<font color="blue" size="3" style="font-family: 'ZCOOL XiaoWei', serif;">
  è¯—å·ï¼šå…­é“åŒå ï¼Œé­”åŠ«ä¸‡åƒï¼Œå¼•æ¸¡å¦‚æ¥ã€‚
</font>
</kbd><br><br>
<script src="/js/utils.js"></script>
<script src="/js/vue/vue-next.js"></script>
<!--<script src="https://unpkg.com/vue@next"></script>-->
<script>
insertCssLink("https://unpkg.com/element-plus/lib/theme-chalk/index.css");
</script>
<script src="https://unpkg.com/element-plus/lib/index.full.js"></script>
<script src="/js/vue/tests/common.js"></script>
#+end_export

* vue diff å…¨è¿‡ç¨‹æºç è§£æï¼Ÿ

[[https://www.cheng92.com/vue/vue-mind-map-runtime-core-2-render/#keyed-children][Vue3 æºç å¤´è„‘é£æš´ä¹‹ 7 â˜ runtime-core(2) - render - è‹¥å¶çŸ¥ç§‹]]


ç®€è¿°ï¼š ä¸¤ä¸ª while + if...else if...else

while1 æ£€æµ‹ patch å¤´éƒ¨ç›¸åŒèŠ‚ç‚¹

while2 æ£€æµ‹ patch å°¾éƒ¨ç›¸åŒèŠ‚ç‚¹

ç»è¿‡ä¸¤ä¸ª while å¤„ç†ä¹‹åå‰©ä¸‹çš„åªæœ‰ä¸è§„åˆ™çš„ä¸¤ç»„(new & old)åºåˆ—ã€‚

if æ‰§è¡Œæ–°å¢

else if æ‰§è¡Œåˆ é™¤

else ä¾ç…§ã€æœ€é•¿å¢é•¿åºåˆ—ã€ç®—æ³•è¿›è¡Œåˆ†æï¼Œå†³å®šæ˜¯åˆ é™¤è¿˜æ˜¯æ–°å¢æˆ–æ’å…¥ã€‚

æœ€é•¿å¢é•¿åºåˆ—ï¼šæ‰¾åˆ°ä¸€ç»„åºåˆ—ä¸­è·¯å¾„æœ€é•¿çš„é€’å¢åºåˆ—ï¼Œæ¯”å¦‚ï¼š

~2,3,1,4~ æœ€é•¿å¢é•¿åºåˆ—å°±æ˜¯ ~2,3,4~

å‰©ä¸‹çš„å…ƒç´ åªå¯èƒ½æ¯”è¿™ä¸ªåºåˆ—ä¸­çš„å…ƒç´ å€¼å°(å¦‚ï¼š ~1~)

* props ? attrs ?
:PROPERTIES:
:COLUMNS: %CUSTOM_ID[(Custom Id)]
:CUSTOM_ID: props-attrs
:END:

è¿™ä¸¤ä¸ªå±æ€§åœ¨ç»„ä»¶ä¸Šæ˜¯å¦‚ä½•åŒºåˆ†çš„ï¼Ÿ

å½“çˆ¶ç»„ä»¶ç»™å­ç»„ä»¶ä¼ é€’å±æ€§çš„æ—¶å€™ï¼Œæœ€ç»ˆéƒ½åˆ’åˆ†åˆ°é‚£ä¸ªå¯¹è±¡ä¸Šäº†ï¼Ÿ

å…ˆä¸Šå®ä¾‹ï¼Œç‚¹å‡»æŒ‰é’®å¯æŸ¥çœ‹å¯¹åº”ç»“æœåˆ†æ([[/js/vue/tests/7jAWzTeF1O.js]]):
#+begin_export html
<div id="x7jAWzTeF1O"></div>
<script src="/js/vue/tests/7jAWzTeF1O.js"></script>
#+end_export

é¦–å…ˆï¼Œåœ¨ compiler é˜¶æ®µæ‰€æœ‰å±æ€§éƒ½ä¼šè¢«ç¼–è¯‘åˆ° vnode.props ä¸Šï¼Œåœ¨ runtime-core patch
é˜¶æ®µæ‰ä¼šåŒºåˆ† props å’Œ attrsï¼Œé‚£è¿™äº›å±æ€§åˆæ˜¯å¦‚ä½•åšçš„åŒºåˆ†ï¼Œå½“å¼€å‘çš„æ—¶å€™ç»™å­ç»„ä»¶ä¼ 
é€’çš„å±æ€§æœ€ç»ˆéƒ½æ”¾åˆ°å“ªä¸ªé‡Œé¢äº†ï¼Ÿ

è¿™é‡Œé¢å°±å¾—å¥½å¥½æ°æ‰¯æ°æ‰¯äº†ï¼ï¼ï¼

æ ¹æ®ä¹‹å‰çš„æºç åˆ†æï¼Œç»„ä»¶ patch æµç¨‹: processComponent -> mountComponent æˆ–
updateComponent è¿™é‡Œæˆ‘ä»¬ä»¥ç»„ä»¶é¦–æ¬¡æ¸²æŸ“è¿›å…¥ mountComponent ä¸ºä¾‹ã€‚

mountComopnent ç®€åŒ–ä¹‹åå…¶å®å°±ä¸¤ä¸ªéƒ¨åˆ†ï¼š

1. setupComponent() åˆå§‹åŒ– props, slots æ‰§è¡Œ setup ç­‰å¾…
2. setupRenderEffect() ç»™å½“å‰ç»„ä»¶å®ä¾‹æ³¨å†Œ instance.update ç»„ä»¶æ›´æ–°æ—¶è°ƒç”¨çš„
   effect å‡½æ•°ã€‚


æ‰€ä»¥è¿™é‡Œå…ˆå¿½ç•¥ç¬¬ *2* ç‚¹ï¼Œåªè®²è®² mount é˜¶æ®µ ~setupComopnent()~ ä¸­å±æ€§åˆå§‹åŒ–å¤„ç†
(~setupComponent: initProps()~)ã€‚

#+begin_src typescript
export function setupComponent(
  instance: ComponentInternalInstance,
  isSSR = false
) {
  isInSSRComponentSetup = isSSR

  const { props, children, shapeFlag } = instance.vnode
  // è¿™é‡ŒåŒºåˆ†æœ‰æ— çŠ¶æ€ç»„ä»¶ï¼Œæ— çŠ¶æ€ç»„ä»¶å°±æ˜¯å‡½æ•°ç»„ä»¶ï¼Œå¯¹è±¡ç»„ä»¶æ˜¯æœ‰çŠ¶æ€ç»„ä»¶
  const isStateful = shapeFlag & ShapeFlags.STATEFUL_COMPONENT
  // è¿™é‡Œæ˜¯é‡ç‚¹ï¼Œ isSSR æ˜¯æœåŠ¡ç«¯æ¸²æŸ“çš„é—®é¢˜è¿™é‡Œæš‚ä¸è®¨è®º
  initProps(instance, props, isStateful, isSSR)
  initSlots(instance, children)

  const setupResult = isStateful
    ? setupStatefulComponent(instance, isSSR)
    : undefined
  isInSSRComponentSetup = false
  return setupResult
}
#+end_src

props åˆå§‹åŒ–æ“ä½œï¼š
#+begin_src typescript

export function initProps(
  instance: ComponentInternalInstance,
  rawProps: Data | null,
  isStateful: number, // result of bitwise flag comparison
  isSSR = false
) {
  const props: Data = {}
  const attrs: Data = {}
  def(attrs, InternalObjectKey, 1)
  setFullProps(instance, rawProps, props, attrs)
  // validation
  if (__DEV__) {
    validateProps(props, instance)
  }

  if (isStateful) {
    // stateful
    instance.props = isSSR ? props : shallowReactive(props)
  } else {
    if (!instance.type.props) {
      // functional w/ optional props, props === attrs
      instance.props = attrs
    } else {
      // functional w/ declared props
      instance.props = props
    }
  }
  instance.attrs = attrs
}
#+end_src

~def(attrs, InternalObjectKey, 1)~

   å¢åŠ : ~attrs.__vInterval = true~ å±æ€§

å‡½æ•°æœ€åçš„ isStateful åˆ¤æ–­æ˜¯æ£€æµ‹å‡½æ•°ç»„ä»¶æˆ–å¯¹è±¡ç»„ä»¶çš„ï¼Œå¦‚æœæ˜¯å‡½æ•°ç»„ä»¶ï¼Œä¸€èˆ¬æ²¡æœ‰
props å±æ€§ï¼Œé™¤éæ‰‹åŠ¨ç»™å‡½æ•°å¢åŠ ä¸€ä¸ª props ï¼Œä¸è¿‡ä¸€èˆ¬ä¸è¿™ä¹ˆç”¨ï¼Œå¦‚æœæœ‰ props å»ºè®®è¿˜
æ˜¯ç”¨å¯¹è±¡ç»„ä»¶ï¼Œæ‰€ä»¥è¿™é‡Œç­‰äºè¯´å‡½æ•°çš„ props å³ attrsï¼Œ attrs å³ propsã€‚

~setFullProps(instance, rawProps, props, attrs)~ è¿™ä¸ªæ˜¯é‡ç‚¹éƒ¨åˆ†ï¼Œå› ä¸ºåœ¨è¿™é‡Œå¼€å§‹
åŒºåˆ† props å’Œ attrsã€‚

#+begin_src typescript
function setFullProps(
  instance: ComponentInternalInstance,
  rawProps: Data | null,
  props: Data,
  attrs: Data
) {
  const [options, needCastKeys] = instance.propsOptions;
  if (rawProps) {
    for (const key in rawProps) {
      const value = rawProps[key];
      // key, ref are reserved and never passed down
      if (isReservedProp(key)) {
        continue;
      }
      // prop option names are camelized during normalization, so to support
      // kebab -> camel conversion here we need to camelize the key.
      let camelKey;
      if (options && hasOwn(options, (camelKey = camelize(key)))) {
        props[camelKey] = value;
      } else if (!isEmitListener(instance.emitsOptions, key)) {
        // Any non-declared (either as a prop or an emitted event) props are put
        // into a separate `attrs` object for spreading. Make sure to preserve
        // original key casing
        attrs[key] = value;
      }
    }
  }

  if (needCastKeys) {
    const rawCurrentProps = toRaw(props);
    for (let i = 0; i < needCastKeys.length; i++) {
      const key = needCastKeys[i];
      props[key] = resolvePropValue(
        options!,
        rawCurrentProps,
        key,
        rawCurrentProps[key],
        instance
      );
    }
  }
}
#+end_src

ä¸¤æ®µå¤„ç†ä»£ç 

1. rawProps å¤„ç†ï¼Œæ¥è‡ª compiler é˜¶æ®µç¼–è¯‘åçš„ vnode.props

   - key, ref ä¿ç•™å±æ€§ï¼Œå³ä¸ä¼šå¾€ä¸‹ä¼ é€’çš„å±æ€§ï¼Œç­‰äºæ˜¯ä½œç”¨äºè¯¥å…ƒç´ è‡ªèº«çš„

   - å…¶æ¬¡ï¼Œoptions -> instanceOptions ä¸­å­˜åœ¨çš„ key çš„å±æ€§å±äº *props*

   - æœ€åï¼Œé emits é€‰é¡¹ä¸­çš„å±æ€§å±äº *attrs*

2. needCastKeys ä¸€äº›éœ€è¦åˆå§‹åŒ–å€¼çš„å±æ€§çš„ keyï¼Œæ¯”å¦‚ï¼š Boolean ç±»å‹å€¼éœ€è¦åˆå§‹åŒ–æˆ
   ~false~ ã€‚


è¿™é‡Œæ¶‰åŠ options é‡Œçš„å±æ€§ ~instance.propsOptions~ è¿™ä¸ªåœ¨åˆå§‹åŒ–ç»„ä»¶å®ä¾‹çš„æ—¶å€™é¡ºå¸¦
åˆå§‹åŒ–äº†

~propsOptions: normalizePropsOptions(type, appContext)~

è¿™ä¸ªå€¼æ˜¯ä¸ªæ•°ç»„ï¼š ~[normalized, needCastKeys]~

*normalized* æ˜¯æ£€æµ‹ç±»å‹å®šä¹‰ä¹‹åçš„ propsï¼Œæ¯”å¦‚ï¼š

~{foo: [Boolean, String]}~ => ~normalized.foo = {type: [Boolean, String]}~

è¡¨ç¤º foo å¯ä»¥æ˜¯å¸ƒå°”ç±»å‹æˆ–è€…å­—ç¬¦ä¸²ç±»å‹ã€‚

~{foo: Function}~ => ~normalized.foo = { type: Function}~

*needCastKeys* è¡¨ç¤ºæ˜¯éœ€è¦å¯¹å±æ€§å€¼è¿›è¡Œå¤„ç†æˆ–è€…å«åˆå§‹åŒ–çš„keysï¼Œæ¯”å¦‚ï¼š ~{ foo:
Boolean, bar: { default: 1 } }~ é‚£ä¹ˆ foo çš„å€¼è¦åœ¨ ~setFullProps()~ é‡Œé¢è½¬æˆ
~false~ å€¼ï¼Œä»¥åŠ ~bar=1~ ï¼Œæ‰€ä»¥æœ€åè¿™ä¸ª props å®é™…ç­‰äº ~{foo: false,
bar: 1}~ è½¬æ¢è§„åˆ™åœ¨ ~setFullProps() -> resolvePropValue()~ ä¸­å®Œæˆã€‚

è§„åˆ™å¦‚ä¸‹ï¼š

1. ~{foo: { default: function() {/*...*/} }}~

   ç±»å‹ä¸æ˜¯ Function ä½†æ˜¯ default å€¼æ˜¯ä¸ªå‡½æ•°ï¼Œåˆ™éœ€è¦æ‰§è¡Œè¿™ä¸ªå‡½æ•°å¾—åˆ°è¯¥å±æ€§æœ€ç»ˆçš„
   é»˜è®¤å€¼ ~{foo: default(props) }~ ä¼ ç»™è¿™ä¸ªå‡½æ•°æ˜¯æ•´ä¸ª props å¯¹è±¡ã€‚

2. ~{foo: { default: function() {/*...*/}, type: Function }}~
   ç±»å‹æ˜¯å‡½æ•°ï¼Œè¡¨ç¤ºè¿™ä¸ªå±æ€§æœ¬èº«å°±æ˜¯å‡½æ•°ï¼Œä¸éœ€è¦åšä»€ä¹ˆå¤„ç†ï¼Œç›´æ¥å°†è¿™ä¸ªå‡½æ•°å½“åšé»˜
   è®¤å€¼å¤„ç† ~{foo: default}~

3. ~{foo: {default: 100}}~ ç­‰ä»·äº ~{foo: 100}~ default æ˜¯æ™®é€šç±»å‹çš„å…·ä½“å€¼çš„å¤„ç†

4. ~BooleanFlags.shouldCast~ è¡¨ç¤ºç±»å‹å®šä¹‰ä¸­æœ‰ ~Boolean~ ç±»å‹

   ~BooleanFlags.shouldCastTrue~ æ—¶å¯èƒ½æƒ…å†µ ~{foo: [Boolean, String]}~, ~{foo:
   [Boolean]}~ è¦ä¹ˆåªæœ‰ ~Boolean~ è¦ä¹ˆ ~Boolean~ åœ¨ ~String~ å‰é¢ï¼Œè¡¨ç¤ºä¼˜å…ˆçº§æ›´
   é«˜ã€‚

   å‡ ç§æƒ…å†µï¼š

   - ~<Child/>~, ~{foo: Boolean}~, ç»“æœ: ~{foo: false}~
   - ~<Child/ foo=true>~, ~{foo: Boolean}~, ç»“æœï¼š ~{foo: true}~
   - ~<Child foo=""/>~, ~{foo: [Boolean, String]}~, ç»“æœ: ~{foo: true}~

     è¿™ç§æƒ…å†µæ¯”è¾ƒç‰¹æ®Šï¼Œvue çš„å¤„ç†æ˜¯å½“ä¸¤ç§ç±»å‹éƒ½å­˜åœ¨ï¼Œä¸” Boolean åœ¨ String å‰é¢çš„
     æ—¶å€™ï¼Œä¼šå°†å€¼ä¸º ~""~ çš„ç©ºä¸²ï¼Œè½¬æˆ ~true~ ï¼Œä½œä¸º foo çš„é»˜è®¤å€¼ã€‚


æœ€åçš„ç»“æœä¼šåœ¨ ~comp.__props = [normalized, needCastKeys]~ ä¿å­˜ä¸€ä»½ã€‚

~normalizePropsOptions()~ å‡½æ•°å°±ä¸å±•å¼€åˆ†æäº†ï¼Œè¿™é‡Œæˆ‘ä»¬åªéœ€è¦çŸ¥é“ needCastKeys æ˜¯
åšä»€ä¹ˆçš„ã€‚

#+begin_quote
æ‰€ä»¥ï¼š

*props*: option api props é‡Œé¢çš„å­˜åœ¨çš„ key å½’ç»“ä¸º props

*attrs*: å…¶ä»–æƒ…å†µï¼Œé™¤äº† emits ä¸­å­˜åœ¨çš„ key ä¹‹å¤–éƒ½å½’ç»“ä¸º attrs
#+end_quote


* setup å‡½æ•°å¦‚ä½•è§£æï¼Ÿåˆæ˜¯å¦‚ä½•æ‰§è¡Œï¼Ÿ

æ‰§è¡Œæµç¨‹ï¼š

render ->

patch ->

processComponent ->

mountComponent ->

createComponentInstance -> åˆ›å»ºç»„ä»¶å®ä¾‹ï¼Œåˆå§‹åŒ–ç»„ä»¶ç»“æ„

setupComponent -> åˆå§‹åŒ– props å’Œ slotsï¼Œæœ‰çŠ¶æ€ç»„ä»¶å¤„ç†

setupStatefulComponent -> ç»™ instance.ctx å¢åŠ ä»£ç†ï¼Œæ‰§è¡Œ setup() å‡½æ•°

ä¹Ÿå°±æ˜¯è¯´åœ¨ setup æ‰§è¡Œä¹‹å‰ props, emits, slots éƒ½å·²ç»å¯ä»¥è®¿é—®äº†ï¼Œå¹¶ä¸”è¿™ä¸ªå‡½æ•°åœ¨ç»„
ä»¶æ•´ä¸ªç”Ÿå‘½å‘¨æœŸä¸­åªä¼šè°ƒç”¨ä¸€æ¬¡ï¼Œå› ä¸ºåé¢ç»„ä»¶çš„æ›´æ–°æ—¶ç›´æ¥è°ƒç”¨ ~instance.update~ æ¥
å®Œæˆï¼Œä¸ä¼šè¿›å…¥ mountComponent ã€‚

[[/vue/vue-mind-map-runtime-core-3-component/#setup][æ›´å¤šåˆ†æé“¾æ¥...]]
* component render å‡½æ•°åœ¨å“ªé‡Œæ‰§è¡Œï¼Ÿ
* TODO ShapeFlags çš„æº¯æºå’Œç”¨é€”ï¼Ÿ
æ¶‰åŠæ¨¡å—ï¼š ~runtime-core~
* æ ‡ç­¾(ç»„ä»¶)ç§ç±»(element, component, slot, template)
  :PROPERTIES:
  :COLUMNS:  %CUSTOM_ID[(Custom Id)]
  :CUSTOM_ID: shell_tag_types
  :END:

  @@html:<kbd>@@æ ‡ç­¾è§£ææ—¶çš„ TagType æ£€æµ‹@@html:</kbd>@@

  1. elementï¼ŒåŸç”Ÿæ ‡ç­¾ç±»å‹ï¼Œé»˜è®¤å€¼(å¦‚ï¼š =div= ï¼Œç»“åˆ ~options.isNativeTag()~)
  2. component ç±»å‹
     - ~!options.isNativeTag()~ ç±»å‹
     - æœ‰ ~v-is~ æŒ‡ä»¤çš„
     - core component ç±»å‹çš„(~[Teleport, Suspense, KeepAlive BaseTransition]~)
     - ~options.isBuiltInComponent()~ æŒ‡å®šçš„ç±»å‹
     - å¤§å†™å­—æ¯å¼€å¤´çš„æ ‡ç­¾(å¦‚ï¼š ~<Comp></Comp>~)
     - æ ‡ç­¾åç›´æ¥æ˜¯ *component* çš„(~<component></component>~)
  3. slot ç±»å‹
  4. template ç±»å‹

  è¿™äº›ç±»å‹çš„å®šä¹‰å’Œè§£æå‡åœ¨ [[/vue/vue3-source-code-compiler-core-parse_ts/#parse-parsetag][parseTag(context, type, parent)]] å‡½æ•°ä¸­å®Œæˆ

  æºç ï¼š

  #+begin_src typescript

    function parseTag(
        context: ParserContext,
        type: TagType,
        parent: ElementNode | undefined
    ): ElementNode {

        // ...çœç•¥ï¼Œè¿™é‡Œæˆ‘ä»¬ä¹‹å…³ç³» tagType

        let tagType = ElementTypes.ELEMENT
        const options = context.options
        if (!context.inVPre && !options.isCustomElement(tag)) {

            const hasVIs = props.some(
                p => p.type === NodeTypes.DIRECTIVE && p.name === 'is'
            )
            if (options.isNativeTag && !hasVIs) {
                // 1. å¦‚æœéåŸç”Ÿ(isNativeTag èŒƒç•´å†…çš„)ï¼Œè§†ä¸ºç»„ä»¶ç±»å‹ï¼Œä¼˜å…ˆçº§æœ€é«˜
                if (!options.isNativeTag(tag)) tagType = ElementTypes.COMPONENT
            } else if (
                // 2. æœ‰ v-is æŒ‡ä»¤çš„ç›´æ¥è§†ä¸ºç»„ä»¶ç±»å‹
                hasVIs ||
                    // 3. vue å†…ç½®çš„æ ¸å¿ƒç»„ä»¶<Teleport, Suspense, KeepAlive BaseTransition>
                    isCoreComponent(tag) ||
                    // 4. å†…ç½®ç»„ä»¶ï¼Œç”±å¼€å‘è€…å®šä¹‰çš„å†…ç½®ç±»å‹ï¼Ÿ
                    (options.isBuiltInComponent && options.isBuiltInComponent(tag)) ||
                    // 5. æ ‡ç­¾åä»¥å¤§å†™å­—æ¯å¼€å¤´çš„è§†ä¸º ç»„ä»¶ç±»å‹
                    /^[A-Z]/.test(tag) ||
                    // 6. æ ‡ç­¾åç›´æ¥æ˜¯ component çš„
                    tag === 'component'
            ) {
                tagType = ElementTypes.COMPONENT
            }

            if (tag === 'slot') {
                tagType = ElementTypes.SLOT
            } else if (
                tag === 'template' &&
                    props.some(p => {
                        return (
                            p.type === NodeTypes.DIRECTIVE && isSpecialTemplateDirective(p.name)
                        )
                    })
            ) {
                tagType = ElementTypes.TEMPLATE
            }
        }

        return {
            type: NodeTypes.ELEMENT,
            ns,
            tag,
            tagType,
            props,
            isSelfClosing,
            children: [],
            loc: getSelection(context, start),
            codegenNode: undefined // to be created during transform phase
        }
    }
  #+end_src

* æŒ‡ä»¤è§£æè¿‡ç¨‹

  [[/vue/vue3-source-code-compiler-core-parse_ts/#parse-parsechildren][parseChildren(context, mode, ancestors)]] ->
  [[/vue/vue3-source-code-compiler-core-parse_ts/#parse-parseelement][parseElement(context, mode)]] -> è§£æå‡ºæ•´ä¸ª element
  [[/vue/vue3-source-code-compiler-core-parse_ts/#parse-parsetag][parseTag(context, type, parent)]] -> è§£æå‡ºæ ‡ç­¾
  [[/vue/vue3-source-code-compiler-core-parse_ts/#parse-parseattributes][parseAttributes(context, type)]] -> è§£ææ‰€æœ‰å±æ€§
  [[/vue/vue3-source-code-compiler-core-parse_ts/#parse-parseattribute][parseAttribute(context, nameSet)]] -> è§£æå•ä¸ªå±æ€§ï¼Œç»“æœè¿”å›åˆ° props ä¸­

  è§£æçš„æ—¶å€™ä¼šæ ¹æ®æ˜ å°„å…³ç³»ï¼Œå°†ç¼©å†™è½¬æ¢æˆåç§°ã€‚

  å¦‚ï¼š
  | abbrev | name   |
  |--------+--------|
  | ~:~    | ~bind~ |
  | ~@~    | ~on~   |
  | ~#~    | ~slot~ |

  å¤„ç†ä»£ç ï¼š

  #+begin_src js
    // function: parseAttribute(...)
    // v-dir æˆ– ç¼©å†™
    if (!context.inVPre && /^(v-|:|@|#)/.test(name)) {
      // ?: éæ•è·ç»„
      // 1. (?:^v-([a-z0-9]+))? -> åŒ¹é… v-dir æŒ‡ä»¤ï¼Œéè´ªå©ªåŒ¹é…ï¼Œæ•è·æŒ‡ä»¤å
      //   ç§°([a-z0=9]+)
      // 2. (?:(?::|^@|^#)([^\.]+))? -> åŒ¹é… :,@,#
      // 3. (.+)?$ åŒ¹é…ä»»æ„å­—ç¬¦
      const match = /(?:^v-([a-z0-9]+))?(?:(?::|^@|^#)([^\.]+))?(.+)?$/i.exec(
        name
      )

      let arg

      // ([a-z0-9]+), ([^\.]+)
      if (match[2]) {
        const startOffset = name.indexOf(match[2])
        const loc = getSelection(
          context,
          getNewPosition(context, start, startOffset),
          getNewPosition(context, start, startOffset + match[2].length)
        )

        let content = match[2]
        let isStatic = true // é™æ€å±æ€§å

        // åŠ¨æ€å±æ€§åè§£æ
        if (content.startsWith('[')) {
          isStatic = false

          if (!content.endsWith(']')) {
            // å¦‚æœæ˜¯åŠ¨æ€å±æ€§åï¼Œå¿…é¡»æ˜¯ [varName] å½¢å¼
            emitError(
              context,
              ErrorCodes.X_MISSING_DYNAMIC_DIRECTIVE_ARGUMENT_END
            )
          }

          content = content.substr(1, content.length - 2)
        }

        arg = {
          type: NodeTypes.SIMPLE_EXPRESSION,
          content,
          isStatic,
          isConstant: isStatic,
          loc
        }
      }

      // å±æ€§æ˜¯å¦è¢«å¼•å·åŒ…èµ·æ¥
      if (value && value.isQuoted) {
        const valueLoc = value.loc
        valueLoc.start.offset++
        valueLoc.start.column++
        valueLoc.end = advancePositionWithClone(valueLoc.start, value.content)
        // å–å¼•å·å†…çš„æ‰€æœ‰å†…å®¹
        valueLoc.source = valueLoc.source.slice(1, -1)
      }

      return {
        type: NodeTypes.DIRECTIVE,
        // : -> v-bind, @ -> v-on, # -> v-slot çš„ç¼©å†™
        name:
        match[1] ||
          (name.startsWith(':') ? 'bind' : name.startsWith('@') ? 'on' : 'slot'),
        exp: value && {
          type: NodeTypes.SIMPLE_EXPRESSION,
          content: value.content,
          isStatic: false,
          isConstant: false,
          loc: value.loc
        },
        arg,
        // ä¿®é¥°ç¬¦å¤„ç†, v-bind.m1.m2 -> .m1.m2 -> ['m1', 'm2']
        modifiers: match[3] ? match[3].substr[1].split('.') : [],
        loc
      }
    }
  #+end_src

  å±æ€§è§£æçš„é¡ºåºæ˜¯ï¼Œå…ˆè§£æå±æ€§å€¼ï¼Œç„¶åè§£ææŒ‡ä»¤åç§°(~name~)ï¼Œå‚æ•°(~arg~)ï¼Œä¿®é¥°ç¬¦(~modifiers~)ã€‚

  [[/vue/vue-mind-map-house/#map-parse-with-directive][è¿™é‡Œæœ‰å®Œæ•´çš„è§£ææµç¨‹å›¾ï¼Œå¯ä»¥æ¸…æ™°å®Œæ•´çš„çŸ¥é“å±æ€§ï¼ŒæŒ‡ä»¤è§£ææ•´ä¸ªè¿‡ç¨‹ã€‚]]

* RCDATA/CDATA ç±»å‹è§£æ
  
  ç¤ºä¾‹ï¼š

  #+begin_src js
    const ast = baseParse(code, {
      getNamespace: (tag, parent) => {
        const ns = parent ? parent.ns : Namespaces.HTML;
        if (ns === Namespaces.HTML) {
          // åœ¨ parseChildren while ä¸­å°†è¿›å…¥ 
          // if (ns !== Namespaces.HTML) {
          //    node = parseCDATA(context, ancestors);
          //  }
          if (tag === "svg") {
            return Namespaces.HTML + 1;
          }
        }
        return ns;
      },
      getTextMode: ({ tag }) => {
        if (tag === "textarea") {
        // RCDATA æ ‡ç­¾å†…çš„å†…å®¹ä¼šç›´æ¥è¿›å…¥ parsText å½“åšæ–‡æœ¬è§£æ 
          return TextModes.RCDATA;
        }
        if (tag === "script") {
          return TextModes.RAWTEXT;
        }
        return TextModes.DATA;
      },
      ...options,
      onError: spy,
    });
  #+end_src

  è¿™ä¸¤ç§ç±»å‹æ•°æ®çš„è§£æå…³é”®æœ‰å‡ ç‚¹([[/vue/vue3-source-code-compiler-core-parse_ts/#test-parse-errors][è¯¦æƒ…è¯·ç§»æ­¥  ğŸ›¬ğŸ›¬ğŸ›¬]]  )ï¼š

  1. é‡å†™ getTextMode åœ¨é‡Œé¢å¯¹æœ‰éœ€è¦çš„ tag ç±»å‹æŒ‡å®šå…¶æ˜¯ä»€ä¹ˆ mode

     #+begin_src js
       function parseElement(...) {
         // ...

         const mode = context.options.getTextMode(element, parent);
         // RCDATA æ¨¡å¼ï¼Œå®ƒçš„å†…å®¹éƒ½ä¼šè¢«å½“åšæ–‡æœ¬æ¥å¤„ç†
         // å¦‚ï¼š<textarea></div></textarea> ä¸­çš„ `</div>` åªæ˜¯ä¸ªæ–‡æœ¬å†…å®¹
         const children = parseChildren(context, mode, ancestors);

         // ...
       }
     #+end_src

  2. é‡å†™ getNamespace å‘ŠçŸ¥ parseChildren èµ°å“ªä¸ªåˆ†æ”¯
     #+begin_src js
       else if (s.startsWith("<![CDATA[")) {
         if (ns !== Namespaces.HTML) {
           node = parseCDATA(context, ancestors);
         } else {
           emitError(context, ErrorCodes.CDATA_IN_HTML_CONTENT);
           node = parseBogusComment(context);
         }
       }
     #+end_src

* ä¸€ä¸ªè¾ƒå®Œæ•´çš„ AST ç»“æ„ï¼š

  #+begin_src js
    {
      "type":0, // root èŠ‚ç‚¹
      "children":[ // èŠ‚ç‚¹çš„å­ç»„ä»¶åˆ—è¡¨
        {
          "type":1, // æ ‡ç­¾ div
          "ns":0, // html
          "tag":"div", // æ ‡ç­¾å
          "tagType":0, // æ ‡ç­¾ç±»å‹ï¼šstart-0, end-1
          "props":[ // æ ‡ç­¾çš„å±æ€§åˆ—è¡¨ï¼Œå¦‚ï¼š v-bind:keyup.prevent.enter
            { // å±æ€§æœ‰å‡ ä¸ªé‡è¦çš„å±æ€§ï¼š
              // 1. name, æŒ‡ä»¤åç§°ï¼Œv- åŠç¼©å†™(#, @, :) ä¼šè½¬æ¢æˆå±æ€§åç§°ï¼Œå¦‚ï¼šbind
              // 2. exp è¡¨è¾¾å¼å³=å·åè¾¹çš„å€¼ï¼Œ
              // 3. arg å‚æ•°åï¼Œç»‘å®šçš„å˜é‡åï¼Œå¯èƒ½æ˜¯åŠ¨æ€çš„
              // 4. ä¿®é¥°ç¬¦ï¼Œmodifiers

              "type":7,
              "name":"bind",
              "exp":{
                "type":4,
                "content":"ok", // è¡¨è¾¾å¼å†…å®¹ï¼Œ
                "isStatic":false,
                "isConstant":false,
                "loc":{
                  "start":{
                    "column":34,
                    "line":1,
                    "offset":33
                  },
                  "end":{
                    "column":36,
                    "line":1,
                    "offset":35
                  },
                  "source":"ok"
                }
              },
              "arg":{ // å‚æ•°ï¼Œç»‘å®šçš„äº‹ä»¶æˆ–å˜é‡
                "type":4,
                "content":"keyup",
                "isStatic":true, // æ”¯æŒ v-bind:[varname] åŠ¨æ€å±æ€§
                "isConstant":true,
                "loc":{
                  "start":{
                    "column":13,
                    "line":1,
                    "offset":12
                  },
                  "end":{
                    "column":18,
                    "line":1,
                    "offset":17
                  },
                  "source":"keyup"
                }
              },
              "modifiers":[
                "prevent",
                "enter"
              ],
              "loc":{
                "start":{
                  "column":6,
                  "line":1,
                  "offset":5
                },
                "end":{
                  "column":37,
                  "line":1,
                  "offset":36
                },
                "source":"v-bind:keyup.prevent.enter="ok""
              }
            }
          ],
          "isSelfClosing":false,
          "children":[
            // å¦‚æœ <div>...</div> è¿˜æœ‰å†…å®¹è¿™é‡Œä¼šé€’å½’è§£æå‡ºå­èŠ‚ç‚¹ ast
          ],
          "loc":{
            "start":{
              "column":1,
              "line":1,
              "offset":0
            },
            "end":{
              "column":44,
              "line":1,
              "offset":43
            },
            "source":"<div v-bind:keyup.prevent.enter="ok"></div>"
          }
        }
      ],
      "loc":{
        "start":{
          "column":1,
          "line":1,
          "offset":0
        },
        "end":{
          "column":44,
          "line":1,
          "offset":43
        },
        "source":"<div v-bind:keyup.prevent.enter="ok"></div>"
      },
      "helpers":[

      ],
      "components":[

      ],
      "directives":[

      ],
      "hoists":[

      ],
      "imports":[

      ],
      "cached":0,
      "temps":0
    }
  #+end_src
