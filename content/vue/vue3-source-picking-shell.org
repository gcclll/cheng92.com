#+TITLE: Vue3.0源码系列 -- 知识点及问题汇总
#+DATE: <2020-09-01 21:40:31>
#+TAGS[]: vue, vue3, vuenext
#+CATEGORIES[]: vue
#+LANGUAGE: zh-cn
#+STARTUP: indent

#+begin_export html
<link href="https://fonts.goo~gleapis.com/cs~s2?family=ZCOOL+XiaoWei&display=swap" rel="stylesheet">
<kbd>
<font color="blue" size="3" style="font-family: 'ZCOOL XiaoWei', serif;">
  诗号：六道同坠，魔劫万千，引渡如来。
</font>
</kbd><br><br>
<script src="/js/utils.js"></script>
<script src="/js/vue/vue-next.js"></script>
<!--<script src="https://unpkg.com/vue@next"></script>-->
<script>
insertCssLink("https://unpkg.com/element-plus/lib/theme-chalk/index.css");
</script>
<script src="https://unpkg.com/element-plus/lib/index.full.js"></script>
<script src="/js/vue/tests/common.js"></script>
#+end_export

* vue diff 全过程源码解析？

[[https://www.cheng92.com/vue/vue-mind-map-runtime-core-2-render/#keyed-children][Vue3 源码头脑风暴之 7 ☞ runtime-core(2) - render - 若叶知秋]]


简述： 两个 while + if...else if...else

while1 检测 patch 头部相同节点

while2 检测 patch 尾部相同节点

经过两个 while 处理之后剩下的只有不规则的两组(new & old)序列。

if 执行新增

else if 执行删除

else 依照『最长增长序列』算法进行分析，决定是删除还是新增或插入。

最长增长序列：找到一组序列中路径最长的递增序列，比如：

~2,3,1,4~ 最长增长序列就是 ~2,3,4~

剩下的元素只可能比这个序列中的元素值小(如： ~1~)

* props ? attrs ?
:PROPERTIES:
:COLUMNS: %CUSTOM_ID[(Custom Id)]
:CUSTOM_ID: props-attrs
:END:

这两个属性在组件上是如何区分的？

当父组件给子组件传递属性的时候，最终都划分到那个对象上了？

先上实例，点击按钮可查看对应结果分析([[/js/vue/tests/7jAWzTeF1O.js]]):
#+begin_export html
<div id="x7jAWzTeF1O"></div>
<script src="/js/vue/tests/7jAWzTeF1O.js"></script>
#+end_export

首先，在 compiler 阶段所有属性都会被编译到 vnode.props 上，在 runtime-core patch
阶段才会区分 props 和 attrs，那这些属性又是如何做的区分，当开发的时候给子组件传
递的属性最终都放到哪个里面了？

这里面就得好好掰扯掰扯了！！！

根据之前的源码分析，组件 patch 流程: processComponent -> mountComponent 或
updateComponent 这里我们以组件首次渲染进入 mountComponent 为例。

mountComopnent 简化之后其实就两个部分：

1. setupComponent() 初始化 props, slots 执行 setup 等待
2. setupRenderEffect() 给当前组件实例注册 instance.update 组件更新时调用的
   effect 函数。


所以这里先忽略第 *2* 点，只讲讲 mount 阶段 ~setupComopnent()~ 中属性初始化处理
(~setupComponent: initProps()~)。

#+begin_src typescript
export function setupComponent(
  instance: ComponentInternalInstance,
  isSSR = false
) {
  isInSSRComponentSetup = isSSR

  const { props, children, shapeFlag } = instance.vnode
  // 这里区分有无状态组件，无状态组件就是函数组件，对象组件是有状态组件
  const isStateful = shapeFlag & ShapeFlags.STATEFUL_COMPONENT
  // 这里是重点， isSSR 是服务端渲染的问题这里暂不讨论
  initProps(instance, props, isStateful, isSSR)
  initSlots(instance, children)

  const setupResult = isStateful
    ? setupStatefulComponent(instance, isSSR)
    : undefined
  isInSSRComponentSetup = false
  return setupResult
}
#+end_src

props 初始化操作：
#+begin_src typescript

export function initProps(
  instance: ComponentInternalInstance,
  rawProps: Data | null,
  isStateful: number, // result of bitwise flag comparison
  isSSR = false
) {
  const props: Data = {}
  const attrs: Data = {}
  def(attrs, InternalObjectKey, 1)
  setFullProps(instance, rawProps, props, attrs)
  // validation
  if (__DEV__) {
    validateProps(props, instance)
  }

  if (isStateful) {
    // stateful
    instance.props = isSSR ? props : shallowReactive(props)
  } else {
    if (!instance.type.props) {
      // functional w/ optional props, props === attrs
      instance.props = attrs
    } else {
      // functional w/ declared props
      instance.props = props
    }
  }
  instance.attrs = attrs
}
#+end_src

~def(attrs, InternalObjectKey, 1)~

   增加: ~attrs.__vInterval = true~ 属性

函数最后的 isStateful 判断是检测函数组件或对象组件的，如果是函数组件，一般没有
props 属性，除非手动给函数增加一个 props ，不过一般不这么用，如果有 props 建议还
是用对象组件，所以这里等于说函数的 props 即 attrs， attrs 即 props。

~setFullProps(instance, rawProps, props, attrs)~ 这个是重点部分，因为在这里开始
区分 props 和 attrs。

#+begin_src typescript
function setFullProps(
  instance: ComponentInternalInstance,
  rawProps: Data | null,
  props: Data,
  attrs: Data
) {
  const [options, needCastKeys] = instance.propsOptions;
  if (rawProps) {
    for (const key in rawProps) {
      const value = rawProps[key];
      // key, ref are reserved and never passed down
      if (isReservedProp(key)) {
        continue;
      }
      // prop option names are camelized during normalization, so to support
      // kebab -> camel conversion here we need to camelize the key.
      let camelKey;
      if (options && hasOwn(options, (camelKey = camelize(key)))) {
        props[camelKey] = value;
      } else if (!isEmitListener(instance.emitsOptions, key)) {
        // Any non-declared (either as a prop or an emitted event) props are put
        // into a separate `attrs` object for spreading. Make sure to preserve
        // original key casing
        attrs[key] = value;
      }
    }
  }

  if (needCastKeys) {
    const rawCurrentProps = toRaw(props);
    for (let i = 0; i < needCastKeys.length; i++) {
      const key = needCastKeys[i];
      props[key] = resolvePropValue(
        options!,
        rawCurrentProps,
        key,
        rawCurrentProps[key],
        instance
      );
    }
  }
}
#+end_src

两段处理代码

1. rawProps 处理，来自 compiler 阶段编译后的 vnode.props

   - key, ref 保留属性，即不会往下传递的属性，等于是作用于该元素自身的

   - 其次，options -> instanceOptions 中存在的 key 的属性属于 *props*

   - 最后，非 emits 选项中的属性属于 *attrs*

2. needCastKeys 一些需要初始化值的属性的 key，比如： Boolean 类型值需要初始化成
   ~false~ 。


这里涉及 options 里的属性 ~instance.propsOptions~ 这个在初始化组件实例的时候顺带
初始化了

~propsOptions: normalizePropsOptions(type, appContext)~

这个值是个数组： ~[normalized, needCastKeys]~

*normalized* 是检测类型定义之后的 props，比如：

~{foo: [Boolean, String]}~ => ~normalized.foo = {type: [Boolean, String]}~

表示 foo 可以是布尔类型或者字符串类型。

~{foo: Function}~ => ~normalized.foo = { type: Function}~

*needCastKeys* 表示是需要对属性值进行处理或者叫初始化的keys，比如： ~{ foo:
Boolean, bar: { default: 1 } }~ 那么 foo 的值要在 ~setFullProps()~ 里面转成
~false~ 值，以及 ~bar=1~ ，所以最后这个 props 实际等于 ~{foo: false,
bar: 1}~ 转换规则在 ~setFullProps() -> resolvePropValue()~ 中完成。

规则如下：

1. ~{foo: { default: function() {/*...*/} }}~

   类型不是 Function 但是 default 值是个函数，则需要执行这个函数得到该属性最终的
   默认值 ~{foo: default(props) }~ 传给这个函数是整个 props 对象。

2. ~{foo: { default: function() {/*...*/}, type: Function }}~
   类型是函数，表示这个属性本身就是函数，不需要做什么处理，直接将这个函数当做默
   认值处理 ~{foo: default}~

3. ~{foo: {default: 100}}~ 等价于 ~{foo: 100}~ default 是普通类型的具体值的处理

4. ~BooleanFlags.shouldCast~ 表示类型定义中有 ~Boolean~ 类型

   ~BooleanFlags.shouldCastTrue~ 时可能情况 ~{foo: [Boolean, String]}~, ~{foo:
   [Boolean]}~ 要么只有 ~Boolean~ 要么 ~Boolean~ 在 ~String~ 前面，表示优先级更
   高。

   几种情况：

   - ~<Child/>~, ~{foo: Boolean}~, 结果: ~{foo: false}~
   - ~<Child/ foo=true>~, ~{foo: Boolean}~, 结果： ~{foo: true}~
   - ~<Child foo=""/>~, ~{foo: [Boolean, String]}~, 结果: ~{foo: true}~

     这种情况比较特殊，vue 的处理是当两种类型都存在，且 Boolean 在 String 前面的
     时候，会将值为 ~""~ 的空串，转成 ~true~ ，作为 foo 的默认值。


最后的结果会在 ~comp.__props = [normalized, needCastKeys]~ 保存一份。

~normalizePropsOptions()~ 函数就不展开分析了，这里我们只需要知道 needCastKeys 是
做什么的。

#+begin_quote
所以：

*props*: option api props 里面的存在的 key 归结为 props

*attrs*: 其他情况，除了 emits 中存在的 key 之外都归结为 attrs
#+end_quote


* setup 函数如何解析？又是如何执行？

执行流程：

render ->

patch ->

processComponent ->

mountComponent ->

createComponentInstance -> 创建组件实例，初始化组件结构

setupComponent -> 初始化 props 和 slots，有状态组件处理

setupStatefulComponent -> 给 instance.ctx 增加代理，执行 setup() 函数

也就是说在 setup 执行之前 props, emits, slots 都已经可以访问了，并且这个函数在组
件整个生命周期中只会调用一次，因为后面组件的更新时直接调用 ~instance.update~ 来
完成，不会进入 mountComponent 。

[[/vue/vue-mind-map-runtime-core-3-component/#setup][更多分析链接...]]
* component render 函数在哪里执行？
* TODO ShapeFlags 的溯源和用途？
涉及模块： ~runtime-core~
* 标签(组件)种类(element, component, slot, template)
  :PROPERTIES:
  :COLUMNS:  %CUSTOM_ID[(Custom Id)]
  :CUSTOM_ID: shell_tag_types
  :END:

  @@html:<kbd>@@标签解析时的 TagType 检测@@html:</kbd>@@

  1. element，原生标签类型，默认值(如： =div= ，结合 ~options.isNativeTag()~)
  2. component 类型
     - ~!options.isNativeTag()~ 类型
     - 有 ~v-is~ 指令的
     - core component 类型的(~[Teleport, Suspense, KeepAlive BaseTransition]~)
     - ~options.isBuiltInComponent()~ 指定的类型
     - 大写字母开头的标签(如： ~<Comp></Comp>~)
     - 标签名直接是 *component* 的(~<component></component>~)
  3. slot 类型
  4. template 类型

  这些类型的定义和解析均在 [[/vue/vue3-source-code-compiler-core-parse_ts/#parse-parsetag][parseTag(context, type, parent)]] 函数中完成

  源码：

  #+begin_src typescript

    function parseTag(
        context: ParserContext,
        type: TagType,
        parent: ElementNode | undefined
    ): ElementNode {

        // ...省略，这里我们之关系 tagType

        let tagType = ElementTypes.ELEMENT
        const options = context.options
        if (!context.inVPre && !options.isCustomElement(tag)) {

            const hasVIs = props.some(
                p => p.type === NodeTypes.DIRECTIVE && p.name === 'is'
            )
            if (options.isNativeTag && !hasVIs) {
                // 1. 如果非原生(isNativeTag 范畴内的)，视为组件类型，优先级最高
                if (!options.isNativeTag(tag)) tagType = ElementTypes.COMPONENT
            } else if (
                // 2. 有 v-is 指令的直接视为组件类型
                hasVIs ||
                    // 3. vue 内置的核心组件<Teleport, Suspense, KeepAlive BaseTransition>
                    isCoreComponent(tag) ||
                    // 4. 内置组件，由开发者定义的内置类型？
                    (options.isBuiltInComponent && options.isBuiltInComponent(tag)) ||
                    // 5. 标签名以大写字母开头的视为 组件类型
                    /^[A-Z]/.test(tag) ||
                    // 6. 标签名直接是 component 的
                    tag === 'component'
            ) {
                tagType = ElementTypes.COMPONENT
            }

            if (tag === 'slot') {
                tagType = ElementTypes.SLOT
            } else if (
                tag === 'template' &&
                    props.some(p => {
                        return (
                            p.type === NodeTypes.DIRECTIVE && isSpecialTemplateDirective(p.name)
                        )
                    })
            ) {
                tagType = ElementTypes.TEMPLATE
            }
        }

        return {
            type: NodeTypes.ELEMENT,
            ns,
            tag,
            tagType,
            props,
            isSelfClosing,
            children: [],
            loc: getSelection(context, start),
            codegenNode: undefined // to be created during transform phase
        }
    }
  #+end_src

* 指令解析过程

  [[/vue/vue3-source-code-compiler-core-parse_ts/#parse-parsechildren][parseChildren(context, mode, ancestors)]] ->
  [[/vue/vue3-source-code-compiler-core-parse_ts/#parse-parseelement][parseElement(context, mode)]] -> 解析出整个 element
  [[/vue/vue3-source-code-compiler-core-parse_ts/#parse-parsetag][parseTag(context, type, parent)]] -> 解析出标签
  [[/vue/vue3-source-code-compiler-core-parse_ts/#parse-parseattributes][parseAttributes(context, type)]] -> 解析所有属性
  [[/vue/vue3-source-code-compiler-core-parse_ts/#parse-parseattribute][parseAttribute(context, nameSet)]] -> 解析单个属性，结果返回到 props 中

  解析的时候会根据映射关系，将缩写转换成名称。

  如：
  | abbrev | name   |
  |--------+--------|
  | ~:~    | ~bind~ |
  | ~@~    | ~on~   |
  | ~#~    | ~slot~ |

  处理代码：

  #+begin_src js
    // function: parseAttribute(...)
    // v-dir 或 缩写
    if (!context.inVPre && /^(v-|:|@|#)/.test(name)) {
      // ?: 非捕获组
      // 1. (?:^v-([a-z0-9]+))? -> 匹配 v-dir 指令，非贪婪匹配，捕获指令名
      //   称([a-z0=9]+)
      // 2. (?:(?::|^@|^#)([^\.]+))? -> 匹配 :,@,#
      // 3. (.+)?$ 匹配任意字符
      const match = /(?:^v-([a-z0-9]+))?(?:(?::|^@|^#)([^\.]+))?(.+)?$/i.exec(
        name
      )

      let arg

      // ([a-z0-9]+), ([^\.]+)
      if (match[2]) {
        const startOffset = name.indexOf(match[2])
        const loc = getSelection(
          context,
          getNewPosition(context, start, startOffset),
          getNewPosition(context, start, startOffset + match[2].length)
        )

        let content = match[2]
        let isStatic = true // 静态属性名

        // 动态属性名解析
        if (content.startsWith('[')) {
          isStatic = false

          if (!content.endsWith(']')) {
            // 如果是动态属性名，必须是 [varName] 形式
            emitError(
              context,
              ErrorCodes.X_MISSING_DYNAMIC_DIRECTIVE_ARGUMENT_END
            )
          }

          content = content.substr(1, content.length - 2)
        }

        arg = {
          type: NodeTypes.SIMPLE_EXPRESSION,
          content,
          isStatic,
          isConstant: isStatic,
          loc
        }
      }

      // 属性是否被引号包起来
      if (value && value.isQuoted) {
        const valueLoc = value.loc
        valueLoc.start.offset++
        valueLoc.start.column++
        valueLoc.end = advancePositionWithClone(valueLoc.start, value.content)
        // 取引号内的所有内容
        valueLoc.source = valueLoc.source.slice(1, -1)
      }

      return {
        type: NodeTypes.DIRECTIVE,
        // : -> v-bind, @ -> v-on, # -> v-slot 的缩写
        name:
        match[1] ||
          (name.startsWith(':') ? 'bind' : name.startsWith('@') ? 'on' : 'slot'),
        exp: value && {
          type: NodeTypes.SIMPLE_EXPRESSION,
          content: value.content,
          isStatic: false,
          isConstant: false,
          loc: value.loc
        },
        arg,
        // 修饰符处理, v-bind.m1.m2 -> .m1.m2 -> ['m1', 'm2']
        modifiers: match[3] ? match[3].substr[1].split('.') : [],
        loc
      }
    }
  #+end_src

  属性解析的顺序是，先解析属性值，然后解析指令名称(~name~)，参数(~arg~)，修饰符(~modifiers~)。

  [[/vue/vue-mind-map-house/#map-parse-with-directive][这里有完整的解析流程图，可以清晰完整的知道属性，指令解析整个过程。]]

* RCDATA/CDATA 类型解析
  
  示例：

  #+begin_src js
    const ast = baseParse(code, {
      getNamespace: (tag, parent) => {
        const ns = parent ? parent.ns : Namespaces.HTML;
        if (ns === Namespaces.HTML) {
          // 在 parseChildren while 中将进入 
          // if (ns !== Namespaces.HTML) {
          //    node = parseCDATA(context, ancestors);
          //  }
          if (tag === "svg") {
            return Namespaces.HTML + 1;
          }
        }
        return ns;
      },
      getTextMode: ({ tag }) => {
        if (tag === "textarea") {
        // RCDATA 标签内的内容会直接进入 parsText 当做文本解析 
          return TextModes.RCDATA;
        }
        if (tag === "script") {
          return TextModes.RAWTEXT;
        }
        return TextModes.DATA;
      },
      ...options,
      onError: spy,
    });
  #+end_src

  这两种类型数据的解析关键有几点([[/vue/vue3-source-code-compiler-core-parse_ts/#test-parse-errors][详情请移步  🛬🛬🛬]]  )：

  1. 重写 getTextMode 在里面对有需要的 tag 类型指定其是什么 mode

     #+begin_src js
       function parseElement(...) {
         // ...

         const mode = context.options.getTextMode(element, parent);
         // RCDATA 模式，它的内容都会被当做文本来处理
         // 如：<textarea></div></textarea> 中的 `</div>` 只是个文本内容
         const children = parseChildren(context, mode, ancestors);

         // ...
       }
     #+end_src

  2. 重写 getNamespace 告知 parseChildren 走哪个分支
     #+begin_src js
       else if (s.startsWith("<![CDATA[")) {
         if (ns !== Namespaces.HTML) {
           node = parseCDATA(context, ancestors);
         } else {
           emitError(context, ErrorCodes.CDATA_IN_HTML_CONTENT);
           node = parseBogusComment(context);
         }
       }
     #+end_src

* 一个较完整的 AST 结构：

  #+begin_src js
    {
      "type":0, // root 节点
      "children":[ // 节点的子组件列表
        {
          "type":1, // 标签 div
          "ns":0, // html
          "tag":"div", // 标签名
          "tagType":0, // 标签类型：start-0, end-1
          "props":[ // 标签的属性列表，如： v-bind:keyup.prevent.enter
            { // 属性有几个重要的属性：
              // 1. name, 指令名称，v- 及缩写(#, @, :) 会转换成属性名称，如：bind
              // 2. exp 表达式即=号后边的值，
              // 3. arg 参数名，绑定的变量名，可能是动态的
              // 4. 修饰符，modifiers

              "type":7,
              "name":"bind",
              "exp":{
                "type":4,
                "content":"ok", // 表达式内容，
                "isStatic":false,
                "isConstant":false,
                "loc":{
                  "start":{
                    "column":34,
                    "line":1,
                    "offset":33
                  },
                  "end":{
                    "column":36,
                    "line":1,
                    "offset":35
                  },
                  "source":"ok"
                }
              },
              "arg":{ // 参数，绑定的事件或变量
                "type":4,
                "content":"keyup",
                "isStatic":true, // 支持 v-bind:[varname] 动态属性
                "isConstant":true,
                "loc":{
                  "start":{
                    "column":13,
                    "line":1,
                    "offset":12
                  },
                  "end":{
                    "column":18,
                    "line":1,
                    "offset":17
                  },
                  "source":"keyup"
                }
              },
              "modifiers":[
                "prevent",
                "enter"
              ],
              "loc":{
                "start":{
                  "column":6,
                  "line":1,
                  "offset":5
                },
                "end":{
                  "column":37,
                  "line":1,
                  "offset":36
                },
                "source":"v-bind:keyup.prevent.enter="ok""
              }
            }
          ],
          "isSelfClosing":false,
          "children":[
            // 如果 <div>...</div> 还有内容这里会递归解析出子节点 ast
          ],
          "loc":{
            "start":{
              "column":1,
              "line":1,
              "offset":0
            },
            "end":{
              "column":44,
              "line":1,
              "offset":43
            },
            "source":"<div v-bind:keyup.prevent.enter="ok"></div>"
          }
        }
      ],
      "loc":{
        "start":{
          "column":1,
          "line":1,
          "offset":0
        },
        "end":{
          "column":44,
          "line":1,
          "offset":43
        },
        "source":"<div v-bind:keyup.prevent.enter="ok"></div>"
      },
      "helpers":[

      ],
      "components":[

      ],
      "directives":[

      ],
      "hoists":[

      ],
      "imports":[

      ],
      "cached":0,
      "temps":0
    }
  #+end_src
