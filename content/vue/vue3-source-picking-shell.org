#+TITLE: Vue3.0æºç ç³»åˆ— -- é‡è¦çŸ¥è¯†ç‚¹æ¡æ¼
#+DATE: <2020-09-01 21:40:31>
#+TAGS[]: vue, vue3, vuenext
#+CATEGORIES[]: vue
#+LANGUAGE: zh-cn
#+STARTUP: indent

* packages(æ¨¡å—åˆ—è¡¨):

  æ‰€æœ‰æ¨¡å—ä»¥â€œ *åŒ…* â€çš„å½¢å¼å­˜åœ¨ã€‚

  + compiler-core/src
    + ast.ts -> [[/vue/vue3-source-code-compiler-core-ast_ts/][æŠ½è±¡è¯­æ³•æ ‘å¤„ç†æ–‡ä»¶]]
    + codegen.ts
    + compiler.ts -> [[/vue/vue3-source-code-compiler-core-parse_ts/][æ¨¡æ¿ç¼–è¯‘å™¨ï¼Œå°†æ ‡ç­¾æ¨¡æ¿è§£ææˆ ast å¯¹è±¡]]ã€‚
    + errors.ts
    + index.ts
    + options.ts
    + parse.ts
    + runtimeHelpers.ts
    + transform.ts
    + transforms/
      + hoistStatic.ts
      + noopDirectiveTransform.ts
      + transformElement.ts
      + transformExpression.ts
      + transformSlotOutlet.ts
      + transformText.ts
      + vBind.ts
      + vFor.ts
      + vIf.ts
      + vModel.ts
      + vOn.ts
      + vOnce.ts
      + vSlot.ts
    + utils.ts
  + compiler-dom
  + compiler-sfc
  + compiler-ssr
  + global.d.ts
  + reactivity
  + runtime-core
  + runtime-dom
  + runtime-test
  + server-renderer
  + shared
  + size-check
  + template-explorer
  + vue
* ä¸€ä¸ªè¾ƒå®Œæ•´çš„ AST ç»“æ„ï¼š

  #+begin_src js
    {
      "type":0, // root èŠ‚ç‚¹
      "children":[ // èŠ‚ç‚¹çš„å­ç»„ä»¶åˆ—è¡¨
        {
          "type":1, // æ ‡ç­¾ div
          "ns":0, // html
          "tag":"div", // æ ‡ç­¾å
          "tagType":0, // æ ‡ç­¾ç±»å‹ï¼šstart-0, end-1
          "props":[ // æ ‡ç­¾çš„å±æ€§åˆ—è¡¨ï¼Œå¦‚ï¼š v-bind:keyup.prevent.enter
            { // å±æ€§æœ‰å‡ ä¸ªé‡è¦çš„å±æ€§ï¼š
              // 1. name, æŒ‡ä»¤åç§°ï¼Œv- åŠç¼©å†™(#, @, :) ä¼šè½¬æ¢æˆå±æ€§åç§°ï¼Œå¦‚ï¼šbind
              // 2. exp è¡¨è¾¾å¼å³=å·åè¾¹çš„å€¼ï¼Œ
              // 3. arg å‚æ•°åï¼Œç»‘å®šçš„å˜é‡åï¼Œå¯èƒ½æ˜¯åŠ¨æ€çš„
              // 4. ä¿®é¥°ç¬¦ï¼Œmodifiers

              "type":7,
              "name":"bind",
              "exp":{
                "type":4,
                "content":"ok", // è¡¨è¾¾å¼å†…å®¹ï¼Œ
                "isStatic":false,
                "isConstant":false,
                "loc":{
                  "start":{
                    "column":34,
                    "line":1,
                    "offset":33
                  },
                  "end":{
                    "column":36,
                    "line":1,
                    "offset":35
                  },
                  "source":"ok"
                }
              },
              "arg":{ // å‚æ•°ï¼Œç»‘å®šçš„äº‹ä»¶æˆ–å˜é‡
                "type":4,
                "content":"keyup",
                "isStatic":true, // æ”¯æŒ v-bind:[varname] åŠ¨æ€å±æ€§
                "isConstant":true,
                "loc":{
                  "start":{
                    "column":13,
                    "line":1,
                    "offset":12
                  },
                  "end":{
                    "column":18,
                    "line":1,
                    "offset":17
                  },
                  "source":"keyup"
                }
              },
              "modifiers":[
                "prevent",
                "enter"
              ],
              "loc":{
                "start":{
                  "column":6,
                  "line":1,
                  "offset":5
                },
                "end":{
                  "column":37,
                  "line":1,
                  "offset":36
                },
                "source":"v-bind:keyup.prevent.enter="ok""
              }
            }
          ],
          "isSelfClosing":false,
          "children":[
            // å¦‚æœ <div>...</div> è¿˜æœ‰å†…å®¹è¿™é‡Œä¼šé€’å½’è§£æå‡ºå­èŠ‚ç‚¹ ast
          ],
          "loc":{
            "start":{
              "column":1,
              "line":1,
              "offset":0
            },
            "end":{
              "column":44,
              "line":1,
              "offset":43
            },
            "source":"<div v-bind:keyup.prevent.enter="ok"></div>"
          }
        }
      ],
      "loc":{
        "start":{
          "column":1,
          "line":1,
          "offset":0
        },
        "end":{
          "column":44,
          "line":1,
          "offset":43
        },
        "source":"<div v-bind:keyup.prevent.enter="ok"></div>"
      },
      "helpers":[

      ],
      "components":[

      ],
      "directives":[

      ],
      "hoists":[

      ],
      "imports":[

      ],
      "cached":0,
      "temps":0
    }
  #+end_src


* æ ‡ç­¾(ç»„ä»¶)ç§ç±»(element, component, slot, template)
  :PROPERTIES:
  :COLUMNS:  %CUSTOM_ID[(Custom Id)]
  :CUSTOM_ID: shell_tag_types
  :END:

  @@html:<kbd>@@æ ‡ç­¾è§£ææ—¶çš„ TagType æ£€æµ‹@@html:</kbd>@@

  1. elementï¼ŒåŸç”Ÿæ ‡ç­¾ç±»å‹ï¼Œé»˜è®¤å€¼(å¦‚ï¼š =div= ï¼Œç»“åˆ ~options.isNativeTag()~)
  2. component ç±»å‹
     - ~!options.isNativeTag()~ ç±»å‹
     - æœ‰ ~v-is~ æŒ‡ä»¤çš„
     - core component ç±»å‹çš„(~[Teleport, Suspense, KeepAlive BaseTransition]~)
     - ~options.isBuiltInComponent()~ æŒ‡å®šçš„ç±»å‹
     - å¤§å†™å­—æ¯å¼€å¤´çš„æ ‡ç­¾(å¦‚ï¼š ~<Comp></Comp>~)
     - æ ‡ç­¾åç›´æ¥æ˜¯ *component* çš„(~<component></component>~)
  3. slot ç±»å‹
  4. template ç±»å‹

  è¿™äº›ç±»å‹çš„å®šä¹‰å’Œè§£æå‡åœ¨ [[/vue/vue3-source-code-compiler-core-parse_ts/#parse-parsetag][parseTag(context, type, parent)]] å‡½æ•°ä¸­å®Œæˆ

  æºç ï¼š

  #+begin_src typescript

    function parseTag(
        context: ParserContext,
        type: TagType,
        parent: ElementNode | undefined
    ): ElementNode {

        // ...çœç•¥ï¼Œè¿™é‡Œæˆ‘ä»¬ä¹‹å…³ç³» tagType

        let tagType = ElementTypes.ELEMENT
        const options = context.options
        if (!context.inVPre && !options.isCustomElement(tag)) {

            const hasVIs = props.some(
                p => p.type === NodeTypes.DIRECTIVE && p.name === 'is'
            )
            if (options.isNativeTag && !hasVIs) {
                // 1. å¦‚æœéåŸç”Ÿ(isNativeTag èŒƒç•´å†…çš„)ï¼Œè§†ä¸ºç»„ä»¶ç±»å‹ï¼Œä¼˜å…ˆçº§æœ€é«˜
                if (!options.isNativeTag(tag)) tagType = ElementTypes.COMPONENT
            } else if (
                // 2. æœ‰ v-is æŒ‡ä»¤çš„ç›´æ¥è§†ä¸ºç»„ä»¶ç±»å‹
                hasVIs ||
                    // 3. vue å†…ç½®çš„æ ¸å¿ƒç»„ä»¶<Teleport, Suspense, KeepAlive BaseTransition>
                    isCoreComponent(tag) ||
                    // 4. å†…ç½®ç»„ä»¶ï¼Œç”±å¼€å‘è€…å®šä¹‰çš„å†…ç½®ç±»å‹ï¼Ÿ
                    (options.isBuiltInComponent && options.isBuiltInComponent(tag)) ||
                    // 5. æ ‡ç­¾åä»¥å¤§å†™å­—æ¯å¼€å¤´çš„è§†ä¸º ç»„ä»¶ç±»å‹
                    /^[A-Z]/.test(tag) ||
                    // 6. æ ‡ç­¾åç›´æ¥æ˜¯ component çš„
                    tag === 'component'
            ) {
                tagType = ElementTypes.COMPONENT
            }

            if (tag === 'slot') {
                tagType = ElementTypes.SLOT
            } else if (
                tag === 'template' &&
                    props.some(p => {
                        return (
                            p.type === NodeTypes.DIRECTIVE && isSpecialTemplateDirective(p.name)
                        )
                    })
            ) {
                tagType = ElementTypes.TEMPLATE
            }
        }

        return {
            type: NodeTypes.ELEMENT,
            ns,
            tag,
            tagType,
            props,
            isSelfClosing,
            children: [],
            loc: getSelection(context, start),
            codegenNode: undefined // to be created during transform phase
        }
    }
  #+end_src

* æŒ‡ä»¤è§£æè¿‡ç¨‹

  [[/vue/vue3-source-code-compiler-core-parse_ts/#parse-parsechildren][parseChildren(context, mode, ancestors)]] ->
  [[/vue/vue3-source-code-compiler-core-parse_ts/#parse-parseelement][parseElement(context, mode)]] -> è§£æå‡ºæ•´ä¸ª element
  [[/vue/vue3-source-code-compiler-core-parse_ts/#parse-parsetag][parseTag(context, type, parent)]] -> è§£æå‡ºæ ‡ç­¾
  [[/vue/vue3-source-code-compiler-core-parse_ts/#parse-parseattributes][parseAttributes(context, type)]] -> è§£ææ‰€æœ‰å±æ€§
  [[/vue/vue3-source-code-compiler-core-parse_ts/#parse-parseattribute][parseAttribute(context, nameSet)]] -> è§£æå•ä¸ªå±æ€§ï¼Œç»“æœè¿”å›åˆ° props ä¸­

  è§£æçš„æ—¶å€™ä¼šæ ¹æ®æ˜ å°„å…³ç³»ï¼Œå°†ç¼©å†™è½¬æ¢æˆåç§°ã€‚

  å¦‚ï¼š
  | abbrev | name   |
  |--------+--------|
  | ~:~    | ~bind~ |
  | ~@~    | ~on~   |
  | ~#~    | ~slot~ |

  å¤„ç†ä»£ç ï¼š

  #+begin_src js
    // function: parseAttribute(...)
    // v-dir æˆ– ç¼©å†™
    if (!context.inVPre && /^(v-|:|@|#)/.test(name)) {
      // ?: éæ•è·ç»„
      // 1. (?:^v-([a-z0-9]+))? -> åŒ¹é… v-dir æŒ‡ä»¤ï¼Œéè´ªå©ªåŒ¹é…ï¼Œæ•è·æŒ‡ä»¤å
      //   ç§°([a-z0=9]+)
      // 2. (?:(?::|^@|^#)([^\.]+))? -> åŒ¹é… :,@,#
      // 3. (.+)?$ åŒ¹é…ä»»æ„å­—ç¬¦
      const match = /(?:^v-([a-z0-9]+))?(?:(?::|^@|^#)([^\.]+))?(.+)?$/i.exec(
        name
      )

      let arg

      // ([a-z0-9]+), ([^\.]+)
      if (match[2]) {
        const startOffset = name.indexOf(match[2])
        const loc = getSelection(
          context,
          getNewPosition(context, start, startOffset),
          getNewPosition(context, start, startOffset + match[2].length)
        )

        let content = match[2]
        let isStatic = true // é™æ€å±æ€§å

        // åŠ¨æ€å±æ€§åè§£æ
        if (content.startsWith('[')) {
          isStatic = false

          if (!content.endsWith(']')) {
            // å¦‚æœæ˜¯åŠ¨æ€å±æ€§åï¼Œå¿…é¡»æ˜¯ [varName] å½¢å¼
            emitError(
              context,
              ErrorCodes.X_MISSING_DYNAMIC_DIRECTIVE_ARGUMENT_END
            )
          }

          content = content.substr(1, content.length - 2)
        }

        arg = {
          type: NodeTypes.SIMPLE_EXPRESSION,
          content,
          isStatic,
          isConstant: isStatic,
          loc
        }
      }

      // å±æ€§æ˜¯å¦è¢«å¼•å·åŒ…èµ·æ¥
      if (value && value.isQuoted) {
        const valueLoc = value.loc
        valueLoc.start.offset++
        valueLoc.start.column++
        valueLoc.end = advancePositionWithClone(valueLoc.start, value.content)
        // å–å¼•å·å†…çš„æ‰€æœ‰å†…å®¹
        valueLoc.source = valueLoc.source.slice(1, -1)
      }

      return {
        type: NodeTypes.DIRECTIVE,
        // : -> v-bind, @ -> v-on, # -> v-slot çš„ç¼©å†™
        name:
        match[1] ||
          (name.startsWith(':') ? 'bind' : name.startsWith('@') ? 'on' : 'slot'),
        exp: value && {
          type: NodeTypes.SIMPLE_EXPRESSION,
          content: value.content,
          isStatic: false,
          isConstant: false,
          loc: value.loc
        },
        arg,
        // ä¿®é¥°ç¬¦å¤„ç†, v-bind.m1.m2 -> .m1.m2 -> ['m1', 'm2']
        modifiers: match[3] ? match[3].substr[1].split('.') : [],
        loc
      }
    }
  #+end_src

  å±æ€§è§£æçš„é¡ºåºæ˜¯ï¼Œå…ˆè§£æå±æ€§å€¼ï¼Œç„¶åè§£ææŒ‡ä»¤åç§°(~name~)ï¼Œå‚æ•°(~arg~)ï¼Œä¿®é¥°ç¬¦(~modifiers~)ã€‚

  [[/vue/vue-mind-map-house/#map-parse-with-directive][è¿™é‡Œæœ‰å®Œæ•´çš„è§£ææµç¨‹å›¾ï¼Œå¯ä»¥æ¸…æ™°å®Œæ•´çš„çŸ¥é“å±æ€§ï¼ŒæŒ‡ä»¤è§£ææ•´ä¸ªè¿‡ç¨‹ã€‚]]

* RCDATA/CDATA ç±»å‹è§£æ
  
  ç¤ºä¾‹ï¼š

  #+begin_src js
    const ast = baseParse(code, {
      getNamespace: (tag, parent) => {
        const ns = parent ? parent.ns : Namespaces.HTML;
        if (ns === Namespaces.HTML) {
          // åœ¨ parseChildren while ä¸­å°†è¿›å…¥ 
          // if (ns !== Namespaces.HTML) {
          //    node = parseCDATA(context, ancestors);
          //  }
          if (tag === "svg") {
            return Namespaces.HTML + 1;
          }
        }
        return ns;
      },
      getTextMode: ({ tag }) => {
        if (tag === "textarea") {
        // RCDATA æ ‡ç­¾å†…çš„å†…å®¹ä¼šç›´æ¥è¿›å…¥ parsText å½“åšæ–‡æœ¬è§£æ 
          return TextModes.RCDATA;
        }
        if (tag === "script") {
          return TextModes.RAWTEXT;
        }
        return TextModes.DATA;
      },
      ...options,
      onError: spy,
    });
  #+end_src

  è¿™ä¸¤ç§ç±»å‹æ•°æ®çš„è§£æå…³é”®æœ‰å‡ ç‚¹([[/vue/vue3-source-code-compiler-core-parse_ts/#test-parse-errors][è¯¦æƒ…è¯·ç§»æ­¥  ğŸ›¬ğŸ›¬ğŸ›¬]]  )ï¼š

  1. é‡å†™ getTextMode åœ¨é‡Œé¢å¯¹æœ‰éœ€è¦çš„ tag ç±»å‹æŒ‡å®šå…¶æ˜¯ä»€ä¹ˆ mode

     #+begin_src js
       function parseElement(...) {
         // ...

         const mode = context.options.getTextMode(element, parent);
         // RCDATA æ¨¡å¼ï¼Œå®ƒçš„å†…å®¹éƒ½ä¼šè¢«å½“åšæ–‡æœ¬æ¥å¤„ç†
         // å¦‚ï¼š<textarea></div></textarea> ä¸­çš„ `</div>` åªæ˜¯ä¸ªæ–‡æœ¬å†…å®¹
         const children = parseChildren(context, mode, ancestors);

         // ...
       }
     #+end_src

  2. é‡å†™ getNamespace å‘ŠçŸ¥ parseChildren èµ°å“ªä¸ªåˆ†æ”¯
     #+begin_src js
       else if (s.startsWith("<![CDATA[")) {
         if (ns !== Namespaces.HTML) {
           node = parseCDATA(context, ancestors);
         } else {
           emitError(context, ErrorCodes.CDATA_IN_HTML_CONTENT);
           node = parseBogusComment(context);
         }
       }
     #+end_src
